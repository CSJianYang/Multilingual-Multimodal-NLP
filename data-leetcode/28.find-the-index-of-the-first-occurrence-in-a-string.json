[
    {
        "title": "Find the Index of the First Occurrence in a String",
        "question_content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n&nbsp;\nExample 1:\n\nInput: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\nExample 2:\n\nInput: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1\nExplanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n\n&nbsp;\nConstraints:\n\n\t1 <= haystack.length, needle.length <= 104\n\thaystack and needle consist of only lowercase English characters.",
        "solutions": [
            {
                "id": 12807,
                "title": "elegant-java-solution",
                "content": "    public int strStr(String haystack, String needle) {\\n      for (int i = 0; ; i++) {\\n        for (int j = 0; ; j++) {\\n          if (j == needle.length()) return i;\\n          if (i + j == haystack.length()) return -1;\\n          if (needle.charAt(j) != haystack.charAt(i + j)) break;\\n        }\\n      }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int strStr(String haystack, String needle) {\\n      for (int i = 0; ; i++) {\\n        for (int j = 0; ; j++) {\\n          if (j == needle.length()) return i;\\n          if (i + j == haystack.length()) return -1;\\n          if (needle.charAt(j) != haystack.charAt(i + j)) break;\\n        }\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 12956,
                "title": "c-brute-force-and-kmp",
                "content": "Traverse all the possible starting points of `haystack` (from `0` to `haystack.length() - needle.length()`) and see if the following characters in `haystack` match those of `needle`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe following is another implementation, shorter but harder to understand.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size(), p = 0;\\n        while (p + n - 1 < m) {\\n            if (haystack.substr(p, n) == needle) {\\n                return p;\\n            }\\n            while (p++ + n - 1 < m && haystack[p] != needle[0]);\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nFinally comes the KMP algorithm. You may refer to [KMP on jBoxer\\'s blog](http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/) and [KMP on geeksforgeeks](http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/) for some explanations. I rewrote the code from the second link.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        if (!n) {\\n            return 0;\\n        }\\n        vector<int> lps = kmpProcess(needle);\\n        for (int i = 0, j = 0; i < m;) {\\n            if (haystack[i] == needle[j]) { \\n                i++, j++;\\n            }\\n            if (j == n) {\\n                return i - j;\\n            }\\n            if (i < m && haystack[i] != needle[j]) {\\n                j ? j = lps[j - 1] : i++;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    vector<int> kmpProcess(string needle) {\\n        int n = needle.size();\\n        vector<int> lps(n, 0);\\n        for (int i = 1, len = 0; i < n;) {\\n            if (needle[i] == needle[len]) {\\n                lps[i++] = ++len;\\n            } else if (len) {\\n                len = lps[len - 1];\\n            } else {\\n                lps[i++] = 0;\\n            }\\n        }\\n        return lps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size(), p = 0;\\n        while (p + n - 1 < m) {\\n            if (haystack.substr(p, n) == needle) {\\n                return p;\\n            }\\n            while (p++ + n - 1 < m && haystack[p] != needle[0]);\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        if (!n) {\\n            return 0;\\n        }\\n        vector<int> lps = kmpProcess(needle);\\n        for (int i = 0, j = 0; i < m;) {\\n            if (haystack[i] == needle[j]) { \\n                i++, j++;\\n            }\\n            if (j == n) {\\n                return i - j;\\n            }\\n            if (i < m && haystack[i] != needle[j]) {\\n                j ? j = lps[j - 1] : i++;\\n            }\\n        }\\n        return -1;\\n    }\\nprivate:\\n    vector<int> kmpProcess(string needle) {\\n        int n = needle.size();\\n        vector<int> lps(n, 0);\\n        for (int i = 1, len = 0; i < n;) {\\n            if (needle[i] == needle[len]) {\\n                lps[i++] = ++len;\\n            } else if (len) {\\n                len = lps[len - 1];\\n            } else {\\n                lps[i++] = 0;\\n            }\\n        }\\n        return lps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249783,
                "title": "java-easy-with-explanation",
                "content": "**If we observe a bit the number of substrings of size needle length is length of haystack minus length of needle+1 so using two pointer we just used a for loop till (length of haystack-length of needle) and then checked if the character in needle is equal to character of haystack. If its equal we just kept on incrementing j. If the j is equal to needle length then we found our first substring that is equal to needle and we return the index of first character of that substring. If we dont find the substring in the haystack then we simply return -1.**\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int haylength=haystack.length();\\n        int needlelength=needle.length();\\n        if(haylength<needlelength)\\n            return -1;\\n        for(int i=0;i<=haystack.length()-needle.length();i++){\\n            int j=0;\\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\\n                j++;\\n            if(j==needle.length()){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/f9e51783-3660-4252-933c-ec2c42b2d57d_1677809905.0379472.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int haylength=haystack.length();\\n        int needlelength=needle.length();\\n        if(haylength<needlelength)\\n            return -1;\\n        for(int i=0;i<=haystack.length()-needle.length();i++){\\n            int j=0;\\n            while(j<needle.length() && haystack.charAt(i+j)==needle.charAt(j))\\n                j++;\\n            if(j==needle.length()){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250360,
                "title": "think-as-a-sliding-window-code-like-a-pro-beats-100",
                "content": "# Approach\\n**I can solve it using substrings. But can I do it without using substrings? Just by iterating the loop manually?**\\nThis thinking introduced me to use some kind of sliding window approach.\\nWhen, the characters are equal, increase the window. When they are not, reinitialize the window from the immediate next index of the previous window\\'s start.\\n\\n`haystack = \"mississippi\", needle = \"issip\"`\\n\\nThe window matching will start from first \"i\". Then it will proceed.\\nMatching:\\n```\\n-> m\\n-> i\\nnot match, reinitialize window start to next index of m. \\nThat is \"i\" from the word \"mississipi\"\\n\\n-> i s s i s\\n-> i s s i p\\ns and p mismatch\\n\\nso, reinitialize the window\\'s start\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> i s s i p\\n-> i s s i p\\nthis time it was a match!\\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*M)$$\\nN is the length of haystack, M is the length of needle. In worst case, the `haystack.charAt(i)==needle.charAt(nIndex)` comparison runs for **M-1** times. Where the last character of the **needle** mismatch.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nWell, guess what! We haven\\'t performed `substring.equals()` or any other operation. The space complexity is really good in a sense.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n\\n``` java []\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack.charAt(i)==needle.charAt(nIndex)){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack[i]==needle[nIndex]){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/80f4636f-20d1-49a8-9ae1-06e036003183_1677820370.907445.png)\\n\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/e9d15172-c989-4baa-b2e0-d92379f925b5_1677818866.229168.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n-> m\\n-> i\\nnot match, reinitialize window start to next index of m. \\nThat is \"i\" from the word \"mississipi\"\\n\\n-> i s s i s\\n-> i s s i p\\ns and p mismatch\\n\\nso, reinitialize the window\\'s start\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> s\\n-> i\\nnot match\\n\\nreinitialize\\n-> i s s i p\\n-> i s s i p\\nthis time it was a match!\\n```\n``` java []\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack.charAt(i)==needle.charAt(nIndex)){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        int nIndex = 0;\\n        for(int i=0; i<hLen; i++){\\n            // as long as the characters are equal, increment needleIndex\\n            if(haystack[i]==needle[nIndex]){\\n                nIndex++;\\n            }\\n            else{\\n                // start from the next index of previous start index\\n                i=i-nIndex;\\n                // needle should start from index 0\\n                nIndex=0;\\n            }\\n            // check if needleIndex reached needle length\\n            if(nIndex==nLen){\\n                // return the first index\\n                return i-nLen+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12814,
                "title": "my-answer-by-python",
                "content": "    class Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(haystack) - len(needle)+1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(haystack) - len(needle)+1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 12811,
                "title": "share-my-accepted-java-solution",
                "content": "    public class Solution {\\n        public int strStr(String haystack, String needle) {\\n            int l1 = haystack.length(), l2 = needle.length();\\n            if (l1 < l2) {\\n                return -1;\\n            } else if (l2 == 0) {\\n                return 0;\\n            }\\n            int threshold = l1 - l2;\\n            for (int i = 0; i <= threshold; ++i) {\\n                if (haystack.substring(i,i+l2).equals(needle)) {\\n                    return i;\\n                }\\n            }\\n            return -1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int strStr(String haystack, String needle) {\\n            int l1 = haystack.length(), l2 = needle.length();\\n            if (l1 < l2) {\\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13024,
                "title": "o-m-n-and-o-mn-solutions",
                "content": "**Solution 1: O(m+n) KMP pattern matching**\\n```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n        \\n        int[] parr = kmpPreprocess(needle);\\n        int i = 0, j = 0;\\n        while(i < haystack.length() && j < needle.length()) {\\n            if(haystack.charAt(i) == needle.charAt(j)) {\\n                i++; j++;\\n            } else if(j > 0) {\\n                j = parr[j - 1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        return j == needle.length() ? i - j : -1;\\n    }\\n\\n    private int[] kmpPreprocess(String pattern) {\\n        int i = 1, j = 0;\\n        int[] res = new int[pattern.length()];\\n        while(i < pattern.length()) {\\n            if(pattern.charAt(i) == pattern.charAt(j)) {\\n                res[i] = j+1;\\n                i++; j++;\\n            } else if (j > 0) {\\n                j = res[j-1];\\n            } else {\\n                res[i] = 0;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n* If you want to understand KMP, watch the [video](https://www.youtube.com/watch?v=GTJr8OvyEVQ).\\n\\n* KMP finds the pattern in a most efficient way. If the use cases require running multiple patterns then [Rabin Karp](https://www.youtube.com/watch?v=H4VrKHVG5qI) algorithm may be useful.\\n\\n**Solution 2: O(mn) Brute Force**\\n\\n```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n\\n        int len = haystack.length(), i = 0, j = 0, pos = 0;\\n        while(i < len && j < needle.length()) {\\n            if(haystack.charAt(i++) == needle.charAt(j)) {\\n                j++;\\n            } else {\\n                i = i - j;\\n                j = 0;\\n                pos = i;\\n            }\\n        }\\n        return j == needle.length()? pos : -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n        \\n        int[] parr = kmpPreprocess(needle);\\n        int i = 0, j = 0;\\n        while(i < haystack.length() && j < needle.length()) {\\n            if(haystack.charAt(i) == needle.charAt(j)) {\\n                i++; j++;\\n            } else if(j > 0) {\\n                j = parr[j - 1];\\n            } else {\\n                i++;\\n            }\\n        }\\n        return j == needle.length() ? i - j : -1;\\n    }\\n\\n    private int[] kmpPreprocess(String pattern) {\\n        int i = 1, j = 0;\\n        int[] res = new int[pattern.length()];\\n        while(i < pattern.length()) {\\n            if(pattern.charAt(i) == pattern.charAt(j)) {\\n                res[i] = j+1;\\n                i++; j++;\\n            } else if (j > 0) {\\n                j = res[j-1];\\n            } else {\\n                res[i] = 0;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n public int strStr(String haystack, String needle) {\\n        if(haystack == null || needle == null || needle.length() > haystack.length()) return -1;\\n\\n        int len = haystack.length(), i = 0, j = 0, pos = 0;\\n        while(i < len && j < needle.length()) {\\n            if(haystack.charAt(i++) == needle.charAt(j)) {\\n                j++;\\n            } else {\\n                i = i - j;\\n                j = 0;\\n                pos = i;\\n            }\\n        }\\n        return j == needle.length()? pos : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535326,
                "title": "java-python-kmp-solution-o-m-n-clean-code",
                "content": "**Compute KMP Table:** LPS which is Longest Prefix also Suffix\\nExample 1:\\n![image.png](https://assets.leetcode.com/users/images/971cb45f-661e-43b3-a55c-209f465baff9_1689541412.9111822.png)\\n\\n\\nExample 2:\\n![image](https://assets.leetcode.com/users/images/cae657d7-9566-43e2-9ebd-dc45fad3864e_1624351502.9443958.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/MYVTzF4h/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(m+n)`, where `m` is needle.length, `n` is haystack.length\\n- Space: `O(m)`\\n\\nMore detail about KMP: https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm",
                "solutionTags": [
                    "String Matching"
                ],
                "code": "**Compute KMP Table:** LPS which is Longest Prefix also Suffix\\nExample 1:\\n![image.png](https://assets.leetcode.com/users/images/971cb45f-661e-43b3-a55c-209f465baff9_1689541412.9111822.png)\\n\\n\\nExample 2:\\n![image](https://assets.leetcode.com/users/images/cae657d7-9566-43e2-9ebd-dc45fad3864e_1624351502.9443958.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/MYVTzF4h/shared\" frameBorder=\"0\" width=\"100%\" height=\"550\"></iframe>\\n\\nComplexity:\\n- Time: `O(m+n)`, where `m` is needle.length, `n` is haystack.length\\n- Space: `O(m)`\\n\\nMore detail about KMP: https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm",
                "codeTag": "Unknown"
            },
            {
                "id": 590911,
                "title": "javascript-solution-no-built-in-methods",
                "content": "I think the point of this exercise is to write your own algorithm without using any built-in methods. \\nThis is my take. The runtime is 52 ms (faster than 86.06%), and the memory usage is 35 MB (less than 57.14%).\\nIn contrast, ```return haystack.indexOf(needle);``` is faster than 86% and memory usage is less than 75%.\\n\\n```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\' || needle === haystack) return 0;    // the only mandatory check here is (needle === \\'\\')\\n  if (haystack.length < needle.length) return -1;        // the other ones are for efficiency\\n  \\n  for (let i = 0; i < haystack.length - needle.length + 1; i++) {    // start looping through haystack until the remaining substring is shorter than needle\\n    if (haystack[i] === needle[0]) {                // as soon as we see a character that matches the first character of needle\\n      for (let j = 0; j < needle.length; j++) {     // start looping through both needle and haystack\\n        if (needle[j] !== haystack[i + j]) {        // as soon as the characters don\\'t match\\n          break;                                    // break out of the loop and return to looping through haystack\\n        } else if (j === needle.length - 1){        // otherwise, if we looped through the entire needle and all of the characters matched\\n          return i;                                 // return the index of the first character of haystack with which we started the loop\\n        }\\n      }\\n    }\\n  }\\n  \\n  return -1;                                        // return -1 if there wasn\\'t a match\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```return haystack.indexOf(needle);```\n```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\' || needle === haystack) return 0;    // the only mandatory check here is (needle === \\'\\')\\n  if (haystack.length < needle.length) return -1;        // the other ones are for efficiency\\n  \\n  for (let i = 0; i < haystack.length - needle.length + 1; i++) {    // start looping through haystack until the remaining substring is shorter than needle\\n    if (haystack[i] === needle[0]) {                // as soon as we see a character that matches the first character of needle\\n      for (let j = 0; j < needle.length; j++) {     // start looping through both needle and haystack\\n        if (needle[j] !== haystack[i + j]) {        // as soon as the characters don\\'t match\\n          break;                                    // break out of the loop and return to looping through haystack\\n        } else if (j === needle.length - 1){        // otherwise, if we looped through the entire needle and all of the characters matched\\n          return i;                                 // return the index of the first character of haystack with which we started the loop\\n        }\\n      }\\n    }\\n  }\\n  \\n  return -1;                                        // return -1 if there wasn\\'t a match\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12931,
                "title": "a-very-clean-solution-brute-force",
                "content": "    int strStr(char *haystack, char *needle) {\\n            if (!haystack || !needle) return -1;\\n            for (int i = 0; ; ++i) {\\n                for (int j = 0; ; ++j) {\\n                    if (needle[j] == 0) return i;\\n                    if (haystack[i + j] == 0) return -1;\\n                    if (haystack[i + j] != needle[j]) break;\\n                }\\n            }\\n        }",
                "solutionTags": [],
                "code": "    int strStr(char *haystack, char *needle) {\\n            if (!haystack || !needle) return -1;\\n            for (int i = 0; ; ++i) {\\n                for (int j = 0; ; ++j) {\\n                    if (needle[j] == 0) return i;\\n                    if (haystack[i + j] == 0) return -1;\\n                    if (haystack[i + j] != needle[j]) break;\\n                }\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 13255,
                "title": "python-56-ms-time-o-n-m-space-o-1",
                "content": "Do we need to really use KMP in the interview? I just had a few interviews but personally I really can not remember those fantastic algorithms in that short period of time in pressure. Maybe I was nervous and needed more programming practice..\\n\\n\\n    def strStr(self, haystack, needle):\\n        if needle == \"\":\\n            return 0\\n        for i in range(len(haystack)-len(needle)+1):\\n            for j in range(len(needle)):\\n                if haystack[i+j] != needle[j]:\\n                    break\\n                if j == len(needle)-1:\\n                    return i\\n        return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "Do we need to really use KMP in the interview? I just had a few interviews but personally I really can not remember those fantastic algorithms in that short period of time in pressure. Maybe I was nervous and needed more programming practice..\\n\\n\\n    def strStr(self, haystack, needle):\\n        if needle == \"\":\\n            return 0\\n        for i in range(len(haystack)-len(needle)+1):\\n            for j in range(len(needle)):\\n                if haystack[i+j] != needle[j]:\\n                    break\\n                if j == len(needle)-1:\\n                    return i\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 12883,
                "title": "kmp-in-c-explanation-included",
                "content": "    int strStr(string haystack, string needle) {\\n            int nsize = needle.size();\\n        \\tint hsize = haystack.size();\\n        \\tif (nsize == 0) return 0;\\n        \\tint *table = new int[nsize];\\n        \\tmemset(table, 0, sizeof(int)*nsize);\\n        \\t//building match table\\n        \\tfor (int i = 1, j = 0; i < nsize - 1;){\\n        \\t\\tif (needle[i] != needle[j]){\\n        \\t\\t\\tif (j>0){\\n        \\t\\t\\t\\tj = table[j - 1];\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\ttable[i] = j + 1;\\n        \\t\\t\\ti++;\\n        \\t\\t\\tj++;\\n        \\t\\t}\\n        \\t}\\n        \\t//matching\\n        \\tfor (int i = 0, match_pos = 0; i < hsize;){\\n        \\t\\tif (haystack[i] == needle[match_pos]){\\n        \\t\\t\\tif (match_pos == nsize - 1){\\n        \\t\\t\\t\\treturn i - (nsize - 1);\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t\\tmatch_pos++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tif (match_pos == 0){\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\tmatch_pos = table[match_pos - 1];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tdelete[]table;\\n        \\treturn -1;\\n        }\\n\\nI'll talk about the basic idea behind KMP algorithm.\\n\\nFirst, some notations:\\n\\n - Denote the pattern string as ps and the match table as table, ps and\\n   table use 0 based index. \\n - Denote substring of ps from index i to index\\n   j (i and j included) as substr(ps,i,j). \\n - Denote string1 is the same as\\n   string2 as string1==string2\\n\\n------------------------------------------------------------------------\\n\\n\\nThe definition of my match table:\\n\\ntable[i] when i>0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i).\\n\\nOr `table[i]=max{k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k<=i}.`\\n\\nAlso, we define table[i]=0.\\n\\nSo, for string \"aba\", table={0,0,1}.\\n\\ntable[1]=0 is because no prefix equals suffix of \"ab\".\\n\\ntable[2]=1 is because prefix \"a\" equals suffix \"a\" of \"aba\".\\n\\nfor string \"abcabce\", table={0,0,0,1,2,3,0}.\\n\\ntable[4]=2 is because prefix \"ab\" equals suffix \"ab\" of \"abcab\"\\n\\ntable[5]=3 is because prefix \"abc\" equals suffix \"abc\" of \"abcabc\"\\n\\nfor string \"aabaabaaa\", table={0,1,0,1,2,3,4,5,2}.\\n\\n------------------------------------------------------------------------\\n\\n\\nHow would this match table be helpful to string matching?\\n\\nSuppose we have a target string \"abcabcdxxxxx\" and a pattern \"abcabce\".\\nIn the first round of matching, we start at first character and have\\n\\n    abcabcdxxxxx\\n    abcabce\\n\\nWe discover that 'd' and 'e' are different and string before that is the same, which is \"abcabc\".\\nif we move \"abcabce\" forward one character, we would be comparing\\n\\n    abcabcdxxxxx\\n     abcabce\\n\\nlet's focus on the parts which are same in the previous round:\\n\\n    abcabc\\n     abcabc\\n\\nwe are actually comparing the suffix of length 5 of \"abcabc\", which is \"bcabc\" and the prefix of length 5 of \"abcabc\", which is \"abcab\".\\n\\nHowever, table[5]==3 tells us the max length of suffix and prefix of \"abcabc\" which are same is 3, so suffix and prefix \\nof length 5 can't be the same. Thus, we can skip this round of comparing.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n      abcabc\\n\\nNow, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n       abcabc\\n\\nNow, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.\\nAnother property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is 'a', with the target string.\\n\\nTo sum up, when the ps(pattern string) at index i(i>0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j].",
                "solutionTags": [],
                "code": "    int strStr(string haystack, string needle) {\\n            int nsize = needle.size();\\n        \\tint hsize = haystack.size();\\n        \\tif (nsize == 0) return 0;\\n        \\tint *table = new int[nsize];\\n        \\tmemset(table, 0, sizeof(int)*nsize);\\n        \\t//building match table\\n        \\tfor (int i = 1, j = 0; i < nsize - 1;){\\n        \\t\\tif (needle[i] != needle[j]){\\n        \\t\\t\\tif (j>0){\\n        \\t\\t\\t\\tj = table[j - 1];\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\ttable[i] = j + 1;\\n        \\t\\t\\ti++;\\n        \\t\\t\\tj++;\\n        \\t\\t}\\n        \\t}\\n        \\t//matching\\n        \\tfor (int i = 0, match_pos = 0; i < hsize;){\\n        \\t\\tif (haystack[i] == needle[match_pos]){\\n        \\t\\t\\tif (match_pos == nsize - 1){\\n        \\t\\t\\t\\treturn i - (nsize - 1);\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t\\tmatch_pos++;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tif (match_pos == 0){\\n        \\t\\t\\t\\ti++;\\n        \\t\\t\\t}\\n        \\t\\t\\telse{\\n        \\t\\t\\t\\tmatch_pos = table[match_pos - 1];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tdelete[]table;\\n        \\treturn -1;\\n        }\\n\\nI'll talk about the basic idea behind KMP algorithm.\\n\\nFirst, some notations:\\n\\n - Denote the pattern string as ps and the match table as table, ps and\\n   table use 0 based index. \\n - Denote substring of ps from index i to index\\n   j (i and j included) as substr(ps,i,j). \\n - Denote string1 is the same as\\n   string2 as string1==string2\\n\\n------------------------------------------------------------------------\\n\\n\\nThe definition of my match table:\\n\\ntable[i] when i>0 means the max length of prefix of ps(0,i) which is the same as the suffix of ps(0,i).\\n\\nOr `table[i]=max{k| substr(substr(ps,0,i),0,k-1) == substr(substr(ps,0,i),i-k+1,i), k<=i}.`\\n\\nAlso, we define table[i]=0.\\n\\nSo, for string \"aba\", table={0,0,1}.\\n\\ntable[1]=0 is because no prefix equals suffix of \"ab\".\\n\\ntable[2]=1 is because prefix \"a\" equals suffix \"a\" of \"aba\".\\n\\nfor string \"abcabce\", table={0,0,0,1,2,3,0}.\\n\\ntable[4]=2 is because prefix \"ab\" equals suffix \"ab\" of \"abcab\"\\n\\ntable[5]=3 is because prefix \"abc\" equals suffix \"abc\" of \"abcabc\"\\n\\nfor string \"aabaabaaa\", table={0,1,0,1,2,3,4,5,2}.\\n\\n------------------------------------------------------------------------\\n\\n\\nHow would this match table be helpful to string matching?\\n\\nSuppose we have a target string \"abcabcdxxxxx\" and a pattern \"abcabce\".\\nIn the first round of matching, we start at first character and have\\n\\n    abcabcdxxxxx\\n    abcabce\\n\\nWe discover that 'd' and 'e' are different and string before that is the same, which is \"abcabc\".\\nif we move \"abcabce\" forward one character, we would be comparing\\n\\n    abcabcdxxxxx\\n     abcabce\\n\\nlet's focus on the parts which are same in the previous round:\\n\\n    abcabc\\n     abcabc\\n\\nwe are actually comparing the suffix of length 5 of \"abcabc\", which is \"bcabc\" and the prefix of length 5 of \"abcabc\", which is \"abcab\".\\n\\nHowever, table[5]==3 tells us the max length of suffix and prefix of \"abcabc\" which are same is 3, so suffix and prefix \\nof length 5 can't be the same. Thus, we can skip this round of comparing.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n      abcabc\\n\\nNow, we are comparing suffix and prefix of length 4, since table[5]==3, we can skip this round.\\nNext, we move \"abcabce\" forward by another one character, we would be comparing\\n\\n    abcabc\\n       abcabc\\n\\nNow, we are comparing suffix and prefix of length 3, since table[5]==3, this is valid.\\nAnother property we can use to simply the matching process is that we already know the prefix and suffix of length 3 are the same, so we can start by comparing from the 4th charater in pattern, which is 'a', with the target string.\\n\\nTo sum up, when the ps(pattern string) at index i(i>0) failed to match ts(target string) at index j, which means substr(ps,0,i-1) matches, we start by comparing ps[table[i-1]] with ts[j].",
                "codeTag": "Unknown"
            },
            {
                "id": 665448,
                "title": "ac-simply-readable-python-kmp-rabin-karp",
                "content": "```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```\\nRabin Karp, built-in hash, constant time (tested)\\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\thash_n = hash(needle)\\n\\tfor i in range(h-n+1):\\n\\t\\tif hash(haystack[i:i+n]) == hash_n:\\n\\t\\t\\treturn i\\n\\treturn -1\\n```\\nRabin Karp, numeral base for both uppercase and lowercase letters, constant time\\n```\\ndef strStr(self, haystack, needle):\\n\\tdef f(c):\\n\\t\\treturn ord(c)-ord(\\'A\\')\\n\\n\\tn, h, d, m = len(needle), len(haystack), ord(\\'z\\')-ord(\\'A\\')+1, sys.maxint \\n\\tif n > h: return -1\\n\\tnd, hash_n, hash_h = d**(n-1), 0, 0   \\n\\tfor i in range(n):\\n\\t\\thash_n = (d*hash_n+f(needle[i]))%m\\n\\t\\thash_h = (d*hash_h+f(haystack[i]))%m            \\n\\tif hash_n == hash_h: return 0        \\n\\tfor i in range(1, h-n+1):\\n\\t\\thash_h = (d*(hash_h-f(haystack[i-1])*nd)+f(haystack[i+n-1]))%m    # e.g. 10*(1234-1*10**3)+5=2345\\n\\t\\tif hash_n == hash_h: return i\\n\\treturn -1\\n```\\nKMP\\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\ti, j, nxt = 1, 0, [-1]+[0]*n\\n\\twhile i < n:                                # calculate next array\\n\\t\\tif j == -1 or needle[i] == needle[j]:   \\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\t\\tnxt[i] = j\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\ti = j = 0\\n\\twhile i < h and j < n:\\n\\t\\tif j == -1 or haystack[i] == needle[j]:\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\treturn i-j if j == n else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\thash_n = hash(needle)\\n\\tfor i in range(h-n+1):\\n\\t\\tif hash(haystack[i:i+n]) == hash_n:\\n\\t\\t\\treturn i\\n\\treturn -1\\n```\n```\\ndef strStr(self, haystack, needle):\\n\\tdef f(c):\\n\\t\\treturn ord(c)-ord(\\'A\\')\\n\\n\\tn, h, d, m = len(needle), len(haystack), ord(\\'z\\')-ord(\\'A\\')+1, sys.maxint \\n\\tif n > h: return -1\\n\\tnd, hash_n, hash_h = d**(n-1), 0, 0   \\n\\tfor i in range(n):\\n\\t\\thash_n = (d*hash_n+f(needle[i]))%m\\n\\t\\thash_h = (d*hash_h+f(haystack[i]))%m            \\n\\tif hash_n == hash_h: return 0        \\n\\tfor i in range(1, h-n+1):\\n\\t\\thash_h = (d*(hash_h-f(haystack[i-1])*nd)+f(haystack[i+n-1]))%m    # e.g. 10*(1234-1*10**3)+5=2345\\n\\t\\tif hash_n == hash_h: return i\\n\\treturn -1\\n```\n```\\ndef strStr(self, haystack, needle):\\n\\tn, h = len(needle), len(haystack)\\n\\ti, j, nxt = 1, 0, [-1]+[0]*n\\n\\twhile i < n:                                # calculate next array\\n\\t\\tif j == -1 or needle[i] == needle[j]:   \\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\t\\tnxt[i] = j\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\ti = j = 0\\n\\twhile i < h and j < n:\\n\\t\\tif j == -1 or haystack[i] == needle[j]:\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\tj = nxt[j]\\n\\treturn i-j if j == n else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 242103,
                "title": "100-time-python-solution",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def strStr(self, haystack: \\'str\\', needle: \\'str\\') -> \\'int\\':\\n           \\n        for i in range(0, len(haystack) - len(needle) + 1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        \\n        return -1\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def strStr(self, haystack: \\'str\\', needle: \\'str\\') -> \\'int\\':\\n           \\n        for i in range(0, len(haystack) - len(needle) + 1):\\n            if haystack[i:i+len(needle)] == needle:\\n                return i\\n        \\n        return -1\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 12886,
                "title": "accepted-kmp-solution-in-java-for-reference",
                "content": "\\n    public String strStr(String haystack, String needle) {\\n    \\t//KMP algorithms\\n    \\tif(needle.equals(\"\")) return haystack;\\n    \\tif(haystack.equals(\"\")) return null;\\n    \\tchar[] arr = needle.toCharArray();\\n    \\tint[] next = makeNext(arr);\\n\\n    \\tfor(int i = 0, j = 0, end = haystack.length(); i < end;){\\n    \\t\\tif(j == -1 || haystack.charAt(i) == arr[j]){\\n    \\t\\t\\tj++;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tif(j == arr.length) return haystack.substring(i - arr.length);\\n    \\t\\t}\\n    \\t\\tif(i < end && haystack.charAt(i) != arr[j]) j = next[j];\\n    \\t}\\n        return null;\\n    }\\n\\n    private int[] makeNext(char[] arr){\\n    \\tint len = arr.length;\\n    \\tint[] next = new int[len];\\n\\n    \\tnext[0] = -1;\\n    \\tfor(int i = 0, j = -1; i + 1 < len;){\\n    \\t\\tif(j == -1 || arr[i] == arr[j]){\\n    \\t\\t\\tnext[i+1] = j+1;\\n    \\t\\t\\tif(arr[i+1] == arr[j+1]) next[i+1] = next[j+1];\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj++;\\n    \\t\\t}\\n    \\t\\tif(arr[i] != arr[j]) j = next[j];\\n    \\t}\\n\\n    \\treturn next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public String strStr(String haystack, String needle) {\\n    \\t//KMP algorithms\\n    \\tif(needle.equals(\"\")) return haystack;\\n    \\tif(haystack.equals(\"\")) return null;\\n    \\tchar[] arr = needle.toCharArray();\\n    \\tint[] next = makeNext(arr);\\n\\n    \\tfor(int i = 0, j = 0, end = haystack.length(); i < end;){\\n    \\t\\tif(j == -1 || haystack.charAt(i) == arr[j]){\\n    \\t\\t\\tj++;\\n    \\t\\t\\ti++;\\n    \\t\\t\\tif(j == arr.length) return haystack.substring(i - arr.length);\\n    \\t\\t}\\n    \\t\\tif(i < end && haystack.charAt(i) != arr[j]) j = next[j];\\n    \\t}\\n        return null;\\n    }\\n\\n    private int[] makeNext(char[] arr){\\n    \\tint len = arr.length;\\n    \\tint[] next = new int[len];\\n\\n    \\tnext[0] = -1;\\n    \\tfor(int i = 0, j = -1; i + 1 < len;){\\n    \\t\\tif(j == -1 || arr[i] == arr[j]){\\n    \\t\\t\\tnext[i+1] = j+1;\\n    \\t\\t\\tif(arr[i+1] == arr[j+1]) next[i+1] = next[j+1];\\n    \\t\\t\\ti++;\\n    \\t\\t\\tj++;\\n    \\t\\t}\\n    \\t\\tif(arr[i] != arr[j]) j = next[j];\\n    \\t}\\n\\n    \\treturn next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13160,
                "title": "detailed-explanation-on-building-up-lps-for-kmp-algorithm",
                "content": "At first special thanks to @jianchao.li.fighter's introduction to KMP algorithm and 2 helpful links in his answer to this problem. Here is his answer: [https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution][1] and below are the 2 links to refer to. \\n\\n 1. [http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/][2]\\n 2. [http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/][3]\\n\\n**For those who don't know what KMP is please read the content in the 2 links first**. And here I just add some detailed supplementary comments on how to build up the lps[] based on the original code and comments from the 2nd link. Hope this will help those who are still confused how the lps[] is built (especially for the tricky part) after read the content in the 2 links above.\\n\\n    void computeLPSArray(char *pat, int M, int *lps)\\n      {\\n          int len = 0;  // lenght of the previous longest prefix suffix\\n          int i;\\n    \\n          lps[0] = 0; // lps[0] is always 0\\n          i = 1;\\n    \\n          // the loop calculates lps[i] for i = 1 to M-1\\n          while (i < M)\\n          {\\n             //example \"abababca\" and i==5, len==3. The longest prefix suffix is \"aba\", when pat[i]==pat[len],\\n             //we get new prefix \"abab\" and new suffix \"abab\", so increase length of  current lps by 1 and go to next iteration. \\n             if (pat[i] == pat[len])\\n             {\\n               len++;\\n               lps[i] = len;\\n               i++;\\n             }\\n             else // (pat[i] != pat[len])\\n             {\\n               if (len != 0)\\n               {\\n                 len = lps[len-1];\\n                 //This is tricky. Consider the example \"ababe......ababc\", i is index of 'c', len==4. The longest prefix suffix is \"abab\",\\n                 //when pat[i]!=pat[len], we get new prefix \"ababe\" and suffix \"ababc\", which are not equal. \\n                 //This means we can't increment length of lps based on current lps \"abab\" with len==4. We may want to increment it based on\\n                 //the longest prefix suffix with length < len==4, which by definition is lps of \"abab\". So we set len to lps[len-1],\\n                 //which is 2, now the lps is \"ab\". Then check pat[i]==pat[len] again due to the while loop, which is also the reason\\n                 //why we do not increment i here. The iteration of i terminate until len==0 (didn't find lps ends with pat[i]) or found\\n                 //a lps ends with pat[i].\\n               }\\n               else // if (len == 0)\\n               { // there isn't any lps ends with pat[i], so set lps[i] = 0 and go to next iteration.\\n                 lps[i] = 0;\\n                 i++;\\n               }\\n             }\\n          }\\n      }  \\n\\n\\n  [1]: https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution\\n  [2]: http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/\\n  [3]: http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/",
                "solutionTags": [],
                "code": "At first special thanks to @jianchao.li.fighter's introduction to KMP algorithm and 2 helpful links in his answer to this problem. Here is his answer: [https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution][1] and below are the 2 links to refer to. \\n\\n 1. [http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/][2]\\n 2. [http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/][3]\\n\\n**For those who don't know what KMP is please read the content in the 2 links first**. And here I just add some detailed supplementary comments on how to build up the lps[] based on the original code and comments from the 2nd link. Hope this will help those who are still confused how the lps[] is built (especially for the tricky part) after read the content in the 2 links above.\\n\\n    void computeLPSArray(char *pat, int M, int *lps)\\n      {\\n          int len = 0;  // lenght of the previous longest prefix suffix\\n          int i;\\n    \\n          lps[0] = 0; // lps[0] is always 0\\n          i = 1;\\n    \\n          // the loop calculates lps[i] for i = 1 to M-1\\n          while (i < M)\\n          {\\n             //example \"abababca\" and i==5, len==3. The longest prefix suffix is \"aba\", when pat[i]==pat[len],\\n             //we get new prefix \"abab\" and new suffix \"abab\", so increase length of  current lps by 1 and go to next iteration. \\n             if (pat[i] == pat[len])\\n             {\\n               len++;\\n               lps[i] = len;\\n               i++;\\n             }\\n             else // (pat[i] != pat[len])\\n             {\\n               if (len != 0)\\n               {\\n                 len = lps[len-1];\\n                 //This is tricky. Consider the example \"ababe......ababc\", i is index of 'c', len==4. The longest prefix suffix is \"abab\",\\n                 //when pat[i]!=pat[len], we get new prefix \"ababe\" and suffix \"ababc\", which are not equal. \\n                 //This means we can't increment length of lps based on current lps \"abab\" with len==4. We may want to increment it based on\\n                 //the longest prefix suffix with length < len==4, which by definition is lps of \"abab\". So we set len to lps[len-1],\\n                 //which is 2, now the lps is \"ab\". Then check pat[i]==pat[len] again due to the while loop, which is also the reason\\n                 //why we do not increment i here. The iteration of i terminate until len==0 (didn't find lps ends with pat[i]) or found\\n                 //a lps ends with pat[i].\\n               }\\n               else // if (len == 0)\\n               { // there isn't any lps ends with pat[i], so set lps[i] = 0 and go to next iteration.\\n                 lps[i] = 0;\\n                 i++;\\n               }\\n             }\\n          }\\n      }  \\n\\n\\n  [1]: https://leetcode.com/discuss/38998/explained-4ms-easy-c-solution\\n  [2]: http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/\\n  [3]: http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/",
                "codeTag": "Unknown"
            },
            {
                "id": 3677775,
                "title": "one-line-code-using-python-tc-o-n-sc-o-1",
                "content": "# Intuition\\nThe intuition behind this approach is to use the built-in find() function in Python to find the index of the first occurrence of the needle string within the haystack string. If the needle is not found, it returns -1.\\n# Approach\\nThe approach is simple and straightforward. We can directly use the find() function on the haystack string and pass the needle string as the argument. The find() function returns the index of the first occurrence of the needle string in the haystack string, or -1 if it is not found.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe find() function has a time complexity of O(n), where n is the length of the haystack string.\\n- Space complexity:\\nThe space complexity is O(1) since no extra space is used.\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return haystack.find(needle)\\n```\\n##### reach me to discuss any problems - https://www.linkedin.com/in/naveen-kumar-g-500469210/\\n#\\n#\\n\\n![image.png](https://assets.leetcode.com/users/images/1671e9d0-2b0a-4c38-b1c3-f5a1211a9145_1687624629.314786.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return haystack.find(needle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313426,
                "title": "pattern-searching-2-pointer-approach-comments-explanation",
                "content": "```\\nint strStr(string haystack, string needle) \\n    {\\n        if(needle==\"\")\\n            return 0;\\n        \\n        int i=0,j=0;\\n        while(i<haystack.size() && j<needle.size())\\n        {\\n            if(haystack[i]==needle[j])\\n            { // when there is a match then increase both the pointers\\n                i++;\\n                j++;\\n                if(j==needle.size()) // if the whole pattern has been matched then return\\n                    return i-needle.size();  // the value by going needle size steps backwards from the current index in array\\n            }\\n            else\\n            { // when there is no match then start checking from the haystack index\\n                i=i-j+1;  // such that it goes backwards till whatever length has been matched \\n                j=0; // and checks from next index and start checking from pattern\\'s beginning\\n            }            \\n        }        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint strStr(string haystack, string needle) \\n    {\\n        if(needle==\"\")\\n            return 0;\\n        \\n        int i=0,j=0;\\n        while(i<haystack.size() && j<needle.size())\\n        {\\n            if(haystack[i]==needle[j])\\n            { // when there is a match then increase both the pointers\\n                i++;\\n                j++;\\n                if(j==needle.size()) // if the whole pattern has been matched then return\\n                    return i-needle.size();  // the value by going needle size steps backwards from the current index in array\\n            }\\n            else\\n            { // when there is no match then start checking from the haystack index\\n                i=i-j+1;  // such that it goes backwards till whatever length has been matched \\n                j=0; // and checks from next index and start checking from pattern\\'s beginning\\n            }            \\n        }        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3253654,
                "title": "javascript-php-6-solutions-with-explanation-understandable",
                "content": "# Approach\\n#### Solution #1 - Built-in function strpos()\\nUse the strpos() Built-in function to find the position of the substring in the string. If the substring is not found, return -1.\\n#### Solution #2 - Find Substring Position with Regex\\nCreate a pattern based on the needle and use preg_match() function to compare the haystack and needle and return the index position. If the substring is not found, return -1.\\n#### Solution #3 - Brute Force\\nLoop through the haystack. For each character, loop through the needle and compare. If they are all equal, return the index of the haystack\\n#### Solution #4 - Brute Force Substring Search\\nCreate a loop to iterate through the haystack and compare the substrings of the haystack and needle using the substr() function. Return the index position of the needle or -1 if not found.\\n#### Solution #5 - Tracking Loop Search - Time: O(N), Space: O(1)\\nLoop through the haystack string and compare each character of the substring to the corresponding character in the haystack. If all characters match, the index is returned. If the substring is not found, return -1.\\n#### Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\nPreprocess the needle to form an array to store the occurs before.\\nLoop through the haystack and compare with needle. If mismatch occurs, move the haystack index by the occurs before array. \\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n\\n# Solution #1 - Built-in function\\n```javascript []\\n/**\\n * Solution #1 - Built-in function\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution 1 - Built-in function strpos()\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pos = strpos($haystack, $needle);\\n        return $pos === false ? -1 : $pos;\\n    }\\n}\\n```\\n# Solution #2 - Find Position with Regex\\n```javascript []\\n/**\\n * Solution #2 - RegExp\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const regex = new RegExp(needle);\\n    return haystack.search(regex);\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #2 - Regular Expression\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pattern = \\'/\\' . $needle . \\'/\\';\\n        $result = preg_match($pattern, $haystack, $matches, PREG_OFFSET_CAPTURE);\\n        return $result ? $matches[0][1] : -1;\\n    }\\n}\\n```\\n\\n\\n\\n\\n# Solution #3 - Brute Force Time: O(N*M)\\n```javascript []\\n/**\\n * Solution #3 - Brute Force - Time: O(N*M), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    if (!needle) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let isMatch = true;\\n        for (let j = 0; j < needle.length; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                isMatch = false;\\n                break;\\n            }\\n        }\\n        if (isMatch) return i;\\n    }\\n    return -1;\\n};\\n```\\n\\n\\n# Solution #4 - Loop through haystack and compare substrings\\n```javascript []\\n/**\\n * Solution #4 - Loop through haystack and compare substrings - Time: O(N), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    for (let i = 0; i <= haystackLength - needleLength; i++) {\\n        if (haystack.substr(i, needleLength) === needle) return i;\\n    }\\n    return -1;\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #4 - Loop through haystack and compare substrings\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        for ($i = 0; $i <= $haystackLength - $needleLength; $i++) {\\n            if (substr($haystack, $i, $needleLength) == $needle) return $i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n\\n\\n# Solution #5 - Tracking Loop Search\\n```javascript []\\n/**\\n * Solution #5 - Loop through haystack and compare characters one by one - Time: O(N), Space: O(1)\\n * Loop through the haystack string and compare each character of the substring to the corresponding character in the haystack. If all characters match, the index is returned. If the substring is not found, return -1.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    let matchingIndex = 0;\\n    for (let i = 0; i < haystackLength; i++) {\\n        if (needle[i - matchingIndex] !== haystack[i]) {\\n            i = matchingIndex;\\n            matchingIndex = i + 1;\\n        } else if (i - matchingIndex == needleLength - 1) {\\n            return matchingIndex;\\n        }\\n    }\\n    return -1;\\n};\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #5 - Loop through haystack and compare characters one by one - no substr or strpos used\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        $matchingIndex = 0;\\n        for ($i = 0; $i < $haystackLength; $i++) {\\n            if ($needle[$i - $matchingIndex] != $haystack[$i]) {\\n                $i = $matchingIndex;\\n                $matchingIndex = $i + 1;\\n            } elseif (($i - $matchingIndex) == ($needleLength - 1)) {\\n                return $matchingIndex;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\n\\n```javascript []\\n/**\\n * Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\n * Preprocess the needle to form an array to store the occurs before.\\n * Loop through the haystack and compare with needle.\\n * If mismatch occurs, move the haystack index by the occurs before array.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const needleLength = needle.length;\\n    let i = 0, j = -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    const lps = [-1];\\n    while (i < needleLength - 1) {\\n        if (j === -1 || needle[i] === needle[j]) {\\n            i++;\\n            j++;\\n            lps[i] = j;\\n        } else {\\n            j = lps[j];\\n        }\\n    }\\n\\n    i = 0, j = 0;\\n    while (i < haystack.length && j < needleLength) {\\n        if (haystack[i] === needle[j]) {\\n            i++;\\n            j++;\\n        } else {\\n            j = lps[j];\\n            if (j < 0) {\\n                i++;\\n                j++;\\n            }\\n        }\\n    }\\n    if (j === needleLength) {\\n        return i - j;\\n    }\\n    return -1;\\n}\\n```\\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #6 -- KMP - Knuth-Morris-Pratt String Matching Algorithm\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    $haystackLength = strlen($haystack);\\n    $needleLength = strlen($needle);\\n    if ($needleLength == 0) return 0;\\n    if ($haystackLength < $needleLength) return -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    $lps = array_fill(0, $needleLength, 0);\\n    $prevLPS = 0;\\n    $i = 1;\\n    while ($i < $needleLength) {\\n        if ($needle[$i] == $needle[$prevLPS]) {\\n            $lps[$i] = $prevLPS + 1;\\n            $prevLPS++;\\n            $i++;\\n        } elseif ($prevLPS == 0) {\\n            $lps[$i] = 0;\\n            $i++;\\n        } else {\\n            $prevLPS = $lps[$prevLPS - 1];\\n        }\\n    }\\n\\n    $i = 0; // for haystack\\n    $j = 0; // for needle\\n    while ($i < $haystackLength) {\\n        if ($haystack[$i] == $needle[$j]) {\\n            $i++;\\n            $j++;\\n        } else {\\n            if ($j == 0) {\\n                $i++;\\n            } else {\\n                $j = $lps[$j - 1];\\n            }\\n        }\\n        if ($j == $needleLength) {\\n            return $i - $needleLength;\\n        }\\n    }\\n    return -1;\\n    }\\n}\\n```\\n\\n**If my work was useful for you, please upvote!**\\n\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "String",
                    "String Matching"
                ],
                "code": "```javascript []\\n/**\\n * Solution #1 - Built-in function\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution 1 - Built-in function strpos()\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pos = strpos($haystack, $needle);\\n        return $pos === false ? -1 : $pos;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #2 - RegExp\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const regex = new RegExp(needle);\\n    return haystack.search(regex);\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #2 - Regular Expression\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $pattern = \\'/\\' . $needle . \\'/\\';\\n        $result = preg_match($pattern, $haystack, $matches, PREG_OFFSET_CAPTURE);\\n        return $result ? $matches[0][1] : -1;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #3 - Brute Force - Time: O(N*M), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    if (!needle) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let isMatch = true;\\n        for (let j = 0; j < needle.length; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                isMatch = false;\\n                break;\\n            }\\n        }\\n        if (isMatch) return i;\\n    }\\n    return -1;\\n};\\n```\n```javascript []\\n/**\\n * Solution #4 - Loop through haystack and compare substrings - Time: O(N), Space: O(1)\\n * Loop through the haystack. For each character, loop through the needle and compare.\\n * If they are all equal, return the index of the haystack\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    for (let i = 0; i <= haystackLength - needleLength; i++) {\\n        if (haystack.substr(i, needleLength) === needle) return i;\\n    }\\n    return -1;\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #4 - Loop through haystack and compare substrings\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        for ($i = 0; $i <= $haystackLength - $needleLength; $i++) {\\n            if (substr($haystack, $i, $needleLength) == $needle) return $i;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #5 - Loop through haystack and compare characters one by one - Time: O(N), Space: O(1)\\n * Loop through the haystack string and compare each character of the substring to the corresponding character in the haystack. If all characters match, the index is returned. If the substring is not found, return -1.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    let haystackLength = haystack.length;\\n    let needleLength = needle.length;\\n    if (haystackLength < needleLength) return -1;\\n\\n    let matchingIndex = 0;\\n    for (let i = 0; i < haystackLength; i++) {\\n        if (needle[i - matchingIndex] !== haystack[i]) {\\n            i = matchingIndex;\\n            matchingIndex = i + 1;\\n        } else if (i - matchingIndex == needleLength - 1) {\\n            return matchingIndex;\\n        }\\n    }\\n    return -1;\\n};\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #5 - Loop through haystack and compare characters one by one - no substr or strpos used\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr(string $haystack, string $needle): int {\\n        $haystackLength = strlen($haystack);\\n        $needleLength = strlen($needle);\\n        if ($haystackLength < $needleLength) return -1;\\n\\n        $matchingIndex = 0;\\n        for ($i = 0; $i < $haystackLength; $i++) {\\n            if ($needle[$i - $matchingIndex] != $haystack[$i]) {\\n                $i = $matchingIndex;\\n                $matchingIndex = $i + 1;\\n            } elseif (($i - $matchingIndex) == ($needleLength - 1)) {\\n                return $matchingIndex;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Solution #6 - KMP - Time: O(N+M) | KMP - Knuth-Morris-Pratt String Matching Algorithm\\n * Preprocess the needle to form an array to store the occurs before.\\n * Loop through the haystack and compare with needle.\\n * If mismatch occurs, move the haystack index by the occurs before array.\\n *\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function (haystack, needle) {\\n    const needleLength = needle.length;\\n    let i = 0, j = -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    const lps = [-1];\\n    while (i < needleLength - 1) {\\n        if (j === -1 || needle[i] === needle[j]) {\\n            i++;\\n            j++;\\n            lps[i] = j;\\n        } else {\\n            j = lps[j];\\n        }\\n    }\\n\\n    i = 0, j = 0;\\n    while (i < haystack.length && j < needleLength) {\\n        if (haystack[i] === needle[j]) {\\n            i++;\\n            j++;\\n        } else {\\n            j = lps[j];\\n            if (j < 0) {\\n                i++;\\n                j++;\\n            }\\n        }\\n    }\\n    if (j === needleLength) {\\n        return i - j;\\n    }\\n    return -1;\\n}\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * Solution #6 -- KMP - Knuth-Morris-Pratt String Matching Algorithm\\n     * \\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    $haystackLength = strlen($haystack);\\n    $needleLength = strlen($needle);\\n    if ($needleLength == 0) return 0;\\n    if ($haystackLength < $needleLength) return -1;\\n\\n    // LPS - Longest Prefix Suffix / Prefix table \\n    $lps = array_fill(0, $needleLength, 0);\\n    $prevLPS = 0;\\n    $i = 1;\\n    while ($i < $needleLength) {\\n        if ($needle[$i] == $needle[$prevLPS]) {\\n            $lps[$i] = $prevLPS + 1;\\n            $prevLPS++;\\n            $i++;\\n        } elseif ($prevLPS == 0) {\\n            $lps[$i] = 0;\\n            $i++;\\n        } else {\\n            $prevLPS = $lps[$prevLPS - 1];\\n        }\\n    }\\n\\n    $i = 0; // for haystack\\n    $j = 0; // for needle\\n    while ($i < $haystackLength) {\\n        if ($haystack[$i] == $needle[$j]) {\\n            $i++;\\n            $j++;\\n        } else {\\n            if ($j == 0) {\\n                $i++;\\n            } else {\\n                $j = $lps[$j - 1];\\n            }\\n        }\\n        if ($j == $needleLength) {\\n            return $i - $needleLength;\\n        }\\n    }\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12952,
                "title": "java-easy-to-understand-solutions",
                "content": "       \\n    public int strStr1(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n    \\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null)\\n            return -1;\\n        int l1 = haystack.length();\\n        int l2 = needle.length();\\n        for (int i = 0; i < l1-l2+1; i++) {\\n            int count = 0;\\n            while (count < l2 && haystack.charAt(i+count) == needle.charAt(count))\\n                count++;\\n            if (count == l2)\\n                return i;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "       \\n    public int strStr1(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n    \\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null)\\n            return -1;\\n        int l1 = haystack.length();\\n        int l2 = needle.length();\\n        for (int i = 0; i < l1-l2+1; i++) {\\n            int count = 0;\\n            while (count < l2 && haystack.charAt(i+count) == needle.charAt(count))\\n                count++;\\n            if (count == l2)\\n                return i;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3062925,
                "title": "easy-c-solution-two-line-code-easy-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I declared a variable \\'index\\' which is initialized to the value returned by the \\'find()\\' function. The \\'find()\\' function is called on the \\'haystack\\' string and the \\'needle\\' string is passed as an argument.\\n2. The \\'find()\\' function returns the index of the first occurrence of the \\'needle\\' string within the \\'haystack\\' string. If the \\'needle\\' string is not found within the \\'haystack\\' string, the function returns a special constant \\'string::npos\\'.\\n3. If \\'index\\' is not equal to \\'string::npos\\', it means that the \\'needle\\' is found, so the \\'index\\' is returned.\\n4. Else, -1 is returned, indicating that the \\'needle\\' is not found in the \\'haystack\\' string.\\n5. The \\'strStr()\\' function returns the index of the first occurrence of the \\'needle\\' string within the \\'haystack\\' string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n) where n is the length of the haystack string. This is because the find function in the C++ STL library has an average time complexity of O(n).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) as it only uses a constant amount of additional memory.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int index = haystack.find(needle);\\n        if(index != string::npos) return index;\\n        else return -1;\\n    }\\n};\\n```\\n\\n\\n\\n![Your paragraph text (1).png](https://assets.leetcode.com/users/images/ba810d33-7b2b-42d1-a6d4-b61e9f4d670c_1673947392.3588023.png)\\n",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int index = haystack.find(needle);\\n        if(index != string::npos) return index;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971852,
                "title": "python",
                "content": "Python, faster than 99.7%\\n\\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        nl, ml = len(needle), len(haystack)\\n        if nl == 0:\\n            return nl\\n        if ml < nl:\\n            return -1\\n        for i in range(ml - nl + 1):\\n            if haystack[i:i+nl] == needle:\\n                return i\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        nl, ml = len(needle), len(haystack)\\n        if nl == 0:\\n            return nl\\n        if ml < nl:\\n            return -1\\n        for i in range(ml - nl + 1):\\n            if haystack[i:i+nl] == needle:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724335,
                "title": "0ms-100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287974,
                "title": "go-0-ms-100-00-easy-code-3-ways",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 1. Fast Code\\n```golang\\nfunc strStr(haystack string, needle string) int {\\n\\tif needle == \"\" {\\n\\t\\treturn 0\\n\\t}\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\\n\\n# 2. Sample Code\\n\\n```golang\\nfunc strStrSample(haystack string, needle string) int {\\n\\treturn strings.Index(haystack, needle)\\n}\\n```\\n\\n# 3. Optimization Code\\n```golang\\nfunc strStrOptimize(haystack string, needle string) int {\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tswitch {\\n\\tcase n == 0:\\n\\t\\treturn 0\\n\\tcase n == 1:\\n\\t\\tfor i := 0; i < h; i++ {\\n\\t\\t\\tif string(haystack[i]) == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n == h:\\n\\t\\tif haystack == needle {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n > h:\\n\\t\\treturn -1\\n\\tdefault:\\n\\t\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc strStr(haystack string, needle string) int {\\n\\tif needle == \"\" {\\n\\t\\treturn 0\\n\\t}\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\treturn i\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\n```golang\\nfunc strStrSample(haystack string, needle string) int {\\n\\treturn strings.Index(haystack, needle)\\n}\\n```\n```golang\\nfunc strStrOptimize(haystack string, needle string) int {\\n\\th := len(haystack)\\n\\tn := len(needle)\\n\\tswitch {\\n\\tcase n == 0:\\n\\t\\treturn 0\\n\\tcase n == 1:\\n\\t\\tfor i := 0; i < h; i++ {\\n\\t\\t\\tif string(haystack[i]) == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n == h:\\n\\t\\tif haystack == needle {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\treturn -1\\n\\tcase n > h:\\n\\t\\treturn -1\\n\\tdefault:\\n\\t\\tfor i := 0; i < h-n+1; i++ {\\n\\t\\t\\tif haystack[i:i+n] == needle {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216780,
                "title": "easy-95-47-faster-using-built-in-method",
                "content": "``` \\nvar strStr = function(haystack, needle) {\\n    if(!needle.length) return 0;\\n    if(!haystack.includes(needle)) return -1;\\n    return haystack.split(`${needle}`)[0].length;\\n};\\n```\\nFirst two lines use base cases, last line works as follows\\n\\n\\'dinosaur\\', \\'saur\\'\\n\\n\\'dinosaur\\'.split(\\'saur\\') returns [\\'dino\\']\\n\\nIndex 0 will always occur right before the first instance of the needle.\\n\\nReturning the length will provide us with the proper index of the first occurance since arrays and strings are 0 indexed.\\n\\nAnother example with repeated needles\\n\\n\\'bonobonobono\\', \\'ono\\'\\n\\'bonobonobono\\'.split(\\'ono\\') returns [\\'b\\',\\'b\\',\\'b\\']\\n[\\'b\\',\\'b\\',\\'b\\'][0].length returns index of 1",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` \\nvar strStr = function(haystack, needle) {\\n    if(!needle.length) return 0;\\n    if(!haystack.includes(needle)) return -1;\\n    return haystack.split(`${needle}`)[0].length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 791914,
                "title": "simple-python-solution-using-split",
                "content": "def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle) == 0:\\n            return 0\\n        elif needle not in haystack:\\n            return -1\\n        else:\\n            return len(haystack.split(needle)[0])\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle) == 0:\\n            return 0\\n        elif needle not in haystack:\\n            return -1\\n        else:\\n            return len(haystack.split(needle)[0])\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3968304,
                "title": "java-runtime-0-ms-beats-100-00",
                "content": "# Intuition\\nMy approach to solving the problem involves implementing a simple string search algorithm, specifically a brute force method, to find the first occurrence of the \\'needle\\' string within the \\'haystack\\' string.\\n\\n# Approach\\nI will use a brute force approach to search for the \\'needle\\' string within the \\'haystack\\' string. The algorithm iterates through the \\'haystack\\' string, checking at each position if a substring of the same length as the \\'needle\\' matches the \\'needle\\' string. It does so by comparing the characters of the \\'haystack\\' substring with the corresponding characters of the \\'needle\\' string. If a match is found, the index of the starting position of the match is returned. If no match is found after iterating through the entire \\'haystack\\', -1 is returned.\\n\\nTo optimize the algorithm, if the remaining length of the \\'haystack\\' string is less than the length of the \\'needle\\', it is concluded that no match can be found. In this case, the loop terminates.\\n\\n\\n**!! For relatively small data sets, the chosen brute force approach is appropriate and straightforward for searching the \\'needle\\' string within the \\'haystack\\'. However, it\\'s important to note that as the size of your data set increases, this approach may become less efficient in terms of both time and performance. In scenarios where you are working with larger data sets, it\\'s advisable to explore more optimized string searching algorithms such as the Knuth-Morris-Pratt (KMP) or Boyer-Moore algorithms.**\\n\\n# Complexity\\n- Time complexity: O((hayLen - needleLen + 1) * needleLen)\\n  The algorithm iterates through the \\'haystack\\' string, and for each position, it performs a comparison between a substring of length \\'needleLen\\' and the \\'needle\\' string. The maximum number of iterations depends on the difference in lengths between \\'haystack\\' and \\'needle\\', and each substring comparison requires \\'needleLen\\' time.\\n\\n- Space complexity: O(1)\\n  The algorithm employs a fixed amount of additional memory space for variables, ensuring that the space complexity remains constant.\\n\\n# Code\\n```java\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hayLen = haystack.length();\\n        int needleLen = needle.length();\\n\\n        if (hayLen < needleLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hayLen - needleLen; i++) {\\n            if (haystack.charAt(i) == needle.charAt(0)) {\\n                boolean found = true;\\n                for (int j = 1; j < needleLen; j++) {\\n                    if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n                if (found) {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int hayLen = haystack.length();\\n        int needleLen = needle.length();\\n\\n        if (hayLen < needleLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hayLen - needleLen; i++) {\\n            if (haystack.charAt(i) == needle.charAt(0)) {\\n                boolean found = true;\\n                for (int j = 1; j < needleLen; j++) {\\n                    if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n                if (found) {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656830,
                "title": "solution-swift-implement-strstr",
                "content": "```swift\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n        let lnH = haystack.count, lnN = needle.count\\n        if lnN == 0 || haystack == needle { return 0 }\\n        guard lnH >= lnN else { return -1 }\\n        \\n        var idxH = haystack.startIndex\\n\\n        for i in 0...(lnH - lnN) {\\n            let idx = haystack.index(idxH, offsetBy: lnN)\\n            if haystack[idxH..<idx] == needle { return i }\\n            idxH = haystack.index(idxH, offsetBy: 1)\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.006 (0.007) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.strStr(\"hello\", \"ll\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.strStr(\"aaaaa\", \"bba\")\\n        XCTAssertEqual(value, -1)\\n    }\\n    \\n    func test2() {\\n        let value = solution.strStr(\"\", \"\")\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n        let lnH = haystack.count, lnN = needle.count\\n        if lnN == 0 || haystack == needle { return 0 }\\n        guard lnH >= lnN else { return -1 }\\n        \\n        var idxH = haystack.startIndex\\n\\n        for i in 0...(lnH - lnN) {\\n            let idx = haystack.index(idxH, offsetBy: lnN)\\n            if haystack[idxH..<idx] == needle { return i }\\n            idxH = haystack.index(idxH, offsetBy: 1)\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.strStr(\"hello\", \"ll\")\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.strStr(\"aaaaa\", \"bba\")\\n        XCTAssertEqual(value, -1)\\n    }\\n    \\n    func test2() {\\n        let value = solution.strStr(\"\", \"\")\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317129,
                "title": "easy-c-solution-using-kmp-algorithm",
                "content": "**Time complexity :- O(n+m) where n=haystack length, m=needle length**\\n**Space complexity :- O(m)**\\n```\\nclass Solution\\n{\\npublic:\\n    // function to generate the LPS array\\n    vector<int>lpsGenerator(string &s)\\n    {\\n        int n=s.length(),i=1,j=0;\\n        vector<int>lps(n);\\n        lps[0]=0;\\n        while(i<n)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                lps[i]=j+1;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    lps[i++]=0;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle)\\n    {\\n        if(needle.length()==0)\\n        {\\n            return 0;\\n        }\\n        vector<int>lps=lpsGenerator(needle);\\n        int i=0,j=0,n=haystack.length(),m=needle.length();\\n        // i is pointing to haystack\\n        // j is pointing to needle\\n        while(i<n)\\n        {\\n            if(needle[j]==haystack[i])\\n            {\\n                i++;\\n                j++;\\n            }\\n            if(j==m)\\n            {\\n                return i-j;\\n            }\\n            else if(i<n && needle[j]!=haystack[i])\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // function to generate the LPS array\\n    vector<int>lpsGenerator(string &s)\\n    {\\n        int n=s.length(),i=1,j=0;\\n        vector<int>lps(n);\\n        lps[0]=0;\\n        while(i<n)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                lps[i]=j+1;\\n                i++;\\n                j++;\\n            }\\n            else\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    lps[i++]=0;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle)\\n    {\\n        if(needle.length()==0)\\n        {\\n            return 0;\\n        }\\n        vector<int>lps=lpsGenerator(needle);\\n        int i=0,j=0,n=haystack.length(),m=needle.length();\\n        // i is pointing to haystack\\n        // j is pointing to needle\\n        while(i<n)\\n        {\\n            if(needle[j]==haystack[i])\\n            {\\n                i++;\\n                j++;\\n            }\\n            if(j==m)\\n            {\\n                return i-j;\\n            }\\n            else if(i<n && needle[j]!=haystack[i])\\n            {\\n                if(j>0)\\n                {\\n                    j=lps[j-1];\\n                }\\n                else\\n                {\\n                    i++;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978984,
                "title": "python-rabin-karp",
                "content": "The value of using Rabin-Karp is in having a rolling hash whose value we can update in `O(1)` time. Instead of comparing `needle` char-by-char with all of the substrings of `haystack`, we compute the hash of each next substring and compare to the hash of the `needle`. If the hashes match, we do the char-by-char comparison to make sure that there\\'s no hash collision happening (two strings having the same hash while being actually different). If we don\\'t have any collisions (or have a few) then runtime will be ~`O(N)`. Worst case, if we have collisions at each iteration and needle is the last substring of haystack, then the runtime will be `O(NM)`. Where `N` is the lenght of the `haystack` and `M` is the length of `needle`.\\n\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tif needle == \\'\\': return 0\\n\\tN = len(needle)\\n\\tbase = 26  # base of the polynomial hash\\n\\tprime_mod = 101  # to avoid hash overflow, doesn\\'t have to be prime number\\n\\n\\tdef charcode(ch):\\n\\t\\treturn ord(ch) - ord(\\'a\\')\\n\\n\\tdef myhash(s):\\n\\t\\t\\'\\'\\'polynomial hash of a string\\'\\'\\'\\n\\t\\tmy_hash = 0\\n\\t\\tfor ch in s:\\n\\t\\t\\tmy_hash = (charcode(ch) + my_hash * base) % prime_mod\\n\\t\\treturn my_hash\\n\\n\\tneedle_hash = myhash(needle)\\n\\trolling_hash = myhash(haystack[:N-1])\\n\\n\\tfirst_pow = base ** (N-1)  # the first digit\\'s base as a const, to avoid recomputation\\n\\n\\tfor i in range(N-1, len(haystack)):\\n\\t\\trolling_hash = (rolling_hash * base + charcode(haystack[i])) % prime_mod\\n\\t\\tif rolling_hash == needle_hash and needle == haystack[i+1-N:i+1]: return i+1-N\\n\\t\\trolling_hash = (rolling_hash - charcode(haystack[i+1-N]) * first_pow) % prime_mod\\n\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tif needle == \\'\\': return 0\\n\\tN = len(needle)\\n\\tbase = 26  # base of the polynomial hash\\n\\tprime_mod = 101  # to avoid hash overflow, doesn\\'t have to be prime number\\n\\n\\tdef charcode(ch):\\n\\t\\treturn ord(ch) - ord(\\'a\\')\\n\\n\\tdef myhash(s):\\n\\t\\t\\'\\'\\'polynomial hash of a string\\'\\'\\'\\n\\t\\tmy_hash = 0\\n\\t\\tfor ch in s:\\n\\t\\t\\tmy_hash = (charcode(ch) + my_hash * base) % prime_mod\\n\\t\\treturn my_hash\\n\\n\\tneedle_hash = myhash(needle)\\n\\trolling_hash = myhash(haystack[:N-1])\\n\\n\\tfirst_pow = base ** (N-1)  # the first digit\\'s base as a const, to avoid recomputation\\n\\n\\tfor i in range(N-1, len(haystack)):\\n\\t\\trolling_hash = (rolling_hash * base + charcode(haystack[i])) % prime_mod\\n\\t\\tif rolling_hash == needle_hash and needle == haystack[i+1-N:i+1]: return i+1-N\\n\\t\\trolling_hash = (rolling_hash - charcode(haystack[i+1-N]) * first_pow) % prime_mod\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1545167,
                "title": "java-bruteforce-tc-o-m-n-sc-o-1-kmp-tc-o-m-n-sc-o-n-two-solutions",
                "content": "**Brute Force string matching**\\n\\n```java\\n/**\\n * Brute Force string matching.\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen < nLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hLen - nLen; i++) {\\n            int j = 0;\\n            while (j < nLen && haystack.charAt(i + j) == needle.charAt(j)) {\\n                j++;\\n            }\\n            if (j == nLen) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n**Using KMP Algorithm**\\n\\n```java\\n/**\\n * Using KMP Algorithm\\n *\\n * Time Complexity: O(M + N). O(N) to create lookup table. O(M) to find the\\n * needle in haystack.\\n *\\n * Space Complexity: O(N). This is required to save the lookup table.\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n\\n        int nLen = needle.length();\\n        int hLen = haystack.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen == 0) {\\n            return -1;\\n        }\\n\\n        int[] table = kmpLookupTable(needle);\\n        int i = 0;\\n        int j = 0;\\n        while (i < hLen && j < nLen) {\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j > 0) {\\n                    j = table[j - 1];\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n\\n        if (j == nLen) {\\n            return i - j;\\n        }\\n        return -1;\\n    }\\n\\n    private int[] kmpLookupTable(String s) {\\n        int[] table = new int[s.length()];\\n        int i = 1;\\n        int index = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == s.charAt(index)) {\\n                table[i] = index + 1;\\n                index++;\\n                i++;\\n            } else {\\n                if (index > 0) {\\n                    index = table[index - 1];\\n                } else {\\n                    table[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return table;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Brute Force string matching.\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(1)\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            throw new IllegalArgumentException(\"Input strings are null\");\\n        }\\n\\n        int hLen = haystack.length();\\n        int nLen = needle.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen < nLen) {\\n            return -1;\\n        }\\n\\n        for (int i = 0; i <= hLen - nLen; i++) {\\n            int j = 0;\\n            while (j < nLen && haystack.charAt(i + j) == needle.charAt(j)) {\\n                j++;\\n            }\\n            if (j == nLen) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```java\\n/**\\n * Using KMP Algorithm\\n *\\n * Time Complexity: O(M + N). O(N) to create lookup table. O(M) to find the\\n * needle in haystack.\\n *\\n * Space Complexity: O(N). This is required to save the lookup table.\\n *\\n * M = Length of haystack string. N = length of needle string.\\n */\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n\\n        int nLen = needle.length();\\n        int hLen = haystack.length();\\n        if (nLen == 0) {\\n            return 0;\\n        }\\n        if (hLen == 0) {\\n            return -1;\\n        }\\n\\n        int[] table = kmpLookupTable(needle);\\n        int i = 0;\\n        int j = 0;\\n        while (i < hLen && j < nLen) {\\n            if (haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j > 0) {\\n                    j = table[j - 1];\\n                } else {\\n                    i++;\\n                }\\n            }\\n        }\\n\\n        if (j == nLen) {\\n            return i - j;\\n        }\\n        return -1;\\n    }\\n\\n    private int[] kmpLookupTable(String s) {\\n        int[] table = new int[s.length()];\\n        int i = 1;\\n        int index = 0;\\n        while (i < s.length()) {\\n            if (s.charAt(i) == s.charAt(index)) {\\n                table[i] = index + 1;\\n                index++;\\n                i++;\\n            } else {\\n                if (index > 0) {\\n                    index = table[index - 1];\\n                } else {\\n                    table[i] = 0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return table;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595243,
                "title": "c-3-solutions-naive-kmp-and-z-algorithm",
                "content": "I will be providing with 3 solutions. The first one is a naive one, which actually runs quite good. Then I will be providing the linear time kmp and z-algorithm ones.\\n\\n**Solution One**\\n\\nThis is a `Naive` implementation. Just check all substrings of length `m` in the haystack. If you get a substring, then just return the first index of the substring. I think the code is quite self explanatory.\\n\\n```\\nint strStr(string haystack, string needle) {\\n\\tint n=haystack.length(), m=needle.length();\\n\\tfor(int i=0;i<n-m+1;i++){\\n\\t\\tint j=0;\\n\\t\\twhile(j<m){\\n\\t\\t\\tif(haystack[i+j]==needle[j]) j++;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif(j==m) return i;\\n\\t}\\n\\treturn -1;\\n}\\n```\\n\\n*Time Complexity* - `O(m*(n-m+1))`\\n*Space Complexity* - `O(1)`\\n\\n**Solution Two**\\n\\nWe use the famous KMP string matching algorithm, which does this in linear time. We have to pre-process and construct a `lps` array, where `lps[i]` denotes longest proper prefix which is also a suffix.\\nFor more understanding of the KMP algo, follow these 3 links -\\n\\n1. [Geeks for Geeks KMP Algo](https://www.***.org/kmp-algorithm-for-pattern-searching/)\\n2. [A blog describing KMP](https://blogarithms.github.io/articles/2018-06/kmp-algorithm)\\n3. Tushar Roy\\'s video about KMP.\\n\\n```\\nclass Solution {\\npublic:\\n    // calculate the lps function\\n    vector<int> calc(string pat, int m)\\n    {\\n        vector<int> lps(m,0);\\n        int i=1, j=0;\\n        while(i<m){\\n            if(pat[i]==pat[j]){\\n                j++;\\n                lps[i++]=j;\\n            }\\n            else{\\n                if(j) j=lps[j-1];\\n                else lps[i++]=0;\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        vector<int> lps = calc(needle, m);\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(haystack[i]==needle[j]){\\n                i++;\\n                j++;\\n            }\\n            if(j==m) return i-j; // since we are returning the first valid index, we just return i-j. If we had to return all valid indices, then we would have to do j=lps[j-1] after this step, since pattern can repeat, and the new pattern may already have started.\\n            else if(i<n && j<m && haystack[i]!=needle[j]){\\n                if(j) j=lps[j-1];\\n                else i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n*Time Complexity* - `O(m+n)`\\n*Space Complexity* - `O(m)`\\n\\n**Solution Three**\\n\\nWe use the famous `Z Algorithm`, which is also a linear pattern matching algorithm. For this we have to construct a `Z-array` where `Z[i]` is equal to the longest substring starting from `S[i]`, which is also a prefix of the original string. We have to concatenate the pattern and the string together, along with a \\'$\\'.\\nFor more info, follow these three links -\\n\\n1. [Geeks for Geeks Z Algo](https://www.***.org/z-algorithm-linear-time-pattern-searching-algorithm/)\\n2. [HackerEarth Tutorial Z Algo](https://www.hackerearth.com/practice/algorithms/string-algorithm/z-algorithm/tutorial/)\\n3. Tushar Roy\\'s video about Z Algo.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> calc(string pat) // calculates the Z-array\\n    {\\n        int n=pat.length();\\n        vector<int> z(n,0);\\n        int L=0, R=0, i=1;\\n        for(;i<n;i++){\\n            if(i>R){  // i is not in the Z-box.\\n                L=R=i;\\n                while(R<n && pat[R-L]==pat[R]) R++;\\n                z[i]=R-L;\\n                R--;\\n            }\\n            else{\\n                int k=i-L;\\n                if(z[k]<R-i+1) z[i]=z[k];\\n                else{\\n                    L=i;\\n                    while(R<n && pat[R-L]==pat[R]) R++;\\n                    z[i]=R-L;\\n                    R--;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        string res=needle+\"$\"+haystack;   // we find the z array for [pat + \\'$\\' + text]\\n        vector<int> z=calc(res);\\n        for(int i=0;i<res.length();i++){\\n            if(z[i]==m) return i-m-1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n*Time Complexity* - `O(m+n)`\\n*Space Complexity* - `O(m+n)`\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint strStr(string haystack, string needle) {\\n\\tint n=haystack.length(), m=needle.length();\\n\\tfor(int i=0;i<n-m+1;i++){\\n\\t\\tint j=0;\\n\\t\\twhile(j<m){\\n\\t\\t\\tif(haystack[i+j]==needle[j]) j++;\\n\\t\\t\\telse break;\\n\\t\\t}\\n\\t\\tif(j==m) return i;\\n\\t}\\n\\treturn -1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // calculate the lps function\\n    vector<int> calc(string pat, int m)\\n    {\\n        vector<int> lps(m,0);\\n        int i=1, j=0;\\n        while(i<m){\\n            if(pat[i]==pat[j]){\\n                j++;\\n                lps[i++]=j;\\n            }\\n            else{\\n                if(j) j=lps[j-1];\\n                else lps[i++]=0;\\n            }\\n        }\\n        return lps;\\n    }\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        vector<int> lps = calc(needle, m);\\n        int i=0,j=0;\\n        while(i<n && j<m){\\n            if(haystack[i]==needle[j]){\\n                i++;\\n                j++;\\n            }\\n            if(j==m) return i-j; // since we are returning the first valid index, we just return i-j. If we had to return all valid indices, then we would have to do j=lps[j-1] after this step, since pattern can repeat, and the new pattern may already have started.\\n            else if(i<n && j<m && haystack[i]!=needle[j]){\\n                if(j) j=lps[j-1];\\n                else i++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> calc(string pat) // calculates the Z-array\\n    {\\n        int n=pat.length();\\n        vector<int> z(n,0);\\n        int L=0, R=0, i=1;\\n        for(;i<n;i++){\\n            if(i>R){  // i is not in the Z-box.\\n                L=R=i;\\n                while(R<n && pat[R-L]==pat[R]) R++;\\n                z[i]=R-L;\\n                R--;\\n            }\\n            else{\\n                int k=i-L;\\n                if(z[k]<R-i+1) z[i]=z[k];\\n                else{\\n                    L=i;\\n                    while(R<n && pat[R-L]==pat[R]) R++;\\n                    z[i]=R-L;\\n                    R--;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int n=haystack.length(), m=needle.length();\\n        if(m==0) return 0;\\n        string res=needle+\"$\"+haystack;   // we find the z array for [pat + \\'$\\' + text]\\n        vector<int> z=calc(res);\\n        for(int i=0;i<res.length();i++){\\n            if(z[i]==m) return i-m-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456653,
                "title": "beats-97-46-7-145-top-interview-question",
                "content": "# Intuition\\n*If we can find the length of the needle then we can use that as the window size and use the sliding windows approach to solve this problem*\\n\\n# Approach\\nThis is a Python function that implements the \"strstr\" function, which searches for a substring within a larger string. The function takes two string arguments, `haystack` and `needle`, and returns the index of the first occurrence of the `needle` in the `haystack`, or `-1` if the `needle` is not found.\\n\\nHere\\'s a step-by-step explanation of how the code works:\\n\\n1. The function starts by checking if `needle` is equal to `haystack`. If it is, then `needle` is a substring of `haystack` and its starting index is 0. In this case, the function returns 0.\\n\\n2. If `needle` is not equal to `haystack`, the function initializes two variables: `i`, which represents the starting index of a substring of `haystack`, and `j`, which represents the ending index of that substring. Initially, `i` is set to 0 and `j` is set to the length of `needle`.\\n\\n3. The function then enters a loop that continues until `j` is greater than the length of `haystack`. In each iteration of the loop, the function extracts a substring of `haystack` that starts at index `i` and ends at index `j - 1`. This substring is stored in a variable called `currentNeedle`.\\n\\n4. The function then compares `currentNeedle` with `needle`. If they are equal, it means that `needle` is a substring of `haystack` starting at index `i`. The function returns `i`.\\n\\n5. If `currentNeedle` is not equal to `needle`, the function increments `i` and `j` by 1 and continues with the next iteration of the loop.\\n\\n6. If the loop completes without finding a match for `needle`, the function returns -1.\\n\\nOverall, this function provides a simple and efficient way to search for substrings within a larger string in Python.\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(n)\\n\\n\\n\\nThe `time complexity of this function is O(mn)`, where `m` is the length of `haystack` and `n` is the length of `needle`. This is because in the worst case scenario, we need to compare every substring of `haystack` of length `n` with `needle`.\\n\\nThe space complexity of this function is O(n), because we are using a slicing operation `haystack[i:j]` which return a copy of substring, Which can be of size `n`.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle == haystack:\\n            return 0\\n        i = 0\\n        j = len(needle)\\n        while j <= len(haystack):\\n            currentNeedle = haystack[i:j]\\n            if currentNeedle == needle:\\n                return i\\n            i += 1\\n            j += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle == haystack:\\n            return 0\\n        i = 0\\n        j = len(needle)\\n        while j <= len(haystack):\\n            currentNeedle = haystack[i:j]\\n            if currentNeedle == needle:\\n                return i\\n            i += 1\\n            j += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920522,
                "title": "solution",
                "content": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2498948,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == n) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550965,
                "title": "easy-o-m-n-js-solution",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n    if (needle.length == 0) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let k = i, j = 0;\\n        while (haystack[k] == needle[j] && j < needle.length) {\\n            k++, j++;\\n        }\\n        if (j == needle.length) return i;\\n    }\\n    return -1; // couldn\\'t find needle in haystack\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    if (needle.length == 0) return 0;\\n    for (let i = 0; i < haystack.length; i++) {\\n        let k = i, j = 0;\\n        while (haystack[k] == needle[j] && j < needle.length) {\\n            k++, j++;\\n        }\\n        if (j == needle.length) return i;\\n    }\\n    return -1; // couldn\\'t find needle in haystack\\n    // Time Complexity: O(m*n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116860,
                "title": "javascript-solution-beats-100",
                "content": "I used substring to replace the comparision letter by letter.\n![image](https://s3-lc-upload.s3.amazonaws.com/users/ruinan/image_1519696100.png)\n\n```javascript\nvar strStr = function(haystack, needle) {\n    if (haystack === needle || needle === \"\") {\n        return 0;\n    }\n    for (let i = 0; i < haystack.length; i++) {\n        if (haystack[i] === needle[0]) {\n            let temp = haystack.substring(i, i + needle.length);\n            if (temp === needle) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\n```",
                "solutionTags": [],
                "code": "```javascript\nvar strStr = function(haystack, needle) {\n    if (haystack === needle || needle === \"\") {\n        return 0;\n    }\n    for (let i = 0; i < haystack.length; i++) {\n        if (haystack[i] === needle[0]) {\n            let temp = haystack.substring(i, i + needle.length);\n            if (temp === needle) {\n                return i;\n            }\n        }\n    }\n    return -1;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 12982,
                "title": "3-different-solutions-15-8-1-lines-c",
                "content": "**Solution 1**\\n\\nBrute force, simple and easy. \\n\\nTime complexity: O(n*m)\\nSpace comlexity: O(1)\\nRun time: 109 ms\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++)\\n            if(haystack[i] == needle[0] && isEqual(haystack.substr(i), needle)) return i;\\n        return -1;\\n    }\\n    \\n    bool isEqual(string s1, string s2){\\n        if(s1.size() < s2.size()) return false;\\n        for(int i = 0; i < s2.size(); i++)\\n            if(s1[i] != s2[i]) return false;\\n        return true;\\n    }\\n};\\n```\\nOr move isEqual() function inside.\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++){\\n            int j = 0;\\n            for(;j < needle.size(); j++){\\n                if(i + j == haystack.size()) return -1;\\n                if(haystack[i + j] != needle[j]) break;\\n            }\\n            if(j == needle.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n***\\n**Solution 2** \\n\\nIn BF solution, we compare two strings everytime we meet the charactor `needle[0]`, which can cause a lot of unnecessary calculations. Is there a way to \"shrink\" the candidate substrings?\\n\\nWe can use a hash table to count the number of occurrence of `char`s in **needle**, and only jump to comparison when substring in **haystack** has the same `char`s and occurrence with needle.\\n\\nIf you are still not clear in what I explained, here is a post may help you understand the idea - [Here is a 10-line template that can solve most 'substring' problems](https://discuss.leetcode.com/topic/30941/here-is-a-10-line-template-that-can-solve-most-substring-problems).\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)\\nRun time: 6 ms\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        unordered_map<char, int>m;\\n        for(auto x: needle) m[x]++;\\n        int count = needle.size();\\n        int begin = 0, end = 0;\\n        while(end < haystack.size()){\\n            if(m[haystack[end++]]-- > 0) count--;\\n            if(count == 0){\\n                int i = begin, j = 0;\\n                while(j < needle.size() && haystack[i] == needle[j]) i++, j++;\\n                if(j == needle.size()) return begin;\\n            }\\n            if(end - begin == needle.size() && m[haystack[begin++]]++ >= 0) count++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n***\\n**Solution 3** \\n\\nFinally, a \"cheat\" solution.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)  (not sure about that, correct me if I'm wrong)\\nRun time: 6 ms\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++)\\n            if(haystack[i] == needle[0] && isEqual(haystack.substr(i), needle)) return i;\\n        return -1;\\n    }\\n    \\n    bool isEqual(string s1, string s2){\\n        if(s1.size() < s2.size()) return false;\\n        for(int i = 0; i < s2.size(); i++)\\n            if(s1[i] != s2[i]) return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        for(int i = 0; i < haystack.size(); i++){\\n            int j = 0;\\n            for(;j < needle.size(); j++){\\n                if(i + j == haystack.size()) return -1;\\n                if(haystack[i + j] != needle[j]) break;\\n            }\\n            if(j == needle.size()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0) return 0;\\n        unordered_map<char, int>m;\\n        for(auto x: needle) m[x]++;\\n        int count = needle.size();\\n        int begin = 0, end = 0;\\n        while(end < haystack.size()){\\n            if(m[haystack[end++]]-- > 0) count--;\\n            if(count == 0){\\n                int i = begin, j = 0;\\n                while(j < needle.size() && haystack[i] == needle[j]) i++, j++;\\n                if(j == needle.size()) return begin;\\n            }\\n            if(end - begin == needle.size() && m[haystack[begin++]]++ >= 0) count++;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512825,
                "title": "c-java-python-javascript-easy-with-explanation",
                "content": "# Intuition:\\nThe problem requires us to find the index of the first occurrence of the needle string in the haystack string. We can solve this problem by checking each substring of the haystack that has the same length as the needle, and compare it with the needle to see if they match. If a match is found, return the starting index of the substring, otherwise continue checking the next substring. If no match is found, return -1.\\n\\n# Approach:\\n1. Calculate the length of the haystack and needle strings.\\n2. If the length of the needle is 0, return 0.\\n3. Use a loop to check each substring of the haystack that has the same length as the needle, starting from the first character of the haystack.\\n4. Inside the loop, use another loop to compare each character of the substring with the corresponding character of the needle. If a character doesn\\'t match, break the loop and move to the next substring.\\n5. If all characters match, return the starting index of the substring.\\n6. If no match is found, return -1.\\n\\n# Complexity\\n- Time Complexity: O((n-m+1)*m) = O(n*m)\\n\\n     - Note - In the worst-case scenario, we would have to check all possible substrings of the haystack string that have the same length as the needle string. There are (n-m+1) such substrings. For each substring, we need to compare each character with the corresponding character in the needle string, which takes O(m) time. Therefore, the total time complexity would be (n-m+1)m, which can be simplified to O(nm) since n and m are both variables that can change.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space Complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            bool found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack[i+j] != needle[j]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            boolean found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        n = len(haystack)\\n        m = len(needle)\\n        \\n        if m == 0:\\n            return 0  # empty needle\\n        \\n        for i in range(n - m + 1):\\n            found = True\\n            for j in range(m):\\n                if haystack[i + j] != needle[j]:\\n                    found = False\\n                    break\\n            if found:\\n                return i\\n        return -1  # needle not found\\n\\n\\n```\\n\\n---\\n\\n# JavaScript\\n```\\nvar strStr = function(haystack, needle) {\\n    let n = haystack.length;\\n    let m = needle.length;\\n    \\n    if (m === 0) return 0; // empty needle\\n    \\n    for (let i = 0; i <= n - m; i++) {\\n        let found = true;\\n        for (let j = 0; j < m; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        if (found) return i;\\n    }\\n    return -1; // needle not found\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            bool found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack[i+j] != needle[j]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int n = haystack.length();\\n        int m = needle.length();\\n        \\n        if (m == 0) return 0; // empty needle\\n        \\n        for (int i = 0; i <= n - m; i++) {\\n            boolean found = true;\\n            for (int j = 0; j < m; j++) {\\n                if (haystack.charAt(i + j) != needle.charAt(j)) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return i;\\n        }\\n        return -1; // needle not found\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        n = len(haystack)\\n        m = len(needle)\\n        \\n        if m == 0:\\n            return 0  # empty needle\\n        \\n        for i in range(n - m + 1):\\n            found = True\\n            for j in range(m):\\n                if haystack[i + j] != needle[j]:\\n                    found = False\\n                    break\\n            if found:\\n                return i\\n        return -1  # needle not found\\n\\n\\n```\n```\\nvar strStr = function(haystack, needle) {\\n    let n = haystack.length;\\n    let m = needle.length;\\n    \\n    if (m === 0) return 0; // empty needle\\n    \\n    for (let i = 0; i <= n - m; i++) {\\n        let found = true;\\n        for (let j = 0; j < m; j++) {\\n            if (haystack[i + j] !== needle[j]) {\\n                found = false;\\n                break;\\n            }\\n        }\\n        if (found) return i;\\n    }\\n    return -1; // needle not found\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022670,
                "title": "c-faster-than-100-with-single-loop",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint strStr(string haystack, string needle) {\\n\\t\\t\\tint needle_len = needle.length();\\n\\t\\t\\tint haystack_len = haystack.length();\\n\\t\\t\\tif(needle_len==0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint j = 0;\\n\\t\\t\\tfor(int i = 0 ; i < haystack_len ; i++){\\n\\n\\t\\t\\t\\tif(haystack[i] == needle[j]){\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\ti = i-j;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j==needle_len){\\n\\t\\t\\t\\t\\treturn i - j +1 ;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint strStr(string haystack, string needle) {\\n\\t\\t\\tint needle_len = needle.length();\\n\\t\\t\\tint haystack_len = haystack.length();\\n\\t\\t\\tif(needle_len==0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3647846,
                "title": "javascript-easy-solution-no-built-in-methods",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let k=0\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack[i]==needle[k]){\\n            k++;\\n            if(k==needle.length){\\n                return i-(k-1)\\n            }\\n        }else{\\n            i=i-(k)\\n            k=0;\\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let k=0\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack[i]==needle[k]){\\n            k++;\\n            if(k==needle.length){\\n                return i-(k-1)\\n            }\\n        }else{\\n            i=i-(k)\\n            k=0;\\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498029,
                "title": "rabin-karp-o-n-q-m-extension-to-find-all-occurances-python",
                "content": "Code is explained in comments below...\\n```\\nimport functools\\nimport random\\n\\n\\nclass Solution(object):\\n    \\n    # Pick a random hash function from a universal family with a small collision probability |pattern| / p.\\n    p = 1000000007\\n    x = random.randint(1, p - 1)\\n    \\n    def strStr(self, haystack, needle):\\n        \\n        # Empty pattern edge case.\\n        if needle == \"\":\\n            return 0\\n        \\n        # Find all occurances of pattern and return 1st (extended to \"find all\" by dropping [0]).\\n        positions = self.rabin_karp(pattern=needle, text=haystack)\\n        return -1 if not positions else positions[0]\\n    \\n    @classmethod\\n    def rabin_karp(cls, pattern, text):\\n        \"\"\"Find all occurances of pattern in text in O(|text| + (num_occurances + 1)*|pattern|).\"\"\"\\n        positions = []\\n        \\n        # Precompute hash of pattern and x^|pattern| in O(|pattern|).\\n        x_p = functools.reduce(lambda aggregate, _: (aggregate * cls.x) % cls.p, range(len(pattern)), 1)\\n        pattern_hash = cls.poly_hash(s=pattern)\\n        \\n        # Compute rolling_hash once and check edge case for position = 0 in O(|pattern|).\\n        rolling_hash = cls.poly_hash(s=text[:len(pattern)])\\n        if rolling_hash == pattern_hash and text[:len(pattern)] == pattern:\\n            positions.append(0)\\n        \\n        # Iterate over O(|text|) positions, in each update rolling hash in O(1) using: H[k + 1] = H[k] * x + s[k + P] - s[k] * x^P (P = len(pattern)).\\n        for position in range(1, 1 + len(text) - len(pattern)):\\n            rolling_hash = (rolling_hash * cls.x + ord(text[position + len(pattern) - 1]) - ord(text[position - 1]) * x_p) % cls.p\\n            if rolling_hash == pattern_hash and text[position:position + len(pattern)] == pattern:  # O(1) unless hash match/collision, in which case O(|pattern|).\\n                positions.append(position)\\n        \\n        # Return positions of all occurances.\\n        return positions\\n        \\n    @classmethod\\n    def poly_hash(cls, s):\\n        \"\"\"Compute the polynomial hash H = sum(s[0] * x^n + ... + s[n] * x^0) % p where n = len(s) - 1.\"\"\"\\n        return functools.reduce(lambda aggregate, char: (aggregate * cls.x + ord(char)) % cls.p, s, 0)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Hash Function"
                ],
                "code": "```\\nimport functools\\nimport random\\n\\n\\nclass Solution(object):\\n    \\n    # Pick a random hash function from a universal family with a small collision probability |pattern| / p.\\n    p = 1000000007\\n    x = random.randint(1, p - 1)\\n    \\n    def strStr(self, haystack, needle):\\n        \\n        # Empty pattern edge case.\\n        if needle == \"\":\\n            return 0\\n        \\n        # Find all occurances of pattern and return 1st (extended to \"find all\" by dropping [0]).\\n        positions = self.rabin_karp(pattern=needle, text=haystack)\\n        return -1 if not positions else positions[0]\\n    \\n    @classmethod\\n    def rabin_karp(cls, pattern, text):\\n        \"\"\"Find all occurances of pattern in text in O(|text| + (num_occurances + 1)*|pattern|).\"\"\"\\n        positions = []\\n        \\n        # Precompute hash of pattern and x^|pattern| in O(|pattern|).\\n        x_p = functools.reduce(lambda aggregate, _: (aggregate * cls.x) % cls.p, range(len(pattern)), 1)\\n        pattern_hash = cls.poly_hash(s=pattern)\\n        \\n        # Compute rolling_hash once and check edge case for position = 0 in O(|pattern|).\\n        rolling_hash = cls.poly_hash(s=text[:len(pattern)])\\n        if rolling_hash == pattern_hash and text[:len(pattern)] == pattern:\\n            positions.append(0)\\n        \\n        # Iterate over O(|text|) positions, in each update rolling hash in O(1) using: H[k + 1] = H[k] * x + s[k + P] - s[k] * x^P (P = len(pattern)).\\n        for position in range(1, 1 + len(text) - len(pattern)):\\n            rolling_hash = (rolling_hash * cls.x + ord(text[position + len(pattern) - 1]) - ord(text[position - 1]) * x_p) % cls.p\\n            if rolling_hash == pattern_hash and text[position:position + len(pattern)] == pattern:  # O(1) unless hash match/collision, in which case O(|pattern|).\\n                positions.append(position)\\n        \\n        # Return positions of all occurances.\\n        return positions\\n        \\n    @classmethod\\n    def poly_hash(cls, s):\\n        \"\"\"Compute the polynomial hash H = sum(s[0] * x^n + ... + s[n] * x^0) % p where n = len(s) - 1.\"\"\"\\n        return functools.reduce(lambda aggregate, char: (aggregate * cls.x + ord(char)) % cls.p, s, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12936,
                "title": "javascript-solution",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n  var needleLength = needle.length\\n  var haystackLength = haystack.length\\n\\n  if(needle === '' && haystack === '' ){\\n    return 0\\n  }\\n\\n  for(var i=0; i < haystack.length; i++){\\n    if (haystack.substr(i, needleLength) === needle){\\n      return i\\n    }\\n  }\\n  return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n  var needleLength = needle.length\\n  var haystackLength = haystack.length\\n\\n  if(needle === '' && haystack === '' ){\\n    return 0\\n  }\\n\\n  for(var i=0; i < haystack.length; i++){\\n    if (haystack.substr(i, needleLength) === needle){\\n      return i\\n    }\\n  }\\n  return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13237,
                "title": "java-and-python-solution-using-kmp-with-o-m-n-time-complexity",
                "content": "The time complexity for this solution should be O(m + n). First of all, we generate the \"next\" array to show any possible duplicates of prefix and postfix within needle. Then we go through haystack. Every time we see a bad match, move j to next[j] and keep i in current position; otherwise, move both of them to next position.\\nPython version:\\n\\n    def strStr(self, haystack, needle):\\n        if haystack == None or needle == None:\\n            return -1\\n        #generate next array, need O(n) time\\n        i, j, m, n = -1, 0, len(haystack), len(needle)\\n        next = [-1] * n\\n        while j < n - 1:  \\n            #needle[k] stands for prefix, neelde[j] stands for postfix\\n            if i == -1 or needle[i] == needle[j]:   \\n                i, j = i + 1, j + 1\\n                next[j] = i\\n            else:\\n                i = next[i]\\n            print i,j,next[i],next[j]\\n        #check through the haystack using next, need O(m) time\\n        i = j = 0\\n        while i < m and j < n:\\n            if j == -1 or haystack[i] == needle[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                j = next[j]\\n        if j == n:\\n            return i - j\\n        return -1\\n\\nJava version:\\n\\n    public int strStr(String haystack, String needle){\\n        if (haystack == null || needle == null)\\n            return -1;\\n        //generate next array, need O(n) time\\n        int i = -1, j = 0, m = haystack.length(), n = needle.length();\\n        int[] next = new int[n];\\n        if (next.length > 0) \\n            next[0] = -1;\\n        while (j < n - 1) {\\n            if (i == -1 || needle.charAt(i) == needle.charAt(j))\\n                next[++j] = ++i;\\n            else \\n                i = next[i];\\n        }\\n        //check through the haystack using next, need O(m) time\\n        i = 0; j = 0;\\n        while (i < m && j < n) {\\n            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else \\n                j = next[j];\\n        }\\n        if (j == n)\\n            return i - j;\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "The time complexity for this solution should be O(m + n). First of all, we generate the \"next\" array to show any possible duplicates of prefix and postfix within needle. Then we go through haystack. Every time we see a bad match, move j to next[j] and keep i in current position; otherwise, move both of them to next position.\\nPython version:\\n\\n    def strStr(self, haystack, needle):\\n        if haystack == None or needle == None:\\n            return -1\\n        #generate next array, need O(n) time\\n        i, j, m, n = -1, 0, len(haystack), len(needle)\\n        next = [-1] * n\\n        while j < n - 1:  \\n            #needle[k] stands for prefix, neelde[j] stands for postfix\\n            if i == -1 or needle[i] == needle[j]:   \\n                i, j = i + 1, j + 1\\n                next[j] = i\\n            else:\\n                i = next[i]\\n            print i,j,next[i],next[j]\\n        #check through the haystack using next, need O(m) time\\n        i = j = 0\\n        while i < m and j < n:\\n            if j == -1 or haystack[i] == needle[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                j = next[j]\\n        if j == n:\\n            return i - j\\n        return -1\\n\\nJava version:\\n\\n    public int strStr(String haystack, String needle){\\n        if (haystack == null || needle == null)\\n            return -1;\\n        //generate next array, need O(n) time\\n        int i = -1, j = 0, m = haystack.length(), n = needle.length();\\n        int[] next = new int[n];\\n        if (next.length > 0) \\n            next[0] = -1;\\n        while (j < n - 1) {\\n            if (i == -1 || needle.charAt(i) == needle.charAt(j))\\n                next[++j] = ++i;\\n            else \\n                i = next[i];\\n        }\\n        //check through the haystack using next, need O(m) time\\n        i = 0; j = 0;\\n        while (i < m && j < n) {\\n            if (j == -1 || haystack.charAt(i) == needle.charAt(j)) {\\n                i++;\\n                j++;\\n            }\\n            else \\n                j = next[j];\\n        }\\n        if (j == n)\\n            return i - j;\\n        return -1;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 3249674,
                "title": "one-line-solution-java-100-0ms-2023",
                "content": "\\t  class Solution {\\n\\t\\t\\t public int strStr(String haystack, String needle) {\\n\\t\\t\\t\\t\\treturn  haystack.indexOf(needle);\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t\\t public int strStr(String haystack, String needle) {\\n\\t\\t\\t\\t\\treturn  haystack.indexOf(needle);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2920525,
                "title": "solution",
                "content": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976007,
                "title": "a-clean-c-solution-using-substr-beats-100-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() == 0 || \\n            haystack.size() == 0)\\n                return 0;\\n        \\n        if (needle.size() > haystack.size())\\n            return -1;\\n\\n        for (int i = 0; i < haystack.size(); ++i)\\n        {\\n            if (haystack[i] == needle[0])\\n            {\\n                if (haystack.substr(i, needle.size()) == needle)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() == 0 || \\n            haystack.size() == 0)\\n                return 0;\\n        \\n        if (needle.size() > haystack.size())\\n            return -1;\\n\\n        for (int i = 0; i < haystack.size(); ++i)\\n        {\\n            if (haystack[i] == needle[0])\\n            {\\n                if (haystack.substr(i, needle.size()) == needle)\\n                {\\n                    return i;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119566,
                "title": "python-knuth-morris-pratt-algorithm",
                "content": "Knuth\\u2013Morris\\u2013Pratt algorithm implemented in Python.\\n```\\nclass Solution:\\n    def build_lps(self, pattern):\\n        \"\"\" Helper function for strStr.\\n        Returns longest proper suffix array for string pattern.\\n        Each lps_array[i] is the length of the longest proper prefix\\n        which is equal to suffix for pattern ending at character i.\\n        Proper means that whole string cannot be prefix or suffix.\\n\\n        Time complexity: O(m). Space complexity: O(1), where\\n        m is the length of the pattern, space used for lps array isn\\'t included.\\n        \"\"\"\\n        m = len(pattern)\\n        lps_array = [0] * m\\n        i, j = 1, 0  # start from the 2nd character in pattern\\n        while i < m:\\n            if pattern[i] == pattern[j]:\\n                lps_array[i] = j + 1\\n                j += 1\\n                i += 1\\n            else:\\n                if j > 0:\\n                    j = lps_array[j - 1]\\n                else:\\n                    lps_array[i] = 0\\n                    i += 1\\n        return lps_array\\n\\n    def strStr(self, text, pattern):\\n        \"\"\" Returns index of 1st occurence of pattern in text.\\n        Returns -1 if pattern is not in the text.\\n        Knuth\\u2013Morris\\u2013Pratt algorithm.\\n        Time complexity: O(n + m). Space complexity: O(m).\\n        \"\"\"\\n        # special cases\\n        if not text and not pattern:\\n            return 0\\n        elif not pattern:\\n            return 0\\n\\n        # build longest proper suffix array for pattern\\n        lps_array = self.build_lps(pattern)\\n\\n        n, m = len(text), len(pattern)\\n        i, j = 0, 0\\n        while i < n:\\n            # current characters match, move to the next characters\\n            if text[i] == pattern[j]:\\n                i += 1\\n                j += 1\\n            # current characters don\\'t match\\n            else:\\n                if j > 0:  # try start with previous longest prefix\\n                    j = lps_array[j - 1]\\n                # 1st character of pattern doesn\\'t match character in text\\n                # go to the next character in text\\n                else:\\n                    i += 1\\n\\n            # whole pattern matches text, match is found\\n            if j == m:\\n                return i - m\\n\\n        # no match was found\\n        return -1\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def build_lps(self, pattern):\\n        \"\"\" Helper function for strStr.\\n        Returns longest proper suffix array for string pattern.\\n        Each lps_array[i] is the length of the longest proper prefix\\n        which is equal to suffix for pattern ending at character i.\\n        Proper means that whole string cannot be prefix or suffix.\\n\\n        Time complexity: O(m). Space complexity: O(1), where\\n        m is the length of the pattern, space used for lps array isn\\'t included.\\n        \"\"\"\\n        m = len(pattern)\\n        lps_array = [0] * m\\n        i, j = 1, 0  # start from the 2nd character in pattern\\n        while i < m:\\n            if pattern[i] == pattern[j]:\\n                lps_array[i] = j + 1\\n                j += 1\\n                i += 1\\n            else:\\n                if j > 0:\\n                    j = lps_array[j - 1]\\n                else:\\n                    lps_array[i] = 0\\n                    i += 1\\n        return lps_array\\n\\n    def strStr(self, text, pattern):\\n        \"\"\" Returns index of 1st occurence of pattern in text.\\n        Returns -1 if pattern is not in the text.\\n        Knuth\\u2013Morris\\u2013Pratt algorithm.\\n        Time complexity: O(n + m). Space complexity: O(m).\\n        \"\"\"\\n        # special cases\\n        if not text and not pattern:\\n            return 0\\n        elif not pattern:\\n            return 0\\n\\n        # build longest proper suffix array for pattern\\n        lps_array = self.build_lps(pattern)\\n\\n        n, m = len(text), len(pattern)\\n        i, j = 0, 0\\n        while i < n:\\n            # current characters match, move to the next characters\\n            if text[i] == pattern[j]:\\n                i += 1\\n                j += 1\\n            # current characters don\\'t match\\n            else:\\n                if j > 0:  # try start with previous longest prefix\\n                    j = lps_array[j - 1]\\n                # 1st character of pattern doesn\\'t match character in text\\n                # go to the next character in text\\n                else:\\n                    i += 1\\n\\n            # whole pattern matches text, match is found\\n            if j == m:\\n                return i - m\\n\\n        # no match was found\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338346,
                "title": "c-easy-to-understand-straight-forward-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size()==0)\\n         return 0;\\n        if(haystack.size()<needle.size())\\n          return -1;  \\n        int n=needle.size();\\n        string str;\\n        for(int i=0;i<=haystack.size()-n;i++)\\n        {\\n            str=haystack.substr(i,n);\\n            if(str==needle)\\n             return i;   \\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle.size()==0)\\n         return 0;\\n        if(haystack.size()<needle.size())\\n          return -1;  \\n        int n=needle.size();\\n        string str;\\n        for(int i=0;i<=haystack.size()-n;i++)\\n        {\\n            str=haystack.substr(i,n);\\n            if(str==needle)\\n             return i;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 455126,
                "title": "python-by-sliding-the-needle-over-haystack",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        stride = len(needle)\\n        haystack_length = len(haystack)\\n        total_step = haystack_length-stride+1\\n        if stride == 0: return 0\\n        for i in range(total_step):\\n            if haystack[i:i+stride] == needle:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        stride = len(needle)\\n        haystack_length = len(haystack)\\n        total_step = haystack_length-stride+1\\n        if stride == 0: return 0\\n        for i in range(total_step):\\n            if haystack[i:i+stride] == needle:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249819,
                "title": "easy-approach-fully-explained-with-img-fastest-solution-beats-100-cpp-solution",
                "content": "Feel free to ask any doubt. you cana contact me on linkdin- https://linkedin.com/in/bhaskar-agrawal-a01069219. please upvote.\\n# INTUITION \\nHere, we have to find the first occurance of needle string in haystack string. if needle is present, return first occuring index else return -1. In this we have to check if first character of needle is equal to which index character of haystack and then proceed further for rest of the characters.\\n# APPROACH WITH EXAMPLE.\\n1. Since we have to find the needle in haystack, iterate over haystack from 0 till length.\\n2. check if the haystack[i] is equal to first character of needle. if equal enter inside the loop else just simply come to next iteration, that is, i++.\\n3. if equal, we have to check for the rest of the index\\'s of hYSTACK and NEEEDLE.  For this, **declare i1 = i+1, and j= 1**. j is 1 so that we can check for next character in needle string.\\n4. in a while loop iterate till **haystack[i1] is equal to needle[j].** that is both character are equal or not.. \\n5. if they are equal, increase i1 and j by 1. \\n6. if they are not equal, break the  while loop.\\n7. at the end of for loop check, if j is equal to needle\\'s length or not. if equal return i which is the first occuring index of needle in haystack.\\n8. if we have terminated all loop, it means, beedle is absent, return -1.\\n\\n# EXAMPLE\\n**haystack** = \"sadbutsad\"\\n**needle** = \"sad\"\\n![image](https://assets.leetcode.com/users/images/b3947158-de4a-42a1-a15c-9ee1c79c5ba5_1677810854.0025146.jpeg)\\nwe have to return the first occuring index, we need not to check for whole string. as soon as we find the needle in haystack, we get our mininum index.\\nfeel free to contact me.\\n\\n# COMPLEXITY.\\n**TIME** O(N)- linear. in worst case in reaches upto O(N^2).\\n**SPACE** - O(!)- constant\\n\\n# CODE\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        for (int i = 0; i < haystack.length(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                int i1 = i + 1;\\n                int j = 1;\\n                while (haystack[i1] && needle[j]) {\\n                    if (haystack[i1] != needle[j]) break;\\n                    i1++;\\n                    j++;\\n                }\\n                if (j == needle.length()) return i;\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        for (int i = 0; i < haystack.length(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                int i1 = i + 1;\\n                int j = 1;\\n                while (haystack[i1] && needle[j]) {\\n                    if (haystack[i1] != needle[j]) break;\\n                    i1++;\\n                    j++;\\n                }\\n                if (j == needle.length()) return i;\\n            }\\n        }\\n        return -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478750,
                "title": "java-elegant-rolling-hash",
                "content": "```\\nclass Solution {\\n    int BASE = 31;\\n    int MOD = 10000007;\\n    public int strStr(String h, String t) {\\n        if (t.length() == 0) {\\n            return 0;\\n        }\\n        if (h.length() == 0) {\\n            return -1;\\n        }\\n        int n = h.length();\\n        int m = t.length();\\n        long target = 0;\\n        long pow = 1;\\n        for (int i = 0; i < m; i++) {\\n            target = (target * BASE + t.charAt(i)) % MOD;\\n            pow = pow * BASE % MOD;\\n        }\\n        long code = 0;\\n        for (int i = 0; i < n; i++) {\\n            code = (code * BASE+ h.charAt(i)) % MOD;\\n            if (i >= m) {\\n                code = ((code - h.charAt(i - m) * pow % MOD) + MOD) % MOD;\\n            }\\n            if (code == target) {\\n                return i - m + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int BASE = 31;\\n    int MOD = 10000007;\\n    public int strStr(String h, String t) {\\n        if (t.length() == 0) {\\n            return 0;\\n        }\\n        if (h.length() == 0) {\\n            return -1;\\n        }\\n        int n = h.length();\\n        int m = t.length();\\n        long target = 0;\\n        long pow = 1;\\n        for (int i = 0; i < m; i++) {\\n            target = (target * BASE + t.charAt(i)) % MOD;\\n            pow = pow * BASE % MOD;\\n        }\\n        long code = 0;\\n        for (int i = 0; i < n; i++) {\\n            code = (code * BASE+ h.charAt(i)) % MOD;\\n            if (i >= m) {\\n                code = ((code - h.charAt(i - m) * pow % MOD) + MOD) % MOD;\\n            }\\n            if (code == target) {\\n                return i - m + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792168,
                "title": "python-3-simple-brute-force-beats-98",
                "content": "```python3 []\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        N, H = len(needle), len(haystack)\\n\\n        for i in range(H - N + 1):\\n            for j in range(N):\\n                if needle[j] != haystack[i + j]:\\n                    break\\n                if j == N - 1:\\n                    return i\\n\\n        return -1       \\n```\\n![Screenshot 2023-07-20 at 14.38.05.png](https://assets.leetcode.com/users/images/a689d9b0-5d4f-4f89-a6c1-77418a2794ec_1689853237.382581.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        N, H = len(needle), len(haystack)\\n\\n        for i in range(H - N + 1):\\n            for j in range(N):\\n                if needle[j] != haystack[i + j]:\\n                    break\\n                if j == N - 1:\\n                    return i\\n\\n        return -1       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251954,
                "title": "easy-to-understand-c-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int StrStr(string haystack, string needle)\\n    {\\n        for (var i = 0; i < haystack.Length - needle.Length + 1; i++)\\n        {\\n            if (haystack.Substring(i, needle.Length) == needle)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/e5c1bc7a-bacb-4930-a388-55046dd7ee20_1677848724.0278893.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "String",
                    "String Matching"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int StrStr(string haystack, string needle)\\n    {\\n        for (var i = 0; i < haystack.Length - needle.Length + 1; i++)\\n        {\\n            if (haystack.Substring(i, needle.Length) == needle)\\n            {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595592,
                "title": "solution",
                "content": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let length = haystack.length;\\n    let targetLength = needle.length;\\n    \\n    // Loop through haystack\\n    for (let i = 0; i < length; i++) {\\n        \\n        // If the first character of both haystack and needle match, compare\\n        if (haystack.charAt(i) === needle.charAt(0)) {\\n            // Compares haystacks substring from i to needles length and compares\\n            if (haystack.substring(i,i+targetLength) === needle) return i;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2595589,
                "title": "solution",
                "content": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n    needle_len = len(needle)\\n    for i in range(len(haystack)):\\n        if haystack[i:i+needle_len] == needle:\\n            return i\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1902475,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n\\t\\tguard haystack.count >= needle.count else { return -1 }\\n\\t\\tlet chars1 = Array(haystack)\\n\\t\\tlet chars2 = Array(needle)\\n\\t\\t\\n        for i in 0..<chars1.count - chars2.count + 1 {\\n\\t\\t\\tvar count = 0\\n\\t\\t\\tfor j in 0..<chars2.count {\\n\\t\\t\\t\\tif chars1[i + j] != chars2[j] { break }\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t\\tif count == chars2.count {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n        return -1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func strStr(_ haystack: String, _ needle: String) -> Int {\\n\\t\\tguard haystack.count >= needle.count else { return -1 }\\n\\t\\tlet chars1 = Array(haystack)\\n\\t\\tlet chars2 = Array(needle)\\n\\t\\t\\n        for i in 0..<chars1.count - chars2.count + 1 {\\n\\t\\t\\tvar count = 0\\n\\t\\t\\tfor j in 0..<chars2.count {\\n\\t\\t\\t\\tif chars1[i + j] != chars2[j] { break }\\n\\t\\t\\t\\tcount += 1\\n\\t\\t\\t}\\n\\t\\t\\tif count == chars2.count {\\n\\t\\t\\t\\treturn i\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n        return -1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293585,
                "title": "easy-python-solution-faster-than-89",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle)==0:\\n            return 0 \\n        elif len(haystack) < len(needle) or needle not in haystack:\\n            return -1\\n        else:\\n            x = len(needle)\\n            for i in range(len(haystack)):\\n                if haystack[i:i+x]==needle:\\n                    return i\\n            return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if len(needle)==0:\\n            return 0 \\n        elif len(haystack) < len(needle) or needle not in haystack:\\n            return -1\\n        else:\\n            x = len(needle)\\n            for i in range(len(haystack)):\\n                if haystack[i:i+x]==needle:\\n                    return i\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248916,
                "title": "python-1-linear",
                "content": "Concise of Straightforward Solution\\n```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack, needle):\\n\\treturn haystack.find(needle)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13143,
                "title": "rabin-karp-solution",
                "content": "This is my Rabin-Karp implementation. It beats only 44% However, as I see how fast the naive approaches are I get the impression that the test cases for this problem are all quite simple.\\n\\n    public class Solution {\\n        private static final int R = 31;\\n        private static final int Q = 997;\\n    //    private static final int Q = java.math.BigInteger.probablePrime(16, new java.util.Random(System.currentTimeMillis())).intValue();\\n        \\n        public int strStr(String haystack, String needle) {\\n            if ( needle.length() > haystack.length() ) { return -1; }\\n            if ( needle.length() == 0 ) { return 0; }\\n            int m = needle.length();\\n            int n = haystack.length();\\n            int mf = 1;\\n            for ( int i = 1; i < m; i++ ) { mf = ( mf * R ) % Q; }\\n            int needleHash = hash(needle, 0, m);\\n            int hash = hash(haystack, 0, m);\\n            \\n            for ( int i = m; i <= n; i++ ) {\\n                if ( hash == needleHash && haystack.substring(i - m, i).equals(needle) ) {\\n                    return i - m;\\n                }\\n                if ( i < n ) {\\n                    hash = ( hash + Q - ( mf * haystack.charAt(i - m) % Q ) ) % Q;\\n                    hash = ( hash * R + haystack.charAt(i) ) % Q;\\n                }\\n            }\\n            return -1;\\n        }\\n        \\n        private static int hash(String s, int from, int to) {\\n            int hash = 0;\\n            for ( int i = from; i < to; i++ ) {\\n                hash = ( ( hash * R ) % Q + s.charAt(i) ) % Q;\\n            }\\n            return hash;\\n        }\\n    }",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\n        private static final int R = 31;\\n        private static final int Q = 997;\\n    //    private static final int Q = java.math.BigInteger.probablePrime(16, new java.util.Random(System.currentTimeMillis())).intValue();\\n        \\n        public int strStr(String haystack, String needle) {\\n            if ( needle.length() > haystack.length() ) { return -1; }",
                "codeTag": "Java"
            },
            {
                "id": 13324,
                "title": "my-c-code-that-implements-boyer-moore-string-search-got-accepted-in-12ms",
                "content": "I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules.\\n\\n\\tchar *strStr(char *haystack, char *needle) {\\n\\t\\tif(NULL==haystack||NULL==needle)\\n\\t\\t\\treturn NULL;\\n\\t\\tint plen = strlen(needle);\\n\\t\\tint slen = strlen(haystack);\\n\\t\\tif(0==plen)\\n\\t\\t\\treturn haystack;\\n\\t\\telse if(plen>slen)\\n\\t\\t\\treturn NULL;\\n\\t\\tint badChar[256];\\n\\t\\tint np = 0;\\n\\t\\tint i,j,k;\\n\\n\\t\\tfor(i=0;i<256;i++)\\n\\t\\t\\tbadChar[i] = plen;\\n    \\n\\t\\twhile(np<plen)\\n\\t\\t{\\n\\t\\t\\tbadChar[*(needle+np)] = plen-np-1;\\n\\t\\t\\tnp++;\\n\\t\\t}\\n\\n\\t\\tint* goodSuffix = new int[plen];\\n\\n\\t\\tint prefix_index = plen;\\n\\t\\tfor(i=plen-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tgoodSuffix[i] = prefix_index;\\n\\t\\t\\tif(*(needle+i)==*(needle+plen-1-i)&&prefix_index==i+1)\\n\\t\\t\\t\\tprefix_index = i;\\n\\t\\t}\\n\\t\\n\\t\\tfor(i=0;i<plen-1;i++)\\n\\t\\t{\\n\\t\\t\\tj = plen-1, k = 0;\\n\\t\\t\\twhile(k<i&&*(needle+j)==*(needle+i-k))\\n\\t\\t\\t{j--;k++;}\\n\\t\\t\\tif(*(needle+plen-1)==*(needle+i))\\n\\t\\t\\t\\tgoodSuffix[j] = plen-1-i;\\n\\t\\t}\\n\\t\\tgoodSuffix[plen-1] = 0;\\n\\n\\t\\tint sp = 0;\\n\\t\\twhile(sp<slen)\\n\\t\\t{\\n\\t\\t\\ti = plen-1;\\n\\t\\t\\twhile(i>=0&&*(haystack+sp+i)==*(needle+i))\\n\\t\\t\\t\\ti--;\\n\\t\\t\\tif(i<0)\\n\\t\\t\\t\\treturn haystack+sp;\\n\\t\\t\\tint bj = badChar[*(haystack+sp+i)] - plen + i + 1;\\n\\t\\t\\tsp += (bj>goodSuffix[i]?bj:goodSuffix[i]);\\n\\t\\t}\\n\\n\\t\\tdelete goodSuffix;\\n\\t\\treturn NULL;\\n\\t}",
                "solutionTags": [],
                "code": "I implements Boyer-Moore string search algorithm and it turns out to be very efficient (accepted in 12ms). Boyer-Moore uses information gained by preprocessing the pattern string to skip as many alignments as possible. A shift is calculated by applying both rules: the bad character rule and the good suffix rule. The actual shifting offset is the maximum of the shifts calculated by these rules.\\n\\n\\tchar *strStr(char *haystack, char *needle) {\\n\\t\\tif(NULL==haystack||NULL==needle)\\n\\t\\t\\treturn NULL;\\n\\t\\tint plen = strlen(needle);\\n\\t\\tint slen = strlen(haystack);\\n\\t\\tif(0==plen)\\n\\t\\t\\treturn haystack;\\n\\t\\telse if(plen>slen)\\n\\t\\t\\treturn NULL;\\n\\t\\tint badChar[256];\\n\\t\\tint np = 0;\\n\\t\\tint i,j,k;\\n\\n\\t\\tfor(i=0;i<256;i++)\\n\\t\\t\\tbadChar[i] = plen;\\n    \\n\\t\\twhile(np<plen)\\n\\t\\t{\\n\\t\\t\\tbadChar[*(needle+np)] = plen-np-1;\\n\\t\\t\\tnp++;\\n\\t\\t}\\n\\n\\t\\tint* goodSuffix = new int[plen];\\n\\n\\t\\tint prefix_index = plen;\\n\\t\\tfor(i=plen-1;i>=0;i--)\\n\\t\\t{\\n\\t\\t\\tgoodSuffix[i] = prefix_index;\\n\\t\\t\\tif(*(needle+i)==*(needle+plen-1-i)&&prefix_index==i+1)\\n\\t\\t\\t\\tprefix_index = i;\\n\\t\\t}\\n\\t\\n\\t\\tfor(i=0;i<plen-1;i++)\\n\\t\\t{\\n\\t\\t\\tj = plen-1, k = 0;\\n\\t\\t\\twhile(k<i&&*(needle+j)==*(needle+i-k))\\n\\t\\t\\t{j--;k++;}\\n\\t\\t\\tif(*(needle+plen-1)==*(needle+i))\\n\\t\\t\\t\\tgoodSuffix[j] = plen-1-i;\\n\\t\\t}\\n\\t\\tgoodSuffix[plen-1] = 0;\\n\\n\\t\\tint sp = 0;\\n\\t\\twhile(sp<slen)\\n\\t\\t{\\n\\t\\t\\ti = plen-1;\\n\\t\\t\\twhile(i>=0&&*(haystack+sp+i)==*(needle+i))\\n\\t\\t\\t\\ti--;\\n\\t\\t\\tif(i<0)\\n\\t\\t\\t\\treturn haystack+sp;\\n\\t\\t\\tint bj = badChar[*(haystack+sp+i)] - plen + i + 1;\\n\\t\\t\\tsp += (bj>goodSuffix[i]?bj:goodSuffix[i]);\\n\\t\\t}\\n\\n\\t\\tdelete goodSuffix;\\n\\t\\treturn NULL;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2471084,
                "title": "javascript-the-answer-interviewers-are-looking-for-also-a-one-liner",
                "content": "For those who want some humor, you can submit this as a valid solution, but that\\'s not the point of this problem. Just note that we are implementing `strStr` (in C) or `indexOf` in Java and JavaScript.\\n```\\nvar strStr = (haystack, needle) => haystack.indexOf(needle);\\n```\\nAlso, it\\'s not `O(1)`, it depends on the implementation of `indexOf` which is basically the function we are recreating.\\n\\nThe point of the problem is to implement it without using any String functions. While you\\'re just implementing something that\\'s already implemented, this is to show case your fundamentals of programming with strings and arrays using their bare structures.\\n```\\nvar strStr = function(haystack, needle) {\\n  if (haystack.length >= needle.length) {\\n    let j;\\n    for (let i = 0; i < haystack.length; i++) {\\n      for (j = 0; j < needle.length; j++) {\\n        if (needle[j] !== haystack[i + j]) break;\\n      }\\n      if (j === needle.length) return i;\\n    }\\n  }\\n  return -1;\\n};\\n```\\n\\n### Possible test cases\\nIt would be a bonus if you recognize the use case where the size of `needle` were bigger than `haystack`. \\n\\nThe description mentions asking about the case for an empty string. You could do that as well.\\n\\n### The solution\\nWe also want to reduce the need for `if` checks so leave the function as soon as we find a match.\\n\\nI put the `let j;` declaration outside of the loops because I did not want to redeclare the same variable that we can simply just reuse. This is a minor optimization, but good to note.\\n\\nI didn\\'t use any string functions. I could have also used the `substring` method to extract a `needle` sized string out of `haystack`, but I didn\\'t. If you do use a string function, you would have to consider the Big O that the function uses. But again, it\\'s not the point of the question, so comparing the strings at each index is likely how it should be if you want to implement it into an optimized function in a given library or code-base.\\n\\n### Big-O TC (Time Complexity)\\n\\n`n` = length of haystack\\n`m` = length of needle\\n\\n`O(n*m)` or `O(n2)` is the worst case scenario (where the needle is not found).\\n\\n`O(n)` in the best case scenario.\\n\\n### Big-O SC (Space Complexity)\\n\\n`O(1)` since we\\'re not using any data structure to store values and reusing others.\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = (haystack, needle) => haystack.indexOf(needle);\\n```\n```\\nvar strStr = function(haystack, needle) {\\n  if (haystack.length >= needle.length) {\\n    let j;\\n    for (let i = 0; i < haystack.length; i++) {\\n      for (j = 0; j < needle.length; j++) {\\n        if (needle[j] !== haystack[i + j]) break;\\n      }\\n      if (j === needle.length) return i;\\n    }\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089672,
                "title": "javascript-97-72ms",
                "content": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n  if (!needle) return 0\\n  let idx = 0\\n  for (let i = 0; i < haystack.length; i++) {\\n    if (haystack[i] != needle[idx]) {\\n      i = i-idx\\n      idx = 0\\n    } else {\\n      if (idx == needle.length-1) return i-idx\\n      idx++\\n    }\\n  }\\n  return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n  if (!needle) return 0\\n  let idx = 0\\n  for (let i = 0; i < haystack.length; i++) {\\n    if (haystack[i] != needle[idx]) {\\n      i = i-idx\\n      idx = 0\\n    } else {\\n      if (idx == needle.length-1) return i-idx\\n      idx++\\n    }\\n  }\\n  return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497180,
                "title": "c-rabin-karp-rolling-hash-100",
                "content": "Adapted from CLRS\\n\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // Base cases\\n        auto n = haystack.length(); auto m = needle.length();\\n        if (m == 0) return 0;\\n        if (n == 0 || n < m) return -1;\\n \\n        // Hashing:\\n        // or using fast integer power algo: \\n        // radix^(m - 1) % prime: int h = pow(d, m - 1) % q;                                            \\n        int d = 31;                                                     // radix - beneficial to make smaller      \\n        int q = 15486703;                                               // some big prime\\n        long p = 0; long t = 0; long h = 1;\\n       \\n        for (auto i = 0; i < m; ++i) {                                  // preprocessing hashes for pattern and text\\n            if (i != m - 1) \\n                h = (d * h) % q;\\n            p = (d * p + needle[i]) % q;\\n            t = (d * t + haystack[i]) % q;\\n        }\\n        \\n        for (auto s = 0; s < n - m + 1; ++s) {\\n            if (t < 0) t += q;                                           // fix negative hash\\n            if (p == t)                                                  // hash matched\\n                if (needle == haystack.substr(s, m))                     // collision handling\\n                    return s;\\n            if (s < n - m)                                               // updating hash: pop front char, push new\\n                t = (d * (t - haystack[s] * h) + haystack[s + m]) % q;\\n        }\\n        \\n        return -1;   \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // Base cases\\n        auto n = haystack.length(); auto m = needle.length();\\n        if (m == 0) return 0;\\n        if (n == 0 || n < m) return -1;\\n \\n        // Hashing:\\n        // or using fast integer power algo: \\n        // radix^(m - 1) % prime: int h = pow(d, m - 1) % q;                                            \\n        int d = 31;                                                     // radix - beneficial to make smaller      \\n        int q = 15486703;                                               // some big prime\\n        long p = 0; long t = 0; long h = 1;\\n       \\n        for (auto i = 0; i < m; ++i) {                                  // preprocessing hashes for pattern and text\\n            if (i != m - 1) \\n                h = (d * h) % q;\\n            p = (d * p + needle[i]) % q;\\n            t = (d * t + haystack[i]) % q;\\n        }\\n        \\n        for (auto s = 0; s < n - m + 1; ++s) {\\n            if (t < 0) t += q;                                           // fix negative hash\\n            if (p == t)                                                  // hash matched\\n                if (needle == haystack.substr(s, m))                     // collision handling\\n                    return s;\\n            if (s < n - m)                                               // updating hash: pop front char, push new\\n                t = (d * (t - haystack[s] * h) + haystack[s + m]) % q;\\n        }\\n        \\n        return -1;   \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294148,
                "title": "javascript-solution",
                "content": "JavaScript:\\n\\n```\\nvar strStr = function(haystack, needle) {\\n    if(!needle) return 0;\\n    if(!haystack) return -1;\\n    if(haystack.length<needle.length) return -1;\\n\\n    \\n    let i=0;\\n    let j=0;\\n    \\n    while(i<haystack.length && j<needle.length){\\n        \\n        if (haystack[i]===needle[j]){\\n            ++i;\\n            ++j;\\n        } else {\\n            i = (++i) - j;\\n            j = 0;\\n        }\\n    }\\n    if(j===needle.length) return i-j;\\n\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    if(!needle) return 0;\\n    if(!haystack) return -1;\\n    if(haystack.length<needle.length) return -1;\\n\\n    \\n    let i=0;\\n    let j=0;\\n    \\n    while(i<haystack.length && j<needle.length){\\n        \\n        if (haystack[i]===needle[j]){\\n            ++i;\\n            ++j;\\n        } else {\\n            i = (++i) - j;\\n            j = 0;\\n        }\\n    }\\n    if(j===needle.length) return i-j;\\n\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13311,
                "title": "kmp-solution-in-java",
                "content": "Hi guys!\\n\\nHere is a pretty concise implementation of a Knuth-Morris-Pratt algorithm in Java.\\nInstead of commenting and explaining the approach I want to give a really-really useful link to [TopCoder tutorial on the topic][1]. The code is just a slightly modified version of the code from the tutorial and an explanation there is perfect.\\n\\n----\\n\\n    public class Solution {\\n        \\n        private int[] failureFunction(char[] str) {\\n            int[] f = new int[str.length+1];\\n            for (int i = 2; i < f.length; i++) {\\n                int j = f[i-1];\\n                while (j > 0 && str[j] != str[i-1]) j = f[j];\\n                if (j > 0 || str[j] == str[i-1]) f[i] = j+1;\\n            }\\n            return f;\\n        }\\n    \\n        public int strStr(String haystack, String needle) {\\n            if (needle.length() == 0) return 0;\\n            if (needle.length() <= haystack.length()) {\\n                int[] f = failureFunction(needle.toCharArray());\\n                int i = 0, j = 0;\\n                while (i < haystack.length()) {\\n                    if (haystack.charAt(i) == needle.charAt(j)) {\\n                        i++; j++;\\n                        if (j == needle.length()) return i-j;\\n                    } else if (j > 0) j = f[j];\\n                    else i++;\\n                }\\n            }\\n            return -1;\\n        }\\n    }\\n\\n\\n  [1]: https://www.topcoder.com/community/data-science/data-science-tutorials/introduction-to-string-searching-algorithms/",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        private int[] failureFunction(char[] str) {\\n            int[] f = new int[str.length+1];\\n            for (int i = 2; i < f.length; i++) {\\n                int j = f[i-1];\\n                while (j > 0 && str[j] != str[i-1]) j = f[j];\\n                if (j > 0 || str[j] == str[i-1]) f[i] = j+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13338,
                "title": "1ms-runtime-solution-in-c",
                "content": "    int strStr(char *haystack, char *needle) {\\n    \\tchar *p, *q;\\n    \\tint i, len = strlen(haystack) - strlen(needle);\\n    \\n    \\tfor (i = 0; i <= len; i++) {\\n    \\t\\tp = haystack + i;\\n    \\t\\tq = needle;\\n    \\t\\twhile (*q && *p == *q) {\\n    \\t\\t\\t++p;\\n    \\t\\t\\t++q;\\n    \\t\\t}\\n    \\t\\tif (*q == 0)\\n    \\t\\t\\treturn i;\\n    \\t}\\n    \\treturn -1;\\n    }",
                "solutionTags": [],
                "code": "    int strStr(char *haystack, char *needle) {\\n    \\tchar *p, *q;\\n    \\tint i, len = strlen(haystack) - strlen(needle);\\n    \\n    \\tfor (i = 0; i <= len; i++) {\\n    \\t\\tp = haystack + i;\\n    \\t\\tq = needle;\\n    \\t\\twhile (*q && *p == *q) {\\n    \\t\\t\\t++p;\\n    \\t\\t\\t++q;\\n    \\t\\t}\\n    \\t\\tif (*q == 0)\\n    \\t\\t\\treturn i;\\n    \\t}\\n    \\treturn -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3627068,
                "title": "novel-approach-with-detailed-explanation-python3",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the question says **haystack and needle consist of only lowercase English characters**, I replace needle into \"A\" inside haystack. If there is no needle in the haystack, nothing changes so \"new\" will be the same as haystack. However, if there is needle in haystack it will replace needle into \"A\" and we just need to return first \"A\" from \"new\".\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        new = haystack.replace(needle,\\'A\\')\\n        if (new == haystack): return -1\\n        else: return new.index(\\'A\\')\\n        \\n        \\n        \\n        \\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        new = haystack.replace(needle,\\'A\\')\\n        if (new == haystack): return -1\\n        else: return new.index(\\'A\\')\\n        \\n        \\n        \\n        \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410567,
                "title": "best-solution-by-java-in-one-line-runtime-in-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n         return haystack.indexOf(needle);\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/d9059796-da65-4784-9096-19339350bcb9_1681342328.2017047.png)\\n\\n### please upvote if you liked the solution.\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n         return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251838,
                "title": "c-shortest-solution-pretty-easy-100-beast",
                "content": "# Complexity\\n- Time complexity: O(n)\\n \\nhttps://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/submissions/908325998/\\n     this is the real shortest solution in one line\\n-  \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string ha, string needle) {\\n        // if needle doesn\\'t exist in haystack\\n        if(ha.find(needle) == string :: npos) return -1;\\n        \\n        int n = ha.size() , m = needle.size() ;\\n\\n        for(int i = 0 ; i < n - m + 1 ; i++ )\\n            // if any substring in haystack with size m == needle \\n            if(needle == ha.substr(i,m) )\\n                return i;\\n        return -1;\\n    }\\n};\\n```\\n# don\\'t miss UPVOTE <3",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string ha, string needle) {\\n        // if needle doesn\\'t exist in haystack\\n        if(ha.find(needle) == string :: npos) return -1;\\n        \\n        int n = ha.size() , m = needle.size() ;\\n\\n        for(int i = 0 ; i < n - m + 1 ; i++ )\\n            // if any substring in haystack with size m == needle \\n            if(needle == ha.substr(i,m) )\\n                return i;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251338,
                "title": "beats-100-0ms-sliding-window-two-pointers-easiest-c-code-beginner-friendly",
                "content": "# Intuition\\nWe have to find a window string(needle) in a haystack string. So we create two pointers which are used to traverse through string checking for first appearance of string.\\n\\n# Approach\\nFor loop for traversing through haystack. Create two pointers (j and ptr). j gets intialized as beginning of needle. create a count.\\nCreate a while loop with conditon that, char at both pointers is equal, and ptr is less than needle length(so that we don\\'t corss above our window)\\nAfter while loop ends if count==needle length, then voila! we have found our needle in our haystack. \\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n\\nPlease Upvote!\\nP.S:-Trying out posting solution for first time.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        for(int i=0;i<haystack.length();i++)\\n        {\\n            int j=i;\\n            int ptr=0;\\n            int count=0;\\n            while(haystack[j]==needle[ptr] && ptr<needle.length())\\n            {\\n                j++;\\n                ptr++;\\n                count++;\\n            }\\n            if(count==needle.length()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        for(int i=0;i<haystack.length();i++)\\n        {\\n            int j=i;\\n            int ptr=0;\\n            int count=0;\\n            while(haystack[j]==needle[ptr] && ptr<needle.length())\\n            {\\n                j++;\\n                ptr++;\\n                count++;\\n            }\\n            if(count==needle.length()) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818661,
                "title": "python-97-52-faster-4-lines-o-n-solution",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        m,n=len(haystack),len(needle)\\n        for i in range(m):\\n            if haystack[i:i+n]==needle: return i\\n        return -1\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        m,n=len(haystack),len(needle)\\n        for i in range(m):\\n            if haystack[i:i+n]==needle: return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491091,
                "title": "python-easy-solution",
                "content": "Solution 1:\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        if needle not in haystack:\\n            return -1\\n        return haystack.index(needle)\\n```\\nSolution 2:\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        index = 0\\n        while (index <= len(haystack)-len(needle)):                \\n            if haystack[index:index+len(needle)] == needle:\\n                return index\\n            index += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        if needle not in haystack:\\n            return -1\\n        return haystack.index(needle)\\n```\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        index = 0\\n        while (index <= len(haystack)-len(needle)):                \\n            if haystack[index:index+len(needle)] == needle:\\n                return index\\n            index += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1431678,
                "title": "java-rabin-karp-explained-line-by-line-i-struggled-with-it-too",
                "content": "Hi everyone,\\n\\nI have seen many Rabin-Karp solutions here, but all of them left me confused to some degree (I guess I\\'m not as smart as other folks, or I failed to find the best solution for me in the haystack of so many solutions). So I wrote my own, and I hope my explanation works better for some people.\\n\\nThis solution when submitted runs in about 4ms (at least in August 2021... these things change apparently). The solution is linear in time, it should run in worst case O(n+m), n being the length of haystack and m being the length of needle. Memory is O(1), we just use a few integer variables to hold the hashes, indexes, prime, etc. I had originally written this to process the char[] version of the Strings (by calling toCharArray() on them at the beginning), but this duplicates the memory used to store each string, as can be seen in [the code for toCharArray()](https://hg.openjdk.java.net/jdk7u/jdk7u6/jdk/file/8c2c5d63a17e/src/share/classes/java/lang/String.java#l2751). That version was a bit faster on most runs.\\n\\nWhen stripped of comments, this implementation has fewer than 50 lines.\\n\\nFor more information, please check [Wikipedia\\'s article on Rabin-Karp](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm) and the explanation in Sedgewick and Wayne\\'s \"Algorithms\" book, where this problem is specifically addressed (their code is [here](https://algs4.cs.princeton.edu/53substring/RabinKarp.java.html)). I also found these slides explaining this and the other linear string matching algorithms: [Substring search](https://algs4.cs.princeton.edu/lectures/keynote/53SubstringSearch-2x2.pdf).\\n\\n\\n```\\nclass Solution {\\n    // Returns the index of the first occurrence of needle in haystack, using an \\n    // implementation of the Rabin\\u2013Karp algorithm\\n    public int strStr(String haystack, String needle) {\\n        // We need a prime to minimize the chance of collisions, as in a HashMap.\\n        // The reason a prime is better is that when we generate hashcodes that are\\n        // multiples of each other, they don\\'t land on the same bucket when we calculate\\n        // their mod (num_buckets) (unless they are multiples of the chosen prime).\\n        // As of where I got this from, I just searched for primes on Wikipedia ;)\\n        final int prime = 9999991;\\n        // Most people use a base here representative of the base the data is encoded in.\\n        // I have found 10 to be more intuitive and to work as fast as others,\\n        // at least for the leetcode test dataset.\\n\\t\\t// Sedgewick uses 256, so feel free to switch to that, or to 26 if you restrict your values\\n\\t\\t// to a-z.\\n        final int base = 10;\\n        \\n        // Handle cornercase: needle is empty\\n        if (needle.length() == 0) return 0;\\n        // Handle cornercase: needle is longer than haystack\\n        if (haystack.length() < needle.length()) return -1;\\n        \\n        // Since we are expressing the string in the hashcode as \\n        // char[i]*base^N + char[i-1] * base^N-1....+char[window.length()-1],\\n        // when we remove the most significant digit in each step a few lines down from here,\\n        // we need to multiply the letter we are removing from the window by the base elevated\\n        // to the number of digits in the window (char[i]*base^N) mod prime.\\n        // Needle (and the window) can have up to 50,000 characters as per requirements,\\n        // so this can go up to Math.pow(10, 50,000), which in Java just returns \"Infinity\" - it\\'s a huge number.\\n        // To mitigate this, since we are going to be using this number to calculate a hash mod prime,\\n        // we can multiply the base n times and calculate its mod prime factor by factor.\\n        // This works because (a*b)%p = ((a%p)*(b%p))%p \\n        // (https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities))\\n        // Here we pre-calculate this number so we can reuse it, as we must do it iteratively \\n        // and it would consume cycles character by character otherwise.\\n        int maxBase = 1;\\n        for (int i = 1; i < needle.length(); i++) {\\n            maxBase = (maxBase * base) % prime;\\n        }\\n\\n        int needlehash = hash(needle, needle.length(), base, prime);\\n        int haystackhash = hash(haystack, needle.length(), base, prime);\\n        \\n        // Did we get lucky with the first (needle.length()) characters?\\n        if (needlehash == haystackhash) return 0;\\n        \\n\\t\\t// This loop slides the window of size needle.length() along the haystack.\\n\\t\\t// For example for [a,b,c,d,...] and a needle of size 3,\\n\\t\\t// it goes from [a,b,c] to [b,c,d] and so on.\\n\\t\\t// At each step, it recalculates the window\\'s hashcode in O(1), by reusing the previous result. This is the key of the algorithm.\\n\\t\\t// For more info, please check https://en.wikipedia.org/wiki/Rolling_hash\\n        for (int i = needle.length(); i < haystack.length(); i++) {\\n            // Take first char out of the hash. You may note here that instead of subtracting the value for the most significant\\n\\t\\t\\t// character directly from haystackhash, I\\'m subtracting it from haystackhash+prime. The reason is that, since I\\'m\\n\\t\\t\\t// subtracting 2 numbers mod prime, the result could easily become negative. To prevent this, we add prime as the result \\n\\t\\t\\t// should be the same (a%p = (a+p)%p) https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)\\n\\t\\t\\t// since now the number on the left of the subtraction is larger than the number on the right, the result\\n\\t\\t\\t// cannot be negative.\\n            haystackhash = (haystackhash+prime - (maxBase*haystack.charAt(i-needle.length())%prime))%prime;\\n            \\n            // Shift to the left, add new char\\n            haystackhash = (haystackhash*base + haystack.charAt(i))%prime;\\n            \\n            // hashes matching can mean a match or a collision. Only way to tell one from the other\\n            // is to linearly verify if the match on hash is also a match character by character.\\n            if (needlehash == haystackhash && checkSolution(haystack, needle, i-needle.length()+1)) return i-needle.length()+1;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // Calculates a hashcode similar to how java.lang.String does it.\\n    // We reimplement it here because we need control over what the prime and the base is.\\n    // Java uses base=31 and prime=Integer.MAX_VALUE (implicitly)\\n    private int hash(String chars, int count, int base, int prime) {\\n        int hash = 0;\\n        for (int i = 0; i < count; i++) {\\n            char c = chars.charAt(i);\\n            hash = (hash * base + c) % prime;\\n        }\\n        \\n        return hash;\\n    }\\n    \\n    // Check solution linearly, fail fast on first character not matching\\n    private boolean checkSolution(String haystack, String needle, int i) {\\n        // Many strings have the same hashcode, we need to check whether this is a collision\\n        for (int j = 0; j < needle.length(); j++) {\\n            if (haystack.charAt(j+i) != needle.charAt(j)) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Returns the index of the first occurrence of needle in haystack, using an \\n    // implementation of the Rabin\\u2013Karp algorithm\\n    public int strStr(String haystack, String needle) {\\n        // We need a prime to minimize the chance of collisions, as in a HashMap.\\n        // The reason a prime is better is that when we generate hashcodes that are\\n        // multiples of each other, they don\\'t land on the same bucket when we calculate\\n        // their mod (num_buckets) (unless they are multiples of the chosen prime).\\n        // As of where I got this from, I just searched for primes on Wikipedia ;)\\n        final int prime = 9999991;\\n        // Most people use a base here representative of the base the data is encoded in.\\n        // I have found 10 to be more intuitive and to work as fast as others,\\n        // at least for the leetcode test dataset.\\n\\t\\t// Sedgewick uses 256, so feel free to switch to that, or to 26 if you restrict your values\\n\\t\\t// to a-z.\\n        final int base = 10;\\n        \\n        // Handle cornercase: needle is empty\\n        if (needle.length() == 0) return 0;\\n        // Handle cornercase: needle is longer than haystack\\n        if (haystack.length() < needle.length()) return -1;\\n        \\n        // Since we are expressing the string in the hashcode as \\n        // char[i]*base^N + char[i-1] * base^N-1....+char[window.length()-1],\\n        // when we remove the most significant digit in each step a few lines down from here,\\n        // we need to multiply the letter we are removing from the window by the base elevated\\n        // to the number of digits in the window (char[i]*base^N) mod prime.\\n        // Needle (and the window) can have up to 50,000 characters as per requirements,\\n        // so this can go up to Math.pow(10, 50,000), which in Java just returns \"Infinity\" - it\\'s a huge number.\\n        // To mitigate this, since we are going to be using this number to calculate a hash mod prime,\\n        // we can multiply the base n times and calculate its mod prime factor by factor.\\n        // This works because (a*b)%p = ((a%p)*(b%p))%p \\n        // (https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities))\\n        // Here we pre-calculate this number so we can reuse it, as we must do it iteratively \\n        // and it would consume cycles character by character otherwise.\\n        int maxBase = 1;\\n        for (int i = 1; i < needle.length(); i++) {\\n            maxBase = (maxBase * base) % prime;\\n        }\\n\\n        int needlehash = hash(needle, needle.length(), base, prime);\\n        int haystackhash = hash(haystack, needle.length(), base, prime);\\n        \\n        // Did we get lucky with the first (needle.length()) characters?\\n        if (needlehash == haystackhash) return 0;\\n        \\n\\t\\t// This loop slides the window of size needle.length() along the haystack.\\n\\t\\t// For example for [a,b,c,d,...] and a needle of size 3,\\n\\t\\t// it goes from [a,b,c] to [b,c,d] and so on.\\n\\t\\t// At each step, it recalculates the window\\'s hashcode in O(1), by reusing the previous result. This is the key of the algorithm.\\n\\t\\t// For more info, please check https://en.wikipedia.org/wiki/Rolling_hash\\n        for (int i = needle.length(); i < haystack.length(); i++) {\\n            // Take first char out of the hash. You may note here that instead of subtracting the value for the most significant\\n\\t\\t\\t// character directly from haystackhash, I\\'m subtracting it from haystackhash+prime. The reason is that, since I\\'m\\n\\t\\t\\t// subtracting 2 numbers mod prime, the result could easily become negative. To prevent this, we add prime as the result \\n\\t\\t\\t// should be the same (a%p = (a+p)%p) https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)\\n\\t\\t\\t// since now the number on the left of the subtraction is larger than the number on the right, the result\\n\\t\\t\\t// cannot be negative.\\n            haystackhash = (haystackhash+prime - (maxBase*haystack.charAt(i-needle.length())%prime))%prime;\\n            \\n            // Shift to the left, add new char\\n            haystackhash = (haystackhash*base + haystack.charAt(i))%prime;\\n            \\n            // hashes matching can mean a match or a collision. Only way to tell one from the other\\n            // is to linearly verify if the match on hash is also a match character by character.\\n            if (needlehash == haystackhash && checkSolution(haystack, needle, i-needle.length()+1)) return i-needle.length()+1;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    // Calculates a hashcode similar to how java.lang.String does it.\\n    // We reimplement it here because we need control over what the prime and the base is.\\n    // Java uses base=31 and prime=Integer.MAX_VALUE (implicitly)\\n    private int hash(String chars, int count, int base, int prime) {\\n        int hash = 0;\\n        for (int i = 0; i < count; i++) {\\n            char c = chars.charAt(i);\\n            hash = (hash * base + c) % prime;\\n        }\\n        \\n        return hash;\\n    }\\n    \\n    // Check solution linearly, fail fast on first character not matching\\n    private boolean checkSolution(String haystack, String needle, int i) {\\n        // Many strings have the same hashcode, we need to check whether this is a collision\\n        for (int j = 0; j < needle.length(); j++) {\\n            if (haystack.charAt(j+i) != needle.charAt(j)) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015275,
                "title": "java-faster-than-100-brute-force",
                "content": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (\"\".equals(needle)) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            if (matches(i, haystack, needle)) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    private static boolean matches(int startIdx, String haystack, String needle) {\\n        for (int i = 0; i < needle.length(); i++) {\\n            if (haystack.charAt(startIdx + i) != needle.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (\"\".equals(needle)) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            if (matches(i, haystack, needle)) {\\n                return i;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    \\n    private static boolean matches(int startIdx, String haystack, String needle) {\\n        for (int i = 0; i < needle.length(); i++) {\\n            if (haystack.charAt(startIdx + i) != needle.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867375,
                "title": "simple-solution-faster-than-100",
                "content": "Runtime: **0 ms**, faster than **100.00%** of Java online submissions for Implement strStr().\\nMemory Usage: 39.2 MB, less than **39.51%** of Java online submissions for Implement strStr().\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.isEmpty() || haystack.equals(needle)) return 0;       \\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            String evalString = haystack.substring(i, i + needle.length());\\n            if (evalString.equals(needle)) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.isEmpty() || haystack.equals(needle)) return 0;       \\n        \\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n            String evalString = haystack.substring(i, i + needle.length());\\n            if (evalString.equals(needle)) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420127,
                "title": "faster-than-95-runtime-48-ms-memory-usage-36-mb-javascript",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n    const needleLength = needle.length;\\n    if(needleLength===0) return 0;\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack.substring(i,i+needleLength)===needle){\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    const needleLength = needle.length;\\n    if(needleLength===0) return 0;\\n    for(let i=0;i<haystack.length;i++){\\n        if(haystack.substring(i,i+needleLength)===needle){\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13034,
                "title": "javascript-kmp-beats-95",
                "content": "```\\nvar strStr = function(haystack, needle) {\\n    var m = haystack.length, n = needle.length;\\n    if(!n) return 0;\\n    var lps = kmpProcess(needle);\\n    for(var i = 0, j = 0; i < m;) {\\n        if(haystack[i] == needle[j]) {\\n            i++, j++;\\n        }\\n        if(j == n) return i - j;\\n        if(i < m && haystack[i] != needle[j]) {\\n            if(j) j = lps[j - 1];\\n            else i++;\\n        }\\n        \\n    }\\n    return -1;\\n};\\n\\nvar kmpProcess = function(needle) {\\n    var n = needle.length;\\n    var lps = new Array(n).fill(0);\\n    for (var i = 1, length = 0; i < n;) {\\n        if(needle[i] === needle[length]) {\\n            length++;\\n            lps[i] = length;\\n            i++;\\n        } else if (length) length = lps[length - 1];\\n        else {\\n            lps[i] = 0; \\n            i++;\\n        }\\n    }\\n    return lps;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(haystack, needle) {\\n    var m = haystack.length, n = needle.length;\\n    if(!n) return 0;\\n    var lps = kmpProcess(needle);\\n    for(var i = 0, j = 0; i < m;) {\\n        if(haystack[i] == needle[j]) {\\n            i++, j++;\\n        }\\n        if(j == n) return i - j;\\n        if(i < m && haystack[i] != needle[j]) {\\n            if(j) j = lps[j - 1];\\n            else i++;\\n        }\\n        \\n    }\\n    return -1;\\n};\\n\\nvar kmpProcess = function(needle) {\\n    var n = needle.length;\\n    var lps = new Array(n).fill(0);\\n    for (var i = 1, length = 0; i < n;) {\\n        if(needle[i] === needle[length]) {\\n            length++;\\n            lps[i] = length;\\n            i++;\\n        } else if (length) length = lps[length - 1];\\n        else {\\n            lps[i] = 0; \\n            i++;\\n        }\\n    }\\n    return lps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13163,
                "title": "my-solution-c-4ms",
                "content": "        int strStr(string haystack, string needle) {\\n\\n            if(haystack.size() < needle.size())\\n                return -1;\\n            \\n            int index = 0;\\n            int i,j;\\n            for(i = 0, j = 0;i < haystack.size() && j < needle.size();){\\n                if(haystack[i] == needle[j]){\\n                    i++; j++;\\n                }else{\\n                   index++;\\n                   i = index;\\n                   j = 0;\\n                }\\n            }\\n        \\n            if(j == needle.size())\\n                return index;\\n            return -1;\\n       }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        int strStr(string haystack, string needle) {\\n\\n            if(haystack.size() < needle.size())\\n                return -1;\\n            \\n            int index = 0;\\n            int i,j;\\n            for(i = 0, j = 0;i < haystack.size() && j < needle.size();){\\n                if(haystack[i] == needle[j]){\\n                    i++; j++;\\n                }else{\\n                   index++;\\n                   i = index;\\n                   j = 0;\\n                }\\n            }\\n        \\n            if(j == needle.size())\\n                return index;\\n            return -1;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 3368173,
                "title": "go-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc strStr(haystack string, needle string) int {\\n    for i:= 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle)+i] == needle {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc strStr(haystack string, needle string) int {\\n    for i:= 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle)+i] == needle {\\n            return i\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3250894,
                "title": "4-lines-of-code-and-magic-pointer-logic",
                "content": "# 4 Lines of code:---->TC:O(N)\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        n=len(needle)\\n        for i in range(len(haystack)):\\n            if haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```\\n# Pointers Approach:TC----->O(N)\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:return -1\\n        a,b=0,0\\n        while a<len(haystack) and b<len(needle):\\n            if haystack[a]==needle[b]:\\n                a+=1\\n                b+=1\\n            else:\\n                a=a-b+1\\n                b=0\\n        return a-b\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        n=len(needle)\\n        for i in range(len(haystack)):\\n            if haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:return -1\\n        a,b=0,0\\n        while a<len(haystack) and b<len(needle):\\n            if haystack[a]==needle[b]:\\n                a+=1\\n                b+=1\\n            else:\\n                a=a-b+1\\n                b=0\\n        return a-b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998941,
                "title": "javascript-short-fast-and-simple",
                "content": "```\\nvar strStr = function(h, n) {\\n    if (!n) return 0\\n    for (let j = 0, i = 0; i < h.length; i++) {\\n        if (h[i] === n[j]) j++\\n        else (i -= j, j = 0)\\n        if (j === n.length) return i - j + 1\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar strStr = function(h, n) {\\n    if (!n) return 0\\n    for (let j = 0, i = 0; i < h.length; i++) {\\n        if (h[i] === n[j]) j++\\n        else (i -= j, j = 0)\\n        if (j === n.length) return i - j + 1\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744624,
                "title": "boyer-moore-substring-search-using-both-bad-character-and-good-suffix-heuristics-explained",
                "content": "This problem may not really be asking for advanced substring search algorithms like KMP and Boyer-Moore etc, but it certainly provides scope for exploring them and testing their implementations here.\\n\\nI was able to understand Rabin Karp and KMP algorithms relatively easily but had a very hard time understanding the dynamics and implementation of Boyer-Moore algorithm. \\nIt is important because it is an efficient string-searching algorithm that is the standard benchmark for practical string-search literature. Many real life file system searches are implemented using this (eg: used in GNU\\'s grep)\\n\\nThe Boyer-Moore algorithm uses two different heuristics for determining the maximum possible shift distance in case of a mismatch: the \"bad character\" and the \"good suffix\" heuristics. \\n**The preprocessing for the good suffix heuristics is rather difficult to understand and to implement. Therefore, sometimes versions of the Boyer-Moore algorithm are found in which the good suffix heuristics is left away**. The argument is that the bad character heuristics would be sufficient and the good suffix heuristics would not save many comparisons. However, this is not true for small alphabets.\\n\\nIf **for simplicity one wants to restrict oneself to the bad character heuristics**, the [Horspool algorithm](https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/horsen.htm)  or the [Sunday algorithm](https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/sundayen.htm) are suited better.\\n\\nBecause of very rare references available for implementation of complete algorithm, I would like to explain java implementation.\\nAs a beginner, I personlly found [this video](https://www.youtube.com/watch?v=4Xyhb72LCX4) very helpful to grasp the overall working of the algorithm. Part 2 of [video is here](https://www.youtube.com/watch?v=Wj606N0IAsw)\\n\\nUnderstanding code directly could still be difficult. So you could better first try to understand the implementational details from [this webpage](https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/bmen.htm). \\nRefer [this wonderful SO answer](https://stackoverflow.com/questions/19345263/boyer-moore-good-suffix-heuristics) for more detailed explaination on good-suffix preprocessing code.\\n\\nFinally here goes the most awaited yet apparently frightening code:\\n```\\n//Boyer-Moore substring search using both bad-character and good-suffix heuristics simultaneously\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\tif (haystack == null || needle == null || haystack.length() < needle.length()) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else if (needle.isEmpty()) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tchar[] text = haystack.toCharArray();\\n\\t\\tchar[] pattern = needle.toCharArray();\\n\\t\\t\\n\\t\\tint[] borderPosition = new int[pattern.length+1]; /* referred as f in academic literatures;\\n\\t\\tf[i] contains the starting position of the widest border of the suffix of the pattern beginning at position i */\\n\\t\\tint[] shift = new int[pattern.length+1]; /* referred as s in academic literatures; \\n\\t\\tEach entry s[i] contains the shift distance of the pattern if a mismatch at position i \\u2013 1 occurs, \\n\\t\\ti.e. if the suffix of the pattern starting at position i has matched */\\n\\t\\tint alphabetSize = 256;\\n\\t\\t\\n\\t\\tint[] lastOccurence = preprocessBadCharacters(pattern, alphabetSize); // bad characters heuristic\\n\\t\\tpreprocessStrongSuffix(pattern, borderPosition, shift); //good suffix heuristic case 1\\n\\t\\tpreprocessPartialSuffix(borderPosition, shift, pattern.length); //good suffix heuristic case 2\\n\\t\\t// good-suffix reference: https://stackoverflow.com/questions/19345263/boyer-moore-good-suffix-heuristics\\n\\t\\t\\n\\t\\tint i=0, j; // i is start index of current window in text \\n\\t\\twhile(i<=text.length-pattern.length) {\\n\\t\\t\\tj = pattern.length-1; // we process pattern from right to left backwards\\n\\t\\t\\twhile(j>=0 && pattern[j]==text[i+j]) { // go left backwards till characters are matching in current window\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif(j<0) { // will be true only when there was a complete match found for pattern in text\\n\\t\\t\\t\\treturn i; //report match found\\n\\t\\t\\t\\t//use i=i+shift[0] if we want to find starting indices for all multiple matches\\n\\t\\t\\t} else { // mismatch found in current window comparison\\n\\t\\t\\t\\t/*  After a mismatch the pattern is shifted by the maximum of the values \\n\\t\\t\\t\\t    given by the good-suffix and the bad-character heuristics */\\n\\t\\t\\t\\ti = i + Math.max(shift[j+1], j-lastOccurence[text[i+j]]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessBadCharacters(char[] pattern, int alphabetSize) {\\n\\t\\tint[] lastOccurence = new int[alphabetSize]; //contains last occurrence index of each character in pattern\\n\\t\\tArrays.fill(lastOccurence, -1);\\n\\n\\t\\tfor (int i = 0; i < pattern.length; i++) {\\n\\t\\t\\tlastOccurence[pattern[i]] = i;\\n\\t\\t}\\n\\n\\t\\treturn lastOccurence;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessStrongSuffix(char[] pattern, int[] borderPosition, int[] shift) {\\n\\t\\tint m = pattern.length;\\n\\t\\t\\n\\t\\tint i = m, j = m + 1;\\n\\t\\tborderPosition[i] = j; // The suffix \\u03B5 beginning at position m has no border, therefore f[m] is set to m+1\\n\\t\\twhile (i > 0) {\\n\\t\\t\\t/* at this line, we know f[i], f[i+1], ... f[m]; If character at position i-1 is not  \\n               equal to character at j-1, then continue searching to right of the pattern for border */\\n\\t\\t\\twhile (j <= m && pattern[i - 1] != pattern[j - 1]) {\\n\\t\\t\\t\\t/* the character preceding the occurrence of t in pattern P is different than the mismatching  \\n\\t               character in P, we stop skipping the occurrences and shift the pattern from i to j */\\n\\t\\t\\t\\tif (shift[j] == 0) {\\n\\t\\t\\t\\t\\tshift[j] = j - i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj = borderPosition[j]; // get the start position of the border of suffix pattern[j] ... pattern[m-1]\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// pattern[i-1] matched with pattern[j-1], border is found. store the beginning position of border \\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t\\tborderPosition[i] = j;\\n\\t\\t}\\n\\t\\treturn shift;\\n\\t}\\n\\t\\n\\tpublic void preprocessPartialSuffix(int[] borderPosition, int[] shift, int m) {\\n\\t\\tint i, j;\\n\\t\\tj = borderPosition[0];\\n\\t\\tfor (i = 0; i <= m; i++) {\\n\\t\\t\\t/* set the border position of the first character of the pattern to all indices \\n\\t\\t\\t   in array shift having shift[i] = 0 */\\n\\t\\t\\tif (shift[i] == 0) {\\n\\t\\t\\t\\tshift[i] = j;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t/* suffix becomes shorter than borderPosition[0], use the position of next widest border as value of j */\\n\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\tj = borderPosition[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```\\n\\nThe Boyer\\u2013Moore algorithm as presented in the original paper has worst-case running time of O(n+m) only if the pattern does not appear in the text. When the pattern does occur in the text, running time of the original algorithm is O(nm) in the worst case. \\nIf the alphabet is large compared to the length of the pattern, the algorithm performs O(n/m) comparisons on the average. So Boyer-Moore algorithm is **extremely fast on large texts** (relative to the length of the pattern)\\nFor the very shortest patterns, the naive algorithm may be better.\\n\\nAny suggestions/feedbacks/improvements are welcome.\\n\\nHappy searching!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Boyer-Moore substring search using both bad-character and good-suffix heuristics simultaneously\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\tif (haystack == null || needle == null || haystack.length() < needle.length()) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else if (needle.isEmpty()) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t\\n\\t\\tchar[] text = haystack.toCharArray();\\n\\t\\tchar[] pattern = needle.toCharArray();\\n\\t\\t\\n\\t\\tint[] borderPosition = new int[pattern.length+1]; /* referred as f in academic literatures;\\n\\t\\tf[i] contains the starting position of the widest border of the suffix of the pattern beginning at position i */\\n\\t\\tint[] shift = new int[pattern.length+1]; /* referred as s in academic literatures; \\n\\t\\tEach entry s[i] contains the shift distance of the pattern if a mismatch at position i \\u2013 1 occurs, \\n\\t\\ti.e. if the suffix of the pattern starting at position i has matched */\\n\\t\\tint alphabetSize = 256;\\n\\t\\t\\n\\t\\tint[] lastOccurence = preprocessBadCharacters(pattern, alphabetSize); // bad characters heuristic\\n\\t\\tpreprocessStrongSuffix(pattern, borderPosition, shift); //good suffix heuristic case 1\\n\\t\\tpreprocessPartialSuffix(borderPosition, shift, pattern.length); //good suffix heuristic case 2\\n\\t\\t// good-suffix reference: https://stackoverflow.com/questions/19345263/boyer-moore-good-suffix-heuristics\\n\\t\\t\\n\\t\\tint i=0, j; // i is start index of current window in text \\n\\t\\twhile(i<=text.length-pattern.length) {\\n\\t\\t\\tj = pattern.length-1; // we process pattern from right to left backwards\\n\\t\\t\\twhile(j>=0 && pattern[j]==text[i+j]) { // go left backwards till characters are matching in current window\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\tif(j<0) { // will be true only when there was a complete match found for pattern in text\\n\\t\\t\\t\\treturn i; //report match found\\n\\t\\t\\t\\t//use i=i+shift[0] if we want to find starting indices for all multiple matches\\n\\t\\t\\t} else { // mismatch found in current window comparison\\n\\t\\t\\t\\t/*  After a mismatch the pattern is shifted by the maximum of the values \\n\\t\\t\\t\\t    given by the good-suffix and the bad-character heuristics */\\n\\t\\t\\t\\ti = i + Math.max(shift[j+1], j-lastOccurence[text[i+j]]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn -1;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessBadCharacters(char[] pattern, int alphabetSize) {\\n\\t\\tint[] lastOccurence = new int[alphabetSize]; //contains last occurrence index of each character in pattern\\n\\t\\tArrays.fill(lastOccurence, -1);\\n\\n\\t\\tfor (int i = 0; i < pattern.length; i++) {\\n\\t\\t\\tlastOccurence[pattern[i]] = i;\\n\\t\\t}\\n\\n\\t\\treturn lastOccurence;\\n\\t}\\n\\t\\n\\tpublic int[] preprocessStrongSuffix(char[] pattern, int[] borderPosition, int[] shift) {\\n\\t\\tint m = pattern.length;\\n\\t\\t\\n\\t\\tint i = m, j = m + 1;\\n\\t\\tborderPosition[i] = j; // The suffix \\u03B5 beginning at position m has no border, therefore f[m] is set to m+1\\n\\t\\twhile (i > 0) {\\n\\t\\t\\t/* at this line, we know f[i], f[i+1], ... f[m]; If character at position i-1 is not  \\n               equal to character at j-1, then continue searching to right of the pattern for border */\\n\\t\\t\\twhile (j <= m && pattern[i - 1] != pattern[j - 1]) {\\n\\t\\t\\t\\t/* the character preceding the occurrence of t in pattern P is different than the mismatching  \\n\\t               character in P, we stop skipping the occurrences and shift the pattern from i to j */\\n\\t\\t\\t\\tif (shift[j] == 0) {\\n\\t\\t\\t\\t\\tshift[j] = j - i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj = borderPosition[j]; // get the start position of the border of suffix pattern[j] ... pattern[m-1]\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// pattern[i-1] matched with pattern[j-1], border is found. store the beginning position of border \\n\\t\\t\\ti--;\\n\\t\\t\\tj--;\\n\\t\\t\\tborderPosition[i] = j;\\n\\t\\t}\\n\\t\\treturn shift;\\n\\t}\\n\\t\\n\\tpublic void preprocessPartialSuffix(int[] borderPosition, int[] shift, int m) {\\n\\t\\tint i, j;\\n\\t\\tj = borderPosition[0];\\n\\t\\tfor (i = 0; i <= m; i++) {\\n\\t\\t\\t/* set the border position of the first character of the pattern to all indices \\n\\t\\t\\t   in array shift having shift[i] = 0 */\\n\\t\\t\\tif (shift[i] == 0) {\\n\\t\\t\\t\\tshift[i] = j;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t/* suffix becomes shorter than borderPosition[0], use the position of next widest border as value of j */\\n\\t\\t\\tif (i == j) {\\n\\t\\t\\t\\tj = borderPosition[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471856,
                "title": "python-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle in haystack:\\n            return haystack.index(needle)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle in haystack:\\n            return haystack.index(needle)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 262799,
                "title": "python-kmp-solution-with-comments",
                "content": "```python\\nclass Solution:\\n    \\n    ################################\\n    # The simpler pythonic method: #\\n    ################################\\n    # if not needle:\\n    #     return 0    \\n    # return haystack.index(needle) if (needle in haystack) else -1\\n\\n    \\n    ########################\\n    # Create the KMP array #\\n    ########################\\n    def kmp_partial(self, pat):\\n        ret = [0]\\n        for i in range(1, len(pat)):\\n            j = ret[i-1]\\n            while j > 0 and pat[i] != pat[j]:\\n                j = ret[j-1]\\n            ret.append(j+1 if pat[i] == pat[j] else j)\\n        return ret\\n    # End of kmp_partial(...)\\n    \\n    \\n    ##################################\\n    # Find the pattern in the string #\\n    ##################################\\n    def strStr(self, string: str, pattern: str) -> int:\\n        \\n        if not pattern: \\n            return 0\\n        \\n        KMP = self.kmp_partial(pattern)\\n        j = 0\\n        \\n        for i in range(len(string)):\\n            \\n            # While \"j\" is larger than zero (coz we may call \"j-1\") and string[i] != pattern[j]...\\n            # \"j\" is updated/decremented (recall that \"j\" is a pointer to the KMP array)\\n            # \\n            # When the while loop ends, either \"j\" becomes zero.. or\\n            # string[i] == pattern[j]\\n            while j > 0 and string[i] != pattern[j]:\\n                j = KMP[j-1]\\n            \\n            # Next, we check if the characters in string and pattern match. \\n            # If they do, increment \"j\" (note that \"i\" is always incremented automatically by the outer for loop).\\n            if string[i] == pattern[j]:\\n                j += 1\\n                \\n            # Check if pointer \"j\" is out of the pattern, if it is, it means we\\'ve found the pattern in the string.\\n            if j == len(pattern):\\n                return (i - j + 1)\\n\\t\\t\\t\\t\\n        # End of for loop.\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    ################################\\n    # The simpler pythonic method: #\\n    ################################\\n    # if not needle:\\n    #     return 0    \\n    # return haystack.index(needle) if (needle in haystack) else -1\\n\\n    \\n    ########################\\n    # Create the KMP array #\\n    ########################\\n    def kmp_partial(self, pat):\\n        ret = [0]\\n        for i in range(1, len(pat)):\\n            j = ret[i-1]\\n            while j > 0 and pat[i] != pat[j]:\\n                j = ret[j-1]\\n            ret.append(j+1 if pat[i] == pat[j] else j)\\n        return ret\\n    # End of kmp_partial(...)\\n    \\n    \\n    ##################################\\n    # Find the pattern in the string #\\n    ##################################\\n    def strStr(self, string: str, pattern: str) -> int:\\n        \\n        if not pattern: \\n            return 0\\n        \\n        KMP = self.kmp_partial(pattern)\\n        j = 0\\n        \\n        for i in range(len(string)):\\n            \\n            # While \"j\" is larger than zero (coz we may call \"j-1\") and string[i] != pattern[j]...\\n            # \"j\" is updated/decremented (recall that \"j\" is a pointer to the KMP array)\\n            # \\n            # When the while loop ends, either \"j\" becomes zero.. or\\n            # string[i] == pattern[j]\\n            while j > 0 and string[i] != pattern[j]:\\n                j = KMP[j-1]\\n            \\n            # Next, we check if the characters in string and pattern match. \\n            # If they do, increment \"j\" (note that \"i\" is always incremented automatically by the outer for loop).\\n            if string[i] == pattern[j]:\\n                j += 1\\n                \\n            # Check if pointer \"j\" is out of the pattern, if it is, it means we\\'ve found the pattern in the string.\\n            if j == len(pattern):\\n                return (i - j + 1)\\n\\t\\t\\t\\t\\n        # End of for loop.\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 12817,
                "title": "straight-forward-c-solution-3-to-6ms",
                "content": "I felt like this was the obvious answer yet I didn't see it posted, so I decided to do so myself.\\n```\\n    int strStr(string haystack, string needle) \\n    {\\n        for (int i = 0; i <= (int)(haystack.length() - needle.length()); i++)\\n        {\\n            if (haystack.substr(i, needle.length()) == needle)\\n                return i;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int strStr(string haystack, string needle) \\n    {\\n        for (int i = 0; i <= (int)(haystack.length() - needle.length()); i++)\\n        {\\n            if (haystack.substr(i, needle.length()) == needle)\\n                return i;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13323,
                "title": "a-simple-python-solution",
                "content": "    class Solution:\\n        # @param haystack, a string\\n        # @param needle, a string\\n        # @return an integer\\n        def strStr(self, haystack, needle):\\n            if haystack == needle == '':\\n                return 0\\n    \\n            n = len(needle)\\n            \\n            for i in range(len(haystack) - n + 1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n    \\n            return -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param haystack, a string\\n        # @param needle, a string\\n        # @return an integer\\n        def strStr(self, haystack, needle):\\n            if haystack == needle == '':\\n                return 0\\n    \\n            n = len(needle)\\n            \\n            for i in range(len(haystack) - n + 1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n    \\n            return -1",
                "codeTag": "Java"
            },
            {
                "id": 4083931,
                "title": "one-line-of-code-beats-100-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```\\n\\n\\n![leet.jpeg](https://assets.leetcode.com/users/images/93e583bc-f206-4267-a4ec-f2e5c1d7ba4f_1695616472.7812035.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        return haystack.find(needle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494587,
                "title": "simple-js-ts-hack",
                "content": "# Code\\n```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2701316,
                "title": "java-100-faster-in-just-1-line",
                "content": "# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636449,
                "title": "python-85-faster-try-except",
                "content": "simple enough to return the index  in the try and if it errors return the -1 in the except block.\\n\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        try:\\n            return(haystack.index(needle))\\n        except:\\n            return(-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        try:\\n            return(haystack.index(needle))\\n        except:\\n            return(-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291527,
                "title": "c-0ms-rabin-karp-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int rabinKarp(string &text, string &pattern){\\n        long BASE = 26, MOD = 1e9+7;\\n        long power = 1;\\n        \\n        for(int i=1; i<pattern.size(); i++){\\n            power = (power*BASE) % MOD;\\n        }\\n\\t\\t\\n         // Find the hash value of the pattern and text\\n        long pattern_hash = 0;\\n        long text_hash = 0;\\n\\t\\t\\n        for(int i=0; i<pattern.size(); i++){\\n            pattern_hash = (pattern_hash*BASE + (pattern[i]-\\'a\\'+1)) % MOD;\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1)) % MOD;\\n        }\\n        \\n        if(pattern_hash == text_hash){\\n            return 0;\\n        }\\n        \\n        // While moving the window, perform two steps: \\n        // 1) Remove the left most character from the window\\n        // 2) Add the new character to the window\\n\\n        int start = 0;\\n        for(int i=pattern.size(); i<text.size(); i++){\\n            // Step1: Removing left character\\n            int ch = text[start++]-\\'a\\'+1;\\n            text_hash = text_hash-(ch*power);\\n            \\n            // Step2: Adding new character\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1))%MOD;\\n\\t\\t\\t\\n\\t\\t\\t// To avoid negative hash values\\n            if(text_hash < 0){\\n                text_hash += MOD;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Hash values of the pattern and text match\\n            if(text_hash == pattern_hash){\\n                return start;\\n            }\\n        }\\n\\t\\treturn -1;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0)\\n            return 0;\\n        return rabinKarp(haystack, needle);\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rabinKarp(string &text, string &pattern){\\n        long BASE = 26, MOD = 1e9+7;\\n        long power = 1;\\n        \\n        for(int i=1; i<pattern.size(); i++){\\n            power = (power*BASE) % MOD;\\n        }\\n\\t\\t\\n         // Find the hash value of the pattern and text\\n        long pattern_hash = 0;\\n        long text_hash = 0;\\n\\t\\t\\n        for(int i=0; i<pattern.size(); i++){\\n            pattern_hash = (pattern_hash*BASE + (pattern[i]-\\'a\\'+1)) % MOD;\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1)) % MOD;\\n        }\\n        \\n        if(pattern_hash == text_hash){\\n            return 0;\\n        }\\n        \\n        // While moving the window, perform two steps: \\n        // 1) Remove the left most character from the window\\n        // 2) Add the new character to the window\\n\\n        int start = 0;\\n        for(int i=pattern.size(); i<text.size(); i++){\\n            // Step1: Removing left character\\n            int ch = text[start++]-\\'a\\'+1;\\n            text_hash = text_hash-(ch*power);\\n            \\n            // Step2: Adding new character\\n            text_hash = (text_hash*BASE + (text[i]-\\'a\\'+1))%MOD;\\n\\t\\t\\t\\n\\t\\t\\t// To avoid negative hash values\\n            if(text_hash < 0){\\n                text_hash += MOD;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Hash values of the pattern and text match\\n            if(text_hash == pattern_hash){\\n                return start;\\n            }\\n        }\\n\\t\\treturn -1;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        if(needle.size() == 0)\\n            return 0;\\n        return rabinKarp(haystack, needle);\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2205390,
                "title": "rust-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        haystack.find(&needle).map(|i| i as i32).unwrap_or(-1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        haystack.find(&needle).map(|i| i as i32).unwrap_or(-1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1686108,
                "title": "most-pythonic-solution",
                "content": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378970,
                "title": "annotated-java-solution-3ms-o-m-n",
                "content": "You can think of the needle as sliding along underneath the haystack.\\n\\n<table>\\n  <tr>\\n    <td>A</td>\\n    <td>B</td>\\n    <td>C</td>\\n\\t<td>D</td>\\n\\t<td>E</td>\\n\\n  </tr>\\n    <tr>\\n    <td>C</td>\\n    <td>D</td>\\n    <td>E</td>\\n\\t<td></td>\\n\\t<td></td>\\n  </tr>\\n</table>\\n \\n \\n <table>\\n  <tr>\\n    <td>A</td>\\n    <td>B</td>\\n    <td>C</td>\\n\\t<td>D</td>\\n\\t<td>E</td>\\n  </tr>\\n    <tr>\\n    <td></td>\\n    <td>C</td>\\n    <td>D</td>\\n\\t<td>E</td>\\n\\t<td></td>\\n  </tr>\\n</table>\\n\\n <table>\\n  <tr>\\n    <td>A</td>\\n    <td>B</td>\\n    <td>C</td>\\n\\t<td>D</td>\\n\\t<td>E</td>\\n  </tr>\\n    <tr>\\n    <td></td>\\n    <td></td>\\n    <td>C</td>\\n\\t<td>D </td>\\n\\t<td>E </td>\\n  </tr>\\n</table>\\n \\n\\nAs you slide the needle along you compare the chars of the needle to its counterpart in the haystack, but start\\nfrom the back. This helps tremendously due to the nature of the tests. It appears that there are many instances where the needle resembles a substring from the haystack up until the last char.\\n\\n```java\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        if (needle.isEmpty())\\n            return 0;\\n\\n        // start iterating over the haystack (starting from 0 but end early to leave room for the tail end of the needle)\\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n\\n            // start comparing the characters in the needle to the current view of the haystack\\n            // going in reverse allows you to exit early\\n            for (int j = needle.length() - 1; j >= 0; j--) {\\n\\n                if (haystack.charAt(i+j) != needle.charAt(j)) // if at any point they dont equal we can break\\n                    break;\\n\\n                if (j == 0) // if we reached the first/last char comparison without a break they must be equal\\n                    return i;\\n            }\\n\\n        }\\n        return - 1; // iterated over the whole haystack, breaking every time on the inner loop\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        if (needle.isEmpty())\\n            return 0;\\n\\n        // start iterating over the haystack (starting from 0 but end early to leave room for the tail end of the needle)\\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\\n\\n            // start comparing the characters in the needle to the current view of the haystack\\n            // going in reverse allows you to exit early\\n            for (int j = needle.length() - 1; j >= 0; j--) {\\n\\n                if (haystack.charAt(i+j) != needle.charAt(j)) // if at any point they dont equal we can break\\n                    break;\\n\\n                if (j == 0) // if we reached the first/last char comparison without a break they must be equal\\n                    return i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1263703,
                "title": "simple-c-solution-2-pointer-approach-without-using-pre-defined-functions",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle == \"\") return 0;\\n        int n1 = haystack.size();\\n        int n2 = needle.size();\\n        int i = 0, j = 0;\\n        while(i < n1 && j < n2)\\n        {\\n            if(haystack[i] == needle[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i -= j;\\n                j = 0;\\n            }  \\n            i++;\\n        }\\n        if(j == n2) return (i - j);\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(needle == \"\") return 0;\\n        int n1 = haystack.size();\\n        int n2 = needle.size();\\n        int i = 0, j = 0;\\n        while(i < n1 && j < n2)\\n        {\\n            if(haystack[i] == needle[j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                i -= j;\\n                j = 0;\\n            }  \\n            i++;\\n        }\\n        if(j == n2) return (i - j);\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722936,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        let (hlen, nlen) = (haystack.len(), needle.len());\\n\\n        if nlen == 0 { return 0; }\\n        else if hlen < nlen { return -1; }\\n\\n        for i in 0..=(hlen - nlen) {\\n            if &haystack[i..i+nlen] == needle {\\n                return i as i32\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn str_str(haystack: String, needle: String) -> i32 {\\n        let (hlen, nlen) = (haystack.len(), needle.len());\\n\\n        if nlen == 0 { return 0; }\\n        else if hlen < nlen { return -1; }\\n\\n        for i in 0..=(hlen - nlen) {\\n            if &haystack[i..i+nlen] == needle {\\n                return i as i32\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164206,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        if needle == \"\":\\n            return 0\\n        n = len(needle)\\n        m = len(haystack)\\n        if m < n:\\n            return -1\\n        else:\\n            for i in range(m-n+1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n            return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        if needle == \"\":\\n            return 0\\n        n = len(needle)\\n        m = len(haystack)\\n        if m < n:\\n            return -1\\n        else:\\n            for i in range(m-n+1):\\n                if haystack[i:i+n] == needle:\\n                    return i\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13216,
                "title": "c-brute-force-solution",
                "content": "        \\n    int strStr(string haystack, string needle) {\\n        for (int i = 0; i < (int)(haystack.size()-needle.size()+1); i++) {\\n            int j = 0;\\n            while (j < needle.size() && haystack[i+j] == needle[j])\\n                j++;\\n            if (j == needle.size()) \\n                return i;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    int strStr(string haystack, string needle) {\\n        for (int i = 0; i < (int)(haystack.size()-needle.size()+1); i++) {\\n            int j = 0;\\n            while (j < needle.size() && haystack[i+j] == needle[j])\\n                j++;\\n            if (j == needle.size()) \\n                return i;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13281,
                "title": "shortest-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int strStr(string haystack, string needle) {\\n        int i = 0, j = 0, count = 0;\\n    \\tif (haystack.size() == 0 && needle.size() == 0 || needle.size() == 0) return 0;\\n    \\n    \\twhile (i < haystack.size())\\n    \\t{\\n    \\t\\tcount++;\\n    \\t\\tif (haystack[i++] != needle[j++]) { j = 0; i=i-count+1;count = 0; }\\n    \\t\\tif (j == needle.size()) return i - count;\\n    \\t}\\n    \\treturn -1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int strStr(string haystack, string needle) {\\n        int i = 0, j = 0, count = 0;\\n    \\tif (haystack.size() == 0 && needle.size() == 0 || needle.size() == 0) return 0;\\n    \\n    \\twhile (i < haystack.size())\\n    \\t{\\n    \\t\\tcount++;\\n    \\t\\tif (haystack[i++] != needle[j++]) { j = 0; i=i-count+1;count = 0; }",
                "codeTag": "Java"
            },
            {
                "id": 3611999,
                "title": "c-two-pointers-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n    \\n        \\n           int n = needle.size();\\n           int m = haystack.size();\\n        \\n            if(n==0) \\n            return 0;\\n        \\n        if(haystack.size() < needle.size())\\n            return -1;\\n        \\n      for(int i = 0; i<=(m-n);i++)\\n      {\\n          bool isBool = true;\\n          int indx;\\n          \\n         for(int j = 0; j<n; j++)\\n         {\\n             if(needle[j] !=haystack[j+i])\\n             {\\n                 isBool = false;\\n                 break;\\n             }\\n             \\n             indx = i;\\n         }\\n          \\n           if(isBool)\\n               return indx;\\n      }\\n       \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n    \\n        \\n           int n = needle.size();\\n           int m = haystack.size();\\n        \\n            if(n==0) \\n            return 0;\\n        \\n        if(haystack.size() < needle.size())\\n            return -1;\\n        \\n      for(int i = 0; i<=(m-n);i++)\\n      {\\n          bool isBool = true;\\n          int indx;\\n          \\n         for(int j = 0; j<n; j++)\\n         {\\n             if(needle[j] !=haystack[j+i])\\n             {\\n                 isBool = false;\\n                 break;\\n             }\\n             \\n             indx = i;\\n         }\\n          \\n           if(isBool)\\n               return indx;\\n      }\\n       \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361717,
                "title": "c-solution-beats-100",
                "content": "# Code\\n```\\nint strStr(char * haystack, char * needle){\\n    if (strlen(needle) > strlen(haystack))\\n        return -1;\\n\\n    for (int i = 0; i < strlen(haystack); i++) {\\n        if (!strncmp(haystack + i, needle, strlen(needle))) \\n            return i;\\n    }\\n\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nint strStr(char * haystack, char * needle){\\n    if (strlen(needle) > strlen(haystack))\\n        return -1;\\n\\n    for (int i = 0; i < strlen(haystack); i++) {\\n        if (!strncmp(haystack + i, needle, strlen(needle))) \\n            return i;\\n    }\\n\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3288858,
                "title": "simple-brute-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to check all substring of haystack \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndivide substring same length as needle length then compare with the needle\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n**2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    \\n\\n    for(let i=0;i<=haystack.length-needle.length;i++){\\n        let str=\"\"\\n       for(let j=i;j<i+needle.length;j++){\\n            str+=haystack[j]\\n        }\\n        if(str==needle){\\n            return i\\n        }\\n\\n    }\\n    return -1\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    \\n\\n    for(let i=0;i<=haystack.length-needle.length;i++){\\n        let str=\"\"\\n       for(let j=i;j<i+needle.length;j++){\\n            str+=haystack[j]\\n        }\\n        if(str==needle){\\n            return i\\n        }\\n\\n    }\\n    return -1\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257529,
                "title": "python-short-and-clean-5-different-solutions-functional-programming",
                "content": "# Approach 1: Two pointers\\nThis is the standard brute force with two pointer approach.\\nUsually `haystack` is so long that it doesn\\'t fit in memory. These are called `online` input problems.\\nThe rest of the solutions assume this to be the case, and solve for generic cases.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i in range(len(haystack) - len(needle) + 1):\\n            if all(haystack[i + j] == needle[j] for j in range(len(needle))):\\n                return i\\n        return -1\\n\\n\\n```\\n\\n---\\n\\n# Approach 2: Brute Force, Sliding Window\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_brute_force(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_brute_force(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    haystack = iter(haystack)\\n    window = deque(islice(haystack, len(needle) - 1), maxlen=len(needle))\\n    for i, x in enumerate(haystack):\\n        window.append(x)\\n        if all(starmap(eq, zip_longest(window, needle, fillvalue=\"\"))):\\n            yield i\\n\\n\\n```\\n\\n---\\n\\n# Approach 3: [Knuth-Morris-Pratt](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_knuth_morris_pratt(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_knuth_morris_pratt(haystack: Iterable[T], needle: Iterable[T]) -> Iterable[int]:\\n    DFA = Sequence[Mapping[T, int]]\\n\\n    def dfa(xs: Iterable[T]) -> DFA:\\n        transitions = []\\n\\n        t = defaultdict(int)\\n        for i, x in enumerate(xs):\\n            transitions.append(t | {x: i + 1})\\n            t = transitions[t[x]]\\n\\n        return transitions\\n\\n    needle_dfa = dfa(needle)\\n    end_state = len(needle_dfa)\\n\\n    states = accumulate(haystack, lambda st, x: needle_dfa[st][x], initial=0)\\n    return (i - end_state for i, st in enumerate(states) if st == end_state)\\n\\n\\n```\\n\\n---\\n\\n# Approach 4: [Boyer-Moore](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm)\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\n- Space complexity: $$O(m)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_boyer_moore(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_boyer_moore(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    SkipTable = Mapping[T, int]\\n\\n    def skip_table(xs: Iterable[T]) -> SkipTable:\\n        return defaultdict(lambda: -1, {ch: i for i, ch in enumerate(xs)})\\n\\n    n = len(needle)\\n    skip_t = skip_table(needle)\\n    \\n    haystack = iter(haystack)\\n    xs = tuple(islice(haystack, n))\\n    if len(xs) < n: return\\n    window = deque(xs, maxlen=n)\\n\\n    i = 0\\n    while xs:\\n        j = next((j for j in range(n - 1, -1, -1) if window[j] != needle[j]), -1)\\n        if j < 0: yield i\\n        steps = max(1, j - skip_t[window[j]])\\n        xs = tuple(islice(haystack, steps))\\n        window.extend(xs)\\n        i += steps\\n\\n\\n```\\n\\n---\\n\\n# Approach 5: [Rabin-Karp](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm)\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is length of haystack`,\\n`m is length of needle`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        hash_fn = {ch: i for i, ch in enumerate(ascii_lowercase, 1)}.__getitem__\\n        return next(substring_rabin_karp(haystack, needle, h_fn=hash_fn), -1)\\n\\n\\nT = Hashable\\nHashFn = Callable[[T], int]\\ndef substring_rabin_karp(haystack: Iterable[T], needle: Iterable[T], * h_fn: HashFn = hash, R: int = 256, Q: int = 1_000_000_007) -> Iterable[int]:\\n    HashValue = int\\n\\n    def hash_(xs: Iterable[T]) -> HashValue:\\n        return reduce(lambda h, x: (h * R + h_fn(x)) % Q, xs, 0)\\n\\n    def rolling_hashes(xs: Iterable[T], k: int) -> Iterable[HashValue]:\\n        xs1, xs2 = iter(xs), iter(xs)\\n        xs_hash = hash_(islice(xs2, k))\\n        RM = pow(R, len(needle), Q)\\n\\n        roll = lambda h, x1x2: ((h * R + h_fn(x1x2[1])) % Q - (h_fn(x1x2[0]) * RM) % Q) % Q\\n\\n        return accumulate(zip(xs1, xs2), roll, initial=xs_hash)\\n\\n    haystack_hashes = rolling_hashes(haystack, len(needle))\\n    needle_hash = hash_(needle)\\n\\n    return (i for i, h in enumerate(haystack_hashes) if h == needle_hash)\\n\\n\\n```\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i in range(len(haystack) - len(needle) + 1):\\n            if all(haystack[i + j] == needle[j] for j in range(len(needle))):\\n                return i\\n        return -1\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_brute_force(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_brute_force(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    haystack = iter(haystack)\\n    window = deque(islice(haystack, len(needle) - 1), maxlen=len(needle))\\n    for i, x in enumerate(haystack):\\n        window.append(x)\\n        if all(starmap(eq, zip_longest(window, needle, fillvalue=\"\"))):\\n            yield i\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_knuth_morris_pratt(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_knuth_morris_pratt(haystack: Iterable[T], needle: Iterable[T]) -> Iterable[int]:\\n    DFA = Sequence[Mapping[T, int]]\\n\\n    def dfa(xs: Iterable[T]) -> DFA:\\n        transitions = []\\n\\n        t = defaultdict(int)\\n        for i, x in enumerate(xs):\\n            transitions.append(t | {x: i + 1})\\n            t = transitions[t[x]]\\n\\n        return transitions\\n\\n    needle_dfa = dfa(needle)\\n    end_state = len(needle_dfa)\\n\\n    states = accumulate(haystack, lambda st, x: needle_dfa[st][x], initial=0)\\n    return (i - end_state for i, st in enumerate(states) if st == end_state)\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        return next(substring_boyer_moore(haystack, needle), -1)\\n\\n\\nT = Hashable\\ndef substring_boyer_moore(haystack: Iterable[T], needle: Sequence[T]) -> Iterable[int]:\\n    SkipTable = Mapping[T, int]\\n\\n    def skip_table(xs: Iterable[T]) -> SkipTable:\\n        return defaultdict(lambda: -1, {ch: i for i, ch in enumerate(xs)})\\n\\n    n = len(needle)\\n    skip_t = skip_table(needle)\\n    \\n    haystack = iter(haystack)\\n    xs = tuple(islice(haystack, n))\\n    if len(xs) < n: return\\n    window = deque(xs, maxlen=n)\\n\\n    i = 0\\n    while xs:\\n        j = next((j for j in range(n - 1, -1, -1) if window[j] != needle[j]), -1)\\n        if j < 0: yield i\\n        steps = max(1, j - skip_t[window[j]])\\n        xs = tuple(islice(haystack, steps))\\n        window.extend(xs)\\n        i += steps\\n\\n\\n```\n```python\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        hash_fn = {ch: i for i, ch in enumerate(ascii_lowercase, 1)}.__getitem__\\n        return next(substring_rabin_karp(haystack, needle, h_fn=hash_fn), -1)\\n\\n\\nT = Hashable\\nHashFn = Callable[[T], int]\\ndef substring_rabin_karp(haystack: Iterable[T], needle: Iterable[T], * h_fn: HashFn = hash, R: int = 256, Q: int = 1_000_000_007) -> Iterable[int]:\\n    HashValue = int\\n\\n    def hash_(xs: Iterable[T]) -> HashValue:\\n        return reduce(lambda h, x: (h * R + h_fn(x)) % Q, xs, 0)\\n\\n    def rolling_hashes(xs: Iterable[T], k: int) -> Iterable[HashValue]:\\n        xs1, xs2 = iter(xs), iter(xs)\\n        xs_hash = hash_(islice(xs2, k))\\n        RM = pow(R, len(needle), Q)\\n\\n        roll = lambda h, x1x2: ((h * R + h_fn(x1x2[1])) % Q - (h_fn(x1x2[0]) * RM) % Q) % Q\\n\\n        return accumulate(zip(xs1, xs2), roll, initial=xs_hash)\\n\\n    haystack_hashes = rolling_hashes(haystack, len(needle))\\n    needle_hash = hash_(needle)\\n\\n    return (i for i, h in enumerate(haystack_hashes) if h == needle_hash)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251442,
                "title": "443-string-compression-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int k=0;  \\n        int niddilesize=needle.size();\\n        while(k<haystack.size()){\\n        auto itr=find(haystack.begin()+k,haystack.end(),needle[0]);\\n        int n=itr-haystack.begin();\\n        string str=haystack.substr(n,niddilesize);\\n        if(str==needle){\\n           ans=n; \\n            break;\\n        }\\n       else \\n           k=k+1;\\n           continue;\\n         }\\n        \\n        if(ans==-1)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int k=0;  \\n        int niddilesize=needle.size();\\n        while(k<haystack.size()){\\n        auto itr=find(haystack.begin()+k,haystack.end(),needle[0]);\\n        int n=itr-haystack.begin();\\n        string str=haystack.substr(n,niddilesize);\\n        if(str==needle){\\n           ans=n; \\n            break;\\n        }\\n       else \\n           k=k+1;\\n           continue;\\n         }\\n        \\n        if(ans==-1)\\n            return -1;\\n        else\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250089,
                "title": "find-the-index-of-the-first-occurrence-in-a-string-solving-the-leetcode-challenge-march-3-2023",
                "content": "![image.png](https://assets.leetcode.com/users/images/d5bd5c46-5f44-4fa7-820f-dd165a96fb91_1677816522.0925934.png)\\n\\n# Full explaination at : [Solution](https://yoichiisagi.hashnode.dev/find-the-index-of-the-first-occurrence-in-a-string-solving-the-leetcode-challenge-march-3-2023)\\n\\n![image.png](https://assets.leetcode.com/users/images/6907ce4f-a766-4668-bd51-1cedade65e46_1677816533.0083919.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n    int n = needle.length();\\n    if (n == 0) {\\n        return 0;\\n    }\\n    int m = haystack.length();\\n    if (m < n) {\\n        return -1;\\n    }\\n    for (int i = 0; i <= m - n; i++) {\\n        if (haystack.substring(i, i + n).equals(needle)) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n    int n = needle.length();\\n    if (n == 0) {\\n        return 0;\\n    }\\n    int m = haystack.length();\\n    if (m < n) {\\n        return -1;\\n    }\\n    for (int i = 0; i <= m - n; i++) {\\n        if (haystack.substring(i, i + n).equals(needle)) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249866,
                "title": "leetcode-the-hard-way-z-algorithm",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // z-algorithm\\n    vector<int> z_function(string s) {\\n        int n = (int) s.length();\\n        vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i <= r)\\n                z[i] = min (r - i + 1, z[i - l]);\\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n                ++z[i];\\n            if (i + z[i] - 1 > r)\\n                l = i, r = i + z[i] - 1;\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int k = (int) needle.size();\\n        if(haystack == needle || k == 0) return 0;\\n        string s = needle + \"$\" + haystack;\\n        vector<int> z = z_function(s);\\n        int n = (int) s.size();\\n        for(int i = 0; i < n; i++) {\\n            if(z[i] == k) {\\n                return i - k - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // z-algorithm\\n    vector<int> z_function(string s) {\\n        int n = (int) s.length();\\n        vector<int> z(n);\\n        for (int i = 1, l = 0, r = 0; i < n; ++i) {\\n            if (i <= r)\\n                z[i] = min (r - i + 1, z[i - l]);\\n            while (i + z[i] < n && s[z[i]] == s[i + z[i]])\\n                ++z[i];\\n            if (i + z[i] - 1 > r)\\n                l = i, r = i + z[i] - 1;\\n        }\\n        return z;\\n    }\\n    \\n    int strStr(string haystack, string needle) {\\n        int k = (int) needle.size();\\n        if(haystack == needle || k == 0) return 0;\\n        string s = needle + \"$\" + haystack;\\n        vector<int> z = z_function(s);\\n        int n = (int) s.size();\\n        for(int i = 0; i < n; i++) {\\n            if(z[i] == k) {\\n                return i - k - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249810,
                "title": "1-liner-code-in-java-simplest-code-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249778,
                "title": "python3-two-pointers-27-ms-faster-than-90-82",
                "content": "Time complexity: O(mn)  \\nhttps://leetcode.com/submissions/detail/908052808/  \\nRuntime: **27 ms, faster than 90.82%** of Python3 online submissions for Find the Index of the First Occurrence in a String.\\nMemory Usage: 13.9 MB, less than 54.52% of Python3 online submissions for Find the Index of the First Occurrence in a String.\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<l1:\\n            if p2==l2:\\n                return p1-l2\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n        if p2==l2:\\n            return l1-l2\\n        return -1\\n```\\nSame solution with variant code  \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<=l1:\\n            if p2==l2:\\n                return p1-l2\\n            elif p1==l1:\\n                return -1\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<l1:\\n            if p2==l2:\\n                return p1-l2\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n        if p2==l2:\\n            return l1-l2\\n        return -1\\n```\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        l1, l2, p1, p2 = len(haystack), len(needle), 0, 0\\n        while p1<=l1:\\n            if p2==l2:\\n                return p1-l2\\n            elif p1==l1:\\n                return -1\\n            if haystack[p1]==needle[p2]:\\n                p2 += 1\\n            else:\\n                p1 = p1 - p2\\n                p2 = 0\\n            p1 += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249587,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-step-by-step-c-javascript-java-python",
                "content": "\\n# Approach\\n**let result = haystack.indexOf(needle);** calls the **indexOf()** method on the needle param to find the index of the first occurrence of the needle variable within haystack. The resulting index is stored in a variable named result.\\n\\nThe **indexOf()** method returns the index of the first occurrence of the specified substring within the input string. If the substring is not found, it returns -1.\\n\\n# Complexity\\n### Time complexity:\\nThe time complexity of finding the index of the first occurrence of a substring in a string using the **indexOf()** method in JavaScript is **O(n)**, where n is the length of the input string.\\n\\nThe **indexOf()** method searches the input string character by character to find the first occurrence of the specified substring. In the worst case scenario, where the substring is not found in the string, the **indexOf()** method has to examine every character in the string before determining that the substring is not present. Therefore, the time complexity of this operation is proportional to the length of the input string, which is **O(n)**.\\n\\nNote that if the substring is found in the input string, the **indexOf()** method will return the index of the first occurrence of the substring, which may be less than n. However, in the worst case scenario, where the substring is not found, the time complexity is **O(n)**.\\n\\n# Code in Javascript\\n```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let result = haystack.indexOf(needle);\\n    return result\\n};\\n```\\n# Code in Python\\n```\\n    // Call the find method on the input string to find the index of the first occurrence of the substring\\n    index = haystack.find(needle)\\n\\n    // Print the index to the console\\n    print(index)\\n```\\n\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} haystack\\n * @param {string} needle\\n * @return {number}\\n */\\nvar strStr = function(haystack, needle) {\\n    let result = haystack.indexOf(needle);\\n    return result\\n};\\n```\n```\\n    // Call the find method on the input string to find the index of the first occurrence of the substring\\n    index = haystack.find(needle)\\n\\n    // Print the index to the console\\n    print(index)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3049597,
                "title": "c-simplified-rabin-karp-o-n-amortised",
                "content": "- If `haystack.substr == needle`, `xor(haystack.substr) == xor(needle)`\\n- If `haystack.substr` contain pairs of duplicate characters, they will cancel each other out (e.g. `xor(\"abb\") == xor(\"aaa\")`)\\n- Therefore we need to double check\\n\\n### C++\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (haystack.size() < needle.size()) return -1;\\n        \\n        int lock = 0, key = 0;\\n        for (int i=0; i<needle.size(); ++i) {\\n            lock ^= needle[i];\\n            key ^= haystack[i];\\n        }\\n\\n        for (int i=0; i<=haystack.size()-needle.size(); ++i) {\\n            if (key == lock && haystack.substr(i, needle.size()) == needle) return i;\\n            key ^= haystack[i] ^ haystack[i+needle.size()];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (haystack.size() < needle.size()) return -1;\\n        \\n        int lock = 0, key = 0;\\n        for (int i=0; i<needle.size(); ++i) {\\n            lock ^= needle[i];\\n            key ^= haystack[i];\\n        }\\n\\n        for (int i=0; i<=haystack.size()-needle.size(); ++i) {\\n            if (key == lock && haystack.substr(i, needle.size()) == needle) return i;\\n            key ^= haystack[i] ^ haystack[i+needle.size()];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046505,
                "title": "two-pointer-cpp-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int n=needle.size();\\n\\n        for(int i=0;i<haystack.size();i++)\\n        {\\n            if(haystack[i]==needle[0])\\n            {\\n                int flag=0;\\n                int index=1;\\n                \\n                while(index!=n)\\n                {\\n                    if((i+index)<haystack.size() && haystack[i+index]==needle[index])\\n                    {\\n                        index++;\\n                    }\\n                    else{\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag==0) \\n                {\\n                    ans=i;\\n                    return ans;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        int n=needle.size();\\n\\n        for(int i=0;i<haystack.size();i++)\\n        {\\n            if(haystack[i]==needle[0])\\n            {\\n                int flag=0;\\n                int index=1;\\n                \\n                while(index!=n)\\n                {\\n                    if((i+index)<haystack.size() && haystack[i+index]==needle[index])\\n                    {\\n                        index++;\\n                    }\\n                    else{\\n                        flag=1;\\n                        break;\\n                    }\\n                }\\n\\n                if(flag==0) \\n                {\\n                    ans=i;\\n                    return ans;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886099,
                "title": "c-0ms-faster-beats-100-o-n-tc-o-k-sc",
                "content": "\\n- Time complexity:O(n) where n is the size of haystack string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k) where k is the size of needle string\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m=haystack.size(),n=needle.size();\\n        int i=0;\\n        while(i<m){\\n            string str;\\n            if(haystack[i]==needle[0])  str=haystack.substr(i,n);\\n            if(str==needle) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m=haystack.size(),n=needle.size();\\n        int i=0;\\n        while(i<m){\\n            string str;\\n            if(haystack[i]==needle[0])  str=haystack.substr(i,n);\\n            if(str==needle) return i;\\n            i++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768073,
                "title": "100-faster-c-java-python-c-javascript-php-go-ruby-typescript-dart",
                "content": "**C++ Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        return haystack.find(needle);\\n    }\\n};\\n```\\n\\n**Java Solution:**\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        return haystack.indexOf(needle);\\n    }\\n}\\n```\\n\\n **Python Solution:**\\n \\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```\\n\\n **Javascript Solution:**\\n \\n```\\nvar strStr = function(haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\\n\\n **Go Solution:** \\n \\n```\\nfunc strStr(haystack string, needle string) int {\\n    \\n    return strings.Index(haystack, needle);\\n}\\n```\\n\\n**C# Solution:**\\n```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```\\n\\n **Typescript Solution:**\\n \\n```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle);\\n};\\n```\\n\\n **Ruby Solution:**\\n \\n```\\ndef str_str(haystack, needle)\\n\\n    return haystack.index(needle) != nil ? haystack.index(needle) : -1\\n        \\nend\\n```\\n\\n **Dart Solution:**\\n\\n```\\nclass Solution {\\n  int strStr(String haystack, String needle) {\\n      return haystack.indexOf(needle);\\n  }\\n}\\n```\\n\\n**PHP Solution:** \\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr($haystack, $needle) {\\n        echo strpos($haystack, $needle);\\n        if (strpos($haystack, $needle) !== false) {\\n            return strpos($haystack, $needle);\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Go",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        return haystack.find(needle);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        return haystack.indexOf(needle);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        return haystack.find(needle)\\n```\n```\\nvar strStr = function(haystack, needle) {\\n    return haystack.indexOf(needle);\\n};\\n```\n```\\nfunc strStr(haystack string, needle string) int {\\n    \\n    return strings.Index(haystack, needle);\\n}\\n```\n```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```\n```\\nfunction strStr(haystack: string, needle: string): number {\\n    return haystack.indexOf(needle);\\n};\\n```\n```\\ndef str_str(haystack, needle)\\n\\n    return haystack.index(needle) != nil ? haystack.index(needle) : -1\\n        \\nend\\n```\n```\\nclass Solution {\\n  int strStr(String haystack, String needle) {\\n      return haystack.indexOf(needle);\\n  }\\n}\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $haystack\\n     * @param String $needle\\n     * @return Integer\\n     */\\n    function strStr($haystack, $needle) {\\n        echo strpos($haystack, $needle);\\n        if (strpos($haystack, $needle) !== false) {\\n            return strpos($haystack, $needle);\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618444,
                "title": "kotlin-one-liner",
                "content": "```kotlin\\nclass Solution {\\n    fun strStr(haystack: String, needle: String): Int = haystack.indexOf(needle)\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun strStr(haystack: String, needle: String): Int = haystack.indexOf(needle)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225081,
                "title": "c-0ms-faster-than-100-best-easiest-solution",
                "content": "**Note:** This is an updated version of a previous post I wrote, just changed some formatting.\\n\\n---\\nRelatively straightforward problem, just brute-forcing works marvelously. \\n\\nIn my taste, this should be an ```easy``` problem, but even if it is placed ```medium```, it is definitely in the easy portion of all the mediums on Leetcode.\\n\\nLet\\'s get in our problem.\\n\\nWe simply search for a possible substring with the first character of ```needle```. If it occurs, check if the other characters match with each other. If it works, return the ```index```. Or else, forget about it and continue.\\n\\nIf anything is **unclear**, feel free to **comment** below.\\n\\nHere is the code for reference. The **second tab** contains **detailed explanations line-by-line.**\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() > haystack.size()) return -1;\\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            if (needle[0] == haystack[i]) {\\n                bool flag = true;\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                if (flag) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // if the needle size is bigger than the haystack\\'s size, the needle would obviously be too big\\n        if (needle.size() > haystack.size()) return -1; \\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            // if first chars match each other, or if it is a possible candidate\\n            if (needle[0] == haystack[i]) { \\n                bool flag = true;\\n                // if any other letters don\\'t match, forget about it (flag = false)\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                // if the whole needle matches, with the haystack substring, return da answer!\\n                if (flag) return i; \\n            }\\n        }\\n        // else, simply return -1 because none can be found\\n        return -1;\\n    }\\n};\\n```\\n\\nYou do not need to upvote or whatever. Feel free to do it at your own will. At least, if you saw my solution, you are already supporting me deep in my heart.\\n\\nHappy coding!\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```easy```\n```medium```\n```needle```\n```index```\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.size() > haystack.size()) return -1;\\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            if (needle[0] == haystack[i]) {\\n                bool flag = true;\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                if (flag) return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        // if the needle size is bigger than the haystack\\'s size, the needle would obviously be too big\\n        if (needle.size() > haystack.size()) return -1; \\n        for (int i = 0; i <= haystack.size() - needle.size(); i++) {\\n            // if first chars match each other, or if it is a possible candidate\\n            if (needle[0] == haystack[i]) { \\n                bool flag = true;\\n                // if any other letters don\\'t match, forget about it (flag = false)\\n                for (int j = 1; j < needle.size(); j++) if (needle[j] != haystack[i + j]) flag = false;\\n                // if the whole needle matches, with the haystack substring, return da answer!\\n                if (flag) return i; \\n            }\\n        }\\n        // else, simply return -1 because none can be found\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1963567,
                "title": "explained-java-code-with-comments-rabin-karp-algo-rolling-hash",
                "content": "**How Rabin-Karp Algorithm Works?**\\n- Calculate the hashCode of pattern to be searched\\n- Calculate the hashCode of  every susbtring of length same as pattern from given text (Sliding window)\\n- Check which window\\'s hashCode matches pattern\\'s hashCode\\n- Compare characters of both strings\\n\\n**What is Rolling Hash?**\\nRolling hash is used to prevent rehashing the whole string while calculating hash values of the substrings of a given string. In rolling hash,the new hash value is rapidly calculated given only the old hash value. Using it, two strings can be compared in constant time.\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int M = needle.length(); \\n        int N = haystack.length();\\n\\t\\t\\n\\t\\t if(M>N)return -1;\\n\\t\\t\\n        int i, j; \\n        int p = 0; // hash value for needle \\n        int t = 0; // hash value for haystack \\n        int h = 1;\\n        int d= 256; // number of characters in the input alphabet \\n        int q= 31; //a prime number\\n\\n        char[] pat=needle.toCharArray();\\n        char[] txt=haystack.toCharArray();\\n        // The value of h would be \"pow(d, M-1)%q\" \\n        for (i = 0; i < M - 1; i++) \\n            h = (h * d) % q; \\n\\n        // Calculate the hash value of pattern and first \\n        // window of text \\n        for (i = 0; i < M; i++) { \\n            p = (d * p + pat[i]) % q; \\n            t = (d * t + txt[i]) % q; \\n        } \\n\\n        // Slide the pattern over text one by one \\n        for (i = 0; i <= N - M; i++) { \\n\\n            // Check the hash values of current window of text \\n            // and pattern. If the hash values match then only \\n            // check for characters on by one \\n            if ( p == t ) { \\n                /* Check for characters one by one */\\n                for (j = 0; j < M; j++) { \\n                    if (txt[i+j] != pat[j]) \\n                        break; \\n                } \\n\\n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1] \\n                if (j == M) \\n                    return i;\\n            } \\n\\n            // Calculate hash value for next window of text: Remove \\n            // leading digit, add trailing digit \\n            if ( i < N-M ) { \\n                t = (d*(t - txt[i]*h) + txt[i+M])%q; \\n\\n                // We might get negative value of t, converting it \\n                // to positive \\n                if (t < 0) \\n                t = (t + q); \\n            } \\n        }\\n        return -1;\\n    }\\n}\\n```\\nTime `O(N+M)`\\nSpace `O(1)`\\nAlthough i used two char array. They can be avoided.\\n\\n**Why use a prime number in hashCode?**\\nPrime numbers are chosen to best distribute data among hash buckets. If the distribution of inputs is random and evenly spread, then the choice of the hash code/modulus does not matter. It only has an impact when there is a certain pattern to the inputs.\\n\\nDo upvote if you liked the solution.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int M = needle.length(); \\n        int N = haystack.length();\\n\\t\\t\\n\\t\\t if(M>N)return -1;\\n\\t\\t\\n        int i, j; \\n        int p = 0; // hash value for needle \\n        int t = 0; // hash value for haystack \\n        int h = 1;\\n        int d= 256; // number of characters in the input alphabet \\n        int q= 31; //a prime number\\n\\n        char[] pat=needle.toCharArray();\\n        char[] txt=haystack.toCharArray();\\n        // The value of h would be \"pow(d, M-1)%q\" \\n        for (i = 0; i < M - 1; i++) \\n            h = (h * d) % q; \\n\\n        // Calculate the hash value of pattern and first \\n        // window of text \\n        for (i = 0; i < M; i++) { \\n            p = (d * p + pat[i]) % q; \\n            t = (d * t + txt[i]) % q; \\n        } \\n\\n        // Slide the pattern over text one by one \\n        for (i = 0; i <= N - M; i++) { \\n\\n            // Check the hash values of current window of text \\n            // and pattern. If the hash values match then only \\n            // check for characters on by one \\n            if ( p == t ) { \\n                /* Check for characters one by one */\\n                for (j = 0; j < M; j++) { \\n                    if (txt[i+j] != pat[j]) \\n                        break; \\n                } \\n\\n                // if p == t and pat[0...M-1] = txt[i, i+1, ...i+M-1] \\n                if (j == M) \\n                    return i;\\n            } \\n\\n            // Calculate hash value for next window of text: Remove \\n            // leading digit, add trailing digit \\n            if ( i < N-M ) { \\n                t = (d*(t - txt[i]*h) + txt[i+M])%q; \\n\\n                // We might get negative value of t, converting it \\n                // to positive \\n                if (t < 0) \\n                t = (t + q); \\n            } \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854661,
                "title": "string-c-very-easyy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        // cout << a << \" \";\\n        return a==b;\\n    }\\n    int strStr(string haystack, string needle) {\\n        if(haystack==needle) return 0;\\n        int n = needle.size();\\n        int m = haystack.size();\\n        for(int i=0;i<=m-n;i++){\\n            if(check(haystack.substr(i,n),needle)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string a,string b){\\n        // cout << a << \" \";\\n        return a==b;\\n    }\\n    int strStr(string haystack, string needle) {\\n        if(haystack==needle) return 0;\\n        int n = needle.size();\\n        int m = haystack.size();\\n        for(int i=0;i<=m-n;i++){\\n            if(check(haystack.substr(i,n),needle)) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1338800,
                "title": "short-and-easy-solutuon-java",
                "content": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        char[] n = needle.toCharArray();\\n        char[] h = haystack.toCharArray();\\n\\n        int cur = 0;\\n        while(cur < h.length) {\\n            if (h[cur] == n[0]) {\\n                if (n.length <= (h.length - cur)) {\\n                    int i = cur, j = 0;\\n                    for (; j < n.length && h[i] == n[j]; i++, j++) {\\n\\n                    }\\n                    if (j == n.length) {\\n                        // all chars in needle found in haystack\\n                        return cur; // first index of match\\n                    }\\n                }\\n            }\\n            cur++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        char[] n = needle.toCharArray();\\n        char[] h = haystack.toCharArray();\\n\\n        int cur = 0;\\n        while(cur < h.length) {\\n            if (h[cur] == n[0]) {\\n                if (n.length <= (h.length - cur)) {\\n                    int i = cur, j = 0;\\n                    for (; j < n.length && h[i] == n[j]; i++, j++) {\\n\\n                    }\\n                    if (j == n.length) {\\n                        // all chars in needle found in haystack\\n                        return cur; // first index of match\\n                    }\\n                }\\n            }\\n            cur++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316041,
                "title": "c-rabin-karp-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(!haystack.size() && !needle.size()) return 0;\\n        int base =  256;\\n        int moduloPrime = 101;\\n        \\n        int n = haystack.size();\\n        int m = needle.size();\\n        \\n        int i, j; // iterator\\n        int h = 1;\\n        int pHash = 0;\\n        int sHash = 0;\\n        // hash function\\n        for(i = 0; i < m-1; ++i) {\\n            h = (h *base) % moduloPrime; \\n        }\\n        \\n        // calculate the hash for pattern and first window of the string\\n        for(i = 0; i < m; ++i) {\\n            pHash = (base * pHash + needle[i]) % moduloPrime;\\n            sHash = (base * sHash + haystack[i]) % moduloPrime;\\n        }\\n        \\n        for(i = 0; i <= n-m; ++i) {\\n            if(pHash == sHash) {\\n                // do character by character comparison\\n                for(j =0 ; j < m; ++j) {\\n                    if(haystack[i+j]!=needle[j]) break;\\n                }\\n            }\\n            if(j == m) return i; // first occurence is found\\n            // else compute the hash for next window\\n            if ( i < n-m ) {\\n                sHash = (base * (sHash - haystack[i]*h) + haystack[i+m])%moduloPrime;\\n                if(sHash < 0) sHash += moduloPrime;\\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if(!haystack.size() && !needle.size()) return 0;\\n        int base =  256;\\n        int moduloPrime = 101;\\n        \\n        int n = haystack.size();\\n        int m = needle.size();\\n        \\n        int i, j; // iterator\\n        int h = 1;\\n        int pHash = 0;\\n        int sHash = 0;\\n        // hash function\\n        for(i = 0; i < m-1; ++i) {\\n            h = (h *base) % moduloPrime; \\n        }\\n        \\n        // calculate the hash for pattern and first window of the string\\n        for(i = 0; i < m; ++i) {\\n            pHash = (base * pHash + needle[i]) % moduloPrime;\\n            sHash = (base * sHash + haystack[i]) % moduloPrime;\\n        }\\n        \\n        for(i = 0; i <= n-m; ++i) {\\n            if(pHash == sHash) {\\n                // do character by character comparison\\n                for(j =0 ; j < m; ++j) {\\n                    if(haystack[i+j]!=needle[j]) break;\\n                }\\n            }\\n            if(j == m) return i; // first occurence is found\\n            // else compute the hash for next window\\n            if ( i < n-m ) {\\n                sHash = (base * (sHash - haystack[i]*h) + haystack[i+m])%moduloPrime;\\n                if(sHash < 0) sHash += moduloPrime;\\n            }\\n            \\n        }\\n        \\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956652,
                "title": "python-two-pointer",
                "content": "```\\n# Two pointer\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        \\n        if len(needle) > len(haystack):\\n            return -1\\n        \\n        for p_haystack in range(len(haystack) - len(needle) + 1):\\n            if self.start_comparision(haystack, needle, p_haystack, 0):\\n                return p_haystack\\n        return -1\\n    \\n    def start_comparision(self, haystack, needle, p_haystack, p_needle):\\n        L = len(needle)\\n        while p_needle < L and haystack[p_haystack] == needle[p_needle]:\\n            p_haystack += 1\\n            p_needle += 1\\n        return True if p_needle == len(needle) else False\\n```",
                "solutionTags": [],
                "code": "```\\n# Two pointer\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if not needle:\\n            return 0\\n        \\n        if len(needle) > len(haystack):\\n            return -1\\n        \\n        for p_haystack in range(len(haystack) - len(needle) + 1):\\n            if self.start_comparision(haystack, needle, p_haystack, 0):\\n                return p_haystack\\n        return -1\\n    \\n    def start_comparision(self, haystack, needle, p_haystack, p_needle):\\n        L = len(needle)\\n        while p_needle < L and haystack[p_haystack] == needle[p_needle]:\\n            p_haystack += 1\\n            p_needle += 1\\n        return True if p_needle == len(needle) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763754,
                "title": "java-three-versions-of-kmp",
                "content": "First, the KMP with DFA(Deterministic Finite Automaton).\\n```\\nclass Solution {\\n    public int strStr(String t, String p) {\\n        int n = t.length(), m = p.length();\\n        if (m == 0) return 0;\\n        int[][] dfa = new int[m][26];\\n        int x = 0;\\n        dfa[0][p.charAt(0) - \\'a\\'] = 1;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0; j < 26; ++j) {\\n                    dfa[i][j] = dfa[x][j];\\n            }\\n\\t\\t\\tdfa[i][p.charAt(i) - \\'a\\'] = i + 1;\\n            x = dfa[x][p.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0, j = 0; i < n && j < m; ++i) {\\n            j = dfa[j][t.charAt(i) - \\'a\\'];\\n            if (j == m) return i - m + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\nThe time complexity of this algorithm can be divided into two parts. First, the cost to build DFA table is ```O(Rm)``` where R is the number of characters. And in this case, ```R = 26```. The matching process cost O(n), we just loop once. Total complexity is ``` O(Rm + n) ```The bottleneck of this problem is the size of R. If it is too large, then the preprocess costs too much.\\n\\nSecond version: KMP with NFA(Nondeterministic Finite Automata). \\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                next[++j] = ++i;\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\\nIn this case, NFA is used. And the time complexity is ```O(m + n)```.\\nSimilar to path compression in Union Find, this can be further improved,\\nThird version is NFA with path compression.\\nThe intuition is that if we move to next position and find that it is still the same as current, there is no need to do this comparison again. \\n\\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                ++j; ++i;\\n                // path compression\\n                next[j] = p.charAt(i) != p.charAt(j) ? i : next[i];\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\\nThis version improve the performance but it doesn\\'t change the ```Big - O``` time and space complexity. \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int strStr(String t, String p) {\\n        int n = t.length(), m = p.length();\\n        if (m == 0) return 0;\\n        int[][] dfa = new int[m][26];\\n        int x = 0;\\n        dfa[0][p.charAt(0) - \\'a\\'] = 1;\\n        for (int i = 1; i < m; ++i) {\\n            for (int j = 0; j < 26; ++j) {\\n                    dfa[i][j] = dfa[x][j];\\n            }\\n\\t\\t\\tdfa[i][p.charAt(i) - \\'a\\'] = i + 1;\\n            x = dfa[x][p.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0, j = 0; i < n && j < m; ++i) {\\n            j = dfa[j][t.charAt(i) - \\'a\\'];\\n            if (j == m) return i - m + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```O(Rm)```\n```R = 26```\n``` O(Rm + n) ```\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                next[++j] = ++i;\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\n```O(m + n)```\n```\\nclass Solution {\\n    public int strStr(String s, String p) {\\n        int m = p.length(), n = s.length();\\n        if (m == 0) return 0;\\n        int[] next = new int[m];\\n        next[0] = -1;\\n        for (int i = -1, j = 0; j < m - 1;) {\\n            if (i < 0 || p.charAt(i) == p.charAt(j)) {\\n                ++j; ++i;\\n                // path compression\\n                next[j] = p.charAt(i) != p.charAt(j) ? i : next[i];\\n            } else {\\n                i = next[i];\\n            }\\n        }\\n        int i = 0, j = 0;\\n        while (i < n && j < m) {\\n            if (j < 0 || s.charAt(i) == p.charAt(j)) {\\n                ++i;\\n                ++j;\\n            } else \\n                j = next[j];\\n        }\\n        return j == m ? i - m : -1;\\n    }\\n}\\n```\n```Big - O```",
                "codeTag": "Java"
            },
            {
                "id": 762113,
                "title": "python-28ms-faster-than-90",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\t\\n        x = len(haystack)\\n        l = len(needle)\\n        if haystack==needle:\\n            return 0\\n        if x==0 and l==0:\\n            return 0\\n        for i in range(0,x-l+1):\\n            if haystack[i:i+l]==needle:\\n                return i\\n        return -1\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\t\\n        x = len(haystack)\\n        l = len(needle)\\n        if haystack==needle:\\n            return 0\\n        if x==0 and l==0:\\n            return 0\\n        for i in range(0,x-l+1):\\n            if haystack[i:i+l]==needle:\\n                return i\\n        return -1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 644663,
                "title": "don-t-call-find-fucntion-algorithms-discussed-briefly-and-cpp-code-given",
                "content": "You may get the correct result by calling find function, but it is not as easy as its surface. If you are interviewed, calling find() function will dissppoint interviewer, at least you will not impress people. \\n\\nIt is classical string mathching problem. You will find detailed dicssion from algorithm books or simply search google with keyword. SO, no need for me to be teacher here. My intention is to give some link or reference for your self-learning.\\n\\n\\nLet us start from a straight-foward solution. A outter loop shifts one character of haystack as the starting character of haystack for the next round of matching (stops if finding a matching). A inner loop compare the character-by-character between needle and sub-string of haystack with starting point determined by the outter loop. It might be easier to get the idea by checking the code below. And the time complxity is O((n-m+1)m) , where m, n are the lengths of needle and haystack, respectively. Memory complexity is O(m+n).\\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int sn = needle.size();\\n            if(sn==0) \\n        return 0;\\n        \\n        int cnt=0;\\n        int sh=haystack.size();\\n        int i=0, j,x;\\n        int search = sh-sn+1;\\n\\n            for(j=0;j<search;j++){\\n                x=j;\\n                while(haystack[x]==needle[i] && x<sh&&i<sn){\\n                    ++i;\\n                    ++cnt;\\n                    ++x;\\n                }\\n                if(cnt==sn) return j;\\n                else {\\n                    i=0;\\n                    cnt=0;\\n                }\\n            }   \\n        return -1;\\n    }\\n};\\n\\'\\'\\'\\n\\nSometimes, learnt from past partitial matching on needle, we may skip duplicated matching in a next mathicng round. With this idea, there are many ways to optimize the above native algorithm. And KMP (Knuth-Morris-Pratt) algorithm is one of most efficient one. KMP needs O(m) time complexity to pre-compute a array recording how many characters can be skiped if a substring of needle is matched, and O(n) time complexity for the real matching procedure. I only give my code as bleow and you need to survey the details by yourself. The runtime of this code only beat 90.46% of CPP submissions. If you know better implementation (without calling find()), please reply to me. Many Thanks. \\n\\n\\n\\n\\'\\'\\'\\n//KMP\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int sn = needle.size();\\n        if(sn==0) \\n            return 0;\\n        \\n        int sh=haystack.size();\\n        \\n        //pre-compute how many characters can be skipped when a sub-string of needle was matched previously.\\n        //For the pattern \\u201CAAAA\\u201D, skip[] is [0, 1, 2, 3]\\n        //For the pattern \\u201CABCDE\\u201D, is [0, 0, 0, 0, 0]\\n        //For the pattern \\u201CAABAACAABAA\\u201D, is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]\\n        //For the pattern \\u201CAAACAAAAAC\\u201D, is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]         \\n        \\n        int skip[sn];\\n        skip[0] = 0;\\n        int i = 1, len = 0; \\n        while (i < sn) { \\n            if (needle[i] == needle[len]) { \\n                len++; \\n                skip[i] = len; \\n                i++; \\n            } \\n            else{ // (needle[i] != needle[len]) \\n                if (len != 0) { \\n                    len = skip[len - 1]; \\n                } \\n                else{ // if (len == 0)  \\n                    skip[i] = 0; \\n                    i++; \\n                } \\n            } \\n        } \\n        \\n        //matching \\n                \\n        i=0;\\n        len =0;\\n        for(len=0;len<sh;){\\n            while(haystack[len]==needle[i] ){\\n                ++i;\\n                ++len;\\n                if(i==sn) return (len-sn);\\n             }\\n             \\n            if(i==0){\\n                ++len;\\n                continue;\\n            }\\n            else{\\n                i=skip[i-1];\\n            }\\n        }\\n        return -1;\\n\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int sn = needle.size();\\n            if(sn==0) \\n        return 0;\\n        \\n        int cnt=0;\\n        int sh=haystack.size();\\n        int i=0, j,x;\\n        int search = sh-sn+1;\\n\\n            for(j=0;j<search;j++){\\n                x=j;\\n                while(haystack[x]==needle[i] && x<sh&&i<sn){\\n                    ++i;\\n                    ++cnt;\\n                    ++x;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 601859,
                "title": "javascript-o-n-m-two-pointers",
                "content": "```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\') {\\n    return 0;\\n  }\\n\\n  if (haystack.length < needle.length) {\\n    return -1;\\n  }\\n\\n  let i = 0;\\n  let j = 0;\\n\\n  for (; i < haystack.length; i += 1) {\\n    if (haystack[i] === needle[j]) {\\n      if (j === needle.length - 1) {\\n        return i - j;\\n      }\\n\\n      j += 1;\\n    } else {\\n      i -= j;\\n      j = 0;\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nconst strStr = (haystack, needle) => {\\n  if (needle === \\'\\') {\\n    return 0;\\n  }\\n\\n  if (haystack.length < needle.length) {\\n    return -1;\\n  }\\n\\n  let i = 0;\\n  let j = 0;\\n\\n  for (; i < haystack.length; i += 1) {\\n    if (haystack[i] === needle[j]) {\\n      if (j === needle.length - 1) {\\n        return i - j;\\n      }\\n\\n      j += 1;\\n    } else {\\n      i -= j;\\n      j = 0;\\n    }\\n  }\\n\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401540,
                "title": "python-solution-using-kmp-string-matching-algorithm",
                "content": "Algorithm overview:\\n1. Generate the prefixes table. The prefixes table is a table with the same length as the needle. Each element `prefixes[i] ` represents the length of the longest prefix which is also a suffix from index 0 to i\\n2. Begin comparing the letters in `haystack` to the letters in `needle`. If it\\'s a match, increment both pointers. Otherwise, consult the prefixes table to find the value at `n-1` where n is the index pointer for `needle`. We want to move `n` to the position at `prefixes[n-1]` because it represents the last character of an already matched prefix.\\n\\n[This guy does a better job explaining. I know that sounded kind of convoluted.](http://https://www.youtube.com/watch?v=BXCEFAzhxGY)\\n\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tprefixes = [0] * len(needle) \\n\\ti, j = 0, 1\\n\\twhile j < len(needle):\\n\\t\\tif needle[i] == needle[j]:\\n\\t\\t\\tprefixes[j] = i+1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\ti = 0 if i == 0 else prefixes[i-1]\\n\\t\\t\\tif needle[i] != needle[j]:\\n\\t\\t\\t\\tprefixes[j] = 0\\n\\t\\t\\t\\tj += 1\\n\\n\\th, n = 0, 0\\n\\twhile h < len(haystack) and n < len(needle):\\n\\t\\tif haystack[h] == needle[n]:\\n\\t\\t\\th += 1\\n\\t\\t\\tn += 1\\n\\t\\telse:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn = prefixes[n-1]\\n\\n\\treturn h - len(needle) if n == len(needle) else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n\\tprefixes = [0] * len(needle) \\n\\ti, j = 0, 1\\n\\twhile j < len(needle):\\n\\t\\tif needle[i] == needle[j]:\\n\\t\\t\\tprefixes[j] = i+1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj += 1\\n\\t\\telse:\\n\\t\\t\\ti = 0 if i == 0 else prefixes[i-1]\\n\\t\\t\\tif needle[i] != needle[j]:\\n\\t\\t\\t\\tprefixes[j] = 0\\n\\t\\t\\t\\tj += 1\\n\\n\\th, n = 0, 0\\n\\twhile h < len(haystack) and n < len(needle):\\n\\t\\tif haystack[h] == needle[n]:\\n\\t\\t\\th += 1\\n\\t\\t\\tn += 1\\n\\t\\telse:\\n\\t\\t\\tif n == 0:\\n\\t\\t\\t\\th += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tn = prefixes[n-1]\\n\\n\\treturn h - len(needle) if n == len(needle) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 279941,
                "title": "rabin-karp-with-comments",
                "content": "```java\\nclass Solution {\\n    public int strStr(String source, String target) {\\n        int M = source.length();\\n        int N = target.length();\\n        if (M < N)\\n            return -1;\\n        long preCompute = 1;\\n        // to compute the mod of remove digits, base^(N-1) % q\\n        long hSource = 0;\\n        long hTarget = 0;\\n        long d = 31; // base\\n        long q = 1000000000000000003L; // hash table size\\n\\n        for (int i = 0; i < N - 1; i++) {\\n            preCompute = (preCompute * d) % q; // (a%n * b%n)%n\\n        }\\n\\n        for (int j = 0; j < N; j++) {\\n            hSource = (hSource * d + source.charAt(j)) % q;\\n            hTarget = (hTarget * d + target.charAt(j)) % q;\\n        }\\n        if (hSource == hTarget)\\n            return 0;\\n        for (int j = 1; j < M - N + 1; j++) {\\n            hSource = (hSource - source.charAt(j - 1) * preCompute) % q;\\n            // remove first digit\\n            hSource = (hSource * d + source.charAt(j + N - 1)) % q;\\n            // add new last digit\\n            if (hSource == hTarget) {\\n                if (source.substring(j, j + N).equals(target))\\n                    return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nThe main idea is to build a hash table for all substring in the source string with equal length with target string. As for how to build the hashtable, divide the substring by a very large prime. We can compute hash for substring based on the substring before it with O(1) time.\\nhttps://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int strStr(String source, String target) {\\n        int M = source.length();\\n        int N = target.length();\\n        if (M < N)\\n            return -1;\\n        long preCompute = 1;\\n        // to compute the mod of remove digits, base^(N-1) % q\\n        long hSource = 0;\\n        long hTarget = 0;\\n        long d = 31; // base\\n        long q = 1000000000000000003L; // hash table size\\n\\n        for (int i = 0; i < N - 1; i++) {\\n            preCompute = (preCompute * d) % q; // (a%n * b%n)%n\\n        }\\n\\n        for (int j = 0; j < N; j++) {\\n            hSource = (hSource * d + source.charAt(j)) % q;\\n            hTarget = (hTarget * d + target.charAt(j)) % q;\\n        }\\n        if (hSource == hTarget)\\n            return 0;\\n        for (int j = 1; j < M - N + 1; j++) {\\n            hSource = (hSource - source.charAt(j - 1) * preCompute) % q;\\n            // remove first digit\\n            hSource = (hSource * d + source.charAt(j + N - 1)) % q;\\n            // add new last digit\\n            if (hSource == hTarget) {\\n                if (source.substring(j, j + N).equals(target))\\n                    return j;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202076,
                "title": "0ms-in-go",
                "content": "```\\nfunc strStr(haystack string, needle string) int {\\n    if haystack == needle {\\n        return 0\\n    }\\n    for i := 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle) + i] == needle {\\n            return i\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc strStr(haystack string, needle string) int {\\n    if haystack == needle {\\n        return 0\\n    }\\n    for i := 0; i <= len(haystack) - len(needle); i++ {\\n        if haystack[i:len(needle) + i] == needle {\\n            return i\\n        }\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200800,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        for(var i = 0; i <= haystack.Length - needle.Length; i++){\\n            int j = 0;\\n            for(j = 0; j < needle.Length; j++){\\n                if(haystack[i + j] == needle[j]) continue;\\n                break;\\n            }\\n            if(j == needle.Length) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) {\\n        for(var i = 0; i <= haystack.Length - needle.Length; i++){\\n            int j = 0;\\n            for(j = 0; j < needle.Length; j++){\\n                if(haystack[i + j] == needle[j]) continue;\\n                break;\\n            }\\n            if(j == needle.Length) return i;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102698,
                "title": "video-step-by-step-visualization-of-o-n-kmp-algorithm",
                "content": "https://youtu.be/0iDiUuHZE_g\\n\\nThe KMP algorithm improves the brute force algorithm from O(m*n) to O(m+n) and consists of two parts.  The first part is the preprocessing step, where we find the length of \"the longest proper prefix that is also a suffix\" for every prefix in `needle`.\\n\\nThe second part is the main algorithm, where we compare `needle` and `haystack` letter-by-letter.  If two characters match, we move both pointers up and see how far we can keep going.  If they don\\'t match, then we use the array created in the preprocessing step to determine how far to move up `needle` to compare the next characters.  For a detailed explanation, please see the video - it\\'s very difficult to explain without visuals.  But the idea is that when traversing `needle` and hitting a mismatch, we know that any proper prefixes that are also a suffix will overlap, so we can skip those characters.\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        lps = [0] * len(needle)\\n\\n        # Preprocessing\\n        pre = 0\\n        for i in range(1, len(needle)):\\n            while pre > 0 and needle[i] != needle[pre]:\\n                pre = lps[pre-1]\\n            if needle[pre] == needle[i]:\\n                pre += 1\\n                lps[i] = pre\\n\\n        # Main algorithm\\n        n = 0 #needle index\\n        for h in range(len(haystack)):\\n            while n > 0 and needle[n] != haystack[h]:\\n                n = lps[n-1]\\n            if needle[n] == haystack[h]:\\n                n += 1\\n            if n == len(needle):\\n                return h - n + 1\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        lps = [0] * len(needle)\\n\\n        # Preprocessing\\n        pre = 0\\n        for i in range(1, len(needle)):\\n            while pre > 0 and needle[i] != needle[pre]:\\n                pre = lps[pre-1]\\n            if needle[pre] == needle[i]:\\n                pre += 1\\n                lps[i] = pre\\n\\n        # Main algorithm\\n        n = 0 #needle index\\n        for h in range(len(haystack)):\\n            while n > 0 and needle[n] != haystack[h]:\\n                n = lps[n-1]\\n            if needle[n] == haystack[h]:\\n                n += 1\\n            if n == len(needle):\\n                return h - n + 1\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992591,
                "title": "python3-one-line-faster-than-95",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n       return haystack.index(needle) if needle in haystack else -1    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n       return haystack.index(needle) if needle in haystack else -1    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346193,
                "title": "c-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) \\n    {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int StrStr(string haystack, string needle) \\n    {\\n        return haystack.IndexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252679,
                "title": "python3-23-ms-faster-than-97-85-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/3aa44090-1865-4a2c-a87b-324d98c5e33d_1677859735.583661.png)\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        h=len(haystack)\\n        n=len(needle)\\n        first_element_of_needle=needle[0]\\n        for i in range(h-n+1):\\n            if haystack[i]==first_element_of_needle and haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```\\nThe given code implements the strStr() function which returns the index of the first occurrence of a needle string in a haystack string. Here\\'s a step-by-step explanation of the code:\\n1. Define a function named \\'strStr\\' that takes two input strings \\'haystack\\' and \\'needle\\' and returns an integer.\\n1. Calculate the length of the \\'haystack\\' and \\'needle\\' strings and store them in the \\'h\\' and \\'n\\' variables, respectively.\\n1. Extract the first character of the \\'needle\\' string and store it in the \\'first_element_of_needle\\' variable.\\n1. Loop through each index \\'i\\' in the range 0 to \\'h-n+1\\':\\n\\t1. \\tCheck if the \\'i\\'th character of \\'haystack\\' is equal to the first character of \\'needle\\' and if the next \\'n\\' characters of \\'haystack\\' are equal to \\'needle\\'.\\n\\t1. \\tIf both the conditions are satisfied, return the current index \\'i\\'.\\n1. If no matching substring is found, return -1.\\n\\nNote that the time complexity of the strStr() function is O(nm), where n and m are the lengths of the \\'haystack\\' and \\'needle\\' strings, respectively. In the worst case, the algorithm has to compare all possible substrings of length \\'m\\' in the \\'haystack\\' string with the \\'needle\\' string. However, in the best case, where the first character of the \\'needle\\' string does not appear in the \\'haystack\\' string, the algorithm has a time complexity of O(n).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        h=len(haystack)\\n        n=len(needle)\\n        first_element_of_needle=needle[0]\\n        for i in range(h-n+1):\\n            if haystack[i]==first_element_of_needle and haystack[i:i+n]==needle:\\n                return i\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3251744,
                "title": "c-commented-tutorial-video-referenced",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nproblem is on pattern searching algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRabin Karp algorithm\\nFor tutorial video: [Rabin Karp Algorithm](https://www.youtube.com/watch?v=-WdkLyTeZ3Q)\\nConcept of [String Hashing](https://www.youtube.com/watch?v=JEOj8U54Cek) used in tutorial\\n\\n# Complexity\\nn = length of the needle \\nh = length of the haystack\\n- Time complexity: O(n+h)\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string h, string n) {\\n        // here n =needle and h=haystack\\n\\n        long long int q=31, m=1e9+7; \\n        long long int P=n.length();\\n        long long int S=h.length();\\n        if(S<P) return -1;   // example: needle=\\'aaaa\\' and haystack = \"aaa\"\\n        vector<long long int> power(S, 1);\\n        \\n        for(int i=1;i<S;i++)  //precomputation of powers with base q\\n        {\\n            power[i]=(power[i-1]*q)%m;\\n        }\\n\\n        long long int hash_n=0;  \\n        for(int i=0;i<P;i++)  // precompute the hash value of needle\\n        {\\n            hash_n=(hash_n+((n[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        vector<long long int> hash(S+1, 0);\\n        for(int i=0;i<S;i++)   // precompute the hash value of haystack substring from 0 till ith index \\n        {\\n            hash[i+1]=(hash[i]+((h[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        for(int i=0;i+P-1<S;i++)  \\n        {\\n            long long int cur_h=(hash[i+P]-hash[i]+m)%m;   // hash value of the window whose length is equal to the length of the needle string \\n            if(cur_h==(hash_n*power[i])%m)  // basic concept of Hashing => value matches with a substing in haystack => return the index\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;  //needle is not found \\n    }\\n};\\n```\\n*Please consider upvoting my solution if it was truly helpful to you, as it motivates me to continue contributing to the coding community. If you have any questions or suggestions for improvement, don\\'t hesitate to leave a comment and share your thoughts.*",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string h, string n) {\\n        // here n =needle and h=haystack\\n\\n        long long int q=31, m=1e9+7; \\n        long long int P=n.length();\\n        long long int S=h.length();\\n        if(S<P) return -1;   // example: needle=\\'aaaa\\' and haystack = \"aaa\"\\n        vector<long long int> power(S, 1);\\n        \\n        for(int i=1;i<S;i++)  //precomputation of powers with base q\\n        {\\n            power[i]=(power[i-1]*q)%m;\\n        }\\n\\n        long long int hash_n=0;  \\n        for(int i=0;i<P;i++)  // precompute the hash value of needle\\n        {\\n            hash_n=(hash_n+((n[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        vector<long long int> hash(S+1, 0);\\n        for(int i=0;i<S;i++)   // precompute the hash value of haystack substring from 0 till ith index \\n        {\\n            hash[i+1]=(hash[i]+((h[i]-\\'a\\'+1)*power[i])%m)%m;\\n        }\\n        for(int i=0;i+P-1<S;i++)  \\n        {\\n            long long int cur_h=(hash[i+P]-hash[i]+m)%m;   // hash value of the window whose length is equal to the length of the needle string \\n            if(cur_h==(hash_n*power[i])%m)  // basic concept of Hashing => value matches with a substing in haystack => return the index\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;  //needle is not found \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250871,
                "title": "python-simple-solution-for-noobs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nVery simple approach I have taken here just took a pointer to have location of the end named end which depicts the ending of needle string\\n\\nhere needle = \"sad\" and haystack=\"sadbutsad\"\\n=> **end=len(needle)** which is equal to 3\\n\\nNow we run the for loop to transverse from start till the length of haystack.\\n\\n=> **for start in range(*len(haystack)*)**\\n\\nhere start will have values from 0 till 9\\n\\nFurther we have provided with if condition to check whether the string in between the start and end pointer is equal to needle if yes then **return start** otherwise continue with the loop and increament the end by 1\\n\\nAt last if we do not find the required string that is needle we will **return -1**\\n\\n \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        end=len(needle)\\n        for start in range(len(haystack)):\\n            if haystack[start:end]==needle:\\n                return start\\n            end+=1\\n        return -1 \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def strStr(self, haystack, needle):\\n        \"\"\"\\n        :type haystack: str\\n        :type needle: str\\n        :rtype: int\\n        \"\"\"\\n        end=len(needle)\\n        for start in range(len(haystack)):\\n            if haystack[start:end]==needle:\\n                return start\\n            end+=1\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250746,
                "title": "clean-100-faster-c-solution-brute-optimal-solution-c-kmp-algorithm",
                "content": "# Brute-Force Solution (100% Faster)\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int l = needle.length();\\n        for(int i=0;i<=n-l;i++)\\n        {\\n            int j=0;\\n            for(;j<l;j++)\\n            {\\n                if(haystack[i+j]!=needle[j])\\n                {\\n                    break;\\n                }\\n            }\\n            if(j==l){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\nThe time complexity of the Brute-Force Approach is $$O(n*m)$$ where $$n$$ is the length of haystack & $$m$$ is the length of needle.\\n- Space Complexity: $$O(1)$$\\n\\n\\n# Optimal Approach (100% Faster)\\nWe will be using Sliding windows to implement the famous KMP(Knuth-Morris-Patt) Algorithm for string matching.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.size();\\n        int m=needle.size();\\n        int x=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(haystack[i]==needle[x])x++;\\n            else\\n            {\\n                i=i-x;\\n                x=0;\\n            }\\n            if(x==m)return i-x+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nThe optimal approach uses Linear Time Complexity of $$O(n+m)$$ where nis the length of haystack & m is the length of needle\\n\\n- Space complexity: $$O(1)$$\\nNo extra Space utilized\\n\\n\\n# Please Upvote if you find these solutions and Algorithms helpful !",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Sliding Window",
                    "String Matching"
                ],
                "code": "```c++ []\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n = haystack.length();\\n        int l = needle.length();\\n        for(int i=0;i<=n-l;i++)\\n        {\\n            int j=0;\\n            for(;j<l;j++)\\n            {\\n                if(haystack[i+j]!=needle[j])\\n                {\\n                    break;\\n                }\\n            }\\n            if(j==l){return i;}\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int n=haystack.size();\\n        int m=needle.size();\\n        int x=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(haystack[i]==needle[x])x++;\\n            else\\n            {\\n                i=i-x;\\n                x=0;\\n            }\\n            if(x==m)return i-x+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249528,
                "title": "daily-leetcoding-challenge-march-day-3",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3228201,
                "title": "100-0ms-java-two-pointer",
                "content": "# Approach\\nTwo Pointer Approach.\\nTake 2 pointers Left and Right, left poining to start of the string(index 0) and Right poining to the length of needle (needle.length) :\\n\\n1. If the length of needle and haystack is same (they are either the same string or not)\\n    1.(a) If they are same string, return 0;\\n    1.(b) Else, return -1 \\n2. If length of needle is greater than haystack, then you definitely won\\'t find the needle in haysack. Hence return -1\\n3. Iterate the loop till the Right reaches the end of the the haystack. Create a substring of Haystack from Left to Right and compare it with needle, \\n    3.(a) If both are same return Left index \\n    3.(b) Else Increment Left and Right both by 1\\n\\nIf at the end of the loop, you still haven\\'t found the needle in the Haystack, return -1  \\n<!-- Describe your approac\\nh to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int nl=needle.length();\\n        int i=0,j=i+nl;\\n        if (nl==haystack.length())\\n        {\\n            if(needle.equals(haystack))\\n                return 0;\\n            return -1;\\n        }\\n        else if(nl>haystack.length())\\n            return -1;\\n\\n        while(j<=haystack.length())\\n        {\\n            if(needle.equals(haystack.substring(i,j)))\\n                return i;\\n            i++;\\n            j++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int nl=needle.length();\\n        int i=0,j=i+nl;\\n        if (nl==haystack.length())\\n        {\\n            if(needle.equals(haystack))\\n                return 0;\\n            return -1;\\n        }\\n        else if(nl>haystack.length())\\n            return -1;\\n\\n        while(j<=haystack.length())\\n        {\\n            if(needle.equals(haystack.substring(i,j)))\\n                return i;\\n            i++;\\n            j++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169122,
                "title": "python3-4-lines-solution",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i, char in enumerate(haystack):\\n            if char == needle[0] and (i+ len(needle)-1) < len(haystack) and haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        for i, char in enumerate(haystack):\\n            if char == needle[0] and (i+ len(needle)-1) < len(haystack) and haystack[i:i+len(needle)] == needle:\\n                return i\\n        return -1\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021950,
                "title": "typescript-1-simple-solution-3-liners-90",
                "content": "\\uD83D\\uDC40 About the rules of this post [here](https://leetcode.com/problems/single-number/solutions/2973298/rules-v1-221231/).\\n\\n# Code (3 Liners, 90%)\\n- Here N is the length of `haystack` and M the length of `needle`\\n    - \\u2605 Time Complexity O(N - M + 1)\\n    - \\u2606 Space Complexity O(1)\\n    - Explanation\\n        - Loop through each strings built with the needle length\\n        - If it is the same as the needle, return the index\\n        - If nothing returned during the loop, return -1\\n```\\n// \\u2705 1 <= haystack.length, needle.length <= 104\\n// \\u2705 haystack and needle consist of only lowercase English characters.\\n\\nfunction strStr(haystack: string, needle: string): number {\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        if (haystack.slice(i, i + needle.length) === needle) return i\\n    }\\n\\n    return -1\\n};\\n```\\n\\n# Thank you\\n\\nUpvote if you like \\u2B06\\uFE0F\\nLet me know if you have any questions on the comment section.\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// \\u2705 1 <= haystack.length, needle.length <= 104\\n// \\u2705 haystack and needle consist of only lowercase English characters.\\n\\nfunction strStr(haystack: string, needle: string): number {\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        if (haystack.slice(i, i + needle.length) === needle) return i\\n    }\\n\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2968366,
                "title": "beats-100-easy-to-understand-problem-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int i,j;\\n        int len1=haystack.size(), len2=needle.size();\\n        for (i = 0; i <= len1-len2; i++) {\\n            for (j = 0; j <len2; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == len2) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int i,j;\\n        int len1=haystack.size(), len2=needle.size();\\n        for (i = 0; i <= len1-len2; i++) {\\n            for (j = 0; j <len2; j++) {\\n                if (haystack[i + j] != needle[j]) {\\n                    break;\\n                }\\n            }\\n            if (j == len2) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729132,
                "title": "easy-to-understand-java-solution",
                "content": "*Please Upvote...if u found it to be somewhat useful... : )*\\n\\n**Runtime:** 1 ms, faster than 69.03% of Java online submissions for Find the Index of the First Occurrence in a String.\\n**Memory Usage:** 41.8 MB, less than 63.10% of Java online submissions for Find the Index of the First Occurrence in a String.\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if(haystack.length()<needle.length()) return -1;\\n        char n=needle.charAt(0);\\n        for(int i=0; i<haystack.length(); i++){\\n            if(haystack.charAt(i)==n){\\n                if(i+needle.length()<=haystack.length()){\\n                    if(haystack.substring(i,i+needle.length()).equals(needle)){\\n                        return i;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Please Upvote... : )**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if(haystack.length()<needle.length()) return -1;\\n        char n=needle.charAt(0);\\n        for(int i=0; i<haystack.length(); i++){\\n            if(haystack.charAt(i)==n){\\n                if(i+needle.length()<=haystack.length()){\\n                    if(haystack.substring(i,i+needle.length()).equals(needle)){\\n                        return i;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671360,
                "title": "java-0ms-100-easy-understanding",
                "content": "![image](https://assets.leetcode.com/users/images/e6b7473c-bebc-401e-82f6-b688898f7060_1665125100.6460817.png)\\n**METHOD-1**\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int result = -1;                                //intialize result to -1\\n        if(haystack.contains(needle)) {                 //check haystack contains needle or not\\n            int index = haystack.indexOf(needle);       // get the index of haystack\\n            result = index;                             // if \"YES\" , assign the index of needle to result\\n        }\\n    return result;                                      //if \"NO\", return -1\\n    }\\n}\\n```\\n**METHOD-2**\\n```\\nclass Solution {\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\t\\treturn haystack.indexOf(needle);\\n    }\\n}\\n```\\n**PLEASE UPVOTE**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int result = -1;                                //intialize result to -1\\n        if(haystack.contains(needle)) {                 //check haystack contains needle or not\\n            int index = haystack.indexOf(needle);       // get the index of haystack\\n            result = index;                             // if \"YES\" , assign the index of needle to result\\n        }\\n    return result;                                      //if \"NO\", return -1\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int strStr(String haystack, String needle) {\\n\\t\\t\\treturn haystack.indexOf(needle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534828,
                "title": "c-100-faster-0-ms-runtime-easy-method-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n\\nint n = needle.size(); \\nint m = haystack.size();\\n\\n//we will iterate till this size as after this size it\\'s not possible to search \\nint search_space = m-n+1;\\n\\n//using substring and finding dummy_ans of size n and if it is equal to needle we return its index as we found our answer else if not found return -1\\n\\nfor(int i=0;i<search_space;i++){\\n\\tstring dummy_ans = haystack.substr(i,n);\\n\\tif(dummy_ans == needle){\\n\\treturn i;\\t\\n\\t\\t\\t}\\t\\t\\t\\t\\n}\\nreturn -1;        \\n    }\\n}; \\n``` \\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n\\nint n = needle.size(); \\nint m = haystack.size();\\n\\n//we will iterate till this size as after this size it\\'s not possible to search \\nint search_space = m-n+1;\\n\\n//using substring and finding dummy_ans of size n and if it is equal to needle we return its index as we found our answer else if not found return -1\\n\\nfor(int i=0;i<search_space;i++){\\n\\tstring dummy_ans = haystack.substr(i,n);\\n\\tif(dummy_ans == needle){\\n\\treturn i;\\t\\n\\t\\t\\t}\\t\\t\\t\\t\\n}\\nreturn -1;        \\n    }\\n}; \\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339886,
                "title": "c-100-faster-easy-solution",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int haystackL=haystack.length(),needleL=needle.length();\\n        for(int i=0;i<haystackL-needleL+1;i++)\\n        {\\n            if(needle[0]==haystack[i] && needle==haystack.substr(i,needleL))\\n\\t\\t\\t\\treturn i;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**If You Find it Hepful Kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int haystackL=haystack.length(),needleL=needle.length();\\n        for(int i=0;i<haystackL-needleL+1;i++)\\n        {\\n            if(needle[0]==haystack[i] && needle==haystack.substr(i,needleL))\\n\\t\\t\\t\\treturn i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268020,
                "title": "very-easy-c-java-c-javascript-solution-fully-explained-100",
                "content": "# **JAVA SOLUTION**\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        // Base condition\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n        // Special case\\n        if (haystack.equals(needle)) {\\n            return 0;\\n        }\\n        // Loop through the haystack and slide the window\\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\\n            // Check if the substring equals to the needle\\n            if (haystack.substring(i, i + needle.length()).equals(needle)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# **C++ SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        if (!needle.size()) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                for (int j = 0; j < needle.size(); j++) {\\n                    if (haystack[i+j] != needle[j])\\n                        break;\\n                }                \\n                if (j == needle.size())\\n                    return i;\\n            }            \\n        }        \\n        return -1;\\n    }\\n};\\n```\\n\\n# **JAVASCRIPT SOLUTION**\\n```\\nvar strStr = function (haystack, needle) {\\n    \\n    // Base condition\\n    if (haystack == null || needle == null) {\\n        return -1;\\n    }\\n    // Special case\\n    if (haystack === needle) {\\n        return 0;\\n    }\\n    // Loop through the haystack and slide the window\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        // Check if the substring equals to the needle\\n        if (haystack.substring(i, i + needle.length) === needle) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```\\n\\n# **C LANGUAGE**\\n```\\nint strStr(char * haystack, char * needle){\\n    \\n    if (strlen(needle) > strlen(haystack))\\n        return -1;  \\n    if (strlen(needle) == 0)\\n        return 0;  \\n    for (int i = 0; i < (strlen(haystack) - strlen(needle) + 1); i++) {\\n        if (strncmp(&haystack[i], needle, strlen(needle)) == 0)\\n            return i;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        \\n        // Base condition\\n        if (haystack == null || needle == null) {\\n            return -1;\\n        }\\n        // Special case\\n        if (haystack.equals(needle)) {\\n            return 0;\\n        }\\n        // Loop through the haystack and slide the window\\n        for (int i = 0; i < haystack.length() - needle.length() + 1; i++) {\\n            // Check if the substring equals to the needle\\n            if (haystack.substring(i, i + needle.length()).equals(needle)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        if (!needle.size()) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[0]) {\\n                for (int j = 0; j < needle.size(); j++) {\\n                    if (haystack[i+j] != needle[j])\\n                        break;\\n                }                \\n                if (j == needle.size())\\n                    return i;\\n            }            \\n        }        \\n        return -1;\\n    }\\n};\\n```\n```\\nvar strStr = function (haystack, needle) {\\n    \\n    // Base condition\\n    if (haystack == null || needle == null) {\\n        return -1;\\n    }\\n    // Special case\\n    if (haystack === needle) {\\n        return 0;\\n    }\\n    // Loop through the haystack and slide the window\\n    for (let i = 0; i < haystack.length - needle.length + 1; i++) {\\n        // Check if the substring equals to the needle\\n        if (haystack.substring(i, i + needle.length) === needle) {\\n            return i;\\n        }\\n    }\\n    return -1;\\n};\\n```\n```\\nint strStr(char * haystack, char * needle){\\n    \\n    if (strlen(needle) > strlen(haystack))\\n        return -1;  \\n    if (strlen(needle) == 0)\\n        return 0;  \\n    for (int i = 0; i < (strlen(haystack) - strlen(needle) + 1); i++) {\\n        if (strncmp(&haystack[i], needle, strlen(needle)) == 0)\\n            return i;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194130,
                "title": "python-simple-and-short-code-sliding-window",
                "content": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if (len(needle)==0):\\n            return []\\n        else :\\n            for i in range(0,len(haystack) - len(needle) + 1):\\n                if haystack[i:i+len(needle)]==needle :\\n                    return i\\n        return -1\\n                \\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if (len(needle)==0):\\n            return []\\n        else :\\n            for i in range(0,len(haystack) - len(needle) + 1):\\n                if haystack[i:i+len(needle)]==needle :\\n                    return i\\n        return -1\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683002,
                "title": "best-and-well-optimized-solution-same-as-find-pattern-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) break;\\n            }\\n            if (j == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int m = haystack.size(), n = needle.size();\\n        for (int i = 0; i <= m - n; i++) {\\n            int j = 0;\\n            for (; j < n; j++) {\\n                if (haystack[i + j] != needle[j]) break;\\n            }\\n            if (j == n) return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579951,
                "title": "simple-java-solution-no-cheating",
                "content": "Runtime: 1 ms, faster than 62.37% of Java online submissions for Implement strStr().\\nMemory Usage: 37.9 MB, less than 67.17% of Java online submissions for Implement strStr().\\n\\nRuntime: O(n * m).\\n\\nNaive solution (without use of KMP algorithm). Many solutions use `indexOf` and `substring` but I think that\\'s too easy - it defeats the point of the problem. Note converting to a character arrary is faster than using `charAt` to index the string.\\n\\n```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        \\n        char[] haystackCharArray = haystack.toCharArray();\\n        char[] needleCharArrary = needle.toCharArray();\\n        int i = 0, j = 0;\\n        while (i < haystackCharArray.length) { // traverse haystack\\n            if (haystackCharArray[i] == needleCharArrary[j]) {\\n                j++; // the current characters are equal, increment the needle\\n            } else { // if not equal, reset needle progress, go backwards in haystack\\n                i -= j;\\n                j = 0;\\n            }\\n            i++; // increment the haystack, be careful of off by 1 erors here\\n            if (j == needleCharArrary.length) {\\n                return i - j; // return the current index minus the length of the needle (start of the needle in haystack) if we\\'ve found a match for evey character in needle in the haystack\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        if (needle.length() == 0) return 0;\\n        \\n        char[] haystackCharArray = haystack.toCharArray();\\n        char[] needleCharArrary = needle.toCharArray();\\n        int i = 0, j = 0;\\n        while (i < haystackCharArray.length) { // traverse haystack\\n            if (haystackCharArray[i] == needleCharArrary[j]) {\\n                j++; // the current characters are equal, increment the needle\\n            } else { // if not equal, reset needle progress, go backwards in haystack\\n                i -= j;\\n                j = 0;\\n            }\\n            i++; // increment the haystack, be careful of off by 1 erors here\\n            if (j == needleCharArrary.length) {\\n                return i - j; // return the current index minus the length of the needle (start of the needle in haystack) if we\\'ve found a match for evey character in needle in the haystack\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445697,
                "title": "python-kmp-boyer-moore-rabin-karp",
                "content": "### KMP\\n\\n```python\\nclass Solution: \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        def get_dfa(p):\\n            n = len(p)\\n            res = [0] * n\\n            for i in range(1,n):\\n                j = res[i-1]\\n                while j > 0 and p[i] != p[j]:\\n                    j = res[j-1]\\n                res[i] = j + 1 if p[i] == p[j] else j\\n            return res\\n        \\n        j, n = 0, len(needle)\\n        if n == 0:\\n            return 0\\n        dfa = get_dfa(needle)\\n        for i, c in enumerate(haystack):\\n            while j > 0 and needle[j] != c:\\n                j = dfa[j-1]\\n                \\n            if c == needle[j]:\\n                j += 1\\n                \\n            if j == n:\\n                return i - j + 1\\n            \\n        return -1\\n```\\n\\n### Boyer-Moore\\n\\n```python\\nclass Solution: \\n\\tdef strStr(self, haystack: str, needle: str) -> int:\\n\\tm, n = len(haystack), len(needle)\\n\\tright = {c: i for i, c in enumerate(needle)}\\n\\n\\ti = 0\\n\\twhile i <= m - n:\\n\\t\\tskip = 0\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tc = haystack[i+j]\\n\\t\\t\\tif c != needle[j]:\\n\\t\\t\\t\\tskip = max(j - right.get(c, -1), 1)\\n\\t\\tif skip == 0:\\n\\t\\t\\treturn i\\n\\t\\ti += skip\\n\\treturn -1\\n```\\n\\n### Rabin-Karp\\n\\n```python\\nclass Solution:    \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        B, Q = 256, 101\\n        m, n = len(haystack), len(needle)\\n        \\n        rm = 1\\n        for _ in range(len(needle) - 1):\\n            rm = (rm * B) % Q\\n        \\n        def hash(txt):\\n            h = 0\\n            for c in txt:\\n                h = (h * B + ord(c)) % Q\\n            return h\\n        \\n        t_hash, p_hash = hash(haystack[:n]), hash(needle)\\n        if t_hash == p_hash and haystack[:n] == needle:\\n            return 0\\n\\n        for i in range(n,m):\\n            t_hash = (t_hash + Q - ord(haystack[i - n]) * rm % Q) % Q\\n            t_hash = (t_hash * B + ord(haystack[i])) % Q\\n\\n            if t_hash == p_hash and haystack[i-n+1:i+1] == needle:\\n                return i - n + 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution: \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        def get_dfa(p):\\n            n = len(p)\\n            res = [0] * n\\n            for i in range(1,n):\\n                j = res[i-1]\\n                while j > 0 and p[i] != p[j]:\\n                    j = res[j-1]\\n                res[i] = j + 1 if p[i] == p[j] else j\\n            return res\\n        \\n        j, n = 0, len(needle)\\n        if n == 0:\\n            return 0\\n        dfa = get_dfa(needle)\\n        for i, c in enumerate(haystack):\\n            while j > 0 and needle[j] != c:\\n                j = dfa[j-1]\\n                \\n            if c == needle[j]:\\n                j += 1\\n                \\n            if j == n:\\n                return i - j + 1\\n            \\n        return -1\\n```\n```python\\nclass Solution: \\n\\tdef strStr(self, haystack: str, needle: str) -> int:\\n\\tm, n = len(haystack), len(needle)\\n\\tright = {c: i for i, c in enumerate(needle)}\\n\\n\\ti = 0\\n\\twhile i <= m - n:\\n\\t\\tskip = 0\\n\\t\\tfor j in range(n-1, -1, -1):\\n\\t\\t\\tc = haystack[i+j]\\n\\t\\t\\tif c != needle[j]:\\n\\t\\t\\t\\tskip = max(j - right.get(c, -1), 1)\\n\\t\\tif skip == 0:\\n\\t\\t\\treturn i\\n\\t\\ti += skip\\n\\treturn -1\\n```\n```python\\nclass Solution:    \\n    def strStr(self, haystack: str, needle: str) -> int:\\n        B, Q = 256, 101\\n        m, n = len(haystack), len(needle)\\n        \\n        rm = 1\\n        for _ in range(len(needle) - 1):\\n            rm = (rm * B) % Q\\n        \\n        def hash(txt):\\n            h = 0\\n            for c in txt:\\n                h = (h * B + ord(c)) % Q\\n            return h\\n        \\n        t_hash, p_hash = hash(haystack[:n]), hash(needle)\\n        if t_hash == p_hash and haystack[:n] == needle:\\n            return 0\\n\\n        for i in range(n,m):\\n            t_hash = (t_hash + Q - ord(haystack[i - n]) * rm % Q) % Q\\n            t_hash = (t_hash * B + ord(haystack[i])) % Q\\n\\n            if t_hash == p_hash and haystack[i-n+1:i+1] == needle:\\n                return i - n + 1\\n        return -1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565202,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1568123,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566418,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1565342,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1570759,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1567172,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1564985,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1575815,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566693,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566235,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1565202,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1568123,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566418,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1565342,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1570759,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1567172,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1564985,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1575815,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566693,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1566235,
                "content": [
                    {
                        "username": "Siddharth2k007",
                        "content": "Who marked this as `Easy`? It\\'s not easy at all. Though you can easily produce O(mn) solution, it is not accepted for python. You need KMP algorithm to produce O(m + n) solution!"
                    },
                    {
                        "username": "countdankula",
                        "content": "[@chazwinter](/chazwinter) Lol. The interviewer will just kick you out if you use indexof() to solve this problem."
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s marked easy because the point is to teach you how to use indexOf.\\nIt\\'s only difficult when you fail to learn it lol"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "Use sliding window, its that easy\\n"
                    },
                    {
                        "username": "dezann1990",
                        "content": "dude, it is oneliner"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "[@Anshmehta380](/Anshmehta380) But that is not the thing Leetcode trying to test;\\nIt wants us to study the working of indexOf () method"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "[@howardcho](/howardcho) Same for me in java"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Bro just use indexOf() method i solved it in a one line code lol"
                    },
                    {
                        "username": "charonme",
                        "content": "tha naive O(n^2) solution is now being accepted, but if the testcases contained enough tests with long enough strings it would give a TLE"
                    },
                    {
                        "username": "aalmos",
                        "content": "[@Mister_CK](/Mister_CK) good luck with doing that on an interview bro. "
                    },
                    {
                        "username": "howardcho",
                        "content": "I\\'m not sure if there\\'s a better way, but this was a one-line solution for me in python."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "?! This is one of the easiest problems on the site, a.indexOf(b) satisfies all requirements (O(mn) time complexity I believe), at least in JS. took me 37 seconds, beats 87%"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "[@jdipirro](/jdipirro) exactly, this is just solved in O(N). I am wondering why it is medium"
                    },
                    {
                        "username": "calm27",
                        "content": "Python3 `O(mn)` is acceptable. "
                    },
                    {
                        "username": "pieceofpie",
                        "content": "It is now a ```Medium``` problem."
                    },
                    {
                        "username": "jdipirro",
                        "content": "Is this answer not valid for some reason?  They remarked it medium, but it can be solved with the super easy method below\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        for x in range(len(haystack)):\\n            if haystack[lx : x + len(needle)] == needle:\\n                return x\\n        else:\\n            return -1"
                    },
                    {
                        "username": "narayan48",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n          int indexOfSubStr = haystack.indexOf(needle);\\n          return indexOfSubStr;\\n\\n    }\\n    //return -1;\\n}"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "dude it is a one line solution in java and it takes 0ms to run"
                    },
                    {
                        "username": "SugerSu",
                        "content": "Maybe sometimes we do not need to think too much!\\n\\npublic int strStr(String haystack, String needle) {\\n\\n\\t\\t\\n\\t\\treturn haystack.indexOf(needle);\\n\\t}"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "similarly you can use find() function in c++\\n```\\nreturn haystack.find(needle);\\n```"
                    },
                    {
                        "username": "enkil2003",
                        "content": "and that is how you never get a job."
                    },
                    {
                        "username": "hippofaris",
                        "content": "giga chad"
                    },
                    {
                        "username": "qAxP4Mw",
                        "content": "[@Meerkats1999](/Meerkats1999) however if your coworker reimplemented indexOf on a project everyone would be pretty annoyed so I think interviewer should accept this answer. Otherwise they should be more clear about what they\\'re looking for."
                    },
                    {
                        "username": "yuangaonyc",
                        "content": "Maybe you should think more"
                    },
                    {
                        "username": "chazwinter",
                        "content": "Don\\'t provide solutions, no matter how easy you think they are.\\nThis answer uses built in Java functionality without imports, so it\\'s fair game. If they wanted you to design your own indexOf method, they would have said so. \\n\\nThere are other problems that specifically say to avoid certain methods, or ask a follow to challenge you to try it another way. This one does not have that, so I see it as an attempt to expose new people to indexOf."
                    },
                    {
                        "username": "dantruongdo3",
                        "content": "[@Meerkats1999](/Meerkats1999) i use the exact same way and feel kinda guilty."
                    },
                    {
                        "username": "Meerkats1999",
                        "content": "I don\\'t think the interviewer will like this answer."
                    },
                    {
                        "username": "emcc1990",
                        "content": "I also submitted this but having doubts of whether the whole point is not to use it and implement something raw. "
                    },
                    {
                        "username": "user0566A",
                        "content": "It\\'s interesting that java indexOf do not use KMP (because of memory I think) or Rabin-Karp (don\\'t know why)\\nhttps://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/lang/StringLatin1.java#L233-L253"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@therishuraj](/therishuraj) My indexOf solution beats 91%... It\\'s definitely fast enough and thus I strongly feel this should be easy. Otherwise LeetCode should drastically limit the time-constraints in my opinion"
                    },
                    {
                        "username": "user0743xF",
                        "content": "[@mohan9814](/mohan9814) because here people are coming to learn algorithms i think :)"
                    },
                    {
                        "username": "therishuraj",
                        "content": "[@mohan9814](/mohan9814)  Because time complexity of the KMP algorithm is O(m+n) And time complexity of the indexOf method is O(nm). "
                    },
                    {
                        "username": "mohan9814",
                        "content": "yes same logic in c++ is working fine why do i need to get into kmp and all this"
                    },
                    {
                        "username": "mgoldenbe",
                        "content": "I don\\'t think they meant that I can call a library function. Also, I get \"Time Limit Exceeded\" on brute-force. So, this means I should use an advanced algorithm, like Rabin-Karp or KMP. Why then is this problem marked \"easy\"?"
                    },
                    {
                        "username": "chazwinter",
                        "content": "It\\'s easy because the point is to teach you to 1) stop overthinking things, and 2) learn one single function that solves the problem in one line."
                    },
                    {
                        "username": "C0de_bumstead",
                        "content": "Can be easily solved using sliding window duhh...."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why should it be marked ```Medium```. This is literally 1line of code or 28 symbols(I\\'m counting the ```return``` function). You don\\'t need any algorithm. You need one function (if you use python3). And that function starts of the letter \"f\""
                    },
                    {
                        "username": "2020uch0017",
                        "content": "it is medium now and yes it is a KMP  problem"
                    },
                    {
                        "username": "jarc",
                        "content": " Is it the standard string matching problem? Am I wrong?"
                    },
                    {
                        "username": "chickooo",
                        "content": "Yeah, this is the standard string matching problem.\\nYour function should perform same as **.find()** function in python OR **.indexOf()** function in javascript"
                    },
                    {
                        "username": "tlong1299",
                        "content": "**USE FIND**\\nAs a Python programmer, refusing to use core language features is akin to using a hammer instead of nail-gun because it makes you a \"better\" carpenter. Remember that this is Python not C. Python\\'s PEP 20 states, \"There should be one-- and preferably only one --obvious way to do it.\" I would call a string operation built into python designed to solve this particular problem the obvious way to do it.\\n\\n**DON\\'T USE FIND**\\nIf you go into an interview and solve this problem with the find() function, you better know how it works underneath, and you should be prepared to defend your use of it. After all nothing is \"free\" in your code, and even \"magic\" functions have a time and memory cost associated with them. Knowing what this cost is, and why it is the way it is will make you a better programmer. Implementing the function yourself, at least once, can really help you develop a better appreciation for the language."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Finally, a Python programmer that isn\\'t an idiot. It\\'s wild how people overthink this problem."
                    },
                    {
                        "username": "marten2",
                        "content": "Hey,\\n\\nI wouldn't say that coming up with the KMP algorithm from scratch is easy ~1 hour time. Did companies that asked this question expect applicants to know KMP by heart? Did they expect the applicant to show a naive implementation? Any opinion on this?\\n\\nBest,\\n\\nMarten"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "[@chazwinter](/chazwinter) is it Python specific task? Or what is indexOf in C++? "
                    },
                    {
                        "username": "chazwinter",
                        "content": "No, they expected you to know indexOf. Don\\'t overthink it."
                    },
                    {
                        "username": "zijianz",
                        "content": "Input: \\t\"\", \"\"\\nOutput: \\t-1\\nExpected: \\t0\\n\\nBasically there is nothing in the string, how do you get the index.\\n\\nIf this test case is valid, then needle =\"\", haystack=\"anything\" could return any value. since empty is everywhere."
                    },
                    {
                        "username": "chazwinter",
                        "content": "Read the constraints. If you had to deal with an empty string, you would simply write an edge case for it."
                    },
                    {
                        "username": "mansourcodes",
                        "content": "1 <= haystack.length, needle.length <= 104\\n"
                    },
                    {
                        "username": "cxaviousb",
                        "content": "> In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has 'a' at 0 index.\n\n[@AvniGoyal22](/AvniGoyal22) That's programming language specific logic.  Let's try applying logic from JavaScript to this problem~\n\n```javascript\n> 'anything'.indexOf('')\n< 0\n> ''.charAt(0)\n< \"\"\n> ''.charAt(9001)\n< \"\"\n> 'anything'.lastIndexOf('')\n< 8\n< \"anything\"\n> 'anything'.substr(0,9)\n< \"anything\"\n> 'anything'.substr(9001,9)\n< \"\"\n```"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "i think you have to make the case of if the string is empty"
                    },
                    {
                        "username": "AvniGoyal22",
                        "content": "In a string, the last element is null character. In the first case, where it is \"\",\"\" both of them has same character that is null character, while in \"\",\"anything\" the first string has null character at 0 index while the next one has \\'a\\' at 0 index. "
                    },
                    {
                        "username": "SarK97",
                        "content": "Why this test case is returning -1? Shouldn\\'t it be 4 since it is a substring?\\n\"mississippi\"\\n\"issip\""
                    },
                    {
                        "username": "impatientcat07",
                        "content": "Here comes the Overlapping case while comparing \"issis\" -> \"issip\" it rejects and reinitializes and starts from \"sippi\" & \\n comparing \"issip\", which in turns return -1; "
                    },
                    {
                        "username": "flyingfist",
                        "content": "its because it is taking issis (index 1 to 5) as index 5 is not matching it goes further and doesnt get issip "
                    },
                    {
                        "username": "MaheshPatil19",
                        "content": "here needle =\"issipi\""
                    },
                    {
                        "username": "chickooo",
                        "content": "If you add this test case ( I just did ), the output is 4 as expected.\\nDon\\'t know why you are getting -1. \\nMaybe there were unwanted spaces in your input. Can you try that again?"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Most of python submissions are based on cheating (s.index() or s.find()).\\nIt is a pitty that when implementing it in pure python (the naive `O(n*m)` way) it results in timeout.\\nIt should either be accepted for `O(n*m)` or if some better approach is expected like with a rolling hash then it should be marked as medium IMHO."
                    },
                    {
                        "username": "ryo-kozin",
                        "content": "I believe  an interviewer would be fine with ussing indexOf(). In real-world programming situations, it is often advisable to take full advantage of available built-in functions and libraries. "
                    },
                    {
                        "username": "labule",
                        "content": "[@Deecodes25](/Deecodes25)  Time Complexity is O(n*m). `haystack[i:j] == needle` touches `m` chars and you do this approximately `n` times."
                    },
                    {
                        "username": "youttsu",
                        "content": "true dude. it works on JS with O(m*n) time complexity though "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "I solved with this approach, can anyone explain what is the Time Complexity for this - \\n```\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        i=0\\n        j=len(needle)\\n        while j<=len(haystack):\\n            if haystack[i:j] == needle:\\n                return i\\n            i+=1\\n            j+=1\\n        return -1\\n```"
                    },
                    {
                        "username": "veerashah1",
                        "content": "[@chickooo](/chickooo) Wouldn\\'t an interviewer be fine with .indexOf(), because there\\'s no reason to re-invent the wheel when there are built in functions? If they specifically ask to avoid it then I guess, but in this case they didn\\'t."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Why is using indexOf cheating? Nowhere is it stated that you shouldn\\'t use that. If they don\\'t want you to use that they should say so, or limit the time constraints to only allow O(N+M)"
                    },
                    {
                        "username": "shaan__0w0",
                        "content": "but it gets submitted by using .indexOf() in java \\n"
                    },
                    {
                        "username": "chickooo",
                        "content": "Agreed with your opinion.\\nIf you were to use just built in function like .find() or .indexOf(), then the problem wouldn\\'t be labeled **Medium**. And if you were in an interview, the interviewer would not be pleased."
                    },
                    {
                        "username": "chehsunliu",
                        "content": "I have solved this problem. However, I think it may be controversial to return index 0 when the inputs are \"A\" and \"\". In my opinion, one of the inputs is \"A\\\\0\" and the other is \"\\\\0\". Perhaps it should return index 1."
                    }
                ]
            },
            {
                "id": 1971779,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1820134,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1715310,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1567049,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1570935,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1570927,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1576731,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1569487,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1567173,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1819969,
                "content": [
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of the KMP Algorithm\\n\\nhttps://youtu.be/0iDiUuHZE_g"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I think Leetcode needs to implement a few testcases where O(n*m) solutions should not be accepted."
                    },
                    {
                        "username": "maratichts",
                        "content": "for java this is for sure an easy problem"
                    },
                    {
                        "username": "shiva97",
                        "content": "I find the KMP algorithm not easy to understand. Wondering why this question is categorized into easy. If the O(m* n) is the expected solution then I agree its easy. I dont think that O(m* n) solution will be accepted in an interview."
                    },
                    {
                        "username": "sachinsharma_11",
                        "content": "![image](https://assets.leetcode.com/users/images/925e6af3-3919-40f2-99b9-742b0df69e22_1656404905.2271748.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "tabrejalamreh",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "yagniktalaviya4122002",
                        "content": "![image](https://assets.leetcode.com/users/images/8af38d85-0eeb-4f1f-9c30-ac7cc6d6579d_1652076284.6094553.png)\\n"
                    },
                    {
                        "username": "sophie0217nz",
                        "content": "I saw your answer and figured it out. but I changed( i<haystack.length()-needle.length()+1); (haystack.substring(i,i+needle.length()).equals(needle)), thank you for giving me the clue. I hope my change would also give you a clue."
                    },
                    {
                        "username": "woodyinho",
                        "content": "Is it okay  to use substring method in a problem like this in the interviews ?"
                    },
                    {
                        "username": "rivanrmail",
                        "content": "too late, but it is not, if anyone is reading this in future."
                    },
                    {
                        "username": "Chuck1991",
                        "content": "Input:\\n\"a\"\\n\"\"\\n\\nOutput:\\n-1\\n\\nExpected:\\n0"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "It\\'s a invalid testcase,see the constraints"
                    },
                    {
                        "username": "XOFJO",
                        "content": "Do not use built-in function!"
                    }
                ]
            },
            {
                "id": 1567814,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1820146,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1678692,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1574132,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1573363,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1569522,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1568847,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 2036478,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1923412,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1820037,
                "content": [
                    {
                        "username": "lzhao",
                        "content": "The problem states that it should return the first occurrence. Is it the same as needle?"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "People who are using built in functions do you think ur solution will be accepted in an interview?"
                    },
                    {
                        "username": "atifhu",
                        "content": "Those who are using in built functions are the ones who will say after their interview \"kya pta interviewer kch KMP aur Z- algo k bare me bol rha tha\" :D"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Is it right to use sliding window approach here with string library function...\\nAs I have used to get correct answer"
                    },
                    {
                        "username": "rexhu100",
                        "content": "This is not a easy problem. I know using built-in hashing function is easy, and probably passible. But the intent for the problem is obviously to use Karp-Rabin, which is not easy at all to implement from scratch."
                    },
                    {
                        "username": "pratikjain227",
                        "content": "\\ttry:\\n\\t\\treturn haystack.index(needle)\\n\\texcept:\\n\\t\\treturn -1\\n\\n"
                    },
                    {
                        "username": "minh-nguyen-mqn",
                        "content": "or just return haystack.find(needle)"
                    },
                    {
                        "username": "Wasant_from_asia",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "czkudo",
                        "content": "see title. what's the meaning of this problem if we can just use indexOf()"
                    },
                    {
                        "username": "Robin_Rathore",
                        "content": "Although This (return haystack.find(needle); ) beats 100% of CPP users, but to practice problems genuinely not just to increase the no. we should do it with our own logic not with any lib fun.\n"
                    },
                    {
                        "username": "syfo_dias",
                        "content": "exactly. Because it doesn't make any sense otherwise. It's like solving a sorting problem by using std::sort"
                    },
                    {
                        "username": "MehtaParth",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        if (needle.empty()) {\\n            return 0;\\n        }\\n        \\n        int j = 0;\\n        int x = -1;\\n        for (int i = 0; i < haystack.size(); i++) {\\n            if (haystack[i] == needle[j]) {\\n                if (j == 0) {\\n                    x = i;  \\n                }\\n                j++;\\n                if (j == needle.size()) {\\n                    return x;  \\n                }\\n            } else {\\n                j = 0;  \\n                x = -1;\\n            }\\n        }\\n        \\n        return -1;  \\n    }\\n};\\n\\n\\nThis code fails to find \"issip\" in \"mississippi\".\\nCan someone find the error"
                    },
                    {
                        "username": "Izaki11",
                        "content": "After failing the check at \\'p\\', the loop continues past the previous \\'i\\', which is where the \"needle\" starts."
                    },
                    {
                        "username": "cheesebread",
                        "content": "...why is this is a medium? Seems pretty straightforward to me"
                    }
                ]
            },
            {
                "id": 1819992,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1631521,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1576975,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575928,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575336,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575306,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1575135,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1574277,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1574187,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1574116,
                "content": [
                    {
                        "username": "dunglee30",
                        "content": "Move to submission to find how can they solve this in O(n+m) and 0ms just to see \n```haystack.indexOf(needle)``` =)))))"
                    },
                    {
                        "username": "dunglee30",
                        "content": "[@Swapnil07072000](/Swapnil07072000) I did solve it without built-in function bro :)) It just funny story that some of the best solutions were built-in function and got accepted."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Try using Two-pointer approach and not built-in function."
                    },
                    {
                        "username": "c4tdog",
                        "content": "you think leetcode wants you to use builtin function? think again"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "Is it okay to use data structure in solving this?"
                    },
                    {
                        "username": "NatureSon22",
                        "content": "I want to use one but it makes me feel illegal\\n"
                    },
                    {
                        "username": "prasadnr606",
                        "content": "The solution is in the subject-line."
                    },
                    {
                        "username": "rayray0706",
                        "content": "![image](https://assets.leetcode.com/users/images/87152572-92da-491b-84df-2b9ab40e7c5a_1635980565.4132447.png)\\n\\n\\nHopefully, theres not a simple reason for this I\\'m missing, but I\\'m not understanding why I\\'m getting this error on this test case and on this line of code. There was another LeetCode problem that was giving me the same error, and I\\'m afraid its my browser or something."
                    },
                    {
                        "username": "tirupati",
                        "content": "Not sure there are so many posts titled with n complexcity but its not.\\n\\nIf you are not using KMP and using two pointers then complexcity would be n * m because we have two loops. One of iterating main string(outer-loop complexcity n-m) and other for checking in the sub string (inner-loop complexcity m).\\ncomplexcity: (n - m) * m = O(nm)\\n\\nReference: https://leetcode.com/problems/implement-strstr/"
                    },
                    {
                        "username": "ChenYehChien001",
                        "content": "![image](https://assets.leetcode.com/users/images/c7ddb51f-f40c-43c3-b10a-6072341a7681_1621912158.6232688.png)\\n"
                    },
                    {
                        "username": "adrianyang2012",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "sknavin369",
                        "content": "The best way to get the position of the first Occurence of needle in haystack is to go with **strstr in-built String Function**, which returns the pointer of the first occurence of needle. Else it returns NULL.\\n\\n\\tint strStr(char * haystack, char * needle){\\n\\t\\t\\n\\t\\tchar *pos = strstr(haystack, needle);\\n\\t\\treturn pos ? pos-haystack : -1;\\n\\t}"
                    },
                    {
                        "username": "jeetrainer",
                        "content": "Link of solution: https://youtu.be/4yT8mpJxHks"
                    },
                    {
                        "username": "BroCode01",
                        "content": "https://youtu.be/TsxFvVy_5m0"
                    }
                ]
            },
            {
                "id": 1573794,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1573741,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1573649,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1573027,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1572330,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1572232,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1571933,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1571070,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1570563,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1568848,
                "content": [
                    {
                        "username": "vijayabaskar",
                        "content": "I see everyone is using language builtin function.  Just wanted to say, the efficient solution is some string search algorithm.  One such algorithm is KMP search.\\n\\nJust want to say it here."
                    },
                    {
                        "username": "nandinisrivastava29",
                        "content": "return haystack.indexOf(needle);\\n"
                    },
                    {
                        "username": "dmb17",
                        "content": "return  haystack.indexOf(needle);"
                    },
                    {
                        "username": "kitmanwork",
                        "content": "![image](https://assets.leetcode.com/users/kitmanwork/image_1569031883.png)\\n"
                    },
                    {
                        "username": "CNife",
                        "content": "You library function guys great."
                    },
                    {
                        "username": "sunxiong90",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "bazilione",
                        "content": "My comment: The problem description asks to return 0 when needle is an empty string, but the match also can have index 0 if string is not empty. This will make the output confusing. -2 if empty string would solve a problem."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "The expected results are both 0 , Isn't it a bit weird ?"
                    },
                    {
                        "username": "Lets1112D",
                        "content": "func strStr(haystack string, needle string) int {\\n\\tvar ind int\\n\\n\\tind = strings.Index(haystack, needle)\\n\\tfmt.Println(ind)\\n\\n\\treturn ind\\n}"
                    },
                    {
                        "username": "young_stone",
                        "content": "if i use the bruth-force method, not the KMP algorithm, the best time is O(m), the worst time is O(mn). (m is length of longer string, n is the length of another string). What's the average time complexity and why?"
                    },
                    {
                        "username": "bl4z1ng",
                        "content": "[@young_stone](/young_stone) There's no such thing as average time complexity 'cause time complexity itself shows the **worst** possible situtaion and shows, how time of computing your algorithm will grow up on increasing of elements number. So it's not about time, it's about speed of growing, so your answer is O(mn)"
                    },
                    {
                        "username": "charonme",
                        "content": "best case is actually O(1) - it\\'s when the haystack and needle have the same length and different first characters"
                    }
                ]
            },
            {
                "id": 1568665,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1576249,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1576145,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1576056,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1575895,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 1574225,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2075727,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2074692,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2059899,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2059046,
                "content": [
                    {
                        "username": "girinatarajan",
                        "content": "return haystack.find(needle)"
                    },
                    {
                        "username": "sankarees",
                        "content": "I have updated the code in my github. Please refer the below link to check the source code and time complexity to run this code.\\n\\nhttps://github.com/sankarees/program-interview-job-learning/upload/main/myplayground/src/myplayground\\n\\n\\n![image](https://assets.leetcode.com/users/images/a10f90bf-98d0-4b5d-8e80-870face53c8f_1642430181.1675096.jpeg)\\n\\n\\n"
                    },
                    {
                        "username": "charan_rs_guru",
                        "content": "return haystack.indexOf(needle);"
                    },
                    {
                        "username": "bosserbosser",
                        "content": "\\tWe commonly use String::charAt to get a char from String, and that function do more things than just get an element from the inner char array instance. Unless making a copy of the inner char array first, it will be unfair for us to compete with the sdandard library. The best way to acess the inner char array is to call String::toCharArray, which actually makes a copy instead of returning the original array Object."
                    },
                    {
                        "username": "SuvenduGhosh",
                        "content": "\\'\\'\\'\\nreturn haystack.find(needle)\\n\\'\\'\\'"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "![image](https://assets.leetcode.com/users/images/db642348-ec38-44ee-934e-3a5074438185_1597595613.9781873.png)\\n\\n![image](https://assets.leetcode.com/users/images/733c099d-3b1d-4339-a93b-89068aa96d35_1597595620.1702633.png)\\n\\n* see why hash function selection is important\\n![image](https://assets.leetcode.com/users/images/76661a64-e6d5-4231-bf1d-013748456c8c_1597595850.0052273.png)\\n\\n"
                    },
                    {
                        "username": "babayagaaaa",
                        "content": "Its like a swamp, the more you try, the more you drown. \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Elsone",
                        "content": "My solution is accepted but the run time is not that good. Time complexity O(n-len(needle)). shift one char at a time and i check if needle is include in the current substring"
                    },
                    {
                        "username": "vinay_jain_61787",
                        "content": "In c++ we could use the built in function find() to find the occurence of the word. \\nWith which we could beat 100% of the users\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Anyone getting wrong answer on test case:\\nhaystack: \"ababcaababcaabc\"\\nneedle: \"ababcaabc\"\\nany advice how to tackle it"
                    }
                ]
            },
            {
                "id": 2057646,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2049472,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2033026,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2026596,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2025851,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2024838,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2023865,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2023694,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2017561,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2015002,
                "content": [
                    {
                        "username": "greensignal",
                        "content": "Why people are using KMP Algo and noone talking of Rabin Karp Algo, timme complexity of both being O(m+n), O(n-m+1) respectively..."
                    },
                    {
                        "username": "buli03",
                        "content": "c# brute force go brrrrrrrrrrr"
                    },
                    {
                        "username": "ashishr0301",
                        "content": "KISS.\\n:) "
                    },
                    {
                        "username": "GouravSingh1729",
                        "content": "Use substring wiht try catch "
                    },
                    {
                        "username": "tanvith_shen0y",
                        "content": "problem on O(mn)  : 😊\nproblem on O(m+n) : 💀"
                    },
                    {
                        "username": "psionl0",
                        "content": "# MSD vs Rabin-Karp\\nI coded this problem using both the MSD algorithm (https://leetcode.com/submissions/detail/1027485142/) and the Rabin-Karp algorithm (https://leetcode.com/submissions/detail/1028159652/). Both algorithms ran in 0 ms and took 5.5 MB.\\nAlthough I understand what the MSD algorithm is doing, I found the coding a little unintuitive meaning that I probably wouldn\\'t be able to  duplicate the code in an interview without using a cheat sheet.\\nHowever, a rolling hash function is easy to compute and I found the whole Rabin-Karp algorithm quite intuitive. Although a character count comparison isn\\'t revealing, it seems that Rabin-Karp requires slightly less coding than MSD but you need to test for more edge cases (for example, if the needle is longer than the haystack then MSD appears to cope but Rabin-Karp fails).\\nMy vote: Rabin-Karp"
                    },
                    {
                        "username": "rastogi31",
                        "content": "here in C++ inbuilt substring function\\n `class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos)\\n    return (found);   //first occur\\n  else \\n    return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "selmun13",
                        "content": "hey guys I\\'ve encountered a problem when I try to submit a Runtime Error occurred because of heap buffer overflow, however the two test cases passed with no problems. \\nPS: Im using C"
                    },
                    {
                        "username": "Venota",
                        "content": "idk why my code is wrong..  i use python3, in this web terminal it doesn\\'t accept, but in PyCharm it\\'s correct\\nMy code:\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        if needle not in haystack:\\n            print(-1)\\n        else:\\n            a = len(haystack)\\n            b = len(needle)\\n            for i in range(a):\\n                if str(needle[0:(b - 1)]) == str(haystack[i:(i + b - 1)]):\\n                    print(i)\\n                    break"
                    },
                    {
                        "username": "HarshSaini07",
                        "content": " class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        auto it = haystack.find(needle);\\n        if(it != haystack.end()){  // in this condition an error generates , what should i do ?\\n \\n            return it;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2014837,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2011323,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2011317,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2001913,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 2000794,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1995771,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1994905,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1990691,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1986252,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1981863,
                "content": [
                    {
                        "username": "Squirrel848",
                        "content": "I somehow feel like this can linked with problem 14. If you decide to use String.StartsWith()"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Here\\'s a concise algorithm to solve the \"Implement strStr()\" problem using a sliding window approach:\\n\\n1. Initialize haystackLen as the length of the haystack string and needleLen as the length of the needle string.\\n\\n2. Check for the special case where needleLen is 0. If true, return 0.\\n\\n3. Loop through the haystack string from index 0 to haystackLen - needleLen:\\n\\n- If the character at the current index i in the haystack matches the first character of the needle:\\n- Use the substring method to extract a substring of length needleLen starting from index i.\\n- Compare the extracted substring with the needle string using the equals method.\\n- If they match, return the index i.\\n4. If no match is found in the loop, return -1 to indicate that the needle is not found in the haystack.\\n\\n"
                    },
                    {
                        "username": "shivx_444",
                        "content": "Certainly! Here\\'s a concise algorithm for solving the string searching problem without using the built-in `indexOf` method:\\n\\n1. If the `needle` is an empty string, return 0, as an empty string matches at the beginning of any string.\\n\\n2. Iterate through the `haystack` using a loop with the index `i` ranging from 0 to `haystack.length() - needle.length()`.\\n\\n3. For each character in `haystack` at index `i` that matches the first character of `needle`:\\n   - Initialize a variable `j` to 0.\\n   - While `j` is less than `needle.length()` and characters at indices `i + j` in `haystack` and `j` in `needle` are equal:\\n     - Increment `j`.\\n   - If `j` becomes equal to `needle.length()`, a complete match is found.\\n     - Return the index `i`.\\n\\n4. If no match is found during the loop, return -1.\\n\\nThis algorithm efficiently searches for the first occurrence of `needle` within `haystack` without using the built-in `indexOf` method."
                    },
                    {
                        "username": "user2342ZB",
                        "content": "LOL I wrote this code and it got accepted because it passed the testcases XD This is cheating, leetcode should look into this.\\n\\n` class Solution:\\n\\n    def strStr(self, haystack: str, needle: str) -> int:\\n\\n        if needle not in haystack:\\n            return -1\\n\\n        return 0`"
                    },
                    {
                        "username": "gaurav_dadwal",
                        "content": "class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans=-1;\\n        for(int i=0;i<haystack.length();i++){\\n            if(haystack.substr(i,needle.size())==needle){\\n                ans=i;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sangram72",
                        "content": "Easy CPP Solution for beginners           \\n\\n\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n         size_t found = haystack.find(needle);\\n  if (found != string::npos){\\n   return found;\\n  }\\n  return -1;\\n\\n    }\\n};"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "This problem serves as a perfect chance to understand and implement one of the most efficient techniques, the Knuth-Morris-Pratt (KMP) algorithm. The problem pushes you to move beyond a naive approach, which could have a time complexity of `O(n*m)` in the worst-case scenario, and use a more efficient KMP algorithm that has a time complexity of `O(n+m)`. This highlights the importance of efficient algorithms in programming. As it\\'s a string-based problem, it gives you practice with string manipulation techniques, you\\'re also required to handle edge cases (like when the needle is an empty string), reinforcing the concept of comprehensive testing."
                    },
                    {
                        "username": "psionl0",
                        "content": "Don\\'t forget about the Rabin-Karp algorithm. This is just as efficient as KMP."
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Easiest and one liner code if you know string methods"
                    },
                    {
                        "username": "mzuathotmaildotcom",
                        "content": "Can we change example from \"sadbutsad\" to \"happyandhappy\" ?"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can input any customized test case you want."
                    },
                    {
                        "username": "Malay107",
                        "content": "Once this problem was marked \"medium\"...now its easy."
                    },
                    {
                        "username": "psionl0",
                        "content": "Probably because you can use brute force or just use a library function to find the substring."
                    }
                ]
            },
            {
                "id": 1980956,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1977619,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1962916,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1948061,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1946854,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1943923,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1940070,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1931437,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1929400,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1909827,
                "content": [
                    {
                        "username": "asemre99",
                        "content": "Brute force approach accepted so  tagging easy for this problem seems accurate"
                    },
                    {
                        "username": "rohan5",
                        "content": "Not Easy at all, even the O(n2) method is a Medium level problem."
                    },
                    {
                        "username": "Charmi_Kalyani",
                        "content": "if the needle is a substring of haystack then the it will return the index of the first occurence or simply 0 for substring and -1 for not a substring\\n"
                    },
                    {
                        "username": "Prince--",
                        "content": "very basic solution!!"
                    },
                    {
                        "username": "jincanchamber",
                        "content": "woahhh time complexity of O(n) when you use strncmp() in C !!!!"
                    },
                    {
                        "username": "user1825F",
                        "content": "why can\\'t we use directly\\nreturn haystack.index(needle)\\nwhy it is showing error while in my ide it is ruuning perfectly"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Think simple guy: class Solution {\\n    public int strStr(String haystack, String needle) {\\n        return haystack.indexOf(needle);\\n    }\\n}"
                    },
                    {
                        "username": "CT-7567",
                        "content": "I think this is cheating, you need to develop an algorithm that finds the index."
                    },
                    {
                        "username": "im-naime",
                        "content": "It\\'s an easy problem but so many corner case have to be considered, which makes it medium!"
                    },
                    {
                        "username": "WalterDark",
                        "content": "Its not easy, but I am  working on it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int p1 = 0;\\n        int p2 = 0;\\n        int n1 = haystack.length();\\n        int n2 = needle.length();\\n        \\n        while (p1 < n1 && p2 < n2) {\\n            char ch1 = haystack.charAt(p1);\\n            char ch2 = needle.charAt(p2);            \\n            if (ch1 == ch2) {\\n                p1++;\\n                p2++;\\n            }\\n              else {\\n                p1 = p1 - p2 + 1;  // Reset p1 to the next character in haystack\\n                p2 = 0;\\n            }\\n        }\\n\\n        if (p2 == n2) {\\n            return p1 - p2;  // Return the index of the first occurrence of needle\\n        } else {\\n            return -1;  // Needle not found\\n        }\\n    }\\n}\\n i saw this solution but did not understand why p1 = p1-p2 + 1;instead of p1 = p1 + 1;"
                    }
                ]
            },
            {
                "id": 1907151,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1905259,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1899633,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1886191,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1884643,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1859564,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1850003,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1849798,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1846614,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1837997,
                "content": [
                    {
                        "username": "Alog",
                        "content": "try  `binary search` with `while loop`"
                    },
                    {
                        "username": "Dhanya_V",
                        "content": "how to approach this one thought it was easy but isn\\'t "
                    },
                    {
                        "username": "CT-7567",
                        "content": "[@ylee078](/ylee078) \\n\\nI fallowed similar steps but I checked the last char of the needle when there is match (used &&) this way you can reduce couple of unnecessary checking. "
                    },
                    {
                        "username": "ylee078",
                        "content": "take the first alphabet of needles and search through the haystack. Once you find the alphabet that matches, check if the needle is in the haystack. If not continue searching for the next matching alphabet. if it goes through the loop without finding the needle, just return -1"
                    },
                    {
                        "username": "ylee078",
                        "content": "Is it cheating to use the find() function?"
                    },
                    {
                        "username": "nkt123",
                        "content": "CheckOut My Code----\\nimport java.io.*;\\nimport java.util.*;\\nimport java.math.*;\\n\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n    //HashMap<String,Integer> hm=new HashMap<String,Integer>();\\n\\n      for (int i = 0; i < haystack.length(); i++) {\\n\\n            String ss=Character.toString(haystack.charAt(i));\\n            \\n             if(ss.equals(needle)){\\n                 return i;\\n\\n               }\\n\\n            for (int j = i+1 ; j < haystack.length(); j++) {\\n\\n                ss=ss+Character.toString(haystack.charAt(j));\\n\\n               // System.out.println(ss);\\n\\n               \\n             if(ss.equals(needle)){\\n                 return i;\\n                 }\\n\\n           }\\n        }\\n        return -1;  \\n  }\\n}"
                    },
                    {
                        "username": "sourjadhr3",
                        "content": "class Solution {\\n    public int strStr(String haystack, String needle) {\\n        int i,j,g=0,f=1;\\n        int n=needle.length();\\n        for(i=0;i<haystack.length();i++)\\n        {\\n            if((i+n)>=haystack.length())\\n                {\\n                    String  s=haystack.substring(i);\\n                     if(s.equals(needle))\\n                     {\\n                         g=1;\\n                         break;\\n                     }\\n                     else\\n                        break;\\n                }\\n                else{\\n                String s=haystack.substring(i,i+n);\\n               \\n                    if(s.equals(needle))\\n                    {\\n                        g=1;\\n                        break;\\n                     }\\n                }\\n    \\n        }\\n    if( g==1)\\n            return i;\\n        else \\n            return -1;\\n    }\\n}\\n\\n\\nbeats 100 % very easy to understand"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast C++ solution with easy code syntax:-\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nApproach\\nComplexity\\nTime complexity:\\nSpace complexity:\\nCode\\nclass Solution {\\npublic:\\n\\n    bool ispossible( string s1, string s2,int index)\\n    {\\n        return ( s2==s1.substr(index, s2.size()) );\\n    }\\n\\n\\n      bool  check ( string s1 , string s2 )\\n      {\\n           unordered_map<int ,int> store;\\n\\n           for( auto it: s1)\\n           {\\n                store[it]++;\\n\\n           }\\n\\n\\n           for( auto  it :s2)\\n           {\\n               store[it]--;\\n               if( store[it]<0)\\n               {\\n                    return false;\\n               }\\n           }\\n\\n               return true ;\\n           \\n      }\\n    int strStr(string s1, string s2) {\\n        \\n        if( s1.size()<s2.size() || !check( s1, s2))\\n        {\\n             return -1;\\n        }\\n       \\n       int j =0;\\n        for( int i =0 ; i<=s1.size()-s2.size();i++)\\n        { \\n            \\n           if( s1[i]==s2[0]) \\n                { \\n\\n                    if( ispossible(s1,s2, i))\\n                    {\\n                         return i;\\n                    }\\n                }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lorulalit407",
                        "content": "HEY! Can someone explain to me how i -= j is working, because to me it is causing infinite loop as we will encounter same mismatch again and again if we set i to the first matched value.\\n\\nclass Solution(object):\\n    def strStr(self, x, target):\\n        if not target:\\n            return 0\\n        \\n        i, j = 0, 0\\n\\n        while i < len(x):\\n            if x[i] == target[j]:\\n                j += 1\\n                if j == len(target):\\n                    return i - j + 1\\n            else:\\n                i -= j\\n                j = 0\\n            i += 1\\n        return -1"
                    },
                    {
                        "username": "karshten",
                        "content": "why leetcode return wrong output: \\nhaystack = \"leetcode\", needle = \"leeto\"\\nvsc (node file.js) => -1; \\nleetcode => 7;\\n\\nhaystack = \"aaaaa\", needle = \"bba\"\\nvsc (node file.js) => -1; \\nleetcode => 0;"
                    },
                    {
                        "username": "AnnOl1",
                        "content": "Hello everyone, my solve is working, but leetcode doesn\\'t agree it. I don\\'t understand, why?\\ndef test(haystack, needle):\\n    nums = haystack.find(needle[0]) \\n    if nums == -1:\\n        return -1\\n    elif haystack[nums:nums+len(needle)] == needle:\\n        return nums"
                    },
                    {
                        "username": "naga_vara_pradeep",
                        "content": "Use Sliding Window technique to solve the problem."
                    }
                ]
            },
            {
                "id": 1835462,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1834996,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1834269,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1832986,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1830612,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1827152,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820839,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820720,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820718,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820711,
                "content": [
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps. https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "zyusuke10",
                        "content": "Why do i get time exceeded with this code? \n\n`class Solution:\n\n    def strStr(self, haystack: str, needle: str) -> int:\n        if needle not in haystack:\n            return -1\n        i = 0\n        j = 0\n        while i < len(haystack) and j < len(needle):\n            if haystack[i] == needle[j]:\n                i+=1\n                j+=1\n            else:\n                i=+1\n                j=0\n        return i-j`"
                    },
                    {
                        "username": "calicojack42",
                        "content": "I get the feeling that most if not all of the one-line solutions using builtin functions are working against the spirit of the question. Instead, try to imagine how you\\'d build this procedure if that function didn\\'t exist."
                    },
                    {
                        "username": "priyanshrm",
                        "content": "hello there! can anyone of you help me get the time complexity of my solution (ima little confused)?\n\n        `list_i = []\n        for j in range(len(haystack)):\n            if haystack[j] == needle[0]:\n                list_i.append(j)\n        for i in list_i:\n            if i + len(needle) <= len(haystack):\n                if needle == haystack[i:i + len(needle)]:\n                    return i\n        return -1`\n\nlink: [Code/Solution](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3299481/beats-89-27-ms-runtime/)\nI am just using a list to store the indices of haystack which have needle's first letter in them. And then the usual of looping through that list and cross-check the strings. (to find any matches) "
                    },
                    {
                        "username": "Deecodes25",
                        "content": "Can anyone tell what is the Time Complexity of this solution - \n\n ```\ni=0\nj=len(needle)\nwhile j<=len(haystack):\n            if haystack[i:j] == needle:\n                return i\n            i+=1\n            j+=1\nreturn -1\n```"
                    },
                    {
                        "username": "Anshmehta380",
                        "content": "Simplest Problem:\\nJust return haystack.indexOf(needle);\\n0ms solution"
                    },
                    {
                        "username": "redocmi7",
                        "content": "A standard string problem. I solved it using map in c++.\\nStoring each substring of the length of the needle string and then at last checking if the map contains the required needle or not. Mapping has been done from the required string to the 1st index from where the substring starts."
                    },
                    {
                        "username": "jperrin36",
                        "content": "good news and bad news\\ngood news: i made a solution that passes\\nbad news:  it only beats 5% runtime kms"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey! \nCheck out my LeetCode solution, which beats 100% of C++ submissions! Hope it helps.https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3309240/solution-without-builtin-functions-beats-100-c-with-time-and-space-complexity-explained/\n\nMy solution uses a simple and intuitive approach to search for the substring without using any built-in functions. By iterating over each possible starting index of the substring in the main string, we compare each character of the substring to the corresponding character in the main string. This approach ensures that we find the earliest occurrence of the substring in the main string.\n\nWhat's more, my solution comes with detailed explanations of the time and space complexity, so you can understand exactly how it works under the hood.\n\nSo if you're looking for a fast, efficient, and easy-to-understand solution to finding the index of the first occurrence of a substring in a string, check out my LeetCode solution today!"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "same as index method in python 3"
                    },
                    {
                        "username": "hmtthakur",
                        "content": "IMPORTANT :\\nI have 2 codes for this problem both using KMP algo, only difference is in 1st I am using  charArray length in while loop condition and in 2nd I am using String length(). \\nRuntime : \\n1 : Beats 41% (1ms)\\n2 : Beats 100% (0ms)\\n\\nMy question : Is this expected that much of a difference because of length calculation?\\n\\nCodes : \\n1 :\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(needle.toCharArray());\\n        int j = 0, i=0;\\n        while( i< haystack.length() && j < needle.length()){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\n\\n2: \\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        char[] hs = haystack.toCharArray();\\n        char[] ndl = needle.toCharArray();\\n        int[] kmp ;\\n        kmp = computeTemporaryArray(ndl);\\n        int j = 0, i=0;\\n        while( i< hs.length && j < ndl.length){\\n            if(haystack.charAt(i) == needle.charAt(j)){\\n                j++;\\n                i++;\\n                continue;\\n\\n            }\\n            else {\\n                if(j>0)\\n                    j = kmp[j-1];\\n                else\\n                    i++;\\n            }\\n        }\\n\\n        if(j == needle.length()){\\n            return i - needle.length();\\n        }\\n        return -1;\\n    }\\n\\n    private int[] computeTemporaryArray(char[] pattern){\\n        int[] lps = new int[pattern.length];\\n        int index =0;\\n        for(int i=1; i < pattern.length;){\\n            if(pattern[i] == pattern[index]){\\n                lps[i] = index + 1;\\n                index++;\\n                i++;\\n            }else{\\n                if(index != 0){\\n                    index = lps[index-1];\\n                }else{\\n                    lps[i] =0;\\n                    i++;\\n                }\\n            }\\n        }\\n        return lps;\\n    }\\n}\\n\\nPlease do reply anyone????"
                    }
                ]
            },
            {
                "id": 1820630,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820505,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820479,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820455,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820317,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820295,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820277,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820220,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820112,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820072,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "It is must one for starting with strings and getting a vibe on to the strings."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "what\\'s your say on this\\n"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "what is this problem is for ?"
                    },
                    {
                        "username": "charonme",
                        "content": "the naive O(n^2) solution is now accepted without TLE, no need for KMP"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "hint is window of needle"
                    },
                    {
                        "username": "shaloba",
                        "content": "The challenge is to write this without using built in functions, i have succeeded to solve this in O(nlog(n)) while n is the length of haystack"
                    },
                    {
                        "username": "ketansarna",
                        "content": "this question used to be marked as easy lol\\n\\n\\n"
                    },
                    {
                        "username": "space_invader",
                        "content": "Wait, what? Is it a medium?"
                    },
                    {
                        "username": "aitachii",
                        "content": "I think the problem description should mention  that using built-in functions are not allowed or the time complexity should be O(m + n)."
                    },
                    {
                        "username": "AnandBawa",
                        "content": "\"Medium\" with one line solution. LC can be confusing."
                    },
                    {
                        "username": "charonme",
                        "content": "this https://leetcode.com/problems/edit-distance/ also has a one line solution if you use a built-in function"
                    },
                    {
                        "username": "harshitisback",
                        "content": "```\nStringBuffer sb = new StringBuffer(haystack);\n        return sb.indexOf(needle,0);\n```\n\nI solved this question with these two lines and surprised why medium level but what the matter even i solved it by two lines it can't give me satisfaction specially when it is a medium level problem it is same as don't use library they just missed this part like they did in sorting problem 🅰️"
                    }
                ]
            },
            {
                "id": 1820029,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1819986,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1819951,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1819944,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1813222,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1810036,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1807176,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796440,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790289,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1783143,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "EASIEST MEDIUM EVER(in java)"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "classic python one-liner marked as Medium "
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This should be easy problems."
                    },
                    {
                        "username": "LY4869",
                        "content": " Didn\\'t work...\\n`class Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        \\n        int i = 0, j = 0;\\n        int n1 = haystack.size(), n2 = needle.size();\\n        if(n2 > n1)\\n            return -1;\\n        \\n        while(i < n1)\\n        {\\n            int idx = i;\\n            while(i < n1 && j < n2 && haystack[i++] == needle[j])\\n                j++;\\n            if(j == n2)\\n                return idx;\\n            j = 0;\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "ilyasabdullah00",
                        "content": "Please tell me what i am doing wrong!!!!\\n\\nclass Solution:\\n    def strStr(self, haystack: str, needle: str) -> int:\\n        \\n        c=0\\n        for j in range(len(haystack)):\\n            \\n            if needle[c]==haystack[j]:\\n                for i in range(len(needle)):\\n                    a=j\\n                    if needle[i]==haystack[a]:\\n                        a=a+1\\n                        c=c+1\\n                    else:\\n                        break\\n            if needle[0]==haystack[j]:\\n                break\\n\\n        if len(needle)==c:\\n            return a-len(needle)\\n        else:\\n            return (-1)"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Why is this medium. this is a 1line solution in python3. I don\\'t know how it became ```Medium``` but this is the easiest problem on LeetCode.  Also,   [@Siddharth Mathur](/Siddharth2k007) or Siddharth2k007, this is really easy. I don\\'t understand how can it be hard.\\n\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "if calling a built-in function with the problem arguments makes the problem \"easy\" then this is \"easy\" too https://leetcode.com/problems/edit-distance/ :D"
                    },
                    {
                        "username": "XOFJO",
                        "content": "[@kylecrowley](/kylecrowley) hhhhhh"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "\"Easiest problem on LeetCode\"? Clearly you haven\\'t seen [this](https://leetcode.com/problems/add-two-integers/) problem."
                    },
                    {
                        "username": "MaximPLV",
                        "content": "well, but you aren't supposed to do this in one line with build in functions"
                    },
                    {
                        "username": "happyAD",
                        "content": " Why this code doesn\\'t work?\\n`public int strStr(String haystack, String needle) {\\n        int ans = -1;\\n        for (int i = 0; i < haystack.length(); i++){\\n            if (i + needle.length() < haystack.length() && haystack.substring(i, needle.length()).equals(needle)){\\n                return i;\\n            }\\n        }\\n        return ans;\\n    }`\\n"
                    },
                    {
                        "username": "akib_alvee",
                        "content": "One approach that you can try!!!\\n\\nIf haystack\\'s i-th character match with needle\\'s k-th character we will increment the value of k. If it doesn\\'t match, but previously there was a slightly match, we will try to search the needle from the next point of previously matched position and set the value of k to 0. Because needle maybe reside from the next position, that we\\'ve already passed. For example, haystack = \"mississippi\" and needle = \"issip\" and another haystack = \"mississippi\" and needle = \"pi\".\\n\\nHope it works for you! :)\\n\\n"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "is using indexOf() cheating in java\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "Yes"
                    },
                    {
                        "username": "VJKUMAR_",
                        "content": "Java solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n\\n        int max=Math.max(haystack.indexOf(needle),-1);\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1771312,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1771182,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1766266,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1765135,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1759238,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1759078,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1758366,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1752195,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1750751,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1749964,
                "content": [
                    {
                        "username": "Ajith_B_J",
                        "content": "This problem having simple and lot of ways\\nhere is easy way  in python\\nreturn haystack.find(needle)\\njust find the needle in haystack"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "I have used sliding window and string library function both in my solution..\\nIs it right way?"
                    },
                    {
                        "username": "rohit6386",
                        "content": "I just used sliding window algorithm for this"
                    },
                    {
                        "username": "MousePotatoa",
                        "content": "I see text and a pattern to match... regex~~"
                    },
                    {
                        "username": "MishaChernov",
                        "content": "It would be better to notice about time/space complexity or \"do not use build-in methods\" to make it as \"Medium\" problem, without this it's \"Easy\""
                    },
                    {
                        "username": "bharath_king77",
                        "content": "May be this is easiest medium question ever \\nJust finished it with 1 line of code"
                    },
                    {
                        "username": "xxxxtj",
                        "content": "This should be easy, no? Especially in python using startswith() ?\\n```\\ndef strStr(self, haystack: str, needle: str) -> int:\\n        for i,l in enumerate(haystack):\\n            if haystack[i::].startswith(needle):\\n                return i\\n        return -1\\n```"
                    },
                    {
                        "username": "__vaxeral",
                        "content": "My solution tried to optimize by iterating both forward and backward at the same time for each character."
                    },
                    {
                        "username": "gaurizade",
                        "content": "Input = \"hello\" \"ll\"\\noutput = 0\\nexpected = 2\\n\\nWhy expected is 2 ?\\n"
                    },
                    {
                        "username": "MaximPLV",
                        "content": "because the first l is on index 2"
                    },
                    {
                        "username": "ritikanandsr123",
                        "content": "can it be solved using recursion?"
                    }
                ]
            },
            {
                "id": 1740839,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1740017,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1738308,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1735714,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1735376,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724552,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1723170,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1721652,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1717432,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1708503,
                "content": [
                    {
                        "username": "Dec0ySec",
                        "content": "using substring is kinda cheat"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\nwhy is it showing -1 when i am submitting the code. but when i am running the test case it is showing correct\n\nhaystack =\n\"mississippi\"\nneedle =\n\"issippi\"\nOutput\n4\nExpected\n-1\n "
                    },
                    {
                        "username": "Vasanth_Kumar_29_19",
                        "content": "ip\\n\"hello\"\\n\"ll\"\\nop - 0\\nexpected - 2\\n??"
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s correct, the \"ll\" needle starts at index 2 of the haystack"
                    },
                    {
                        "username": "vinaykumarbaithi04",
                        "content": "i did in c# but it says unhandled exception \\n"
                    },
                    {
                        "username": "hamaresh",
                        "content": "I am facing issue with leetcode compiler i.e, it shows wrong output while running test cases of python code but this code gives correct output while running on python IDLE or spyder or jupyter note book."
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if(haystack.contains(needle)){\n            int i = haystack.indexOf(needle);\n            return i;\n        }else{\n            return -1;\n        }\n    }\n}"
                    },
                    {
                        "username": "Vikashrathour",
                        "content": "[leetcode](https://leetcode.com)class Solution {\\n    public int strStr(String haystack, String needle) {\\n        for(int i=0;i<haystack.length();i++){\\n            for(int j=i+1;j<=haystack.length();j++){\\n                if(subString(haystack.substring(i,j),needle)==true)\\n                     return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static boolean subString(String str,String s){\\n        if(str.equals(s))\\n           return true;\\n        return false;\\n    }\\n}"
                    },
                    {
                        "username": "js_27",
                        "content": "// How Can I Optimise It more ??   \\n\\n`\\nclass Solution {\\n    public int strStr(String haystack, String needle) \\n    {\\n        int n = needle.length();\\n        if(haystack.length() < needle.length())\\n        {\\n            return -1;\\n        }\\n        for(int i=0  ; i < haystack.length() ; i++)\\n        {\\n            if(haystack.charAt(i) == needle.charAt(0))\\n            {\\n                if(i+n <= haystack.length())\\n                {\\n                    String a = haystack.substring(i,i+n);\\n                    if(a.equals(needle))\\n                    {\\n                        return i;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                continue;\\n            }\\n        }\\n        return -1;      \\n    }\\n}\\n\\n`"
                    },
                    {
                        "username": "Shubham_198",
                        "content": "3 Line Code C++ Runtime:0ms\\nclass Solution {\\npublic:\\n    int strStr(string haystack, string needle) {\\n        int ans2=haystack.find(needle);\\n        if(ans2!=-1){\\n            return ans2;\\n        }\\n        else\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "Ashish_252",
                        "content": "One Line Solution\\nclass Solution {\\n    public int strStr(String haystack, String needle) {\\n        return ( haystack.indexOf(needle));\\n    }\\n}"
                    }
                ]
            }
        ]
    }
]