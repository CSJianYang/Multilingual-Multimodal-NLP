[
    {
        "title": "Number of Laser Beams in a Bank",
        "question_content": "Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.\nThere is one laser beam between any two security devices if both conditions are met:\n\n\tThe two devices are located on two different rows: r1 and r2, where r1 < r2.\n\tFor each row i where r1 < i < r2, there are no security devices in the ith row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\nReturn the total number of laser beams in the bank.\n&nbsp;\nExample 1:\n\nInput: bank = [\"011001\",\"000000\",\"010100\",\"001000\"]\nOutput: 8\nExplanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n * bank[0][1] -- bank[2][1]\n * bank[0][1] -- bank[2][3]\n * bank[0][2] -- bank[2][1]\n * bank[0][2] -- bank[2][3]\n * bank[0][5] -- bank[2][1]\n * bank[0][5] -- bank[2][3]\n * bank[2][1] -- bank[3][2]\n * bank[2][3] -- bank[3][2]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.\n\nExample 2:\n\nInput: bank = [\"000\",\"111\",\"000\"]\nOutput: 0\nExplanation: There does not exist two devices located on two different rows.\n\n&nbsp;\nConstraints:\n\n\tm == bank.length\n\tn == bank[i].length\n\t1 <= m, n <= 500\n\tbank[i][j] is either '0' or '1'.",
        "solutions": [
            {
                "id": 1660943,
                "title": "python3-java-c-simple-o-mn",
                "content": "**Explanation**:\\nTo find the total number of `laser beams` we have to do 2 things:\\n1. Find the `number of laser beams` between \\'adjacent rows\\'. A row here is considered only if it has atleast 1 `security device`. Otherwise the row is simply ignored. \\nThus if:                                   \\nRow `1`: 3 security devices   \\nRow `2`: 0 security devices    \\nRow `3`: 2 security devices\\nWe can ignore row `2` and say that row `1` is adjacent to row `3`. To find the `number of laser beams` between \\'adjacent rows\\' we can multiply the number of security devices in the first row of the pair to the number of security devices in the second row of the pair.\\n2. Doing step 1 only solves a part of the problem. We now need to find the sum of all the `laser beams` from each pair of \\'adjacent rows\\'.\\n\\n**Algorithm**:\\nFor each string in bank:\\n* `count` = number of ones in string\\n* Multiply `count` by the non-zero `count` of previous string and add it to `ans`\\n<iframe src=\"https://leetcode.com/playground/CfnEimzJ/shared\" frameBorder=\"0\" width=\"500\" height=\"275\"></iframe>\\n\\nTime Complexity: `O(mn)`, `m` = length of bank, `n` = length of string",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "**Explanation**:\\nTo find the total number of `laser beams` we have to do 2 things:\\n1. Find the `number of laser beams` between \\'adjacent rows\\'. A row here is considered only if it has atleast 1 `security device`. Otherwise the row is simply ignored. \\nThus if:                                   \\nRow `1`: 3 security devices   \\nRow `2`: 0 security devices    \\nRow `3`: 2 security devices\\nWe can ignore row `2` and say that row `1` is adjacent to row `3`. To find the `number of laser beams` between \\'adjacent rows\\' we can multiply the number of security devices in the first row of the pair to the number of security devices in the second row of the pair.\\n2. Doing step 1 only solves a part of the problem. We now need to find the sum of all the `laser beams` from each pair of \\'adjacent rows\\'.\\n\\n**Algorithm**:\\nFor each string in bank:\\n* `count` = number of ones in string\\n* Multiply `count` by the non-zero `count` of previous string and add it to `ans`\\n<iframe src=\"https://leetcode.com/playground/CfnEimzJ/shared\" frameBorder=\"0\" width=\"500\" height=\"275\"></iframe>\\n\\nTime Complexity: `O(mn)`, `m` = length of bank, `n` = length of string",
                "codeTag": "Unknown"
            },
            {
                "id": 1674079,
                "title": "skip-and-multiply",
                "content": "Mouthful description; easy once you unpack it.\\n\\n**C++**\\n```cpp\\nint numberOfBeams(vector<string>& bank) {\\n    int prev = 0, res = 0;\\n    for (auto &r : bank) {\\n        int cur = count(begin(r), end(r), \\'1\\');\\n        if (cur) {\\n            res += prev * cur;\\n            prev = cur;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numberOfBeams(vector<string>& bank) {\\n    int prev = 0, res = 0;\\n    for (auto &r : bank) {\\n        int cur = count(begin(r), end(r), \\'1\\');\\n        if (cur) {\\n            res += prev * cur;\\n            prev = cur;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660998,
                "title": "java-c-count-1-s-o-nm-explanation",
                "content": "**Algorithm:**\\nCount the number of ones in each string and then multiply the count of consecutive ones and add it to the ans:\\nLets first do it in O(n) space in order to understand what exactly we\\u2019re doing:\\n\\n<iframe src=\"https://leetcode.com/playground/YjcAYtMx/shared\" frameBorder=\"0\" width=\"600\" height=\"300\"></iframe>\\n\\n**Space optimised O(1):**\\nAs we can observe from the above solution, we just need to keep track of previous count of one and we can simply multiply the current count one to the previous count and add it to answer. After that our current count will be the old count for the next coming string.\\n\\n```\\npublic int numberOfBeams(String[] bank) {\\n        int pOnes=0; int res=0;\\n        for(String s: bank){\\n            int count=0;\\n            for(char ch: s.toCharArray()){\\n                if(ch==\\'1\\'){\\n                    count++;\\n\\t\\t\\t\\t}\\n            }\\n           if(count>0){\\n                res+=(count*pOnes);\\n                pOnes=count;\\n            }\\n        }\\n        return res;\\n    }\\n```\\nUsing **Java Stream API**\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int pOnes=0; int res=0;\\n        for(String s: bank){\\n            int count=(int)s.chars().filter(ch->ch==\\'1\\').count();\\n            res+=(count*pOnes);\\n            if(count>0)\\n                pOnes=count;\\n        }\\n        return res;\\n    }\\n}\\n```\\n**C++ code** by @coderaky\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int pre=0,cur=0,res=0;\\n        for(int i=0;i<bank.size();i++){\\n            cur=count(bank[i].begin(),bank[i].end(),\\'1\\');\\n            if(cur>0)\\n                res+=pre*cur,pre=cur;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic int numberOfBeams(String[] bank) {\\n        int pOnes=0; int res=0;\\n        for(String s: bank){\\n            int count=0;\\n            for(char ch: s.toCharArray()){\\n                if(ch==\\'1\\'){\\n                    count++;\\n\\t\\t\\t\\t}\\n            }\\n           if(count>0){\\n                res+=(count*pOnes);\\n                pOnes=count;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int pOnes=0; int res=0;\\n        for(String s: bank){\\n            int count=(int)s.chars().filter(ch->ch==\\'1\\').count();\\n            res+=(count*pOnes);\\n            if(count>0)\\n                pOnes=count;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int pre=0,cur=0,res=0;\\n        for(int i=0;i<bank.size();i++){\\n            cur=count(bank[i].begin(),bank[i].end(),\\'1\\');\\n            if(cur>0)\\n                res+=pre*cur,pre=cur;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662229,
                "title": "c-python-java-simple-solution-one-pass-image-explanation",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* First count the number of `1` in each layer as N<sub>i<sub>\\n* skip or remove the layers which do not contain `1`\\n* So the number of connections between any two adjacent layers is N<sub>i</sub> * N<sub>i-1</sub>\\n\\t* return the sum of  N<sub>i</sub> * N<sub>i-1</sub>\\n\\n![image](https://assets.leetcode.com/users/images/5f84dff4-9389-470a-bedf-cecbe8dba904_1641110803.5347712.png)\\n\\n```\\nTime  Complexity: O(MN)\\nSpace Complexity: O(1)\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0, pre = 0;\\n        for (int i = 0;i < bank.size(); i ++) {\\n            int n = count(bank[i].begin(), bank[i].end(), \\'1\\');\\n            if (n == 0) continue;\\n            ans += pre * n;;\\n            pre = n;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def numberOfBeams(self, bank):\\n        ans, pre = 0, 0\\n        for s in bank:\\n            n = s.count(\\'1\\')\\n            if n == 0: continue\\n            ans += pre * n\\n            pre = n\\n        return ans\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int ans = 0, pre = 0;\\n        for (int i = 0;i < bank.length; i ++) {\\n            int n = 0;\\n            for (int j = 0; j < bank[i].length(); j ++) if(bank[i].charAt(j) == \\'1\\') n ++;\\n            if (n == 0) continue;\\n            ans += pre * n;;\\n            pre = n;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nTime  Complexity: O(MN)\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0, pre = 0;\\n        for (int i = 0;i < bank.size(); i ++) {\\n            int n = count(bank[i].begin(), bank[i].end(), \\'1\\');\\n            if (n == 0) continue;\\n            ans += pre * n;;\\n            pre = n;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def numberOfBeams(self, bank):\\n        ans, pre = 0, 0\\n        for s in bank:\\n            n = s.count(\\'1\\')\\n            if n == 0: continue\\n            ans += pre * n\\n            pre = n\\n        return ans\\n```\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int ans = 0, pre = 0;\\n        for (int i = 0;i < bank.length; i ++) {\\n            int n = 0;\\n            for (int j = 0; j < bank[i].length(); j ++) if(bank[i].charAt(j) == \\'1\\') n ++;\\n            if (n == 0) continue;\\n            ans += pre * n;;\\n            pre = n;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661238,
                "title": "count-1-s-and-multiply-c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        vector<int> num;  // to store the camera cnt at each lvl if cnt>0\\n        int cnt=0;\\n\\t\\t\\tfor(int i=0;i<bank.size();i++){  // counting camera at all lvl\\n            cnt=0;\\n            for(int j=0;j<bank[0].size();j++){\\n                if(bank[i][j]==\\'1\\'){\\n                    cnt++;\\n                }                \\n            }\\n            if(cnt>0)  //only need to push if cnt>0\\n                num.push_back(cnt);\\n        }\\n        \\n        if(num.size()<=1){  //corner case\\n            return 0;\\n        }\\n\\t\\t\\n        long long sum=0 ;\\n        for(int i=0;i<num.size()-1;i++){   // calc final ans\\n            sum+=(num[i]*num[i+1]);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\nConsider any two levels with camera\\'s, and observe that\\n*  No. of laser b/w level i and i+1 = (num of camera on lvl  i) * (num of camera on lvl i+1)\\n\\n1. So keep count of camera in a vector ```num``` and multiply ``` num[i] * num[i+1]``` to get no. of lasers from lvl i to lvl i+1\\n2.  Since you need count no of lasers between each level, keep on adding the product into ```sum``` to get total count\\n\\n**NOTE** ->  we only need to store the value in nums if the level has >0 cameras, since a laser extends to the next level having a camera. ( 0 value in num would spoil our ans ). \\n\\n**DRY RUN**\\n1. For Eg1, our ```num``` will be  ```num={3,2,1}``` .\\n2. For laser b/w r2 & r1 we have 3 * 2 = 6;\\n3. For lasers b/w r2 & r3 we have 2 * 1 = 2;\\n4. Final ```ans  = sum of all levels = 6+2 = 8 ```\\n\\n``` Time Complexity : O(n*m) , where n= no of rows and m = no of columns ```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        vector<int> num;  // to store the camera cnt at each lvl if cnt>0\\n        int cnt=0;\\n\\t\\t\\tfor(int i=0;i<bank.size();i++){  // counting camera at all lvl\\n            cnt=0;\\n            for(int j=0;j<bank[0].size();j++){\\n                if(bank[i][j]==\\'1\\'){\\n                    cnt++;\\n                }                \\n            }\\n            if(cnt>0)  //only need to push if cnt>0\\n                num.push_back(cnt);\\n        }\\n        \\n        if(num.size()<=1){  //corner case\\n            return 0;\\n        }\\n\\t\\t\\n        long long sum=0 ;\\n        for(int i=0;i<num.size()-1;i++){   // calc final ans\\n            sum+=(num[i]*num[i+1]);\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\n```num```\n``` num[i] * num[i+1]```\n```sum```\n```num```\n```num={3,2,1}```\n```ans  = sum of all levels = 6+2 = 8 ```\n``` Time Complexity : O(n*m) , where n= no of rows and m = no of columns ```",
                "codeTag": "Java"
            },
            {
                "id": 2272999,
                "title": "python-3-99-13-less-memory-94-93-faster-explanation",
                "content": "Runtime: **87 ms, faster than 94.93%** of Python3 online submissions for Number of Laser Beams in a Bank.\\nMemory Usage: **15.9 MB, less than 99.13%** of Python3 online submissions for Number of Laser Beams in a Bank.\\n\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        a, s = [x.count(\"1\") for x in bank if x.count(\"1\")], 0\\n\\n\\t\\t# ex: bank is [[00101], [01001], [00000], [11011]]\\n\\t\\t# a would return [2, 2, 4]\\n\\n        for c in range(len(a)-1):\\n            s += (a[c]*a[c+1])\\n\\n\\t\\t\\t# basic math to find the total amount of lasers\\n\\t\\t\\t# for the first iteration: s += 2*2\\n\\t\\t\\t# for the second iteration: s += 2*4\\n\\t\\t\\t# returns s = 12\\n\\n        return s\\n                            \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: **87 ms, faster than 94.93%** of Python3 online submissions for Number of Laser Beams in a Bank.\\nMemory Usage: **15.9 MB, less than 99.13%** of Python3 online submissions for Number of Laser Beams in a Bank.\\n\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        a, s = [x.count(\"1\") for x in bank if x.count(\"1\")], 0\\n\\n\\t\\t# ex: bank is [[00101], [01001], [00000], [11011]]\\n\\t\\t# a would return [2, 2, 4]\\n\\n        for c in range(len(a)-1):\\n            s += (a[c]*a[c+1])\\n\\n\\t\\t\\t# basic math to find the total amount of lasers\\n\\t\\t\\t# for the first iteration: s += 2*2\\n\\t\\t\\t# for the second iteration: s += 2*4\\n\\t\\t\\t# returns s = 12\\n\\n        return s\\n                            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1720404,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n * @param {string[]} bank\\n * @return {number}\\n */\\nconst numberOfBeams = (bank) =>\\n    bank\\n        .map((str) => str.split(\"0\").join(\"\").length)\\n        .filter((val) => val !== 0)\\n        .reduce((acc, cur, ind, arr) => acc + cur * (arr[ind + 1] || 0), 0);\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} bank\\n * @return {number}\\n */\\nconst numberOfBeams = (bank) =>\\n    bank\\n        .map((str) => str.split(\"0\").join(\"\").length)\\n        .filter((val) => val !== 0)\\n        .reduce((acc, cur, ind, arr) => acc + cur * (arr[ind + 1] || 0), 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3244717,
                "title": "easy-java-solution-easy-peasy-lemon-squeezy-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int beams = 0;\\n        int prev_num = 0;\\n        int current_num = 0;\\n        for(int i=0;i<bank.length;i++){\\n            current_num = countOnes(bank[i]);\\n            beams += current_num*prev_num;\\n            if(current_num != 0) prev_num = current_num;\\n        }\\n        return beams;\\n    }\\n\\n    private int countOnes(String str){\\n        int count = 0;\\n        for(int i=0;i<str.length();i++){\\n            if(str.charAt(i) == \\'1\\') count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int beams = 0;\\n        int prev_num = 0;\\n        int current_num = 0;\\n        for(int i=0;i<bank.length;i++){\\n            current_num = countOnes(bank[i]);\\n            beams += current_num*prev_num;\\n            if(current_num != 0) prev_num = current_num;\\n        }\\n        return beams;\\n    }\\n\\n    private int countOnes(String str){\\n        int count = 0;\\n        for(int i=0;i<str.length();i++){\\n            if(str.charAt(i) == \\'1\\') count++;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660994,
                "title": "python3-simulation",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/18f88320ffb2c2a06e86fad46d82ebd17dadad64) for solutions of weekly 274. \\n\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        ans = prev = 0 \\n        for row in bank: \\n            curr = row.count(\\'1\\')\\n            if curr: \\n                ans += prev * curr\\n                prev = curr \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        ans = prev = 0 \\n        for row in bank: \\n            curr = row.count(\\'1\\')\\n            if curr: \\n                ans += prev * curr\\n                prev = curr \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661014,
                "title": "java-python-3-product-of-neighboring-row-devices-number",
                "content": "**Q & A**\\n\\nQ1: How we got to know that we are required to do product of adjacent rows with count of 1s? \\nA1: According to the problem:\\nThere is one laser beam between any two security devices if both conditions are met:\\n\\n1. The two devices are located on two different rows: r1 and r2, where r1 < r2.\\n2. For each row i where r1 < i < r2, there are no security devices in the ith row.\\n\\n**End of Q & A**\\n\\n----\\n\\nGet rid of empty rows and then sum the product of each pair of neighbors.\\n```java\\n    public int numberOfBeams(String[] bank) {\\n        int cnt = 0, prev = 0;\\n        for (String devs : bank) {\\n            // devs.chars() cost more than O(1) space. - credit to @bharathkalyans.\\n            // int cur = devs.chars().map(i -> i == \\'1\\' ? 1 : 0).sum();\\n            int cur = 0;\\n            for (int i = 0; i < devs.length(); ++i) {\\n                cur += devs.charAt(i) == \\'1\\' ? 1 : 0;\\n            }\\n            cnt += prev * cur;\\n            if (cur > 0) {\\n                prev = cur;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        cnt = prev = 0\\n        for devs in bank:\\n            cur = devs.count(\\'1\\')\\n            cnt += cur * prev\\n            if cur > 0:\\n                prev = cur\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n` is the **total** number of characters in `bank`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int numberOfBeams(String[] bank) {\\n        int cnt = 0, prev = 0;\\n        for (String devs : bank) {\\n            // devs.chars() cost more than O(1) space. - credit to @bharathkalyans.\\n            // int cur = devs.chars().map(i -> i == \\'1\\' ? 1 : 0).sum();\\n            int cur = 0;\\n            for (int i = 0; i < devs.length(); ++i) {\\n                cur += devs.charAt(i) == \\'1\\' ? 1 : 0;\\n            }\\n            cnt += prev * cur;\\n            if (cur > 0) {\\n                prev = cur;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        cnt = prev = 0\\n        for devs in bank:\\n            cur = devs.count(\\'1\\')\\n            cnt += cur * prev\\n            if cur > 0:\\n                prev = cur\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2950790,
                "title": "c-solution",
                "content": "# Approach\\nCount the security devices in the current and previous row, multiply them and add them to the ans.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nm)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int ans = 0;\\n        int prev = 0 ;\\n\\n        for(string i : bank){\\n            int t = 0; \\n            for(int j = 0 ; j < i.size() ; j++){\\n                if( i[j] == \\'1\\')\\n                 t++;\\n            }\\n            if( t != 0 ){ \\n            ans += prev*t ;\\n            prev = t;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int ans = 0;\\n        int prev = 0 ;\\n\\n        for(string i : bank){\\n            int t = 0; \\n            for(int j = 0 ; j < i.size() ; j++){\\n                if( i[j] == \\'1\\')\\n                 t++;\\n            }\\n            if( t != 0 ){ \\n            ans += prev*t ;\\n            prev = t;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661016,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> v;\\n        for(string b:bank)\\n        {\\n            int count=0;\\n            for(int i=0;i<b.size();i++)\\n            {\\n                if(b[i]==\\'1\\')\\n                    count++;\\n            }\\n            if(count>0)\\n                v.push_back(count);\\n        }\\n        int result=0;\\n        for(int i=1;i<v.size();i++)\\n            result+=v[i]*v[i-1];\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> v;\\n        for(string b:bank)\\n        {\\n            int count=0;\\n            for(int i=0;i<b.size();i++)\\n            {\\n                if(b[i]==\\'1\\')\\n                    count++;\\n            }\\n            if(count>0)\\n                v.push_back(count);\\n        }\\n        int result=0;\\n        for(int i=1;i<v.size();i++)\\n            result+=v[i]*v[i-1];\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831953,
                "title": "java-easy-solution-100-beats-fully-explained",
                "content": "# Approach\\nThe given problem involves finding the total number of laser beams in a bank, where the bank\\'s floor plan is represented by a 0-indexed binary string array. Each row in the array corresponds to a row in the bank, and each character in the row can either be \\'0\\' (empty cell) or \\'1\\' (security device).\\n\\nTo solve the problem, the provided code implements the following approach:\\n\\n1. Initialize variables: The code starts by initializing two variables, \"count\" and \"prev,\" to 0. The \"count\" variable will keep track of the total number of laser beams found, and \"prev\" will store the count of security devices in the previous row.\\n\\n2. Loop through each row: The code iterates through each row (floor) in the bank using a for-each loop.\\n\\n3. Count ones in the current row: For each row, the \"countOnes\" function is called to count the number of security devices (\\'1\\'s) in that row.\\n\\n4. Calculate the beams: If the number of security devices in the current row is not zero, it means there is at least one potential laser beam between the current row and the previous row. The code then updates the \"count\" variable by adding the product of the number of security devices in the current row and the number of security devices in the previous row (\"ones * prev\"). The \"prev\" variable is then updated to the number of security devices in the current row to be used in the next iteration.\\n\\n5. Return the total count: After processing all rows, the function returns the final \"count,\" which represents the total number of laser beams in the bank.\\n\\nLogic behind the approach:\\n- The approach leverages the fact that to form a laser beam, there must be security devices on two different rows, and no other rows in between them should have any security devices.\\n- By counting the number of security devices in each row, the code identifies potential beam pairs between consecutive rows. The number of beams between each pair is given by the product of the number of security devices in the current row and the previous row. This is because each security device in the current row can potentially form a beam with each security device in the previous row.\\n- The \"prev\" variable is used to keep track of the number of security devices in the previous row, allowing the code to calculate the beams for each consecutive pair of rows.\\n\\nOverall, this approach efficiently calculates the total number of laser beams in the bank by iterating through the rows only once and counting the security devices in each row. The time complexity of this solution is O(m * n), where \"m\" is the number of rows and \"n\" is the number of columns in the bank matrix. The space complexity is O(1) since it uses a constant amount of additional space regardless of the input size.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int count = 0;\\n        int prev = 0;\\n\\n        for (String floor : bank) {\\n            int ones = countOnes(floor);\\n            if (ones != 0) {\\n                count += ones * prev;\\n                prev = ones;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private int countOnes(String floor) {\\n        int ones = 0;\\n        for (char c : floor.toCharArray()) {\\n            if (c == \\'1\\') {\\n                ones++;\\n            }\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Math",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int count = 0;\\n        int prev = 0;\\n\\n        for (String floor : bank) {\\n            int ones = countOnes(floor);\\n            if (ones != 0) {\\n                count += ones * prev;\\n                prev = ones;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private int countOnes(String floor) {\\n        int ones = 0;\\n        for (char c : floor.toCharArray()) {\\n            if (c == \\'1\\') {\\n                ones++;\\n            }\\n        }\\n        return ones;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659178,
                "title": "most-simple-optimized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0,x=0,y=0;\\n        for(auto &i: bank){\\n            for(auto &j: i){\\n                if(j==\\'1\\')x++;\\n            }\\n            if(x){\\n                ans += (x*y);\\n                y = x;\\n                x = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0,x=0,y=0;\\n        for(auto &i: bank){\\n            for(auto &j: i){\\n                if(j==\\'1\\')x++;\\n            }\\n            if(x){\\n                ans += (x*y);\\n                y = x;\\n                x = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642572,
                "title": "simple-c-solution-time-complexity-o-m-n-with-explaination",
                "content": "**Approach**\\n\\n* Count the number of 1\\'s in each row \\n* Store the count (if count>0) in a temporary array.\\n* Multiply every two adjacent elements of the array \\n* Add them all and return the value.\\n\\n**Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> temp;\\n        for(int i=0;i<bank.size();i++){\\n            int cnt=count(bank[i].begin(),bank[i].end(),\\'1\\');     // Count the number of 1 \\n            if(cnt>0)                                             // If there is no 1 in the row then that row can be skipped\\n                temp.push_back(cnt);                              // i.e- Only store the rows which have number of 1\\'s > 0\\n        }\\n        temp.push_back(0);                                        // If there is only 1 row in the input then to do multiplication adding aother row.   \\n        int ans=0;\\n        for(int i=0;i<temp.size()-1;i++){\\n            ans+=temp[i]*temp[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n// PLEASE UPVOTE \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> temp;\\n        for(int i=0;i<bank.size();i++){\\n            int cnt=count(bank[i].begin(),bank[i].end(),\\'1\\');     // Count the number of 1 \\n            if(cnt>0)                                             // If there is no 1 in the row then that row can be skipped\\n                temp.push_back(cnt);                              // i.e- Only store the rows which have number of 1\\'s > 0\\n        }\\n        temp.push_back(0);                                        // If there is only 1 row in the input then to do multiplication adding aother row.   \\n        int ans=0;\\n        for(int i=0;i<temp.size()-1;i++){\\n            ans+=temp[i]*temp[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n// PLEASE UPVOTE \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687692,
                "title": "simplest-java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevRowGuns = 0;\\n        int ans = 0;\\n        for(String b : bank){\\n            int curRowGuns = 0;\\n            for(int i=0;i<b.length();i++){\\n                if(b.charAt(i)==\\'1\\'){\\n                    curRowGuns++;\\n                }\\n            }\\n            if(curRowGuns!=0){\\n                ans +=prevRowGuns*curRowGuns;\\n                prevRowGuns=curRowGuns;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevRowGuns = 0;\\n        int ans = 0;\\n        for(String b : bank){\\n            int curRowGuns = 0;\\n            for(int i=0;i<b.length();i++){\\n                if(b.charAt(i)==\\'1\\'){\\n                    curRowGuns++;\\n                }\\n            }\\n            if(curRowGuns!=0){\\n                ans +=prevRowGuns*curRowGuns;\\n                prevRowGuns=curRowGuns;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789870,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        su = 0\\n        a = []\\n        for i in range(len(bank)):\\n            count = 0\\n            for j in range(len(bank[i])):\\n                if bank[i][j]==\\'1\\':\\n                    count+=1\\n            if count>0:\\n                a.append(count)\\n        if len(a)<=1:\\n            return 0\\n        else:\\n            for i in range(len(a)-1):\\n                su+=a[i]*a[i+1]\\n        return su\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        su = 0\\n        a = []\\n        for i in range(len(bank)):\\n            count = 0\\n            for j in range(len(bank[i])):\\n                if bank[i][j]==\\'1\\':\\n                    count+=1\\n            if count>0:\\n                a.append(count)\\n        if len(a)<=1:\\n            return 0\\n        else:\\n            for i in range(len(a)-1):\\n                su+=a[i]*a[i+1]\\n        return su\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427073,
                "title": "number-of-laser-beams-in-a-bank-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIteration\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We will firstly see if a row has \\'1\\' or not. \\n2. If it has, then we see whether that\\'s the first row to have \\'1\\'.\\n3. If yes, them we calculate the number of \\'1\\'\\'s in the row and store in variable m.\\n4. We then check for other rows iteratively, if they have \\'1\\', then the count of \\'1\\'s is calculated for the row and multiplied by the intitial value \\'m\\'.\\n5. We then update the value of \\'m\\' to the current count of \\'1\\'s in the present row.\\n6. Continue this process till we have traversed all the rows.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int i, m=0, total_laser_beams=0;\\n        for(i=0 ; i<bank.size() ; i++)\\n        {\\n            if(count(bank[i].begin(), bank[i].end(), \\'1\\')>0)\\n            {\\n                if(m==0)\\n                {\\n                    m = count(bank[i].begin(), bank[i].end(), \\'1\\');\\n                }\\n                else\\n                {\\n                    total_laser_beams += m*count(bank[i].begin(), bank[i].end(), \\'1\\');\\n                    m = count(bank[i].begin(), bank[i].end(), \\'1\\');\\n                }\\n            }\\n        }\\n        return total_laser_beams;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/930cfcc0-9885-4143-90c7-3d9242b182ae_1682613170.83302.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int i, m=0, total_laser_beams=0;\\n        for(i=0 ; i<bank.size() ; i++)\\n        {\\n            if(count(bank[i].begin(), bank[i].end(), \\'1\\')>0)\\n            {\\n                if(m==0)\\n                {\\n                    m = count(bank[i].begin(), bank[i].end(), \\'1\\');\\n                }\\n                else\\n                {\\n                    total_laser_beams += m*count(bank[i].begin(), bank[i].end(), \\'1\\');\\n                    m = count(bank[i].begin(), bank[i].end(), \\'1\\');\\n                }\\n            }\\n        }\\n        return total_laser_beams;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255781,
                "title": "java-98-55",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int x = 0, y = 0, sum = 0;\\n        for(String s : bank){\\n            if(x != 0)\\n                y = x;\\n            x = 0;\\n            for(char c : s.toCharArray()){\\n                x += c - \\'0\\';\\n            }\\n            sum += x*y;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int x = 0, y = 0, sum = 0;\\n        for(String s : bank){\\n            if(x != 0)\\n                y = x;\\n            x = 0;\\n            for(char c : s.toCharArray()){\\n                x += c - \\'0\\';\\n            }\\n            sum += x*y;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056995,
                "title": "easiest-approach-o-nxn-time-o-1-space",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //Idea is foe each row we go for next row which has security element if we reach to the last means no security elemnet between two rows. if we found the row we\\'ll calculate the beams by multiplying the no. of 1s in both row & move curr row to the that row\\n    int containes(string row){\\n        int cnt=0;\\n        for(int i=0;i<row.length();i++){\\n            if(row[i]==\\'1\\')cnt++;\\n        }\\n        return cnt;\\n    }\\n    int numberOfBeams(vector<string>& bank) {\\n        int res=0;\\n        for(int i=0;i<bank.size()-1;i++){\\n            int n=containes(bank[i]);\\n            int j=i+1;\\n            if(n){\\n                for(;j<bank.size();j++){\\n                    int m=containes(bank[j]);\\n                    if(m){\\n                        res+=(m*n);\\n                        i=j-1;\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n            if(j==bank.size())break;\\n        }\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //Idea is foe each row we go for next row which has security element if we reach to the last means no security elemnet between two rows. if we found the row we\\'ll calculate the beams by multiplying the no. of 1s in both row & move curr row to the that row\\n    int containes(string row){\\n        int cnt=0;\\n        for(int i=0;i<row.length();i++){\\n            if(row[i]==\\'1\\')cnt++;\\n        }\\n        return cnt;\\n    }\\n    int numberOfBeams(vector<string>& bank) {\\n        int res=0;\\n        for(int i=0;i<bank.size()-1;i++){\\n            int n=containes(bank[i]);\\n            int j=i+1;\\n            if(n){\\n                for(;j<bank.size();j++){\\n                    int m=containes(bank[j]);\\n                    if(m){\\n                        res+=(m*n);\\n                        i=j-1;\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n            if(j==bank.size())break;\\n        }\\n        return res;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991147,
                "title": "very-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        prev, ans = 0, 0\\n        for i in bank:\\n            current = i.count(\\'1\\')\\n            if current:\\n                ans += prev * current\\n                prev = current\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        prev, ans = 0, 0\\n        for i in bank:\\n            current = i.count(\\'1\\')\\n            if current:\\n                ans += prev * current\\n                prev = current\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931888,
                "title": "java-easy-solution",
                "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931863,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s: bank){\\n            int curLazer =0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer>0){\\n                ans+=(curLazer*prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s: bank){\\n            int curLazer =0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer>0){\\n                ans+=(curLazer*prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906510,
                "title": "java-solution-96-9-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n      int ones=0;\\n      int sum=0;\\n      for(String stu:bank){\\n          int counter=0;\\n          for(char ch:stu.toCharArray()){\\n              if(ch==\\'1\\'){\\n                  counter++;\\n              }\\n          }\\n\\n          if(counter>0){\\n              sum+=counter*ones;\\n              ones=counter;\\n\\n          }\\n      }\\n      return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n      int ones=0;\\n      int sum=0;\\n      for(String stu:bank){\\n          int counter=0;\\n          for(char ch:stu.toCharArray()){\\n              if(ch==\\'1\\'){\\n                  counter++;\\n              }\\n          }\\n\\n          if(counter>0){\\n              sum+=counter*ones;\\n              ones=counter;\\n\\n          }\\n      }\\n      return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771931,
                "title": "python-easy-explanation-easy-solution",
                "content": "Runtime: 87 ms, faster than **93.99%** of Python3 online submissions for Number of Laser Beams in a Bank.\\nMemory Usage: 15.9 MB, less than **90.75%** of Python3 online submissions for Number of Laser Beams in a Bank.\\n\\nPretty self explanatory code. We itterate over bank and count occurence of 1\\'s in each string. \\nmultiply it with previously row count and add it to result. update the previous row count.\\n\\n***Leave an upvote if this helps!!!***\\n\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        pre = 0\\n        nn = 0\\n        ans = 0\\n        for i in bank:\\n            nn=i.count(\\'1\\')\\n            if nn:\\n                ans+=nn*pre\\n                pre= nn\\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        pre = 0\\n        nn = 0\\n        ans = 0\\n        for i in bank:\\n            nn=i.count(\\'1\\')\\n            if nn:\\n                ans+=nn*pre\\n                pre= nn\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767257,
                "title": "java-simple-and-easily-understood-solution",
                "content": "**The idea is to first find the first row/string that has atleast one security device.Count the no of devices and store it into variable firstRow. After finding that row, find the next closest row/string that has atleast one security device and store it into the variable secondRow. Then multiply firstRow with secondRow and add it to the answer.**\\n\\nImplement the above idea until we reach the last row/element of string array and then return the final answer.\\n\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        if(bank.length < 2)\\n            return 0;\\n        int ans = 0;\\n        int firstRow = 0;\\n        int j = 0;\\n        \\n        // First find first row that has atleast 1 security device\\n        for(int i=0; i<bank.length; i++) {\\n            firstRow = countOnes(bank[i]);\\n            if(firstRow != -1) {\\n                j = i;\\n                break;\\n            }\\n            if(i == bank.length)\\n                return 0;\\n        }\\n        \\n        // Then find the closest next row that has atleast 1 security device and then add their product to the \\'ans\\'. After that, change firstRow to secondRow and check for remaining rows.\\n        for(int k=j+1; k<bank.length; k++) {\\n            int secondRow = countOnes(bank[k]);\\n            if(secondRow != -1) {\\n                ans += (firstRow * secondRow);\\n                firstRow = secondRow;\\n            }\\n        }\\n    return ans;\\n    }\\n    \\n    // Count the no of security devices present in a row.\\n    private int countOnes(String s) {\\n        int a = 0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\')\\n                a++;\\n        }\\n        return a > 0 ? a : -1;\\n    }\\n}\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        if(bank.length < 2)\\n            return 0;\\n        int ans = 0;\\n        int firstRow = 0;\\n        int j = 0;\\n        \\n        // First find first row that has atleast 1 security device\\n        for(int i=0; i<bank.length; i++) {\\n            firstRow = countOnes(bank[i]);\\n            if(firstRow != -1) {\\n                j = i;\\n                break;\\n            }\\n            if(i == bank.length)\\n                return 0;\\n        }\\n        \\n        // Then find the closest next row that has atleast 1 security device and then add their product to the \\'ans\\'. After that, change firstRow to secondRow and check for remaining rows.\\n        for(int k=j+1; k<bank.length; k++) {\\n            int secondRow = countOnes(bank[k]);\\n            if(secondRow != -1) {\\n                ans += (firstRow * secondRow);\\n                firstRow = secondRow;\\n            }\\n        }\\n    return ans;\\n    }\\n    \\n    // Count the no of security devices present in a row.\\n    private int countOnes(String s) {\\n        int a = 0;\\n        for(int i=0; i<s.length(); i++) {\\n            if(s.charAt(i) == \\'1\\')\\n                a++;\\n        }\\n        return a > 0 ? a : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677735,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(MN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        ans = prev = 0\\n        for s in bank:\\n            c = s.count(\\'1\\')\\n            if c:\\n                ans += prev * c\\n                prev = c\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        ans = prev = 0\\n        for s in bank:\\n            c = s.count(\\'1\\')\\n            if c:\\n                ans += prev * c\\n                prev = c\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638707,
                "title": "begineer-friendly-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int ans = 0;\\n        int prevArrLaserCount = 0;\\n        \\n        // iterate through bank array\\n        for(var i : bank){\\n            int curArrLaserCount = 0;\\n            // for finding the count of each string\\n            for(var j : i.toCharArray()){\\n                if(j == \\'1\\'){\\n                    curArrLaserCount++;\\n                }\\n            }\\n            // if value is greater than zero then we multiply\\n            if(curArrLaserCount>0){\\n                ans += prevArrLaserCount * curArrLaserCount;\\n                prevArrLaserCount = curArrLaserCount;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int ans = 0;\\n        int prevArrLaserCount = 0;\\n        \\n        // iterate through bank array\\n        for(var i : bank){\\n            int curArrLaserCount = 0;\\n            // for finding the count of each string\\n            for(var j : i.toCharArray()){\\n                if(j == \\'1\\'){\\n                    curArrLaserCount++;\\n                }\\n            }\\n            // if value is greater than zero then we multiply\\n            if(curArrLaserCount>0){\\n                ans += prevArrLaserCount * curArrLaserCount;\\n                prevArrLaserCount = curArrLaserCount;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525930,
                "title": "count-the-lasers-in-each-row-java-code",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n List<Integer> list= new ArrayList<>();\\n        int count=0,ans=0;\\n        for(String s:bank){\\n            count=0;\\n            for(char c:s.toCharArray()){\\n            if(c==\\'1\\'){\\n                count++;\\n            }\\n           \\n       }\\n             if(count!=0){\\n            list.add(count);\\n            } }\\n        \\n        for(int i=0;i<list.size()-1;i++){\\n            ans+=list.get(i)*list.get(i+1);\\n        }\\n        return ans;\\n\\n}\\n    }\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n List<Integer> list= new ArrayList<>();\\n        int count=0,ans=0;\\n        for(String s:bank){\\n            count=0;\\n            for(char c:s.toCharArray()){\\n            if(c==\\'1\\'){\\n                count++;\\n            }\\n           \\n       }\\n             if(count!=0){\\n            list.add(count);\\n            } }\\n        \\n        for(int i=0;i<list.size()-1;i++){\\n            ans+=list.get(i)*list.get(i+1);\\n        }\\n        return ans;\\n\\n}\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335519,
                "title": "c-simple-soln",
                "content": "this question in Hindi  *Haathi k daat dikhane k aur and khaane k aur*\\n*Explanation*\\ncalculate the sum of bits and if sum is zero than copy previous to that zero\\n```\\n    int sumbit(string s){\\n        int count=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n     vector<int> makevec(vector<string>& bank)\\n     {\\n         vector<int> vec;\\n         for(auto str:bank)\\n         {\\n             vec.push_back(sumbit(str));\\n         }\\n         return vec;\\n     }     \\n    int numberOfBeams(vector<string>& bank) {\\n         int ans=0;\\n         vector<int> vec=makevec(bank);\\n         for(int i=0;i<vec.size()-1;i++){\\n             if(vec[i+1]){\\n                 ans+=vec[i]*vec[i+1];\\n             }else{\\n                 vec[i+1]=vec[i];\\n             }\\n         }\\n         return ans;\\n     }\\n\\n```\\n##### If you like this solution, do **UPVOTE**.\\n##### Feel free to ask any **doubts** in the comment section.\\n##### Happy Coding :)",
                "solutionTags": [],
                "code": "```\\n    int sumbit(string s){\\n        int count=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'1\\') count++;\\n        }\\n        return count;\\n    }\\n     vector<int> makevec(vector<string>& bank)\\n     {\\n         vector<int> vec;\\n         for(auto str:bank)\\n         {\\n             vec.push_back(sumbit(str));\\n         }\\n         return vec;\\n     }     \\n    int numberOfBeams(vector<string>& bank) {\\n         int ans=0;\\n         vector<int> vec=makevec(bank);\\n         for(int i=0;i<vec.size()-1;i++){\\n             if(vec[i+1]){\\n                 ans+=vec[i]*vec[i+1];\\n             }else{\\n                 vec[i+1]=vec[i];\\n             }\\n         }\\n         return ans;\\n     }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323560,
                "title": "c-no-explanation-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n    int pre=0;\\n        int cur=0;\\n        int ans=0;\\n        for(auto &a:bank){\\n            cur=count(a.begin(),a.end(),\\'1\\');\\n            if(cur!=0){\\n                ans+=pre*cur;\\n                pre=cur;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n    int pre=0;\\n        int cur=0;\\n        int ans=0;\\n        for(auto &a:bank){\\n            cur=count(a.begin(),a.end(),\\'1\\');\\n            if(cur!=0){\\n                ans+=pre*cur;\\n                pre=cur;\\n            }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318946,
                "title": "java-stack-easy",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int n = bank.length;\\n        Stack<Integer> s = new Stack<>();\\n        for(int i =0; i<n ;i++){\\n            int x = one(bank[i]);\\n            if(x != 0){\\n                s.push(x);\\n            }\\n        }\\n        \\n        int ans = 0, p = 0;\\n        if(!s.isEmpty()) p = s.pop();\\n       while(!s.isEmpty()){\\n           ans += s.peek()*p;\\n           p = s.pop();\\n       }   \\n        return ans;\\n    \\n    }\\n    public int one(String str){\\n        int n = 0;\\n        for(int i =0; i<str.length() ;i++){\\n            if(str.charAt(i)==\\'1\\') n++;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int n = bank.length;\\n        Stack<Integer> s = new Stack<>();\\n        for(int i =0; i<n ;i++){\\n            int x = one(bank[i]);\\n            if(x != 0){\\n                s.push(x);\\n            }\\n        }\\n        \\n        int ans = 0, p = 0;\\n        if(!s.isEmpty()) p = s.pop();\\n       while(!s.isEmpty()){\\n           ans += s.peek()*p;\\n           p = s.pop();\\n       }   \\n        return ans;\\n    \\n    }\\n    public int one(String str){\\n        int n = 0;\\n        for(int i =0; i<str.length() ;i++){\\n            if(str.charAt(i)==\\'1\\') n++;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930256,
                "title": "java-easy-consise-easiest-o-mn",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int res = 0, prev = 0;\\n        for(String str:bank){\\n            int cur = 0;\\n            for(char ch:str.toCharArray()) if(ch == \\'1\\') cur++;\\n            if(prev != 0) res += cur * prev;\\n            if(cur != 0) prev = cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int res = 0, prev = 0;\\n        for(String str:bank){\\n            int cur = 0;\\n            for(char ch:str.toCharArray()) if(ch == \\'1\\') cur++;\\n            if(prev != 0) res += cur * prev;\\n            if(cur != 0) prev = cur;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789691,
                "title": "python3-simple-explanation-skip-count-1-s-and-multiply",
                "content": "**Explanation**\\n\\nFor finding total number of laser beams:\\n\\n1) Finding the no. of laser beams between adjacent rows. \\n**Note:** A row here is considered only if it has atleast 1 security device (atleast 1 \"1\" in string). Otherwise skiped that row.\\n\\n\\tTo find the number of laser beams between adjacent rows we can multiply the number of security devices (no. of ones) in the first row and of second row.\\n\\n\\tRepeat step-1 for finding the sum of all the laser beams from each pair of adjacent rows.\\n\\n**Algorithm**\\n\\nFor each string (element) in bank list:\\n\\ncount number of ones in string.\\nMultiply count by the non-zero count of previous string.\\nAdd it to ans.\\n\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        first = -1 \\n        ans = 0\\n        for i in bank:\\n            \\n            temp = i.count(\"1\")\\n            \\n            if temp == 0:\\n                pass\\n            else:\\n                if first == -1:\\n                    first = temp  \\n                else:\\n                    ans += (first*temp)\\n                    first = temp\\n        \\n        return ans\\n\\n```\\n\\nTime Complexity: O(m * n)\\nwhere, m = len of bank, n = len of string\\nSpace: O(1)\\n\\n**Do Upvote if you like** \\uD83D\\uDE0A\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        first = -1 \\n        ans = 0\\n        for i in bank:\\n            \\n            temp = i.count(\"1\")\\n            \\n            if temp == 0:\\n                pass\\n            else:\\n                if first == -1:\\n                    first = temp  \\n                else:\\n                    ans += (first*temp)\\n                    first = temp\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781908,
                "title": "explained-with-image-comments-java-beats-99",
                "content": "\\n\\n**Code:**\\n\\n\\tpublic int numberOfBeams(String[] bank) {\\n        int total = 0;\\n        int prev = 0;\\n        for(int i=0;i<bank.length;i++){\\n            int curr = countNum(bank[i]);\\n            if(curr!=0){\\n                total+= prev*curr;\\n                prev = curr;\\n            }\\n        }\\n        return total;\\n    }    \\n    \\n    //returns number of \\'1s\\' in the String\\n    int countNum(String row){\\n        int count = 0;\\n        for(char c : row.toCharArray())\\n            if(c==\\'1\\') count++;   \\n        return count;\\n    }\\n\\t\\n**Logic Explained with Comments:**\\n\\n        int total = 0;  // used to count total laser beams\\n        int prev = 0;  // number of devices in previous row (ignoring empty ones)\\n        \\n        for(int i=0;i<bank.length;i++){\\n            int curr = countNum(bank[i]); // number of devices in current row\\n            if(curr!=0){  // if the row is not empty\\n                total+= prev*curr;  // no. of beams b/w previous and current row will be prev*curr\\n                prev = curr;  // now the current row will act as previous for the next rows\\n            }\\n\\t\\t}\\n\\t\\n**Image:**\\n![image](https://assets.leetcode.com/users/images/38656f1d-a340-4be5-82ba-825ed4f7646f_1644673643.437999.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n\\n**Code:**\\n\\n\\tpublic int numberOfBeams(String[] bank) {\\n        int total = 0;\\n        int prev = 0;\\n        for(int i=0;i<bank.length;i++){\\n            int curr = countNum(bank[i]);\\n            if(curr!=0){\\n                total+= prev*curr;\\n                prev = curr;\\n            }\\n        }\\n        return total;\\n    }    \\n    \\n    //returns number of \\'1s\\' in the String\\n    int countNum(String row){\\n        int count = 0;\\n        for(char c : row.toCharArray())\\n            if(c==\\'1\\') count++;   \\n        return count;\\n    }\\n\\t\\n**Logic Explained with Comments:**\\n\\n        int total = 0;  // used to count total laser beams\\n        int prev = 0;  // number of devices in previous row (ignoring empty ones)\\n        \\n        for(int i=0;i<bank.length;i++){\\n            int curr = countNum(bank[i]); // number of devices in current row\\n            if(curr!=0){  // if the row is not empty\\n                total+= prev*curr;  // no. of beams b/w previous and current row will be prev*curr\\n                prev = curr;  // now the current row will act as previous for the next rows\\n            }\\n\\t\\t}\\n\\t\\n**Image:**\\n![image](https://assets.leetcode.com/users/images/38656f1d-a340-4be5-82ba-825ed4f7646f_1644673643.437999.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1683643,
                "title": "python3-runtime-76-ms-faster-than-95-70-memory-16-4-mb-less-than-12-01",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        temp = [row.count(\"1\") for row in bank if row.count(\"1\") > 0]\\n        ans = 0\\n        n = len(temp)\\n        if n == 1:\\n            return ans\\n        for i in range(1,n):\\n            ans += temp[i-1] * temp[i]\\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        temp = [row.count(\"1\") for row in bank if row.count(\"1\") > 0]\\n        ans = 0\\n        n = len(temp)\\n        if n == 1:\\n            return ans\\n        for i in range(1,n):\\n            ans += temp[i-1] * temp[i]\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673332,
                "title": "a-few-solutions",
                "content": "We can use the rule-of-product to accumulate the total `t` amount of lazers for each `i`<sup>th</sup> and `k`<sup>th</sup> adjacent rows during a linear scan of the rows of the input matrix `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numberOfBeams(A: Array<String>): Int {\\n        var t = 0\\n        var (M, N) = Pair(A.size, A[0].length)\\n        var (i, k) = Pair(0, 1)\\n        var f = { i: Int -> A[i].split(\"\").filter{ it == \"1\" }.size }\\n        while (k < M) {\\n            t += f(i) * f(k)\\n            if (0 < f(k))\\n                i = k\\n            ++k\\n        }\\n        return t\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numberOfBeams = (A, t = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let i = 0,\\n        k = 1;\\n    let f = i => A[i].split(\\'\\').filter(c => c == \\'1\\').length;\\n    while (k < M) {\\n        t += f(i) * f(k);\\n        i = f(k) ? k : i;\\n        ++k;\\n    }\\n    return t;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numberOfBeams(self, A: List[str], t = 0) -> int:\\n        M, N = len(A), len(A[0])\\n        i = 0\\n        k = 1\\n        f = lambda i: len([c for c in A[i] if c == \\'1\\'])\\n        while k < M:\\n            t += f(i) * f(k)\\n            if f(k):\\n                i = k\\n            k += 1\\n        return t\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numberOfBeams(VS& A, int t = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto i = 0,\\n             k = 1;\\n        auto f = [&](auto i) { return count_if(A[i].begin(), A[i].end(), [](auto c) { return c == \\'1\\'; }); };\\n        while (k < M) {\\n            t += f(i) * f(k);\\n            if (f(k))\\n                i = k;\\n            ++k;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numberOfBeams(A: Array<String>): Int {\\n        var t = 0\\n        var (M, N) = Pair(A.size, A[0].length)\\n        var (i, k) = Pair(0, 1)\\n        var f = { i: Int -> A[i].split(\"\").filter{ it == \"1\" }.size }\\n        while (k < M) {\\n            t += f(i) * f(k)\\n            if (0 < f(k))\\n                i = k\\n            ++k\\n        }\\n        return t\\n    }\\n}\\n```\n```\\nlet numberOfBeams = (A, t = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let i = 0,\\n        k = 1;\\n    let f = i => A[i].split(\\'\\').filter(c => c == \\'1\\').length;\\n    while (k < M) {\\n        t += f(i) * f(k);\\n        i = f(k) ? k : i;\\n        ++k;\\n    }\\n    return t;\\n};\\n```\n```\\nclass Solution:\\n    def numberOfBeams(self, A: List[str], t = 0) -> int:\\n        M, N = len(A), len(A[0])\\n        i = 0\\n        k = 1\\n        f = lambda i: len([c for c in A[i] if c == \\'1\\'])\\n        while k < M:\\n            t += f(i) * f(k)\\n            if f(k):\\n                i = k\\n            k += 1\\n        return t\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    int numberOfBeams(VS& A, int t = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto i = 0,\\n             k = 1;\\n        auto f = [&](auto i) { return count_if(A[i].begin(), A[i].end(), [](auto c) { return c == \\'1\\'; }); };\\n        while (k < M) {\\n            t += f(i) * f(k);\\n            if (f(k))\\n                i = k;\\n            ++k;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666821,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int numberOfBeams(String[] b) {\\n        int k=b.length,p=0,s=0;\\n        for(int i=0;i<b[0].length();i++)\\n        {\\n            if(b[0].charAt(i)==\\'1\\')\\n                p++;\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            if(!(b[i].contains(\"1\")))\\n                continue;\\n            else\\n            {\\n                int h=0,f=b[i].length();\\n                for(int j=0;j<f;j++)\\n                {\\n                    if(b[i].charAt(j)==\\'1\\')\\n                        h++;\\n                }\\n                s=s+(p*h);\\n                p=h;\\n            }\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int numberOfBeams(String[] b) {\\n        int k=b.length,p=0,s=0;\\n        for(int i=0;i<b[0].length();i++)\\n        {\\n            if(b[0].charAt(i)==\\'1\\')\\n                p++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1663295,
                "title": "go-100-time-and-100-space-o-n-m",
                "content": "```\\nfunc numberOfBeams(bank []string) int {\\n\\tprevBits, currentBits, result := 0, 0, 0\\n\\tfor i := 0; i < len(bank); i++ {\\n\\t\\tif currentBits = countBits(bank[i]); currentBits != 0 {\\n\\t\\t\\tresult += prevBits * currentBits\\n\\t\\t\\tprevBits = currentBits\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc countBits(s string) int {\\n\\tresult := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\tresult++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numberOfBeams(bank []string) int {\\n\\tprevBits, currentBits, result := 0, 0, 0\\n\\tfor i := 0; i < len(bank); i++ {\\n\\t\\tif currentBits = countBits(bank[i]); currentBits != 0 {\\n\\t\\t\\tresult += prevBits * currentBits\\n\\t\\t\\tprevBits = currentBits\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc countBits(s string) int {\\n\\tresult := 0\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tif s[i] == \\'1\\' {\\n\\t\\t\\tresult++\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661988,
                "title": "java-easy-o-mn",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int n = bank.length;\\n        int m = bank[0].length();\\n        int ans = 0;\\n        int count[] = new int[n];\\n        //Precalculate the number of 1\\'s for every row\\n        for(int i = 0 ; i < n ; i++){\\n            count[i] = countOne(bank[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            String row = bank[i];\\n            int cans = 0; //count of current answer for every i + 1 row.\\n            for(int j = i + 1 ; j < n ; j++){\\n                if(count[j] > 0){\\n                    cans += count[j];\\n                    break; //break the search as we are not considering the devices of other rows as soon as we find the device.\\n                }\\n            }\\n            ans = ans + cans * count[i]; //MATHS\\n        }\\n        return ans;\\n    }\\n    public int countOne(String s){\\n        int count = 0 ;\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int n = bank.length;\\n        int m = bank[0].length();\\n        int ans = 0;\\n        int count[] = new int[n];\\n        //Precalculate the number of 1\\'s for every row\\n        for(int i = 0 ; i < n ; i++){\\n            count[i] = countOne(bank[i]);\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            String row = bank[i];\\n            int cans = 0; //count of current answer for every i + 1 row.\\n            for(int j = i + 1 ; j < n ; j++){\\n                if(count[j] > 0){\\n                    cans += count[j];\\n                    break; //break the search as we are not considering the devices of other rows as soon as we find the device.\\n                }\\n            }\\n            ans = ans + cans * count[i]; //MATHS\\n        }\\n        return ans;\\n    }\\n    public int countOne(String s){\\n        int count = 0 ;\\n        \\n        for(int i = 0 ; i < s.length(); i++){\\n            if(s.charAt(i) == \\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661649,
                "title": "easy-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n         int prev=0,row=0,ans=0;\\n        for(int i=0;i<bank.size();i++){\\n            row=0;\\n            for(int j=0;j<bank[0].size();j++){\\n                if(bank[i][j]==\\'1\\') row++;\\n            }\\n            ans+=row*prev;\\n            if(row>0) prev=row;\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n         int prev=0,row=0,ans=0;\\n        for(int i=0;i<bank.size();i++){\\n            row=0;\\n            for(int j=0;j<bank[0].size();j++){\\n                if(bank[i][j]==\\'1\\') row++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1661438,
                "title": "c-clean-and-short-explained-with-image",
                "content": "**Explanation:**\\nSimple subproblem: If there are two rows containing `m` devices and `n` devices, then what is the total number of laser beams?\\nAnswer: There can be laser beam between every two device of previous row, so `m x n` laser beams are possible.\\n\\nAnd according to 2nd condition of question\\n* For each row `i` where `r1 < i < r2`, there are no security devices in the `ith` row.\\n\\nMeans we have to calculate the sum of above subproblem for every two device containing adjacent row.\\nAnd we simply have to ignore the row which contain no devices.\\n\\n![image](https://assets.leetcode.com/users/images/332ed53d-926e-4446-9dcd-74d05e8784b2_1641103659.0308094.png)\\n\\n**How to implement?**\\nTo implement the above solution we will count the number of 1\\'s in every row and multiply with the number of 1\\'s in previous row.\\n\\n`cnt1` - number of 1\\'s in last row which contains laser device.\\n`cnt2` - number of 1\\'s in the current row \\n\\nEvery time if it is not zero add `cnt1 x cnt2` in the result and update the value of `cnt1`.\\n\\n**Code:**\\n```\\nint numberOfBeams(vector<string>& bank) {\\n    int n = bank.size();\\n    int m = bank[0].size();\\n    int ans = 0, cnt1 = 0;\\n\\n    for(int i=0; i<n; i++)\\n    {\\n        int cnt2 = 0;\\n        for(int j=0; j<m; j++)\\n            cnt2 += (bank[i][j] == \\'1\\');\\n        \\n        if(cnt1 == 0 && cnt2 != 0) cnt1 = cnt2;  // this will run only one time, for the first row containing device\\n        else if(cnt2 == 0) continue;\\n        else {\\n            ans += (cnt1 * cnt2);\\n            cnt1 = cnt2;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nint numberOfBeams(vector<string>& bank) {\\n    int n = bank.size();\\n    int m = bank[0].size();\\n    int ans = 0, cnt1 = 0;\\n\\n    for(int i=0; i<n; i++)\\n    {\\n        int cnt2 = 0;\\n        for(int j=0; j<m; j++)\\n            cnt2 += (bank[i][j] == \\'1\\');\\n        \\n        if(cnt1 == 0 && cnt2 != 0) cnt1 = cnt2;  // this will run only one time, for the first row containing device\\n        else if(cnt2 == 0) continue;\\n        else {\\n            ans += (cnt1 * cnt2);\\n            cnt1 = cnt2;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661128,
                "title": "simple-solution-counting-c-clean-code",
                "content": "# Code :\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int n = bank.size();\\n        vector<int> cntOnes;\\n        \\n\\t\\t// Count number of ones in current bank\\n        for(auto& b : bank) {\\n            int cnt = 0;\\n            for(auto& i : b) {\\n                if(i == \\'1\\') cnt++;\\n            }\\n            cntOnes.push_back(c);\\n        }\\n        \\n        int res = 0;\\n        \\n        int i = 0;\\n        while(i<n && cntOnes[i] == 0) i++;\\n        \\n        for(i=0; i<n; ) {\\n\\t\\t\\t// Get the next bank index\\n\\t\\t\\t// Where there is atleast one device \\n\\t\\t\\t// i.e cntOnes >= 1\\n            int j = i+1;\\n            while(j < n && cntOnes[j] == 0) j++;\\n            \\n            if(j<n)\\n                res += (cntOnes[i] * cntOnes[j]);\\n            i = j;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* Time : `O(N * M)`, N is size of `bank` list, and M is size of each string\\n* Space : `O(N)`\\n\\n***If you find this helpful, do give it like :)***",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int n = bank.size();\\n        vector<int> cntOnes;\\n        \\n\\t\\t// Count number of ones in current bank\\n        for(auto& b : bank) {\\n            int cnt = 0;\\n            for(auto& i : b) {\\n                if(i == \\'1\\') cnt++;\\n            }\\n            cntOnes.push_back(c);\\n        }\\n        \\n        int res = 0;\\n        \\n        int i = 0;\\n        while(i<n && cntOnes[i] == 0) i++;\\n        \\n        for(i=0; i<n; ) {\\n\\t\\t\\t// Get the next bank index\\n\\t\\t\\t// Where there is atleast one device \\n\\t\\t\\t// i.e cntOnes >= 1\\n            int j = i+1;\\n            while(j < n && cntOnes[j] == 0) j++;\\n            \\n            if(j<n)\\n                res += (cntOnes[i] * cntOnes[j]);\\n            i = j;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661049,
                "title": "super-simple-python",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        lastSum = 0\\n        res = 0\\n        for row in bank:\\n            lasers = row.count(\"1\")\\n            if lasers:\\n                res += lasers * lastSum\\n                lastSum = lasers\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        lastSum = 0\\n        res = 0\\n        for row in bank:\\n            lasers = row.count(\"1\")\\n            if lasers:\\n                res += lasers * lastSum\\n                lastSum = lasers\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397017,
                "title": "python3-code-runtime-beats-91-o-n-memory-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        res = []\\n        s = 0\\n        for i in bank:\\n            if i.count(\"1\")>0:\\n                res.append(i.count(\"1\"))\\n        i,j=0,1\\n        while j<len(res):\\n            s+= res[i]*res[j]\\n            j+=1\\n            i+=1\\n        return s\\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        res = []\\n        s = 0\\n        for i in bank:\\n            if i.count(\"1\")>0:\\n                res.append(i.count(\"1\"))\\n        i,j=0,1\\n        while j<len(res):\\n            s+= res[i]*res[j]\\n            j+=1\\n            i+=1\\n        return s\\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209473,
                "title": "multiply-non-zero-count-of-1s",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& b) {\\n        \\n        int n  = b.size();\\n        vector<int> ans;\\n        for(auto &i: b)\\n        {\\n            int temp = count(i.begin(),i.end(),\\'1\\');\\n            if(temp!=0){\\n                ans.push_back(temp);\\n            }\\n            \\n        }\\n        int res=0;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            int t = ans[i]*ans[i-1];\\n            res+=t;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& b) {\\n        \\n        int n  = b.size();\\n        vector<int> ans;\\n        for(auto &i: b)\\n        {\\n            int temp = count(i.begin(),i.end(),\\'1\\');\\n            if(temp!=0){\\n                ans.push_back(temp);\\n            }\\n            \\n        }\\n        int res=0;\\n        for(int i=1;i<ans.size();i++)\\n        {\\n            int t = ans[i]*ans[i-1];\\n            res+=t;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196105,
                "title": "basic-python-stack-solution-if-elif-approach-beats-60-solutions",
                "content": "# Intuition\\nBasic Python approach using Stack to keep track of previous laser device count\\n\\n# Approach\\nmajor If Else approach using a stack to maintain the previous device count to generate the number of lasers between r1 and r2.\\n\\n# Complexity\\n- Time complexity:\\no(n*n)\\n\\n- Space complexity:\\n- o(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, arr: List[str]) -> int:\\n        li=[-1]\\n        flag=0\\n        summ=0\\n        for i in range(len(arr)):\\n            laser=arr[i].count(\\'1\\')\\n            if li[-1]==-1:\\n                li.append(laser)\\n            elif li[-1]==0 and laser==0:\\n                li.append(-1)\\n            elif laser==0:\\n                pass\\n            else:\\n                summ+=li[-1]*laser\\n                li.append(laser)\\n        return summ\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, arr: List[str]) -> int:\\n        li=[-1]\\n        flag=0\\n        summ=0\\n        for i in range(len(arr)):\\n            laser=arr[i].count(\\'1\\')\\n            if li[-1]==-1:\\n                li.append(laser)\\n            elif li[-1]==0 and laser==0:\\n                li.append(-1)\\n            elif laser==0:\\n                pass\\n            else:\\n                summ+=li[-1]*laser\\n                li.append(laser)\\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170816,
                "title": "simplest-c-solution-with-clear-explanetion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to calculate the number of \\'1\\'s in a row . So that we can connect the beems between them\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1st calculating the number of security device present in a row .Then checking if the other rows are containing the security device or not so that we can connect beems between them . If the no of rows containing  security device are less than 2 we are returning 0 otherwise we r calculating  all possible beems in between  security device . \\n# Complexity\\n- Time complexity: O(n\\xB2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& b) {\\n    vector<int> v ;\\n    int ans = 0  ;\\n    for(int i = 0 ; i < b.size() ; i++){\\n        int cnt = 0 ;\\n        for(int j = 0 ; j < b[i].length() ; j++)\\n        if(b[i][j]==\\'1\\') cnt++ ;\\n        if(cnt>0)\\n        v.push_back(cnt);\\n    }\\n    if(v.size()<=1) return 0 ;\\n    else \\n        for(int i = 0 ; i < v.size() - 1 ; i++)\\n         ans += v[i]*v[i+1] ;\\n    return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& b) {\\n    vector<int> v ;\\n    int ans = 0  ;\\n    for(int i = 0 ; i < b.size() ; i++){\\n        int cnt = 0 ;\\n        for(int j = 0 ; j < b[i].length() ; j++)\\n        if(b[i][j]==\\'1\\') cnt++ ;\\n        if(cnt>0)\\n        v.push_back(cnt);\\n    }\\n    if(v.size()<=1) return 0 ;\\n    else \\n        for(int i = 0 ; i < v.size() - 1 ; i++)\\n         ans += v[i]*v[i+1] ;\\n    return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128864,
                "title": "java-sol-simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int ans = 0;\\n        int temp = 0;\\n        for (int i=0; i<bank.length; i++) {\\n            if (bank[i].contains(\"1\")) {\\n                int count = 0;\\n                for (int j=0; j<bank[i].length(); j++) {\\n                    if (bank[i].charAt(j)==\\'1\\') count++;\\n                }\\n                ans += temp*count;\\n                temp = count;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int ans = 0;\\n        int temp = 0;\\n        for (int i=0; i<bank.length; i++) {\\n            if (bank[i].contains(\"1\")) {\\n                int count = 0;\\n                for (int j=0; j<bank[i].length(); j++) {\\n                    if (bank[i].charAt(j)==\\'1\\') count++;\\n                }\\n                ans += temp*count;\\n                temp = count;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125601,
                "title": "python-easy-to-understand-beats-99-time-complexity",
                "content": "# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        arr = []\\n        for i in range(len(bank)):\\n            temp = bank[i].count(\"1\")\\n            if temp > 0: arr.append(temp)\\n        cnt = 0\\n        for i in range(len(arr)-1):\\n            cnt += (arr[i] * arr[i+1])\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        arr = []\\n        for i in range(len(bank)):\\n            temp = bank[i].count(\"1\")\\n            if temp > 0: arr.append(temp)\\n        cnt = 0\\n        for i in range(len(arr)-1):\\n            cnt += (arr[i] * arr[i+1])\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914751,
                "title": "c-solution",
                "content": "# Intuition\\nFilter out the rows having no devices. Sum up the product of the number of devices of each two adjacent rows. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) {\\n        var cnts = bank.Select(r => r.Count(d => d == \\'1\\')).Where(cnt => cnt > 0).ToArray();\\n        var len = cnts.Length;\\n        var res = 0;\\n        for (var i = 1; i < len; ++i) res += cnts[i] * cnts[i - 1];\\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) {\\n        var cnts = bank.Select(r => r.Count(d => d == \\'1\\')).Where(cnt => cnt > 0).ToArray();\\n        var len = cnts.Length;\\n        var res = 0;\\n        for (var i = 1; i < len; ++i) res += cnts[i] * cnts[i - 1];\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832158,
                "title": "very-easy-java-solution",
                "content": "int c=0,z=0;\\n        int A[]=new int[bank.length];\\n         for(int i=0;i<bank.length;i++){\\nString s=bank[i];\\n             for(int j=0;j<s.length();j++){\\n                 char ch=s.charAt(j);\\n                 if(ch==\\'1\\')\\n                     c++;\\n             }\\n             if(c>=1){\\n                 A[z]=c;\\n         z++;\\n             }\\n             c=0;\\n         }\\n        int sum1=0;\\n        for(int i=0;i<A.length-1;i++){\\n            sum1=sum1+A[i]*A[i+1];\\n        }\\n        return sum1;",
                "solutionTags": [],
                "code": "int c=0,z=0;\\n        int A[]=new int[bank.length];\\n         for(int i=0;i<bank.length;i++){\\nString s=bank[i];\\n             for(int j=0;j<s.length();j++){\\n                 char ch=s.charAt(j);\\n                 if(ch==\\'1\\')\\n                     c++;\\n             }\\n             if(c>=1){\\n                 A[z]=c;\\n         z++;\\n             }\\n             c=0;\\n         }\\n        int sum1=0;\\n        for(int i=0;i<A.length-1;i++){\\n            sum1=sum1+A[i]*A[i+1];\\n        }\\n        return sum1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2824030,
                "title": "easy-math-using-prev-and-current-multiplication-java-solution",
                "content": "```\\npublic int numberOfBeams(String[] bank) \\n    {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        for(int i=0;i<bank.length;i++)\\n        {\\n            curr=0;\\n            for(int j=0;j<bank[i].length();j++)\\n            {\\n                if(bank[i].charAt(j)==\\'1\\')\\n                    curr++;\\n            }\\n            if(prev==0)\\n            {\\n                prev=curr;\\n            }\\n            else\\n            {\\n                if(curr!=0)\\n                {\\n                ans+=(prev*curr);\\n                prev=curr;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Matrix"
                ],
                "code": "```\\npublic int numberOfBeams(String[] bank) \\n    {\\n        int ans=0;\\n        int prev=0;\\n        int curr=0;\\n        for(int i=0;i<bank.length;i++)\\n        {\\n            curr=0;\\n            for(int j=0;j<bank[i].length();j++)\\n            {\\n                if(bank[i].charAt(j)==\\'1\\')\\n                    curr++;\\n            }\\n            if(prev==0)\\n            {\\n                prev=curr;\\n            }\\n            else\\n            {\\n                if(curr!=0)\\n                {\\n                ans+=(prev*curr);\\n                prev=curr;\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807404,
                "title": "store-count-of-one-easy-to-understand-90-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        if(bank.size()==1)return 0;\\n        vector<int> v;\\n        int o = 0;\\n        for(auto &i: bank){\\n            o = 0;\\n            for(auto &j: i){\\n                if(j==\\'1\\'){\\n                    o++;\\n                }\\n            }\\n            if(o)v.push_back(o);\\n        }\\n        if(v.size()<=1)return 0;\\n        int ans = 0;\\n        for(int i = 0; i < v.size()-1; i++){\\n            ans += v[i]*v[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        if(bank.size()==1)return 0;\\n        vector<int> v;\\n        int o = 0;\\n        for(auto &i: bank){\\n            o = 0;\\n            for(auto &j: i){\\n                if(j==\\'1\\'){\\n                    o++;\\n                }\\n            }\\n            if(o)v.push_back(o);\\n        }\\n        if(v.size()<=1)return 0;\\n        int ans = 0;\\n        for(int i = 0; i < v.size()-1; i++){\\n            ans += v[i]*v[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693653,
                "title": "cpp-faster-than-90-easy-and-concise",
                "content": "```\\nint numberOfBeams(vector<string>& bank) {\\n        int m = bank.size();\\n        int n = bank[0].size();\\n        int curr = 0;\\n        int prev = 0;\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ones = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(bank[i][j] == \\'1\\')\\n                    ones++;\\n            }\\n            if(ones !=0)\\n            {\\n                if(curr == 0)\\n                    curr = ones;\\n                else\\n                {\\n                    prev = curr;\\n                    curr = ones;\\n                    ans = ans + prev * curr;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numberOfBeams(vector<string>& bank) {\\n        int m = bank.size();\\n        int n = bank[0].size();\\n        int curr = 0;\\n        int prev = 0;\\n        int ans = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ones = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(bank[i][j] == \\'1\\')\\n                    ones++;\\n            }\\n            if(ones !=0)\\n            {\\n                if(curr == 0)\\n                    curr = ones;\\n                else\\n                {\\n                    prev = curr;\\n                    curr = ones;\\n                    ans = ans + prev * curr;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2633920,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        pre = 0\\n        nn = 0\\n        ans = 0\\n        for i in bank:\\n            nn= 0\\n            for j in i:\\n                if j == \\'1\\':\\n                    nn+=1\\n            if nn:\\n                ans+=nn*pre\\n                pre= nn\\n        return ans\\n## PLease upvote if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        pre = 0\\n        nn = 0\\n        ans = 0\\n        for i in bank:\\n            nn= 0\\n            for j in i:\\n                if j == \\'1\\':\\n                    nn+=1\\n            if nn:\\n                ans+=nn*pre\\n                pre= nn\\n        return ans\\n## PLease upvote if you like the Solution",
                "codeTag": "Java"
            },
            {
                "id": 2629956,
                "title": "c-easy-to-understand-code-brute-force-approach",
                "content": "```\\nint numberOfBeams(vector<string>& bank) {\\n        int n = bank.size(), m = bank[0].size(), p = 0;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            int c = 0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\') c++;\\n            }\\n            if(c) v.push_back(c);\\n        }\\n        if(v.size()==1) return 0;\\n        else{\\n            for(int i=1;i<v.size();i++) p+=(v[i]*v[i-1]);\\n        }\\n        return p;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfBeams(vector<string>& bank) {\\n        int n = bank.size(), m = bank[0].size(), p = 0;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            int c = 0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\') c++;\\n            }\\n            if(c) v.push_back(c);\\n        }\\n        if(v.size()==1) return 0;\\n        else{\\n            for(int i=1;i<v.size();i++) p+=(v[i]*v[i-1]);\\n        }\\n        return p;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587223,
                "title": "java-string-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prev=0,count=0,total=0;\\n        for(int i=0;i<bank.length;i++){ \\n            count=0;\\n            for(int j=0;j<bank[i].length();j++){\\n                if(bank[i].charAt(j)==\\'1\\')\\n                    count++;\\n            }\\n            if(count>0){\\n                total=total+count*prev;\\n                prev=count;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prev=0,count=0,total=0;\\n        for(int i=0;i<bank.length;i++){ \\n            count=0;\\n            for(int j=0;j<bank[i].length();j++){\\n                if(bank[i].charAt(j)==\\'1\\')\\n                    count++;\\n            }\\n            if(count>0){\\n                total=total+count*prev;\\n                prev=count;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573507,
                "title": "2125-number-of-laser-beams-in-a-bank",
                "content": "**EASY TO UNDERSTAND || BEGINNER FRIENDLY**\\n```\\n        arr=[]\\n        \\n        for i in range(len(bank)):\\n            count=0\\n            for j in range(len(bank[i])):\\n                if bank[i][j]==\\'1\\':\\n                    count+=1\\n            arr.append(count)\\n\\n        ans=[]\\n        \\n        for ii in range(len(arr)):\\n            if arr[ii]!=0:\\n                ans.append(arr[ii])\\n        \\n        anss=0\\n        \\n        for x in range(len(ans)-1):\\n            anss+=ans[x]*ans[x+1]\\n        return anss\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        arr=[]\\n        \\n        for i in range(len(bank)):\\n            count=0\\n            for j in range(len(bank[i])):\\n                if bank[i][j]==\\'1\\':\\n                    count+=1\\n            arr.append(count)\\n\\n        ans=[]\\n        \\n        for ii in range(len(arr)):\\n            if arr[ii]!=0:\\n                ans.append(arr[ii])\\n        \\n        anss=0\\n        \\n        for x in range(len(ans)-1):\\n            anss+=ans[x]*ans[x+1]\\n        return anss\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551051,
                "title": "java-solution-intuitive-math-s-c-0-1-t-c-o-n",
                "content": "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        \\n        int prev = -1;\\n        int ans = 0;\\n        for(String s : bank){\\n            int one = countOnes(s);\\n            if(one !=0){\\n                if(prev == -1){  // first row where the count of 1\\'s >0 \\n                    prev = one;\\n                }\\n                else{\\n                    ans += prev*one; // multiply the prev number with current no. of 1 in row and  add it to the result\\n                    prev = one;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    private int countOnes(String s){ // To count the number of ones int the row\\n         \\n        int count =0;\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'1\\'){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        \\n        int prev = -1;\\n        int ans = 0;\\n        for(String s : bank){\\n            int one = countOnes(s);\\n            if(one !=0){\\n                if(prev == -1){  // first row where the count of 1\\'s >0 \\n                    prev = one;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2543380,
                "title": "easy-python-soution",
                "content": "```class Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        arr = []\\n        for i in bank:\\n            if i.count(\"1\"):\\n                arr.append(i.count(\"1\"))\\n\\n        res = 0\\n        i = 0\\n        while(i< len(arr) - 1):\\n\\t\\t\\tres += arr[i] * arr[i+1]\\n\\t\\t\\ti += 1\\n\\t\\t\\n\\t\\treturn res\\n        \\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        arr = []\\n        for i in bank:\\n            if i.count(\"1\"):\\n                arr.append(i.count(\"1\"))\\n\\n        res = 0\\n        i = 0\\n        while(i< len(arr) - 1):\\n\\t\\t\\tres += arr[i] * arr[i+1]\\n\\t\\t\\ti += 1\\n\\t\\t\\n\\t\\treturn res\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2440980,
                "title": "java-easiest-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int res = 0;\\n        for(String str : bank){\\n            int countOnes = 0;\\n            for(char c : str.toCharArray()) if(c==\\'1\\') countOnes++;\\n            if(countOnes>0) list.add(countOnes);\\n        }\\n        \\n        int ans = 0;\\n        int n = list.size()-1;\\n        for(int i=0;i<n;i++){\\n            int val = list.get(i)*list.get(i+1);\\n            ans+=val;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        int res = 0;\\n        for(String str : bank){\\n            int countOnes = 0;\\n            for(char c : str.toCharArray()) if(c==\\'1\\') countOnes++;\\n            if(countOnes>0) list.add(countOnes);\\n        }\\n        \\n        int ans = 0;\\n        int n = list.size()-1;\\n        for(int i=0;i<n;i++){\\n            int val = list.get(i)*list.get(i+1);\\n            ans+=val;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394813,
                "title": "typescript-javascript-100-fastest-typescript-solution",
                "content": "The task can be treated as summing up the products of amounts of devices in non-empty rows.\\nFor the given example `[\"011001\",\"000000\",\"010100\",\"001000\"]` we have 3 devices in the first row, skip second one as it\\'s empty, 2 in the third and 1 in the fourth row: `[3, 2, 1]` which is `3 * 2 + 2 * 1 = 8`.\\nThis statement counts 1s in each row, then skips zeroes.\\n```\\nbank.map(e => (e.match(/1/g) || []).length).filter(a => a !== 0);\\n```\\nSo we have\\n```\\nfunction numberOfBeams(bank: string[]): number {\\n  const devices: number[] = bank.map(e => (e.match(/1/g) || []).length).filter(a => a !== 0);\\n  \\n  if (!devices.length || devices.length === 1) {\\n    return 0;\\n  }\\n\\n  let sum = 0;\\n\\n  for (let i = 1; i < devices.length; i++) {\\n    sum += devices[i] * devices[i - 1];\\n  }\\n  \\n  return sum;\\n}\\n```\\nLet me know if you have any questions. Please hit upvote if you find it useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "String"
                ],
                "code": "```\\nbank.map(e => (e.match(/1/g) || []).length).filter(a => a !== 0);\\n```\n```\\nfunction numberOfBeams(bank: string[]): number {\\n  const devices: number[] = bank.map(e => (e.match(/1/g) || []).length).filter(a => a !== 0);\\n  \\n  if (!devices.length || devices.length === 1) {\\n    return 0;\\n  }\\n\\n  let sum = 0;\\n\\n  for (let i = 1; i < devices.length; i++) {\\n    sum += devices[i] * devices[i - 1];\\n  }\\n  \\n  return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385750,
                "title": "c-simple-9-lines-of-code-easy-to-understand",
                "content": "int numberOfBeams(vector<string>& bank) {\\n        int n = bank.size(), m = bank[0].length();\\n        vector<int> count(n, 0);\\n        \\n        for(int i=0; i<n; i++) for(int j=0; j<m; j++) if( bank[i][j] == \\'1\\' ) count[i]++; \\n            \\n        int res = 0;\\n        vector<int>nya;\\n        for(int k=0; k < n; k++) if(count[k]!=0) nya.push_back(count[k]);\\n        for(int i = 0;i+1<nya.size();i++) res += nya[i]*nya[i+1];\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Array"
                ],
                "code": "int numberOfBeams(vector<string>& bank) {\\n        int n = bank.size(), m = bank[0].length();\\n        vector<int> count(n, 0);\\n        \\n        for(int i=0; i<n; i++) for(int j=0; j<m; j++) if( bank[i][j] == \\'1\\' ) count[i]++; \\n            \\n        int res = 0;\\n        vector<int>nya;\\n        for(int k=0; k < n; k++) if(count[k]!=0) nya.push_back(count[k]);\\n        for(int i = 0;i+1<nya.size();i++) res += nya[i]*nya[i+1];\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2385731,
                "title": "c-simple-oo-wottt-using-for-loop",
                "content": "class Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) \\n    {\\n        int n = bank.size(), m = bank[0].length();\\n        vector<int> count(n, 0);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if( bank[i][j] == \\'1\\' ) count[i]++; \\n            }\\n            \\n        }\\n        int res = 0;\\n        vector<int>nya;\\n        for(int k=0; k < n; k++){\\n            if(count[k]!=0){\\n                nya.push_back(count[k]);\\n            }  \\n        }\\n        if(nya.size()==0) return 0;\\n        for(int i = 0;i<nya.size()-1;i++) res += nya[i]*nya[i+1];\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) \\n    {\\n        int n = bank.size(), m = bank[0].length();\\n        vector<int> count(n, 0);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if( bank[i][j] == \\'1\\' ) count[i]++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2315969,
                "title": "fastest-logical-java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int count=0,pc=0;\\n        for(char c:bank[0].toCharArray())\\n            if(c==\\'1\\')\\n                pc++;\\n        for(int i=1;i<bank.length;i++)\\n        {\\n            if(bank[i].contains(\"1\"))\\n            {\\n                int cc=0;\\n                for(char c:bank[i].toCharArray())\\n                    if(c==\\'1\\')\\n                        cc++;\\n                count+=(pc*cc);\\n                pc=cc;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int count=0,pc=0;\\n        for(char c:bank[0].toCharArray())\\n            if(c==\\'1\\')\\n                pc++;\\n        for(int i=1;i<bank.length;i++)\\n        {\\n            if(bank[i].contains(\"1\"))\\n            {\\n                int cc=0;\\n                for(char c:bank[i].toCharArray())\\n                    if(c==\\'1\\')\\n                        cc++;\\n                count+=(pc*cc);\\n                pc=cc;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2266238,
                "title": "easy-and-peasey-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> ans;\\n        for(int i=0;i<bank.size();i++){\\n             int cnt=0;\\n            for(int j=0;j<bank[i].size();j++){\\n                if(bank[i][j]==\\'1\\') cnt++;\\n                }\\n            if(cnt!=0)ans.push_back(cnt);\\n        }\\n        if(ans.size()==0) return 0;\\n        int ans1=0;\\n        for(int i=0;i<ans.size()-1;i++){\\n            ans1+= ans[i]*ans[i+1];\\n            }return ans1;\\n    }};\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> ans;\\n        for(int i=0;i<bank.size();i++){\\n             int cnt=0;\\n            for(int j=0;j<bank[i].size();j++){\\n                if(bank[i][j]==\\'1\\') cnt++;\\n                }\\n            if(cnt!=0)ans.push_back(cnt);\\n        }\\n        if(ans.size()==0) return 0;\\n        int ans1=0;\\n        for(int i=0;i<ans.size()-1;i++){\\n            ans1+= ans[i]*ans[i+1];\\n            }return ans1;\\n    }};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2221710,
                "title": "simple-java-solution-o-mn-count-1-s",
                "content": "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        \\n        int res=0, prev=0;\\n        \\n        for(String s:bank){\\n            int ones = 0;\\n            for(int i=0; i<s.length(); i++)\\n                if(s.charAt(i)==\\'1\\') ones++;\\n            if(ones!=0){\\n                res += prev*ones;\\n                prev=ones;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        \\n        int res=0, prev=0;\\n        \\n        for(String s:bank){\\n            int ones = 0;\\n            for(int i=0; i<s.length(); i++)\\n                if(s.charAt(i)==\\'1\\') ones++;\\n            if(ones!=0){\\n                res += prev*ones;\\n                prev=ones;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2207402,
                "title": "c-solution-explained",
                "content": "Multiply the number of laser beams in ith row with the number of laser beams in the (i+1)th row and add it to the sum variable, don\\'t consider the rows where there is not a single laser. \\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int sum = 0, count1 = 0, count2 = 0;\\n        \\n        \\n        for(int i=0; i<bank.size() - 1; i++)\\n        {\\n            for(int j=0; j<bank[i].size(); j++)\\n            {\\n                if(bank[i][j] == \\'1\\')\\n                {\\n                    count1++;\\n                }\\n            }\\n            \\n            for(int j=0; j<bank[i+1].size(); j++)\\n            {\\n                if(bank[i+1][j] == \\'1\\')\\n                {\\n                    count2++;\\n                }\\n            }\\n            \\n            if(count1 == 0 && count2 == 0)\\n            {\\n                //Do Nothing\\n            }\\n            else if(count1 == 0)\\n            {\\n                count1 = 0;\\n                count2 = 0;\\n            }\\n            else if(count2 == 0)\\n            {\\n                count2 = 0;\\n            }\\n            else\\n            {\\n                sum += (count1 * count2);\\n            \\n                count1 = 0;\\n                count2 = 0;\\n            }\\n            \\n            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int sum = 0, count1 = 0, count2 = 0;\\n        \\n        \\n        for(int i=0; i<bank.size() - 1; i++)\\n        {\\n            for(int j=0; j<bank[i].size(); j++)\\n            {\\n                if(bank[i][j] == \\'1\\')\\n                {\\n                    count1++;\\n                }\\n            }\\n            \\n            for(int j=0; j<bank[i+1].size(); j++)\\n            {\\n                if(bank[i+1][j] == \\'1\\')\\n                {\\n                    count2++;\\n                }\\n            }\\n            \\n            if(count1 == 0 && count2 == 0)\\n            {\\n                //Do Nothing\\n            }\\n            else if(count1 == 0)\\n            {\\n                count1 = 0;\\n                count2 = 0;\\n            }\\n            else if(count2 == 0)\\n            {\\n                count2 = 0;\\n            }\\n            else\\n            {\\n                sum += (count1 * count2);\\n            \\n                count1 = 0;\\n                count2 = 0;\\n            }\\n            \\n            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187767,
                "title": "skip-the-zero-s-multiply-each-pair",
                "content": "Skip any row with no security device, then find the sum of the product between remaining every pair elements.\\n\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int result=0,prev=0;\\n        for(String str:bank){\\n            int count=0;\\n            for(char c:str.toCharArray()){\\n                if(c==\\'1\\'){\\n                    count++;\\n                }\\n            }\\n            if(count>0){\\n                result+=(prev*count);\\n                prev=count;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int result=0,prev=0;\\n        for(String str:bank){\\n            int count=0;\\n            for(char c:str.toCharArray()){\\n                if(c==\\'1\\'){\\n                    count++;\\n                }\\n            }\\n            if(count>0){\\n                result+=(prev*count);\\n                prev=count;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166631,
                "title": "simple-c-code",
                "content": "Simple Ques that just looks to be Scary...................................................\\nApproach - By given cndtns we get to know that total laser beams b/w i and j rows is equal to product of laser devices in both rows i and j.\\n1) Count no of lasers in each row and enter the no of lasers of each row into new Array(lasers in below code) .\\n2) If no of lasers in some row i is 0 then do not push it into array lasers.\\n3) Now calculate answer by multiplying lasers[i\\n and lasers[i+1] and adding all to get final answer.\\n ```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) \\n    {\\n        int n=bank.size(), m=bank[0].size();\\n        vector<int> lasers;\\n        for(int i=0; i<n; i++)\\n        {\\n            int temp=0;\\n            for(int j=0; j<m; j++) { if(bank[i][j]==\\'1\\') temp++; }\\n            if(temp) { lasers.push_back(temp);}\\n        }\\n        \\n        int sol=0; n = lasers.size();\\n        if(n==1) return 0;\\n        \\n        for(int i=0; i<n-1; i++) { sol += lasers[i]*lasers[i+1]; }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) \\n    {\\n        int n=bank.size(), m=bank[0].size();\\n        vector<int> lasers;\\n        for(int i=0; i<n; i++)\\n        {\\n            int temp=0;\\n            for(int j=0; j<m; j++) { if(bank[i][j]==\\'1\\') temp++; }\\n            if(temp) { lasers.push_back(temp);}\\n        }\\n        \\n        int sol=0; n = lasers.size();\\n        if(n==1) return 0;\\n        \\n        for(int i=0; i<n-1; i++) { sol += lasers[i]*lasers[i+1]; }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146696,
                "title": "java-simple-solution",
                "content": "```\\npublic int numberOfBeams(String[] bank) {\\n        int ones = bank[0].length() - bank[0].replaceAll(\"1\", \"\").length();\\n        int prod = 0;\\n        int i = 1;\\n        int next;\\n        while (i < bank.length) {\\n            next = bank[i].length() - bank[i].replaceAll(\"1\", \"\").length();\\n            prod += ones * next;\\n            ones = next > 0 ? next : ones;\\n            i++;\\n        }\\n        return prod;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numberOfBeams(String[] bank) {\\n        int ones = bank[0].length() - bank[0].replaceAll(\"1\", \"\").length();\\n        int prod = 0;\\n        int i = 1;\\n        int next;\\n        while (i < bank.length) {\\n            next = bank[i].length() - bank[i].replaceAll(\"1\", \"\").length();\\n            prod += ones * next;\\n            ones = next > 0 ? next : ones;\\n            i++;\\n        }\\n        return prod;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123743,
                "title": "java-easy-solution",
                "content": "# **java**\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n       int prevc=0,ans=0;\\n        for(String s:bank){\\n            int currc=0;\\n            for(char ch:s.toCharArray()){\\n                if(ch==\\'1\\')currc++;\\n            }\\n            if(currc>0){\\n                ans+=prevc*currc;\\n                prevc=currc;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# please upvote",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n       int prevc=0,ans=0;\\n        for(String s:bank){\\n            int currc=0;\\n            for(char ch:s.toCharArray()){\\n                if(ch==\\'1\\')currc++;\\n            }\\n            if(currc>0){\\n                ans+=prevc*currc;\\n                prevc=currc;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106797,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        convert = [sum([int(i) for i in x]) for x in bank]\\n        count = 0\\n        for i in range(len(convert)):\\n            if convert[i] != 0:\\n                p1 = convert[i]\\n                rp = i+1\\n                while rp<len(convert):\\n                    if convert[rp]!=0:\\n                        count+=p1*convert[rp]\\n                        break\\n                    rp+=1\\n\\n\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        convert = [sum([int(i) for i in x]) for x in bank]\\n        count = 0\\n        for i in range(len(convert)):\\n            if convert[i] != 0:\\n                p1 = convert[i]\\n                rp = i+1\\n                while rp<len(convert):\\n                    if convert[rp]!=0:\\n                        count+=p1*convert[rp]\\n                        break\\n                    rp+=1\\n\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052763,
                "title": "easy-constant-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int prevCount=0,ans=0;\\n        for(int i=0;i<bank.size();i++){\\n            int count=0;\\n            for(int j=0;j<bank[i].length();j++){\\n                if(bank[i][j]==\\'1\\')\\n                    count++;\\n            }\\n            if(count!=0){\\n                ans=ans+(prevCount*count);\\n                prevCount=count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int prevCount=0,ans=0;\\n        for(int i=0;i<bank.size();i++){\\n            int count=0;\\n            for(int j=0;j<bank[i].length();j++){\\n                if(bank[i][j]==\\'1\\')\\n                    count++;\\n            }\\n            if(count!=0){\\n                ans=ans+(prevCount*count);\\n                prevCount=count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974859,
                "title": "java-solution-using-queue",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for(String s : bank){\\n            int count = 0;\\n            for(int i = 0; i<s.length();i++){\\n                if(s.charAt(i)==\\'1\\')  count++;\\n            }\\n            if(count!=0) queue.offer(count);\\n        }\\n        int ans = 0;\\n        queue.offer(0);\\n        while (!queue.isEmpty()){\\n            if( queue.peek() == 0) break;\\n            ans += queue.poll()* queue.peek();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        for(String s : bank){\\n            int count = 0;\\n            for(int i = 0; i<s.length();i++){\\n                if(s.charAt(i)==\\'1\\')  count++;\\n            }\\n            if(count!=0) queue.offer(count);\\n        }\\n        int ans = 0;\\n        queue.offer(0);\\n        while (!queue.isEmpty()){\\n            if( queue.peek() == 0) break;\\n            ans += queue.poll()* queue.peek();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973237,
                "title": "60ms-c-simple-approach",
                "content": "```\\nclass Solution {\\n    public:\\n    \\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    \\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0,cur=0;\\n        for(auto &i:bank){\\n            int sum=0;\\n            for(auto &j:i){\\n                sum+=j-\\'0\\';     //calculating sum;\\n            }\\n            if(sum){\\n                ans+=cur*sum;\\n                cur=sum;\\n            }\\n        }\\n        \\n        \\n        return ans;                     //return ans;\\n        }\\n        \\n        \\n        \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n    \\n    Solution(){\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n    }\\n    \\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0,cur=0;\\n        for(auto &i:bank){\\n            int sum=0;\\n            for(auto &j:i){\\n                sum+=j-\\'0\\';     //calculating sum;\\n            }\\n            if(sum){\\n                ans+=cur*sum;\\n                cur=sum;\\n            }\\n        }\\n        \\n        \\n        return ans;                     //return ans;\\n        }\\n        \\n        \\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972595,
                "title": "think-about-the-concept-of-multiplication",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int[] description = new int[bank.length];\\n        for(int i=0;i<bank.length;i++){\\n            for(int j=0;j<bank[i].length();j++){\\n                description[i]+= bank[i].charAt(j)-\\'0\\';\\n            }\\n        }\\n        int ans = 0, firstRow = 0, secondRow = 0;\\n        for(int i = 0;i < description.length;i++){\\n            if(description[i]>0){\\n                firstRow=secondRow;\\n                secondRow=description[i];\\n                ans += (firstRow*secondRow);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int[] description = new int[bank.length];\\n        for(int i=0;i<bank.length;i++){\\n            for(int j=0;j<bank[i].length();j++){\\n                description[i]+= bank[i].charAt(j)-\\'0\\';\\n            }\\n        }\\n        int ans = 0, firstRow = 0, secondRow = 0;\\n        for(int i = 0;i < description.length;i++){\\n            if(description[i]>0){\\n                firstRow=secondRow;\\n                secondRow=description[i];\\n                ans += (firstRow*secondRow);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960792,
                "title": "javascript",
                "content": "```\\nvar numberOfBeams = function(bank) {\\n    let before = 0,after = 0,total = 0;\\n    for(i=0;i<bank.length;i++){\\n        for(j=0;j<bank[i].length;j++){\\n            if(bank[i][j] === \\'1\\'){\\n                after ++;\\n            }\\n        }\\n        if(after > 0){\\n            if(before === 0){\\n                before = after;\\n            }else{\\n                total += before*after;\\n                before = after;\\n            }\\n        }\\n        after = 0;\\n    }\\n    return total\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfBeams = function(bank) {\\n    let before = 0,after = 0,total = 0;\\n    for(i=0;i<bank.length;i++){\\n        for(j=0;j<bank[i].length;j++){\\n            if(bank[i][j] === \\'1\\'){\\n                after ++;\\n            }\\n        }\\n        if(after > 0){\\n            if(before === 0){\\n                before = after;\\n            }else{\\n                total += before*after;\\n                before = after;\\n            }\\n        }\\n        after = 0;\\n    }\\n    return total\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939657,
                "title": "simple-java-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        \\n        int count=0;\\n        int prev = 0;\\n        for(int i = 0; i < bank.length ; i++){\\n            int current =0;\\n                for(int j = 0 ; j < bank[i].length() ; j++)\\n                    if(bank[i].charAt(j)==\\'1\\') current++;\\n                  if(current==0) continue;\\n                    count+=prev*current;\\n                    prev=current;\\n        }\\n            return count; \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        \\n        int count=0;\\n        int prev = 0;\\n        for(int i = 0; i < bank.length ; i++){\\n            int current =0;\\n                for(int j = 0 ; j < bank[i].length() ; j++)\\n                    if(bank[i].charAt(j)==\\'1\\') current++;\\n                  if(current==0) continue;\\n                    count+=prev*current;\\n                    prev=current;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1938928,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        beams = 0\\n        prev = 0\\n        for b in bank:\\n            last = b.count(\\'1\\')\\n            if last:\\n                beams += prev * last\\n                prev = last\\n        return beams\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        beams = 0\\n        prev = 0\\n        for b in bank:\\n            last = b.count(\\'1\\')\\n            if last:\\n                beams += prev * last\\n                prev = last\\n        return beams\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929370,
                "title": "js-solution-using-map-and-filter",
                "content": "```\\nvar numberOfBeams = function(bank) {\\n  var finalRes = 0;\\n  const res = bank\\n    .map((row) => // counting 1\\'s and 0\\'s in each row\\n      [...row].reduce((prev, curr) => parseInt(prev) + parseInt(curr))\\n    ) // removing zeroes\\n    .filter((securityDevices) => securityDevices != 0);\\n// calculating the sum of multiplications of each security device row\\n  for (let i = 1; i < res.length; i++) {\\n    finalRes += res[i] * res[i - 1];\\n  }\\n  return finalRes;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numberOfBeams = function(bank) {\\n  var finalRes = 0;\\n  const res = bank\\n    .map((row) => // counting 1\\'s and 0\\'s in each row\\n      [...row].reduce((prev, curr) => parseInt(prev) + parseInt(curr))\\n    ) // removing zeroes\\n    .filter((securityDevices) => securityDevices != 0);\\n// calculating the sum of multiplications of each security device row\\n  for (let i = 1; i < res.length; i++) {\\n    finalRes += res[i] * res[i - 1];\\n  }\\n  return finalRes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1913882,
                "title": "c-solution-with-explanation",
                "content": "**Approch** \\n\\n* let\\'s say i^th row contain `n` ones and then consecutive row ( whichever with `m` ones `m > 0` ) then total possible laser is `n * m` \\n* so just count the `1\\'s` in each row and store it ( i.e if zero then don\\'t ) and traverse value and calculate according to `point 1`.\\n\\n**Time-Complexity**   -  **`O(nm)`**\\n**Space-Complexity**  - **`O(n)`**\\n\\n**Solution**\\n\\n```\\nclass Solution {\\n    \\nprivate :\\n    \\n    int Count_1(std::string s)\\n    {\\n        int res = 0 ;\\n        \\n        for( int i = 0 ; i < s.length() ; i++ )\\n            if( s[i] == \\'1\\' )\\n                res++ ;\\n        \\n        return res ;\\n    }\\n    \\npublic:\\n    \\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        std::vector<int> vec ;\\n        \\n        for( int i = 0 ; i < bank.size() ; i++ )\\n        {\\n            int val = Count_1(bank[i]) ;\\n            \\n            if( val )\\n                vec.push_back(val) ;\\n        }\\n        \\n        int res = 0 ;\\n        int n = vec.size() ;\\n        \\n        for( int i = 0 ; n &&  i < n-1 ; i++ )\\n        {\\n            res += vec[i] * vec[i+1] ;\\n        }\\n        \\n        return res ;\\n    }\\n};\\n```\\n\\ndo upvote if this helps :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    \\nprivate :\\n    \\n    int Count_1(std::string s)\\n    {\\n        int res = 0 ;\\n        \\n        for( int i = 0 ; i < s.length() ; i++ )\\n            if( s[i] == \\'1\\' )\\n                res++ ;\\n        \\n        return res ;\\n    }\\n    \\npublic:\\n    \\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        std::vector<int> vec ;\\n        \\n        for( int i = 0 ; i < bank.size() ; i++ )\\n        {\\n            int val = Count_1(bank[i]) ;\\n            \\n            if( val )\\n                vec.push_back(val) ;\\n        }\\n        \\n        int res = 0 ;\\n        int n = vec.size() ;\\n        \\n        for( int i = 0 ; n &&  i < n-1 ; i++ )\\n        {\\n            res += vec[i] * vec[i+1] ;\\n        }\\n        \\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870534,
                "title": "easy-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> vec;\\n        \\n        int row=bank.size();\\n        int col=bank[0].size();\\n        int sum=0;\\n        if(col==1 && row==1)\\n            return 0;\\n        \\n        int count=0,pCount=0;\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(bank[i][j]==\\'1\\')\\n                    count++;\\n            }\\n            if(count>0){\\n                 sum+=count*pCount;\\n                pCount=count;\\n                count=0;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> vec;\\n        \\n        int row=bank.size();\\n        int col=bank[0].size();\\n        int sum=0;\\n        if(col==1 && row==1)\\n            return 0;\\n        \\n        int count=0,pCount=0;\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(bank[i][j]==\\'1\\')\\n                    count++;\\n            }\\n            if(count>0){\\n                 sum+=count*pCount;\\n                pCount=count;\\n                count=0;\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860976,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int i,j;\\n        int k=0,ans=0;\\n        int prev=0;\\n        int n=bank.size();\\n        for(i=0;i<n;i++)\\n        {\\n            int o=0;\\n            for(j=0;j<bank[i].length();j++)\\n                if(bank[i][j]==\\'1\\')\\n                    o++;\\n            ans=ans+prev*o;\\n            if(o!=0)\\n            prev=o;\\n            cout<<ans<<\" \"<<prev<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int i,j;\\n        int k=0,ans=0;\\n        int prev=0;\\n        int n=bank.size();\\n        for(i=0;i<n;i++)\\n        {\\n            int o=0;\\n            for(j=0;j<bank[i].length();j++)\\n                if(bank[i][j]==\\'1\\')\\n                    o++;\\n            ans=ans+prev*o;\\n            if(o!=0)\\n            prev=o;\\n            cout<<ans<<\" \"<<prev<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1832792,
                "title": "python-solution-95-lesser-memory-5-lines-of-code",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        laser, n = [], len(bank[0])\\n        bank = list(filter((\"0\"*n).__ne__, bank))    \\n        for i in range(len(bank)-1):\\n            laser.append(bank[i].count(\"1\")*bank[i+1].count(\"1\"))\\n        return sum(laser)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        laser, n = [], len(bank[0])\\n        bank = list(filter((\"0\"*n).__ne__, bank))    \\n        for i in range(len(bank)-1):\\n            laser.append(bank[i].count(\"1\")*bank[i+1].count(\"1\"))\\n        return sum(laser)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831149,
                "title": "simple-solution-in-c-easy-understanding",
                "content": "class Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        vector<int>temp;\\n        \\n        for(auto x:bank)\\n        {\\n            int count=0;\\n            for(int y:x)\\n            {\\n                if(y==\\'1\\') count++;\\n            }\\n             \\n            if(count!=0)\\n            {\\n                temp.push_back(count);\\n            }\\n        }\\n        \\n        if(temp.size()<2)\\n        {\\n            return 0;\\n        }\\n        \\n        int ans =0;\\n        \\n        for(int i=1;i<temp.size();i++)\\n        {\\n            ans = ans + (temp[i-1]*temp[i]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        vector<int>temp;\\n        \\n        for(auto x:bank)\\n        {\\n            int count=0;\\n            for(int y:x)\\n            {\\n                if(y==\\'1\\') count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1816118,
                "title": "count-and-muntiply",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution() {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n    }\\n    int numberOfBeams(vector<string>& bank)\\n    {\\n        int n = bank.size();\\n        int cnt[n],count =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            count = 0;\\n            for(int j=0;j<bank[i].size();j++)\\n            {\\n                if(bank[i][j]==\\'1\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            cnt[i] = count;\\n        }\\n        int product = cnt[0],i=1;\\n        int sol = 0;\\n        while(i<n)\\n        {\\n            if(cnt[i]!=0)\\n            {\\n                product = product*cnt[i];\\n                sol += product;\\n                product = cnt[i];\\n            }\\n            i++;         \\n        }\\n    \\n      \\n        \\n        return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() {\\n        std::ios::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n    }\\n    int numberOfBeams(vector<string>& bank)\\n    {\\n        int n = bank.size();\\n        int cnt[n],count =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            count = 0;\\n            for(int j=0;j<bank[i].size();j++)\\n            {\\n                if(bank[i][j]==\\'1\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            cnt[i] = count;\\n        }\\n        int product = cnt[0],i=1;\\n        int sol = 0;\\n        while(i<n)\\n        {\\n            if(cnt[i]!=0)\\n            {\\n                product = product*cnt[i];\\n                sol += product;\\n                product = cnt[i];\\n            }\\n            i++;         \\n        }\\n    \\n      \\n        \\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775677,
                "title": "java-22ms-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public int count(String s)\\n    {\\n        int c=0,i;\\n        for(i=0;i<s.length();i++)\\n            {\\n                if(s.charAt(i)==\\'1\\'){\\n                  c+=1;\\n                }\\n            }\\n        return c;\\n            \\n    }\\n    public int numberOfBeams(String[] bank) {\\n        int i,a=0,k=0,pre=0;\\n        \\n            \\n        for(i=0;i<bank.length;i++)\\n        {\\n              k=count(bank[i]);\\n            if(k!=0){\\n              a+=pre*k;\\n              pre=k;\\n            }\\n        }\\n       \\n        \\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int count(String s)\\n    {\\n        int c=0,i;\\n        for(i=0;i<s.length();i++)\\n            {\\n                if(s.charAt(i)==\\'1\\'){\\n                  c+=1;\\n                }\\n            }\\n        return c;\\n            \\n    }\\n    public int numberOfBeams(String[] bank) {\\n        int i,a=0,k=0,pre=0;\\n        \\n            \\n        for(i=0;i<bank.length;i++)\\n        {\\n              k=count(bank[i]);\\n            if(k!=0){\\n              a+=pre*k;\\n              pre=k;\\n            }\\n        }\\n       \\n        \\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774441,
                "title": "number-of-laser-beams-in-a-bank",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0,c=0,d=0;\\n        for(int i=0;i<bank.size();i++){\\n            c=0;\\n          for(int j=0;j<bank[i].size();j++){\\n              if(bank[i][j]==\\'1\\')\\n                  c++;\\n          }\\n            if(c!=0){\\n                d+=ans*c;\\n                ans=c;\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0,c=0,d=0;\\n        for(int i=0;i<bank.size();i++){\\n            c=0;\\n          for(int j=0;j<bank[i].size();j++){\\n              if(bank[i][j]==\\'1\\')\\n                  c++;\\n          }\\n            if(c!=0){\\n                d+=ans*c;\\n                ans=c;\\n            }\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753411,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {String[]} bank\\n# @return {Integer}\\ndef number_of_beams(bank)\\n  bank.grep(/1/).map { _1.count(\\'1\\') }.each_cons(2).sum { _1 * _2 }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {String[]} bank\\n# @return {Integer}\\ndef number_of_beams(bank)\\n  bank.grep(/1/).map { _1.count(\\'1\\') }.each_cons(2).sum { _1 * _2 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1742636,
                "title": "simple-java-soln-faster-than-98",
                "content": "\\tpublic int numberOfBeams(String[] bank) {\\n        int prev = 0;\\n\\t\\tint res = 0;\\n\\t\\tfor (String b : bank) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (char c : b.toCharArray()) {\\n\\t\\t\\t\\tif (c == \\'1\\')\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tres += count * prev;\\n\\t\\t\\tif (count != 0)\\n\\t\\t\\t\\tprev = count;\\n\\t\\t}\\n\\t\\treturn res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic int numberOfBeams(String[] bank) {\\n        int prev = 0;\\n\\t\\tint res = 0;\\n\\t\\tfor (String b : bank) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (char c : b.toCharArray()) {\\n\\t\\t\\t\\tif (c == \\'1\\')\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tres += count * prev;\\n\\t\\t\\tif (count != 0)\\n\\t\\t\\t\\tprev = count;\\n\\t\\t}\\n\\t\\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1731678,
                "title": "python-3-solution-o-n-m",
                "content": "```py\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        res, prev = 0, -1\\n        for row in bank:\\n            if prev == -1:\\n                prev = row.count(\"1\")\\n                continue\\n            \\n            curr_cnt = row.count(\"1\")\\n            if curr_cnt:\\n                res += (prev * curr_cnt)\\n                prev = curr_cnt\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        res, prev = 0, -1\\n        for row in bank:\\n            if prev == -1:\\n                prev = row.count(\"1\")\\n                continue\\n            \\n            curr_cnt = row.count(\"1\")\\n            if curr_cnt:\\n                res += (prev * curr_cnt)\\n                prev = curr_cnt\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730640,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n*m)**\\nwhere n is length of bandk [] and m is lengths of strings in it.\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int[] arr = new int[bank.length];\\n        int k = 0;\\n        for(String s : bank){\\n            int count = 0;\\n            for(int i=0; i<s.length(); i++){\\n                if(s.charAt(i) == \\'1\\')   count++;\\n            }\\n            if(count != 0)  arr[k++] = count;\\n        }\\n        int res = 0;\\n        for(int i=0; i<arr.length-1; i++){\\n            res += arr[i] * arr[i+1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int[] arr = new int[bank.length];\\n        int k = 0;\\n        for(String s : bank){\\n            int count = 0;\\n            for(int i=0; i<s.length(); i++){\\n                if(s.charAt(i) == \\'1\\')   count++;\\n            }\\n            if(count != 0)  arr[k++] = count;\\n        }\\n        int res = 0;\\n        for(int i=0; i<arr.length-1; i++){\\n            res += arr[i] * arr[i+1];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1717420,
                "title": "c-map-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int result = 0;\\n        std::vector<int>map;\\n        for(int i=0;i<(int)bank.size();i++){\\n            int temp = 0;\\n            for(int j=0;j<(int)bank[i].length();j++){\\n                if(bank[i][j]==\\'1\\')\\n                    temp++;\\n            }\\n            if(temp) map.push_back(temp);\\n        }\\n        for(int i=0;i<(int)map.size()-1;i++)\\n            result += map[i] * map[i+1];\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int result = 0;\\n        std::vector<int>map;\\n        for(int i=0;i<(int)bank.size();i++){\\n            int temp = 0;\\n            for(int j=0;j<(int)bank[i].length();j++){\\n                if(bank[i][j]==\\'1\\')\\n                    temp++;\\n            }\\n            if(temp) map.push_back(temp);\\n        }\\n        for(int i=0;i<(int)map.size()-1;i++)\\n            result += map[i] * map[i+1];\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707511,
                "title": "easy-solution-less-than-150-ms-js-solution",
                "content": "This is a naive approach, but works...\\n\\n```\\nlet countBits = (n) => {\\n    let res = 0;\\n    for(let chr of n)\\n        if(chr === \\'1\\')\\n            res++;\\n    return res;    \\n}\\n\\nvar numberOfBeams = function(bank) {\\n    \\n    let countRow = 0;\\n    let countRowNext = 0;\\n    let noOfBeams = 0;\\n    let i = 0;\\n    let j = 1;\\n    \\n    while(i < bank.length-1 && j < bank.length){\\n        countRow = countBits(bank[i]);\\n        if(countRow === 0) { i++; j++; continue; }\\n        \\n        countRowNext = countBits(bank[j]);\\n        if(countRowNext === 0) { j++; continue;}\\n        \\n        if(countRowNext > 0){\\n            noOfBeams = noOfBeams + (countRow * countRowNext);\\n            i = j;\\n            j++;\\n        }\\n    }\\n    \\n    return noOfBeams;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "String"
                ],
                "code": "```\\nlet countBits = (n) => {\\n    let res = 0;\\n    for(let chr of n)\\n        if(chr === \\'1\\')\\n            res++;\\n    return res;    \\n}\\n\\nvar numberOfBeams = function(bank) {\\n    \\n    let countRow = 0;\\n    let countRowNext = 0;\\n    let noOfBeams = 0;\\n    let i = 0;\\n    let j = 1;\\n    \\n    while(i < bank.length-1 && j < bank.length){\\n        countRow = countBits(bank[i]);\\n        if(countRow === 0) { i++; j++; continue; }\\n        \\n        countRowNext = countBits(bank[j]);\\n        if(countRowNext === 0) { j++; continue;}\\n        \\n        if(countRowNext > 0){\\n            noOfBeams = noOfBeams + (countRow * countRowNext);\\n            i = j;\\n            j++;\\n        }\\n    }\\n    \\n    return noOfBeams;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1703215,
                "title": "java-10ms-beats-99-precompute-empty-row-string-iterate-rows",
                "content": "```\\n/*\\nRuntime: 10 ms, faster than 99.32% of Java online submissions for Number of Laser Beams in a Bank.\\nMemory Usage: 39.2 MB, less than 92.89% of Java online submissions for Number of Laser Beams in a Bank.\\n*/\\n\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        // int m = bank.length;\\n        int n = bank[0].length();\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (sb.length() < n) {\\n            sb.append(\"0\");\\n        }\\n        String emptyRow = sb.toString();\\n        \\n        int numLasers = 0; // what we\\'ll return\\n        int prevNumDevices = 0;\\n        for (String row : bank) {\\n            if (row.equals(emptyRow)) {\\n                continue;\\n            }\\n            \\n            int numDevices = 0;\\n            for (char c : row.toCharArray()) {\\n                if (c == \\'1\\') {\\n                    ++numDevices;\\n                }\\n            }\\n            \\n            numLasers += prevNumDevices * numDevices;\\n            prevNumDevices = numDevices;\\n        }\\n        \\n        return numLasers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 10 ms, faster than 99.32% of Java online submissions for Number of Laser Beams in a Bank.\\nMemory Usage: 39.2 MB, less than 92.89% of Java online submissions for Number of Laser Beams in a Bank.\\n*/\\n\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        // int m = bank.length;\\n        int n = bank[0].length();\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while (sb.length() < n) {\\n            sb.append(\"0\");\\n        }\\n        String emptyRow = sb.toString();\\n        \\n        int numLasers = 0; // what we\\'ll return\\n        int prevNumDevices = 0;\\n        for (String row : bank) {\\n            if (row.equals(emptyRow)) {\\n                continue;\\n            }\\n            \\n            int numDevices = 0;\\n            for (char c : row.toCharArray()) {\\n                if (c == \\'1\\') {\\n                    ++numDevices;\\n                }\\n            }\\n            \\n            numLasers += prevNumDevices * numDevices;\\n            prevNumDevices = numDevices;\\n        }\\n        \\n        return numLasers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692065,
                "title": "rust-count",
                "content": "```\\n    pub fn number_of_beams(bank: Vec<String>) -> i32 {\\n        let mut ans = 0;\\n        let mut prev = 0;\\n        for row in bank {\\n            let devices = row.chars().filter(|x| *x == \\'1\\').count() as i32;\\n            match devices {\\n                d if d > 0 => {  \\n                    ans += d * prev;  \\n                    prev = d; \\n                },\\n                _ => (),\\n            }\\n        }\\n        ans\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn number_of_beams(bank: Vec<String>) -> i32 {\\n        let mut ans = 0;\\n        let mut prev = 0;\\n        for row in bank {\\n            let devices = row.chars().filter(|x| *x == \\'1\\').count() as i32;\\n            match devices {\\n                d if d > 0 => {  \\n                    ans += d * prev;  \\n                    prev = d; \\n                },\\n                _ => (),\\n            }\\n        }\\n        ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688804,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int>v;//storing the frequency of 1\\'s;\\n       \\n        for(auto k:bank){\\n             int m=0;\\n            for(auto k1:k){\\n                if(k1==\\'1\\')\\n                    m++;\\n            }\\n            if(m!=0)\\n                v.push_back(m);\\n        }\\n        int ans=0;\\n        if(v.size()==0||v.size()==1)//there will be no matching laser beam in another row\\n            return 0;\\n        for(int i=0;i<v.size()-1;i++)\\n            ans+=v[i]*v[i+1];\\n        return ans;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int>v;//storing the frequency of 1\\'s;\\n       \\n        for(auto k:bank){\\n             int m=0;\\n            for(auto k1:k){\\n                if(k1==\\'1\\')\\n                    m++;\\n            }\\n            if(m!=0)\\n                v.push_back(m);\\n        }\\n        int ans=0;\\n        if(v.size()==0||v.size()==1)//there will be no matching laser beam in another row\\n            return 0;\\n        for(int i=0;i<v.size()-1;i++)\\n            ans+=v[i]*v[i+1];\\n        return ans;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684084,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int count = 0, prevCount = 0;\\n        \\n        for (int i = 0; i < bank.length; i++) {\\n            int currCount = 0;\\n            for (int j = 0; j < bank[i].length(); j++) {\\n                if (bank[i].charAt(j) == \\'1\\') currCount++;\\n            }\\n            if (currCount > 0) {\\n                count += prevCount * currCount;\\n                prevCount = currCount;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int count = 0, prevCount = 0;\\n        \\n        for (int i = 0; i < bank.length; i++) {\\n            int currCount = 0;\\n            for (int j = 0; j < bank[i].length(); j++) {\\n                if (bank[i].charAt(j) == \\'1\\') currCount++;\\n            }\\n            if (currCount > 0) {\\n                count += prevCount * currCount;\\n                prevCount = currCount;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673246,
                "title": "c-full-detailed-solution",
                "content": "We can solve these problem with two steps - \\n##### FIRST STEP - \\n\\nFrom the question one of the test case - \\n![image](https://assets.leetcode.com/users/images/d2d5efe4-40b4-42c6-827a-2564f83239ee_1641568016.9132593.png)\\n\\nNow if we recall the rule of formation of laser  - \\n![image](https://assets.leetcode.com/users/images/a104083e-b13b-44a4-bfc2-492b3fa5223f_1641568055.9364724.png)\\n\\nFrom the example we have first and third row in which we have 3 and 2 security devices respecively\\nNow every single device from the first row can form the laser with the first device in third row\\n\\n![image](https://assets.leetcode.com/users/images/3d46adb1-074f-412b-b093-7931b949d5bb_1641569631.1834948.png)\\n\\nSo number of lasers formed = **3x1**\\nFor the second security device in the third row we again able to form the laser from all the three security device present in the first row so \\ntotal number of lasers formed between the first and third row = **6**\\n\\nNow if we follow the same procedure for the row third and fourth \\ntotal number of lasers formed between the third and fourth row = **2**\\n\\n**Total number of lasers formed  =** **6 + 2 = 8**\\n\\n##### General Approach - \\n\\nSo let suppose you have two rows with the index **i** and **j**\\nRow **i** has **n(number of security devices)** and row **j** has **m(number of security devices)** \\n\\nNumber of laser formed between the **i** and **j** row  = **n*m**\\n\\nSo for the first step we will create the array of devices and store number of devices in each row\\n\\n##### SECOND STEP - \\nAs from the general approach we saw earlier we use that formula for each pair of row where security devices present.\\nWe will exclude those rows which has zero security device.\\n\\n##### Code- \\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int n = bank.size();\\n        int m = bank[0].size();\\n        vector<int> devices(n,0);\\n        for(int i=0;i<n;i++){\\n            int cnt = 0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\') cnt++;\\n            }\\n            devices[i] = cnt;\\n        }\\n        int res = 0;\\n        int i = 0;\\n        while(i<n){\\n            while(i<n && devices[i]==0) i++;\\n            if(i<n){\\n                int src = devices[i++];\\n                while(i<n && devices[i]==0) i++;\\n                if(i<n) res+=(src*devices[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nHopefully my explanation and code make sense to you all.\\nIf you find my post helpful please upvote my post.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int n = bank.size();\\n        int m = bank[0].size();\\n        vector<int> devices(n,0);\\n        for(int i=0;i<n;i++){\\n            int cnt = 0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\') cnt++;\\n            }\\n            devices[i] = cnt;\\n        }\\n        int res = 0;\\n        int i = 0;\\n        while(i<n){\\n            while(i<n && devices[i]==0) i++;\\n            if(i<n){\\n                int src = devices[i++];\\n                while(i<n && devices[i]==0) i++;\\n                if(i<n) res+=(src*devices[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668699,
                "title": "python-99-with-built-in-function",
                "content": "```python\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        prev = res = 0\\n        for row in bank:\\n            curr = row.count(\\'1\\')\\n            if curr:\\n                res += prev*curr\\n                prev = curr\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        prev = res = 0\\n        for row in bank:\\n            curr = row.count(\\'1\\')\\n            if curr:\\n                res += prev*curr\\n                prev = curr\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1666406,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "* ******Using Two Pointer******\\n\\n1. ***Time Complexity : O(N)***\\n2. ***Space Complexity : O(N)***\\n\\n```\\nint count_1(string str)\\n    {\\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'1\\')\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int n = bank.size();\\n        \\n        if(n == 0)\\n            return 0;\\n        \\n        vector<int> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int res = count_1(bank[i]);\\n            arr[i] = res;\\n        }\\n        \\n        int ans = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n-1)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                i++;\\n                continue;\\n            }\\n            \\n            int j = i+1;\\n            \\n            while(j < n && arr[j] == 0)\\n            {\\n                j++;\\n            }\\n            \\n            if(j < n)\\n            ans += arr[i] * arr[j];\\n            \\n            i = j;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint count_1(string str)\\n    {\\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(str[i] == \\'1\\')\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int n = bank.size();\\n        \\n        if(n == 0)\\n            return 0;\\n        \\n        vector<int> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int res = count_1(bank[i]);\\n            arr[i] = res;\\n        }\\n        \\n        int ans = 0;\\n        \\n        int i = 0;\\n        \\n        while(i < n-1)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                i++;\\n                continue;\\n            }\\n            \\n            int j = i+1;\\n            \\n            while(j < n && arr[j] == 0)\\n            {\\n                j++;\\n            }\\n            \\n            if(j < n)\\n            ans += arr[i] * arr[j];\\n            \\n            i = j;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1665693,
                "title": "c-easy-solution-o-mn",
                "content": "All we need to know is the nnumber of 1\\'s in each string. if we know the count of 1\\'s for each string, we can then simple multiply with the next string\\'s 1 count, cause that many combinations can be formed.\\n```\\nclass Solution {\\npublic:\\n    int count(string s){\\n        int n=0;\\n        for(auto i: s)\\n            if(i==\\'1\\') n++;\\n        return n;\\n    }\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0;\\n        vector<int> v;\\n        for(auto i: bank){\\n            int a=count(i);\\n            if(a) v.push_back(a);\\n        }\\n        if(v.size()==0) return 0;\\n        for(int i=1; i<v.size(); i++){\\n            ans+=(v[i]*v[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(string s){\\n        int n=0;\\n        for(auto i: s)\\n            if(i==\\'1\\') n++;\\n        return n;\\n    }\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0;\\n        vector<int> v;\\n        for(auto i: bank){\\n            int a=count(i);\\n            if(a) v.push_back(a);\\n        }\\n        if(v.size()==0) return 0;\\n        for(int i=1; i<v.size(); i++){\\n            ans+=(v[i]*v[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665573,
                "title": "ruby-solution",
                "content": "```\\n# @param {String[]} bank\\n# @return {Integer}\\ndef number_of_beams(bank)\\n    rows = bank.map {|row| row.count(\"1\")}.reject {|val| val==0}\\n    count = 0\\n    for i in 0...rows.length-1\\n        count += rows[i]*rows[i+1]\\n    end\\n    count\\nend",
                "solutionTags": [],
                "code": "```\\n# @param {String[]} bank\\n# @return {Integer}\\ndef number_of_beams(bank)\\n    rows = bank.map {|row| row.count(\"1\")}.reject {|val| val==0}\\n    count = 0\\n    for i in 0...rows.length-1\\n        count += rows[i]*rows[i+1]\\n    end\\n    count\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 1663834,
                "title": "simple-python-76ms-space-o-1",
                "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        n, m, prev, res, i= len(bank), len(bank[0]),0,0,0\\n        while i<n:\\n            one = bank[i].count(\\'1\\')\\n            i+=1\\n            if one:\\n                prev = one\\n                break \\n            \\n        for ii in range(i,n):\\n            curr = bank[ii].count(\\'1\\')\\n            if curr:\\n                res += curr*prev\\n                prev = curr \\n        return res \\n            \\n        \\n```\\nThe solution that I come up first time\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        arr = []\\n        n,m = len(bank),len(bank[0])\\n        for i in range(n):\\n            c = 0 \\n            for j in range(m):\\n                c += bank[i][j] == \\'1\\'\\n            if c:\\n                arr.append(c)\\n        res = 0 \\n        for i in range(1,len(arr)):\\n            res += arr[i]*arr[i-1]\\n        print(res)\\n        return res \\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        n, m, prev, res, i= len(bank), len(bank[0]),0,0,0\\n        while i<n:\\n            one = bank[i].count(\\'1\\')\\n            i+=1\\n            if one:\\n                prev = one\\n                break \\n            \\n        for ii in range(i,n):\\n            curr = bank[ii].count(\\'1\\')\\n            if curr:\\n                res += curr*prev\\n                prev = curr \\n        return res \\n            \\n        \\n```\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        arr = []\\n        n,m = len(bank),len(bank[0])\\n        for i in range(n):\\n            c = 0 \\n            for j in range(m):\\n                c += bank[i][j] == \\'1\\'\\n            if c:\\n                arr.append(c)\\n        res = 0 \\n        for i in range(1,len(arr)):\\n            res += arr[i]*arr[i-1]\\n        print(res)\\n        return res \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663408,
                "title": "c-2125-number-of-laser-beams-in-a-bank",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0, prev = 0; \\n        for (auto& row : bank) {\\n            int curr = count(row.begin(), row.end(), \\'1\\'); \\n            if (curr) {\\n                ans += prev * curr; \\n                prev = curr; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0, prev = 0; \\n        for (auto& row : bank) {\\n            int curr = count(row.begin(), row.end(), \\'1\\'); \\n            if (curr) {\\n                ans += prev * curr; \\n                prev = curr; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662670,
                "title": "simple-c-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    int numberOfBeams(vector<string>& bank) {\\n        int n=bank.size();\\n       int ans=0;\\n        vector<int>vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            for(int j=0;j<bank[i].size();j++)\\n            {\\n                if(bank[i][j]==\\'1\\')cnt++;\\n            }\\n            if(cnt!=0)\\n            vec.push_back(cnt);\\n        }\\n        if(vec.size()<=1)return 0;\\n        for(int i=0;i<vec.size()-1;i++)\\n        {\\n            ans+=vec[i]*vec[i+1];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int numberOfBeams(vector<string>& bank) {\\n        int n=bank.size();\\n       int ans=0;\\n        vector<int>vec;\\n        for(int i=0;i<n;i++)\\n        {\\n            int cnt=0;\\n            for(int j=0;j<bank[i].size();j++)\\n            {\\n                if(bank[i][j]==\\'1\\')cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1662621,
                "title": "number-of-laser-beams-in-a-bank",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector< string >& bank) {\\n        int n= bank.size();\\n        vector< int >val;\\n        for(int i=0;i<n;i++){\\n            int m=bank[i].size(),count=0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\')\\n                    count++;\\n            }\\n            if(count!=0)\\n              val.push_back(count);\\n        }\\n        int result=0;\\n        if(val.size()>1){\\n         for(int i=0;i+1<val.size();i++)\\n            result+=val[i]*val[i+1];\\n        return result;\\n        }\\n        else\\n            return 0;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfBeams(vector< string >& bank) {\\n        int n= bank.size();\\n        vector< int >val;\\n        for(int i=0;i<n;i++){\\n            int m=bank[i].size(),count=0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\')\\n                    count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1661822,
                "title": "naive-to-efficient-o-1-space-simple-easy-c",
                "content": "Implementation\\n\\n**Naive Approach\\nTime Complexity = O(N*M), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> vec;\\n        for(int itr = 0; itr < bank.size(); itr++){\\n            int count = 0;\\n            \\n            for(auto s : bank[itr]){\\n                if(s == \\'1\\') count++;\\n            }         \\n            if(count) vec.push_back(count);\\n        }\\n        \\n        if(vec.size() == 0) return 0;\\n        \\n        int res = 0;\\n        for(int itr = 0; itr < vec.size()-1; itr++){\\n            res += vec[itr] * vec[itr+1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Efficient Approach\\nTime Complexity = O(N*M), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {        \\n        int res = 0, prev = 0;        \\n        for(int itr = 0; itr < bank.size(); itr++){\\n            int cnt = count(bank[itr].begin(), bank[itr].end(), \\'1\\');            \\n            res += cnt * prev;\\n            if(cnt > 0) prev = cnt;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        vector<int> vec;\\n        for(int itr = 0; itr < bank.size(); itr++){\\n            int count = 0;\\n            \\n            for(auto s : bank[itr]){\\n                if(s == \\'1\\') count++;\\n            }         \\n            if(count) vec.push_back(count);\\n        }\\n        \\n        if(vec.size() == 0) return 0;\\n        \\n        int res = 0;\\n        for(int itr = 0; itr < vec.size()-1; itr++){\\n            res += vec[itr] * vec[itr+1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {        \\n        int res = 0, prev = 0;        \\n        for(int itr = 0; itr < bank.size(); itr++){\\n            int cnt = count(bank[itr].begin(), bank[itr].end(), \\'1\\');            \\n            res += cnt * prev;\\n            if(cnt > 0) prev = cnt;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661756,
                "title": "python-js-go-c-o-mn-by-decomposition-w-diagram",
                "content": "Laser beams comes from **two nearest effective laser device rows**\\n\\nWhole laser security array can be viewed as combination of laser rows.\\n\\n![image](https://assets.leetcode.com/users/images/4ecefbda-b713-4109-ac80-a0eab3edec99_1641110261.9475265.png)\\n\\nTotal count of laser beams \\n= **accumulation** of laser beams from **each effective pair of laser device row**\\n\\n---\\n\\n**Implementation** \\nin **Python**:\\n\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        get_laser_nodes = lambda row: row.count(\\'1\\')\\n        total_beams  = 0\\n        \\n        # initialization on first row\\n        prev = get_laser_nodes(bank[0])\\n\\n        # scan from second row in the bank\\n        for _, row in enumerate(bank[1:]):\\n            \\n            cur = get_laser_nodes(row)\\n            \\n            if not cur:\\n                # skip if current row has not laser nodes\\n                continue\\n            \\n            # count the laser beams between two nearest effective laser rows\\n            total_beams += prev * cur\\n            \\n            prev = cur\\n            \\n        return total_beams\\n```\\n\\n---\\n\\nin **Javascript**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nvar numberOfBeams = function(bank) {\\n    \\n    var getLaserNode = function(row){\\n        return ( row.match(/1/g) || [] ).length;\\n    }\\n    \\n    \\n    let totalBeams = 0;\\n    \\n    // # initialization on first row\\n    let prev = getLaserNode( bank[0] );\\n    \\n\\n    // scan from second row in the bank\\n    for(const row of bank.slice(1) ){\\n        \\n        let cur = getLaserNode( row );\\n        \\n        // skip if current row has not laser nodes\\n        if( cur == 0 )\\n        {   continue;\\n        }\\n        \\n        // count the laser beams between two nearest effective laser rows\\n        totalBeams += prev * cur;\\n        \\n        prev = cur;\\n        \\n    }\\n    \\n    return totalBeams;\\n    \\n};\\n```\\n\\n</details>\\n\\n\\n---\\n\\n\\nin **Go**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nfunc numberOfBeams(bank []string) int {\\n    \\n    var getLaserNode func(string) int\\n    \\n    getLaserNode = func(row string)int{\\n        return strings.Count(row, \"1\")\\n    }\\n    \\n    \\n    totalBeams := 0\\n    \\n    // initialization on first row\\n    prev := getLaserNode( bank[0] )\\n    \\n    \\n    // scan from second row in the bank\\n    for _, row := range( bank[1:] ){\\n        \\n        cur := getLaserNode( row )\\n        \\n        // skip if current row has not laser nodes\\n        if 0 == cur{\\n            continue\\n        }\\n        \\n        // count the laser beams between two nearest effective laser rows\\n        totalBeams += prev * cur\\n        \\n        prev = cur\\n    }\\n    \\n    return totalBeams\\n}\\n```\\n\\n</details>\\n\\n\\n---\\n\\n\\nin **C++**:\\n\\n<details>\\n\\t<summary> Expand to see source code </summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int totalBeams = 0;\\n        \\n        // initialization on first row\\n        int prev = getLaserNode( bank[0] );\\n        \\n        \\n        // scan from second row in the bank\\n        for(auto iter = bank.begin()+1 ; iter != bank.end() ; iter++){\\n            \\n            int cur = getLaserNode( *iter );\\n            \\n            // skip if current row has not laser nodes\\n            if( 0 == cur ){\\n                continue;\\n            }\\n            \\n            // count the laser beams between two nearest effective laser rows\\n            totalBeams += prev * cur;\\n            \\n            prev = cur;\\n            \\n        }\\n        \\n        return totalBeams;\\n    }\\n    \\nprivate:\\n    int getLaserNode( string& row){\\n        return std::count( row.begin(), row.end(), \\'1\\');\\n    }\\n};\\n```\\n\\n</details>",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        \\n        get_laser_nodes = lambda row: row.count(\\'1\\')\\n        total_beams  = 0\\n        \\n        # initialization on first row\\n        prev = get_laser_nodes(bank[0])\\n\\n        # scan from second row in the bank\\n        for _, row in enumerate(bank[1:]):\\n            \\n            cur = get_laser_nodes(row)\\n            \\n            if not cur:\\n                # skip if current row has not laser nodes\\n                continue\\n            \\n            # count the laser beams between two nearest effective laser rows\\n            total_beams += prev * cur\\n            \\n            prev = cur\\n            \\n        return total_beams\\n```\n```\\nvar numberOfBeams = function(bank) {\\n    \\n    var getLaserNode = function(row){\\n        return ( row.match(/1/g) || [] ).length;\\n    }\\n    \\n    \\n    let totalBeams = 0;\\n    \\n    // # initialization on first row\\n    let prev = getLaserNode( bank[0] );\\n    \\n\\n    // scan from second row in the bank\\n    for(const row of bank.slice(1) ){\\n        \\n        let cur = getLaserNode( row );\\n        \\n        // skip if current row has not laser nodes\\n        if( cur == 0 )\\n        {   continue;\\n        }\\n        \\n        // count the laser beams between two nearest effective laser rows\\n        totalBeams += prev * cur;\\n        \\n        prev = cur;\\n        \\n    }\\n    \\n    return totalBeams;\\n    \\n};\\n```\n```\\nfunc numberOfBeams(bank []string) int {\\n    \\n    var getLaserNode func(string) int\\n    \\n    getLaserNode = func(row string)int{\\n        return strings.Count(row, \"1\")\\n    }\\n    \\n    \\n    totalBeams := 0\\n    \\n    // initialization on first row\\n    prev := getLaserNode( bank[0] )\\n    \\n    \\n    // scan from second row in the bank\\n    for _, row := range( bank[1:] ){\\n        \\n        cur := getLaserNode( row )\\n        \\n        // skip if current row has not laser nodes\\n        if 0 == cur{\\n            continue\\n        }\\n        \\n        // count the laser beams between two nearest effective laser rows\\n        totalBeams += prev * cur\\n        \\n        prev = cur\\n    }\\n    \\n    return totalBeams\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int totalBeams = 0;\\n        \\n        // initialization on first row\\n        int prev = getLaserNode( bank[0] );\\n        \\n        \\n        // scan from second row in the bank\\n        for(auto iter = bank.begin()+1 ; iter != bank.end() ; iter++){\\n            \\n            int cur = getLaserNode( *iter );\\n            \\n            // skip if current row has not laser nodes\\n            if( 0 == cur ){\\n                continue;\\n            }\\n            \\n            // count the laser beams between two nearest effective laser rows\\n            totalBeams += prev * cur;\\n            \\n            prev = cur;\\n            \\n        }\\n        \\n        return totalBeams;\\n    }\\n    \\nprivate:\\n    int getLaserNode( string& row){\\n        return std::count( row.begin(), row.end(), \\'1\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661590,
                "title": "c-linq-2-lines-o-m-n-time-o-m-space",
                "content": "```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) \\n    {\\n        var list = bank.Select(s => s.Count(\\'1\\'.Equals)).Where(x => x != 0).ToList();\\n        return list.Zip(list.Skip(1), (cur, next) => cur * next).Sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) \\n    {\\n        var list = bank.Select(s => s.Count(\\'1\\'.Equals)).Where(x => x != 0).ToList();\\n        return list.Zip(list.Skip(1), (cur, next) => cur * next).Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661353,
                "title": "javascript-2125-number-of-laser-beams-in-a-bank",
                "content": "\\n---\\n\\n**Weekly Contest 274**\\n  - **Q1** answer\\n    - https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/discuss/1661296/JavaScript-2124.-Check-if-All-A\\'s-Appears-Before-All-B\\'s\\n- **Q2** answer\\n  - https://leetcode.com/problems/number-of-laser-beams-in-a-bank/discuss/1661353/javascript-2125-number-of-laser-beams-in-a-bank\\n  - **below**\\n- **Q3** answer\\n  - https://leetcode.com/problems/destroying-asteroids/discuss/1661395/JavaScript-2126.-Destroying-Asteroids\\n- **Q4** answer - **C++ & JavaScript**\\n  - https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/discuss/1664868/C%2B%2B-JavaScript-return-max-(-maxCycleLength-sumOfMaxCycle2ChainLengths-)\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar numberOfBeams = function (bank) {\\n    let sum = 0;\\n\\n    let prev = 0;                                      // previous device count\\n    for (let floor of bank) {                          // bank floor\\n        let curr = getDeviceCount(floor);              // current device count\\n        if (curr) {\\n            sum += curr * prev;\\n            prev = curr;\\n        }\\n    }\\n\\n    return sum;\\n};\\n\\nconst getDeviceCount = (s) => s.split(\"\").filter((x) => x === \"1\").length;\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfBeams = function (bank) {\\n    let sum = 0;\\n\\n    let prev = 0;                                      // previous device count\\n    for (let floor of bank) {                          // bank floor\\n        let curr = getDeviceCount(floor);              // current device count\\n        if (curr) {\\n            sum += curr * prev;\\n            prev = curr;\\n        }\\n    }\\n\\n    return sum;\\n};\\n\\nconst getDeviceCount = (s) => s.split(\"\").filter((x) => x === \"1\").length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661205,
                "title": "100-space-efficiency-c-simple-o-nm-using-bitset",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int count = 0;\\n        int start = 0;\\n        int end = 1;\\n        \\n        while(end < bank.size()){\\n            int n = bank[0].size();\\n            bitset<500> a((bank[start]));\\n            bitset<500> b((bank[end]));\\n            \\n            if(a.count() == 0 && b.count() == 0){\\n                start++;\\n                end++;\\n            }\\n            else if(a.count() != 0 && b.count() == 0){\\n                end++;\\n            }\\n            else if(a.count() == 0 && b.count() != 0){\\n                start = end;\\n                end++;\\n            }\\n            else{\\n                count+= a.count()*b.count();\\n                start = end;\\n                end++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int count = 0;\\n        int start = 0;\\n        int end = 1;\\n        \\n        while(end < bank.size()){\\n            int n = bank[0].size();\\n            bitset<500> a((bank[start]));\\n            bitset<500> b((bank[end]));\\n            \\n            if(a.count() == 0 && b.count() == 0){\\n                start++;\\n                end++;\\n            }\\n            else if(a.count() != 0 && b.count() == 0){\\n                end++;\\n            }\\n            else if(a.count() == 0 && b.count() != 0){\\n                start = end;\\n                end++;\\n            }\\n            else{\\n                count+= a.count()*b.count();\\n                start = end;\\n                end++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661145,
                "title": "python3-easy-to-understand",
                "content": "First count the number of \\'1\\'s for each row and insert in a list if the number of 1\\'s are greater than 0.\\n\\nThen, If the last row contains no security device then insert 0 in the list\\n\\nNow, just multiply the current and next value and add it to the ans\\n\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        ans=0\\n        a=[]\\n        for i in bank:\\n            c=i.count(\\'1\\')\\n            if c>0:a.append(c)\\n        c = bank[-1].count(\\'1\\')\\n        if c==0:\\n            a.append(c)\\n        for i in range(len(a)-1):\\n            ans+=a[i]*a[i+1]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        ans=0\\n        a=[]\\n        for i in bank:\\n            c=i.count(\\'1\\')\\n            if c>0:a.append(c)\\n        c = bank[-1].count(\\'1\\')\\n        if c==0:\\n            a.append(c)\\n        for i in range(len(a)-1):\\n            ans+=a[i]*a[i+1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661006,
                "title": "simple-and-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int rowSize=bank.size();\\n        int colSize=bank[0].size();\\n        \\n        vector<long long> row(rowSize,0);\\n        \\n        for(int i=0; i<rowSize; i++)\\n        {\\n            for(int j=0; j<colSize; j++)\\n            {\\n                if(bank[i][j] == \\'1\\')\\n                    row[i]++;\\n            }\\n        }\\n        \\n        long long totalBeams=0;\\n        \\n        for(int i=0; i<rowSize-1; i++)\\n        {\\n            if(row[i+1] == 0)\\n                row[i+1]=row[i];\\n            else\\n            {\\n                totalBeams+=(row[i] * row[i+1]);        \\n            }\\n        }\\n        \\n        return (int)totalBeams;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        \\n        int rowSize=bank.size();\\n        int colSize=bank[0].size();\\n        \\n        vector<long long> row(rowSize,0);\\n        \\n        for(int i=0; i<rowSize; i++)\\n        {\\n            for(int j=0; j<colSize; j++)\\n            {\\n                if(bank[i][j] == \\'1\\')\\n                    row[i]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1660974,
                "title": "java-simple-o-n",
                "content": "````\\n\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int pre = 0;\\n        int out = 0;\\n        for(int i=0;i<bank.length;i++){\\n            int c = 0;            \\n            for(int j=0;j<bank[i].length();j++){\\n                if(bank[i].charAt(j) == \\'1\\'){\\n                    c++;\\n                }\\n            }\\n            out += (c * pre);\\n            if(c > 0){\\n                pre=c;\\n            }\\n        }\\n        return out;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int pre = 0;\\n        int out = 0;\\n        for(int i=0;i<bank.length;i++){\\n            int c = 0;            \\n            for(int j=0;j<bank[i].length();j++){\\n                if(bank[i].charAt(j) == \\'1\\'){\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1660970,
                "title": "my-c-solution-easy-to-understand",
                "content": "```\\nint numberOfBeams(vector<string>& bank)\\n    {\\n        int n=bank.size();\\n        int isLaser[n];\\n        for(int i=0;i<n;i++)\\n            isLaser[i]=0;\\n        \\n        int res=0;\\n        int lastnonzero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<bank[0].length();j++)\\n            {\\n                if(bank[i][j]==\\'1\\')\\n                    isLaser[i]++;\\n            }\\n            if(i>0 && isLaser[i]!=0 && isLaser[i-1]!=0)\\n                res+=isLaser[i]*isLaser[i-1];\\n            else if(i>0 && isLaser[i]!=0)\\n                res+=isLaser[i]*lastnonzero;\\n            \\n              if(isLaser[i]!=0)\\n                lastnonzero=isLaser[i];\\n        }\\n        return res;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nint numberOfBeams(vector<string>& bank)\\n    {\\n        int n=bank.size();\\n        int isLaser[n];\\n        for(int i=0;i<n;i++)\\n            isLaser[i]=0;\\n        \\n        int res=0;\\n        int lastnonzero=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<bank[0].length();j++)\\n            {\\n                if(bank[i][j]==\\'1\\')\\n                    isLaser[i]++;\\n            }\\n            if(i>0 && isLaser[i]!=0 && isLaser[i-1]!=0)\\n                res+=isLaser[i]*isLaser[i-1];\\n            else if(i>0 && isLaser[i]!=0)\\n                res+=isLaser[i]*lastnonzero;\\n            \\n              if(isLaser[i]!=0)\\n                lastnonzero=isLaser[i];\\n        }\\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4078610,
                "title": "solution-of-number-of-laser-beams-in-a-bank-problem-two-pointer-algorithm",
                "content": "# Approach\\nSolved using two-pointer algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ - as two-pointer algorithm takes linear time and \\n.count() function takes linear time --> $$O(n*n)$$ == $$O(n^2)\\n$$.\\n- Space complexity:\\n$$O(1)$$ - as, no extra space is required.\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        left, right = 0, 0\\n        count = 0\\n        while right != len(bank) - 1:\\n            right += 1\\n            if bank[right].count(\"1\") != 0:\\n                count += bank[left].count(\"1\") * bank[right].count(\"1\")\\n                left = right\\n        return count\\n            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        left, right = 0, 0\\n        count = 0\\n        while right != len(bank) - 1:\\n            right += 1\\n            if bank[right].count(\"1\") != 0:\\n                count += bank[left].count(\"1\") * bank[right].count(\"1\")\\n                left = right\\n        return count\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078034,
                "title": "simple-and-intuitive-cpp-solution-that-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int m = bank.size(),n = bank[0].size();\\n        int ans = 0,prev = -1;\\n        for(int i=0;i<m;i++){\\n            int ones = 0;\\n            for(int j=0;j<n;j++){\\n                if(bank[i][j]==\\'1\\')\\n                    ones++;\\n            }\\n            cout<<ones<<endl;\\n            if(prev != -1 )\\n            ans+=(prev*ones);\\n            if(ones!=0)\\n            prev = ones;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int m = bank.size(),n = bank[0].size();\\n        int ans = 0,prev = -1;\\n        for(int i=0;i<m;i++){\\n            int ones = 0;\\n            for(int j=0;j<n;j++){\\n                if(bank[i][j]==\\'1\\')\\n                    ones++;\\n            }\\n            cout<<ones<<endl;\\n            if(prev != -1 )\\n            ans+=(prev*ones);\\n            if(ones!=0)\\n            prev = ones;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4074006,
                "title": "c-beats-100-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) \\n    {\\n      int n = bank.Length;\\n            int[] array = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                int m = 0;\\n                for (int j = 0; j < bank[i].Length; j++)\\n                {\\n                    if (bank[i][j] -\\'0\\' == 1)\\n                    {\\n                        m++;\\n                    }\\n                }\\n\\n                array[i] = m;\\n                m = 0;\\n            }\\n\\n            int x = 0, y = 1, ans = 0;\\n            while (x < n-1 && y < n)\\n            {\\n                while (x < n - 1 && array[x] == 0)\\n                {\\n                    x++;\\n                }\\n\\n                y = x + 1;\\n                while (y < n - 1 && array[y] == 0)\\n                {\\n                    y++;\\n                }\\n\\n                if (x >= y || y >= n)\\n                {\\n                    break;\\n                }\\n\\n                ans += (array[x]) * (array[y]);\\n                x = y;\\n            }\\n\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) \\n    {\\n      int n = bank.Length;\\n            int[] array = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                int m = 0;\\n                for (int j = 0; j < bank[i].Length; j++)\\n                {\\n                    if (bank[i][j] -\\'0\\' == 1)\\n                    {\\n                        m++;\\n                    }\\n                }\\n\\n                array[i] = m;\\n                m = 0;\\n            }\\n\\n            int x = 0, y = 1, ans = 0;\\n            while (x < n-1 && y < n)\\n            {\\n                while (x < n - 1 && array[x] == 0)\\n                {\\n                    x++;\\n                }\\n\\n                y = x + 1;\\n                while (y < n - 1 && array[y] == 0)\\n                {\\n                    y++;\\n                }\\n\\n                if (x >= y || y >= n)\\n                {\\n                    break;\\n                }\\n\\n                ans += (array[x]) * (array[y]);\\n                x = y;\\n            }\\n\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073620,
                "title": "c-solution-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<bank.size();i++){\\n            for(auto j:bank[i]){\\n                if(j==\\'1\\'){\\n                    m[i]++;\\n                }\\n            }\\n        }\\n        if(m.size()==0 || m.size()==1) return 0;\\n        vector<int> v;\\n        for(auto i:m){\\n            v.push_back(i.second);\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            ans+=v[i]*v[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0;\\n        map<int,int> m;\\n        for(int i=0;i<bank.size();i++){\\n            for(auto j:bank[i]){\\n                if(j==\\'1\\'){\\n                    m[i]++;\\n                }\\n            }\\n        }\\n        if(m.size()==0 || m.size()==1) return 0;\\n        vector<int> v;\\n        for(auto i:m){\\n            v.push_back(i.second);\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            ans+=v[i]*v[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072860,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        count_ones = []\\n\\n        for i in bank:\\n            count = i.count(\\'1\\')\\n            if count != 0:\\n                count_ones.append(count)\\n        \\n        if len(count_ones) <= 1:\\n            return 0\\n        \\n        total = 0\\n\\n        for i in range(1, len(count_ones)):\\n            total += count_ones[i] * count_ones[i-1]\\n\\n        return total\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        count_ones = []\\n\\n        for i in bank:\\n            count = i.count(\\'1\\')\\n            if count != 0:\\n                count_ones.append(count)\\n        \\n        if len(count_ones) <= 1:\\n            return 0\\n        \\n        total = 0\\n\\n        for i in range(1, len(count_ones)):\\n            total += count_ones[i] * count_ones[i-1]\\n\\n        return total\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071340,
                "title": "c-consider-rows-with-devices-only",
                "content": "# Intuition\\nLet\\'s think about this situation. Imagine we have 4 devices in the row 0, 0 devices in the row 1 and 2 devices in the row 2. Since we don\\'t have any devices in the row 1, the devices in the row 0 have nothing to do with devices in the row 1 and for that very reason the devices in the row 0 can interact with devices in the row 2. We skip the rows where we don\\'t have any devices and if a row does not have any devices\\n, then it lets the devices in the row above itself send laser beams to the devices in the row below itself (if any).\\n\\nYou can also convert the given array into an array of integers where each element in the array would indicate the number of laser devices on a particular row, not considering the rows with no devices. \\nFor example the array from the first example would be converted to an an array of integer as follows:\\n[3, 2, 1]. \\n3 is the number of devices in the row 0, 2 is the number of devices in the row 2 and 1 is the number of devices in the row 3. As you can see, we skiped the row 1 as it has no devices. Now the answer will be the sum of products of every pair of adjacent elements in the array\\nans = 3 * 2 + 2 * 1 = 8\\n\\nNote: if there is only one row with devices, then the answer is zero\\n\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#define vv std::vector\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        if(bank.size() == 1)\\n            return 0;\\n\\n        int above = 0, below = 0; // the floors, one on top of another\\n        int ans = 0;\\n\\n        above = numOfLaserBeams(bank, 0);\\n        for(int i = 1; i < bank.size(); i++)\\n        {\\n            //the number of devices on the above row is 0, skip \\n//finding the number of devices for the current row\\n            if(above == 0 && below != 0)\\n            {\\n                above = below;\\n                continue;\\n            }\\n            below = numOfLaserBeams(bank, i);\\n            if(below != 0)\\n            {\\n                ans += (above * below);\\n                above = below;\\n            }\\n        }\\n\\n        return ans;\\n    }\\nprivate:\\n    int numOfLaserBeams(vv<std::string>& bank, int row)\\n    {\\n        int cnt = 0;\\n        for(char i : bank[row])\\n            cnt += (i - \\'0\\');\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define vv std::vector\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        if(bank.size() == 1)\\n            return 0;\\n\\n        int above = 0, below = 0; // the floors, one on top of another\\n        int ans = 0;\\n\\n        above = numOfLaserBeams(bank, 0);\\n        for(int i = 1; i < bank.size(); i++)\\n        {\\n            //the number of devices on the above row is 0, skip \\n//finding the number of devices for the current row\\n            if(above == 0 && below != 0)\\n            {\\n                above = below;\\n                continue;\\n            }\\n            below = numOfLaserBeams(bank, i);\\n            if(below != 0)\\n            {\\n                ans += (above * below);\\n                above = below;\\n            }\\n        }\\n\\n        return ans;\\n    }\\nprivate:\\n    int numOfLaserBeams(vv<std::string>& bank, int row)\\n    {\\n        int cnt = 0;\\n        for(char i : bank[row])\\n            cnt += (i - \\'0\\');\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049424,
                "title": "c-a-very-simple-approach-to-this-problem-beats-89",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply traverse over all the rows (floors), while keeping a count of the number of cameras seen on the previous floor having cameras. Then we simply apply the multiplicative rule of PnC to get the required combinations sum.\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$ for traversing the prison matrix, where m is the number of floors and n is the number of cells on each floor.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0, curr = 0;\\n        for (string s: bank) {\\n            int devices = 0;\\n            for (char ch: s) {\\n                if (ch == \\'1\\') devices++;\\n            }\\n            if (devices) {\\n                ans += (devices * curr);\\n                curr = devices;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0, curr = 0;\\n        for (string s: bank) {\\n            int devices = 0;\\n            for (char ch: s) {\\n                if (ch == \\'1\\') devices++;\\n            }\\n            if (devices) {\\n                ans += (devices * curr);\\n                curr = devices;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042721,
                "title": "number-of-laser-beams-in-a-bank-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n       vector<int>ans;\\n       for(int i=0;i<bank.size();i++){\\n           int count=0;\\n           for(int j=0;j<bank[0].size();j++){\\n               if(bank[i][j]==\\'1\\') count++;\\n           }\\n           if(count>0) ans.push_back(count);\\n       } \\n       if(ans.size()<=1) return 0;\\n       long long sum=0;\\n       for(int i=0;i<ans.size()-1;i++) sum=sum+(ans[i]*ans[i+1]);\\n       return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n       vector<int>ans;\\n       for(int i=0;i<bank.size();i++){\\n           int count=0;\\n           for(int j=0;j<bank[0].size();j++){\\n               if(bank[i][j]==\\'1\\') count++;\\n           }\\n           if(count>0) ans.push_back(count);\\n       } \\n       if(ans.size()<=1) return 0;\\n       long long sum=0;\\n       for(int i=0;i<ans.size()-1;i++) sum=sum+(ans[i]*ans[i+1]);\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037261,
                "title": "delete-empty-rows",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        res=0\\n        index=[]\\n        for i in range(len(bank)):\\n            if bank[i].count(\\'1\\')==0:\\n                index.append(i)\\n        for i in index[::-1]:\\n            del bank[i]\\n        for i in range(len(bank)-1):\\n            first=bank[i].count(\\'1\\')\\n            last=bank[i+1].count(\\'1\\')\\n            res+=first*last\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        res=0\\n        index=[]\\n        for i in range(len(bank)):\\n            if bank[i].count(\\'1\\')==0:\\n                index.append(i)\\n        for i in index[::-1]:\\n            del bank[i]\\n        for i in range(len(bank)-1):\\n            first=bank[i].count(\\'1\\')\\n            last=bank[i+1].count(\\'1\\')\\n            res+=first*last\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032888,
                "title": "intuitive-o-m-n-python3-solution",
                "content": "# Intuition\\nEach device in a row creates a beam with each device in the following non-empty row. \\n\\n# Approach\\nCount number of devices in each row, multiply that with the number of devices in the next non-empty row, and sum all those values. \\n\\n# Complexity\\n- Time complexity: $$O(m\\xD7n)$$ where $$m\\xD7n$$ is the size of the matrix. Since we need to go through each row and go through all the cells in that row to count the devices. \\n\\n\\n- Space complexity: $$O(1)$$ Since we only use a 3 extra integer variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        lastCount, totalCount= 0, 0\\n        for row in bank:\\n            count = row.count(\"1\")\\n            if count !=0:\\n                totalCount += lastCount * count\\n                lastCount = count\\n        return totalCount\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        lastCount, totalCount= 0, 0\\n        for row in bank:\\n            count = row.count(\"1\")\\n            if count !=0:\\n                totalCount += lastCount * count\\n                lastCount = count\\n        return totalCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030378,
                "title": "easy-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prev=0;\\n        int res=0;\\n        for(String s:bank)\\n        {\\n          \\n           int cur=0;\\n            for(char c:s.toCharArray())\\n            {\\n                if(c==\\'1\\')\\n                cur++;\\n            }\\n          if(cur>0){\\n          res+=(prev*cur);\\n          prev=cur;\\n          }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prev=0;\\n        int res=0;\\n        for(String s:bank)\\n        {\\n          \\n           int cur=0;\\n            for(char c:s.toCharArray())\\n            {\\n                if(c==\\'1\\')\\n                cur++;\\n            }\\n          if(cur>0){\\n          res+=(prev*cur);\\n          prev=cur;\\n          }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026615,
                "title": "java-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nlinear time o(n)\\n\\n- Space complexity:\\nconstant time o(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n       \\n        int lastFloorHasDevice=-1;\\n        int lastFloorNumOfDevice=0;\\n        int result=0;\\n        for(int i=0;i<bank.length;i++)\\n        {\\n            int devicesPerFloor=0;\\n          for(int j=0;j<bank[i].length();j++)\\n          {\\n            devicesPerFloor+=bank[i].charAt(j)==\\'1\\'?1:0;\\n\\n          }\\n          if(devicesPerFloor!=0)\\n          {\\n              if(lastFloorHasDevice!=-1)\\n                   result+=lastFloorNumOfDevice*devicesPerFloor;\\n              \\n              lastFloorHasDevice=i;\\n              lastFloorNumOfDevice=devicesPerFloor;\\n              \\n          }\\n         \\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n       \\n        int lastFloorHasDevice=-1;\\n        int lastFloorNumOfDevice=0;\\n        int result=0;\\n        for(int i=0;i<bank.length;i++)\\n        {\\n            int devicesPerFloor=0;\\n          for(int j=0;j<bank[i].length();j++)\\n          {\\n            devicesPerFloor+=bank[i].charAt(j)==\\'1\\'?1:0;\\n\\n          }\\n          if(devicesPerFloor!=0)\\n          {\\n              if(lastFloorHasDevice!=-1)\\n                   result+=lastFloorNumOfDevice*devicesPerFloor;\\n              \\n              lastFloorHasDevice=i;\\n              lastFloorNumOfDevice=devicesPerFloor;\\n              \\n          }\\n         \\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022114,
                "title": "easy-and-short-cpp-solution-beats-98",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int n=bank.size();\\n        int m=bank[0].size();\\n        int ans=0, st=0, curr=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\'){\\n                    curr++;\\n                }\\n            }\\n            if(curr!=0){\\n                st=i;\\n                break;\\n            }   \\n        }\\n        for(int i=st+1;i<n;i++){\\n            int temp=0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\'){\\n                    temp++;\\n                }\\n            }\\n            if(temp!=0){\\n                ans+=(curr*temp);\\n                curr=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int n=bank.size();\\n        int m=bank[0].size();\\n        int ans=0, st=0, curr=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\'){\\n                    curr++;\\n                }\\n            }\\n            if(curr!=0){\\n                st=i;\\n                break;\\n            }   \\n        }\\n        for(int i=st+1;i<n;i++){\\n            int temp=0;\\n            for(int j=0;j<m;j++){\\n                if(bank[i][j]==\\'1\\'){\\n                    temp++;\\n                }\\n            }\\n            if(temp!=0){\\n                ans+=(curr*temp);\\n                curr=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014672,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0,m=0,n=0,begin=0;\\n        for(int i=0;i<bank.size();i++){\\n            int count=0;\\n            for(int j=0;j<bank[0].length();j++){\\n                if(bank[i][j]==\\'1\\')\\n                count++;\\n            }\\n            if(m==0)\\n            m=count;\\n            else if(m>0 && count>0){\\n            ans+=count*m;\\n            m=count;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans=0,m=0,n=0,begin=0;\\n        for(int i=0;i<bank.size();i++){\\n            int count=0;\\n            for(int j=0;j<bank[0].length();j++){\\n                if(bank[i][j]==\\'1\\')\\n                count++;\\n            }\\n            if(m==0)\\n            m=count;\\n            else if(m>0 && count>0){\\n            ans+=count*m;\\n            m=count;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014222,
                "title": "c-5-lines-of-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) \\n    {\\n        int ans = 0, num_lasers = 0, temp = 0;\\n\\n        for(int i=0; i<bank.size(); i++)\\n        {\\n            if(num_lasers != 0) temp = num_lasers, num_lasers = 0;\\n            \\n            for(int j=0; j<bank[i].length(); j++)\\n                if(bank[i][j] == \\'1\\') ++num_lasers;\\n\\n            if(num_lasers != 0) ans += temp * num_lasers;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) \\n    {\\n        int ans = 0, num_lasers = 0, temp = 0;\\n\\n        for(int i=0; i<bank.size(); i++)\\n        {\\n            if(num_lasers != 0) temp = num_lasers, num_lasers = 0;\\n            \\n            for(int j=0; j<bank[i].length(); j++)\\n                if(bank[i][j] == \\'1\\') ++num_lasers;\\n\\n            if(num_lasers != 0) ans += temp * num_lasers;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005356,
                "title": "ruby-one-liner-71ms",
                "content": "```\\ndef number_of_beams(bank)\\n  bank.delete_if{|b| !b.include?(\"1\")}.map{|b| b.count(\"1\")}.each_cons(2).sum{|a, b| a * b}\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef number_of_beams(bank)\\n  bank.delete_if{|b| !b.include?(\"1\")}.map{|b| b.count(\"1\")}.each_cons(2).sum{|a, b| a * b}\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4001563,
                "title": "easy-simple-beginer-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0,x=0,y=0;\\n        for(auto &i: bank){\\n            for(auto &j: i){\\n                if(j==\\'1\\')x++;\\n            }\\n            if(x){\\n                ans += (x*y);\\n                y = x;\\n                x = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int ans = 0,x=0,y=0;\\n        for(auto &i: bank){\\n            for(auto &j: i){\\n                if(j==\\'1\\')x++;\\n            }\\n            if(x){\\n                ans += (x*y);\\n                y = x;\\n                x = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000994,
                "title": "c-looping-approach-beginner-friendly-solution-programmed-by-a-beginner-p",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a 2D-array. Two laser devices connect with each other to form a laser beam. So we need to maintain two different different variable to store the count the number of security devices in between two rows.\\nWe are given that every device will connect to each and every device in it\\'s next row (if next row is not empty, else it will connect to the next non-empty row) this gives us the beams in between those two rows as `count of devices in first row * count of devices in second row`. In this way we can find total number of beams by simply adding them up.  \\n\\n*I don\\'t know what an upvote does, but still need one :)*\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a simple while loop we can traverse through the rows of the 2D array. Another for loop is used to maintain the count of security devices that we found in that particular row.\\nIf there is a device present in that row, then we simply make row1 = row2 and row2 = count. For count of beam, between those 2 rows we can simply multiply them and add to the final answer.\\n\\n\\n# Complexity\\n- Time complexity: O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int m = bank.size();\\n        int n = bank[0].size();\\n        int row1 = 0, row2 = 0;\\n        int count = 0;\\n        int ans = 0;\\n        int i = 0;\\n        while(i < m){\\n            count = 0;\\n            for(int j=0; j<n; j++){\\n                if(bank[i][j] == \\'1\\') count++;\\n            }\\n            if(count > 0){\\n                row1 = row2;\\n                row2 = count;\\n                ans += row1 * row2;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int m = bank.size();\\n        int n = bank[0].size();\\n        int row1 = 0, row2 = 0;\\n        int count = 0;\\n        int ans = 0;\\n        int i = 0;\\n        while(i < m){\\n            count = 0;\\n            for(int j=0; j<n; j++){\\n                if(bank[i][j] == \\'1\\') count++;\\n            }\\n            if(count > 0){\\n                row1 = row2;\\n                row2 = count;\\n                ans += row1 * row2;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977300,
                "title": "90-beats-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int c=0,ans=0,prev=0;\\n        vector<int> temp;\\n\\n        for(int i=0;i<bank.size();i++){\\n            c=0;\\n            c=count(bank[i].begin(),bank[i].end(),\\'1\\');\\n            if(c){\\n                ans+=prev*c;\\n                prev=c;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int c=0,ans=0,prev=0;\\n        vector<int> temp;\\n\\n        for(int i=0;i<bank.size();i++){\\n            c=0;\\n            c=count(bank[i].begin(),bank[i].end(),\\'1\\');\\n            if(c){\\n                ans+=prev*c;\\n                prev=c;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972452,
                "title": "prev-sum-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prev=0,sum=0;\\n        for(String str:bank){\\n            int count=0;\\n            for(char ch:str.toCharArray()){\\n                if(ch==\\'1\\')count++;\\n            }\\n            if(count>0){\\n                sum+=prev*count;\\n                prev=count;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prev=0,sum=0;\\n        for(String str:bank){\\n            int count=0;\\n            for(char ch:str.toCharArray()){\\n                if(ch==\\'1\\')count++;\\n            }\\n            if(count>0){\\n                sum+=prev*count;\\n                prev=count;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971139,
                "title": "c-sol",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) {\\n            List<int> Beams = new List<int>();\\n            int NumOfBeams = 0;\\n            int result = 0;\\n            \\n            for (int i = 0; i < bank.Length; i++) {\\n                for (int j = 0; j < bank[i].Length; j++) {\\n                    if (bank[i][j] == \\'1\\') {\\n                        NumOfBeams++;\\n                    }\\n                }\\n\\n                if (NumOfBeams != 0) { \\n\\n                    Beams.Add(NumOfBeams);\\n                    \\n                }\\n                NumOfBeams = 0;\\n            }\\n\\n            for (int i = 1; i < Beams.Count(); i++) {\\n                result += Beams[i] * Beams[i - 1];\\n            }\\n\\n            return result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) {\\n            List<int> Beams = new List<int>();\\n            int NumOfBeams = 0;\\n            int result = 0;\\n            \\n            for (int i = 0; i < bank.Length; i++) {\\n                for (int j = 0; j < bank[i].Length; j++) {\\n                    if (bank[i][j] == \\'1\\') {\\n                        NumOfBeams++;\\n                    }\\n                }\\n\\n                if (NumOfBeams != 0) { \\n\\n                    Beams.Add(NumOfBeams);\\n                    \\n                }\\n                NumOfBeams = 0;\\n            }\\n\\n            for (int i = 1; i < Beams.Count(); i++) {\\n                result += Beams[i] * Beams[i - 1];\\n            }\\n\\n            return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966349,
                "title": "number-of-laser-beams-in-a-bank",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        // 3241\\n        // 6+8+4=18\\n        int count = 0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<bank.length;i++)\\n        {\\n            int c = 0;\\n            for(int j=0;j<bank[i].length();j++)\\n            {\\n                if(bank[i].charAt(j)==\\'1\\')\\n                c++;\\n            }\\n            if(c>0)\\n            arr.add(c);\\n        }\\n        System.out.println(arr.size());\\n        if(arr.size()<=1)\\n        return 0;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            count=count+arr.get(i)*arr.get(i+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        // 3241\\n        // 6+8+4=18\\n        int count = 0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        for(int i=0;i<bank.length;i++)\\n        {\\n            int c = 0;\\n            for(int j=0;j<bank[i].length();j++)\\n            {\\n                if(bank[i].charAt(j)==\\'1\\')\\n                c++;\\n            }\\n            if(c>0)\\n            arr.add(c);\\n        }\\n        System.out.println(arr.size());\\n        if(arr.size()<=1)\\n        return 0;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            count=count+arr.get(i)*arr.get(i+1);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963847,
                "title": "beats-100-faster-c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& b) {\\n\\n        int ans=0;\\n        vector<int>v;\\n        for(auto i:b){\\n            int t=count(i.begin(),i.end(),\\'1\\');\\n            if(t){\\n                v.push_back(t);\\n            }\\n        }\\n        if(v.size()<=1){\\n            return 0;\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            ans+=v[i]*v[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& b) {\\n\\n        int ans=0;\\n        vector<int>v;\\n        for(auto i:b){\\n            int t=count(i.begin(),i.end(),\\'1\\');\\n            if(t){\\n                v.push_back(t);\\n            }\\n        }\\n        if(v.size()<=1){\\n            return 0;\\n        }\\n        for(int i=0;i<v.size()-1;i++){\\n            ans+=v[i]*v[i+1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946772,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        a=0\\n        for i in range(0,len(bank)-1) :\\n            if bank[i].count(\\'1\\')>0 :\\n                for j in range(i+1,len(bank)) :\\n                    if bank[j].count(\\'1\\')>0 :\\n                        a+=bank[i].count(\\'1\\')*bank[j].count(\\'1\\')\\n                        break\\n        return a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        a=0\\n        for i in range(0,len(bank)-1) :\\n            if bank[i].count(\\'1\\')>0 :\\n                for j in range(i+1,len(bank)) :\\n                    if bank[j].count(\\'1\\')>0 :\\n                        a+=bank[i].count(\\'1\\')*bank[j].count(\\'1\\')\\n                        break\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940922,
                "title": "c-time-o-mn-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep a record of last row that has devices\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) {\\n        int prev = 0;\\n        int beams = 0;\\n\\n        foreach(string s in bank)\\n        {\\n            int cur = s.Count(c => c == \\'1\\');\\n\\n            if (cur > 0)\\n            {\\n                beams += prev * cur;\\n                prev = cur;\\n            }   \\n        }\\n\\n        return beams;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumberOfBeams(string[] bank) {\\n        int prev = 0;\\n        int beams = 0;\\n\\n        foreach(string s in bank)\\n        {\\n            int cur = s.Count(c => c == \\'1\\');\\n\\n            if (cur > 0)\\n            {\\n                beams += prev * cur;\\n                prev = cur;\\n            }   \\n        }\\n\\n        return beams;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939057,
                "title": "very-easy-explanation-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeams will be between two rows having some zeroes. we can get beams by multiplying security device between two adjacent non zero rows.\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        // To store total number of beams\\n        int ans=0;\\n        // To store security devices in previous row\\n        int prev=0;\\n        for(int i=0;i<bank.length;i++){\\n            // To  store security devices in current row\\n            int curr=0;\\n            for(int j=0;j<bank[i].length();j++)\\n            {\\n                // If there is security device \\n                if(bank[i].charAt(j)==\\'1\\')\\n                {\\n                    curr++;\\n                }\\n            }\\n            // Adding beams between current row and previous row security device.\\n            ans+=curr*prev;\\n            if(curr!=0)\\n            {\\n                prev=curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        // To store total number of beams\\n        int ans=0;\\n        // To store security devices in previous row\\n        int prev=0;\\n        for(int i=0;i<bank.length;i++){\\n            // To  store security devices in current row\\n            int curr=0;\\n            for(int j=0;j<bank[i].length();j++)\\n            {\\n                // If there is security device \\n                if(bank[i].charAt(j)==\\'1\\')\\n                {\\n                    curr++;\\n                }\\n            }\\n            // Adding beams between current row and previous row security device.\\n            ans+=curr*prev;\\n            if(curr!=0)\\n            {\\n                prev=curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930084,
                "title": "94-beats-in-cpp-solutions-i-hope-you-like-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis a type of combination problem. You just have to keep track of  the previous number of laser;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe apparoach is quite simple You have to count the number of lasers at current row. Then you have a track of previous laser, suppose the current row have 2 lasers and previous laser row have  3 laser.....Tell me how many beams are generated...... The number of beams are 3*2 because every leaser releasing 2 beams....and thats it.....I hope you understand.....\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m*n) where m is the size of bank array and n is the size of every string inside the back array. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int beams = 0;\\n        int prev = 0;\\n        for(int i = 0;i < bank.size();i++){\\n            string s = bank[i];\\n            int lasers = 0;\\n            for(int j = 0;j < s.size();j++){\\n                if(s[j] == \\'1\\')lasers++;\\n            }\\n            beams += prev*lasers;\\n            if(lasers != 0)prev = lasers;\\n        }\\n        return beams;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int beams = 0;\\n        int prev = 0;\\n        for(int i = 0;i < bank.size();i++){\\n            string s = bank[i];\\n            int lasers = 0;\\n            for(int j = 0;j < s.size();j++){\\n                if(s[j] == \\'1\\')lasers++;\\n            }\\n            beams += prev*lasers;\\n            if(lasers != 0)prev = lasers;\\n        }\\n        return beams;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928445,
                "title": "beginner-friendly-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int c=0,ans=0;\\n        vector<int>res;\\n        if(bank.size()==1)\\n        return 0;\\n        for(int i=0;i<bank.size();i++){\\n            c=0;\\n            for(int j=0;j<bank[i].size();j++){\\n                if(bank[i][j]!=\\'0\\')\\n                c++;\\n            }\\n            if(c!=0)\\n            res.push_back(c);\\n        }\\n        if(res.size()==1||res.size()==0)\\n        return 0;\\n       for(int i=0;i<res.size()-1;i++){\\n          ans=ans+(res[i]*res[i+1]);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int c=0,ans=0;\\n        vector<int>res;\\n        if(bank.size()==1)\\n        return 0;\\n        for(int i=0;i<bank.size();i++){\\n            c=0;\\n            for(int j=0;j<bank[i].size();j++){\\n                if(bank[i][j]!=\\'0\\')\\n                c++;\\n            }\\n            if(c!=0)\\n            res.push_back(c);\\n        }\\n        if(res.size()==1||res.size()==0)\\n        return 0;\\n       for(int i=0;i<res.size()-1;i++){\\n          ans=ans+(res[i]*res[i+1]);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926963,
                "title": "java-treemap",
                "content": "# Intuition\\n//just store no. of beams of row in treeMap\\n// now for curr row see prev row having count > 0;\\n// and do simple maths\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int numberOfBeams(String[] bank) {\\n        int m = bank.length;\\n        int n = bank[0].length();\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int res = 0;\\n        for (int r = 0; r < m; r++) {\\n            int count = 0;\\n            for (int c = 0; c < n; c++) {\\n                if (bank[r].charAt(c) == \\'1\\') count++;\\n            }\\n            if (count > 0) map.put(r, count);\\n        }\\n\\n        int prev = -1;\\n        int k = 0;\\n        for (int key : map.keySet()) {\\n            if (k != 0) {\\n                int pr = map.get(prev);\\n                int cr = map.get(key);\\n                res += pr * cr;\\n            }\\n            k++;\\n            prev = key;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int numberOfBeams(String[] bank) {\\n        int m = bank.length;\\n        int n = bank[0].length();\\n\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int res = 0;\\n        for (int r = 0; r < m; r++) {\\n            int count = 0;\\n            for (int c = 0; c < n; c++) {\\n                if (bank[r].charAt(c) == \\'1\\') count++;\\n            }\\n            if (count > 0) map.put(r, count);\\n        }\\n\\n        int prev = -1;\\n        int k = 0;\\n        for (int key : map.keySet()) {\\n            if (k != 0) {\\n                int pr = map.get(prev);\\n                int cr = map.get(key);\\n                res += pr * cr;\\n            }\\n            k++;\\n            prev = key;\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920541,
                "title": "java-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        List<Integer> list = new ArrayList<>();\\n        int count = 0;\\n        for(int i = 0; i < bank.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < bank[i].length(); j++) {\\n                if(bank[i].charAt(j) == \\'1\\')\\n                    count += 1;\\n            }\\n            if(count > 0)\\n                list.add(count);\\n        }        \\n        int ans = 0;\\n        for(int i = 0; i < list.size()-1; i++)\\n            ans += (list.get(i) * list.get(i+1));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        List<Integer> list = new ArrayList<>();\\n        int count = 0;\\n        for(int i = 0; i < bank.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < bank[i].length(); j++) {\\n                if(bank[i].charAt(j) == \\'1\\')\\n                    count += 1;\\n            }\\n            if(count > 0)\\n                list.add(count);\\n        }        \\n        int ans = 0;\\n        for(int i = 0; i < list.size()-1; i++)\\n            ans += (list.get(i) * list.get(i+1));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908882,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 96 ms, faster than 81.34% of Python3 online submissions for Number of Laser Beams in a Bank.\\n# Memory Usage: 18.4 MB, less than 68.24% of Python3 online submissions for Number of Laser Beams in a Bank.\\n\\n\\tclass Solution:\\n\\t\\tdef numberOfBeams(self, bank: List[str]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tpreviuos_security_device = 0\\n\\n\\t\\t\\tfor row in bank:\\n\\n\\t\\t\\t\\tcurrent_security_device = row.count(\\'1\\')\\n\\n\\t\\t\\t\\tif previuos_security_device == 0:\\n\\t\\t\\t\\t\\tpreviuos_security_device = row.count(\\'1\\')\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult = result + previuos_security_device * current_security_device\\n\\n\\t\\t\\t\\t\\tif current_security_device != 0:\\n\\t\\t\\t\\t\\t\\tpreviuos_security_device = current_security_device\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n * m)\\n\\tSpace Complexity : O(1)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "String"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 96 ms, faster than 81.34% of Python3 online submissions for Number of Laser Beams in a Bank.\\n# Memory Usage: 18.4 MB, less than 68.24% of Python3 online submissions for Number of Laser Beams in a Bank.\\n\\n\\tclass Solution:\\n\\t\\tdef numberOfBeams(self, bank: List[str]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tpreviuos_security_device = 0\\n\\n\\t\\t\\tfor row in bank:\\n\\n\\t\\t\\t\\tcurrent_security_device = row.count(\\'1\\')\\n\\n\\t\\t\\t\\tif previuos_security_device == 0:\\n\\t\\t\\t\\t\\tpreviuos_security_device = row.count(\\'1\\')\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult = result + previuos_security_device * current_security_device\\n\\n\\t\\t\\t\\t\\tif current_security_device != 0:\\n\\t\\t\\t\\t\\t\\tpreviuos_security_device = current_security_device\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n * m)\\n\\tSpace Complexity : O(1)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3907880,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int beams = 0, prev_leasers = 0;\\n        for(int i=0; i < bank.size(); i++){\\n            int leasers = 0;\\n            for(int j=0; j < bank[i].size(); j++) if(bank[i][j]==\\'1\\') leasers++;\\n            if(leasers){\\n                beams += leasers*prev_leasers;\\n                prev_leasers = leasers;\\n            }\\n        }\\n        return beams;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfBeams(vector<string>& bank) {\\n        int beams = 0, prev_leasers = 0;\\n        for(int i=0; i < bank.size(); i++){\\n            int leasers = 0;\\n            for(int j=0; j < bank[i].size(); j++) if(bank[i][j]==\\'1\\') leasers++;\\n            if(leasers){\\n                beams += leasers*prev_leasers;\\n                prev_leasers = leasers;\\n            }\\n        }\\n        return beams;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1669349,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            },
            {
                "id": 1729409,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            },
            {
                "id": 1964451,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            },
            {
                "id": 1841069,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            },
            {
                "id": 2064431,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            },
            {
                "id": 2028948,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            },
            {
                "id": 1841071,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            },
            {
                "id": 1830519,
                "content": [
                    {
                        "username": "Lucew",
                        "content": "I don't wanna sound pretentious or arrogant, but I think this could also be an easy labelled (medium-easy) problem? Anybody with a different opinion?"
                    },
                    {
                        "username": "Prajju22",
                        "content": "agree.....\\n"
                    },
                    {
                        "username": "Chaiguy",
                        "content": "I agree this was relatively easy"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Definitely not a medium level problem. More like easy level problem if you ask me."
                    },
                    {
                        "username": "oops_moment",
                        "content": "For the one\\'s getting confused about wth the question is , bruh leetcode made it complex, take it simple it\\'s just a simple maths questions about the number of possible combinations.\\nSame to array : {3,0,2,1}:  answer is 3*2 + 2*1 as simple.\\nUpvote if you get what i\\'m saying :)"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "can this problem be resolved in complexity lower than n*n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "why is it medium?\\n"
                    },
                    {
                        "username": "tmcnutt22",
                        "content": "This problem is def an easy once you figure out what the 2nd condition means."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Nice little problem, it's easy because even  i can do it with no problem "
                    }
                ]
            }
        ]
    }
]