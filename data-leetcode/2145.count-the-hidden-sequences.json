[
    {
        "title": "Count the Hidden Sequences",
        "question_content": "You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers of a hidden sequence of length (n + 1). More formally, call the hidden sequence hidden, then we have that differences[i] = hidden[i + 1] - hidden[i].\nYou are further given two integers lower and upper that describe the inclusive range of values [lower, upper] that the hidden sequence can contain.\n\n\tFor example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6 (inclusive).\n\t\n\t\t[3, 4, 1, 5] and [4, 5, 2, 6] are possible hidden sequences.\n\t\t[5, 6, 3, 7] is not possible since it contains an element greater than 6.\n\t\t[1, 2, 3, 4] is not possible since the differences are not correct.\n\t\n\t\n\nReturn the number of possible hidden sequences there are. If there are no possible sequences, return 0.\n&nbsp;\nExample 1:\n\nInput: differences = [1,-3,4], lower = 1, upper = 6\nOutput: 2\nExplanation: The possible hidden sequences are:\n- [3, 4, 1, 5]\n- [4, 5, 2, 6]\nThus, we return 2.\n\nExample 2:\n\nInput: differences = [3,-4,5,1,-2], lower = -4, upper = 5\nOutput: 4\nExplanation: The possible hidden sequences are:\n- [-3, 0, -4, 1, 2, 0]\n- [-2, 1, -3, 2, 3, 1]\n- [-1, 2, -2, 3, 4, 2]\n- [0, 3, -1, 4, 5, 3]\nThus, we return 4.\n\nExample 3:\n\nInput: differences = [4,-7,2], lower = 3, upper = 6\nOutput: 0\nExplanation: There are no possible hidden sequences. Thus, we return 0.\n\n&nbsp;\nConstraints:\n\n\tn == differences.length\n\t1 <= n <= 105\n\t-105 <= differences[i] <= 105\n\t-105 <= lower <= upper <= 105",
        "solutions": [
            {
                "id": 1709755,
                "title": "java-c-python-straight-forward-solution-with-explantion",
                "content": "# **Explanation**\\nAssume we start with `a = 0`,\\ncontinuously calculate the next value by `difference`.\\nWe only need to record the current value `a`, the `max` and the `min` value in this sequence.\\n\\nNow we need to put the sequence with range `[min, max]` into a range of `[lower, upper]`.\\n\\nIf `upper - lower < max - min`, no possible hidden sequences.\\nIf `upper - lower == max - min`, we have only 1 possible hidden sequences.\\nIf `upper - lower == max - min + 1`, we have 2 possible hidden sequences.\\nIf `upper - lower == max - min + k`, we have k + 1 possible hidden sequences.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int numberOfArrays(int[] diff, int lower, int upper) {\\n        long a = 0, ma = 0, mi = 0;\\n        for (int d: diff) {\\n            a += d;\\n            ma = Math.max(ma, a);\\n            mi = Math.min(mi, a);\\n        }\\n        return (int)Math.max(0, (upper - lower) - (ma - mi) + 1);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        long a = 0, ma = 0, mi = 0;\\n        for (int d: diff) {\\n            a += d;\\n            ma = max(ma, a);\\n            mi = min(mi, a);\\n        }\\n        return max(0L, (upper - lower) - (ma - mi) + 1);\\n    }\\n```\\n\\n**Python3**\\n```py\\n    def numberOfArrays(self, diff, lower, upper):\\n        A = list(accumulate(diff, initial = 0))\\n        return max(0, (upper - lower) - (max(A) - min(A)) + 1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int numberOfArrays(int[] diff, int lower, int upper) {\\n        long a = 0, ma = 0, mi = 0;\\n        for (int d: diff) {\\n            a += d;\\n            ma = Math.max(ma, a);\\n            mi = Math.min(mi, a);\\n        }\\n        return (int)Math.max(0, (upper - lower) - (ma - mi) + 1);\\n    }\\n```\n```cpp\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        long a = 0, ma = 0, mi = 0;\\n        for (int d: diff) {\\n            a += d;\\n            ma = max(ma, a);\\n            mi = min(mi, a);\\n        }\\n        return max(0L, (upper - lower) - (ma - mi) + 1);\\n    }\\n```\n```py\\n    def numberOfArrays(self, diff, lower, upper):\\n        A = list(accumulate(diff, initial = 0))\\n        return max(0, (upper - lower) - (max(A) - min(A)) + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1709710,
                "title": "c-one-pass-o-n-time",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\nAssume `hidden[0] = 0`.\\n\\nWe can get all `hidden[i+1] = hidden[i] + diff[i]`.\\n\\nThe `hidden` array forms a polyline. Assume the max/min values are `max`/`min`.\\n\\nBy changing `hidden[0]`, we can shift this range up or down.\\n\\nIf we snap `max` to `upper`, we move up by `upper - max` steps. Then the number of possible of hidden sequences is `min + (upper - max) - lower + 1`.\\n![image](https://assets.leetcode.com/users/images/3d4d6da3-bfbf-4fb1-bc48-6e5b0deb77a7_1642871020.8740537.png)\\n\\nAnother way to think about it:\\n\\n![image](https://assets.leetcode.com/users/images/0c930a17-cd56-4903-9f3d-1e6f324b5253_1642909732.2986798.png)\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/count-the-hidden-sequences/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& A, int lower, int upper) {\\n        long sum = 0, mn = 0, mx = 0;\\n        for (int n : A) {\\n            sum += n;\\n            mn = min(mn, sum);\\n            mx = max(mx, sum);\\n        }\\n        return max(0L, mn - mx + upper - lower + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-70/problems/count-the-hidden-sequences/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& A, int lower, int upper) {\\n        long sum = 0, mn = 0, mx = 0;\\n        for (int n : A) {\\n            sum += n;\\n            mn = min(mn, sum);\\n            mx = max(mx, sum);\\n        }\\n        return max(0L, mn - mx + upper - lower + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709790,
                "title": "c-java-dry-run-steps-for-easy-understanding-observational-type",
                "content": "### Summary\\n- just see how much we need to bring the minimum value in the given range\\n- after bringing in the desired range, check if any element exceeded the `upper` range. \\n- if not then by subtracting from `upper` range check how much we can still add, until it reaches the maximum.\\n\\n### Approach\\n- first lets construct the **array** itself.\\n- array having first value same as `lower` seems fit\\n- then increased further elements as per in `difference array`. \\n- meanwhile we track, minimum value in `mn` and maximum value in `mx`.\\n- increase all the elements by _how much minimum element goes down from lower_.\\n- if by any chance any element goes above _(after uplifting every element)_ `upper` then **no** ans. possible, return 0. \\n- else we returned the by **how much more amount we can increase values**, till it reaches upper value.\\n- and that would be `given_upper_range - max_element_in_array + 1` _(after we have build the array, and all elements in range, **from lower to upper**)_.\\n\\n##### NOTE\\n- int got `signed integer overflow` in C++\\n\\n### Dry run\\n```\\nInput: differences = [1,-3,4], lower = 1, upper = 6\\nOutput: 2\\nExplanation: The possible hidden sequences are:\\n- [3, 4, 1, 5]\\n- [4, 5, 2, 6]\\nThus, we return 2.\\n```\\n\\n##### here we go\\n\\n- greedily we put the first element equals to `lower`\\n\\t```\\n\\tans = [1] \\n\\t```\\n- difference b/w 1st element of array and 2nd one has to be 1\\n\\t```\\n\\tans = [1, 1 + 1 ] \\n\\t```\\n- proceeding futher according to `difference array`. \\n\\t```\\n\\tans = [1, 1 + 1, 1 + 1 - 3, 1 + 1 - 3 + 4]\\n\\t```\\n- Finally\\n\\t```\\n\\tans = [1, 2, -1, 3]\\n\\t```\\n- bring minimum value in range, by lifting all the elements \\n  by, `lower - minimum_value`, here by `2`\\n\\t```\\n\\tans = [3, 4, 1, 5]\\n\\t```\\n * Note\\n\\t * if any value goes above `upper`, then we would have `return 0`, \\n\\t * there is no way we could get all values in range.\\n * Time to get final answer. \\n\\t * note that the maximum of this array is 5\\n\\t * permissible maximum is 6, so we can reach one more step further from 5 !! \\n\\t * by lifting all the elements by 1, i.e. `upper - maximum_value`.\\n\\t * which means how much more arrays we can get if we keep incrementing by `1`.\\n\\t * or, if keep adding `1` by `upper - maximum_value` times, then we will keep getting new array.\\n \\n\\n**THATS ALL** , `upper - maximum_value + 1` is our answer `+1` for the array we just build.\\n\\n<details>\\n<summary> C++ implementation </summary>\\n\\n```cpp\\nusing ll = long long int;\\nclass Solution {\\n    public:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        vector<ll> ans; \\n        ans.push_back(lower); \\n        ll mn = lower;\\n        ll mx = lower;\\n        for (const auto& d: differences) {\\n            ans.push_back(d + ans.back());\\n            mn = min(mn, ans.back());\\n            mx = max(mx, ans.back());\\n        }\\n\\n        ll add = lower - mn;\\n        \\n        for (auto& i: ans) i += add;\\n        for (auto& i: ans) if (i < lower or upper < i) return 0;\\n        \\n        ll add2 = upper - mx;\\n        \\n        return add2 - add + 1;\\n    }\\n}; \\n```\\n\\n</details>\\n\\n<details>\\n<summary> Java implementation </summary>\\n\\n```java\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(lower); \\n        int mn = lower;\\n        int mx = lower;\\n        \\n        for (int i = 0; i < differences.length; i++) {\\n            int d = differences[i];\\n            ans.add(d + ans.get(ans.size() - 1));\\n            mn = Math.min(mn, ans.get(ans.size() - 1));\\n            mx = Math.max(mx, ans.get(ans.size() - 1));\\n        }\\n\\n        int add = lower - mn;\\n        \\n        for (int i = 0; i < ans.size(); i++) {\\n            ans.set(i, ans.get(i) + add);\\n        }\\n        \\n        for (int i = 0; i < ans.size(); i++) {\\n            if (ans.get(i) < lower ||  upper < ans.get(i)) {\\n                return 0;\\n            }\\n        }\\n        \\n        int add2 = upper - mx;\\n        \\n        return add2 - add + 1;\\n    }\\n}\\n```\\n</details>\\n\\n\\n[More Questions with such explanations](https://github.com/mayankdutta/category-wise-problems)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nInput: differences = [1,-3,4], lower = 1, upper = 6\\nOutput: 2\\nExplanation: The possible hidden sequences are:\\n- [3, 4, 1, 5]\\n- [4, 5, 2, 6]\\nThus, we return 2.\\n```\n```\\n\\tans = [1] \\n\\t```\n```\\n\\tans = [1, 1 + 1 ] \\n\\t```\n```\\n\\tans = [1, 1 + 1, 1 + 1 - 3, 1 + 1 - 3 + 4]\\n\\t```\n```\\n\\tans = [1, 2, -1, 3]\\n\\t```\n```\\n\\tans = [3, 4, 1, 5]\\n\\t```\n```cpp\\nusing ll = long long int;\\nclass Solution {\\n    public:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        vector<ll> ans; \\n        ans.push_back(lower); \\n        ll mn = lower;\\n        ll mx = lower;\\n        for (const auto& d: differences) {\\n            ans.push_back(d + ans.back());\\n            mn = min(mn, ans.back());\\n            mx = max(mx, ans.back());\\n        }\\n\\n        ll add = lower - mn;\\n        \\n        for (auto& i: ans) i += add;\\n        for (auto& i: ans) if (i < lower or upper < i) return 0;\\n        \\n        ll add2 = upper - mx;\\n        \\n        return add2 - add + 1;\\n    }\\n}; \\n```\n```java\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(lower); \\n        int mn = lower;\\n        int mx = lower;\\n        \\n        for (int i = 0; i < differences.length; i++) {\\n            int d = differences[i];\\n            ans.add(d + ans.get(ans.size() - 1));\\n            mn = Math.min(mn, ans.get(ans.size() - 1));\\n            mx = Math.max(mx, ans.get(ans.size() - 1));\\n        }\\n\\n        int add = lower - mn;\\n        \\n        for (int i = 0; i < ans.size(); i++) {\\n            ans.set(i, ans.get(i) + add);\\n        }\\n        \\n        for (int i = 0; i < ans.size(); i++) {\\n            if (ans.get(i) < lower ||  upper < ans.get(i)) {\\n                return 0;\\n            }\\n        }\\n        \\n        int add2 = upper - mx;\\n        \\n        return add2 - add + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711078,
                "title": "c-o-n-easy-solution-just-use-simple-math",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int> differences, int lower, int upper) {\\n        long max_diff = 0;\\n        long min_diff = 0;\\n        long num = 0;\\n        for(int i = 0; i < differences.size(); i++) {\\n            num += differences[i];\\n            max_diff = max(max_diff, num);\\n            min_diff = min(min_diff, num);\\n        }\\n        int count = (upper - max_diff) - (lower - min_diff) + 1;\\n        return max(0, count);\\n    }\\n};\\n```\\n\\n# Logic\\ndifferences = [3,-4,5,1,-2], lower = -4, upper = 5\\n\\nfor solving this ques,\\nLet 1st no. be **x**  and we easily find all numbers using given difference array\\nso. \\n1st number = **x**\\n2nd number = 1st no. + diff = **x + 3**\\n3rd number = 2nd no. + diff = **(x + 3) + -4 = x - 1**\\n4th number = 3rd no. + diff = **(x - 1) + 5 = x + 4**\\n5th number = 4th no. + diff = **(x + 4) + 1 = x + 5**\\n6th number = 5th no. + diff = **(x + 5) + -2 = x +3**\\n\\nso no. will be **[x, x + 3, x - 1, x + 4, x + 5, x + 3]**\\n![image](https://assets.leetcode.com/users/images/c0e88cac-ed3d-414e-89fd-3fbea184cb5c_1642904982.241261.png)\\n\\n\\n\\nin this array, largest number is x + 5, smallest number is x - 1\\nand these are to be in given limit\\nand given limit is [-4, 5]\\n\\nso, largest number will be <= upper limit, i.e\\n```\\nlarge_num <= upper_limit\\nx + 5 <= 5 \\nx <= 5-5\\nx <= 0\\n```\\n\\nor in general, **x <= upper - max_diff**\\nand smallest number will be >= lower limit, i.e \\n```\\nsmaller_num >= loweer_limit\\nx - 1 >= -4 \\nx >= -4 + 1\\nx >= -3\\n```\\n\\nor in general, **x >= lower - min_diff**\\nso. overall eq. will be **-3 <= x <= 0**\\nor in general, **lower - min_diff <= x <= upper - max_diff**\\nThe possible hidden sequences are:\\n- [-3, 0, -4, 1, 2, 0]\\n- [-2, 1, -3, 2, 3, 1]\\n- [-1, 2, -2, 3, 4, 2]\\n- [0, 3, -1, 4, 5, 3]\\n\\nno. of arrays  = 0 - (-3) + 1 = 4 possible sequences\\nor in general, **(upper - max_diff) - (lower - min_diff) + 1**\\n\\nif this is -ve then this mean there is no possible sequence, simply return 0",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int> differences, int lower, int upper) {\\n        long max_diff = 0;\\n        long min_diff = 0;\\n        long num = 0;\\n        for(int i = 0; i < differences.size(); i++) {\\n            num += differences[i];\\n            max_diff = max(max_diff, num);\\n            min_diff = min(min_diff, num);\\n        }\\n        int count = (upper - max_diff) - (lower - min_diff) + 1;\\n        return max(0, count);\\n    }\\n};\\n```\n```\\nlarge_num <= upper_limit\\nx + 5 <= 5 \\nx <= 5-5\\nx <= 0\\n```\n```\\nsmaller_num >= loweer_limit\\nx - 1 >= -4 \\nx >= -4 + 1\\nx >= -3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710083,
                "title": "c-simple-explanation-o-n",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* Find the count of sequence that can be made using any value between upper bound and lower bound\\n#### \\u2714\\uFE0F **Solution - I (Naive Approach)**\\n##### **Intuition :-**\\n* Let take array [1, -3, 4]\\n* Thus, to create the hidden sequence we have to make the sequence such that [a, a + 1, a - 2, a + 2] as we are subtracting I element with I + 1 assume a = 0.\\n* Limits are a - 2 >= 1 and a + 2 <=6 as bounds are given on solving equation we get a >= 3 and a <= 4;\\n* Thus count = 2 as we can use a = 3 and 4 only.\\n\\n##### **Code :-**\\n```\\nclass Solution\\n{\\npublic:\\n     int numberOfArrays(vector<int> &A, int lower, int upper)\\n     {\\n          long total = 0, minimum = total, maximum = total;\\n          for (int num : A)\\n          {\\n               total += num;\\n               maximum = max(maximum, total);\\n               minimum = min(minimum, total);\\n          }\\n          return max(0L, minimum - maximum + upper - lower + 1);\\n     }\\n};\\n```\\n**Time Complexity** : `O(N)`, \\n**Space Complexity** : `O(1)`, \\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n     int numberOfArrays(vector<int> &A, int lower, int upper)\\n     {\\n          long total = 0, minimum = total, maximum = total;\\n          for (int num : A)\\n          {\\n               total += num;\\n               maximum = max(maximum, total);\\n               minimum = min(minimum, total);\\n          }\\n          return max(0L, minimum - maximum + upper - lower + 1);\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709696,
                "title": "c-simple-logic-explanation",
                "content": "```\\n// Logic \\n// Let\\'s say we take a value X as start element\\n// Now we keep adding elements of the differences to the value X. \\n// With every index, diff keeps accumulating\\n// We need to find the minimum and maximum difference from the start value. \\n\\n// For all values in the given range [lowerBound , upperBound], we check if it is possible to have a values with (val-minDiff) and (val+maxDiff)\\n\\n// For example : [1,-3,4] , lowerbound=1, upperbound=6\\n// if X is start value, then array elemnts can be represented as\\n// [X, X+1, X+(1-3), X+(1-3+4)] = [X, X+1, X-2, X+2]\\n// minDiff = -2\\n// maxDiff = +2\\n// Checking for values in range [1,6] for which [val+mindiff, val+maxdiff] are also in given range\\n\\n// (1) - (1-2, 1+2) - (-1, 3) - not in range\\n// (2) - (2-2, 2+2) - (0, 4) - not in range\\n// (3) - (3-2, 3+2) - (1, 5) - in range\\n// (4) - (4-2, 4+2) - (2, 6) - in range\\n// (5) - (5-2, 5+2) - (3, 7) - not in range\\n// (6) - (6-2, 6+2) - (4, 8) - not in range\\n\\n// ans = [3, 4] => count = (2)\\n\\n// Time complexity - O(n)\\n// Space complexity - O(1)\\n\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        \\n        long long int minDiff=0, maxDiff=0, val=0, start, end;\\n        for(int d : diff)\\n        {\\n            val+=d;\\n            minDiff = min(minDiff, val);\\n            maxDiff = max(maxDiff, val);\\n            \\n        }\\n\\n        int cnt=0;\\n        for(int i=lower; i<=upper; i++)\\n        {\\n            start = i+minDiff;\\n            end = i+maxDiff;\\n            if(start>=lower and end<=upper)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        \\n        long long int minDiff=0, maxDiff=0, val=0, start, end;\\n        for(int d : diff)\\n        {\\n            val+=d;\\n            minDiff = min(minDiff, val);\\n            maxDiff = max(maxDiff, val);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1709782,
                "title": "intuitive-straight-forward-minmax",
                "content": "**UPVOTE if you like the solution**\\uD83D\\uDC4D\\n\\n**Intuition**\\nIntuition was to start with backtracking and dp, but then you can see that the only changing parameter is the starting position, so it should be much easier.\\n\\n**Idea**\\nLet\\'s filter start positions:\\n- we pick a position from lower to upper\\n- if during the operations we go below lower or above higher we can\\'t start from that position\\n\\nWe calculate the smallest number we can reach during performing operations and the biggest one so we can say if each position is ok to start with.\\n\\nThe answer is the difference between minimum and maximum starting positions. This is the only thing we need to count because the whole hidden array depends on starting positons and knowing the sum (or max and min) we know if it will fit between lower and upper.\\n\\n**Code**\\n```\\npublic int numberOfArrays(int[] ar, int l, int u) {\\n\\tint n = ar.length;\\n\\tlong min = ar[0], max = ar[0], sum = 0;\\n\\t\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tsum+=ar[i];\\n\\t\\tmin=Math.min(min,sum);\\n\\t\\tmax=Math.max(max,sum);\\n\\t}\\n\\t\\n\\t// if we have a negative min it is possible we can go below [lower]\\n\\tlong lo = min < 0 ? l - min : l;\\n\\t\\n\\t// if we have a positive max it is possible we can go above [higher]\\n\\tlong hi = max > 0 ? u - max : u;\\n\\t\\n\\tif (hi < lo) return 0;\\n\\t\\n\\treturn (int)(hi - lo) + 1;\\n}\\n```\\n\\n**Stats**\\nTime O(n)\\nSpace O(1)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numberOfArrays(int[] ar, int l, int u) {\\n\\tint n = ar.length;\\n\\tlong min = ar[0], max = ar[0], sum = 0;\\n\\t\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tsum+=ar[i];\\n\\t\\tmin=Math.min(min,sum);\\n\\t\\tmax=Math.max(max,sum);\\n\\t}\\n\\t\\n\\t// if we have a negative min it is possible we can go below [lower]\\n\\tlong lo = min < 0 ? l - min : l;\\n\\t\\n\\t// if we have a positive max it is possible we can go above [higher]\\n\\tlong hi = max > 0 ? u - max : u;\\n\\t\\n\\tif (hi < lo) return 0;\\n\\t\\n\\treturn (int)(hi - lo) + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711702,
                "title": "c-o-n-solution-easy-understanding-detailed-explanation",
                "content": "Given array is [1,-3,4] = [x1, x2, x3]\\nLet the hidden sequence array is [a,b,c,d] where \\nb-a = x1, c-b = x2, d-c = x3\\n\\n1. The possible values for the element \\'a\\' are [lower, upper] = [1,6]\\n\\n2. Now, let\\'s try to find the possible values of element \\'b\\'. Since b-a = 1 .i.e. b=1+a, the possible values for element \\'b\\' are [1+a, 1+a] = [1+1, 1+6] = [2,7]. \\nBut according to the given range, the possible values for an element are [1,6]. \\nThus, range of b = **[max(new_lower, lower), min(new_upper, upper)]** = [max(2,1), min(6,7)] = [2,6]. \\n\\t\\t\\t\\t\\t\\t \\n3. Next, c-b=-3, the possible values for c are [-3+b, -3+b] = [-3+2, -3+6] = [1,3]. \\n\\tBut due to the given limits, the possible values of c are [max(1,1), min(3,6)] = [1,3]\\n\\n4. Next, d-c=4, the possible values for d are [4+c, 4+c] = [4+1, 4+3]= [5,7].\\n\\tBut due to the given limits, the possible values of d are [max(5, 1), min(7,6)] =[5, 6]\\n\\nFinally, the no.of possible values = upper-lower+1 = 6-5+1 = 2\\n\\nSometimes, no sequence is possible. In that case, we get negative value for possible values. Hence, return 0 whenever no.of possible values is negative.\\n```\\nint numberOfArrays(vector<int>& differences, int lower, int upper) {\\n\\n\\t// Initially for \\'a\\', the new_lower and new_upper are same as lower and upper\\n\\tlong new_lower = lower, new_upper = upper;\\n\\t\\n\\t// Add the current element to the present ranges to get the range of the next element in hidden sequence \\n\\tfor(auto it: differences){\\n\\t\\tnew_lower = max(new_lower+it, long(lower));\\n\\t\\tnew_upper = min(new_upper+it, long(upper));\\n\\t}\\n\\t\\n\\tlong ans = new_upper-new_lower+1;\\n\\treturn ans > 0 ? ans: 0;\\n}\\n```\\n\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numberOfArrays(vector<int>& differences, int lower, int upper) {\\n\\n\\t// Initially for \\'a\\', the new_lower and new_upper are same as lower and upper\\n\\tlong new_lower = lower, new_upper = upper;\\n\\t\\n\\t// Add the current element to the present ranges to get the range of the next element in hidden sequence \\n\\tfor(auto it: differences){\\n\\t\\tnew_lower = max(new_lower+it, long(lower));\\n\\t\\tnew_upper = min(new_upper+it, long(upper));\\n\\t}\\n\\t\\n\\tlong ans = new_upper-new_lower+1;\\n\\treturn ans > 0 ? ans: 0;\\n}\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1723033,
                "title": "best-optimal-explanation-with-example-c-mathematics-implementation",
                "content": "```\\n/* \\n\\t\\tThis problem is the implementation of mathematics.\\n        \\n        suppose your hidden array\\'s first element is x;\\n        \\n        then by taking example as [1,-3,4], lower = 1, upper = 6\\n\\t\\t\\n        your hidden array element would be x, x+1, x-2, x+2;\\n        \\n        Now if you see your maximum and minimum element of hidden array is x+2 and x-2 respectively.\\n        so x+2 <= upper and x-2 >= lower\\n        \\n        which is x+2 <= 6 and x-2 >= 1\\n        \\n        => x <= 4 and x >= 3\\n        \\n        => x = [3,4]\\n        \\n        which gives answer as you can have two hidden subarrays.\\n        And In code we are adding 1 to the answer bcz 4-3 = 1 but both 3 and 4 \\n\\t\\tshould be included in answer , hence we increase it by 1\\n\\t\\t*/\\n        C++ Code : \\n\\t\\t\\nint numberOfArrays(vector<int>& diff, int lower, int upper){\\n       \\n         long sum = 0, maxi = 0, mini = 0;\\n         for (int d : diff) {\\n            sum += d;\\n            maxi = max(maxi, sum);\\n            mini = min(mini, sum);\\n        }\\n        return max(0L, (upper - lower) - (maxi - mini) + 1);\\n }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* \\n\\t\\tThis problem is the implementation of mathematics.\\n        \\n        suppose your hidden array\\'s first element is x;\\n        \\n        then by taking example as [1,-3,4], lower = 1, upper = 6\\n\\t\\t\\n        your hidden array element would be x, x+1, x-2, x+2;\\n        \\n        Now if you see your maximum and minimum element of hidden array is x+2 and x-2 respectively.\\n        so x+2 <= upper and x-2 >= lower\\n        \\n        which is x+2 <= 6 and x-2 >= 1\\n        \\n        => x <= 4 and x >= 3\\n        \\n        => x = [3,4]\\n        \\n        which gives answer as you can have two hidden subarrays.\\n        And In code we are adding 1 to the answer bcz 4-3 = 1 but both 3 and 4 \\n\\t\\tshould be included in answer , hence we increase it by 1\\n\\t\\t*/\\n        C++ Code : \\n\\t\\t\\nint numberOfArrays(vector<int>& diff, int lower, int upper){\\n       \\n         long sum = 0, maxi = 0, mini = 0;\\n         for (int d : diff) {\\n            sum += d;\\n            maxi = max(maxi, sum);\\n            mini = min(mini, sum);\\n        }\\n        return max(0L, (upper - lower) - (maxi - mini) + 1);\\n }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1735431,
                "title": "python3-flowing-constraint-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to calculate constraints for every element of the hidden sequence starting from the beginning. The last constraint will be equal to the range that the last element of the sequence can take. Considering that the value of elements in the sequence depends on each other, the number of values that the last element can take is equal to the number of possible sequences, i.e. this is our answer. \\n\\nExample:  `differences = [1,-3,4], lower = 1, upper = 6`. Let the hidden sequence be `[a, b, c, d]`. Thus:\\n```\\nb - a = 1\\nc - b = -3\\nd - c = 4\\n```\\nLet\\'s isolate every element:\\n```\\na = b - 1\\nb = c + 3\\nc = d - 4\\n```\\nCalculate constraints for every element:\\n```\\nlower <= a <= upper\\n\\nlower <= b - 1 <= upper\\nlower + 1 <= b <= upper + 1\\n\\nlower + 1 <= c + 3 <= upper + 1\\nlower + 1 - 3 <= c <= upper + 1 - 3\\n\\nlower + 1 - 3 <= d - 4 <= upper + 1 - 3\\nlower + 1 - 3 + 4 <= d <= upper + 1 - 3 + 4\\n```\\nOn every step, we clip the resulting boundaries to the range `lower .. upper`, and also check if we got out of the range and return 0.\\n\\nTime: **O(n)** - linear\\nSpace: **O(1)** - nothing stored \\n\\nRuntime: 1288 ms, faster than **89.22%** of Python3 online submissions for Count the Hidden Sequences.\\nMemory Usage: 28.5 MB, less than **95.81%** of Python3 online submissions for Count the Hidden Sequences.\\n\\n```\\ndef numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n\\tlo, up = lower, upper\\n\\tfor diff in differences:\\n\\t\\tlo, up = max(lower, lo + diff), min(upper, up + diff)\\n\\t\\tif lo > upper or up < lower: return 0\\n\\n\\treturn up - lo + 1\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nb - a = 1\\nc - b = -3\\nd - c = 4\\n```\n```\\na = b - 1\\nb = c + 3\\nc = d - 4\\n```\n```\\nlower <= a <= upper\\n\\nlower <= b - 1 <= upper\\nlower + 1 <= b <= upper + 1\\n\\nlower + 1 <= c + 3 <= upper + 1\\nlower + 1 - 3 <= c <= upper + 1 - 3\\n\\nlower + 1 - 3 <= d - 4 <= upper + 1 - 3\\nlower + 1 - 3 + 4 <= d <= upper + 1 - 3 + 4\\n```\n```\\ndef numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n\\tlo, up = lower, upper\\n\\tfor diff in differences:\\n\\t\\tlo, up = max(lower, lo + diff), min(upper, up + diff)\\n\\t\\tif lo > upper or up < lower: return 0\\n\\n\\treturn up - lo + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1714246,
                "title": "right-left",
                "content": "Assuming that the starting point is zero, we determine the range of the hidden sequence ([left, right]).\\n\\nIf this range is smaller than [lower, upper] - we can form a valid sequence. The difference between those two ranges tells us how many valid sequences we can form: `upper - lower - (right - left) + 1`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:\\n        diff = list(accumulate(diff, initial = 0))\\n        return max(0, upper - lower - (max(diff) - min(diff)) + 1)\\n```\\n**C++**\\n```cpp\\nint numberOfArrays(vector<int>& diff, int lower, int upper) {\\n    long long left = 0, right = 0, cur = 0;\\n    for (int d : diff) {\\n        cur += d;\\n        left = min(left, cur);\\n        right = max(right, cur);\\n    }\\n    return max(0LL, upper - lower - (right - left) + 1);\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:\\n        diff = list(accumulate(diff, initial = 0))\\n        return max(0, upper - lower - (max(diff) - min(diff)) + 1)\\n```\n```cpp\\nint numberOfArrays(vector<int>& diff, int lower, int upper) {\\n    long long left = 0, right = 0, cur = 0;\\n    for (int d : diff) {\\n        cur += d;\\n        left = min(left, cur);\\n        right = max(right, cur);\\n    }\\n    return max(0LL, upper - lower - (right - left) + 1);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709717,
                "title": "binary-search-o-nlog-low-high-java",
                "content": "```\\nclass Solution {\\n    public int findLeft(int l, int h, int min, int max){\\n        int res = 1000000;\\n        int lower = l;\\n        int upper = h;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if( mid + min >= lower && mid + max <= upper){\\n                res = mid;\\n                h = mid-1;\\n            }\\n            else if( mid+min < lower){\\n                l = mid+1;\\n            }\\n            else\\n                h = mid-1;\\n        }\\n\\n        return res;\\n    }\\n\\n    public int findRight(int l, int h, int min, int max){\\n        int res = 1000000;\\n        int lower = l;\\n        int upper = h;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if( mid + min >= lower && mid + max <= upper){\\n                res = mid;\\n                l = mid+1;\\n            }\\n            else if( mid+min < lower){\\n                l = mid+1;\\n            }\\n            else\\n                h = mid-1;\\n        }\\n        return res;\\n    }\\n\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int n = differences.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        int sum = 0;\\n\\n        for(int i : differences){\\n            sum += i;\\n            min = Math.min(min, sum);\\n            max = Math.max(max, sum);\\n        }\\n\\n        int left = findLeft(lower, upper, min, max);\\n        int right = findRight(lower, upper, min, max);\\n\\n        if( left == 1000000 || right == 1000000)\\n            return 0;\\n\\n        return right-left+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findLeft(int l, int h, int min, int max){\\n        int res = 1000000;\\n        int lower = l;\\n        int upper = h;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if( mid + min >= lower && mid + max <= upper){\\n                res = mid;\\n                h = mid-1;\\n            }\\n            else if( mid+min < lower){\\n                l = mid+1;\\n            }\\n            else\\n                h = mid-1;\\n        }\\n\\n        return res;\\n    }\\n\\n    public int findRight(int l, int h, int min, int max){\\n        int res = 1000000;\\n        int lower = l;\\n        int upper = h;\\n        while(l <= h){\\n            int mid = l + (h-l)/2;\\n            if( mid + min >= lower && mid + max <= upper){\\n                res = mid;\\n                l = mid+1;\\n            }\\n            else if( mid+min < lower){\\n                l = mid+1;\\n            }\\n            else\\n                h = mid-1;\\n        }\\n        return res;\\n    }\\n\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int n = differences.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        int sum = 0;\\n\\n        for(int i : differences){\\n            sum += i;\\n            min = Math.min(min, sum);\\n            max = Math.max(max, sum);\\n        }\\n\\n        int left = findLeft(lower, upper, min, max);\\n        int right = findRight(lower, upper, min, max);\\n\\n        if( left == 1000000 || right == 1000000)\\n            return 0;\\n\\n        return right-left+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709670,
                "title": "java-simple-solution-find-possible-min-and-max-o-n",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int result = 0;\\n        int diff = 0;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        // the possible max and min value when adding differences\\n        for (int i = 0; i < differences.length; ++i) {\\n            diff += differences[i];\\n            min = Math.min(min, diff);\\n            max = Math.max(max, diff);\\n        }\\n        for (int i = lower; i <= upper; ++i) {\\n            int low = i + min;\\n            int high = i + max;\\n            if (low >= lower && high <= upper) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int result = 0;\\n        int diff = 0;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        // the possible max and min value when adding differences\\n        for (int i = 0; i < differences.length; ++i) {\\n            diff += differences[i];\\n            min = Math.min(min, diff);\\n            max = Math.max(max, diff);\\n        }\\n        for (int i = lower; i <= upper; ++i) {\\n            int low = i + min;\\n            int high = i + max;\\n            if (low >= lower && high <= upper) {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710267,
                "title": "c-o-n-time-one-pass-and-constant-space",
                "content": "Main idea is to understand that we need to check for boundaries for lower and upper limits while traversing the difference array.\\nSay for first test case, ```differences = [1,-3,4], lower = 1, upper = 6``` we can make sure that for limits 1,2 this will fail as we will be out of bounds. Similarly, for 5,6 we will cross the upper bound.\\nHow to decide this bound?\\nSay we have lower limit as 1. We start off with 1 and checking difference array we populate our next elements that will be 2, -1 and 3.\\nSince, third element -1 is below our lower limit we won\\'t count this in answer.\\nHow can we check using single pass that number of lower bounds which will fail? We do that, using a sum variable to check progress and it repeatedly holds our minimum ever value here which is going to be -1. Thus, to be well within range, it needs to be 2 units up. Thus, we shall increase our lower limit two units up to 3. Similarly, upper limit goes to 4.\\nThus 3 and 4 will be our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& a, int l, int u) {\\n        long sum = 0, minm = l, maxm = u;\\n        for(auto& i: a) {\\n            sum += i;\\n            minm = min(minm, sum+l);\\n            maxm = max(maxm, sum+u);\\n        }\\n        int lower = 2*l - minm, upper = 2*u-maxm;\\n        return (lower > upper ? 0: upper-lower+1);\\n    }\\n};\\n```\\n\\nUpvote, if you find it useful :)",
                "solutionTags": [],
                "code": "```differences = [1,-3,4], lower = 1, upper = 6```\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& a, int l, int u) {\\n        long sum = 0, minm = l, maxm = u;\\n        for(auto& i: a) {\\n            sum += i;\\n            minm = min(minm, sum+l);\\n            maxm = max(maxm, sum+u);\\n        }\\n        int lower = 2*l - minm, upper = 2*u-maxm;\\n        return (lower > upper ? 0: upper-lower+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709996,
                "title": "c-o-n-explanation",
                "content": "Approach: Consider ements of hidden sequence as a,b,c,d ...\\n\\nSo ***distance array*** is **{a-b,b-c,c-d.......}**\\nSo if we find ***prefix sum*** of distance array we get  **{a-b,a-c,a-d,a-e.......}**\\n\\nNow , if ***our base/ refrence is \"a\" ie first element,*** then this prefix array tells us the difference between refrence and other elements. \\n\\nSo maximun prefix sum will be for the element which is at largest difference with refrence ie \"a\".\\nSimilarly minimum will be also for such extreme.\\n\\nConsider we have prefix array [-2,-3,2] ~ [a-b, a-c, a-d]\\nPlot  it like this to understand\\na-b = -2 then b = a+2\\na-c = -3 then c = a+3\\na-d = +2 then d = a-2\\nAnd if we consider **a = 0** , we get b=2,c=3,d=-2 and now plot them\\nThis will give us \\n```\\n.   \\n5   |\\n4   |\\n3   |                         c----------------------|\\n2   |               b                                |    \\n1  |                                                 |\\n0   |    a                                           |     This gap is range of sequence ( Gap between Max and min from refrence)\\n-1  |                                                |\\n-2  |                                     d----------|\\n-3  |\\n.       __________________________________     \\n.\\n```\\n\\nand if we can notice **range of sequence is gap between max height element and min height element**\\nie here between c and d or say it as (c-d)\\nConsider range as R = c-d .\\nNow we have to find number of sequence possible between [Lower,Upper]\\n\\n**So total count will be Upper - (Lower+Range) +1 .**\\nWhy?? => Assign lowest value in sequence as Lower, Then in next turn Lower+1 ....keep doint until highest element is <= Upper.\\n\\nIf Range size is more than Upper - Lower , no sequence can be made.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& d, int l, int u) {\\n        \\n        long long int n = d.size();\\n        long long int pr =0;\\n        long long int mini =0;\\n        long long int maxi =0;\\n        for(long long int i=0;i<n;i++)\\n        {\\n            pr+=d[i];\\n            maxi=max(maxi,pr);\\n            mini=min(mini,pr);\\n        }\\n        \\n\\n        long long int range = maxi-mini;\\n        long long int cnt=0;\\n        if(u-l<range)\\n            return 0;\\n        cnt = u-(l+range);\\n        return cnt+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n.   \\n5   |\\n4   |\\n3   |                         c----------------------|\\n2   |               b                                |    \\n1  |                                                 |\\n0   |    a                                           |     This gap is range of sequence ( Gap between Max and min from refrence)\\n-1  |                                                |\\n-2  |                                     d----------|\\n-3  |\\n.       __________________________________     \\n.\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& d, int l, int u) {\\n        \\n        long long int n = d.size();\\n        long long int pr =0;\\n        long long int mini =0;\\n        long long int maxi =0;\\n        for(long long int i=0;i<n;i++)\\n        {\\n            pr+=d[i];\\n            maxi=max(maxi,pr);\\n            mini=min(mini,pr);\\n        }\\n        \\n\\n        long long int range = maxi-mini;\\n        long long int cnt=0;\\n        if(u-l<range)\\n            return 0;\\n        cnt = u-(l+range);\\n        return cnt+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709869,
                "title": "python3-runtime-o-n",
                "content": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        l = [0]\\n        for i in differences:\\n            l.append(l[-1]+i)\\n        return max(0,(upper-lower+1)-(max(l)-min(l)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        l = [0]\\n        for i in differences:\\n            l.append(l[-1]+i)\\n        return max(0,(upper-lower+1)-(max(l)-min(l)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709849,
                "title": "naive-and-optimized-with-in-depth-explanation-c",
                "content": "**Naive Approach**\\n->We start checking from the \\'lower\\' value and continue checking upto \\'upper\\' if they fulfil the condition of hidden sequence\\n-> If it is we simply increment the \\'count\\', otherwise we break that loop there\\n->Finally we return the value of \\'count\\'\\n\\n**TC: O(M*N)**, where M=upper-lower, and N=size of the difference vector\\n**SC: O(1),** as we don\\'t use any aus space here\\n\\n\\n```\\nint numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        int count=0;\\n\\t\\t\\n        for(int i=lower; i<=upper; i++){\\n            int curVal=i;  \\n            for(int j=diff.size()-1; j>=0; j--){\\n                int curDif=curVal-diff[j];\\n                if(curDif>=lower && curDif<=upper){  //we check if the current value satisfies the condition of hidden sequence\\n                    curVal=curDif;  //we change the \\'curVal\\' for the next iteration\\n                }else{\\n                    break;\\n                }\\n                \\n                if(j==0) count++;  //when thecurrent sequence is a valid hidden sequence j will beome 0 at the very end of the loop\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\n\\n**Approach-2: We Optimize the previous approach here**\\n->If you observe properly you can see- the first sequence that we get(may be valid or not) that one is linked to the number of hidden sequence we may have. Let\\'s see how-\\n->The difference of the (upper-maxVal) and (lower-minVal) and an addition of 1 gives us the number of hidden sequence we can achieve. You\\'ll get the logic when you dry run it atleast once and observe it properly.\\n\\n**TC: O(N)**, as we linearly traverse it\\n**SC: O(N),** as we store the first sequence in a vector\\n\\n\\n    int numberOfArrays(vector<int>& diff, int lower, int upper){\\n        vector<long> vec(diff.size()+1);  //a vector of size \\'n+1\\'\\n\\t\\t\\n\\t\\t//First create the first sequence (may be valid or may not)\\n        int k=vec.size()-1;\\n        vec[k--]=lower;\\n\\t\\t\\n        for(int i=diff.size()-1; i>=0; i--){\\n            vec[k]=vec[k+1]-diff[i];\\n            k--;\\n        }\\n        \\n\\t\\t//Now, find out the minimum and maximum value from there\\n        long maxVal=INT_MIN, minVal=INT_MAX;\\n        \\n        for(int i=0; i<vec.size(); i++){\\n            if(vec[i]<minVal) minVal=vec[i];\\n            if(vec[i]>maxVal) maxVal=vec[i];\\n        }\\n        \\n\\t\\t//Now, calculate the result value\\n        long ans=((long)upper-maxVal)-((long)lower-minVal)+1;\\n        \\n        if(ans>0) return ans;\\n        \\n        return 0;\\n    }\\n\\t\\n\\t\\n***Hope It Helps:)***\\n\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        int count=0;\\n\\t\\t\\n        for(int i=lower; i<=upper; i++){\\n            int curVal=i;  \\n            for(int j=diff.size()-1; j>=0; j--){\\n                int curDif=curVal-diff[j];\\n                if(curDif>=lower && curDif<=upper){  //we check if the current value satisfies the condition of hidden sequence\\n                    curVal=curDif;  //we change the \\'curVal\\' for the next iteration\\n                }else{\\n                    break;\\n                }\\n                \\n                if(j==0) count++;  //when thecurrent sequence is a valid hidden sequence j will beome 0 at the very end of the loop\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709719,
                "title": "c-easy-solution-with-inline-explaination-o-n",
                "content": "```\\nint numberOfArrays(vector<int>& d, int lower, int upper) {\\n        long long peak=0, vally=0, cur=0;\\n        for(int i=0;i<d.size();i++){      //peak- highest number , vally- lowest number -->relative to zero \\n            cur+=d[i];                    //cur-  current position\\n            vally=min(vally,cur); peak=max(peak,cur);\\n        }\\n        long long d1= peak-vally, d2=upper-lower, ans=0;\\n        if(peak==vally) d1=abs(peak);      //if no difference in vally and peak\\n        if(d1<=d2) ans= 1 + d2 - d1;       // for different values in given range\\n        return ans;\\n    }\\n```\\n\\nUpvote if you appreciate ;)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numberOfArrays(vector<int>& d, int lower, int upper) {\\n        long long peak=0, vally=0, cur=0;\\n        for(int i=0;i<d.size();i++){      //peak- highest number , vally- lowest number -->relative to zero \\n            cur+=d[i];                    //cur-  current position\\n            vally=min(vally,cur); peak=max(peak,cur);\\n        }\\n        long long d1= peak-vally, d2=upper-lower, ans=0;\\n        if(peak==vally) d1=abs(peak);      //if no difference in vally and peak\\n        if(d1<=d2) ans= 1 + d2 - d1;       // for different values in given range\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709666,
                "title": "o-n-time-o-1-space-java-solution",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int min=Integer.MAX_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        int num=lower;\\n        for(int i=0;i<differences.length;i++){\\n            if(num<min){\\n                min=num;\\n            }\\n            if(num>max){\\n                max=num;\\n            }\\n             num+=differences[i];\\n        }\\n         if(num<min){\\n                min=num;\\n            }\\n            if(num>max){\\n                max=num;\\n            }\\n        int count=0;\\n        while(max<=upper){\\n            if(min>=lower && max<=upper){\\n                count++;\\n            }\\n            min++;\\n            max++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int min=Integer.MAX_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        int num=lower;\\n        for(int i=0;i<differences.length;i++){\\n            if(num<min){\\n                min=num;\\n            }\\n            if(num>max){\\n                max=num;\\n            }\\n             num+=differences[i];\\n        }\\n         if(num<min){\\n                min=num;\\n            }\\n            if(num>max){\\n                max=num;\\n            }\\n        int count=0;\\n        while(max<=upper){\\n            if(min>=lower && max<=upper){\\n                count++;\\n            }\\n            min++;\\n            max++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160969,
                "title": "time95-spce99-99-beats-o-n-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& nums, long long int a, long long int b) {\\n       long long int l = a,r = b;\\n       long long int sum = 0;\\n       for(auto &i: nums){\\n           sum += i;\\n           l = max(l,a-sum);\\n           r = min(r,b-sum);\\n       }\\n        return max(r-l+1,0LL);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& nums, long long int a, long long int b) {\\n       long long int l = a,r = b;\\n       long long int sum = 0;\\n       for(auto &i: nums){\\n           sum += i;\\n           l = max(l,a-sum);\\n           r = min(r,b-sum);\\n       }\\n        return max(r-l+1,0LL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713582,
                "title": "java-kotlin-python-intuitive-illustrations-graph-within-the-lower-and-upper-limits",
                "content": "# Explanation\\nTo see graphically the problem : how many series/sequences can be included withing these lower and upper limits.\\n\\n## Example\\nInput: \\ndifferences = [3,-4,5,1,-2], lower = -4, upper = 5\\nOutput: 4\\n\\nWe are interested in computing the accumulated sum of differences. Assume `accSum` is initialized to 0, we add each element of the array one by one.\\n3 = 3  + 3\\n-1 = 3 -4\\n4 = -1 + 5 \\n5 = 4  + 1\\n3 = 5-2\\n\\n**And the  accumulated sum of differences = [3,-1,4,5,3]**\\n\\nThe sequence starts at (0,0).\\n![image](https://assets.leetcode.com/users/images/33ca4e29-3f73-4928-8d77-cfc05d53a8fc_1642956803.1879742.png)\\n\\nWe are interested about the minimum and maximum of the sum.\\nIn order to determine whether the number of sequences that will fit inside the lower and upper limits.\\n\\n![image](https://assets.leetcode.com/users/images/7ed072f2-c645-4956-983f-643bfd08aaaa_1642956618.7133608.png)\\n\\n**How to calculate the number of sequences inside the horizontal limits ?**\\n\\nI brute forced [during the contest](https://leetcode.com/contest/biweekly-contest-70/problems/count-the-hidden-sequences/)   and got the [answer thanks to Lee215](https://leetcode.com/problems/count-the-hidden-sequences/discuss/1709755/JavaC%2B%2BPython-Straight-Forward-Solution-with-Explantion).\\n\\nIntuitively, it is the difference of upper and lower limit  malus the difference of maxSum and minSum. \\nAdd + 1 . Why ? Because imagine if the upper, lower limits  are equals and the only sequence is inside the limits.\\n\\n# Codes\\nTime complexity : O(n)\\nSpace complexity: O(1)\\n\\nNote: there is an edge case going over the `Integer` range, we have to use `Long` type.\\n\\n## Java\\n\\n```\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long  accSum = 0;\\n        long  maxSum = 0;\\n        long  minSum = 0;\\n        for (int d : differences) {\\n            accSum += d;\\n            maxSum = Math.max(maxSum, accSum);\\n            minSum = Math.min(minSum, accSum);\\n        }\\n        return (int) Math.max(0, (upper - lower) - (maxSum - minSum) + 1);\\n    }\\n```\\n\\n## Kotlin\\n\\n```\\n    fun numberOfArrays(differences: IntArray, lower: Int, upper: Int): Int {\\n        var accSum = 0L\\n        var minSum = 0L\\n        var maxSum = 0L\\n        \\n        for(diff in differences){\\n            accSum += diff\\n            minSum = minOf(accSum , minSum)\\n            maxSum = maxOf(accSum, maxSum)\\n        }\\n        \\n        return maxOf(0, (upper- lower) - (maxSum - minSum) +1).toInt()\\n    }\\n```\\n\\n## Python 3\\n```\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        accSum = 0\\n        minSum = 0\\n        maxSum = 0\\n        for d in differences:\\n            accSum += d\\n            minSum = min(minSum, accSum)\\n            maxSum = max(maxSum, accSum)\\n        \\n        return max(0, (upper - lower) - (maxSum - minSum) + 1)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Kotlin"
                ],
                "code": "```\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long  accSum = 0;\\n        long  maxSum = 0;\\n        long  minSum = 0;\\n        for (int d : differences) {\\n            accSum += d;\\n            maxSum = Math.max(maxSum, accSum);\\n            minSum = Math.min(minSum, accSum);\\n        }\\n        return (int) Math.max(0, (upper - lower) - (maxSum - minSum) + 1);\\n    }\\n```\n```\\n    fun numberOfArrays(differences: IntArray, lower: Int, upper: Int): Int {\\n        var accSum = 0L\\n        var minSum = 0L\\n        var maxSum = 0L\\n        \\n        for(diff in differences){\\n            accSum += diff\\n            minSum = minOf(accSum , minSum)\\n            maxSum = maxOf(accSum, maxSum)\\n        }\\n        \\n        return maxOf(0, (upper- lower) - (maxSum - minSum) +1).toInt()\\n    }\\n```\n```\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        accSum = 0\\n        minSum = 0\\n        maxSum = 0\\n        for d in differences:\\n            accSum += d\\n            minSum = min(minSum, accSum)\\n            maxSum = max(maxSum, accSum)\\n        \\n        return max(0, (upper - lower) - (maxSum - minSum) + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1710505,
                "title": "java-python-o-n-solution-with-explanation-and-comments",
                "content": "Consider the following test case:\\n```\\ndifferences = [3,-4,5,1,-2]\\nlower = -4\\nupper = 5\\n```\\nLet us start with some guess work.\\nThe maximum value that we can have is 5. \\n\\n**So let us start with 5.**\\n* First Number = 5 + 3 which is greater than the upper limit. So we reject this start.\\n\\n**Now, let us start with 4.**\\n* First Number = 4 + 3 which is again greater than the upper limit. So we reject this as well.\\n\\n**Let\\'s move on to 3**\\n* First Number = 3 + 3 which, once again, is greater than upper limit.\\n\\n**Now, let\\'s try with 2**\\n* First Number = 2 + 3 = 5 which is allowed.\\n* Second Number = 5 - 4 = 1. ALLOWED\\n* Third Number = 1 + 5 = 6. NOT ALLOWED\\n\\n**Starting with 1**\\n* First Number = 1 + 3 = 4. ALLOWED.\\n* Second Number = 4 - 4 = 0. ALLOWED\\n* Third Number = 0 + 5 = 5. ALLOWED\\n* Fourth Number = 5 + 1 = 6. NOT ALLOWED\\n\\n**Starting with 0**\\n* First Number = 0 + 3 = 3. ALLOWED.\\n* Second Number = 3 - 4 = -1. ALLOWED\\n* Third Number = -1 + 5 = 4. ALLOWED\\n* Fourth Number = 4 + 1 = 5. ALLOWED\\n* Fifth Number = 5 - 2 = 3. ALLOWED\\n\\nNow, if we start with 0, or any number less than 0, it is quite evident that it will not cross the upper limit because 0 is the maximum value at which, the upper limit boundary is not violated.\\nSo 0 can be the maximum value of the element we can start with.\\nNow, we need a smarter way to get this value in order to satisfy time constraints.\\n\\nNotice the `difference = [3,-4,5,1,-2]` array: What is the maximum increment that we can have?\\n\\nLet max = 0 initially.\\n* First increment is 3. So 3 > max : max = 3\\n* Next we have -4. So 3 - 4 = -1 which is not greater than max.\\n* Next we have 5. So -1 + 5 = 4 > max, i.e. it is currently the maximum increment possible. So max = 4.\\n* Next we have 1. So 4 + 1 = 5 > max, i.e. it is currently the maximum increment possible. So max = 5.\\n* Next we have -2. So 5 - 2 = 3 which is not greater than max.\\n\\nNotice that the maximum increment possible on the starting value is 5. So, the maximum start value allowed has to be `upper - max`\\n\\nOn the similar lines, we can check for the minimum starting value. You can skip to the code if you\\'re satisfied with the above explanation.\\nThe minimum value that we can have is -4. \\n\\n**So let us start with -4.**\\n* First Number = -4 + 3 = -1. ALLOWED\\n* Second Number = -1 - 4 = -5. NOT ALLOWED\\n\\n**Now, let us start with -3.**\\n* First Number = -3 + 3 = 0. ALLOWED\\n* Second Number = 0 - 4 = -4. ALLOWED\\n* Third Number = -4 + 5 = 1. ALLOWED\\n* Fourth Number = 1 + 1 = 2. ALLOWED\\n* Fift Number = 2 - 2 = 0. ALLOWED\\n\\nNow, if we start with -3, or any number greater than -3, it is quite evident that it will not cross the lower limit because -3 is the minimum value at which, the lower limit boundary is not violated.\\n\\n**So -3 can be the minimum value of the element we can start with.**\\n\\nUsing the same logic to find `min` that was used to find `max`\\n\\nLet min = 0 initially.\\n* First increment is 3 and 3 is not less than min\\n* Next we have -4. So 3 - 4 = -1 < min, i.e. it is currently the biggest decrement possible.  So min = -1.\\n* Next we have 5. So -1 + 5 = 4, which is not less than min\\n* Next we have 1. So 4 + 1 = 5 which is not less than min\\n* Next we have -2. So 5 - 2 = 3 which is not less than min.\\n\\nNotice that the biggest decrement possible on the starting value is -1. So, the minimum start value allowed has to be `lower - min`\\n\\nNow, total possibilities for the above example -\\n* Start with -3\\n* Start with -2\\n* Start with -1\\n* Start with 0\\n\\n`Number of possibilities = 4 = (Maximum Start - Minimum Start) + 1 = ((upper - max) - (lower - min)) + 1`\\n\\nNote that there might be a case where no start value will satisfy the given constraints. It will happen when `min` is less than `lower` and `max` is greater than `upper`.\\nIn that case, `upper - max` is negative, `lower - min` is negative. So `((upper - max) - (lower - min)) + 1` is negative or zero. In such case, we return 0.\\n\\nNow, let\\'s have a look at the program for the same:\\n\\n**Java**\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n\\t\\t// Largest Increment\\n        long maxAdd = 0;\\n\\t\\t\\n\\t\\t// Largest Decrement\\n        long minSub = 0;\\n\\t\\t\\n\\t\\t// Current Difference\\n        long currDiff = 0;\\n\\t\\t\\n\\t\\t// Calculating above values in this loop\\n        for (int i = 0; i < differences.length; i++) {\\n            currDiff += (long)differences[i];\\n\\t\\t\\t\\n\\t\\t\\t// We need largest increment, so we choose the maximum value\\n            maxAdd = (long)Math.max(currDiff, maxAdd);\\n\\t\\t\\t\\n\\t\\t\\t// We need largest decrement, so we choose the minimum value\\n            minSub = (long)Math.min(currDiff, minSub);\\n        }\\n        \\n\\t\\t// Return 0 if value of the equation is negative\\n        return (int)Math.max(0, (upper - maxAdd) - (lower - minSub) + 1);\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n\\t\\t# Largest Increment\\n        maxAdd = 0;\\n\\t\\t\\n\\t\\t# Largest Decrement\\n        minSub = 0;\\n\\t\\t\\n\\t\\t# Current Difference\\n        currDiff = 0;\\n\\t\\t\\n\\t\\t# Calculating above values in this loop\\n        for i in range(len(differences)):\\n            currDiff += differences[i]\\n\\t\\t\\t\\n\\t\\t\\t# We need largest increment, so we choose the maximum value\\n            maxAdd = max(currDiff, maxAdd)\\n\\t\\t\\t\\n\\t\\t\\t# We need largest decrement, so we choose the minimum value\\n            minSub = min(currDiff, minSub)\\n        \\n\\t\\t# Return 0 if value of the equation is negative\\n        return max(0, (upper - maxAdd) - (lower - minSub) + 1);\\n        \\n```\\n*This is my first post on Leetcode. Do give a thumbs up if this helps you!*\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\ndifferences = [3,-4,5,1,-2]\\nlower = -4\\nupper = 5\\n```\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n\\t\\t// Largest Increment\\n        long maxAdd = 0;\\n\\t\\t\\n\\t\\t// Largest Decrement\\n        long minSub = 0;\\n\\t\\t\\n\\t\\t// Current Difference\\n        long currDiff = 0;\\n\\t\\t\\n\\t\\t// Calculating above values in this loop\\n        for (int i = 0; i < differences.length; i++) {\\n            currDiff += (long)differences[i];\\n\\t\\t\\t\\n\\t\\t\\t// We need largest increment, so we choose the maximum value\\n            maxAdd = (long)Math.max(currDiff, maxAdd);\\n\\t\\t\\t\\n\\t\\t\\t// We need largest decrement, so we choose the minimum value\\n            minSub = (long)Math.min(currDiff, minSub);\\n        }\\n        \\n\\t\\t// Return 0 if value of the equation is negative\\n        return (int)Math.max(0, (upper - maxAdd) - (lower - minSub) + 1);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n\\t\\t# Largest Increment\\n        maxAdd = 0;\\n\\t\\t\\n\\t\\t# Largest Decrement\\n        minSub = 0;\\n\\t\\t\\n\\t\\t# Current Difference\\n        currDiff = 0;\\n\\t\\t\\n\\t\\t# Calculating above values in this loop\\n        for i in range(len(differences)):\\n            currDiff += differences[i]\\n\\t\\t\\t\\n\\t\\t\\t# We need largest increment, so we choose the maximum value\\n            maxAdd = max(currDiff, maxAdd)\\n\\t\\t\\t\\n\\t\\t\\t# We need largest decrement, so we choose the minimum value\\n            minSub = min(currDiff, minSub)\\n        \\n\\t\\t# Return 0 if value of the equation is negative\\n        return max(0, (upper - maxAdd) - (lower - minSub) + 1);\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710243,
                "title": "java-simple-mapping-given-difference-easy-to-understand-o-n",
                "content": "We just have to map the result maximum and minimum difference and the given lower and upper difference.\\nExplanation:\\n\\t1. Find the maximum and minimum from the difference\\n\\t2. Calculate the result difference as maximum - minimum\\n\\t3. Calculate the original difference as upper - lower\\n\\t4. Since both are inclusive add +1 to it\\n\\t5. If the original difference + 1 is greater than result difference then return the result\\n\\n```\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long current = 0, min = 0, max = 0;\\n        int res = 0;\\n        for(int one : differences){\\n        \\tcurrent = current + one;\\n        \\tmin = Math.min(current, min);\\n        \\tmax = Math.max(current, max);\\n        }\\n        int resultdiff = (int) (max - min);\\n        int originaldiff = upper - lower;\\n        if(originaldiff-resultdiff+1>0)\\n        \\tres = originaldiff-resultdiff+1;\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "We just have to map the result maximum and minimum difference and the given lower and upper difference.\\nExplanation:\\n\\t1. Find the maximum and minimum from the difference\\n\\t2. Calculate the result difference as maximum - minimum\\n\\t3. Calculate the original difference as upper - lower\\n\\t4. Since both are inclusive add +1 to it\\n\\t5. If the original difference + 1 is greater than result difference then return the result\\n\\n```\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long current = 0, min = 0, max = 0;\\n        int res = 0;\\n        for(int one : differences){\\n        \\tcurrent = current + one;\\n        \\tmin = Math.min(current, min);\\n        \\tmax = Math.max(current, max);\\n        }\\n        int resultdiff = (int) (max - min);\\n        int originaldiff = upper - lower;\\n        if(originaldiff-resultdiff+1>0)\\n        \\tres = originaldiff-resultdiff+1;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1710045,
                "title": "maths-based-solution-solving-n-inequalities-interval-o-n",
                "content": "Let\\'s say the starting value `h0`, then what is `h1` going to be? It will be `diff0 + h0`. Following the same pattern:\\n\\n- `h1` = `diff0 + h0`\\n- `h2` = `diff0 + diff1 + h0`\\n- `h3` = `diff0 + diff1 + diff2 + h0`\\n.\\n.\\n.\\nNow we know that each of these elements must be within bound `lower` and `higher`, so let\\'s apply those as well\\n- `lower` <= `h0` <= `higher` and \\n- `lower` <= `diff0 + h0` <= `higher` and\\n-  `lower` <= `diff0 + diff1 + h0` <= `higher`\\n.\\n.\\n.\\nNote that we have known values of all elements, what we have to do is just solve these inequality w.r.t `h0`. In other words there are n+1 intervals and we have to find intersection of those intervals. Let\\'s say the resulting interval is [a, b] then the result wil be this\\n- b-a+1 if b>=a\\n- 0 otherwise.\\n\\n```\\nclass Solution:\\n    def numberOfArrays(self, diff: List[int], l: int, u: int) -> int:\\n        ls = []\\n        ls.append(diff[0])\\n        for ele in diff[1:]:\\n            ls.append(ele+ls[-1])\\n        \\n        a = l\\n        b = u\\n        for ele in ls:\\n            a = max(a, l-ele)\\n            b = min(b, u-ele)\\n        \\n        if b<a:\\n            return 0\\n        \\n        return b-a+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, diff: List[int], l: int, u: int) -> int:\\n        ls = []\\n        ls.append(diff[0])\\n        for ele in diff[1:]:\\n            ls.append(ele+ls[-1])\\n        \\n        a = l\\n        b = u\\n        for ele in ls:\\n            a = max(a, l-ele)\\n            b = min(b, u-ele)\\n        \\n        if b<a:\\n            return 0\\n        \\n        return b-a+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709924,
                "title": "c-o-n-solution",
                "content": "```\\nint numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long m1,m2;\\n        vector<long long> vec;\\n        if(differences.size()==1){\\n            if(upper-lower>=differences[0]) return upper - lower -abs(differences[0]) +1;\\n            else return 0;\\n        }\\n        vec.push_back(0);\\n        vec.push_back(differences[0]);\\n        for(int i=1;i<differences.size();i++){\\n            vec.push_back(vec[vec.size()-1]+differences[i]);\\n        }\\n\\n        m1=*max_element(vec.begin(),vec.end());\\n        m2=*min_element(vec.begin(),vec.end());\\n        long long ans=(upper-lower)-(m1-m2)+1;\\n        if(ans<0) ans=0;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nint numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long m1,m2;\\n        vector<long long> vec;\\n        if(differences.size()==1){\\n            if(upper-lower>=differences[0]) return upper - lower -abs(differences[0]) +1;\\n            else return 0;\\n        }\\n        vec.push_back(0);\\n        vec.push_back(differences[0]);\\n        for(int i=1;i<differences.size();i++){\\n            vec.push_back(vec[vec.size()-1]+differences[i]);\\n        }\\n\\n        m1=*max_element(vec.begin(),vec.end());\\n        m2=*min_element(vec.begin(),vec.end());\\n        long long ans=(upper-lower)-(m1-m2)+1;\\n        if(ans<0) ans=0;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709787,
                "title": "java-easy-straight-forward-prefix-sum",
                "content": "**Idea**\\n\\nThe basic idea is to first calculate the max/min value of the hidden array is the first item was \\n\\nThen we can simply check with various possible starting values in the range [lower,upper].\\n \\nIf the max and min remain in range with a particular chosen value, we add it to the number of possible solutions.\\n\\n````\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        \\n        int min=differences[0],max=differences[0];\\n        for(int i=1;i<differences.length;i++)\\n        {\\n        \\tmin=Math.min(min, differences[i-1]+differences[i]);\\n        \\tmax=Math.max(max, differences[i-1]+differences[i]);\\n        \\tdifferences[i]+=differences[i-1];\\n        }\\n        int a=upper-max;\\n        int b=lower-min;\\n        a=Math.min(a,upper);\\n        b=Math.max(b,lower);\\n        if(a-b+1<0)\\n            return 0;\\n        return (int)(a-b+1);\\n    }\\n}\\n````\\n\\n**Please Upvote if you get it :))**",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        \\n        int min=differences[0],max=differences[0];\\n        for(int i=1;i<differences.length;i++)\\n        {\\n        \\tmin=Math.min(min, differences[i-1]+differences[i]);\\n        \\tmax=Math.max(max, differences[i-1]+differences[i]);\\n        \\tdifferences[i]+=differences[i-1];\\n        }\\n        int a=upper-max;\\n        int b=lower-min;\\n        a=Math.min(a,upper);\\n        b=Math.max(b,lower);\\n        if(a-b+1<0)\\n            return 0;\\n        return (int)(a-b+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709777,
                "title": "lienear-javascript-solution-explained",
                "content": "First of all we need to find any sequence. Let start from 0 and apply all the operations.\\nThen let adkust our sequence to the lowwer limit. So the minimum element of our sequence = lower limit.\\nNow the anser would be equal to \"Upper Limit\" - \"Adjusted Max of our sequence\".\\nIf the answer <= 0 there are now possible sequences.\\n```\\nvar numberOfArrays = function(differences, lower, upper) {\\n    let dp = new Array(differences.length+1)\\n    \\n    dp[0] = 0\\n    let min = dp[0]\\n    let max = dp[0]\\n    for(let i = 1; i <= differences.length; i++){\\n        dp[i] = dp[i-1] + differences[i-1]\\n        min = Math.min(dp[i], min)\\n        max = Math.max(dp[i], max)\\n    }\\n    \\n    let shift = min - lower\\n    max = max - shift\\n    \\n    let count = upper - max + 1\\n    if(count <= 0){\\n        return 0\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar numberOfArrays = function(differences, lower, upper) {\\n    let dp = new Array(differences.length+1)\\n    \\n    dp[0] = 0\\n    let min = dp[0]\\n    let max = dp[0]\\n    for(let i = 1; i <= differences.length; i++){\\n        dp[i] = dp[i-1] + differences[i-1]\\n        min = Math.min(dp[i], min)\\n        max = Math.max(dp[i], max)\\n    }\\n    \\n    let shift = min - lower\\n    max = max - shift\\n    \\n    let count = upper - max + 1\\n    if(count <= 0){\\n        return 0\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1714168,
                "title": "c-single-pass-solution-explained-92ms-107-2mb",
                "content": "This is a nice cute one that forces people to think a bit more than just recalling algos by rote memorisation.\\n\\nMy intuition was at it follows:\\n* a quick look at the constraints made crystal clear that actually building the arrays was not an option, unless you really love to be slapped down by TLE messages;\\n* following the differences we might get from the starting value, we can go on and compute a cumulative \"oscillation\" around the first value, with a minimum and a maximum;\\n* that information will be precious to us in order to know how much range we can have for each possible array.\\n\\nLet\\'s assume for example that we have the initial test case of `{1,-3,4}`, which in turn would translate into a \"base\" array like `0,1,-2,2`, which has `-2` and `2` respectively as minimum and maximum.\\n\\nAnd this is important information: if we know for example that the maximum value we can get is `6`, it means we cannot start with any value `> 4` (given that the maximum oscillation is `+2`, as found above); similarly, knowing that our minimum is `1`, we know that with a minimum oscillation of `-2`, no value `< 3` would work.\\n\\nNow that we just found our upper (`4`) and lower (`3`) limit, we can easily figure out how many valid array we can get that way, by simply subtracting the upper to the minimum value, `+ 1`, since both extremes are to be included.\\n\\nLet\\'s turn all of this into code, shall we?\\n\\nFirst of all, support variables:\\n* `minV`, `maxVal` and `curr` will store the minimum value we found so far, the maximum and the current oscillation - all of them `long` to avoid overflows (look at the constraints!) and all of them initialised to `0`;\\n* `res` will be where we store our result before returning it for one last check.\\n\\nTime now to parse `d` and for each value `n` of it, we will;\\n* add `n` to `curr`;\\n* update `minV` to the the minimum between its current value and `curr`;\\n* update `maxV` to the the maximum between its current value and `curr`.\\n\\nWe can now compute `res` as explained above: `upper - maxV - (lower - minV) + 1`; one final check to be made is if this value is negative, in which case we can just `return` `0`; if not, we will `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& d, int lower, int upper) {\\n        // support variables\\n        long minV = 0, maxV = 0, curr = 0;\\n        int res = 0;\\n        // getting the absolute minimum and maximum distance from the starting element\\n        for (int n: d) {\\n            curr += n;\\n            minV = min(minV, curr);\\n            maxV = max(maxV, curr);\\n        }\\n        // computing res\\n        res = upper - maxV - (lower - minV) + 1;\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```\\n\\nThe last two lines can actually be merged, sparing us a variable declaration (but not necessarily a great idea during an interview), like this:\\n\\n```cpp\\n        // computing the result\\n        return max(0, upper - maxV - (lower - minV) + 1);\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& d, int lower, int upper) {\\n        // support variables\\n        long minV = 0, maxV = 0, curr = 0;\\n        int res = 0;\\n        // getting the absolute minimum and maximum distance from the starting element\\n        for (int n: d) {\\n            curr += n;\\n            minV = min(minV, curr);\\n            maxV = max(maxV, curr);\\n        }\\n        // computing res\\n        res = upper - maxV - (lower - minV) + 1;\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```\n```cpp\\n        // computing the result\\n        return max(0, upper - maxV - (lower - minV) + 1);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712464,
                "title": "binary-search-c",
                "content": "**Intution :**\\n* Find the **lowest** value  which is in range and satisifies the given  array **differences**.\\n* Similarly, find the **greatest** value which is in range and satisifies the given  array **differences**.\\n* return **greatest** - **lowest** + **1**;\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    \\n   int search(vector<int>& d, int lower,int higher,bool move_left){\\n        \\n\\t\\tint ans = INT_MIN;\\n\\t\\tint n = d.size();\\n\\t\\tint low = lower,high = higher;\\n\\n              while(low<=high){\\n                    int mid = (low + high)/2;\\n\\t\\t\\t\\t\\tint curr = mid;\\n                    \\n\\t\\t\\t\\t\\t  for(int i=0;i<n;i++){\\n                            curr+= d[i];\\n                         if(curr<lower||curr>higher)\\n                             break;\\n                     }\\n                \\n                if(curr < lower)\\n                  low = mid + 1;\\n                else if(curr>higher)\\n                    high = mid-1;\\n                else {\\n                    ans = mid;\\n                   \\n                    if(move_left)\\n                        high = mid-1;\\n                    else\\n                        low = mid +1;\\n                }    \\n          }\\n        \\n         return ans;\\n    }\\n    \\n    \\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n       int start = search(differences,lower,upper, true);// searching the lowest value ,here move_left is true because we finding lowest value.\\n       int end =   search(differences,lower,upper,false);//searching the greatest value ,here move_left is false because we finding greatest value.\\n\\t\\t\\n         if(start == INT_MIN || end== INT_MIN)\\n            return 0;\\n        \\n        return end - start+1;     \\n    }\\n};\\n```\\n\\n**Time Complexity :  O(nlogn) where n  = upper - lower + 1**\\n**Space Complexity: O(1)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   int search(vector<int>& d, int lower,int higher,bool move_left){\\n        \\n\\t\\tint ans = INT_MIN;\\n\\t\\tint n = d.size();\\n\\t\\tint low = lower,high = higher;\\n\\n              while(low<=high){\\n                    int mid = (low + high)/2;\\n\\t\\t\\t\\t\\tint curr = mid;\\n                    \\n\\t\\t\\t\\t\\t  for(int i=0;i<n;i++){\\n                            curr+= d[i];\\n                         if(curr<lower||curr>higher)\\n                             break;\\n                     }\\n                \\n                if(curr < lower)\\n                  low = mid + 1;\\n                else if(curr>higher)\\n                    high = mid-1;\\n                else {\\n                    ans = mid;\\n                   \\n                    if(move_left)\\n                        high = mid-1;\\n                    else\\n                        low = mid +1;\\n                }    \\n          }\\n        \\n         return ans;\\n    }\\n    \\n    \\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n       int start = search(differences,lower,upper, true);// searching the lowest value ,here move_left is true because we finding lowest value.\\n       int end =   search(differences,lower,upper,false);//searching the greatest value ,here move_left is false because we finding greatest value.\\n\\t\\t\\n         if(start == INT_MIN || end== INT_MIN)\\n            return 0;\\n        \\n        return end - start+1;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712126,
                "title": "javascript-faster-than-100",
                "content": "```\\nvar numberOfArrays = function(differences, lower, upper) {\\n    let temp = 0;\\n    let res = 0;\\n    let n = lower;\\n    \\n    for (let i = 0; i < differences.length; i++) {\\n        temp += differences[i];\\n        differences[i] = temp;\\n    }\\n    \\n    const min = Math.min(...differences);\\n    const max = Math.max(...differences);\\n    \\n    while (n <= upper) {\\n        if (n + min >= lower && n + max <= upper) res++;\\n        n++;\\n    }\\n    return res;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfArrays = function(differences, lower, upper) {\\n    let temp = 0;\\n    let res = 0;\\n    let n = lower;\\n    \\n    for (let i = 0; i < differences.length; i++) {\\n        temp += differences[i];\\n        differences[i] = temp;\\n    }\\n    \\n    const min = Math.min(...differences);\\n    const max = Math.max(...differences);\\n    \\n    while (n <= upper) {\\n        if (n + min >= lower && n + max <= upper) res++;\\n        n++;\\n    }\\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1710121,
                "title": "java-one-loop",
                "content": "Recreate the original array hypothetically starting with first element=0. \\nKeep track of min and max. At the end calculate the range (max-min) and compare it with the range given as the input (upper-lower).\\nIf the actual range is greater - we have no solutions; if they\\'re equal, we can only have 1 solution; if the input range is greater, we can fit multiple solutions in the input range.\\n```\\npublic int numberOfArrays(int[] diff, int lower, int upper) {\\n\\tlong val= 0, min= 0, max= 0;\\n\\tint n= diff.length;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tval+= diff[i];\\n\\t\\tmin= Math.min(min, val);\\n\\t\\tmax= Math.max(max, val);\\n\\t}\\n\\tint count= (int)((upper-lower) - (max-min));\\n\\treturn count<0 ? 0 : count+1;            \\n}",
                "solutionTags": [],
                "code": "Recreate the original array hypothetically starting with first element=0. \\nKeep track of min and max. At the end calculate the range (max-min) and compare it with the range given as the input (upper-lower).\\nIf the actual range is greater - we have no solutions; if they\\'re equal, we can only have 1 solution; if the input range is greater, we can fit multiple solutions in the input range.\\n```\\npublic int numberOfArrays(int[] diff, int lower, int upper) {\\n\\tlong val= 0, min= 0, max= 0;\\n\\tint n= diff.length;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tval+= diff[i];\\n\\t\\tmin= Math.min(min, val);\\n\\t\\tmax= Math.max(max, val);\\n\\t}\\n\\tint count= (int)((upper-lower) - (max-min));\\n\\treturn count<0 ? 0 : count+1;            \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1710019,
                "title": "c-easy-solution-100-faster",
                "content": "**Time Complexity : O(n)\\nSpace Complexity : O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long count = 0, mx = 0, mi =0;\\n        for(int i = 0; i<differences.size(); i++){\\n            count+= differences[i];\\n            mx = max(mx,count);\\n            mi = min(mi,count);\\n        }\\n        return max(0L, (upper - lower) - (mx - mi) + 1);\\n    }\\n};\\n```\\n\\n# Approach\\n![image](https://assets.leetcode.com/users/images/61e759ed-dfe6-4af6-b8df-56cf3c41bcd6_1642880475.0242302.png)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long count = 0, mx = 0, mi =0;\\n        for(int i = 0; i<differences.size(); i++){\\n            count+= differences[i];\\n            mx = max(mx,count);\\n            mi = min(mi,count);\\n        }\\n        return max(0L, (upper - lower) - (mx - mi) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709786,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n       \\n        int n = differences.length;\\n        int[] firstSeq = new int[n+1];\\n        firstSeq[n] = upper;\\n        \\n        int max = upper;\\n        for(int i = n-1; i >= 0; i--){\\n            firstSeq[i] = firstSeq[i+1] - differences[i];\\n            max = Math.max(max,firstSeq[i]);\\n        }\\n        \\n        int diff = max - upper;\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < firstSeq.length; i++){\\n             firstSeq[i] -= diff;\\n             min = Math.min(min,firstSeq[i]);\\n        }\\n        \\n        if(min < lower) return 0;\\n        \\n        int ans = 1;\\n        ans += (min - lower);\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n       \\n        int n = differences.length;\\n        int[] firstSeq = new int[n+1];\\n        firstSeq[n] = upper;\\n        \\n        int max = upper;\\n        for(int i = n-1; i >= 0; i--){\\n            firstSeq[i] = firstSeq[i+1] - differences[i];\\n            max = Math.max(max,firstSeq[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1709778,
                "title": "simple-java-solution-move-window-in-larger-range",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long lowest = 0, highest =0;\\n        long prev = 0, current = 0;\\n        for(int diff: differences){\\n            //diff = current - prev;\\n            current = diff+prev;\\n            prev = current;\\n            lowest = Math.min(lowest, current);\\n            highest = Math.max(highest, current);\\n        }\\n        long range = upper - lower + 1;\\n        return (int)Math.max(0, range-(highest-lowest));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long lowest = 0, highest =0;\\n        long prev = 0, current = 0;\\n        for(int diff: differences){\\n            //diff = current - prev;\\n            current = diff+prev;\\n            prev = current;\\n            lowest = Math.min(lowest, current);\\n            highest = Math.max(highest, current);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1709737,
                "title": "java-simple-o-n-time-o-1-space-one-pass",
                "content": "Suppose the first num is 0, then passing the array we can get the absolute value of each value, record min and max, moving the range [min, max] inside [lower, upper] is like adding a offset for our first num 0.\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min = 0; long max = 0;\\n        long prev = 0;\\n        for(int i = 0; i < differences.length; i++) {\\n            prev += differences[i];\\n            min = Math.min(min, prev);\\n            max = Math.max(max, prev);\\n        }\\n        long res = upper-lower-(max-min);\\n        return res < 0? 0: (int) (res+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min = 0; long max = 0;\\n        long prev = 0;\\n        for(int i = 0; i < differences.length; i++) {\\n            prev += differences[i];\\n            min = Math.min(min, prev);\\n            max = Math.max(max, prev);\\n        }\\n        long res = upper-lower-(max-min);\\n        return res < 0? 0: (int) (res+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709705,
                "title": "short-python-solution",
                "content": "```\\nm = n = s = 0\\nfor d in differences:\\n\\ts += d\\n\\tm, n = max(m, s), min(n, s)\\nreturn max(0, upper - lower + n - m + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nm = n = s = 0\\nfor d in differences:\\n\\ts += d\\n\\tm, n = max(m, s), min(n, s)\\nreturn max(0, upper - lower + n - m + 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709694,
                "title": "python3-compare-range",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8fc8469e823a229654fc858172dfa9383d805e39) for solutions of biweekly 70. \\n\\n**Intuition**\\nCompute the range of variation from `differences`. Compuare this range with allowed range `upper - lower`. If it is within this range, then a solutions exists i.e. `upper - lower - range` otherwise return 0. \\n\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prefix = mn = mx = 0 \\n        for x in differences: \\n            prefix += x\\n            mn = min(mn, prefix)\\n            mx = max(mx, prefix)\\n        return max(0, (upper-lower) - (mx-mn) + 1)\\n```\\n\\n**AofA**\\ntime complexity `O(N)`\\nspace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prefix = mn = mx = 0 \\n        for x in differences: \\n            prefix += x\\n            mn = min(mn, prefix)\\n            mx = max(mx, prefix)\\n        return max(0, (upper-lower) - (mx-mn) + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3680849,
                "title": "c-super-easy-clean-and-simple-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long mini = lower;\\n        long maxi = lower;\\n        long ele = lower;\\n        for(int i=0; i<differences.size(); i++){\\n            ele += differences[i];\\n            mini = min(mini,ele);\\n            maxi = max(maxi,ele);\\n        }\\n        int ans = (upper - lower) - (maxi - mini) + 1;\\n        return ans<0 ? 0: ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long mini = lower;\\n        long maxi = lower;\\n        long ele = lower;\\n        for(int i=0; i<differences.size(); i++){\\n            ele += differences[i];\\n            mini = min(mini,ele);\\n            maxi = max(maxi,ele);\\n        }\\n        int ans = (upper - lower) - (maxi - mini) + 1;\\n        return ans<0 ? 0: ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693818,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int maxElt = differences[0], minElt = differences[0];\\n        for(int i= 1; i < differences.size(); i++) {\\n            differences[i] += differences[i-1] ;\\n            maxElt = max(maxElt, differences[i]) ;\\n            minElt = min(minElt, differences[i]) ;\\n       \\n            if(maxElt > 200000 || minElt < -200000) \\n                return 0; \\n        }\\n        \\n        int count = 0 ;\\n        for(int n = lower ; n <= upper; n++) {\\n            if(n + minElt >= lower && n + maxElt <= upper)\\n                count++ ;\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int maxElt = differences[0], minElt = differences[0];\\n        for(int i= 1; i < differences.size(); i++) {\\n            differences[i] += differences[i-1] ;\\n            maxElt = max(maxElt, differences[i]) ;\\n            minElt = min(minElt, differences[i]) ;\\n       \\n            if(maxElt > 200000 || minElt < -200000) \\n                return 0; \\n        }\\n        \\n        int count = 0 ;\\n        for(int n = lower ; n <= upper; n++) {\\n            if(n + minElt >= lower && n + maxElt <= upper)\\n                count++ ;\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429348,
                "title": "c-prefixsum",
                "content": "class Solution {\\n# public:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int count=0;\\n        vector<long long>v;\\n        v.push_back(differences[0]);\\n       for(int i=1;i<differences.size();i++){\\n           v.push_back(v[i-1]+differences[i]);\\n       }\\n        sort(v.begin(),v.end());\\n        for(int i=lower;i<=upper;i++){\\n            if(i+v[0]>=lower && i+v[v.size()-1]<=upper){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n# public:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int count=0;\\n        vector<long long>v;\\n        v.push_back(differences[0]);\\n       for(int i=1;i<differences.size();i++){\\n           v.push_back(v[i-1]+differences[i]);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2279286,
                "title": "easiest-java-solution-with-one-pass",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int max = 0;\\n        int min = 0;\\n        \\n        int num = 0;\\n        \\n        for (final int diff : differences) {\\n            num += diff;\\n            max = Math.max(num, max);\\n            min = Math.min(num, min);\\n            \\n            if (max - min > upper - lower) {\\n                return 0;\\n            }\\n        }\\n        \\n        final int diff = max - min;\\n        \\n        return Math.max(0, upper - lower - diff + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int max = 0;\\n        int min = 0;\\n        \\n        int num = 0;\\n        \\n        for (final int diff : differences) {\\n            num += diff;\\n            max = Math.max(num, max);\\n            min = Math.min(num, min);\\n            \\n            if (max - min > upper - lower) {\\n                return 0;\\n            }\\n        }\\n        \\n        final int diff = max - min;\\n        \\n        return Math.max(0, upper - lower - diff + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237050,
                "title": "java-one-pass-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\n    //a,  a+diff[0],  a+diff[0]+diff[1]  and so on......\\n    //assume a=0\\n    public int numberOfArrays(int[] diff, int lower, int upper) \\n    {\\n        long prev=0;\\n        \\n        //min-->min number in series\\n        long min=0; \\n        \\n        \\n        //max--->max number in series\\n        long max=0;\\n        \\n        for(int i=0;i<diff.length;i++)\\n        {\\n            //curr number=prev number + diff[i]\\n            long curr=diff[i]+prev;\\n            prev=curr;\\n            \\n            min=Math.min(min,curr);\\n            max=Math.max(max,curr);\\n        }\\n        \\n        //op1 tells a\\'s lower bound\\n        long op1=lower-min;\\n        \\n        //op2 tells a\\'s upper bound\\n        long op2=upper-max;\\n        \\n        //upper bound- lower bound +1 =ans (if>0)\\n        \\n        return op2-op1+1>0?(int)(op2-op1+1):0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    //a,  a+diff[0],  a+diff[0]+diff[1]  and so on......\\n    //assume a=0\\n    public int numberOfArrays(int[] diff, int lower, int upper) \\n    {\\n        long prev=0;\\n        \\n        //min-->min number in series\\n        long min=0; \\n        \\n        \\n        //max--->max number in series\\n        long max=0;\\n        \\n        for(int i=0;i<diff.length;i++)\\n        {\\n            //curr number=prev number + diff[i]\\n            long curr=diff[i]+prev;\\n            prev=curr;\\n            \\n            min=Math.min(min,curr);\\n            max=Math.max(max,curr);\\n        }\\n        \\n        //op1 tells a\\'s lower bound\\n        long op1=lower-min;\\n        \\n        //op2 tells a\\'s upper bound\\n        long op2=upper-max;\\n        \\n        //upper bound- lower bound +1 =ans (if>0)\\n        \\n        return op2-op1+1>0?(int)(op2-op1+1):0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156311,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int min=Integer.MAX_VALUE, max=Integer.MIN_VALUE,sum=0;\\n        for(int i : differences){\\n            sum+=i;\\n            min=Math.min(sum,min);\\n            max=Math.max(sum,max);\\n        }\\n        int count=0;\\n        for(int i=lower;i<=upper;i++){\\n            if(i+min>=lower && i+max<=upper) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int min=Integer.MAX_VALUE, max=Integer.MIN_VALUE,sum=0;\\n        for(int i : differences){\\n            sum+=i;\\n            min=Math.min(sum,min);\\n            max=Math.max(sum,max);\\n        }\\n        int count=0;\\n        for(int i=lower;i<=upper;i++){\\n            if(i+min>=lower && i+max<=upper) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108040,
                "title": "c-min-max",
                "content": "```\\n#include \"bits/stdc++.h\"\\n#define ll long long\\nclass Solution\\n{\\n    public:\\n        int numberOfArrays(vector<int> &differences, int lower, int upper){\\n         ll mini = 0;\\n         ll maxi = 0;\\n         ll c =0;\\n            \\n        for (int d: differences) {\\n             c += d;\\n              mini=min(mini, c);\\n              maxi=max(maxi, c);\\n        }\\n       return max(0ll, upper - lower - (maxi - mini) + 1);\\n    }\\n};\\n```\\n\\n**If Helpful Please Like Or Upvoke**",
                "solutionTags": [],
                "code": "```\\n#include \"bits/stdc++.h\"\\n#define ll long long\\nclass Solution\\n{\\n    public:\\n        int numberOfArrays(vector<int> &differences, int lower, int upper){\\n         ll mini = 0;\\n         ll maxi = 0;\\n         ll c =0;\\n            \\n        for (int d: differences) {\\n             c += d;\\n              mini=min(mini, c);\\n              maxi=max(maxi, c);\\n        }\\n       return max(0ll, upper - lower - (maxi - mini) + 1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2054947,
                "title": "js",
                "content": "```\\nvar numberOfArrays = function (differences, lower, upper) {\\n\\tlet sum = 0, min = 0, max = 0;\\n\\tdifferences.forEach(d => {\\n\\t\\tsum += d;\\n\\t\\tmin = Math.min(sum, min);\\n\\t\\tmax = Math.max(sum, max);\\n\\t});\\n\\tconst dif = upper - lower - max + min;\\n\\treturn dif < 0 ? 0 : dif + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numberOfArrays = function (differences, lower, upper) {\\n\\tlet sum = 0, min = 0, max = 0;\\n\\tdifferences.forEach(d => {\\n\\t\\tsum += d;\\n\\t\\tmin = Math.min(sum, min);\\n\\t\\tmax = Math.max(sum, max);\\n\\t});\\n\\tconst dif = upper - lower - max + min;\\n\\treturn dif < 0 ? 0 : dif + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1948370,
                "title": "c-an-interesting-question-a-lot-of-thoughts",
                "content": "So this question ask about all the possible sequences, but we actually don\\'t have to enumerate all possible sequences...\\n\\nI have thought about the number of all possible starting points at the beginning. Then, I calculate the changes of value while parsing the differences array.\\n\\nThen, I discovered that there are peek differences and valley differneces within the array. For instance:\\n\\ndiff array = [3, -4, 5, 1, -2]\\naccumulated sum of differences:\\n0 -> 3 -> -1 -> 4 -> 5 -> 3\\n\\nLet starting value = s, max possible value during parsing = s + 5, min possible value during parsing = s - 1.\\n\\nSo, the number must not be higher than the value (upper - peek) and must not be lower than (lower - valley) value. \\n\\ncode:\\n```cpp\\ntypedef long long int lld;\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        lld valley = 0;\\n        lld peek = 0;\\n        lld offset = 0;\\n        \\n        for (int v : differences) {\\n            offset += v;\\n            if (offset > peek) {\\n                peek = offset;\\n            }\\n            if (offset < valley) {\\n                valley = offset;\\n            }\\n        }\\n        int cnt = (int)((upper - peek) - (lower - valley) + 1);\\n        if (cnt <= 0) {\\n            return 0; \\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nPersonal side-notes:\\n\\nFor this question, it is not too hard. Think about other math topics like combinatorics, probabilities, statistics, etc. There\\'s much to learn... I am happy as an average person, because there is always something new to learn (like the suffix array thing. It is hard tbh.)\\n\\nNonetheless, I am thinking in a much more systematic manner now. This question looks easy, but I can\\'t imagine that past self five years ago can solve any problems on LeetCode...\\n\\nyou can do a lot of things in life like sport, hiking, performing on stage, doing artwork, watching TVs, comedies, hang out with people, reciting notes, revising for exams. Yes, I have learnt life skills, people skills, ways to appreciate beauty, I might even have learnt some philosophical ideas like meaning of life, etc. Yes, in a rare occation, there are deeper-level discussions on problems existing around us.\\n\\nBut yea, that\\'s language and literature for you. There are just too many ways to talk about the same idea. People can just play around with wordings instead of the core logic and problems. (like what am I doing right now). You can talk about a topic in a lengthy manner but with little value.\\n\\nBut for math and critical thinking, you don\\'t have much room for making arguments. \\n\\n**If it is correct, it is correct, *no matter what kind of wordings and ideas you are expression right now.***\\n\\nI believe that no one can actually \\'teach\\' that. I am definitely not a master in logical thinking as well (I am a newbie at codeforce. Yes, I only practice at LeetCode right now to maintain my ability in coding, but I rarely practice on codeforce, those contests will then be a **real IQ test** for me.). \\n\\nLike many people said, \"If you are stupid, you can\\'t possibly be a cracker-jacker programmer / math guy / engineer\", etc.\\n\\n**Yes, they are right.**\\n\\nBut even for average people like me (average IQ, average physicality, average appearance, average EQ), I can feel and experience the benefit of being a little bit smarter by doing little coding / mathy problems. \\n\\nWhen you go out on the street, I make better purchasing decisions. I won\\'t be easily affected by the salespersons and purchase unnecessary products. \\n\\nWhen I am dealing with new problems, I break it down into smaller chunks and solve them one by one.\\n\\nand many many more little, trivial, insignificant examples in life...\\n\\nYea! Yes! I get it! **They all sounds so trivial!** But sometimes, when such scenario exist, **all you can rely on is your instincts and gut feelings, your knee-jerk responese.**\\n\\n**...ta-da! AND THERE IS THE DIFFERENCE!**\\n\\n------------------------------------------------------------------------------------------------------------------------------\\nHow to be rich? Well, it is definitely not by doing a lot of LeetCode problems. \\\\\\\\(^_^)/\\n\\nBut when you are doing many things in life, like gambling, those are zero-sum games. One party must lost something to the winner. Yes, you have made $$, but others may not like you anymore  \\\\\\\\(@_@)/ (meanwhile, someone said I don\\'t fxxking care as long as I am making $$. Well, after many years, I still can\\'t do that. Maybe I am being too kind.)\\n\\nSo, if you are a real problem-solver, you help others, and others pay you back with $$. This is the best idea to make $$ (although I am poor).\\n\\n...or you can be a people-pleasing clown (like most actors / actresses nowadays), which is also completely fine, it is an honest way to make a living as well. (Just don\\'t do the Illuminati hand-sign)\\n\\n\\\\\\\\(^_^)/\\n\\nCool.",
                "solutionTags": [],
                "code": "```cpp\\ntypedef long long int lld;\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        lld valley = 0;\\n        lld peek = 0;\\n        lld offset = 0;\\n        \\n        for (int v : differences) {\\n            offset += v;\\n            if (offset > peek) {\\n                peek = offset;\\n            }\\n            if (offset < valley) {\\n                valley = offset;\\n            }\\n        }\\n        int cnt = (int)((upper - peek) - (lower - valley) + 1);\\n        if (cnt <= 0) {\\n            return 0; \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879354,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} differences\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar numberOfArrays = function(differences, lower, upper) {\\n    let res = 0;\\n    let min = null;\\n    let index = null;\\n\\t// find the min value\\n    for(let i=0; i<differences.length; i++){\\n        if(min === null || differences[i] < min){\\n            min = differences[i];\\n            index = i;\\n        }\\n    }\\n\\n    let arr = new Array(differences.length+1).fill(0);\\n\\t// first assume min as lower\\n    arr[index+1] = lower;\\n\\t// calc the rest array element\\n    for(let i=index; i>=0; i--){\\n        arr[i] = arr[i+1] - differences[i];\\n    }\\n    for(let i=index+2; i<differences.length+1; i++){\\n        arr[i] = arr[i-1] + differences[i-1];\\n    }\\n\\t// check max and make sure max <= upper\\n    let max = Math.max(...arr);\\n    res = upper - max + 1 > 0 ? upper - max + 1 : 0;\\n    // double check min and make sure min >= lower\\n    let newMin = Math.min(...arr);\\n    if(newMin < lower){\\n        res = res - (lower - newMin) > 0 ? res - (lower - newMin) : 0;\\n    }\\n\\n    return res;    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} differences\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar numberOfArrays = function(differences, lower, upper) {\\n    let res = 0;\\n    let min = null;\\n    let index = null;\\n\\t// find the min value\\n    for(let i=0; i<differences.length; i++){\\n        if(min === null || differences[i] < min){\\n            min = differences[i];\\n            index = i;\\n        }\\n    }\\n\\n    let arr = new Array(differences.length+1).fill(0);\\n\\t// first assume min as lower\\n    arr[index+1] = lower;\\n\\t// calc the rest array element\\n    for(let i=index; i>=0; i--){\\n        arr[i] = arr[i+1] - differences[i];\\n    }\\n    for(let i=index+2; i<differences.length+1; i++){\\n        arr[i] = arr[i-1] + differences[i-1];\\n    }\\n\\t// check max and make sure max <= upper\\n    let max = Math.max(...arr);\\n    res = upper - max + 1 > 0 ? upper - max + 1 : 0;\\n    // double check min and make sure min >= lower\\n    let newMin = Math.min(...arr);\\n    if(newMin < lower){\\n        res = res - (lower - newMin) > 0 ? res - (lower - newMin) : 0;\\n    }\\n\\n    return res;    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873252,
                "title": "c-one-pass-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n        long long curr_elem = lower;\\n        long long min_elem = lower;\\n        long long max_elem = lower;\\n        \\n        for(int diff : differences){\\n            curr_elem += (long long)diff;\\n            \\n            min_elem = min(min_elem,curr_elem);\\n            \\n            max_elem = max(max_elem, curr_elem);\\n        }\\n    \\n        if(min_elem < lower){\\n            long long diff = lower - min_elem;\\n            max_elem += diff;\\n        }\\n                \\n        if(max_elem > upper)\\n            return 0;\\n        \\n        return upper - max_elem + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n        long long curr_elem = lower;\\n        long long min_elem = lower;\\n        long long max_elem = lower;\\n        \\n        for(int diff : differences){\\n            curr_elem += (long long)diff;\\n            \\n            min_elem = min(min_elem,curr_elem);\\n            \\n            max_elem = max(max_elem, curr_elem);\\n        }\\n    \\n        if(min_elem < lower){\\n            long long diff = lower - min_elem;\\n            max_elem += diff;\\n        }\\n                \\n        if(max_elem > upper)\\n            return 0;\\n        \\n        return upper - max_elem + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807190,
                "title": "check-for-value-at-0th-position-only",
                "content": "Find the range of values that can appear on 0th position considering the addition of successive \\n         differences.\\n\\t\\t Range of values at 0th pos = max(lower,lower-min_prefix_sum) --> min(upper,upper-max_prefix_sum)\\n```\\nclass Solution:\\n    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:\\n        curr,l,r = 0,lower,upper\\n        for x in diff:\\n            curr+=x \\n            l,r = max(l,lower-curr),min(r,upper-curr)\\n        return max(r-l+1,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, diff: List[int], lower: int, upper: int) -> int:\\n        curr,l,r = 0,lower,upper\\n        for x in diff:\\n            curr+=x \\n            l,r = max(l,lower-curr),min(r,upper-curr)\\n        return max(r-l+1,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771088,
                "title": "c-faster-than-71-with-complete-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        //approach\\n        \\n        // let diff=[1,3,-5,8,-9];\\n        // vector=[x,x+1,x+1+3,x+1+3-5....]=[x,x+1,x+4,x-1,x+7,x-2];\\n        // min=x-2 and max=x+7;\\n        // for min : x=lower+2;\\n        // for max : x=upper-7;\\n        // total (inclusive upper and lower)  ans=(upper-7)-(lower+2)-1;\\n        // if(ans<=0) ans=0\\n        \\n        long long int temp=0;\\n        long long int maxi=0;\\n        long long int mini=0;\\n        for(auto it: differences)\\n        {\\n            temp+=it;\\n            maxi=max(maxi,temp);\\n            mini=min(mini,temp);\\n        }\\n        \\n        //relating with above example\\n        // maxi=7 and mini=-2\\n        \\n        long long int ans=(upper-maxi)-(lower-mini)+1;\\n        if(ans<=0) return 0;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        //approach\\n        \\n        // let diff=[1,3,-5,8,-9];\\n        // vector=[x,x+1,x+1+3,x+1+3-5....]=[x,x+1,x+4,x-1,x+7,x-2];\\n        // min=x-2 and max=x+7;\\n        // for min : x=lower+2;\\n        // for max : x=upper-7;\\n        // total (inclusive upper and lower)  ans=(upper-7)-(lower+2)-1;\\n        // if(ans<=0) ans=0\\n        \\n        long long int temp=0;\\n        long long int maxi=0;\\n        long long int mini=0;\\n        for(auto it: differences)\\n        {\\n            temp+=it;\\n            maxi=max(maxi,temp);\\n            mini=min(mini,temp);\\n        }\\n        \\n        //relating with above example\\n        // maxi=7 and mini=-2\\n        \\n        long long int ans=(upper-maxi)-(lower-mini)+1;\\n        if(ans<=0) return 0;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729351,
                "title": "java-solution-faster-than-99",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] diff, int lower, int upper) {\\n        int n = diff.length;\\n        if(lower == upper){\\n            for(int i=0; i<n; i++){\\n                if(diff[i]!=0) return 0;\\n            }\\n        }\\n        \\n        int max = -(int)1e9;\\n        int min = (int)1e9;\\n        int[] hidden = new int[n+1];\\n        hidden[0] = 0;\\n        \\n        for(int i=1; i<=n; i++){\\n            hidden[i] = hidden[i-1] + diff[i-1];\\n        }\\n        \\n        for(int i=0; i<=n; i++){\\n            if(hidden[i] > max) max = hidden[i];\\n            if(hidden[i] < min) min = hidden[i];\\n        }\\n        \\n        int low = lower - min;\\n        int high = upper - max;\\n       \\n        if(low > high) return 0;\\n        int count = (high - low) + 1;\\n        \\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numberOfArrays(int[] diff, int lower, int upper) {\\n        int n = diff.length;\\n        if(lower == upper){\\n            for(int i=0; i<n; i++){\\n                if(diff[i]!=0) return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1716456,
                "title": "c-binary-search-o-nlog-low-high-solution",
                "content": "\\n    int isPoss( vector<int>& differences, int start, int lower, int upper ) {\\n        int n = differences.size();\\n        int sum = start;\\n        for( int i = 0; i < n; i++ ) {\\n            sum = sum + differences[i];\\n            if( sum > upper)\\n                return 2;\\n            if( sum < lower )\\n                return 0;\\n        }\\n\\n        return 1;\\n    }\\n\\n    // [0,1,2,3,4,5,6]\\n    // [0,0,1,1,2,2,2]\\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int l = lower, r = upper;        \\n        while( l <= r ) {\\n            int mid = ( l + r ) >> 1;\\n            int midVal = isPoss( differences, mid, lower, upper );\\n            if( midVal == 0 || midVal == 1 )\\n                l = mid + 1;\\n            else r = mid - 1;\\n        }\\n\\n        int upperIdx = l;\\n\\n        l = lower, r = upper;\\n        while( l <= r ) {\\n            int mid = ( l + r ) >> 1;\\n            int midVal = isPoss( differences, mid, lower, upper );\\n            if( midVal == 1 || midVal == 2 )\\n                r = mid - 1;\\n            else l = mid + 1;\\n        }\\n\\n        int lowerIdx = l;\\n\\n        return (upperIdx - lowerIdx);\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "\\n    int isPoss( vector<int>& differences, int start, int lower, int upper ) {\\n        int n = differences.size();\\n        int sum = start;\\n        for( int i = 0; i < n; i++ ) {\\n            sum = sum + differences[i];\\n            if( sum > upper)\\n                return 2;\\n            if( sum < lower )\\n                return 0;\\n        }\\n\\n        return 1;\\n    }\\n\\n    // [0,1,2,3,4,5,6]\\n    // [0,0,1,1,2,2,2]\\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int l = lower, r = upper;        \\n        while( l <= r ) {\\n            int mid = ( l + r ) >> 1;\\n            int midVal = isPoss( differences, mid, lower, upper );\\n            if( midVal == 0 || midVal == 1 )\\n                l = mid + 1;\\n            else r = mid - 1;\\n        }\\n\\n        int upperIdx = l;\\n\\n        l = lower, r = upper;\\n        while( l <= r ) {\\n            int mid = ( l + r ) >> 1;\\n            int midVal = isPoss( differences, mid, lower, upper );\\n            if( midVal == 1 || midVal == 2 )\\n                r = mid - 1;\\n            else l = mid + 1;\\n        }\\n\\n        int lowerIdx = l;\\n\\n        return (upperIdx - lowerIdx);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1714749,
                "title": "java-easy-solution-using-prefix-sum-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/23ebb143-cb3a-46ed-9e4f-6ab43f33cd27_1642998684.069137.jpeg)\\n![image](https://assets.leetcode.com/users/images/3088fc6e-afef-40a6-9650-254ad93d2d29_1642998685.3694851.jpeg)\\n\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int n=differences.length;\\n        long ans=0;\\n         long max=0;\\n        long min=0;\\n        for(int i=0;i<n;i++){\\n            ans+=(long)differences[i];\\n            max=(long)Math.max(ans,max);\\n            min=(long)Math.min(ans,min);\\n        }\\n        long minBound=lower-min;\\n        long maxBound=upper-max;\\n        if(minBound>maxBound) return 0;\\n        return (int)(Math.abs(maxBound-minBound)+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int n=differences.length;\\n        long ans=0;\\n         long max=0;\\n        long min=0;\\n        for(int i=0;i<n;i++){\\n            ans+=(long)differences[i];\\n            max=(long)Math.max(ans,max);\\n            min=(long)Math.min(ans,min);\\n        }\\n        long minBound=lower-min;\\n        long maxBound=upper-max;\\n        if(minBound>maxBound) return 0;\\n        return (int)(Math.abs(maxBound-minBound)+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713290,
                "title": "binary-search-solution-o-n-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& arr, vector<int>& d, int l, int r, int &ele)\\n    {\\n        for(int i=0;i<d.size();i++)\\n        {\\n            ele = d[i] + arr[i];\\n            if(ele>=l && ele<=r )\\n            {\\n                arr[i+1] = ele;\\n                \\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int numberOfArrays(vector<int>& d, int lower, int upper) {\\n        \\n        int n= d.size();\\n        int low =lower;\\n        int high = upper;\\n        int ans = 0;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            vector<int>arr(n+1);\\n            arr[0]=mid;\\n            int ele=mid;\\n            if(solve(arr, d, lower, upper, ele))\\n            {\\n                int mx =INT_MIN;\\n                for(int j : arr)\\n                {\\n                    mx = max(mx, j);\\n                }\\n                ans = max(ans, upper- mx+1);\\n                //cout<<mx<<endl;\\n                high = mid - 1;\\n            }\\n            else if(ele > high)\\n            {\\n                high = mid -1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nTime Complexity : O(N(log(N))) , N = upper - lower +1",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(vector<int>& arr, vector<int>& d, int l, int r, int &ele)\\n    {\\n        for(int i=0;i<d.size();i++)\\n        {\\n            ele = d[i] + arr[i];\\n            if(ele>=l && ele<=r )\\n            {\\n                arr[i+1] = ele;\\n                \\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int numberOfArrays(vector<int>& d, int lower, int upper) {\\n        \\n        int n= d.size();\\n        int low =lower;\\n        int high = upper;\\n        int ans = 0;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            vector<int>arr(n+1);\\n            arr[0]=mid;\\n            int ele=mid;\\n            if(solve(arr, d, lower, upper, ele))\\n            {\\n                int mx =INT_MIN;\\n                for(int j : arr)\\n                {\\n                    mx = max(mx, j);\\n                }\\n                ans = max(ans, upper- mx+1);\\n                //cout<<mx<<endl;\\n                high = mid - 1;\\n            }\\n            else if(ele > high)\\n            {\\n                high = mid -1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1710233,
                "title": "c-solution-using-kadane-s-and-negative-kadane-s-algorithm",
                "content": "```\\n\\n```int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long int pcurrsum =0;\\n        long int pmaxsum =0;\\n        long int nmaxsum=0;\\n        long int ncurrsum=0;\\n        long int bounddiff = upper-lower;\\n        int maxsum =0;\\n            for(int i=0;i<differences.size();i++)\\n            {\\n              pcurrsum += differences[i];  //kadane\\'s\\n              if(pcurrsum<0)\\n                  pcurrsum =0; \\n              if(pcurrsum>pmaxsum)\\n                  pmaxsum = pcurrsum;\\n              ncurrsum -= differences[i];  //negative kadane\\'s\\n              if(ncurrsum<0)\\n                  ncurrsum =0;\\n             if(ncurrsum>nmaxsum )\\n                 nmaxsum = ncurrsum;\\n            }\\n            if(nmaxsum>pmaxsum)\\n                maxsum=nmaxsum;\\n            else \\n                maxsum=pmaxsum;\\n            if(bounddiff<maxsum)\\n                return 0;\\n            else \\n                return bounddiff-maxsum+1;\\n   }``",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1710123,
                "title": "cpp-one-pass-o-n-time-and-o-1-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& di, int lower, int upper) {\\n\\t//considering the 1st element of hidden array be 0 so max and min val be 0\\n        long long mi=0,c=0,mx=0;\\n        for(int i=0;i<di.size();i++)\\n        {\\n            c+=(long long)di[i];\\n            if(c<mi)\\n            {\\n                mi=c;\\n            }\\n            if(c>mx)\\n            {\\n                mx=c;\\n            }\\n        }\\n        mx=mx+(lower-mi);\\n        if(upper-mx+1<=0)\\n            return 0;\\n        return upper-mx+1;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfArrays(vector<int>& di, int lower, int upper) {\\n\\t//considering the 1st element of hidden array be 0 so max and min val be 0\\n        long long mi=0,c=0,mx=0;\\n        for(int i=0;i<di.size();i++)\\n        {\\n            c+=(long long)di[i];\\n            if(c<mi)\\n            {\\n                mi=c;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1709969,
                "title": "c-counting-o-n-time-and-space",
                "content": "```\\n1. length of the array is fixed (size of difference array + 1)\\n2. differences are fixed (that\\'s the question)\\n3. Find the max and min in the pre sum array to find the range of a \\ndummy array (may be starting element 0, doesn\\'t matter because we\\nare only concerned with range) and then we have our maximum range\\n(upper - lower)...count the total arrays (read the return statement)\\n```\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& dif, int lower, int upper) {\\n        int n = dif.size();\\n        vector<long> ps(n+1);\\n        for(int i=0; i<n; i++){\\n            ps[i+1] = dif[i]+ ps[i];\\n        }\\n        long mx = ps[0]; long mn = ps[0];\\n        for(int i=0; i<n+1; i++) {\\n            mx = max(mx, ps[i]);\\n            mn = min(mn, ps[i]);\\n        }\\n        if((upper - lower) >= (mx - mn)) return (upper - lower) - (mx - mn) + 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Counting"
                ],
                "code": "```\\n1. length of the array is fixed (size of difference array + 1)\\n2. differences are fixed (that\\'s the question)\\n3. Find the max and min in the pre sum array to find the range of a \\ndummy array (may be starting element 0, doesn\\'t matter because we\\nare only concerned with range) and then we have our maximum range\\n(upper - lower)...count the total arrays (read the return statement)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& dif, int lower, int upper) {\\n        int n = dif.size();\\n        vector<long> ps(n+1);\\n        for(int i=0; i<n; i++){\\n            ps[i+1] = dif[i]+ ps[i];\\n        }\\n        long mx = ps[0]; long mn = ps[0];\\n        for(int i=0; i<n+1; i++) {\\n            mx = max(mx, ps[i]);\\n            mn = min(mn, ps[i]);\\n        }\\n        if((upper - lower) >= (mx - mn)) return (upper - lower) - (mx - mn) + 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709856,
                "title": "java-prefix-sum-t-c-o-n",
                "content": "**Approach:**\\n* To check if the solution is possible or not between the lower limit and upper limit, we need not worry about other elements except minimum and maximum.\\n* We got the minimum and maximum elements by calculating the prefix sum.\\n* For every element in the limit, we will check if some of itself with minimum element is not less than lower limit and maximum element is not greater that upper limit.\\n```\\npublic int numberOfArrays(int[] differences, int lower, int upper) {\\n        int count = 0;\\n        int prefiSum = 0;\\n        int maxPrefix = Integer.MIN_VALUE;\\n        int minPrefix = Integer.MAX_VALUE;\\n        for(int i=0;i<differences.length;i++){\\n            prefiSum+=differences[i];\\n            maxPrefix = Math.max(maxPrefix,prefiSum);\\n            minPrefix = Math.min(minPrefix,prefiSum);\\n        }           \\n        for(int i=lower;i<=upper;i++){\\n            if(maxPrefix+i<=upper && minPrefix+i>=lower)\\n                count++;\\n\\t\\t\\telse if(count>0)\\n                break;\\n        }\\n        return count;\\n    }\\n```\\n**PLEASE UPVOTE IF YOU FIND THIS SOLUTION USEFUL**",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic int numberOfArrays(int[] differences, int lower, int upper) {\\n        int count = 0;\\n        int prefiSum = 0;\\n        int maxPrefix = Integer.MIN_VALUE;\\n        int minPrefix = Integer.MAX_VALUE;\\n        for(int i=0;i<differences.length;i++){\\n            prefiSum+=differences[i];\\n            maxPrefix = Math.max(maxPrefix,prefiSum);\\n            minPrefix = Math.min(minPrefix,prefiSum);\\n        }           \\n        for(int i=lower;i<=upper;i++){\\n            if(maxPrefix+i<=upper && minPrefix+i>=lower)\\n                count++;\\n\\t\\t\\telse if(count>0)\\n                break;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709826,
                "title": "c-o-n-with-intuition",
                "content": "We can check each element from lower to higher and in actual we need to check to which extent it can fall and to which extent it can rise \\nif it lies between the range then that\\'s one of the answers.\\n```\\nint numberOfArrays(vector<int>& differences, int lower, int higher) {\\n        \\n        long long mini=INT_MAX;\\n        long long maxi=INT_MIN;\\n        long long sum=0;\\n        for(int ele:differences){\\n            sum+=ele;                // from here find to which extent it can fall and rise\\n            mini=min(mini,sum);\\n            maxi=max(maxi,sum);\\n        }\\n        \\n        \\n        \\n        int count=0;\\n        for(int i=lower;i<=higher;i++){\\n            if(i+mini>=lower&&i+maxi<=higher){\\n                count++;\\n            }\\n            \\n            \\n            \\n        }\\n        return count;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nint numberOfArrays(vector<int>& differences, int lower, int higher) {\\n        \\n        long long mini=INT_MAX;\\n        long long maxi=INT_MIN;\\n        long long sum=0;\\n        for(int ele:differences){\\n            sum+=ele;                // from here find to which extent it can fall and rise\\n            mini=min(mini,sum);\\n            maxi=max(maxi,sum);\\n        }\\n        \\n        \\n        \\n        int count=0;\\n        for(int i=lower;i<=higher;i++){\\n            if(i+mini>=lower&&i+maxi<=higher){\\n                count++;\\n            }\\n            \\n            \\n            \\n        }\\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709796,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& dif, int l, int u) {\\n        int ans = 0;\\n        for(int i=l; i<=u; i++){\\n            int chk = i, cnt=0, max = i;\\n            for(int x:dif){\\n                chk+=x;\\n                if(chk<l){\\n                    break;\\n                }\\n                if(chk>u)\\n                    return 0;\\n                max = (max<chk) ? chk : max;\\n                cnt++;\\n            }\\n            if(cnt==dif.size())\\n                return u-max+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& dif, int l, int u) {\\n        int ans = 0;\\n        for(int i=l; i<=u; i++){\\n            int chk = i, cnt=0, max = i;\\n            for(int x:dif){\\n                chk+=x;\\n                if(chk<l){\\n                    break;\\n                }\\n                if(chk>u)\\n                    return 0;\\n                max = (max<chk) ? chk : max;\\n                cnt++;\\n            }\\n            if(cnt==dif.size())\\n                return u-max+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709784,
                "title": "python3-simple-solution-with-maximum-and-minimum",
                "content": "```\\ndef numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n    mini = maxi = i = 0\\n    for d in differences:\\n        i += d\\n        mini = min(i, mini)\\n        maxi = max(i, maxi)\\n    return max(0, (upper - lower) - (maxi - mini) + 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n    mini = maxi = i = 0\\n    for d in differences:\\n        i += d\\n        mini = min(i, mini)\\n        maxi = max(i, maxi)\\n    return max(0, (upper - lower) - (maxi - mini) + 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1709768,
                "title": "c-simple-maths-explained-with-example",
                "content": "The property of differences \\nif we have a sequence [a1,a2,a3,a4]\\nand differences as [d1,d2,d3]\\n\\n***Notice that difference won\\'t change if we increase or decrease each number in sequence by a constant k***\\n\\nExample: If we have difference as [1,-3,4] \\nthen we can produce an array such that [0,1,-2,2]\\nsee that this is a solution but it does not lie in the range \\nso we increase all elements in array with 3 so all elements now are in range [3,4,1,5] and just increase each number by 1 we get another sequence [4,5,2,6] , we can not go further since we will exceed range. So we have 2 sequences.\\n***update***\\nWe don\\'t need to store values, just keep track of the difference and minm maxm values\\n\\n```\\nint numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int n = differences.size();\\n        long arr[n+1];\\n        arr[0] = INT_MIN;\\n        long maxm = arr[0];\\n        long minm = arr[0];\\n        \\n\\t\\t\\n\\t\\t//create a temporary array and store starting  array \\n        for(int i=1;i<n+1;i++){\\n            arr[i] = arr[i-1]+differences[i-1];\\n            if(arr[i]>maxm)\\n                maxm = arr[i];\\n            if(arr[i]<minm)\\n                minm = arr[i];\\n        }\\n        long min1 = 0;\\n        long max1 = 0;\\n\\t\\t\\n\\t\\t//increase minimum value by k such that k lies in range\\n        min1 = lower - minm;\\n        max1 = maxm + min1;\\n\\t\\t\\n\\t\\t//if increasing minm number doesn\\'t make max go out of bounds we can calculate total sequences\\n        if(max1<=upper){\\n            return upper-max1+1;\\n        }\\n        \\n        else\\n            return 0;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nint numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int n = differences.size();\\n        long arr[n+1];\\n        arr[0] = INT_MIN;\\n        long maxm = arr[0];\\n        long minm = arr[0];\\n        \\n\\t\\t\\n\\t\\t//create a temporary array and store starting  array \\n        for(int i=1;i<n+1;i++){\\n            arr[i] = arr[i-1]+differences[i-1];\\n            if(arr[i]>maxm)\\n                maxm = arr[i];\\n            if(arr[i]<minm)\\n                minm = arr[i];\\n        }\\n        long min1 = 0;\\n        long max1 = 0;\\n\\t\\t\\n\\t\\t//increase minimum value by k such that k lies in range\\n        min1 = lower - minm;\\n        max1 = maxm + min1;\\n\\t\\t\\n\\t\\t//if increasing minm number doesn\\'t make max go out of bounds we can calculate total sequences\\n        if(max1<=upper){\\n            return upper-max1+1;\\n        }\\n        \\n        else\\n            return 0;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1709749,
                "title": "c-o-n-time-based-on-observations",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    \\n    int numberOfArrays(vector<int>& diff, int low, int high) {\\n        ll sum = 0, maxN = INT_MIN, minN = INT_MAX, n = diff.size();\\n        \\n        for(int i = 0; i < n; i ++){\\n            sum += diff[i];\\n            \\n            maxN = max(maxN, sum); // stores maximum number we will add into some X\\n            minN = min(minN, sum); // stores minimum number we will add into some X\\n        }\\n        \\n        int res = 0;\\n        \\n        // check if some X [low, high] + minN is in range & X [low, high] + maxN is in range; \\n        for(int i = low; i <= high; i ++){\\n            if(i + minN >= low && i + minN <= high && i + maxN >= low && i + maxN <= high) res += 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    \\n    int numberOfArrays(vector<int>& diff, int low, int high) {\\n        ll sum = 0, maxN = INT_MIN, minN = INT_MAX, n = diff.size();\\n        \\n        for(int i = 0; i < n; i ++){\\n            sum += diff[i];\\n            \\n            maxN = max(maxN, sum); // stores maximum number we will add into some X\\n            minN = min(minN, sum); // stores minimum number we will add into some X\\n        }\\n        \\n        int res = 0;\\n        \\n        // check if some X [low, high] + minN is in range & X [low, high] + maxN is in range; \\n        for(int i = low; i <= high; i ++){\\n            if(i + minN >= low && i + minN <= high && i + maxN >= low && i + maxN <= high) res += 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709731,
                "title": "c-simple-manipulating-the-range",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>&A, int l, int u) {\\n        int l1 = l;\\n        int u1 = u;\\n        for(int a : A)\\n        {\\n            if(a > 0)\\n            {\\n                l1 = l1 + a;\\n                if(l1 > u)\\n                    return 0;\\n                u1 = min(u,u1 + a);\\n            }\\n            else if(a < 0)\\n            {\\n                u1 = u1 + a;\\n                if(u1 < l)\\n                    return 0;\\n                l1 = max(l,l1 + a);\\n            }\\n        }\\n        return (u1 - l1 + 1);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>&A, int l, int u) {\\n        int l1 = l;\\n        int u1 = u;\\n        for(int a : A)\\n        {\\n            if(a > 0)\\n            {\\n                l1 = l1 + a;\\n                if(l1 > u)\\n                    return 0;\\n                u1 = min(u,u1 + a);\\n            }\\n            else if(a < 0)\\n            {\\n                u1 = u1 + a;\\n                if(u1 < l)\\n                    return 0;\\n                l1 = max(l,l1 + a);\\n            }\\n        }\\n        return (u1 - l1 + 1);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709700,
                "title": "prefix-sum-needed-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& arr, int lower, int higher) {\\n        long Min = 0;\\n        long Max = 0;\\n        long current = 0;\\n\\n        for (int& val : arr) {\\n            current += val;\\n            Min = min(Min, current);\\n            Max = max(Max, current);\\n        }\\n\\n        return max(0L, (higher - lower) - (Max - Min) + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& arr, int lower, int higher) {\\n        long Min = 0;\\n        long Max = 0;\\n        long current = 0;\\n\\n        for (int& val : arr) {\\n            current += val;\\n            Min = min(Min, current);\\n            Max = max(Max, current);\\n        }\\n\\n        return max(0L, (higher - lower) - (Max - Min) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709698,
                "title": "c-python-o-n-time-o-1-space-single-pass",
                "content": "1. We try to find minimum and maximum values within hidden sequence, which starts with 0.\\n2. Once we find them, we need to determine the valid range of the first element of the hidden sequence, given lower and upper bounds, and return it. \\n\\nPython:\\n\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        currVal, minVal, maxVal = 0, 0, 0\\n        \\n        for i in range(len(differences)):\\n            currVal += differences[i]\\n            minVal = min(minVal, currVal)\\n            maxVal = max(maxVal, currVal)\\n        \\n        startInterval = lower - minVal\\n        endInterval = upper - maxVal\\n        \\n        return max(0, endInterval - startInterval + 1)\\n```\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long currVal = 0, minVal = 0, maxVal = 0;\\n        \\n        for (int i = 0; i < differences.size(); i++)\\n        {\\n            currVal += differences[i];\\n            minVal = min(minVal, currVal);\\n            maxVal = max(maxVal, currVal);\\n        }\\n        \\n        int startInterval = lower - minVal;\\n        int endInterval = upper - maxVal;\\n        \\n        return max(0, endInterval - startInterval + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        currVal, minVal, maxVal = 0, 0, 0\\n        \\n        for i in range(len(differences)):\\n            currVal += differences[i]\\n            minVal = min(minVal, currVal)\\n            maxVal = max(maxVal, currVal)\\n        \\n        startInterval = lower - minVal\\n        endInterval = upper - maxVal\\n        \\n        return max(0, endInterval - startInterval + 1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long currVal = 0, minVal = 0, maxVal = 0;\\n        \\n        for (int i = 0; i < differences.size(); i++)\\n        {\\n            currVal += differences[i];\\n            minVal = min(minVal, currVal);\\n            maxVal = max(maxVal, currVal);\\n        }\\n        \\n        int startInterval = lower - minVal;\\n        int endInterval = upper - maxVal;\\n        \\n        return max(0, endInterval - startInterval + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709693,
                "title": "python3-o-n-with-prefix-sum-approach",
                "content": "```\\n# O(n) with PREFIX SUM\\n# Number of sequences == number of valid start points\\n# Calculate the biggest positive and negative steps difference relative to our lower and upper points (with prefix sum)\\n# The number of valid start points is: (upper-pos) - (lower+(-neg)) + 1. Prevent the result from going to the negatives by using 0 as lower bound.\\n\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prefixSum = 0\\n        neg = 0\\n        pos = 0\\n        for diff in differences:\\n            prefixSum += diff\\n            neg = min(neg, prefixSum)\\n            pos = max(pos, prefixSum)\\n\\n        return max((upper-pos) - (lower-neg) + 1, 0)\\n\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n# O(n) with PREFIX SUM\\n# Number of sequences == number of valid start points\\n# Calculate the biggest positive and negative steps difference relative to our lower and upper points (with prefix sum)\\n# The number of valid start points is: (upper-pos) - (lower+(-neg)) + 1. Prevent the result from going to the negatives by using 0 as lower bound.\\n\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prefixSum = 0\\n        neg = 0\\n        pos = 0\\n        for diff in differences:\\n            prefixSum += diff\\n            neg = min(neg, prefixSum)\\n            pos = max(pos, prefixSum)\\n\\n        return max((upper-pos) - (lower-neg) + 1, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709660,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun numberOfArrays(A: IntArray, beg: Int, end: Int): Int {\\n        var (t, lo, hi) = Triple(0L, 0L, 0L)\\n        for (x in A) {\\n            t += x\\n            lo = Math.min(lo, t)\\n            hi = Math.max(hi, t)\\n        }\\n        var offset = beg - lo\\n        hi += offset\\n        return if (end < hi) 0 else (end - hi + 1).toInt()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numberOfArrays = (A, beg, end) => {\\n    let [t, lo, hi] = [0, 0, 0];\\n    for (let x of A) {\\n        t += x;\\n        lo = Math.min(lo, t);\\n        hi = Math.max(hi, t);\\n    }\\n    let offset = beg - lo;\\n    hi += offset;\\n    return end < hi ? 0 : end - hi + 1;\\n};\\n\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def numberOfArrays(self, A: List[int], beg: int, end: int) -> int:\\n        t, lo, hi = 0, 0, 0\\n        for x in A:\\n            t += x\\n            lo = min(lo, t)\\n            hi = max(hi, t)\\n        offset = beg - lo\\n        hi += offset\\n        return 0 if end < hi else end - hi + 1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int numberOfArrays(VI& A, int beg, int end) {\\n        auto [t, lo, hi] = make_tuple(0LL, 0LL, 0LL);\\n        for (auto x: A) {\\n            t += x;\\n            lo = min(lo, t);\\n            hi = max(hi, t);\\n        }\\n        auto offset = beg - lo;\\n        hi += offset;\\n        return end < hi ? 0 : end - hi + 1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numberOfArrays(A: IntArray, beg: Int, end: Int): Int {\\n        var (t, lo, hi) = Triple(0L, 0L, 0L)\\n        for (x in A) {\\n            t += x\\n            lo = Math.min(lo, t)\\n            hi = Math.max(hi, t)\\n        }\\n        var offset = beg - lo\\n        hi += offset\\n        return if (end < hi) 0 else (end - hi + 1).toInt()\\n    }\\n}\\n```\n```\\nlet numberOfArrays = (A, beg, end) => {\\n    let [t, lo, hi] = [0, 0, 0];\\n    for (let x of A) {\\n        t += x;\\n        lo = Math.min(lo, t);\\n        hi = Math.max(hi, t);\\n    }\\n    let offset = beg - lo;\\n    hi += offset;\\n    return end < hi ? 0 : end - hi + 1;\\n};\\n\\n```\n```\\nclass Solution:\\n    def numberOfArrays(self, A: List[int], beg: int, end: int) -> int:\\n        t, lo, hi = 0, 0, 0\\n        for x in A:\\n            t += x\\n            lo = min(lo, t)\\n            hi = max(hi, t)\\n        offset = beg - lo\\n        hi += offset\\n        return 0 if end < hi else end - hi + 1\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int numberOfArrays(VI& A, int beg, int end) {\\n        auto [t, lo, hi] = make_tuple(0LL, 0LL, 0LL);\\n        for (auto x: A) {\\n            t += x;\\n            lo = min(lo, t);\\n            hi = max(hi, t);\\n        }\\n        auto offset = beg - lo;\\n        hi += offset;\\n        return end < hi ? 0 : end - hi + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901394,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int pref[]=new int[differences.length]; \\n        // b=a+differences[0], c=a+differences[0]+differences[1],...\\n        for(int i=0;i<differences.length;i++)\\n        {\\n            if(i==0)\\n            {\\n                pref[i]=differences[i];\\n            }\\n            else\\n            {\\n                pref[i]=pref[i-1]+differences[i];\\n            }\\n        }\\n        int rangeCount=0;\\n        int x=Integer.MIN_VALUE,y=Integer.MAX_VALUE;\\n        for(int i=0;i<pref.length;i++)\\n        {\\n            int low=lower-pref[i];\\n            int high=upper-pref[i];\\n            if(low>upper)\\n            {\\n                return 0;\\n            }\\n            if(low<lower)\\n            {\\n                low=lower;\\n            }\\n            if(upper<high)\\n            {\\n                high=upper;\\n            }\\n            if(low>x)\\n            {\\n                x=low;\\n            }\\n            if(high<y)\\n            {\\n                y=high;\\n            }  \\n            if(y<x)\\n            {\\n                return 0;\\n            }          \\n        }\\n\\n        return y-x+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int pref[]=new int[differences.length]; \\n        // b=a+differences[0], c=a+differences[0]+differences[1],...\\n        for(int i=0;i<differences.length;i++)\\n        {\\n            if(i==0)\\n            {\\n                pref[i]=differences[i];\\n            }\\n            else\\n            {\\n                pref[i]=pref[i-1]+differences[i];\\n            }\\n        }\\n        int rangeCount=0;\\n        int x=Integer.MIN_VALUE,y=Integer.MAX_VALUE;\\n        for(int i=0;i<pref.length;i++)\\n        {\\n            int low=lower-pref[i];\\n            int high=upper-pref[i];\\n            if(low>upper)\\n            {\\n                return 0;\\n            }\\n            if(low<lower)\\n            {\\n                low=lower;\\n            }\\n            if(upper<high)\\n            {\\n                high=upper;\\n            }\\n            if(low>x)\\n            {\\n                x=low;\\n            }\\n            if(high<y)\\n            {\\n                y=high;\\n            }  \\n            if(y<x)\\n            {\\n                return 0;\\n            }          \\n        }\\n\\n        return y-x+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899050,
                "title": "simple-prefix-sum-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int n= differences.size();\\n        vector<long long>a(n,0);\\n        long long mn=INT_MAX,mx=INT_MIN;\\n        a[0]= differences[0];\\n        mn=min(mn,a[0]);\\n        mx=max(mx,a[0]);\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i-1]+ differences[i];\\n            mn=min(mn,a[i]);\\n            mx=max(mx,a[i]);\\n        }\\n        int l=lower-mn,u=upper-mx;\\n        if(l<lower)l=lower;\\n        if(u>upper)u=upper;\\n        cout<<l<<\" \"<<u;\\n        if(u-l+1<=0)return 0;\\n        return u-l+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int n= differences.size();\\n        vector<long long>a(n,0);\\n        long long mn=INT_MAX,mx=INT_MIN;\\n        a[0]= differences[0];\\n        mn=min(mn,a[0]);\\n        mx=max(mx,a[0]);\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i-1]+ differences[i];\\n            mn=min(mn,a[i]);\\n            mx=max(mx,a[i]);\\n        }\\n        int l=lower-mn,u=upper-mx;\\n        if(l<lower)l=lower;\\n        if(u>upper)u=upper;\\n        cout<<l<<\" \"<<u;\\n        if(u-l+1<=0)return 0;\\n        return u-l+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3869322,
                "title": "running-sum",
                "content": "**time: `O(N)`; space: `O(1)`**\\n```\\nint numberOfArrays(vector<int>& d, int L, int U) \\n{\\n\\tlong long m{}, M{};\\n\\tfor(long long s{}; const auto &  d : d)\\n\\t\\ts+=d, M=max(M,s), m=min(m, s);\\n\\treturn max(0ll, (U-L)-(M-m)+1);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numberOfArrays(vector<int>& d, int L, int U) \\n{\\n\\tlong long m{}, M{};\\n\\tfor(long long s{}; const auto &  d : d)\\n\\t\\ts+=d, M=max(M,s), m=min(m, s);\\n\\treturn max(0ll, (U-L)-(M-m)+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3852969,
                "title": "python-one-liner",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find `max` and `min` elements of our `hidden` array `A` which assumed to start with `0`. Differences of margin of these values and margin of `U` and `L` gives us our flexibility which can\\'t be below `0`.\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self,D,L,U):\\n        return max(0,U-L-max(A:=list(accumulate([0]+D)))+min(A)+1)\\n```\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self,D,L,U):\\n        return max(0,U-L-max(A:=list(accumulate([0]+D)))+min(A)+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838322,
                "title": "c-beats-97-detailed-walkthrough",
                "content": "# Intuition\\nConstruct the smallest possible vector in terms of magnitude for the given differences. Then, find how small the smallest value in this vector is compared to the \"lower\". This term is the bias which we can add to the vector to bump it up to the desired range, differences will remain intact. We can keep incrementing all values of the vector by 1 until the largest value in the vector is < \"upper\"\\n\\n# Approach\\n- Construct the smallest vector with the given differences \\n- Bump all values in the vector so that its smallest value = \"lower\" \\n- Check if the above step causes max value of vector to exceed \"higher\" in this case there are 0 solutions \\n- Keep bumping the vector by 1 until its max value exceeds the upper bound\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long findMin(vector<long> arr) {\\n        long minVal = INT_MAX;\\n        for (int i=0; i<arr.size();i++) {\\n            if (arr[i] < minVal) minVal = arr[i];\\n        }\\n        return minVal;\\n    }\\n\\n    long findMax(vector<long> arr) {\\n        long maxVal = INT_MIN;\\n        for (int i=0; i<arr.size();i++) {\\n            if (arr[i] > maxVal) maxVal = arr[i];\\n        }\\n        return maxVal;\\n    }\\n    void incrementVec(vector<long>& arr, long bias) {\\n        for (int i = 0; i < arr.size(); i++) {\\n            arr[i] += bias;\\n        }\\n    }\\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        vector<long> ans; \\n        ans.push_back(lower);\\n        long currVal = 0;\\n\\n        for (int i=0; i<differences.size(); i++) {\\n            currVal = differences[i] + ans[i];\\n            ans.push_back(currVal);\\n        }\\n\\n        long bias = lower - findMin(ans); \\n        incrementVec(ans, bias);\\n        long high = findMax(ans);\\n\\n        if (high > upper) return 0;\\n\\n        int counter = 1;\\n        while (high < upper) {\\n            high ++, counter ++;\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long findMin(vector<long> arr) {\\n        long minVal = INT_MAX;\\n        for (int i=0; i<arr.size();i++) {\\n            if (arr[i] < minVal) minVal = arr[i];\\n        }\\n        return minVal;\\n    }\\n\\n    long findMax(vector<long> arr) {\\n        long maxVal = INT_MIN;\\n        for (int i=0; i<arr.size();i++) {\\n            if (arr[i] > maxVal) maxVal = arr[i];\\n        }\\n        return maxVal;\\n    }\\n    void incrementVec(vector<long>& arr, long bias) {\\n        for (int i = 0; i < arr.size(); i++) {\\n            arr[i] += bias;\\n        }\\n    }\\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        vector<long> ans; \\n        ans.push_back(lower);\\n        long currVal = 0;\\n\\n        for (int i=0; i<differences.size(); i++) {\\n            currVal = differences[i] + ans[i];\\n            ans.push_back(currVal);\\n        }\\n\\n        long bias = lower - findMin(ans); \\n        incrementVec(ans, bias);\\n        long high = findMax(ans);\\n\\n        if (high > upper) return 0;\\n\\n        int counter = 1;\\n        while (high < upper) {\\n            high ++, counter ++;\\n        }\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649311,
                "title": "brute-force-o-n-upper-lower-optimized-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nBrute forece O(N*(upper-lower))\\n\\nclass Solution {\\npublic:\\n   bool check(int i, vector<int>& differences, int upper, int lower){\\n\\n        int ele=i;\\n            for(int j=0; j<differences.size(); j++){\\n                if(ele<=upper && ele>=lower){\\n                ele+=differences[j];\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(ele<=upper && ele>=lower){\\n        return true;}\\n        return false;\\n    }\\n   \\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n        int cnt=0;\\n        for(int i=lower; i<=upper; i++){\\n            if(check(i,differences,upper,lower)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n         \\n    }\\n};\\n\\n\\nOptimized O(N)\\n\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper){\\n\\n        long long sum=0,mini=0,maxi=0;\\n\\n        for(int i=0; i<differences.size(); i++){\\n            sum+=differences[i];\\n            mini=min(mini,sum);\\n            maxi=max(maxi,sum);\\n        }\\n\\n        int upperbound = upper-maxi;\\n        int lowerbound = lower-mini;\\n\\n        if(upperbound-lowerbound+1>0) return upperbound-lowerbound+1;\\n        return 0;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nBrute forece O(N*(upper-lower))\\n\\nclass Solution {\\npublic:\\n   bool check(int i, vector<int>& differences, int upper, int lower){\\n\\n        int ele=i;\\n            for(int j=0; j<differences.size(); j++){\\n                if(ele<=upper && ele>=lower){\\n                ele+=differences[j];\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        if(ele<=upper && ele>=lower){\\n        return true;}\\n        return false;\\n    }\\n   \\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n        int cnt=0;\\n        for(int i=lower; i<=upper; i++){\\n            if(check(i,differences,upper,lower)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n         \\n    }\\n};\\n\\n\\nOptimized O(N)\\n\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper){\\n\\n        long long sum=0,mini=0,maxi=0;\\n\\n        for(int i=0; i<differences.size(); i++){\\n            sum+=differences[i];\\n            mini=min(mini,sum);\\n            maxi=max(maxi,sum);\\n        }\\n\\n        int upperbound = upper-maxi;\\n        int lowerbound = lower-mini;\\n\\n        if(upperbound-lowerbound+1>0) return upperbound-lowerbound+1;\\n        return 0;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647525,
                "title": "c-easy-neat",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n        long neg_diff = 0, pos_diff = 0, cum_diff = 0;\\n        int mn, mx;\\n        \\n        for(int diff: differences){\\n            cum_diff += diff;\\n\\n            neg_diff = min(neg_diff, cum_diff);\\n            pos_diff = max(pos_diff, cum_diff);\\n        }\\n\\n        mn = lower - neg_diff;\\n        mx = upper - pos_diff;\\n\\n        return max(mx-mn+1, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        \\n        long neg_diff = 0, pos_diff = 0, cum_diff = 0;\\n        int mn, mx;\\n        \\n        for(int diff: differences){\\n            cum_diff += diff;\\n\\n            neg_diff = min(neg_diff, cum_diff);\\n            pos_diff = max(pos_diff, cum_diff);\\n        }\\n\\n        mn = lower - neg_diff;\\n        mx = upper - pos_diff;\\n\\n        return max(mx-mn+1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587251,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int minNum = 0, maxNum = 0, curr = 0, res;\\n        for(int diff:differences){\\n            curr += diff;\\n            minNum = min(minNum, curr);\\n            maxNum = max(maxNum, curr);\\n            res =  (upper - lower) - (maxNum - minNum) +1;\\n            if(res < 0){\\n                return 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int minNum = 0, maxNum = 0, curr = 0, res;\\n        for(int diff:differences){\\n            curr += diff;\\n            minNum = min(minNum, curr);\\n            maxNum = max(maxNum, curr);\\n            res =  (upper - lower) - (maxNum - minNum) +1;\\n            if(res < 0){\\n                return 0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562140,
                "title": "easiest-solution-on-leet-code-now",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n                long a = 0, ma = 0, mi = 0;\\n        for (int d: differences) {\\n            a += d;\\n            ma = Math.max(ma, a);\\n            mi = Math.min(mi, a);\\n        }\\n        return (int)Math.max(0, (upper - lower) - (ma - mi) + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n                long a = 0, ma = 0, mi = 0;\\n        for (int d: differences) {\\n            a += d;\\n            ma = Math.max(ma, a);\\n            mi = Math.min(mi, a);\\n        }\\n        return (int)Math.max(0, (upper - lower) - (ma - mi) + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503266,
                "title": "my-solution-is-nothing-special",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min = 0, max = 0, sum = 0;\\n        for (int value : differences) {\\n            sum += value;\\n            min = Math.min(min, sum);\\n            max = Math.max(max, sum);\\n        }\\n        long diffGap = max - min;\\n        return Math.max(upper - lower - (int)diffGap + 1, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min = 0, max = 0, sum = 0;\\n        for (int value : differences) {\\n            sum += value;\\n            min = Math.min(min, sum);\\n            max = Math.max(max, sum);\\n        }\\n        long diffGap = max - min;\\n        return Math.max(upper - lower - (int)diffGap + 1, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435719,
                "title": "solution-with-detailed-approach",
                "content": "# Intuition\\nTo find the number of possible hidden sequences, we need to determine the range of values that the hidden sequence can take. We know that each element in the hidden sequence can be obtained by adding consecutive differences in the given differences array. Therefore, we can reconstruct the hidden sequence by computing the prefix sums of the differences array. Once we have the prefix sums, we can determine the minimum and maximum values that the hidden sequence can take, and count the number of integers within this range.\\n\\n# Approach\\nInitialize a variable sum to 0, and two variables mn and mx to 0.\\n\\nTraverse the differences array from left to right, and for each element diff, update sum as sum + diff.\\n\\nUpdate mn as min(mn, sum) and mx as max(mx, sum).\\n\\nCompute the range of values for the hidden sequence as mn - mx + upper - lower + 1.\\n\\nReturn the number of integers within this range, which is max(0, range).\\n\\n# Complexity\\n- Time complexity:\\nThe solution uses a single pass through the differences array, and performs constant-time operations in each iteration. Therefore, the time complexity of the solution is O(n), where n is the length of the differences array.\\n\\n- Space complexity:\\nThe solution uses a constant amount of extra space, regardless of the size of the input. Therefore, the space complexity of the solution is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long sum = 0, mn = 0, mx = 0;\\n        for (int diff : differences) {\\n            sum += diff;\\n            mn = min(mn, sum);\\n            mx = max(mx, sum);\\n        }\\n        return max(0LL, mn - mx + upper - lower + 1);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long sum = 0, mn = 0, mx = 0;\\n        for (int diff : differences) {\\n            sum += diff;\\n            mn = min(mn, sum);\\n            mx = max(mx, sum);\\n        }\\n        return max(0LL, mn - mx + upper - lower + 1);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421614,
                "title": "c-min-max-accumulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long ma = 0;\\n        long long mi = 0;\\n        long long val = 0;\\n        for(int i = 0; i < differences.size(); i++){\\n            val += differences[i];\\n            ma = max(val, ma);\\n            mi = min(val, mi);\\n        }\\n        long long diff = ma - mi;\\n        if(diff > (upper - lower)) return 0;\\n        return upper - lower - diff + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long ma = 0;\\n        long long mi = 0;\\n        long long val = 0;\\n        for(int i = 0; i < differences.size(); i++){\\n            val += differences[i];\\n            ma = max(val, ma);\\n            mi = min(val, mi);\\n        }\\n        long long diff = ma - mi;\\n        if(diff > (upper - lower)) return 0;\\n        return upper - lower - diff + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370911,
                "title": "c-golang-prefix-sum",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long sum = 0, minimum = 1e12, maximum = -1e12;\\n        for(int i = 0; i < differences.size(); i++) {\\n            sum += differences[i];\\n            minimum = min(minimum, sum);\\n            maximum = max(maximum, sum);\\n        }\\n        return max(0, min(upper, upper - (int)maximum) - max(lower, lower - (int)minimum) + 1);\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int64) int64 {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc numberOfArrays(differences []int, lower int, upper int) int {\\n    var sum, minimum, maximum int64 = 0, 1e12, -1e12\\n    for i := 0; i < len(differences); i++ {\\n        sum += int64(differences[i])\\n        minimum = min(minimum, sum)\\n        maximum = max(maximum, sum)\\n    }\\n    return int(max(0, min(int64(upper), int64(upper) - maximum) - max(int64(lower), int64(lower) - minimum) + 1))\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long sum = 0, minimum = 1e12, maximum = -1e12;\\n        for(int i = 0; i < differences.size(); i++) {\\n            sum += differences[i];\\n            minimum = min(minimum, sum);\\n            maximum = max(maximum, sum);\\n        }\\n        return max(0, min(upper, upper - (int)maximum) - max(lower, lower - (int)minimum) + 1);\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int64) int64 {\\n    if a < b {return a}\\n    return b\\n}\\n\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc numberOfArrays(differences []int, lower int, upper int) int {\\n    var sum, minimum, maximum int64 = 0, 1e12, -1e12\\n    for i := 0; i < len(differences); i++ {\\n        sum += int64(differences[i])\\n        minimum = min(minimum, sum)\\n        maximum = max(maximum, sum)\\n    }\\n    return int(max(0, min(int64(upper), int64(upper) - maximum) - max(int64(lower), int64(lower) - minimum) + 1))\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368801,
                "title": "100-python",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numberOfArrays(self, differences, lower, upper):\\n        lo = hi = k = 0\\n        for diff in differences:\\n            k += diff\\n            if k < lo:\\n                lo = k\\n            elif hi < k:\\n                hi = k\\n        j = 1 + (upper-hi) - (lower - lo)\\n        if j <= -1:\\n            return 0\\n        return j\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numberOfArrays(self, differences, lower, upper):\\n        lo = hi = k = 0\\n        for diff in differences:\\n            k += diff\\n            if k < lo:\\n                lo = k\\n            elif hi < k:\\n                hi = k\\n        j = 1 + (upper-hi) - (lower - lo)\\n        if j <= -1:\\n            return 0\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359254,
                "title": "scala-2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def numberOfArrays(differences: Array[Int], lower: Int, upper: Int): Int = {\\n        val acc = differences.foldLeft(List(0L))((acc, cur) =>{(acc.head + cur) +: acc})\\n        Math.max(0, (upper - lower) - (acc.max - acc.min) + 1).toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def numberOfArrays(differences: Array[Int], lower: Int, upper: Int): Int = {\\n        val acc = differences.foldLeft(List(0L))((acc, cur) =>{(acc.head + cur) +: acc})\\n        Math.max(0, (upper - lower) - (acc.max - acc.min) + 1).toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3262015,
                "title": "c-cumulative-sum-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        ll maxInc = 0, maxDec = 0, tmp = 0;\\n        for (int i = 0; i < differences.size(); ++ i) {\\n            tmp += differences[i];\\n            maxInc = max(maxInc, tmp);\\n            maxDec = min(maxDec, tmp);\\n        }\\n        if (upper - maxInc < lower - maxDec) return 0;\\n        return (upper - maxInc - lower + maxDec + 1);\\n    }\\n};        \\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        ll maxInc = 0, maxDec = 0, tmp = 0;\\n        for (int i = 0; i < differences.size(); ++ i) {\\n            tmp += differences[i];\\n            maxInc = max(maxInc, tmp);\\n            maxDec = min(maxDec, tmp);\\n        }\\n        if (upper - maxInc < lower - maxDec) return 0;\\n        return (upper - maxInc - lower + maxDec + 1);\\n    }\\n};        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247790,
                "title": "c-easy-math-solution",
                "content": "# Approach\\nThe output array will be a, a+x, a+x+y, a+x+y+z... where x, y, z... are the elements of difference array. How did I reach this result? Let the original array be [a,b,c,d] and difference array be [x,y,z] now **b-a = x, c-b = y** and **d-c = z**. Now representing all variables in terms of **a** we get **b = a+x**, **c = b+y** and **b = a+x** so **c = a+x+y** and **d = a+x+y+z**. Now we can check if the maximum and minimum element of our array satisfy the values of **a** by putting different values and increasing the count hence the count will be our final answer. We are checking minimum and maximum because if they lie in between lower and upper variables then all elements would lie in between the range.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        int n = diff.size();\\n        int cnt=0;\\n        vector<long long> arr(n+1);\\n        arr[0] = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i+1] = arr[i]+diff[i];\\n        }\\n        sort(arr.begin(),arr.end());\\n        int mini = arr[0];\\n        int maxi = arr[n];\\n        for(int i=lower;i<=upper;i++)\\n        {\\n            if(i+mini>=lower && i+maxi<=upper)\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        int n = diff.size();\\n        int cnt=0;\\n        vector<long long> arr(n+1);\\n        arr[0] = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i+1] = arr[i]+diff[i];\\n        }\\n        sort(arr.begin(),arr.end());\\n        int mini = arr[0];\\n        int maxi = arr[n];\\n        for(int i=lower;i<=upper;i++)\\n        {\\n            if(i+mini>=lower && i+maxi<=upper)\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201121,
                "title": "c",
                "content": "```\\nint numberOfArrays(int* differences, int differencesSize, int lower, int upper){\\n    int n = differencesSize + 1 ;\\n    long long* arr = malloc(n * sizeof(long long)) ;\\n    arr[0] = 0 ;\\n    long long min = arr[0] ;\\n    long long max = arr[0] ;\\n    for(int i = 1; i < n; i++){\\n        arr[i] = arr[i-1] + differences[i-1] ;\\n        min = fminl(min, arr[i]) ;\\n        max = fmaxl(max, arr[i]) ;\\n    }\\n    if((max-min) > (upper-lower))\\n        return 0 ;\\n    return (upper-lower) - (max-min) + 1 ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint numberOfArrays(int* differences, int differencesSize, int lower, int upper){\\n    int n = differencesSize + 1 ;\\n    long long* arr = malloc(n * sizeof(long long)) ;\\n    arr[0] = 0 ;\\n    long long min = arr[0] ;\\n    long long max = arr[0] ;\\n    for(int i = 1; i < n; i++){\\n        arr[i] = arr[i-1] + differences[i-1] ;\\n        min = fminl(min, arr[i]) ;\\n        max = fmaxl(max, arr[i]) ;\\n    }\\n    if((max-min) > (upper-lower))\\n        return 0 ;\\n    return (upper-lower) - (max-min) + 1 ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3085226,
                "title": "java-sol-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ndp[i][1] => store max value\\ndp[i][0] => store min value\\nif min>max => return 0\\nelse max-min + 1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int n = differences.length;\\n        int dp[][] = new int[n+1][2];\\n        dp[n][0] = lower;\\n        dp[n][1] = upper; \\n        for(int i=n-1;i>=0;i--){\\n            dp[i][1] = Math.min(dp[i+1][1] - differences[i], upper);\\n            dp[i][0] = Math.max(dp[i+1][0] - differences[i], lower);\\n            if(dp[i][0] > upper || dp[i][1] < lower) return 0;\\n        }\\n        return Math.abs(dp[0][0] - dp[0][1])+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int n = differences.length;\\n        int dp[][] = new int[n+1][2];\\n        dp[n][0] = lower;\\n        dp[n][1] = upper; \\n        for(int i=n-1;i>=0;i--){\\n            dp[i][1] = Math.min(dp[i+1][1] - differences[i], upper);\\n            dp[i][0] = Math.max(dp[i+1][0] - differences[i], lower);\\n            if(dp[i][0] > upper || dp[i][1] < lower) return 0;\\n        }\\n        return Math.abs(dp[0][0] - dp[0][1])+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988990,
                "title": "dead-simple-rust-solution",
                "content": "# Intuition\\nThis boils down into \\'what\\'s the difference between the largest and smallest value in the hidden array\\'.  So, that\\'s pretty much the only heavy lifting that needs to be done.\\n\\nAlso, I was careful to calculate whether \\'relative_val\\' could overflow an i32.  If you were to add 10^5 to itself 10^5 times, you get 10^10, which does overflow any 32 bit type.\\n\\n# Approach\\nThe only little optimization present here is to use a branchless inner loop.  std::cmp::max and std::cmp::min are branchless operations, at least on x86_64.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn number_of_arrays(differences: Vec<i32>, lower: i32, upper: i32) -> i32 {\\n        let mut max = 0;\\n        let mut min = 0;\\n        let mut relative_val = 0 as i64;\\n        for i in differences.into_iter() {\\n            relative_val += i as i64;\\n            max = std::cmp::max(max, relative_val);\\n            min = std::cmp::min(min, relative_val);\\n        }\\n        let difference = max - min;\\n        let input_diff = upper - lower;\\n        std::cmp::max(input_diff as i64 - difference + 1, 0) as i32\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn number_of_arrays(differences: Vec<i32>, lower: i32, upper: i32) -> i32 {\\n        let mut max = 0;\\n        let mut min = 0;\\n        let mut relative_val = 0 as i64;\\n        for i in differences.into_iter() {\\n            relative_val += i as i64;\\n            max = std::cmp::max(max, relative_val);\\n            min = std::cmp::min(min, relative_val);\\n        }\\n        let difference = max - min;\\n        let input_diff = upper - lower;\\n        std::cmp::max(input_diff as i64 - difference + 1, 0) as i32\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950697,
                "title": "o-n-time-complexity-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        Min = Max = 0\\n        Sum = 0\\n        for n in differences:\\n            Sum += n\\n            Min = min(Min, Sum)\\n            Max = max(Max, Sum)\\n        \\n        C = Max - Min\\n        N = upper - lower + 1\\n        if N - C > 0:\\n            return N - C\\n\\n        return 0\\n\\n\\n\\n\\n        # ans = 0\\n        # for i in range(lower, upper + 1):\\n        #     cur = i\\n        #     valid_seq = True\\n        #     j = 0\\n        #     while j < len(differences) and valid_seq:\\n        #         cur += differences[j]\\n        #         if cur < lower or upper < cur:\\n        #             valid_seq = False\\n        #         j += 1\\n\\n        #     if valid_seq:\\n        #         ans += 1\\n\\n        # return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        Min = Max = 0\\n        Sum = 0\\n        for n in differences:\\n            Sum += n\\n            Min = min(Min, Sum)\\n            Max = max(Max, Sum)\\n        \\n        C = Max - Min\\n        N = upper - lower + 1\\n        if N - C > 0:\\n            return N - C\\n\\n        return 0\\n\\n\\n\\n\\n        # ans = 0\\n        # for i in range(lower, upper + 1):\\n        #     cur = i\\n        #     valid_seq = True\\n        #     j = 0\\n        #     while j < len(differences) and valid_seq:\\n        #         cur += differences[j]\\n        #         if cur < lower or upper < cur:\\n        #             valid_seq = False\\n        #         j += 1\\n\\n        #     if valid_seq:\\n        #         ans += 1\\n\\n        # return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922564,
                "title": "ruby-solution-brute-force-optimized",
                "content": "### Brute Force: TLE\\nWorst case time is **O(m*n)** where:\\n\\tm = upper - lower\\n\\tn = differences.size\\n```\\ndef number_of_arrays(differences, lower, upper)\\n    count = 0\\n    (lower..upper).each do |starter|\\n        temp = starter + differences[0]\\n        i = 1\\n        while i < differences.size && boundary_check(temp, lower, upper)\\n            temp = temp + differences[i]\\n            i += 1\\n        end\\n        count += 1 if i == differences.size && boundary_check(temp, lower, upper)\\n    end\\n\\t\\n    return count\\nend\\n\\ndef boundary_check(val, lower, upper)\\n    return val >= lower && val <= upper ? true : false\\nend\\n```\\n\\n\\n### O(n) optimized:\\n```\\ndef number_of_arrays(differences, lower, upper)\\n    temp = [0]\\n    differences.each_with_index { |diff, idx| temp << temp[idx] + diff }\\n\\t\\n    acceptable_window_size = upper - lower\\n    amt_of_deviation = temp.max - temp.min\\n    num_hidden_sequences = acceptable_window_size - amt_of_deviation + 1\\n    \\n    #  negative num_hidden_sequences means none fit the criteria\\n    return [0, num_hidden_sequences].max\\nend\\n```\\n\\nBrute force approach is pretty straightforward. I was pretty disappointed to get TLE as this is how I would write the code in a production environment. \\n* We iterate for every value between the lower and upper boundaries. \\n\\t* Using each of these as a starting point, we calculate the next hidden value and save it as the variable ```temp```. \\n\\t* If ```boundary_check``` returns false on ```temp``` we go to the next ```starter``` \\n\\t* If we reach the end of ```differences``` , we increment ```count```\\n\\nThe trick with the optimized solution is to have each index of ```temp``` represent the distance that you\\'re deviating from the starting value. \\n* ```temp.max```  is the most you deviate in the positive direction\\n* ```temp.min``` is the most you deviate in the negative direction\\n* ```temp.max - temp.min``` is the size of our deviation window\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef number_of_arrays(differences, lower, upper)\\n    count = 0\\n    (lower..upper).each do |starter|\\n        temp = starter + differences[0]\\n        i = 1\\n        while i < differences.size && boundary_check(temp, lower, upper)\\n            temp = temp + differences[i]\\n            i += 1\\n        end\\n        count += 1 if i == differences.size && boundary_check(temp, lower, upper)\\n    end\\n\\t\\n    return count\\nend\\n\\ndef boundary_check(val, lower, upper)\\n    return val >= lower && val <= upper ? true : false\\nend\\n```\n```\\ndef number_of_arrays(differences, lower, upper)\\n    temp = [0]\\n    differences.each_with_index { |diff, idx| temp << temp[idx] + diff }\\n\\t\\n    acceptable_window_size = upper - lower\\n    amt_of_deviation = temp.max - temp.min\\n    num_hidden_sequences = acceptable_window_size - amt_of_deviation + 1\\n    \\n    #  negative num_hidden_sequences means none fit the criteria\\n    return [0, num_hidden_sequences].max\\nend\\n```\n```temp```\n```boundary_check```\n```temp```\n```starter```\n```differences```\n```count```\n```temp```\n```temp.max```\n```temp.min```\n```temp.max - temp.min```",
                "codeTag": "Python3"
            },
            {
                "id": 2877694,
                "title": "python-short-and-intuitive-o-n-solution",
                "content": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        \\n        a, b = lower, upper # start with maximum range\\n        for i in range(len(differences)):\\n            \\n            # get the next element range\\n            a += differences[i]\\n            b += differences[i]\\n            \\n            # normalize element\\'s range if possible(i.e: new range intersects with [lower, upper]), return 0 otherwise\\n            if a <= lower <= b or lower <= a <= upper:\\n                a, b = max(a, lower), min(b, upper)\\n            else:\\n                return 0\\n                \\n        return b - a + 1 # the length of range\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        \\n        a, b = lower, upper # start with maximum range\\n        for i in range(len(differences)):\\n            \\n            # get the next element range\\n            a += differences[i]\\n            b += differences[i]\\n            \\n            # normalize element\\'s range if possible(i.e: new range intersects with [lower, upper]), return 0 otherwise\\n            if a <= lower <= b or lower <= a <= upper:\\n                a, b = max(a, lower), min(b, upper)\\n            else:\\n                return 0\\n                \\n        return b - a + 1 # the length of range\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2859078,
                "title": "java-c-best-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ -->\\n\\n- Space complexity:\\n $$O(1)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long mx=0,mn=0,sum=0;\\n        for(int x : differences){\\n            sum += x;\\n            mx = max(mx,sum);\\n            mn = min(mn,sum);\\n        }\\n        int count = (upper-mx) - (lower-mn) + 1;\\n        return max(0,count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Number Theory",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long mx=0,mn=0,sum=0;\\n        for(int x : differences){\\n            sum += x;\\n            mx = max(mx,sum);\\n            mn = min(mn,sum);\\n        }\\n        int count = (upper-mx) - (lower-mn) + 1;\\n        return max(0,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840090,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min = lower;\\n        long max = lower;\\n        long start = lower;\\n        for(int difference : differences)\\n        {\\n            start+=difference;\\n            min = Math.min(min,start);\\n            max = Math.max(max,start);\\n        }\\n        if(min < lower)\\n        {\\n            long diff = lower-min;\\n            min += diff;\\n            max += diff;\\n        }\\n        if(max > upper)\\n        {\\n            return 0;\\n        }\\n        return (int)(upper-max+1L);\\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min = lower;\\n        long max = lower;\\n        long start = lower;\\n        for(int difference : differences)\\n        {\\n            start+=difference;\\n            min = Math.min(min,start);\\n            max = Math.max(max,start);\\n        }\\n        if(min < lower)\\n        {\\n            long diff = lower-min;\\n            min += diff;\\n            max += diff;\\n        }\\n        if(max > upper)\\n        {\\n            return 0;\\n        }\\n        return (int)(upper-max+1L);\\n\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824240,
                "title": "easiest-possible-solution-with-explaination",
                "content": "# Intuition\\nFind the lowest number that would work and the highest number that would work. Answer will be all the numbers between them and they themselves.\\n\\n# Approach\\n1. Find the highest/rightmost value that satisfies the hidden sequence using binary search.\\n2. Find the lowest/leftmost value that satisfies the hidden sequence using binary search.\\n3. Answer would be the numbers between them inclusive of themselves.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N*log(upper-lower+1))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        l = lower\\n        r = upper\\n        right = float(\"-inf\")\\n\\n        while l <= r:\\n            mid = l+r>>1\\n\\n            isHidden,condition = self.isHiddenSequence(differences,mid,lower,upper)\\n            if isHidden:\\n                right = mid\\n                l = mid + 1\\n            else:\\n                if condition == \"HIGH\": r = mid - 1\\n                else: l = mid + 1\\n        \\n        l = lower\\n        r = upper\\n        left = float(\"inf\")\\n\\n        while l <= r:\\n            mid = l+r>>1\\n\\n            isHidden,condition = self.isHiddenSequence(differences,mid,lower,upper)\\n            if isHidden:\\n                left = mid\\n                r = mid - 1\\n            else:\\n                if condition == \"HIGH\": r = mid - 1\\n                else: l = mid + 1\\n\\n        if right == float(\"-inf\") or left == float(\"inf\"): return 0\\n        return right - left + 1\\n\\n    def isHiddenSequence(self,differences,start,lower,upper):\\n        cur_sum = start\\n        for difference in differences:\\n            cur_sum += difference\\n            if cur_sum < lower: return False,\"LOW\"\\n            if cur_sum > upper: return False,\"HIGH\"\\n\\n        return True,\"PERFECT\"\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        l = lower\\n        r = upper\\n        right = float(\"-inf\")\\n\\n        while l <= r:\\n            mid = l+r>>1\\n\\n            isHidden,condition = self.isHiddenSequence(differences,mid,lower,upper)\\n            if isHidden:\\n                right = mid\\n                l = mid + 1\\n            else:\\n                if condition == \"HIGH\": r = mid - 1\\n                else: l = mid + 1\\n        \\n        l = lower\\n        r = upper\\n        left = float(\"inf\")\\n\\n        while l <= r:\\n            mid = l+r>>1\\n\\n            isHidden,condition = self.isHiddenSequence(differences,mid,lower,upper)\\n            if isHidden:\\n                left = mid\\n                r = mid - 1\\n            else:\\n                if condition == \"HIGH\": r = mid - 1\\n                else: l = mid + 1\\n\\n        if right == float(\"-inf\") or left == float(\"inf\"): return 0\\n        return right - left + 1\\n\\n    def isHiddenSequence(self,differences,start,lower,upper):\\n        cur_sum = start\\n        for difference in differences:\\n            cur_sum += difference\\n            if cur_sum < lower: return False,\"LOW\"\\n            if cur_sum > upper: return False,\"HIGH\"\\n\\n        return True,\"PERFECT\"\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773818,
                "title": "easy-python-solution",
                "content": "\\n\\t\\t\\t\\t\\t\\t\\tclass Solution:\\n\\t\\t\\t\\t\\t\\t\\t\\tdef numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tl=[0]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor i in differences:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tl.append(l[-1]+i)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn max(0,(upper-lower+1)-(max(l)-min(l)))\\n",
                "solutionTags": [],
                "code": "\\n\\t\\t\\t\\t\\t\\t\\tclass Solution:\\n\\t\\t\\t\\t\\t\\t\\t\\tdef numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tl=[0]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfor i in differences:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tl.append(l[-1]+i)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn max(0,(upper-lower+1)-(max(l)-min(l)))\\n",
                "codeTag": "Java"
            },
            {
                "id": 2760847,
                "title": "c-concise",
                "content": "```\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long xmin = 0, xmax = 0, sum = 0;\\n        for(int x:differences){\\n            sum+=x;\\n            xmin = min(xmin, sum);\\n            xmax = max(xmax, sum);\\n        }\\n        return max<long long>(0, upper - lower - (xmax -xmin) + 1);\\n    }",
                "solutionTags": [],
                "code": "```\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long xmin = 0, xmax = 0, sum = 0;\\n        for(int x:differences){\\n            sum+=x;\\n            xmin = min(xmin, sum);\\n            xmax = max(xmax, sum);\\n        }\\n        return max<long long>(0, upper - lower - (xmax -xmin) + 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2754844,
                "title": "go-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst find the hidden array with the smallest value that satisfies the condition, and the other arrays that satisfies the condition can be obtained by adding 1 to them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can build the hidden array once starting with `lower`, and then see if the largest(`max`) and smallest number(`min`) in the array is in the [`lower`,`upper`]. If `min` is smaller than `lower`, it means the first number in the hidden array should be larger than lower (equals `lower`+`lower`-`min`), and the `max` also need add the difference(`lower`-`min`). Then, the difference between `upper` and `max` is the result(if `upper` less than `max`, the result is 0).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc numberOfArrays(differences []int, lower int, upper int) int {\\n    // find `min` and `max`\\n    minN, maxN := lower, lower\\n    for i, curr := 0, lower; i < len(differences); i++ {\\n        curr += differences[i]\\n        minN = min(minN, curr)\\n        maxN = max(maxN, curr)\\n    }\\n\\n    // check if need enlarge `max`\\n    if minN < lower {\\n        maxN += lower-minN\\n    }\\n\\n    // `max` is greater than `upper`, the hidden array doesn\\'t exist.\\n    if maxN > upper {\\n        return 0\\n    }\\n\\n    return upper-maxN+1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numberOfArrays(differences []int, lower int, upper int) int {\\n    // find `min` and `max`\\n    minN, maxN := lower, lower\\n    for i, curr := 0, lower; i < len(differences); i++ {\\n        curr += differences[i]\\n        minN = min(minN, curr)\\n        maxN = max(maxN, curr)\\n    }\\n\\n    // check if need enlarge `max`\\n    if minN < lower {\\n        maxN += lower-minN\\n    }\\n\\n    // `max` is greater than `upper`, the hidden array doesn\\'t exist.\\n    if maxN > upper {\\n        return 0\\n    }\\n\\n    return upper-maxN+1\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2753968,
                "title": "java-calculating-margin",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int N = differences.length;\\n        long cur = 0;\\n        long min = 0;\\n        long max = 0;\\n\\n        for(int i=0; i<N; i++) {\\n            cur = cur + differences[i];\\n            min = Math.min(min, cur);\\n            max = Math.max(max, cur);\\n        }\\n\\n        long leftMargin = lower-min;\\n        long rightMargin = upper-max;\\n\\n        return rightMargin-leftMargin >= 0 ? (int)(rightMargin-leftMargin+1) : 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int N = differences.length;\\n        long cur = 0;\\n        long min = 0;\\n        long max = 0;\\n\\n        for(int i=0; i<N; i++) {\\n            cur = cur + differences[i];\\n            min = Math.min(min, cur);\\n            max = Math.max(max, cur);\\n        }\\n\\n        long leftMargin = lower-min;\\n        long rightMargin = upper-max;\\n\\n        return rightMargin-leftMargin >= 0 ? (int)(rightMargin-leftMargin+1) : 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746398,
                "title": "python-prefix-sum-o-n-time-solution-with-explanation",
                "content": "**Explanation**\\n\\t- the basic idea  is to find the first sequence by starting from \"start\" as lower bound and storing the maximum and the minimum element in the same time by  using prifix sum\\n\\t- if the minimum value is lower than \"start\" so each element of this array should need to uplifted by value \"start -minimum\"\\n\\t- the maximum value is also uplifted by the above case \\n\\t- so our answer will be the number of steps we can uplift the maximum to reach the \"upper\" which is \"upper - maximum +1 \" we added 1 because the current arr is also the part of the solution\\n\\t- we will return -1 if  \"maximum\" is greater than \"upper\\n\\t\\n**complexity**\\n\\t\\t- time : O(n)\\n\\t\\t- space : O(1)\\n```\\n class Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        minimum = float(inf)\\n        maximum = lower\\n        prefixsum= lower\\n\\t\\t\\n        for i in range(len(differences)):\\n            prefixsum = prefixsum + differences[i]\\n            minimum = min(prefixsum,minimum)\\n            maximum = max(prefixsum,maximum)\\n       \\n        if minimum < lower :\\n            maximum += (lower-minimum)\\n        return 1+(upper-maximum) if maximum <=upper else 0\\n        \\n            \\n```\\n\\n   **upvote if you find it good and simple**",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\n class Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        minimum = float(inf)\\n        maximum = lower\\n        prefixsum= lower\\n\\t\\t\\n        for i in range(len(differences)):\\n            prefixsum = prefixsum + differences[i]\\n            minimum = min(prefixsum,minimum)\\n            maximum = max(prefixsum,maximum)\\n       \\n        if minimum < lower :\\n            maximum += (lower-minimum)\\n        return 1+(upper-maximum) if maximum <=upper else 0\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692277,
                "title": "python-solution-with-explanation-o-n-time-o-1-space",
                "content": "Here is my solution in Python with an explanation.\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        \"\"\"\\n        Time complexity: O(n)\\n        Space complexity: O(1)\\n        \\n        Proof of correctness:\\n        1.) Say that differences = [d1,d2,...,dn]\\n        2.) Then the ith element (0-based) in hidden is hidden[0]+d1+d2+...+dn\\n        3.) Then the minimum element is min(hidden[0]+d1+d2+...+di) = hidden[0] + min(d1+d2+...+di) for some i in [0,n]\\n            |-> The min is our minc value\\n        4.) And the maximum element is max(hidden[0]+d1+d2+...+dj) = hidden[0] + max(d1+d2+...+dj) for some j in [0,n]\\n            |-> The max is our maxc value\\n        \\n        5.) Now, if [lower, upper] are the bounds of hidden, then hidden[0]+minc >= lower and hidden[0]+maxc <= upper\\n        6.) Then min(hidden[0]) = lower-minc, and max(hidden[0]) = upper+maxc\\n        \\n        7.) Then there are (upper-maxc) - (lower-minc) + 1 possible values for hidden[0]\\n        \\n        8.) We can say that there is a one-to-one and onto mapping hidden[0]->hidden[i] for any 0 <= i < n \\n            |-> Therefore the number of possible hidden[i]\\'s is the same as the number of possible hidden[0]\\'s for any i\\n        9.) Therefore the answer is (upper-maxc) - (lower-minc) + 1, assuming it\\'s nonnegative. \\n\\t\\t10.) If the value is negative, then there are no such solutions, so we output 0 as the problem statement asks us to do :)\\n        \"\"\"\\n        minc = 0\\n        maxc = 0\\n        csum = 0\\n        \\n        for diff in differences:\\n            csum += diff\\n            maxc = max(maxc, csum)\\n            minc = min(minc, csum)\\n        \\n        return max(0, (upper-maxc) - (lower-minc) + 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        \"\"\"\\n        Time complexity: O(n)\\n        Space complexity: O(1)\\n        \\n        Proof of correctness:\\n        1.) Say that differences = [d1,d2,...,dn]\\n        2.) Then the ith element (0-based) in hidden is hidden[0]+d1+d2+...+dn\\n        3.) Then the minimum element is min(hidden[0]+d1+d2+...+di) = hidden[0] + min(d1+d2+...+di) for some i in [0,n]\\n            |-> The min is our minc value\\n        4.) And the maximum element is max(hidden[0]+d1+d2+...+dj) = hidden[0] + max(d1+d2+...+dj) for some j in [0,n]\\n            |-> The max is our maxc value\\n        \\n        5.) Now, if [lower, upper] are the bounds of hidden, then hidden[0]+minc >= lower and hidden[0]+maxc <= upper\\n        6.) Then min(hidden[0]) = lower-minc, and max(hidden[0]) = upper+maxc\\n        \\n        7.) Then there are (upper-maxc) - (lower-minc) + 1 possible values for hidden[0]\\n        \\n        8.) We can say that there is a one-to-one and onto mapping hidden[0]->hidden[i] for any 0 <= i < n \\n            |-> Therefore the number of possible hidden[i]\\'s is the same as the number of possible hidden[0]\\'s for any i\\n        9.) Therefore the answer is (upper-maxc) - (lower-minc) + 1, assuming it\\'s nonnegative. \\n\\t\\t10.) If the value is negative, then there are no such solutions, so we output 0 as the problem statement asks us to do :)\\n        \"\"\"\\n        minc = 0\\n        maxc = 0\\n        csum = 0\\n        \\n        for diff in differences:\\n            csum += diff\\n            maxc = max(maxc, csum)\\n            minc = min(minc, csum)\\n        \\n        return max(0, (upper-maxc) - (lower-minc) + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675107,
                "title": "python3-solution-o-n-time-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prev=0\\n        minVal,maxVal=0,0\\n        #min  max initialize\\n        for i in differences:\\n            curr=i+prev\\n            if curr<minVal:\\n                minVal=curr\\n            elif curr>maxVal:\\n                maxVal=curr\\n            prev=curr\\n        \\n        if lower-minVal<=upper-maxVal:\\n            return (upper-maxVal)-(lower-minVal)+1\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prev=0\\n        minVal,maxVal=0,0\\n        #min  max initialize\\n        for i in differences:\\n            curr=i+prev\\n            if curr<minVal:\\n                minVal=curr\\n            elif curr>maxVal:\\n                maxVal=curr\\n            prev=curr\\n        \\n        if lower-minVal<=upper-maxVal:\\n            return (upper-maxVal)-(lower-minVal)+1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669733,
                "title": "javascript-prefix-sum-solution",
                "content": "/**\\n * @param {number[]} differences\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar numberOfArrays = function(differences, lower, upper) {\\n    \\n    let arr=[0]\\n    for(let i=0;i<differences.length;i++){\\n        arr[i+1]=differences[i]+arr[i]\\n    }\\n    let range=Math.max(...arr)-Math.min(...arr)\\n    \\n    let ans=upper-lower+1-range\\n    \\n    if(ans<1) return 0\\n    else return ans\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "/**\\n * @param {number[]} differences\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar numberOfArrays = function(differences, lower, upper) {\\n    \\n    let arr=[0]\\n    for(let i=0;i<differences.length;i++){\\n        arr[i+1]=differences[i]+arr[i]\\n    }\\n    let range=Math.max(...arr)-Math.min(...arr)\\n    \\n    let ans=upper-lower+1-range\\n    \\n    if(ans<1) return 0\\n    else return ans\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2654806,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef numberOfArrays(self, diff, lower, upper):\\n\\t\\t\\tA = list(accumulate(diff, initial = 0))\\n\\t\\t\\treturn max(0, (upper - lower) - (max(A) - min(A)) + 1)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numberOfArrays(self, diff, lower, upper):\\n\\t\\t\\tA = list(accumulate(diff, initial = 0))\\n\\t\\t\\treturn max(0, (upper - lower) - (max(A) - min(A)) + 1)",
                "codeTag": "Java"
            },
            {
                "id": 2626087,
                "title": "fundamental-approach-c-math-trick",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long mini = 0, maax = 0, sum = 0;\\n        for(auto diff: differences) {\\n            sum += diff;\\n            mini = min(sum, mini);\\n            maax = max(sum, maax);\\n        }\\n        long high = upper - maax;\\n        long low = lower - mini;\\n        cout<<high;\\n        return ((high-low+1)>0)?(high-low+1):0;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long mini = 0, maax = 0, sum = 0;\\n        for(auto diff: differences) {\\n            sum += diff;\\n            mini = min(sum, mini);\\n            maax = max(sum, maax);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2427130,
                "title": "c-easy-understanding-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    every sequence is fixed with taking first element\\n    need to check for every element in lower-higher, if the sequence is possible\\n    a1 a2 a3 a4\\n    d1 d2 d3      a1 = a1\\n    a2 = a1+d1    a2 = a1+d1 \\n    a3 = a2+d2 -> a3 = a1+d1+d2\\n    a4 = a3+d3 -> a4 = a1+d1+d2+d3\\n    \\n    need to find smallest and largest sum of d1+....+di\\n    and check if a1+smallest is more than equal to lower\\n    and check if a1+largest is less than eqaul to upper\\n        \\n    */\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long mx = -1e11;\\n        long mn = 1e11;\\n        long sm = 0;\\n        for(auto val:differences){\\n            sm+=1LL*val;\\n            mn = min(mn,sm);\\n            mx = max(mx,sm);\\n        }\\n        int ans = 0;\\n        for(int choice = lower;choice<=upper;choice++){\\n            if( (1LL*choice+mx <= 1LL*upper) && (1LL*choice+mn >= 1LL*lower) ) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    every sequence is fixed with taking first element\\n    need to check for every element in lower-higher, if the sequence is possible\\n    a1 a2 a3 a4\\n    d1 d2 d3      a1 = a1\\n    a2 = a1+d1    a2 = a1+d1 \\n    a3 = a2+d2 -> a3 = a1+d1+d2\\n    a4 = a3+d3 -> a4 = a1+d1+d2+d3\\n    \\n    need to find smallest and largest sum of d1+....+di\\n    and check if a1+smallest is more than equal to lower\\n    and check if a1+largest is less than eqaul to upper\\n        \\n    */\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long mx = -1e11;\\n        long mn = 1e11;\\n        long sm = 0;\\n        for(auto val:differences){\\n            sm+=1LL*val;\\n            mn = min(mn,sm);\\n            mx = max(mx,sm);\\n        }\\n        int ans = 0;\\n        for(int choice = lower;choice<=upper;choice++){\\n            if( (1LL*choice+mx <= 1LL*upper) && (1LL*choice+mn >= 1LL*lower) ) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406668,
                "title": "intuitive-simple-implementation-explained",
                "content": "Just assume u start with the lowest element....you form the array...you find the maximum and minimum of the array..if minimum is below the given lower, you will have to uplift every elemnt of array so that the minimum becomes the given \\'lower\\',...now find the, how far is the current maximum from the given upper....these many solutions are possible. if its negative that means while trying to bring minimum to \\'lower\\' , you overflowed the upper and thus zero solutions are possible.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        vector<long long> ans;\\n        ans.push_back(lower);\\n        long long maxi = lower;\\n        long long mini = lower;\\n        for(auto x:diff){\\n            ans.push_back((long long)x+ans.back());\\n            maxi = max(ans.back(),maxi);\\n            mini = min(ans.back(),mini);\\n        }\\n        if(mini<lower){\\n            long long yu = lower-mini;\\n            maxi += yu;\\n        }\\n        int anss = upper-maxi+1;\\n        return (anss>0?anss:0);\\n    }\\n};\\n\\n// differences = [1, -3, 4], lower = 1, upper = 6\\n// start with 1 -> 1 2 -1 3 -> minimum = -1 and maximum = 3\\n// to bring -1 to 1 -> add 2 to all elemnts, thus maximum becomes 5\\n// 3 4 1 5\\n// now the current maximum is 1 away from the given upper...thus 2 is the answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        vector<long long> ans;\\n        ans.push_back(lower);\\n        long long maxi = lower;\\n        long long mini = lower;\\n        for(auto x:diff){\\n            ans.push_back((long long)x+ans.back());\\n            maxi = max(ans.back(),maxi);\\n            mini = min(ans.back(),mini);\\n        }\\n        if(mini<lower){\\n            long long yu = lower-mini;\\n            maxi += yu;\\n        }\\n        int anss = upper-maxi+1;\\n        return (anss>0?anss:0);\\n    }\\n};\\n\\n// differences = [1, -3, 4], lower = 1, upper = 6\\n// start with 1 -> 1 2 -1 3 -> minimum = -1 and maximum = 3\\n// to bring -1 to 1 -> add 2 to all elemnts, thus maximum becomes 5\\n// 3 4 1 5\\n// now the current maximum is 1 away from the given upper...thus 2 is the answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363766,
                "title": "java-prefix-sum-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int min = 0, max = 0, sum = 0 ;\\n        \\n        for (int i = 0; i < differences.length; i++) {\\n            sum += differences[i] ;\\n            if (min > sum) min = sum ;\\n            if (max < sum) max = sum ;\\n            if (max-min > upper-lower) return 0 ;\\n        }\\n        \\n        int result = (upper-max) - (lower-min) + 1 ;\\n        return result ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        int min = 0, max = 0, sum = 0 ;\\n        \\n        for (int i = 0; i < differences.length; i++) {\\n            sum += differences[i] ;\\n            if (min > sum) min = sum ;\\n            if (max < sum) max = sum ;\\n            if (max-min > upper-lower) return 0 ;\\n        }\\n        \\n        int result = (upper-max) - (lower-min) + 1 ;\\n        return result ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335435,
                "title": "python3-prefix-sum-tc-o-n-sc-o-1-explained",
                "content": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        #Firstly, imagine array A with lower as the first element A[0] and the rest elements be defined by A[i+1] = A[i] + diff[i].\\n        #If minimum element of A is less than lower, we have to add (lower - min(A)) to all elements. Let this new array be denoted by B. \\n        #By the way, as max(B) should be less than or equal to upper, the following inequality must hold.\\n        #  max(B) =  max(A) + (lower - min(A)) <= upper. (1)\\n        #Now what we have to do is check whether (1) holds or not.\\n        minA = maxA = cur = lower \\n        for diff in differences:\\n            cur += diff\\n            minA = min(minA, cur)\\n            maxA = max(maxA, cur)\\n            \\n        if upper - maxA - (lower - minA) < 0:\\n            return 0\\n        \\n        return upper - maxA - lower + minA + 1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        #Firstly, imagine array A with lower as the first element A[0] and the rest elements be defined by A[i+1] = A[i] + diff[i].\\n        #If minimum element of A is less than lower, we have to add (lower - min(A)) to all elements. Let this new array be denoted by B. \\n        #By the way, as max(B) should be less than or equal to upper, the following inequality must hold.\\n        #  max(B) =  max(A) + (lower - min(A)) <= upper. (1)\\n        #Now what we have to do is check whether (1) holds or not.\\n        minA = maxA = cur = lower \\n        for diff in differences:\\n            cur += diff\\n            minA = min(minA, cur)\\n            maxA = max(maxA, cur)\\n            \\n        if upper - maxA - (lower - minA) < 0:\\n            return 0\\n        \\n        return upper - maxA - lower + minA + 1",
                "codeTag": "Java"
            },
            {
                "id": 2321159,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long lo = lower;\\n        long long hi = upper;\\n        long long sum = 0;\\n        for(int i = 0; i < differences.size(); i++) {\\n            sum += differences[i];\\n            lo = max(lo, lower-sum);\\n            hi = min(hi, upper-sum);\\n        }\\n        return max(0ll, hi-lo+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long lo = lower;\\n        long long hi = upper;\\n        long long sum = 0;\\n        for(int i = 0; i < differences.size(); i++) {\\n            sum += differences[i];\\n            lo = max(lo, lower-sum);\\n            hi = min(hi, upper-sum);\\n        }\\n        return max(0ll, hi-lo+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296963,
                "title": "python-simple-prefix-sum",
                "content": "\\n    def numberOfArrays(self, differences, lower, upper):\\n        low = high = total = 0\\n        \\n        for i in differences:\\n            total += i\\n            low = min(low, total)\\n            high = max(high, total)\\n            \\n        return max(0, 1 + upper - lower - (high - low))",
                "solutionTags": [],
                "code": "\\n    def numberOfArrays(self, differences, lower, upper):\\n        low = high = total = 0\\n        \\n        for i in differences:\\n            total += i\\n            low = min(low, total)\\n            high = max(high, total)\\n            \\n        return max(0, 1 + upper - lower - (high - low))",
                "codeTag": "Python3"
            },
            {
                "id": 2290553,
                "title": "c-easy-understanding-prefix-sum-good-question",
                "content": "```\\n int numberOfArrays(vector<int>& diff, int l, int u) {\\n        \\n       int n=diff.size();\\n        \\n        long long min_ele=0;\\n        long long max_ele=0;\\n        \\n        long long sum=0;\\n        \\n       for(int i=0;i<n;i++)\\n       {\\n          sum+=diff[i];\\n           \\n           min_ele=min(min_ele , sum);\\n           max_ele=max(max_ele , sum);\\n       }\\n        \\n       long long v = (u-max_ele)-(l-min_ele);\\n        \\n       long long ans = max( 0 , (int) v+1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\n int numberOfArrays(vector<int>& diff, int l, int u) {\\n        \\n       int n=diff.size();\\n        \\n        long long min_ele=0;\\n        long long max_ele=0;\\n        \\n        long long sum=0;\\n        \\n       for(int i=0;i<n;i++)\\n       {\\n          sum+=diff[i];\\n           \\n           min_ele=min(min_ele , sum);\\n           max_ele=max(max_ele , sum);\\n       }\\n        \\n       long long v = (u-max_ele)-(l-min_ele);\\n        \\n       long long ans = max( 0 , (int) v+1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286214,
                "title": "intuitive-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        // \\n        // f(n) = start + acc(diff(0, n));\\n        // start + 1 - 3 + 4\\n        // lower <= f(n) and f(n) <= upper\\n        // once first number determined, the rest is determined\\n        \\n        int res = 0;\\n        \\n        long long low = LONG_LONG_MAX;\\n        long long high = LONG_LONG_MIN;\\n        long long acc = 0;\\n        for (auto d : differences) {\\n            acc += d;\\n            low = min(low, acc);\\n            high = max(high, acc);\\n        }\\n        \\n        long long start_low = max((long long)lower, lower - low);\\n        long long start_high = min((long long)upper, upper - high);\\n        \\n        if (start_low > start_high)\\n            return 0;\\n        \\n        return start_high - start_low + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        // \\n        // f(n) = start + acc(diff(0, n));\\n        // start + 1 - 3 + 4\\n        // lower <= f(n) and f(n) <= upper\\n        // once first number determined, the rest is determined\\n        \\n        int res = 0;\\n        \\n        long long low = LONG_LONG_MAX;\\n        long long high = LONG_LONG_MIN;\\n        long long acc = 0;\\n        for (auto d : differences) {\\n            acc += d;\\n            low = min(low, acc);\\n            high = max(high, acc);\\n        }\\n        \\n        long long start_low = max((long long)lower, lower - low);\\n        long long start_high = min((long long)upper, upper - high);\\n        \\n        if (start_low > start_high)\\n            return 0;\\n        \\n        return start_high - start_low + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256286,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        vector<long long> v(differences.size()+1);\\n        v[0]=0;\\n        for (int i=1;i<v.size();i++) v[i]=differences[i-1]+v[i-1];\\n        int ans=(upper-lower)+(*min_element(v.begin(),v.end())-*max_element(v.begin(),v.end()))+1;\\n        if (ans<0) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        vector<long long> v(differences.size()+1);\\n        v[0]=0;\\n        for (int i=1;i<v.size();i++) v[i]=differences[i-1]+v[i-1];\\n        int ans=(upper-lower)+(*min_element(v.begin(),v.end())-*max_element(v.begin(),v.end()))+1;\\n        if (ans<0) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252193,
                "title": "easy-clear-solution-with-68-tc-and-85-sc",
                "content": "```\\nmaxx = minn = start = 0\\nfor i in differences:\\n\\tstart += i\\n\\tminn = min(minn, start)\\n\\tmaxx = max(maxx, start)\\nreturn max(0, (upper-lower)-(maxx-minn)+1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nmaxx = minn = start = 0\\nfor i in differences:\\n\\tstart += i\\n\\tminn = min(minn, start)\\n\\tmaxx = max(maxx, start)\\nreturn max(0, (upper-lower)-(maxx-minn)+1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201845,
                "title": "python-easy-understand-solution",
                "content": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        cum_sum = [0]\\n        for diff in differences:\\n            cum_sum.append(cum_sum[-1]+diff)\\n    \\n        max_diff = max(cum_sum)-min(cum_sum)\\n        \\n\\t\\tif upper-lower < max_diff:\\n            return 0\\n        \\n\\t\\treturn upper-lower-max_diff+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        cum_sum = [0]\\n        for diff in differences:\\n            cum_sum.append(cum_sum[-1]+diff)\\n    \\n        max_diff = max(cum_sum)-min(cum_sum)\\n        \\n\\t\\tif upper-lower < max_diff:\\n            return 0\\n        \\n\\t\\treturn upper-lower-max_diff+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159031,
                "title": "python3-solution-binary-search-approach",
                "content": "\\'\\'\\'\\nThe approach here is to check within the bounds ( [lower, upper] ) for a solution ( a list of numbers that satisfy the difference -> the min number >= lower and the max number <= upper, min and max from that list). After finding that case we just return the difference between upper and lower + 1 and subtract the diff between max and min from that list.\\nAs an observation: We can see that every next list of numbers that satisfy the condition has an min and max bigger with 1 than the last one. (Because of that we need only a valid case since the list min and max will move in that range and binary search will find the way for that).\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        def check(differences, a, lower, upper):\\n            my_min, my_max = math.inf, -math.inf\\n            possible = True\\n            my_min = min(my_min, a)\\n            my_max = max(my_max, a)\\n            for j in range(len(differences)):\\n                a = a + differences[j]\\n                my_min = min(my_min, a)\\n                my_max = max(my_max, a)\\n                if lower > a or a > upper:\\n                    possible = False\\n                    break\\n            if possible:\\n                return True, my_min, my_max\\n            return False, my_min, my_max\\n        \\n        start = lower\\n        end = upper\\n        while start <= end:\\n            mid = (start+end)//2\\n            b, minX, maxX = check(differences, mid, lower, upper)\\n            if b:\\n                return upper-lower+1 - (maxX-minX)\\n            else:\\n                if minX < lower:\\n                    start = mid + 1\\n                elif maxX > upper:\\n                    end = mid - 1\\n        return 0\\n```\\n\\'\\'\\'\\nIf you like it, please upvote!^^",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        def check(differences, a, lower, upper):\\n            my_min, my_max = math.inf, -math.inf\\n            possible = True\\n            my_min = min(my_min, a)\\n            my_max = max(my_max, a)\\n            for j in range(len(differences)):\\n                a = a + differences[j]\\n                my_min = min(my_min, a)\\n                my_max = max(my_max, a)\\n                if lower > a or a > upper:\\n                    possible = False\\n                    break\\n            if possible:\\n                return True, my_min, my_max\\n            return False, my_min, my_max\\n        \\n        start = lower\\n        end = upper\\n        while start <= end:\\n            mid = (start+end)//2\\n            b, minX, maxX = check(differences, mid, lower, upper)\\n            if b:\\n                return upper-lower+1 - (maxX-minX)\\n            else:\\n                if minX < lower:\\n                    start = mid + 1\\n                elif maxX > upper:\\n                    end = mid - 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107206,
                "title": "c-with-description-running-total-o-n",
                "content": "If we assume the first element of the hypotetical array equals to `x`, then:\\n- the 2nd element equals to `x + hidden[0]`, \\n- the 3rd element equals to `x + hidden[0] + hidden[1]`, \\n- etc.\\n\\nNow we need to figure out what\\'s the max and min value we can reach for the `hidden` array values. For calculated max and min we check the **lowest possible** value and the **highest possible** value. Number of possible arrays is **the count of numbers between highest and lowest possible** value for `x`\\n```\\npublic class Solution\\n{\\n\\tpublic int NumberOfArrays(int[] differences, int lower, int upper)\\n\\t{\\n\\t\\tvar min = int.MaxValue;\\n\\t\\tvar max = int.MinValue;\\n\\t\\tvar sumDiff = 0;\\n\\t\\tforeach (var d in differences)\\n\\t\\t{\\n\\t\\t\\tsumDiff += d;\\n\\t\\t\\tmin = Math.Min(min, sumDiff);\\n\\t\\t\\tmax = Math.Max(max, sumDiff);\\n\\t\\t}\\n\\n\\t\\tvar lowestPossibleNum = Math.Max(lower, lower + max);\\n\\t\\tvar highestPossibleNum = Math.Min(upper, upper + min);\\n\\n\\t\\tif (highestPossibleNum < lowestPossibleNum)\\n\\t\\t\\treturn 0;\\n\\n\\t\\treturn highestPossibleNum - lowestPossibleNum + 1;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n\\tpublic int NumberOfArrays(int[] differences, int lower, int upper)\\n\\t{\\n\\t\\tvar min = int.MaxValue;\\n\\t\\tvar max = int.MinValue;\\n\\t\\tvar sumDiff = 0;\\n\\t\\tforeach (var d in differences)\\n\\t\\t{\\n\\t\\t\\tsumDiff += d;\\n\\t\\t\\tmin = Math.Min(min, sumDiff);\\n\\t\\t\\tmax = Math.Max(max, sumDiff);\\n\\t\\t}\\n\\n\\t\\tvar lowestPossibleNum = Math.Max(lower, lower + max);\\n\\t\\tvar highestPossibleNum = Math.Min(upper, upper + min);\\n\\n\\t\\tif (highestPossibleNum < lowestPossibleNum)\\n\\t\\t\\treturn 0;\\n\\n\\t\\treturn highestPossibleNum - lowestPossibleNum + 1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979873,
                "title": "python-3-prefix-sum-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        low = high = cur = 0\\n        for diff in differences:\\n            cur += diff\\n            low = min(low, cur)\\n            high = max(high, cur)\\n        \\n        return max(0, 1 + upper - lower - (high - low))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        low = high = cur = 0\\n        for diff in differences:\\n            cur += diff\\n            low = min(low, cur)\\n            high = max(high, cur)\\n        \\n        return max(0, 1 + upper - lower - (high - low))",
                "codeTag": "Java"
            },
            {
                "id": 1920390,
                "title": "beats-100-percent-cpp-solutions-prefix-sums",
                "content": "class Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n      int ct =0;\\n        int n=differences.size();\\n        long long  pre[n];\\n        pre[0]=differences[0];\\n        long long maxi=-1e9;\\n        long long mini=1e9;\\n        for(int i =1;i<n;i++){\\n            pre[i]=pre[i-1]+differences[i];\\n        }\\n        for(auto x:pre){\\n            maxi=max(maxi,x);\\n            mini=min(mini,x);\\n                \\n        }\\n        for(int i =lower;i<=upper;i++)\\n            \\n        {\\n           // bool flag =false;\\n            long long curr =i;\\n          if(curr+maxi<=upper && curr+mini>=lower){\\n              ct++;\\n          }\\n         \\n            \\n        }\\n        return ct;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n      int ct =0;\\n        int n=differences.size();\\n        long long  pre[n];\\n        pre[0]=differences[0];\\n        long long maxi=-1e9;\\n        long long mini=1e9;\\n        for(int i =1;i<n;i++){\\n            pre[i]=pre[i-1]+differences[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1909654,
                "title": "c-o-n-time-easy-to-understand-with-detailed-explanation",
                "content": "```\\n //Logic :- \\n    //      for differences = {1,-3,4} and upper = 6 and lower = 1\\n    //          let first term of hidden term is a \\n    //          then the hidden array is {a,a+1,a-2,a+2};\\n    //              now the largest term of array should be <= upper \\n    //                  a + 2 <= upper  => a <= upper - 2  \\n                        //  => a <= 4 \\n    //              now the smallest term of array should be >= lower\\n    //                  a-2 >= lower => a >= lower + 2 \\n                        //  => a >= 3\\n    //              So, we got a>= 3 and a <= 4\\n    //                  so possible values for a = 3,4\\n    //                      therefore 2 hidden sequences possible\\n    //                  here if lower + 2 was higher than upper -2 \\n    //                      a would have 0 possible values \\n    //   The same approach is used in code below\\n    //      Please upvote if found helpful :)\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int n = differences.size();\\n        vector<int> a(n+1,0);\\n        int maxi = 0 , mini = 0;\\n        for(int i = 1;i<n+1;i++)\\n        {\\n            a[i] = a[i-1] + differences[i-1];\\n            maxi = max(maxi,a[i]);\\n            mini = min(mini,a[i]);\\n            if((upper - maxi) < (lower - mini))\\n                return 0;\\n        }\\n        if((upper - maxi) < (lower - mini))\\n            return 0;\\n        return ((upper - maxi) - (lower - mini ) + 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n //Logic :- \\n    //      for differences = {1,-3,4} and upper = 6 and lower = 1\\n    //          let first term of hidden term is a \\n    //          then the hidden array is {a,a+1,a-2,a+2};\\n    //              now the largest term of array should be <= upper \\n    //                  a + 2 <= upper  => a <= upper - 2  \\n                        //  => a <= 4 \\n    //              now the smallest term of array should be >= lower\\n    //                  a-2 >= lower => a >= lower + 2 \\n                        //  => a >= 3\\n    //              So, we got a>= 3 and a <= 4\\n    //                  so possible values for a = 3,4\\n    //                      therefore 2 hidden sequences possible\\n    //                  here if lower + 2 was higher than upper -2 \\n    //                      a would have 0 possible values \\n    //   The same approach is used in code below\\n    //      Please upvote if found helpful :)\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int n = differences.size();\\n        vector<int> a(n+1,0);\\n        int maxi = 0 , mini = 0;\\n        for(int i = 1;i<n+1;i++)\\n        {\\n            a[i] = a[i-1] + differences[i-1];\\n            maxi = max(maxi,a[i]);\\n            mini = min(mini,a[i]);\\n            if((upper - maxi) < (lower - mini))\\n                return 0;\\n        }\\n        if((upper - maxi) < (lower - mini))\\n            return 0;\\n        return ((upper - maxi) - (lower - mini ) + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842094,
                "title": "c-o-n-solution-2145",
                "content": "As we were given the differences of all adjacent values of original array so we can find the the original array by traversing lower to upper and checking the each in between value in the range but it would give TLE\\nIf we think it in a different way such as we were given the continuous sum so that we can find the maximum and minimum addition to the first value choosen at every index in the array and check whether it is in the range or not. So lower and upper serve to check the maximum and minimum values we would ever get during the array traversal.\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long minAdd = INT_MAX,maxAdd = INT_MIN,sum = 0;\\n        for(int diff : differences){\\n            sum += diff;\\n            minAdd = min(minAdd,sum);\\n            maxAdd = max(maxAdd,sum);\\n        }\\n\\t\\t//return max(0LL,1+upper-lower-maxAdd+minAdd); will also work.\\n\\t\\t//For sake of detailed process happening elaborated below\\n        lower = (long long)(lower);\\n        upper = (long long)(upper);\\n        long long l = (lower > lower-minAdd) ? lower : lower-minAdd;\\n        long long r = (upper < upper-maxAdd) ? upper : upper-maxAdd;\\n        return (r-l+1 < 0) ? 0 : r-l+1;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long minAdd = INT_MAX,maxAdd = INT_MIN,sum = 0;\\n        for(int diff : differences){\\n            sum += diff;\\n            minAdd = min(minAdd,sum);\\n            maxAdd = max(maxAdd,sum);\\n        }\\n\\t\\t//return max(0LL,1+upper-lower-maxAdd+minAdd); will also work.\\n\\t\\t//For sake of detailed process happening elaborated below\\n        lower = (long long)(lower);\\n        upper = (long long)(upper);\\n        long long l = (lower > lower-minAdd) ? lower : lower-minAdd;\\n        long long r = (upper < upper-maxAdd) ? upper : upper-maxAdd;\\n        return (r-l+1 < 0) ? 0 : r-l+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800556,
                "title": "c-explained-using-maths-inequalities",
                "content": "Let **mxDiff**, **mnDiff** be the maximum and minimum cummulative difference from *hidden[0]*. Thats what the for loop is calculating.\\nLets call *hidden[0]* as **k**.\\n\\nNotice that if we fix the first element of hidden as **k** then all elements in *hidden* will fall in range **[mnDiff + k, mxDiff + k]**\\nWe have to make sure this range is falling inside **[lower, upper]**\\n\\nWe need to find out how many k are there so that the following inequalities are satisfied:\\n* **lower <= mnDiff + k <= upper**    rewritten as ---->   **lower - mnDiff <= k <= upper - mnDiff**\\n* **lower <= mxDiff + k <= upper**  rewritten as ----> **lower - mxDiff <= k <= upper - mxDiff**\\n* Also since k is the first element,  **lower <= k <= upper**\\n\\nThese can be combined to result the following:\\n**max({lower - mnDiff, lower - mxDiff, lower})  <= k <= min({upper - mnDiff, upper - mxDiff, upper})**\\nCan be simplified to:\\n**max(lower - mnDiff, lower) <= k <= min(upper - mxDiff, upper)**   \\nsince **mxDiff >= mnDiff**\\n\\n\\n```\\n\\nint numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        long long mxDiff = -1e15, mnDiff = 1e15;\\n        long long sum = 0;\\n        for (int i = 0; i < diff.size(); i++) {\\n            sum += diff[i];\\n            mxDiff = max(mxDiff, sum);\\n            mnDiff = min(mnDiff, sum);\\n        }\\n        long long left = max(1LL * lower, lower - mnDiff), right = min(1LL * upper, upper - mxDiff);\\n        return max(0LL, right - left + 1);\\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        long long mxDiff = -1e15, mnDiff = 1e15;\\n        long long sum = 0;\\n        for (int i = 0; i < diff.size(); i++) {\\n            sum += diff[i];\\n            mxDiff = max(mxDiff, sum);\\n            mnDiff = min(mnDiff, sum);\\n        }\\n        long long left = max(1LL * lower, lower - mnDiff), right = min(1LL * upper, upper - mxDiff);\\n        return max(0LL, right - left + 1);\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1799245,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long x_left = lower, x_right = upper;\\n        long long sum = 0;\\n        for (int diff : differences) {\\n            sum += diff;\\n            x_left = max(x_left, lower - sum);\\n            x_right = min(x_right, upper - sum);\\n        }\\n        return x_left <= x_right ? x_right - x_left + 1: 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long x_left = lower, x_right = upper;\\n        long long sum = 0;\\n        for (int diff : differences) {\\n            sum += diff;\\n            x_left = max(x_left, lower - sum);\\n            x_right = min(x_right, upper - sum);\\n        }\\n        return x_left <= x_right ? x_right - x_left + 1: 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797302,
                "title": "simple-one-pass-o-n-solution-python-3",
                "content": "If we know the hidden[0] value, the rest of string is inferred uniquely. we try with assuming hidde[0]=lower and then adjust it if conflicts arises (some vlaue become smaller than hidden[0]). same thing for upper...\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        min_val = lower\\n        max_val = upper\\n        curr_min_val = min_val\\n        curr_max_val = max_val\\n        for val in differences:\\n            curr_min_val += val\\n            curr_max_val += val\\n            if curr_min_val < min_val:\\n                min_val = curr_min_val\\n            if curr_max_val > max_val:\\n                max_val = curr_max_val\\n        \\n        if lower > min_val:\\n            lower += (lower-min_val)\\n        if upper < max_val:\\n            upper -= (max_val-upper)\\n        \\n        return max(0, upper-lower+1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        min_val = lower\\n        max_val = upper\\n        curr_min_val = min_val\\n        curr_max_val = max_val\\n        for val in differences:\\n            curr_min_val += val\\n            curr_max_val += val\\n            if curr_min_val < min_val:\\n                min_val = curr_min_val\\n            if curr_max_val > max_val:\\n                max_val = curr_max_val\\n        \\n        if lower > min_val:\\n            lower += (lower-min_val)\\n        if upper < max_val:\\n            upper -= (max_val-upper)\\n        \\n        return max(0, upper-lower+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787700,
                "title": "python-o-n-generate-the-min-possible-array-and-increment-each",
                "content": "The idea is super simple: \\n1. we just generate one array by setting the first element to 0\\n2. increase every element by `x` so that the minimum of the array equals to `lower`\\n3. the result is the `1 + (upper - max(array))`. `upper - max(array)` is the number of times that we can increase every element by 1\\n\\nLooking at the above steps, you should notice that we don\\'t really need to keep every element of the array, because we only care about the max and min. So we can just use two variables to keep track of max and min, and do the calculation.\\n\\n```python\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        min_val = max_val = last = 0\\n        for diff in differences:\\n            last += diff\\n            min_val = min(last, min_val)\\n            max_val = max(last, max_val)\\n        diff = lower - min_val\\n        min_val += diff\\n        max_val += diff\\n        if max_val > upper: return 0\\n        return 1 + upper - max_val\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        min_val = max_val = last = 0\\n        for diff in differences:\\n            last += diff\\n            min_val = min(last, min_val)\\n            max_val = max(last, max_val)\\n        diff = lower - min_val\\n        min_val += diff\\n        max_val += diff\\n        if max_val > upper: return 0\\n        return 1 + upper - max_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771025,
                "title": "python-with-short-comments",
                "content": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        acc = list(accumulate(differences))\\n        i = max(lower-min(acc),lower) # lower bounds of start point\\n        u = min(upper-max(acc),upper) # upper bounds of start point\\n        return max(u-i+1,0) # number of start points between lower and upper bounds\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        acc = list(accumulate(differences))\\n        i = max(lower-min(acc),lower) # lower bounds of start point\\n        u = min(upper-max(acc),upper) # upper bounds of start point\\n        return max(u-i+1,0) # number of start points between lower and upper bounds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769390,
                "title": "python-4-lines-o-n-beats-96",
                "content": "Find the range needed for the sequence (via accumulated sum, prepending 0 for the first \\'hidden\\' element) and directly compute the result from the lower and upper bounds. \\n\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prefix_sum = [0,] + list(itertools.accumulate(differences, operator.add))\\n        min_sum = min(prefix_sum)\\n        max_sum = max(prefix_sum)\\n        return max(0, upper - lower + 1 - abs(max_sum-min_sum))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        prefix_sum = [0,] + list(itertools.accumulate(differences, operator.add))\\n        min_sum = min(prefix_sum)\\n        max_sum = max(prefix_sum)\\n        return max(0, upper - lower + 1 - abs(max_sum-min_sum))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765923,
                "title": "simple-java-solution",
                "content": "\\n```\\n    public int numberOfArrays(int[] diff, int lower, int upper) {\\n        int res = 0, max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        boolean flag = true;\\n        int[] newArr = new int[diff.length+1];\\n        int[] pre = new int[diff.length];\\n        pre[0] = diff[0];\\n        for(int i=1;i<pre.length;i++){\\n            pre[i] = pre[i-1] + diff[i];\\n        }\\n        for(int i=0;i<pre.length;i++){\\n            max = Math.max(pre[i],max);\\n            min = Math.min(pre[i],min);\\n        }\\n        for(int i=lower;i<=upper;i++){\\n            if(min+i>=lower && max+i <= upper)\\n                res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numberOfArrays(int[] diff, int lower, int upper) {\\n        int res = 0, max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        boolean flag = true;\\n        int[] newArr = new int[diff.length+1];\\n        int[] pre = new int[diff.length];\\n        pre[0] = diff[0];\\n        for(int i=1;i<pre.length;i++){\\n            pre[i] = pre[i-1] + diff[i];\\n        }\\n        for(int i=0;i<pre.length;i++){\\n            max = Math.max(pre[i],max);\\n            min = Math.min(pre[i],min);\\n        }\\n        for(int i=lower;i<=upper;i++){\\n            if(min+i>=lower && max+i <= upper)\\n                res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1754149,
                "title": "java-o-n-by-narrowing-boundaries",
                "content": "```\\nclass Solution {\\n  public int numberOfArrays(int[] differences, int lower, int upper) {\\n    long sumDiff = 0;\\n    long peak = Long.MIN_VALUE;\\n    long trough = Long.MAX_VALUE;\\n    for (int difference : differences) {\\n      sumDiff += difference;\\n      peak = Math.max(peak, sumDiff);\\n      trough = Math.min(trough, sumDiff);\\n    }\\n    if (trough > 0) {\\n      trough = 0;\\n    }\\n    if (peak < 0) {\\n      peak = 0;\\n    }\\n    long res = (upper-Math.abs(peak))-(lower+Math.abs(trough));\\n    return res < 0 ? 0 : (int)(res+1);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int numberOfArrays(int[] differences, int lower, int upper) {\\n    long sumDiff = 0;\\n    long peak = Long.MIN_VALUE;\\n    long trough = Long.MAX_VALUE;\\n    for (int difference : differences) {\\n      sumDiff += difference;\\n      peak = Math.max(peak, sumDiff);\\n      trough = Math.min(trough, sumDiff);\\n    }\\n    if (trough > 0) {\\n      trough = 0;\\n    }\\n    if (peak < 0) {\\n      peak = 0;\\n    }\\n    long res = (upper-Math.abs(peak))-(lower+Math.abs(trough));\\n    return res < 0 ? 0 : (int)(res+1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753026,
                "title": "short-simple-code",
                "content": "```\\nclass Solution {\\n    public static int numberOfArrays(int[] arr, int l, int u) {\\n        int n = arr.length, mn = Integer.MAX_VALUE, mx = Integer.MIN_VALUE;\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            j += arr[i];\\n            mn = Math.min(j, mn);\\n            mx = Math.max(mx, j);\\n        }\\n        long z=0, tmp=Math.min(u, u - mx);\\n        tmp-= Math.max(l, l - mn);\\n        ++tmp;\\n        if(tmp<z)\\n            return 0;\\n        return (int) tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int numberOfArrays(int[] arr, int l, int u) {\\n        int n = arr.length, mn = Integer.MAX_VALUE, mx = Integer.MIN_VALUE;\\n        for (int i = 0, j = 0; i < n; ++i) {\\n            j += arr[i];\\n            mn = Math.min(j, mn);\\n            mx = Math.max(mx, j);\\n        }\\n        long z=0, tmp=Math.min(u, u - mx);\\n        tmp-= Math.max(l, l - mn);\\n        ++tmp;\\n        if(tmp<z)\\n            return 0;\\n        return (int) tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734919,
                "title": "2145-python3-o-n-easy-to-understand-runtime-1136-ms-97-51-faster-memory-28-8-mb",
                "content": "Fix the first element of the hidden sequence to any value x and ignore the given bounds. Notice that we can then determine all the other elements of the sequence by using the differences array.\\n\\nWe will also be able to determine the difference between the minimum and maximum elements of the sequence. Notice that the value of x does not affect this.\\n\\nWe now have the \\u2018range\\u2019 of the sequence (difference between min and max element), we can then calculate how many ways there are to fit this range into the given range of lower to upper.\\n\\nAnswer is (upper - lower + 1) - (range of sequence)\\n\\n```\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        sub_lower = 0\\n        sub_upper = 0\\n        hidden = 0\\n\\n        for diff in differences:\\n            hidden += diff\\n            if hidden > sub_upper:\\n                sub_upper = hidden\\n            if hidden < sub_lower:\\n                sub_lower = hidden\\n\\n        sub_range = sub_upper - sub_lower\\n        range_ = upper - lower\\n        res = range_ - sub_range + 1\\n        \\n        return res if res > 0 else 0\\n\\n# Time: O(N)\\n# Space: O(1)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/702970fe-8d1f-48ea-babe-b30e0e317172_1643653766.1429477.png)\\n\\n![image](https://assets.leetcode.com/users/images/c5d2b909-b291-422b-8682-8f52733844e6_1643653771.1497252.png)\\n\\n--------\\n--------\\n**Find this solution and many others on my Github:** https://github.com/dimon41k2010/LeetCodeTasks/blob/main/2145-count-the-hidden-sequences/2145-count-the-hidden-sequences.py\\n\\n**Please upvote if it makes sence and helpful to you. Let\\'s stay motivated! Peace.**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        sub_lower = 0\\n        sub_upper = 0\\n        hidden = 0\\n\\n        for diff in differences:\\n            hidden += diff\\n            if hidden > sub_upper:\\n                sub_upper = hidden\\n            if hidden < sub_lower:\\n                sub_lower = hidden\\n\\n        sub_range = sub_upper - sub_lower\\n        range_ = upper - lower\\n        res = range_ - sub_range + 1\\n        \\n        return res if res > 0 else 0\\n\\n# Time: O(N)\\n# Space: O(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1734438,
                "title": "python-simple-diagram-one-pass-with-min-max",
                "content": "**Intuition/Sketch**\\nFor this problem, have the following visualization in mind: \\n![image](https://assets.leetcode.com/users/images/e7b387d9-f793-44f1-ba99-0f1d9b352b62_1643639748.687121.png)\\n`hidden` here can take one value (blue), zero values (red), or multiple values (green) if we imagine sliding the entire `hidden` sequence up and down the vertical axis. `max(min)_delta` is the difference between the greatest(least) value in `hidden` and `hidden[0]`.  We maintain a running sum along `differences`, keeping track of the max/min values attained, which will give us `max(min)_delta`. Then, the number of sequences is something like the difference between `max_delta - min_delta` and `upper-lower`.\\n\\n **Algorithm**\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        max_delta, min_delta = 0, 0\\n        running_sum = 0\\n        for diff in differences: \\n            running_sum = running_sum + diff\\n            max_delta, min_delta = max(max_delta, running_sum), min(min_delta, running_sum)\\n        delta = max_delta - min_delta\\n        gamma = upper - lower \\n        return max(0, gamma - delta + 1)\\n```\\n**Details**\\nWe return `max(gamma - delta + 1, 0)` because if `gamma = delta`, there is one hidden sequence. If `gamma > delta` then there are no sequences. \\n**Complexity Analysis**\\nThe runtime complexity is *O(n)* because we do a single pass through `differences`. The space complexity is `O(1)` because we store a constant number of int variables.",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        max_delta, min_delta = 0, 0\\n        running_sum = 0\\n        for diff in differences: \\n            running_sum = running_sum + diff\\n            max_delta, min_delta = max(max_delta, running_sum), min(min_delta, running_sum)\\n        delta = max_delta - min_delta\\n        gamma = upper - lower \\n        return max(0, gamma - delta + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729634,
                "title": "c-one-pass-with-explanations",
                "content": "This question is equivalent to find the total number of the valid first elements. Please check the comments along with the code, or more details at https://algorithm-notes-allinone.blogspot.com/2022/01/leetcode-2145-count-hidden-sequences.html\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long sum = 0, mn = differences[0], mx = mn;\\n        for(auto &a : differences) {\\n            sum += a;\\n            mn = min(mn, sum);\\n            mx = max(mx, sum);\\n        }\\n        // d0: the first element\\n        // d_min: the min element exclude d0\\n        // d_max: the max element exclude d0\\n        // d_min - d0 = mn ---> d_min = d0 + mn\\n        // d_max - d0 = mx ---> d_max = d0 + mx\\n        // lower(L) <= di <= upper(R) for all i, so\\n        // (1) L <= d0 + mn <= R ---> L - mn <= d0 <= R - mn\\n        // (2) L <= d0 + mx <= R ---> L - mx <= d0 <= R - mx\\n        // (3) L <= d0 <= R\\n        // combine (1) - (3)\\n        // max(L-mn, L) <= d0 <= min(R, R - mx)\\n        // so question becomes: how many valid d0?\\n        long l = max((long)lower, lower - mn), r = min((long)upper, upper - mx);\\n        return r >= l ? r - l + 1 : 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long sum = 0, mn = differences[0], mx = mn;\\n        for(auto &a : differences) {\\n            sum += a;\\n            mn = min(mn, sum);\\n            mx = max(mx, sum);\\n        }\\n        // d0: the first element\\n        // d_min: the min element exclude d0\\n        // d_max: the max element exclude d0\\n        // d_min - d0 = mn ---> d_min = d0 + mn\\n        // d_max - d0 = mx ---> d_max = d0 + mx\\n        // lower(L) <= di <= upper(R) for all i, so\\n        // (1) L <= d0 + mn <= R ---> L - mn <= d0 <= R - mn\\n        // (2) L <= d0 + mx <= R ---> L - mx <= d0 <= R - mx\\n        // (3) L <= d0 <= R\\n        // combine (1) - (3)\\n        // max(L-mn, L) <= d0 <= min(R, R - mx)\\n        // so question becomes: how many valid d0?\\n        long l = max((long)lower, lower - mn), r = min((long)upper, upper - mx);\\n        return r >= l ? r - l + 1 : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729529,
                "title": "my-in-contest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int &lower, int &upper) {\\n        long long int ans=0,n=differences.size(),mini=1e7,maxa=-1e7;\\n        vector<long long int>v(n+1);\\n        v[0]=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            v[i] = (differences[i-1]+v[i-1]);\\n        }\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            mini=min(mini,v[i]);\\n            maxa=max(maxa,v[i]);\\n        }\\n        \\n        // cout<<mini<<\" \"<<maxa<<\"\\\\n\";\\n        mini=lower-mini;\\n        maxa=upper-maxa;\\n        \\n        ans = maxa-mini+1;\\n        \\n        if(ans>=0)\\n            return ans;\\n        else\\n            return 0;\\n    }\\n};\\n\\n// v[i+1] - v[i] = diff[i]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int &lower, int &upper) {\\n        long long int ans=0,n=differences.size(),mini=1e7,maxa=-1e7;\\n        vector<long long int>v(n+1);\\n        v[0]=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            v[i] = (differences[i-1]+v[i-1]);\\n        }\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            mini=min(mini,v[i]);\\n            maxa=max(maxa,v[i]);\\n        }\\n        \\n        // cout<<mini<<\" \"<<maxa<<\"\\\\n\";\\n        mini=lower-mini;\\n        maxa=upper-maxa;\\n        \\n        ans = maxa-mini+1;\\n        \\n        if(ans>=0)\\n            return ans;\\n        else\\n            return 0;\\n    }\\n};\\n\\n// v[i+1] - v[i] = diff[i]\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1726747,
                "title": "intuitive-python-two-ways-but-only-one-is-suggested",
                "content": "It is actually the variation of the values that matters. Start with a value of 0 (which does NOT matter), find the max value and the min value via traversing the differences. If max-min == upper - lower, we have only one option, let min = lower and max = upper. Else if max-min < upper - lower, there are more possibilities. Else no chance. The answer would be (upper-lower) - (max-min) + 1. Note that \"2145b\" took less than 50 % time that the compact implementation with built-in functions \\u201C2145a\\u201D did, because at most one block of the if/elif statement would be implemented.\\n\\n# 2145a\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        mn = mx = v = 0\\n        for diff in differences:\\n            v += diff\\n            mn, mx = min(mn, v), max(mx, v)\\n        vary, interval = mx-mn, upper-lower\\n        return 0 if vary > interval else interval-vary+1\\n```\\n\\n# 2145b\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        mn = mx = v = 0\\n        for diff in differences:\\n            v += diff\\n            if v < mn:\\n                mn = v\\n            elif v > mx:\\n                mx = v\\n        vary, interval = mx-mn, upper-lower\\n        return 0 if vary > interval else interval-vary+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        mn = mx = v = 0\\n        for diff in differences:\\n            v += diff\\n            mn, mx = min(mn, v), max(mx, v)\\n        vary, interval = mx-mn, upper-lower\\n        return 0 if vary > interval else interval-vary+1\\n```\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        mn = mx = v = 0\\n        for diff in differences:\\n            v += diff\\n            if v < mn:\\n                mn = v\\n            elif v > mx:\\n                mx = v\\n        vary, interval = mx-mn, upper-lower\\n        return 0 if vary > interval else interval-vary+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726638,
                "title": "c-straight-forward-solution-with-description",
                "content": "First, lets creating hidden array relatively to **0** value(hidden[0] = 0). Then, by defining min/max values, finding hidden positions for **min and max** which should not exceed Lower and Upper values. After the difference between them will be answer: \\n```\\npublic class Solution {\\n    public int NumberOfArrays(int[] diffs, int lower, int upper) {\\n        int[] hidden = new int[diffs.Length + 1];\\n        int min = 0, max = 0;\\n        for (int i = 0; i < hidden.Length - 1; i++) {\\n            hidden[i + 1] = hidden[i] + diffs[i];\\n            min = Math.Min(min, hidden[i + 1]);\\n            max = Math.Max(max, hidden[i + 1]);\\n        }\\n\\n        int minPos = 0, maxPos = 0;\\n        for (int i = 0; i < hidden.Length; i++) {\\n            minPos = hidden[i] + (lower - min);\\n            maxPos = hidden[i] + (upper - max);\\n            if (minPos < lower || minPos > upper\\n              || maxPos < lower || maxPos > upper) return 0;\\n        }\\n\\n        return maxPos - minPos + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumberOfArrays(int[] diffs, int lower, int upper) {\\n        int[] hidden = new int[diffs.Length + 1];\\n        int min = 0, max = 0;\\n        for (int i = 0; i < hidden.Length - 1; i++) {\\n            hidden[i + 1] = hidden[i] + diffs[i];\\n            min = Math.Min(min, hidden[i + 1]);\\n            max = Math.Max(max, hidden[i + 1]);\\n        }\\n\\n        int minPos = 0, maxPos = 0;\\n        for (int i = 0; i < hidden.Length; i++) {\\n            minPos = hidden[i] + (lower - min);\\n            maxPos = hidden[i] + (upper - max);\\n            if (minPos < lower || minPos > upper\\n              || maxPos < lower || maxPos > upper) return 0;\\n        }\\n\\n        return maxPos - minPos + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724905,
                "title": "this-problem-is-crap",
                "content": "I absolutely hated this problem. Waste of my time actually:\\n\\nMy solution anyhow:\\n\\n```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n         int min = 0;\\n        int max = 0;\\n        int c =0;\\n        int n = upper -lower + 1;\\n        int delta = 0;\\n\\n        for (int d: differences) {\\n          c += d;\\n\\n          if (c > max) {\\n            max = c;\\n          }\\n\\n          if (c < min) {\\n            min = c;\\n          }\\n\\n          delta = max - min;\\n\\n          if (delta >= n ) {\\n            return 0;\\n          }\\n        }\\n\\n        return n - delta;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n         int min = 0;\\n        int max = 0;\\n        int c =0;\\n        int n = upper -lower + 1;\\n        int delta = 0;\\n\\n        for (int d: differences) {\\n          c += d;\\n\\n          if (c > max) {\\n            max = c;\\n          }\\n\\n          if (c < min) {\\n            min = c;\\n          }\\n\\n          delta = max - min;\\n\\n          if (delta >= n ) {\\n            return 0;\\n          }\\n        }\\n\\n        return n - delta;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1723377,
                "title": "c-time-complexity-o-n-aux-space-o-n",
                "content": "```\\n/*\\n * author: deytulsi18\\n * problem: https://leetcode.com/problems/count-the-hidden-sequences/\\n * time complexity: O(n)\\n * auxiliary space: O(n)\\n * language: cpp\\n */\\nclass Solution {\\npublic:\\n    bool isValid(vector<long long> vec, long long upper, long long lower)\\n    {\\n        for (auto i : vec)\\n            if (i > upper or i < lower)\\n                return false;\\n\\n        return true;\\n    }\\n    void adjust(vector<long long> &vec, long long upper, long long lower)\\n    {\\n        long long vecSize = vec.size();\\n        long long maxi = 0;\\n        \\n        for (long long i = 0; i < vecSize; i++)\\n            if (vec[i] > vec[maxi])\\n                maxi = i;\\n        \\n        long long minus = vec[maxi] > upper ? (vec[maxi] - upper) : 0;\\n   \\n        for (long long i = 0; i < vecSize; i++)\\n            vec[i] -= minus;\\n        \\n        long long mini = 0;\\n        \\n        for (long long i = 0; i < vecSize; i++)\\n            if (vec[i] < vec[mini])\\n                mini = i;\\n        \\n        minus = vec[mini] < lower ? vec[mini] - lower : 0;\\n        \\n        for (long long i = 0; i < vecSize; i++)\\n            vec[i] -= minus;\\n    }\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        long long n = diff.size();\\n        long long maxIdx = 0;\\n        long long minIdx = 0;\\n        \\n        for (long long i = 0; i < n; i++)\\n        {\\n            if (diff[i] > diff[maxIdx])\\n                maxIdx = i;\\n            if (diff[i] < diff[minIdx])\\n                minIdx = i;\\n        }\\n        \\n        vector<long long> vecHigh(n + 1, 0);\\n        vector<long long> vecLow(n + 1, 0);\\n        \\n        long long vecSize = n + 1;\\n        \\n        maxIdx++;\\n        minIdx++;\\n\\n        vecHigh[maxIdx] = upper;\\n        vecLow[minIdx] = lower;\\n        \\n        for (long long i = maxIdx + 1; i < vecSize; i++)\\n            vecHigh[i] = vecHigh[i - 1] + diff[i - 1]; \\n        for (long long i = maxIdx - 1; i >= 0; i--)\\n            vecHigh[i] = vecHigh[i + 1] - diff[i]; \\n        \\n        adjust(vecHigh, upper, lower);\\n        \\n        for (long long i = minIdx + 1; i < vecSize; i++)\\n            vecLow[i] = vecLow[i - 1] + diff[i - 1]; \\n        for (long long i = minIdx - 1; i >= 0; i--)\\n            vecLow[i] = vecLow[i + 1] - diff[i]; \\n        \\n        adjust(vecLow, upper, lower);\\n        \\n        long long res = 0;\\n        \\n        if (isValid(vecHigh, upper, lower) and isValid(vecLow, upper, lower))\\n            res = vecHigh[0] - vecLow[0] + 1;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n * author: deytulsi18\\n * problem: https://leetcode.com/problems/count-the-hidden-sequences/\\n * time complexity: O(n)\\n * auxiliary space: O(n)\\n * language: cpp\\n */\\nclass Solution {\\npublic:\\n    bool isValid(vector<long long> vec, long long upper, long long lower)\\n    {\\n        for (auto i : vec)\\n            if (i > upper or i < lower)\\n                return false;\\n\\n        return true;\\n    }\\n    void adjust(vector<long long> &vec, long long upper, long long lower)\\n    {\\n        long long vecSize = vec.size();\\n        long long maxi = 0;\\n        \\n        for (long long i = 0; i < vecSize; i++)\\n            if (vec[i] > vec[maxi])\\n                maxi = i;\\n        \\n        long long minus = vec[maxi] > upper ? (vec[maxi] - upper) : 0;\\n   \\n        for (long long i = 0; i < vecSize; i++)\\n            vec[i] -= minus;\\n        \\n        long long mini = 0;\\n        \\n        for (long long i = 0; i < vecSize; i++)\\n            if (vec[i] < vec[mini])\\n                mini = i;\\n        \\n        minus = vec[mini] < lower ? vec[mini] - lower : 0;\\n        \\n        for (long long i = 0; i < vecSize; i++)\\n            vec[i] -= minus;\\n    }\\n    int numberOfArrays(vector<int>& diff, int lower, int upper) {\\n        long long n = diff.size();\\n        long long maxIdx = 0;\\n        long long minIdx = 0;\\n        \\n        for (long long i = 0; i < n; i++)\\n        {\\n            if (diff[i] > diff[maxIdx])\\n                maxIdx = i;\\n            if (diff[i] < diff[minIdx])\\n                minIdx = i;\\n        }\\n        \\n        vector<long long> vecHigh(n + 1, 0);\\n        vector<long long> vecLow(n + 1, 0);\\n        \\n        long long vecSize = n + 1;\\n        \\n        maxIdx++;\\n        minIdx++;\\n\\n        vecHigh[maxIdx] = upper;\\n        vecLow[minIdx] = lower;\\n        \\n        for (long long i = maxIdx + 1; i < vecSize; i++)\\n            vecHigh[i] = vecHigh[i - 1] + diff[i - 1]; \\n        for (long long i = maxIdx - 1; i >= 0; i--)\\n            vecHigh[i] = vecHigh[i + 1] - diff[i]; \\n        \\n        adjust(vecHigh, upper, lower);\\n        \\n        for (long long i = minIdx + 1; i < vecSize; i++)\\n            vecLow[i] = vecLow[i - 1] + diff[i - 1]; \\n        for (long long i = minIdx - 1; i >= 0; i--)\\n            vecLow[i] = vecLow[i + 1] - diff[i]; \\n        \\n        adjust(vecLow, upper, lower);\\n        \\n        long long res = 0;\\n        \\n        if (isValid(vecHigh, upper, lower) and isValid(vecLow, upper, lower))\\n            res = vecHigh[0] - vecLow[0] + 1;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723040,
                "title": "golang-o-n-time-o-1-mem-simple",
                "content": "```go\\nfunc numberOfArrays(differences []int, lower int, upper int) int {\\n    max, min := 0, 0\\n   \\n    sum := 0\\n    for _, v := range differences {\\n        sum += v\\n        if sum > max {\\n            max = sum\\n        }\\n        if sum < min {\\n            min = sum\\n        }\\n    }\\n   \\n    d := (upper - lower) - (max - min) + 1\\n    if d < 0 {\\n        d = 0\\n    }\\n    \\n    return d \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc numberOfArrays(differences []int, lower int, upper int) int {\\n    max, min := 0, 0\\n   \\n    sum := 0\\n    for _, v := range differences {\\n        sum += v\\n        if sum > max {\\n            max = sum\\n        }\\n        if sum < min {\\n            min = sum\\n        }\\n    }\\n   \\n    d := (upper - lower) - (max - min) + 1\\n    if d < 0 {\\n        d = 0\\n    }\\n    \\n    return d \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1721112,
                "title": "one-pass-75-speed",
                "content": "![image](https://assets.leetcode.com/users/images/e38706f8-53cb-48c6-9e53-c7db1c43c39f_1643193155.4706523.png)\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        n = min_n = max_n = 0\\n        for diff in differences:\\n            n += diff\\n            min_n = min(min_n, n)\\n            max_n = max(max_n, n)\\n        upper_start_n = upper - max_n\\n        lower_start_n = lower - min_n\\n        return (upper_start_n - lower_start_n + 1\\n                if upper_start_n >= lower_start_n else 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        n = min_n = max_n = 0\\n        for diff in differences:\\n            n += diff\\n            min_n = min(min_n, n)\\n            max_n = max(max_n, n)\\n        upper_start_n = upper - max_n\\n        lower_start_n = lower - min_n\\n        return (upper_start_n - lower_start_n + 1\\n                if upper_start_n >= lower_start_n else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719996,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func numberOfArrays(_ differences: [Int], _ lower: Int, _ upper: Int) -> Int {\\n        let sizeOfPossibleRange = upper - lower\\n        \\n        var minimumVal = 0\\n        var maximumVal = 0\\n        var cumulativeSum = 0\\n        \\n        for d in differences {\\n            cumulativeSum += d\\n            if cumulativeSum > maximumVal {\\n                maximumVal = cumulativeSum\\n            } else if cumulativeSum < minimumVal {\\n                minimumVal = cumulativeSum\\n            }\\n        }\\n        \\n        let sizeOfRange = maximumVal - minimumVal\\n        \\n        return max(sizeOfPossibleRange - sizeOfRange + 1,0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numberOfArrays(_ differences: [Int], _ lower: Int, _ upper: Int) -> Int {\\n        let sizeOfPossibleRange = upper - lower\\n        \\n        var minimumVal = 0\\n        var maximumVal = 0\\n        var cumulativeSum = 0\\n        \\n        for d in differences {\\n            cumulativeSum += d\\n            if cumulativeSum > maximumVal {\\n                maximumVal = cumulativeSum\\n            } else if cumulativeSum < minimumVal {\\n                minimumVal = cumulativeSum\\n            }\\n        }\\n        \\n        let sizeOfRange = maximumVal - minimumVal\\n        \\n        return max(sizeOfPossibleRange - sizeOfRange + 1,0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719744,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer[]} differences\\n# @param {Integer} lower\\n# @param {Integer} upper\\n# @return {Integer}\\ndef number_of_arrays(differences, lower, upper)\\n    curr = 0\\n    min_val = 0\\n    max_val = 0\\n    for i in 0...differences.length\\n        curr += differences[i]\\n        min_val = curr if curr < min_val\\n        max_val = curr if curr > max_val\\n    end\\n    [(upper-lower+1) - (max_val-min_val),0].max\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} differences\\n# @param {Integer} lower\\n# @param {Integer} upper\\n# @return {Integer}\\ndef number_of_arrays(differences, lower, upper)\\n    curr = 0\\n    min_val = 0\\n    max_val = 0\\n    for i in 0...differences.length\\n        curr += differences[i]\\n        min_val = curr if curr < min_val\\n        max_val = curr if curr > max_val\\n    end\\n    [(upper-lower+1) - (max_val-min_val),0].max\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1719328,
                "title": "java-passed-o-n",
                "content": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        \\n        int sumD = 0;\\n        \\n        int min=Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int n : differences){\\n            sumD+=n;\\n            min = Math.min(min, sumD);\\n            max = Math.max(max, sumD);\\n        }\\n        int count=0;\\n        for(int i=lower;i<=upper;i++){\\n            \\n            if(i+min<lower || i+max>upper) continue;\\n            if(i+sumD>upper) continue;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        \\n        int sumD = 0;\\n        \\n        int min=Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int n : differences){\\n            sumD+=n;\\n            min = Math.min(min, sumD);\\n            max = Math.max(max, sumD);\\n        }\\n        int count=0;\\n        for(int i=lower;i<=upper;i++){\\n            \\n            if(i+min<lower || i+max>upper) continue;\\n            if(i+sumD>upper) continue;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718602,
                "title": "cpp-solution-c-solution-count-the-hidden-sequences",
                "content": "Here finding only hidden sequence is not a big deal we can simply find that by using simple arithmetic and loop run.\\nBut for countimg number of such sequences in tht range of lower an dupper is a big deal because for a large size array its time out problem and also there is no need for taht much calculations here we can also work by simple playing with minimum and maximum.\\n\\n(1)Here first i calculated one (lowest) hidden sequence\\n(2)then there are  max (upper-lower) possible hidden sequence combination can posible but here some are out of range\\n(3)some i am moving from up to down first by taking min of sequence \\n(4)then again moving from down to up by taking help of max and min\\n\\nwe can see some conditional and some variables are uses for that we can understand those by looking into code\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int diff=upper-lower;\\n        vector<long long>array,temp_array;\\n        array.resize(differences.size()+1);\\n        temp_array.resize(differences.size()+1);\\n        //creating that Hidden Sequences array////////////////////////////\\n\\t array[0]=lower;\\n         for(int i=1;i<differences.size()+1;i++)\\n         {\\n            array[i]=array[i-1]+differences[i-1];\\n         }\\n        //////////////////////////////////////////////////////////////////\\n    \\n         long long min_of_array,max_of_temp_array,max_of_array,min_of_temp_array;\\n         //upper boundry going down\\n            min_of_array=*min_element(array.begin(), array.end());\\n            max_of_array=*max_element(array.begin(), array.end());\\n            int upper_boundry=lower-min_of_array;//this is how many times we have to go down           \\n            max_of_array+=upper_boundry;//shifting max_of_array by that many times\\n         if(max_of_array>upper)//here chacking is max in the range or not if not then no sequence are possible\\n         {\\n             return 0;\\n         }\\n////////////////////////////////////////////////////////////////\\n         long long temp1=array[0]+upper_boundry;//here doing same changes with first index of seqence whtever we done with max i.e sifting, i am using this variable for saving its position that well use to calculate count of possible hidden sequence \\n         //here now we are going to work from down to up\\n\\t max_of_array=*max_element(array.begin(), array.end());\\n         min_of_array=*min_element(array.begin(), array.end());\\n         max_of_array+=diff;//first sending max to down\\n         long long temp=max_of_array-upper;//then here calculating how many steps we are out of range\\n         min_of_array+=diff; then we have to substract that many times\\n         min_of_array-=temp;\\n         long long temp2=array[0]+diff-temp;//here i am again saving as we did with temp1\\n         if(min_of_array<lower)\\n         {\\n             return 0;\\n         }\\n//////////////////////////////////////////////////////\\n        return (temp2-temp1 +1);\\n    }\\n};\\n\\n\\n```![image](https://assets.leetcode.com/users/images/f0cb7289-157c-47e8-ae58-66a97adbb707_1643114058.9953113.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        int diff=upper-lower;\\n        vector<long long>array,temp_array;\\n        array.resize(differences.size()+1);\\n        temp_array.resize(differences.size()+1);\\n        //creating that Hidden Sequences array////////////////////////////\\n\\t array[0]=lower;\\n         for(int i=1;i<differences.size()+1;i++)\\n         {\\n            array[i]=array[i-1]+differences[i-1];\\n         }\\n        //////////////////////////////////////////////////////////////////\\n    \\n         long long min_of_array,max_of_temp_array,max_of_array,min_of_temp_array;\\n         //upper boundry going down\\n            min_of_array=*min_element(array.begin(), array.end());\\n            max_of_array=*max_element(array.begin(), array.end());\\n            int upper_boundry=lower-min_of_array;//this is how many times we have to go down           \\n            max_of_array+=upper_boundry;//shifting max_of_array by that many times\\n         if(max_of_array>upper)//here chacking is max in the range or not if not then no sequence are possible\\n         {\\n             return 0;\\n         }\\n////////////////////////////////////////////////////////////////\\n         long long temp1=array[0]+upper_boundry;//here doing same changes with first index of seqence whtever we done with max i.e sifting, i am using this variable for saving its position that well use to calculate count of possible hidden sequence \\n         //here now we are going to work from down to up\\n\\t max_of_array=*max_element(array.begin(), array.end());\\n         min_of_array=*min_element(array.begin(), array.end());\\n         max_of_array+=diff;//first sending max to down\\n         long long temp=max_of_array-upper;//then here calculating how many steps we are out of range\\n         min_of_array+=diff; then we have to substract that many times\\n         min_of_array-=temp;\\n         long long temp2=array[0]+diff-temp;//here i am again saving as we did with temp1\\n         if(min_of_array<lower)\\n         {\\n             return 0;\\n         }\\n//////////////////////////////////////////////////////\\n        return (temp2-temp1 +1);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718297,
                "title": "o-n-solution-easy-c",
                "content": "class Solution {\\npublic:\\n    int numberOfArrays(vector<int>& d, int l, int u)\\n    {\\n        vector<long long> ans;\\n        ans.push_back(l);\\n        for(int i=0;i<d.size();i++)\\n        {\\n            long long pp=d[i]+ans[i];\\n            if(pp>u)\\n            {\\n                return 0;\\n            }\\n            ans.push_back(pp);\\n        }\\n        sort(ans.begin(),ans.end());\\n        int s=ans[0];\\n        int e=ans[ans.size()-1];\\n        \\n        int p=0;\\n        if(s<l)\\n        {\\n            p=l-s;\\n        }\\n        if(e+p>u)\\n        {\\n            return 0;\\n        }\\n        return u-e-p+1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numberOfArrays(vector<int>& d, int l, int u)\\n    {\\n        vector<long long> ans;\\n        ans.push_back(l);\\n        for(int i=0;i<d.size();i++)\\n        {\\n            long long pp=d[i]+ans[i];\\n            if(pp>u)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1717212,
                "title": "c-find-boundary",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long hi = INT_MIN, lo = INT_MAX, cur = 0;\\n        \\n        for (auto n : differences) {\\n            cur += n;\\n            \\n            lo = min(lo, cur);\\n            hi = max(hi, cur);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = lower; i <= upper; ++i) {\\n            if (i + lo >= lower && i + hi <= upper) {\\n                ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& differences, int lower, int upper) {\\n        long long hi = INT_MIN, lo = INT_MAX, cur = 0;\\n        \\n        for (auto n : differences) {\\n            cur += n;\\n            \\n            lo = min(lo, cur);\\n            hi = max(hi, cur);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = lower; i <= upper; ++i) {\\n            if (i + lo >= lower && i + hi <= upper) {\\n                ++ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716114,
                "title": "brute-force-optimize-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper){\\n   \\n        // 1st Approach --> O(N)\\n        long long sum = 0;\\n        long long mini = 0;\\n        long long maxi = 0;\\n        \\n        for(auto &it : diff){\\n            sum += it;\\n            mini = min(mini,sum);\\n            maxi = max(maxi,sum);\\n        }\\n        \\n        int ub = upper - maxi;\\n        int lb = lower - mini;\\n        int ans = ub - lb + 1;\\n        if(ans <= 0) return 0;\\n        return ans;\\n        \\n        //2nd Approach --> Brute Force --> O(N^2)\\n        unordered_set<int> st1,st2;\\n        for(int i=lower;i<=upper;i++) st1.insert(i);\\n        \\n        int n = diff.size();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int req = diff[i];\\n            \\n            for(auto it : st1)\\n                if(it + req >= lower and it+req <= upper) st2.insert(it+req);\\n            \\n            st1 = st2;\\n            st2.clear();\\n        }\\n        \\n        return st1.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numberOfArrays(vector<int>& diff, int lower, int upper){\\n   \\n        // 1st Approach --> O(N)\\n        long long sum = 0;\\n        long long mini = 0;\\n        long long maxi = 0;\\n        \\n        for(auto &it : diff){\\n            sum += it;\\n            mini = min(mini,sum);\\n            maxi = max(maxi,sum);\\n        }\\n        \\n        int ub = upper - maxi;\\n        int lb = lower - mini;\\n        int ans = ub - lb + 1;\\n        if(ans <= 0) return 0;\\n        return ans;\\n        \\n        //2nd Approach --> Brute Force --> O(N^2)\\n        unordered_set<int> st1,st2;\\n        for(int i=lower;i<=upper;i++) st1.insert(i);\\n        \\n        int n = diff.size();\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int req = diff[i];\\n            \\n            for(auto it : st1)\\n                if(it + req >= lower and it+req <= upper) st2.insert(it+req);\\n            \\n            st1 = st2;\\n            st2.clear();\\n        }\\n        \\n        return st1.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715398,
                "title": "java-o-n",
                "content": "```\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min=0, max=0, balance=0;\\n        for(int d : differences){\\n            balance += d;\\n            min = Math.min(min, balance);\\n            max = Math.max(max, balance);\\n        }\\n\\n        long delta;\\n        if(max<0)\\n            delta = min;\\n        else if(min>0)\\n            delta = max;\\n        else\\n            delta = max-min;\\n\\n        long count=upper-lower-delta;\\n        return count<0 ? 0 : (int)count+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numberOfArrays(int[] differences, int lower, int upper) {\\n        long min=0, max=0, balance=0;\\n        for(int d : differences){\\n            balance += d;\\n            min = Math.min(min, balance);\\n            max = Math.max(max, balance);\\n        }\\n\\n        long delta;\\n        if(max<0)\\n            delta = min;\\n        else if(min>0)\\n            delta = max;\\n        else\\n            delta = max-min;\\n\\n        long count=upper-lower-delta;\\n        return count<0 ? 0 : (int)count+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715074,
                "title": "visuals-logic-behind-the-formula-upper-lower-max-min-1",
                "content": "<h1>Logic behind the formula: (upper - lower) - (max - min) + 1</h1>\\n<hr>\\n<img width=\"800\" src=\"https://raw.githubusercontent.com/shalomalexander/Leetcode/main/CountHiddenSequence.png\">\\n\\n```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        minimum = 0\\n        maximum = 0\\n        \\n        a = 0\\n        \\n        for d in differences:\\n            a += d\\n            \\n            minimum = min(a, minimum)\\n            maximum = max(a, maximum)\\n        \\n        return max((upper - lower) - (maximum - minimum) + 1, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numberOfArrays(self, differences: List[int], lower: int, upper: int) -> int:\\n        minimum = 0\\n        maximum = 0\\n        \\n        a = 0\\n        \\n        for d in differences:\\n            a += d\\n            \\n            minimum = min(a, minimum)\\n            maximum = max(a, maximum)\\n        \\n        return max((upper - lower) - (maximum - minimum) + 1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714527,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} differences\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar numberOfArrays = function(differences, lower, upper) {\\n    const len = 1 + differences.length\\n    const arr = new Array(len)\\n    arr[0] = 0\\n    \\n    \\n    for (const [i, difference] of differences.entries()) {\\n        arr[i + 1] = arr[i] + difference\\n    }\\n    const minVal = Math.min(...arr)\\n    const addMe = lower - minVal\\n    for (const i of arr.keys())\\n        arr[i] += addMe\\n    \\n    \\n    const maxVal = Math.max(...arr)\\n    const offset = upper - maxVal\\n    \\n    \\n    let result = 1 + offset\\n    result = Math.max(result, 0)\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} differences\\n * @param {number} lower\\n * @param {number} upper\\n * @return {number}\\n */\\nvar numberOfArrays = function(differences, lower, upper) {\\n    const len = 1 + differences.length\\n    const arr = new Array(len)\\n    arr[0] = 0\\n    \\n    \\n    for (const [i, difference] of differences.entries()) {\\n        arr[i + 1] = arr[i] + difference\\n    }\\n    const minVal = Math.min(...arr)\\n    const addMe = lower - minVal\\n    for (const i of arr.keys())\\n        arr[i] += addMe\\n    \\n    \\n    const maxVal = Math.max(...arr)\\n    const offset = upper - maxVal\\n    \\n    \\n    let result = 1 + offset\\n    result = Math.max(result, 0)\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2047615,
                "content": [
                    {
                        "username": "grean_peas2020",
                        "content": "This question was asked in Zomato OA. If anyone is here, a small info for you."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "TIP: \njust see how much we need to bring the minimum value in the given range\nafter bringing in the desired range, check if any element exceeded the upper range.\nif not then by subtracting from upper range check how much we can still add, until it reaches the maximum."
                    }
                ]
            },
            {
                "id": 1861897,
                "content": [
                    {
                        "username": "grean_peas2020",
                        "content": "This question was asked in Zomato OA. If anyone is here, a small info for you."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "TIP: \njust see how much we need to bring the minimum value in the given range\nafter bringing in the desired range, check if any element exceeded the upper range.\nif not then by subtracting from upper range check how much we can still add, until it reaches the maximum."
                    }
                ]
            }
        ]
    }
]