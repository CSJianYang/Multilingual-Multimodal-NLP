[
    {
        "title": "Find the Score of All Prefixes of an Array",
        "question_content": "We define the conversion array conver of an array arr as follows:\n\n\tconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n&nbsp;\nExample 1:\n\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\n\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 3420109,
                "title": "c-python3-prefix-sum",
                "content": "\\n# Intuition\\nFirst find `conver` array and then find its prefix sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python3**:\\n```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\\n1 liner credits [@SunnyvaleCA](https://leetcode.com/SunnyvaleCA/):\\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```\\n\\n**C++**:\\n```\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n      vector<long long> pre;\\n      long long m = 0, s = 0;\\n      for(int x : nums) {\\n          m = max(m, (long long)x);\\n          s += x + m;\\n          pre.push_back(s);\\n      }\\n      return pre;\\n  }",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\ndef findPrefixScore(self, nums: List[int]) -> List[int]:\\n    m, conver = 0, []\\n    for x in nums:\\n        m = max(m, x)\\n        conver.append(x + m)\\n    return accumulate(conver)\\n```\n```\\ndef findPrefixScore(self, A):\\n    return accumulate(n+maxN for n,maxN in zip(A, accumulate(A,max)))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3420907,
                "title": "c-easiest-approach-easy-to-understand-simple-logic-with-comments",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(n)\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }\\r\\n        return ans;                      \\r\\n    }\\r\\n};\\r\\n\\r\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\r\\npublic:\\r\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\r\\n        vector<long long> b;  \\r\\n        vector<long long> ans;\\r\\n        int n = nums.size();\\r\\n        int mm= INT_MIN;\\r\\n        long long aa = 0;\\r\\n        for(int  i = 0 ; i < n; i++){        //0, 1...\\r\\n            long long a  = 0;\\r\\n            mm = max(mm, nums[i]);        // 2 , 3...\\r\\n            a = nums[i] + mm;             //2+2 = 4, 3+3  = 6, ..\\r\\n            b.push_back(a);               // b=[4,6,]...\\r\\n            aa += b[i];                   //0+4 = 4, 4+6 = 10,...  \\r\\n            ans.push_back(aa);            //ans = [4,10,...]\\r\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3420302,
                "title": "prefix-sum-very-simple-easy-to-understand-solution",
                "content": "<b> Please Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum = 0, mx = 0;\\n        for(auto n: nums){\\n            if(mx < n) mx = n;\\n            sum += n + mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420254,
                "title": "c-prefix-sum-easy-to-understand-superfast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use the prefix sum approach to make a `conver` vector and then `ans` vector by applying prefix sum approach on `conver` message.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store `2*nums[0]` in `conver[0]`.\\n- Then run a loop and assign `conver[i] = nums[i] +0ll+ mx`, where `mx` is variable having the maximum running number.\\n- Then, at last simply make a prefix sum array `ans` of `conver` vector and return it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        vector<long long> conver(n);\\n        conver[0] = 2*nums[0];\\n        int mx = nums[0];\\n        for(int i=1; i<n; i++){\\n            mx = max(mx, nums[i]);\\n            conver[i] = nums[i] +0ll+ mx;\\n        }\\n        ans[0]=conver[0];\\n        for(int i=1; i<n; i++){\\n            ans[i] = ans[i-1] + 0ll+conver[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n//  PLEASE UPVOTE IF YOU LIKE THE SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420062,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420024,
                "title": "java-python-3-1-pass-codes",
                "content": "\\n\\n```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] score = new long[n + 1];\\n        for (int i = 0, max = 0; i < n; ++i) {\\n            max = Math.max(max, nums[i]);\\n            score[i + 1] += score[i] + max + nums[i];\\n        }\\n        return Arrays.copyOfRange(score, 1, n + 1);        \\n    }\\n```\n```python\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        score, mx = [0], 0\\n        for num in nums:\\n            mx = max(mx, num)\\n            score.append(score[-1] + num + mx)\\n        return score[1 :]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419972,
                "title": "c-java-python-intuition-with-explanation-simple-prefix-sum-time-o-n",
                "content": "# Intuition\\n$conver[i] = nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n$score(nums) = \\\\sum conver(nums)$\\n\\n$ans[i] = score(nums[0...i])$\\n$ans[i] = \\\\sum conver(nums[0...i])$\\n\\n$ans[i]$ is the the prefix sum of $conver[i]$\\n\\n$ans[i] = \\\\left(\\\\displaystyle\\\\sum conver(nums[0...i-1])\\\\right) + conver[i]$\\n$ans[i] = ans[i - 1] + conver[i]$\\n$ans[i] = ans[i - 1] + nums[i] + \\\\displaystyle\\\\max_{0 \\\\le j \\\\le i} (nums[j])$\\n\\n# Approach\\nMaintain $maximum$ value till current index.\\n$ans[i] = ans[i - 1] + nums[i] + maximum$\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(n)$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(), maximum = nums[0];\\n        vector<long long> result(n);\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, maximum = nums[0];\\n        long[] result = new long[n];\\n        result[0] = 2 * nums[0];\\n        for (int i = 1; i < n; i++) {\\n            maximum = Math.max(maximum, nums[i]);\\n            result[i] = result[i - 1] + nums[i] + maximum;\\n        }\\n        return result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        result = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            result.append(result[i - 1] + nums[i] + maximum)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420214,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nTo calculate the score of each prefix of the input array nums, we need to calculate the conversion array conver for each prefix, and then sum up the elements of the conversion array to get the prefix score. To calculate the conver array for each prefix, we need to find the maximum value of the input array up to that index, and then add it to each element of the prefix.\\n\\n\\n# Approach\\n1. Initialize an array ans of length n with all elements initialized to 0.\\n2. Initialize a variable max_val to negative infinity.\\n3. Loop through the input array nums:\\na. Update the max_val variable to the maximum value seen so far.\\nb. Calculate the conversion value conver for the current index by adding the current element of the input array to the max_val.\\nc. Update the corresponding element of the ans array with the conver value.\\n4. Initialize an array res of length n with all elements initialized to 0.\\n5. Initialize a variable s to 0.\\n6. Loop through the ans array:\\na. Add the current element to the s variable.\\nb. Update the corresponding element of the res array with the current value of s.\\n7. Return the res array.\\n# Complexity\\n- Time complexity:\\nO(n), where n is the length of the input array nums. We need to loop through the array twice, once to calculate the ans array and once to calculate the res array, both of which take O(n) time.\\n- Space complexity:\\nO(n), we need to use two arrays of length n, ans and res, which take O(n) space in total. Additionally, we use a few constant variables, which take O(1) space.\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420127,
                "title": "clean-and-simple-solution-using-heap-100-faster",
                "content": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        heap = [-nums[0]]\\n        result = []\\n        runningSum = 0\\n        for num in nums:\\n            maxSum = max(num, -1 * heapq.heappop(heap))\\n            result.append(runningSum + num + maxSum)\\n            runningSum += maxSum+num\\n            heappush(heap,- maxSum)\\n        return result\\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3420054,
                "title": "short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            max = Math.max(max,nums[i]);\\n            res[i] = nums[i] + max + (i==0 ? 0 : res[i-1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420279,
                "title": "c-o-n-prefix-sum-clean-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n,-1);\\n        long long l=nums[0];\\n        //calculating the conver[i]\\n        for(int i=0;i<n;++i){\\n            if(l<nums[i])l = nums[i];\\n            ans[i]=nums[i]+l;\\n        }\\n        //taking the prefix sum\\n        for(int i=1;i<n;++i)ans[i]+=ans[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420129,
                "title": "cpp-prefix-sum",
                "content": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        vector<ll> ans;\\n        ll mx = 0LL, s = 0LL;\\n        for(int x : v) {\\n            mx = max(mx,(ll)x);\\n            s += (x + mx);\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421148,
                "title": "c-easy-prefix-sum",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/fcf80d18-7665-46c4-a0fb-5038ce657498_1681589962.770271.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& a) {\\n        vector<long long>v;\\n        v.push_back(a[0]+a[0]);\\n        long long mx=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long an=a[i];\\n            if(mx<a[i])mx=a[i];\\n            an+=mx;\\n            long long h=v[i-1]+an;\\n            v.push_back(h);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420130,
                "title": "simple-prefix-sum",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        max_, sum_ = 0, 0\\n        res = []\\n        for num in nums:\\n            max_ = max(max_, num)\\n            res.append(num + max_)\\n        last = 0\\n        for i, val in enumerate(res):\\n            res[i] += last\\n            last += val\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554506,
                "title": "c-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> v(n,0);\\n        v[0] += nums[0]*2;\\n        long long mx = nums[0];\\n        for(int i = 1; i < n; i++){\\n            mx = max(nums[i]*1LL,mx);\\n            v[i] = mx+nums[i];\\n            v[i] += v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438048,
                "title": "short-and-crisp-beginner-friendly-one-pass-o-n-time-complexity",
                "content": "\\n\\n# Approach\\nJust keep track of maximum element before i+1 index and to take on prefix array to store values at same time.\\n\\n# Complexity\\n- Time complexity:\\no(n);\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n =  nums.size();\\n        vector<long long > ans(n,0);//prefix Array to return\\n        int maxi =  nums[0];\\n        ans[0] = 2*nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            maxi = max(maxi,nums[i]); //track of maxi before i+1 index\\n            nums[i]+=maxi; \\n            ans[i]+=ans[i-1]+nums[i];//Making prefix array to return\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423547,
                "title": "c-easiest-approach-prefix-sum-beginner-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will use Prefix-Sum method here to find maximum element till every i\\'th index.\\nThen we will add out prefix_max at i\\'th position to our original vector at i\\'th position.\\nAt last we will take sum upto every i\\'th index and push it into our answer vector.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![2ddedd60-39d6-4167-9b77-88e10400f044_1673586388.8794823.jpeg](https://assets.leetcode.com/users/images/ca1f0d37-8838-454f-b4e8-dc22323e3ed3_1681647899.5235333.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        \\n        vector<long long> prefix_max;\\n        int max_current=nums[0];\\n        prefix_max.push_back(max_current);\\n        for(int i=1;i<n;i++)\\n        {\\n            max_current=max(max_current,nums[i]);\\n            prefix_max.push_back(max_current);\\n        }\\n        \\n        vector<long long> ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]+=prefix_max[i];\\n        }\\n        \\n        long long sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            ans.push_back(sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421177,
                "title": "one-liner",
                "content": "**Python3**\\n```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420325,
                "title": "c-o-n-solution",
                "content": "\\n# Approach: Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the answer array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long maxy = 0, conver = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            maxy = nums[i] > maxy ? nums[i] : maxy;\\n            conver = maxy + nums[i];\\n            sum += conver;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420219,
                "title": "simple-o-n",
                "content": "# Intuition\\nUse memoization\\n\\n# Approach\\nIterate the initial array. Store both max so far and score of i-1. For ith element max(i) = max(max(i-1), nums(i)), score(i) = score(i-1) + max(i) + nums(i).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let sum = 0\\n    let max = nums[0]\\n    \\n    let res = []\\n    for(let i = 0; i < nums.length; i++){\\n        max = Math.max(nums[i], max);\\n        sum += (max + nums[i])\\n        res.push(sum);\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3419995,
                "title": "python-1-liner-solution",
                "content": "# **Explanation**\\nGet the accumulate max array of  `pre_max`\\nAnd return the accumulate sum of `A + max_acc`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n\\n**Python**\\n```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findPrefixScore(self, A: List[int]) -> List[int]:\\n        acc_max = accumulate(A, max)\\n        return list(accumulate(map(sum, zip(A, acc_max))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3443265,
                "title": "c-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHello guys, Here you just have to simply iterate the array and keep a max count  till  ith index.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Here I am explaining my approach :\\n1.) Simply iterate the array from 1st index to last.\\n2.) Keep a max to keep account of maximum till the ith index. \\n3.) Simply add this max to current index to get the value.\\n4.) Now you have sum the elements of this ans array to get final result.\\n5.) Taken a cur pointer and with the help of it added them , this cur contains sum till (i-1)th index.\\n6.)Keep in mind to take long long variable otherwise you will get TLE\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N+N) \\ni.e. O(2*N) ~ O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2*N) [for sum and ans array]\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        vector<long long > ans,sum;\\n        int n = nums.size();\\n\\n        long long max = nums[0];\\n        sum.push_back(2*nums[0]);\\n        ans.push_back(2*nums[0]);\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>max) max = nums[i];\\n\\n            sum.push_back(nums[i]+max);\\n        }\\n        \\n        long long cur = sum[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long long summ =0;\\n            summ = sum[i]+cur;\\n            ans.push_back(summ);\\n            cur = summ;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420212,
                "title": "simple-c-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long > temp(n);\\n        int maxval=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             maxval=max(maxval,nums[i]);\\n             temp[i]=nums[i]+maxval;\\n            if(i>0)\\n            {\\n                temp[i]+=temp[i-1];\\n            }\\n           \\n            \\n        }\\n \\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420118,
                "title": "c-prefix-sum-short-sweet-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        vector<long long int> mx(n),dp(n);\\n        dp[0] = 2*nums[0],mx[0] = nums[0];\\n        for(i = 1; i < n; i++){\\n            mx[i] = max(mx[i-1],nums[i]*1LL);\\n        }\\n        for(i = 1; i < n; i++){\\n            dp[i] = nums[i]+dp[i-1]+mx[i];\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420032,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<ll> ans;\\n        int n = nums.size();\\n        ll sum = 0,maxVal=0,val;\\n        for(int i=0;i<n;i++){\\n            maxVal = max(maxVal, (ll)nums[i]);\\n            val = nums[i] + maxVal;\\n            sum += val;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966852,
                "title": "fastest-efficient-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        long long  prevMax = -1 ;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            prevMax = max(prevMax, (long long)nums[i]) ;\\n            if(i == 0){\\n                conver.push_back(prevMax + nums[i]) ;\\n            }else{\\n                conver.push_back(prevMax + nums[i] + conver.back()) ;\\n            }\\n        }\\n        return conver ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920265,
                "title": "o-n-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\nFor storing the answer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> conver(n);\\n        vector<long long> score(n);\\n        \\n        \\n        \\n        long long prefixMax = nums[0];\\n        conver[0] = nums[0] + prefixMax;\\n        score[0] = conver[0];\\n        long long prefixSum = conver[0];\\n        \\n        for(int i=1;i<n;i++) {\\n            prefixMax = max(static_cast<long long>(nums[i]), prefixMax);  // Use long long here\\n            conver[i] = static_cast<long long>(nums[i]) + prefixMax;      // Use long long here\\n            \\n            \\n            prefixSum += conver[i];\\n            \\n            score[i] = prefixSum;\\n            \\n            \\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849823,
                "title": "simple-code-with-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe simply iterate over array keeping track of maximum value and also storing the total sum\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif the array is is less than or eqaul maxi then simply add the maxi to that element and store it ,if not add the same maxi twice and push\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        int maxi=nums[0];\\n        long long tot=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<=maxi){\\n                tot+=nums[i]+maxi;\\n                ans.push_back(tot);\\n            }\\n            else{\\n                 maxi=nums[i];\\n                 tot+=2*maxi;\\n                 ans.push_back(tot);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849219,
                "title": "beats-99-80-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590130,
                "title": "simple-solution-o-n-time-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr= new long[nums.length];\\n        long max=nums[0];\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            max=max<=nums[i]?nums[i]:max;\\n            sum=sum+nums[i]+max;\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519543,
                "title": "easy-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply traverse the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep track of max and sum as you go ahead\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nIf you find it helpful then please upvote (thanks)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n = nums.size();\\n       vector<long long> score;\\n       long long max = INT_MIN;\\n       long long sum = 0;\\n       for(int i=0;i<n;i++){\\n           if(nums[i]>max)max = nums[i];\\n           sum += max+nums[i];\\n           score.push_back(sum);\\n       }\\n       return score; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444609,
                "title": "java-fastest-runtime-easy-and-elegant-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n     long a = 0;\\n        long max = nums[0];\\n        long[] k = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            k[i] = a + nums[i] + max;\\n            a = k[i];\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425978,
                "title": "max-val-in-prefix-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        //we will do some precomputation to find the max in the range\\n        vector<int>prefix(nums.size(),-1);\\n        prefix[0] = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            int ele = max(prefix[i-1],nums[i]);\\n            prefix[i] = ele;\\n        }\\n        //we are going to make the ans vector\\n        vector<long long>ans;\\n\\n        //now making ans for the every index\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            long long ele = nums[i];\\n            long long tillmax = prefix[i];\\n\\n            if(ans.size() == 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax));\\n                ans.push_back(result);\\n            }\\n            else if(ans.size() > 0)\\n            {\\n                long long result = (0LL + (1LL*ele) + (1LL*tillmax)) + (0LL + ans.back());\\n                ans.push_back(result);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424772,
                "title": "easy-c-solution-prefix-array",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n= nums.size();\\n        vector<long long> conver,score(n,0);\\n        int maxi= INT_MIN;\\n        for (int i=0; i<n; i++){\\n            maxi= max(maxi,nums[i]);\\n            conver.push_back((long long)(nums[i])+maxi);\\n            \\n        }\\n        score[0]= conver[0];\\n        for (int i=1; i<n; i++){\\n            score[i]= score[i-1]+conver[i];\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424575,
                "title": "do-exactly-what-the-question-has-asked",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\\n---\\n## Single loop:\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        // fill the conversion array\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n        }\\n        // define the scores in the same array (prefix sum)\\n        for (int i = 1; i < n; i++) {\\n            c[i] += c[i - 1];\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] c = new long[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(nums[i], max);\\n            c[i] = nums[i] + max;\\n            if (i > 0) {\\n                c[i] += c[i - 1];\\n            }\\n        }        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424010,
                "title": "c-easy-solution-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main catch here is if you are using *max_element() for finding out the max element then the code will give TLE, as *max_element() function takes $$O(n)$$ and the overall complexity turns out to be O(n<sup>2</sup>).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote_cat.jpeg](https://assets.leetcode.com/users/images/f87692e8-d2b3-42f0-89a2-44e236bc72d7_1681659029.549422.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long max1 = nums[0];\\n        ans.push_back(2*nums[0]);\\n        long long sum1 = 2*nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]>=max1){\\n                max1 = nums[i];\\n                sum1 = sum1+(2*nums[i]);\\n                ans.push_back(sum1);\\n            }else{\\n                sum1 = sum1+(nums[i]+max1);\\n                ans.push_back(sum1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423148,
                "title": "c-easy-4-lines-only-o-n-faster-96",
                "content": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```c++\\nvector<long long> findPrefixScore(vector<int>& nums) {\\n    vector<long long> res;\\n    long long max_so_far = 0, prev = 0;\\n    for (auto num: nums) {\\n        max_so_far = max(max_so_far, 1LL * num);\\n        res.push_back(0LL + num + max_so_far + prev);\\n        prev = res.back();\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422816,
                "title": "c-very-very-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        ans.push_back(nums[0]+nums[0]);\\n        int maxi=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            ans.push_back(nums[i]+maxi);\\n        }\\n        \\n        for(int i=1;i<ans.size();i++){\\n            ans[i]=ans[i-1]+ans[i]; \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422758,
                "title": "easy-to-undersatnd-cpp-solution",
                "content": "![UPvote.jpg](https://assets.leetcode.com/users/images/f5aa6015-14a7-4eb6-b0d6-1c39cb83a85c_1681631343.6630116.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> res;\\n        long long sum = 0;\\n        int n = nums.size();\\n        int max_elem = nums[0];\\n        for(int i=0;i<n;i++){\\n            if(nums[i] > max_elem) max_elem = nums[i];\\n            sum += max_elem + nums[i];\\n            res.push_back(sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422289,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long[] ans=new long[n];\\n        long max=Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<n;i++){\\n            max=Math.max(max>nums[i]?max:nums[i],max);\\n            ans[i]=nums[i]+max;\\n        }\\n        \\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            ans[i]=sum;\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n//         int n=nums.length;\\n//         long conver[]=new long[n];\\n        \\n//         for(int i=0;i<nums.length;i++){\\n//             conver[i] = nums[i];\\n//             long max=0;\\n//             for(int j=0;j<=i;j++){\\n//                 if(nums[j]>max){\\n//                     max=nums[j];\\n//                 }\\n                \\n//             }\\n//             conver[i]=conver[i]+max;\\n//         }\\n        \\n//         for(int i=1;i<n;i++){\\n//             conver[i]=conver[i]+conver[i-1];\\n//         }\\n//         return conver;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422073,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422068,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422067,
                "title": "c-brute-force",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=nums[0];\\n        vector<long long int>ans(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            maxi=max(maxi, nums[i]);\\n            ans[i]=nums[i];\\n            ans[i]+=maxi;\\n        }\\n        for(int i=1; i<nums.size(); i++){\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421994,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nThe key to solving the problem is literally by writing the arrays on a paper and figuring out where to add what. The given formula is `conver[i] = arr[i] + max(arr[0..i]) `.\\n\\nNow, with this we can understand that conversion array will contain sum of element at i and maximum element till i. Hence, we need to keep track of maximum element till i and check for it first when we iterate. \\n\\nNext, we do not want to return the conversion array!  We are asked to return array of sums from 0 to i of conversion array. Hence, we\\'ll keep track of sum and store that in the array to return it.\\n\\nIn the given solution, conversion array is not stored as it will just take extra space. But for understanding purposes, you can get to conversion array first and then iterate another loop to get sum/ans array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        // array of sums till i\\n        long ans[]=new long[nums.length];\\n        long sum=0;\\n        int max=nums[0];\\n        for (int i=0;i<nums.length;i++){\\n            // updating max\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            // conversion array value = nums[i]+max\\n            // ans array = sum of all till i\\n            sum = sum + nums[i] + max;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420828,
                "title": "python-greedy-6-lines-100-beats",
                "content": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        s, m, a = 0, 0, []\\n\\n        for n in nums:\\n            m = max(m, n)\\n            s += n + m\\n            a.append(s)\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420591,
                "title": "explained-with-code-c-easy-to-understand-and-implement",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need a maxium from the 0th index to current index so we can just get it using\\n`max_i = max(max_i,nums[i])`\\nit will the the latest maximum number\\n`ans[1] = nums[1] + max_i + ans[0]`(which is a prefix sum until now)\\n\\n# Complexity\\n## - Time complexity: O(n)\\n\\n## - Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        int max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        ans[0] = nums[0] + nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            ans[i] = nums[i] + max_i + ans[i-1];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420382,
                "title": "c-well-explained-8-line-code-prefix-sum-o-n-time",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        for(auto it : nums) ans.push_back(it);\\n        long long maxi = 0;\\n        for(int i=0; i<ans.size(); i++) {\\n            maxi = max(maxi, ans[i]);\\n            ans[i] += maxi;\\n        }\\n        for(int i=1; i<ans.size(); i++) ans[i] += ans[i-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420243,
                "title": "c-solution",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        int max = 0;\\n        for(int i=0;i<nums.size();i++){\\nif(nums[i] > max) {\\n    max = nums[i];\\n}\\n            ans.push_back(max+nums[i]);\\n}\\n    long sum = ans[0];\\n        for(int i = 1; i < nums.size(); i++) {\\nsum += ans[i];\\n            ans[i] = sum;\\n            \\n}\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420238,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            \\n            arr[i] = nums[i] + max;\\n        }\\n        \\n        long sum = arr[0];\\n        for(int i = 1; i < nums.length; i++) {\\n            sum += arr[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420211,
                "title": "easy-c",
                "content": "# Intuition\\nIf you see pattern here then it is like \\nfor example [2,3,7,5,10]\\nanswer is \\nans[0] = 2 + max(2) + 0\\nans[1] = 3 + max(2,3) + ans[0];\\nans[2] = 7 + max(2,3,7) + ans[1];\\nans[3] = 5 + max(2,3,7,5) + ans[2];\\nans[4] = 10 + max(2,3,7,5,10) + ans[3];\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans(nums.size(),0);\\n        \\n        long long sum = nums[0];\\n        long long maxi = nums[0];\\n        \\n        ans[0] = sum+maxi;\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            maxi = max((long long) nums[i],maxi);\\n            ans[i] = maxi + (long long)nums[i] + ans[i-1];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420190,
                "title": "c-simple-iteration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use a loop to iterate over the elements of the array and update the maximum element seen so far. Then, calculate the prefix score for the current element by adding it to the maximum element seen so far. Finally, store the prefix score for each element in a vector and returns the vector as the result. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<long long>ans(n);\\n        int max_till=0;\\n        for(int i=0;i<n;++i){\\n            max_till=max(arr[i],max_till);\\n            long long curr=arr[i]+max_till;\\n            if(i==0){\\n                ans[i]=curr;\\n            }\\n            else ans[i]=ans[i-1]+curr;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420156,
                "title": "c-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        \\n        int n = size(nums);\\n        \\n        vector<long long> prefix;\\n        \\n        long long mx = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            mx = max(mx,0LL+nums[i]);\\n            if(prefix.empty())prefix.push_back(nums[i]+mx);\\n            else prefix.push_back(0ll+prefix.back()+nums[i]+mx);\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420152,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        acc_max=accumulate(nums,max)\\n        return list(accumulate(map(sum,zip(nums,acc_max))))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420115,
                "title": "java-prefix-sum-easiest-o-n-self-explanatory",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length, max = -1;\\n        long[] conv = new long[n];\\n        \\n        for(int i=0;i<n;i++){\\n          max = Math.max(max, nums[i]);\\n          conv[i] = nums[i] + max;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            conv[i] = conv[i-1] + conv[i];\\n        }\\n        \\n        return conv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420089,
                "title": "c-2-lines-easy-solution-o-n",
                "content": "# Approach\\nThe prefix score of an element at index i is the sum of the maximum element from index 0 to i and the element at index i itself. This prefix score is calculated for all elements in the input vector and returned in the output vector.\\n\\n# Complexity\\n- Time complexity:\\nThe function iterates through the input vector once, so the time complexity is O(n), where n is the size of the input vector.\\n\\n- Space complexity:\\nThe function creates a new vector to store the prefix scores, so the space complexity is also O(n), where n is the size of the input vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> conver;\\n        int maks=nums[0];\\n        long long hence=0;\\n        for(int i=0; i<nums.size(); i++){\\n            maks = max(maks,nums[i]);\\n            hence+=maks+nums[i];\\n            conver.push_back(hence);\\n        }\\n       \\n        return conver;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420067,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    const ans = [];\\n    let max = 0, sum = 0;\\n    for (const n of nums) {\\n        max = Math.max(max, n);\\n        sum += n + max;\\n        ans.push(sum);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420037,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] res = new long[nums.length];\\n        long sum = 0;\\n        long max = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n            sum += nums[i] + max;\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420028,
                "title": "1-loop-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int t = 0, n = nums.size(); \\n        vector<long long> ans(n, 0);\\n        \\n        for(int i=0; i<n; i++){\\n            t = max(t, nums[i]); \\n            ans[i] = nums[i] + t; \\n            if(i>0) ans[i] += ans[i-1];\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420027,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution{\\n    typedef long long ll;\\npublic:\\n    vector<ll> findPrefixScore(const vector<int>&v){\\n        ll n=v.size();\\n        vector<ll>ans(n), pref(n); // Convers\\n        pref[0]=ans[0]=2*v[0];\\n        for(ll i=1, mx=v[0]; i<n; ++i){\\n            mx=max(mx, ll(v[i])); // max so far\\n            pref[i]=v[i]+mx;\\n            ans[i]=ans[i-1]+pref[i]; // sum of Convers, i.e., the cur score\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419998,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long x = nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(x<nums[i]) x = nums[i];\\n            nums[i] += x;\\n        }\\n        vector<long long> ans(nums.size());\\n        ans[0] = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans[i] += (nums[i]+ans[i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419983,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        long max = nums[0];\\n       \\n        for(int i =0 ;i < nums.length;i++){\\n            if(nums[i] > max){\\n                max = nums[i];\\n            }\\n             System.out.println(max);\\n            long sum = max + nums[i];\\n            arr[i] = sum;\\n        }\\n        for(int i =1 ;i<arr.length;i++){\\n            arr[i] = arr[i] + arr[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101062,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long arr[] = new long[nums.length];\\n        long max = Integer.MIN_VALUE;\\n        long sum = 0;\\n        for(int i=0; i<nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088059,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maximum = nums[0]\\n        res = [2 * nums[0]]\\n        for i in range(1, len(nums)):\\n            maximum = max(maximum, nums[i])\\n            res.append(res[i - 1] + nums[i] + maximum)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081077,
                "title": "easy-to-understand-c-o-n-beats-94-59",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> v;\\n        int m = 0;\\n        long long sum = 0;\\n        for(int i = 0; i<nums.size(); ++i){\\n            m = max(m, nums[i]);\\n            nums[i] = nums[i] + m;\\n            sum += nums[i];\\n            v.push_back(sum);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072916,
                "title": "java-solution-100-faster-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int[] conver = new int[nums.length];\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n\\n            conver[i] = nums[i]+max;\\n        }\\n\\n        long[] ans = new long[nums.length];\\n\\n        ans[0] = conver[0];\\n\\n        for(int i = 1; i < nums.length; i++)\\n            ans[i] = ans[i-1]+conver[i];\\n\\n        return ans;   \\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069449,
                "title": "very-easy-using-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069443,
                "title": "very-easy-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       int n=nums.size();\\n       int maxi=-1;\\n       vector<long long>ans;\\n       long long sum=0;\\n       map<int,int>mp;\\n       for(int i=0;i<n;i++){\\n           maxi=max(maxi,nums[i]);\\n           mp[i]=maxi;\\n           sum+=(nums[i]+mp[i]);\\n           ans.push_back(sum);\\n       }\\n       return ans;\\n      \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066305,
                "title": "c-really-easy-and-clean-solution",
                "content": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int N=nums.size();\\n        vector<long long> res(N);\\n        vector<long long> conv(N);\\n        long long score=0, maxVal=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            maxVal = max(maxVal, (long long)nums[i]);\\n            conv[i] = nums[i] + maxVal;\\n            score += conv[i];\\n            res[i] = score;\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 4063799,
                "title": "python-elegant-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the `accumulate(nums, max)` to keep track of the running maximum, \\n`map(add, nums, accumulate(nums, max))` to add the running maxima to the elements of the input list, and finally `accumulate` all that to get the desired result.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - we bascially do what amounts to a single iteration over the source list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - it\\'s all iterators inside, no temporary lists are ever allocated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        return accumulate(map(add, nums, accumulate(nums, max)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051688,
                "title": "simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int max=INT_MIN;\\n        vector<long long> ans;\\n        long long score =0;\\n        int idx=0;\\n\\n        while(idx<nums.size())\\n        {\\n            if (max <nums[idx])\\n            {\\n                max = nums[idx];\\n            }\\n            score = score + nums[idx] + max;\\n            ans.push_back(score);\\n            idx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043158,
                "title": "beats-99-68-runtime-most-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        vector<long long>conver;\\n        int ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ma=max(ma,nums[i]);\\n            conver.push_back(nums[i]+ma);\\n        }\\n        vector<long long>ans;\\n        long long res=0;\\n        for(int i=0;i<conver.size();i++)\\n        {\\n            res+=conver[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040810,
                "title": "prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int ax=1;\\n        long long p=0;\\n        vector<long long>ans;\\n        for(int i=0;i<size(nums);i++){\\n            ax=max(ax,nums[i]);\\n            p+=ax+nums[i];\\n            ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038388,
                "title": "easy-o-n-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefix = new long[nums.length];\\n        long[] res = new long[nums.length];\\n        int prev = nums[0];\\n        res[0] = prev + nums[0];\\n        for (int i = 1; i < prefix.length; i++) {\\n            prev = Math.max(prev, nums[i]);\\n            long curr = prev + nums[i];\\n            res[i] = curr + res[i - 1];\\n        }\\n        return res;\\n    }\\n}\\n/**\\n2, 2 -> 4\\n\\n2 3 -> 4 6 -> 10\\n\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037276,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> findPrefixScore(List<int> nums) {\\n      final List<int> res = [0];\\n      var prevMax = 0;\\n      for (int i = 0; i < nums.length; i++) {\\n          prevMax = max(prevMax, nums[i]);\\n          final totalAtIndex = prevMax + nums[i];\\n          final total = totalAtIndex + res.last;\\n          res.add(total);\\n      }\\n\\n      return res.sublist(1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035243,
                "title": "step-by-step-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] ans = new long[nums.length];\\n\\n        //This maxArray will store the max value till ith position\\n        int [] maxArray = new int[nums.length];\\n        int[] conversion =  new int[nums.length];\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0 ; i<nums.length;i++){\\n            max = Math.max(max,nums[i]);\\n            maxArray[i] = max;\\n        }\\n        for(int i = 0 ; i<nums.length;i++){\\n            conversion[i] = nums[i] + maxArray[i];\\n            System.out.println(conversion[i]);\\n        }\\n        ans[0] = conversion[0];\\n        for(int i = 1; i<nums.length;i++){\\n            ans[i] = (long)(conversion[i] + ans[i-1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020332,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] r = new long[nums.length];\\n        int max = nums[0];\\n        for (int i = 0; i < nums.length; i ++) {\\n            if (max < nums[i]) {\\n                max = nums[i];\\n            }\\n            int conv = nums[i] + max;\\n            if (i == 0) {\\n                r[i] = conv;\\n            }\\n            else {\\n                r[i] = conv + r[i - 1];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017769,
                "title": "easiest-solution-in-single-traversal-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        long long sum=0;\\n        int maxi=0;\\n        for(auto i:nums){\\n            maxi=max(maxi,i);\\n            sum=sum+i+maxi;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016660,
                "title": "short-code-easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>&n){\\n        vector<long long>ans;\\n        long long mx=0 , sum=0;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]>mx){\\n                mx=n[i];\\n            }\\n            sum+=n[i]+mx;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999361,
                "title": "java-straightforward",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int  maxd =  nums[0] ;\\n        long res[] = new long[nums.length];\\n        res[0] = maxd*2 ;\\n        for(int i = 1; i< nums.length ; i++){\\n            \\n            maxd = Math.max(nums[i] , maxd);\\n            res[i] = maxd + nums[i] + res[i-1]; \\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996249,
                "title": "c-easy-and-understandable",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long >ans;\\n        vector<int>v;\\n        int mx=nums[0];\\n        v.push_back(mx+nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            mx=max(nums[i],mx);\\n            v.push_back(nums[i]+mx);\\n        }\\n        long long  k=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans.push_back(1LL*(k+v[i]));\\n            k=ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994065,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n = nums.length;\\n        long[] arr = new long[n];\\n        long prefix =0,max=0;\\n\\n        for(int i=0;i<n;i++){\\n           max =  Math.max(max,nums[i]);\\n           arr[i] = nums[i] + max + prefix;\\n           prefix = arr[i];\\n     }\\n       return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992531,
                "title": "how-can-this-question-be-of-medium-level-difficulty-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> findPrefixScore(vector<int>& nums) \\n{\\n        vector<long long> ans;\\n        long long curr=0;\\n        int mx=-100;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i]); // max number till current index\\n            curr+= (mx+nums[i]); // addition of currnumber with max number till curr index and storing the sum\\n            ans.push_back(curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989319,
                "title": "find-the-score-of-all-prefixes-of-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        arr[0] = nums[0]+max;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            arr[i] = nums[i]+arr[i-1]+max;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988324,
                "title": "python-simple-python-solution-prefix-sum-98-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 409 ms, faster than 98.17% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n# Memory Usage: 38.9 MB, less than 81.41% of Python3 online submissions for Find the Score of All Prefixes of an Array.\\n![image](https://assets.leetcode.com/users/images/b2a7499e-0801-4f5b-943e-b4e4fa283cc2_1693569893.2199633.png)\\n\\n\\n\\tclass Solution:\\n\\t\\tdef findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n\\t\\t\\tresult = []\\n\\n\\t\\t\\tcurrent_max = nums[0]\\n\\n\\t\\t\\tresult.append(nums[0] * 2)\\n\\n\\t\\t\\tfor num in nums[1:]:\\n\\n\\t\\t\\t\\tcurrent_max = max(current_max , num)\\n\\n\\t\\t\\t\\tresult.append(result[-1] + num + current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n\\tTime Complexity : O(n)\\n\\tSpace Complexity : O(n)\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3986671,
                "title": "very-easy-approach-using-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n\\n        vector<long long> output;\\n\\n        long long sum = 0;\\n        long int temp;\\n        output.push_back(nums[0]*2);\\n        sum = nums[0]*2;\\n        long int maxele = nums[0];\\n        for(int i = 1;i<nums.size();i++){\\n\\n            // if(nums[i-1] > nums[i]){\\n            //     temp = nums[i-1]+nums[i];\\n            // }else{\\n            //     temp = nums[i]*2;\\n            // }\\n\\n            if(maxele <= nums[i]){\\n                maxele = nums[i];\\n            }\\n            temp=maxele + nums[i];\\n\\n            sum+=temp;\\n\\n            output.push_back(sum);\\n\\n            \\n        }\\n        return output;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980151,
                "title": "prefixsum-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefixSum Java Easy Solution\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] prefixSum = new long[nums.length];\\n\\n        prefixSum[0] = nums[0] + nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > max)\\n                max = nums[i];\\n            prefixSum[i] = prefixSum[i-1] + nums[i] + max;\\n        }\\n\\n        return prefixSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975237,
                "title": "beats-98-23-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> since we need to return vector.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n       vector<long long> pre(nums.size());\\n       int maxi=nums[0];\\n       pre[0]=maxi+nums[0];\\n       for(int i=1; i<nums.size(); i++) {\\n           maxi=max(maxi, nums[i]);\\n           pre[i]=nums[i]+pre[i-1]+maxi;\\n       }\\n       return pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966494,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        int maxi=0;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=max(maxi,nums[i]);\\n            long long val=maxi+nums[i];\\n            sum=sum+val;;\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963370,
                "title": "swift-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findPrefixScore(_ nums: [Int]) -> [Int] {\\n    var maxVal = 0\\n    var result = [Int]()\\n    \\n    for num in nums {\\n        maxVal = max(maxVal, num)\\n        result.append(num + maxVal)\\n    }\\n    var arr = [Int]()\\n    var cur = 0\\n    for i in result {\\n        cur += i\\n        arr.append(cur)\\n    }\\n    return arr\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962597,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long ans[]=new long[n];\\n        int min=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(min<=nums[i])\\n            {\\n                min=nums[i];\\n            }\\n            ans[i]+=min+nums[i];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            ans[i]+=ans[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957803,
                "title": "easy-and-well-explained",
                "content": "\\n\\n# Approach\\nmaintain a maxi variable to store the maximum till the current element.\\nInitialise a pre variable to store the score of previous elements.\\nUpdate the pre variable every time .\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int maxi=-1;\\n        long long pre=0;\\n        long long curr;\\n        vector<long long>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            maxi=max(maxi,nums[i]);\\n\\n             curr=maxi+nums[i];\\n\\n            ans.push_back(curr+pre);\\n            pre=curr+pre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951346,
                "title": "c-prefix-sum-simple-code",
                "content": "\\n\\n# Code\\n```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// #define int long long\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& v) {\\n        long long max = v[0];\\n        vector<long long> ans;\\n        ans.push_back(v[0]*2);\\n        for(int i = 1; i<v.size(); i++){\\n            if(v[i]>max) max=v[i];\\n            long long x = v[i] + max;\\n            ans.push_back(ans[i-1]+x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944076,
                "title": "elegant-solution-java-beats-70",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int max= Integer.MIN_VALUE;\\n        long [] conArr = new long[nums.length];\\n        long [] conArrAns = new long[nums.length];\\n\\n        for(int i=0;i<nums.length;i++)\\n        {   \\n            int j=0;\\n            if(nums[i]>max)\\n            max=nums[i];\\n            conArr[i] = nums[i]+max;     \\n        }\\n        long sum=0;\\n        for(int i=0;i<conArr.length;i++)\\n        {\\n            sum =sum +conArr[i];\\n            conArrAns[i]=sum;\\n        }\\n        return conArrAns;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943782,
                "title": "soooooooooooooo-much-easyyyyyyyyyyyyy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        maxi=nums[0]\\n        count=0\\n        for i in nums:\\n            if i>=maxi:\\n                count = count +(i+i)\\n                maxi=i\\n            else:\\n                count=count+(i+maxi)\\n            ans.append(count)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931863,
                "title": "elixir-solution-use-enum-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 285ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 85MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_prefix_score(nums :: [integer]) :: [integer]\\n  def find_prefix_score(nums) do\\n    Enum.reduce(nums, {0, [0]}, fn num, {t_max, ans} ->\\n      t_max = max(t_max, num)\\n      {t_max, [num + t_max + (ans |> hd) | ans]}\\n    end) |> elem(1) |> Enum.reverse() |> tl\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3926316,
                "title": "python-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        maxx=nums[0]\\n        nums[0]=nums[0]*2\\n        \\n        sum=nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]>maxx:\\n                maxx=nums[i]\\n            nums[i]+=maxx\\n            sum+=nums[i]\\n            nums[i]=sum\\n            \\n        return nums\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926266,
                "title": "c-code-beats-100-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int max = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                if (max < nums[i])\\n                {\\n                    max = nums[i];\\n                }\\n\\n                nums[i] += max;\\n            }\\n\\n            long[] answer = new long[nums.Length];\\n            answer[0] = nums[0];\\n\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                answer[i] = answer[i - 1] + nums[i];\\n            }\\n            return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913564,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        res=[]\\n        maxx=-1\\n        cnt=0\\n        for i in range(len(nums)):\\n            if maxx<nums[i]:\\n                maxx=nums[i]\\n            cnt+=nums[i]+maxx\\n            res.append(cnt)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910941,
                "title": "python-solution-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findPrefixScore(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        a = []\\n        sum = 0\\n        max = nums[0]\\n        for i in range(0,len(nums)):\\n            if nums[i]>max:\\n                max = nums[i]\\n            sum = sum + max + nums[i]\\n            a.append(sum)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904134,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] result=new long[nums.length];\\n        int max=nums[0];\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            max=Math.max(max,nums[j]);\\n            nums[j]=max+nums[j];\\n        }\\n\\n        long sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum+=nums[i];\\n            result[i]=sum;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903415,
                "title": "straight-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        current_max = nums[0]\\n        conver = [0]*len(nums)\\n        conver[0] = 2*current_max\\n\\n        for i in range(1, len(nums)):\\n            current_max = max(current_max, nums[i])\\n            conver[i] = conver[i-1] + nums[i] + current_max\\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902615,
                "title": "java-straight-forward-easy-to-understand-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n = nums.length;\\n        long[] scores = new long[n];\\n\\n        long score = 0;\\n\\n        long maxVal = nums[0];\\n\\n        int index = 0;\\n\\n        for(int val : nums){\\n            maxVal = Math.max(maxVal, val);\\n            score += val + maxVal;\\n            scores[index++] = score;\\n        }\\n        return scores;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901008,
                "title": "java-easy-prefix-sum-100-beats",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long conver[]=new long[nums.length];\\n        long arr[]=new long[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           max=Math.max(max,nums[i]);\\n           conver[i]=nums[i]+max;\\n        }\\n\\n        arr[0]=conver[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            arr[i]=arr[i-1]+conver[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892092,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### Use for loop to go through the nums array.\\n##### Keep a variable max to keep track of the maximum element till i\\n##### Add max to the current nums[i] now you got the conversion array value\\n##### After finding the value we have to add to final_temp which gives score at index i of our solution array.\\n\\n# Complexity\\n## - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n##### O(n) where n is length of nums array.\\n\\n## - Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n##### O(n) as we are storing the result in an array res of length n.\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        long res[]=new long[n];\\n        long max=0;\\n        long final_temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(max<nums[i])\\n                max=nums[i];\\n            long temp=nums[i]+max;\\n            final_temp+=temp;\\n            res[i]=final_temp;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887877,
                "title": "golang-o-n-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findPrefixScore(nums []int) []int64 {\\n\\tprevMax := nums[0]\\n\\tans := make([]int64, len(nums))\\n\\tans[0]=int64(nums[0]*2)\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tprevMax = max(nums[i], prevMax)\\n\\t\\tans[i] = int64(nums[i] + prevMax)+ans[i-1]\\n\\t}\\n\\treturn ans\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878745,
                "title": "efficient-solution-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        lenNum=len(nums)\\n        ans=[]\\n        sum=0\\n        maxnum=-9999\\n        for i in range(lenNum):\\n            if maxnum < nums[i]:\\n                maxnum=nums[i]\\n            sum +=maxnum+nums[i]\\n            ans.append(sum)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874890,
                "title": "c-time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep track of max and previous score when iterating\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] FindPrefixScore(int[] nums) {\\n        int maxValue = 0;\\n        long prevScore = 0;\\n        long[] ret = new long[nums.Length];\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] > maxValue)\\n                maxValue = nums[i];\\n\\n            ret[i] = prevScore + nums[i] + maxValue;\\n\\n            prevScore = ret[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862678,
                "title": "c-o-n-time-space-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find prefix max of all elements in array\\nThen find arr[i]+prefixMax[i] its conversion array\\nNow find prefix sum of conversion array\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>maxPrefix(nums.size());\\n        //Step:1 finding prefix max of array\\n        maxPrefix[0]=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=max((long long)nums[i],maxPrefix[i-1]);\\n        }\\n        //ZStep-2 converting maxPrefix array to conversion array\\n        for(int i=0;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+nums[i];\\n        }\\n        //Step:3 now calculating prefix sum of conversion array\\n        for(int i=1;i<nums.size();i++){\\n            maxPrefix[i]=maxPrefix[i]+maxPrefix[i-1];\\n        }\\n        return maxPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859012,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nimplementation\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>ans;\\n        long long temp=0;\\n        int mx=0;\\n        for(auto i:nums){\\n            mx=max(mx,i);\\n            ans.push_back(temp+mx+i);\\n            temp+=mx+i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852180,
                "title": "c-shortest-o-n-space-time",
                "content": "# Approach\\n\\nSince vector elements are always default-initialized but we wouldn\\'t care about its default values here, let\\'s put it at least to some use and pass as \"default value\" the one that should be in the first element, i.e. `largest \\xD7 2`. This would allow us to 1) skip first cycle 2) get rid of `i` boundary check in the cycle.\\n\\nOther than that, the code is straigtforward: we go through `nums` vector and compute each element according to the task description.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(const vector<int>& nums) {\\n        int largest = nums[0];\\n        vector<long long> answer(nums.size(), largest * 2);\\n        for (size_t i = 1; i < nums.size(); ++i) {\\n            largest = max(largest, nums[i]);\\n            answer[i] = largest + nums[i] +  answer[i-1];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841137,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        long long maxi=nums[0];\\n        vector<long long>ans(n);\\n        ans[0]=maxi+nums[0];\\n        for (int i=1;i<n;i++)\\n        {\\n           if (nums[i]>maxi) maxi=nums[i];\\n            ans[i]=1LL*nums[i]+maxi+ans[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838349,
                "title": "javascript-you-got-it-mate",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findPrefixScore = function(nums) {\\n    let conv = []\\n    let max = 0\\n    let sum = 0\\n    for(let i=0;i<nums.length;i++){\\n        max = Math.max(max,nums[i])\\n        conv[i] = max + nums[i]\\n        sum += conv[i]\\n        nums[i] = sum\\n    }\\n\\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834572,
                "title": "linear-python",
                "content": "# Intuition\\nSince the formula for converting each element only relies on the maximum among prior elements, and the formula for score only relies on summing prior sub-arrays, we can probably do this in linear time with a single pass while keeping track of maximum and score.\\n\\n# Approach\\nLoop through the array calculating conversion value and score along the way.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ; we only traverse the array once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ ; we allocate one extra array to hold the answer which is the same length as the input\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        score = 0\\n        scores = [None] * len(nums)\\n        for idx, i in enumerate(nums):\\n            if i > m:\\n                m = i\\n            score += (i + m)\\n            scores[idx] = score\\n        return scores\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832694,
                "title": "c-beats-100-users-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n, 0);\\n        int maxi = nums[0];\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            ans[i] = nums[i]+maxi;\\n        }\\n        vector<long long> res(n, 0);\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=ans[i];\\n            res[i] = sum;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823424,
                "title": "javascript-100-runtime",
                "content": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst findPrefixScore = (nums) => {\\n  let prefix = 0;\\n  let max = 0;\\n  return nums.map((num) => {\\n    max = Math.max(max, num);\\n    prefix += num + max;\\n    return prefix;\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3803091,
                "title": "python3-3-lines-o-n-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse the accumulate() and map() functions to create intermediary lists efficiently.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        a = list(itertools.accumulate(nums, max))\\n        a = list(map(add, nums, a))\\n        return list(itertools.accumulate(a))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799998,
                "title": "python3-one-pass-beats-99-52",
                "content": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        mx=nums[0]\\n        cumsum=0\\n        ls=[]\\n        for i in nums:\\n            if i>mx:\\n                mx=i\\n            conver=i+mx\\n            cumsum+=conver\\n            ls.append(cumsum)\\n        \\n        return ls\\n![image](https://assets.leetcode.com/users/images/158e8585-19fb-4f54-bd3c-6af9944dc537_1690014678.3895664.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3779535,
                "title": "simple-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- cv is vector storing the max element upto i th element\\n- mx is vector storing the sum , the convert array \\n ( mx[i] = nums[i] + max(nums[0....i]) ) upto i th element\\n- the loop iterates over nums and with each itertion cv stores the max element upto i\\n- mx stores the sum of num arrays with max element making the conversion array making the resultant array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![leet.jpeg](https://assets.leetcode.com/users/images/efc6a9a0-bdef-4071-80c9-79274758646e_1689612916.0885437.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> cv(nums.size(),0);  //stores max element\\n        vector<long long> mx(nums.size(),0);    //stores sum upto i th element making the convert array\\n        cv[0]=nums[0];\\n        mx[0]=nums[0]+cv[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            cv[i]=max(nums[i],cv[i-1]);\\n            mx[i]=nums[i]+cv[i]+mx[i-1];\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760113,
                "title": "o-n-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Observation. `ans` store cummulative sum of elements of `conver` of whole `nums`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRather than calculating `conver` for whole `nums`, As we want to store cummulative sum as we iterate through `conver` in `ans`.\\n`conver[i] = nums[i] + maxi`, so rather than storing `conver`,\\ntake a variable `sum` we stores cummulative sum of elements of `conver` on each iteration, and store the value in the corresponding `ans[i]`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long> ans(n);\\n        int maxi = -1e9;\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi, nums[i]);\\n            sum += nums[i] + maxi;\\n            ans[i] = sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743854,
                "title": "c-easy-to-understand-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> ans;\\n        vector<int> store;\\n        int a=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>a)\\n                a=nums[i];\\n            int push=a+nums[i];\\n            store.push_back(push);\\n        }\\n        long long sum=0;\\n        for(int i=0;i<store.size();i++){\\n            sum+=(long long)store[i];\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741585,
                "title": "typescript-solution-beats-speed-100-memory-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction findPrefixScore(nums: number[]): number[] {\\n    \\n    const n: number = nums.length;\\n    let result: number[] = [...Array(n+1)].fill(0);\\n    let maxResult: number = 0;\\n    for(let i=0; i<nums.length; i++) {\\n       maxResult = Math.max(nums[i], maxResult);\\n       result[i+1] = result[i] + maxResult + nums[i];\\n    }\\n    result = result.slice(1);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3717471,
                "title": "optimal-solution-o-n-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        currMax = 0\\n        ans = []\\n\\n        for n in nums:\\n            currMax = max(currMax, n)\\n            if not ans:\\n                ans.append(currMax + n)\\n            else:\\n                ans.append(currMax + n + ans[-1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708003,
                "title": "easily-understandable-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<long long> v(n);\\n        long long sum=0;\\n        v[0]=2*nums[0];\\n        int m=nums[0];\\n        sum+=v[0];\\n        for(int i=1;i<n;i++){\\n            m=max(m,nums[i]);\\n            long long p=nums[i]+m;\\n            sum+=p;\\n            v[i]=sum;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701913,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum\\n\\n# Approach\\nCreate an empty array ( or an array having an filler value). Create a  ```max_till_now``` variable to store the max value of the the array at that instant while traversing the loop. Add the value of max_till-now to the the iterator and append the value to the ```ans``` array.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```max_till_now```\n```ans```\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans = [0]\\n        max_till_now = nums[0]\\n\\n        # ans = []\\n        for num in nums:\\n            max_till_now = max(max_till_now, num)\\n            n = num + max_till_now\\n            ans.append(ans[-1] + n )\\n\\n            # print(ans)  \\n        return ans[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698236,
                "title": "python-prefix-sum",
                "content": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums):\\n        maxPrefix = [nums[0]]\\n        for i in range(1, len(nums)):\\n            maxPrefix.append(max(maxPrefix[-1], nums[i]))\\n        ans = [maxPrefix[0] + nums[0]]\\n        for i in range(1, len(maxPrefix)):\\n            ans.append(ans[-1] + maxPrefix[i] + nums[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697048,
                "title": "prefix-sum-one-pass-simple-java-solution-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n    long ans[]=new long[nums.length];\\n    long max=Long.MIN_VALUE;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        max=Math.max(max,nums[i]);\\n        ans[i]=nums[i]+max;\\n        if(i!=0)\\n            ans[i]+=ans[i-1];\\n    }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696796,
                "title": "c-clean-code-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<int> v=nums;\\n        vector<long long int> a;\\n        int m=v[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m=max(m,v[i]);\\n            v[i]=m;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        a.push_back(v[i]+nums[i]);\\n        long long int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            c+=a[i];\\n            a[i]=c;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688982,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        long long int res=0, mx = 0;\\n        vector<long long int> ans;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            mx = max(mx, (long long)nums[i]);\\n            res += mx + (long long)nums[i];\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688538,
                "title": "explaination-in-hindi-and-easy-to-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        // is problem me hamko current element aur 0 to i range tk k maximum value find krna hai.\\n// aur current element aur largest value(0-i range) k sum find krna hai \\n// aur us sum ko ek  new array me dalna hai.\\n// uske bad prefix sum find krna hai \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n       // long data type use karege kyoki return type long diya hua hai \\n        int n  = nums.length;\\n        long prefix1[] = new long[n];\\n        long prefix2[] = new long[n];\\n        int largest = Integer.MIN_VALUE;\\n        for(int i =0; i<n ;i++)\\n        {\\n    // largest number find kr rhe hai yha pr 0 to i range tk \\n            if(nums[i]>largest)\\n            {\\n                largest = nums[i];\\n            }\\n // new prefix Array me ham current element aur largest element k sum dalege \\n            prefix1[i] = nums[i]+largest;\\n        }\\n        long  m = prefix1.length;\\n   // simple yha pr jaise PREFIX SUM find krte hai wo find krna hai \\n        prefix2[0] = prefix1[0];\\n        for(int i=1;i<m;i++)\\n        {\\n            prefix2[i] = prefix2[i-1]+prefix1[i];\\n        }\\n // last me ham prefix2 array ko  return kr dege\\n        return prefix2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683940,
                "title": "using-stack-and-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore max value in a variable rather than to find max value for each iteration\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse nums and find converse use stack to find score\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n\\n        stack=[0]\\n\\n        m=nums[0]\\n\\n        for i in range(0,len(nums)):\\n            if nums[i]>m:\\n                m=nums[i]\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n            else:\\n                g=nums[i]+m+stack[-1]\\n                stack.append(g)\\n        \\n        stack.remove(stack[0])\\n        return stack\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671148,
                "title": "python3-solution-with-using-prefix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        conver = [0] * len(nums)\\n\\n        cur_max = 0\\n        for idx in range(len(nums)):\\n            cur_max = max(cur_max, nums[idx])\\n            conver[idx] = cur_max + nums[idx]\\n\\n        for idx in range(1, len(conver)):\\n            conver[idx] += conver[idx - 1]\\n        \\n        return conver\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669194,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        mx=0\\n        for num in nums:\\n            mx=max(num,mx)\\n            if len(ans)>0:\\n                ans.append(mx+num+ans[-1])\\n            else:\\n                ans.append(mx+num)\\n\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667211,
                "title": "one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        m = -1\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            nums[i] += m\\n            if i >0:\\n                nums[i]+=nums[i-1]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665090,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```\\nIf you made it this far please upvote.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int m = 0;\\n        int[] max = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            max[i] = Math.max(m, nums[i]);\\n            m = max[i];\\n        }\\n\\n        long n = 0;\\n        long[] result = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            result[i] = nums[i] + max[i] + n;\\n            n = result[i];\\n        }\\n        return result;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664357,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] score = new long[nums.length];\\n        int max  = Integer.MIN_VALUE;\\n        long conver = 0; long i_score =0;\\n        for(int i =0;i <nums.length;i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            conver = nums[i]+max;\\n            i_score += conver;\\n            score[i] = i_score;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659176,
                "title": "c-solution-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long> arr;\\n        int max = nums[0];\\n        long long sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr.push_back(sum);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659174,
                "title": "java-solution-o-n-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] arr = new long[nums.length];\\n        int max = nums[0];\\n        long sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            sum = sum + max + nums[i];\\n            arr[i] = sum;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657727,
                "title": "easy-solution-straight-forward-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>res(nums.size());\\n    \\n        int maxi=nums[0],x;\\n        for(int i=0;i<nums.size();i++){\\n              if(nums[i]>maxi){\\n                  maxi=nums[i];\\n              }\\n              x=nums[i]+maxi;\\n              if(i==0){\\n                res[i]=x;\\n              }else{\\n                 res[i]=res[i-1]+x;\\n              }\\n        }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652788,
                "title": "2-ms-runtime-beats-100-simple-observation-java",
                "content": "# Intuition\\nNotice from example 1 the differences between each array of the answer. The first difference is 6 which is the sum of the current max, 3, and the current element 3. Notice the third difference 12, which is the sum of the current max, 7, and the current element 5. \\n\\n# Approach\\nIf we calculate these differences and add them to the previous element, we can get the next element in our output array. Gang!\\n# Complexity\\nThe time complexity is O(N) - we traverse the array just once. \\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = nums[0];\\n        long[] out = new long[nums.length];\\n        out[0] = nums[0] + max;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            out[i] = nums[i] + out[i-1] + max;\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652005,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int n=nums.length;\\n        int[] t=new int[n];\\n        int max=Integer.MIN_VALUE;\\n        long[] res=new long[n];\\n        for(int i=0;i<n;i++){\\n            max=Math.max(max,nums[i]);\\n            t[i]=max;\\n        }\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            res[i]=nums[i]+t[i]+sum;\\n            sum=res[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642587,
                "title": "98-11-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nauto _ = []()\\n{\\n    std::cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>a;\\n        a.push_back(nums[0]);\\n        for(int i = 1 ; i<nums.size();i++){\\n            if(nums[i]>a[a.size()-1]){\\n                a.push_back(nums[i]);\\n            }\\n            else{\\n                a.push_back(a[a.size()-1]);\\n            }\\n        }\\n        for(int i = 0 ; i<nums.size();i++){\\n            a[i] = a[i] + nums[i];\\n        }\\n        for(int i = 1 ; i<a.size() ; i++){\\n            a[i] = a[i-1] + a[i];\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637272,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep record of sum of convertion array till each element\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore max and sum of convertion array for each element and add converted array element for that index \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findPrefixScore(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=0\\n        m=0\\n        for i in range(len(nums)):\\n            m=max(m,nums[i])\\n            s=s+nums[i]+m\\n            l.append(s)\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618344,
                "title": "beginner-freindly-approach-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<long long>mx(n);\\n        mx[0] = nums[0];\\n        int mxe = nums[0];\\n        for(int i=1; i<n; i++){\\n            mxe = max(mxe, nums[i]);\\n            mx[i]=mxe;\\n\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            mx[i] = mx[i]+nums[i];\\n        }\\n        for(int i=1; i<n; i++){\\n            mx[i] = mx[i]+mx[i-1];\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586372,
                "title": "beat-100-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        int max = 0;\\n        long[] result = new long[nums.length];\\n        for(int i = 0;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n            if(i == 0){\\n                result[i] = nums[i] + max;\\n            }\\n            else{\\n            result[i] = result[i-1]+nums[i] + max;\\n        \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582084,
                "title": "java-easy-solution",
                "content": "# Intuition\\nMaximum is fixed and direct implementation of given formula\\n\\n# Approach\\nDynamic programming\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        long[] conver = new long[nums.length];\\n        conver[0] = nums[0]*2;\\n        int maxi = nums[0];\\n        for(int i = 1;nums.length>i;i++){\\n            maxi = Math.max(maxi,nums[i]);\\n            conver[i] = maxi+nums[i]+conver[i-1];\\n        }\\n        return conver;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581187,
                "title": "java-simple-solution-o-n-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long[] findPrefixScore(int[] nums) {\\n        long max = 0;\\n        long sum = 0;\\n        long[] ans = new long[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) {\\n                max = nums[i];\\n            }\\n            sum += nums[i] + max;\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571029,
                "title": "simple-solution-in-a-single-loop-prefix-sum",
                "content": "# Intuition\\n<a href=\"https://ibb.co/mDwk4pt\"><img src=\"https://i.ibb.co/BzxbBkj/null-1.png\" alt=\"null-1\" border=\"0\"></a><br />\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<long long int> prefix(len,0);\\n        int mx(0);\\n\\n        for(int i  = 0; i < len; i++){\\n            mx = max(mx,nums[i]);\\n\\n            prefix[i] = (nums[i] + mx);\\n\\n            if(i > 0){\\n                prefix[i] += prefix[i - 1];\\n            }\\n        }\\n\\n        return prefix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567821,
                "title": "simple-java-solution-using-array-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO( N )<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO( N )<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long[] findPrefixScore(int[] nums) {\\n        \\n        int n=nums.length;\\n        long[] ans=new long[n]; //for final ans\\n        long[] max=new long[n]; //for calculating sum of element and max\\n                                // before it\\n\\n        max[0]=2*nums[0];\\n        long temp=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>temp){\\n                max[i]=2*nums[i];\\n                temp=nums[i]; //Here we have calculted the max value before\\n                             //it and sum of that element.\\n            }\\n            else max[i]=temp+nums[i];\\n        }\\n        \\n        ans[0]=max[0];\\n\\n        for(int i=1;i<n;i++){\\n            ans[i]=ans[i-1]+max[i]; //we calculated the prefix sum using\\n                                    // max array.\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567125,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nfirst calculating the prefix sum then calculating the score. for calculating prefix sum used priority queue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n), where n is size of nums.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n        vector<long long>pref,ans; \\n        priority_queue<long long>pq;  \\n       // pq.push(nums[0]);\\n        for(int i=0;i<nums.size();i++) \\n        { \\n             pq.push(nums[i]);\\n           pref.push_back(nums[i]+pq.top()); \\n          \\n        } \\n        ans.push_back(pref[0]); \\n        for(int i=1;i<pref.size();i++) \\n        {\\n            ans.push_back(ans[i-1]+pref[i]);\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566507,
                "title": "c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<long long> Get_converted(vector<int> &nums)\\n{\\n    vector<long long> ans = {};\\n    long long maximum = nums[0];\\n    for(int i = 0; i<nums.size(); i++)\\n    {\\n        maximum = max((long long)nums[i], maximum);\\n        int x = nums[i] + maximum;\\n        ans.push_back(x);\\n    }\\n    return ans;\\n}\\nvoid Get_added(vector<long long> &ans)\\n{\\n    long long sum = 0;\\n    for(int i = 0; i<ans.size(); i++)\\n    {\\n        sum = sum + ans[i];\\n        ans[i] = sum;\\n    }\\n}\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        // Cancel as answer differs after sorting -> sort(nums.begin(), nums.end());\\n        // We got the conversion array\\n        vector<long long> ans = Get_converted(nums);\\n        Get_added(ans);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864501,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1880976,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1868316,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864344,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1974599,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1938215,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1876746,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1865483,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864439,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            },
            {
                "id": 1864351,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this should be marked under easy"
                    },
                    {
                        "username": "Prajju22",
                        "content": "those who dont know about prefix sum may stuck with this problem"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s giving a TLE so it is not \"Easy\""
                    },
                    {
                        "username": "adityaleo1411",
                        "content": "i think example 1 -4 th  line  is worng double of 5 is given 12\\nbut this is too easy for medium level\\n\\n"
                    },
                    {
                        "username": "GarborSergey",
                        "content": "The difficulty is medium only because of this description?"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Jason-Law](/Jason-Law) may be its about people who dk prefix sum "
                    },
                    {
                        "username": "Jason-Law",
                        "content": "\\uD83D\\uDE02 true"
                    },
                    {
                        "username": "Knight-03",
                        "content": "i think we can do it in constant space also but as lc has given vector of int i\\'m not able to return \\n ```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) \\n    {\\n        long long max_i = nums[0];\\n        vector<long long> ans(nums.size(),0);\\n        int prefix_sum = 0;\\n        nums[0] *= 2;\\n\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            max_i = max(max_i,nums[i]);\\n            nums[i] = nums[i] + (max_i + nums[i-1]);\\n        }\\n        return nums; \\n    }\\n};\\n``` \\nif its wrong any test case you comment it \\n"
                    },
                    {
                        "username": "OP101202",
                        "content": "there are many easy tagged problem which are more difficult than this one but it is still tagged as medium "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "can be stated as easy in medium level questions !"
                    },
                    {
                        "username": "debaudh",
                        "content": "how do they define \"medium\"?\\n"
                    },
                    {
                        "username": "Sailor-lisai",
                        "content": "This is super strait forward, even no need thinking. It should be marked as easy."
                    },
                    {
                        "username": "harrysrangal",
                        "content": "First medium question that I found easy."
                    },
                    {
                        "username": "Rk-43_",
                        "content": "a=[]\\nans=[]\\nfor i in range(len(nums)):\\n        a.append(nums[i]+max(nums[0:i+1]))\\n        ans.append(sum(a))\\nreturn ans \\n\\nwhy this solution is giving TLE with just one for loop where as \\n\\nn = len(nums)\\n        ans = [0] * n\\n        max_val = float(\\'-inf\\')\\n        for i in range(n):\\n            max_val = max(max_val, nums[i])\\n            conver = nums[i] + max_val\\n            ans[i] = conver\\n        res=[]\\n        s=0\\n        for i in range(n):\\n            s+=ans[i]            \\n            res.append(s)\\n            \\n        return res\\nthis solution with two for loop is accepted???  "
                    },
                    {
                        "username": "gopalv5020",
                        "content": "a.append(nums[i]+max(nums[0:i+1]))\nans.append(sum(a))\nyour algorithm is O(n^2) due to using max and sum on the subarray up to index i. This causes it to TLE on bigger inputs "
                    }
                ]
            }
        ]
    },
    {
        "title": "Design Cancellable Function",
        "question_content": "<p>Sometimes you have a long running task, and you may wish to cancel it before it completes. To help with this goal, write a function&nbsp;<code>cancellable</code> that accepts a generator object and returns an array of two values: a <strong>cancel function</strong> and a <strong>promise</strong>.</p>\n\n<p>You may assume the generator function will only&nbsp;yield promises. It is your function&#39;s responsibility to pass the values resolved by the promise back to the generator. If the promise rejects, your function should throw that&nbsp;error back to the generator.</p>\n\n<p>If the cancel callback is called before the generator is done, your function should throw an error back to the generator. That error should be the string&nbsp;<code>&quot;Cancelled&quot;</code>&nbsp;(Not an <code>Error</code>&nbsp;object). If the error was caught, the returned&nbsp;promise should resolve with the next value that was yielded or returned. Otherwise, the promise should reject with the thrown error. No more code should be executed.</p>\n\n<p>When the generator is done, the promise your function returned should resolve the value the generator returned. If, however, the generator throws an error, the returned promise should reject with the error.</p>\n\n<p>An example of how your code would be used:</p>\n\n<pre>\nfunction* tasks() {\n  const val = yield new Promise(resolve =&gt; resolve(2 + 2));\n  yield new Promise(resolve =&gt; setTimeout(resolve, 100));\n  return val + 1; // calculation shouldn&#39;t be done.\n}\nconst [cancel, promise] = cancellable(tasks());\nsetTimeout(cancel, 50);\npromise.catch(console.log); // logs &quot;Cancelled&quot; at t=50ms\n</pre>\n\n<p>If&nbsp;instead&nbsp;<code>cancel()</code> was not called or was called after <code>t=100ms</code>, the promise would&nbsp;have resolved&nbsp;<code>5</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; return 42; \n}\ncancelledAt = 100\n<strong>Output:</strong> {&quot;resolved&quot;: 42}\n<strong>Explanation:</strong>\nconst generator = generatorFunction();\nconst [cancel, promise] = cancellable(generator);\nsetTimeout(cancel, 100);\npromise.then(console.log); // resolves 42 at t=0ms\n\nThe generator immediately yields 42 and finishes. Because of that, the returned promise immediately resolves 42. Note that cancelling a finished generator does nothing.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong>\ngeneratorFunction = function*() { \n&nbsp; const msg = yield new Promise(res =&gt; res(&quot;Hello&quot;)); \n&nbsp; throw `Error: ${msg}`; \n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;rejected&quot;: &quot;Error: Hello&quot;}\n<strong>Explanation:</strong>\nA promise is yielded. The function handles this by waiting for it to resolve and then passes the resolved value back to the generator. Then an error is thrown which has the effect of causing the promise to reject with the same thrown error.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 200)); \n&nbsp; return &quot;Success&quot;; \n}\ncancelledAt = 100\n<strong>Output:</strong> {&quot;rejected&quot;: &quot;Cancelled&quot;}\n<strong>Explanation:</strong>\nWhile the function is waiting for the yielded promise to resolve, cancel() is called. This causes an error message to be sent back to the generator. Since this error is uncaught, the returned promise rejected with this error.\n</pre>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<pre>\n<strong>Input:</strong>\ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100));\n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp; result += yield new Promise(res =&gt; res(1)); \n&nbsp; return result;\n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;resolved&quot;: 2}\n<strong>Explanation:</strong>\n4 promises are yielded. Two of those promises have their values added to the result. After 200ms, the generator finishes with a value of 2, and that value is resolved by the returned promise.\n</pre>\n\n<p><strong class=\"example\">Example 5:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; let result = 0; \n&nbsp; try { \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp;   yield new Promise(res =&gt; setTimeout(res, 100)); \n&nbsp;   result += yield new Promise(res =&gt; res(1)); \n&nbsp; } catch(e) { \n&nbsp;   return result; \n&nbsp; } \n&nbsp; return result; \n}\ncancelledAt = 150\n<strong>Output:</strong> {&quot;resolved&quot;: 1}\n<strong>Explanation:</strong>\nThe first two yielded promises resolve and cause the result to increment. However, at t=150ms, the generator is cancelled. The error sent to the generator is caught and the result is returned and finally resolved by the returned promise.\n</pre>\n\n<p><strong class=\"example\">Example 6:</strong></p>\n\n<pre>\n<strong>Input:</strong> \ngeneratorFunction = function*() { \n&nbsp; try { \n&nbsp;   yield new Promise((resolve, reject) =&gt; reject(&quot;Promise Rejected&quot;)); \n&nbsp; } catch(e) { \n&nbsp;   let a = yield new Promise(resolve =&gt; resolve(2));\n    let b = yield new Promise(resolve =&gt; resolve(2)); \n&nbsp;   return a + b; \n&nbsp; }; \n}\ncancelledAt = null\n<strong>Output:</strong> {&quot;resolved&quot;: 4}\n<strong>Explanation:</strong>\nThe first yielded promise immediately rejects. This error is caught. Because the generator hasn&#39;t been cancelled, execution continues as usual. It ends up resolving 2 + 2 = 4.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>cancelledAt == null or 0 &lt;= cancelledAt &lt;= 1000</code></li>\n\t<li><code>generatorFunction</code> returns a generator object</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3440923,
                "title": "simple-solution-with-async-and-promise-race",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    var cancel;\\n    const cancelPromise = new Promise((_, reject) => { cancel = () => reject(\"Cancelled\"); });\\n    // Every Promise rejection has to be caught.\\n    cancelPromise.catch(()=>{});\\n\\n    const promise = (async () => {\\n        let next = generator.next();\\n        while (!next.done) {\\n            try {\\n                next = generator.next(await Promise.race([next.value, cancelPromise]));\\n            } catch (e) {\\n                next = generator.throw(e);\\n            }\\n        }\\n        return next.value;\\n    })();\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443563,
                "title": "javascript-typescript-simple-solution-with-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nBased on the given code snippet, the `cancellable` function seems to wrap a generator function in a way that allows it to be cancelled using a returned function. The generator function is executed asynchronously using promises and `await`, and the cancellation is implemented by rejecting a cancellation promise that is created inside the `cancellable` function.\\n\\nTo solve this problem, one could start by understanding how generators work in JavaScript/TypeScript and how to use the `Generator` type. Then, one could analyze the given code snippet and try to understand how it works, and what are the roles of the `cancel` function and the `cancelPromise`. Finally, one could try to replicate the same functionality in a different way or extend the existing code to fit a specific use case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngeneral approach that one use to solve a problem:\\n\\n1. Understand the problem: Read and analyze the problem statement, requirements, and constraints. Ensure that you understand the problem\\'s scope, expected output, and any input constraints.\\n\\n2. Research: Look for relevant information, algorithms, libraries, and tools that could help solve the problem. Check for any existing solutions, and learn from their approaches.\\n\\n3. Plan and design: Based on your understanding of the problem and the available resources, plan your approach and design your solution. Break down the problem into smaller sub-problems and identify the key components and functions that you need.\\n\\n4. Implement: Start implementing your solution in code. Follow best practices, write clean, modular, and maintainable code. Test your code frequently and make adjustments as needed.\\n\\n5. Test and validate: Test your code thoroughly, both manually and using automated tests. Validate your code\\'s output against the problem requirements and ensure that it meets the expected results.\\n\\n6. Optimize and improve: Once you have a working solution, look for ways to optimize and improve it. Consider factors such as performance, scalability, security, and usability.\\n\\n7. Document and share: Document your code, including its purpose, usage, and any dependencies. Share your code with others, and contribute to the community by sharing your insights, solutions, and experiences.\\n# Complexity\\nThe time and space complexity of the `cancellable` function depend on the implementation details and the behavior of the generator function passed as a parameter. However, we can analyze the time and space complexity of the `cancellable` function itself:\\n- Time complexity: The `cancellable` function creates a new promise and uses the `Promise.race` method to race between the generator\\'s next value and the cancellation promise. The `Promise.race` method has a time complexity of O(n), where n is the number of promises passed as arguments. The generator function is executed synchronously until it reaches the first `yield` statement, so its time complexity depends on its implementation. Therefore, the time complexity of the `cancellable` function is at least O(1) and at most O(n), where n is the number of promises involved in the race.\\n\\n- Space complexity: The `cancellable` function creates two promises: the cancellation promise and the promise returned by the async function. It also creates a `cancel` function and a `next` variable used to iterate over the generator function. The space complexity of the `cancellable` function is therefore O(1), as the amount of memory used by the function does not depend on the input size. However, the space complexity of the generator function may be higher, depending on its implementation and the amount of data it processes.\\n\\n```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```\\n```TypeScript []\\nconst cancellable = <T>(generator: Generator): [() => void, Promise<T>] => {\\n  let cancel: () => void;\\n  const cancelPromise = new Promise<never>((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async (): Promise<T> => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\nconst cancellable = (generator) => {\\n  let cancel;\\n  const cancelPromise = new Promise((_, reject) => {\\n    cancel = () => reject(\"Cancelled\");\\n  });\\n  // Every Promise rejection has to be caught.\\n  cancelPromise.catch(() => {});\\n\\n  const promise = (async () => {\\n    let next = generator.next();\\n    while (!next.done) {\\n      try {\\n        next = generator.next(await Promise.race([next.value, cancelPromise]));\\n      } catch (e) {\\n        next = generator.throw(e);\\n      }\\n    }\\n    return next.value;\\n  })();\\n\\n  return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564498,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let resolve;\\n  let reject;\\n  let isCancelled = false;\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const cancel = () => {\\n    isCancelled = true;\\n    try {\\n      const obj = generator.throw(\"Cancelled\");\\n      resolve(obj.value);\\n    } catch (e) {\\n      reject(e);\\n    }\\n  };\\n\\n  function helper(val, err) {\\n    if (isCancelled) return;\\n    try {\\n      const obj = err ? generator.throw(err) : generator.next(val);\\n      if (obj.done) {\\n        resolve(obj.value);\\n      } else {\\n        Promise.resolve(obj.value)\\n          .then((result) => helper(result))\\n          .catch((e) => helper(undefined, e));\\n      }\\n    } catch (e) {\\n      reject(e);\\n    }\\n  }\\n  helper();\\n\\n  return [cancel, promise]; \\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608553,
                "title": "design-cancellable-function-compact-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let canceled = false;\\n\\n    return [\\n        () => canceled = true,\\n        (async () => {\\n            let next = generator.next();\\n\\n            while(!next.done){\\n                try {\\n                    let nextValue = await next.value;\\n                    next = canceled ? generator.throw(\"Cancelled\") : generator.next(nextValue);\\n                } catch (e) {\\n                    next = generator.throw(e);\\n                }\\n            }\\n\\n            return next.value;\\n        })()\\n    ]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442426,
                "title": "easy-to-understand",
                "content": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let resolve;\\n    let reject;\\n    let isCancelled = false;\\n    \\n    const promise = new Promise((res, rej) => {\\n        resolve = res;\\n        reject = rej;\\n    });\\n    \\n    const cancel = () => {\\n        isCancelled = true;\\n        try {\\n        \\tconst obj = generator.throw(\"Cancelled\");\\n            resolve(obj.value)\\n        } catch (e) {\\n            reject(e);\\n        }\\n    }\\n    \\n    function helper(val, err) {\\n        if (isCancelled) return;\\n        try {\\n            const obj = err ? generator.throw(err) : generator.next(val);\\n            if (obj.done) {\\n                resolve(obj.value)\\n            } else {\\n                obj.value.then(helper).catch(e => helper(undefined, e))\\n            }\\n        } catch (e) {\\n            reject(e)\\n        }\\n    }\\n    helper();\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445591,
                "title": "a-support-request-to-leetcode",
                "content": "# To Leetcode team\\n\\nHi, so I have a solution that has a bug which manages to pass all the given testcases in the description. However, when I submit it as a solution, it fails and the evaluator says 0 testcases passed. This is not true because if I add logs I can see that most testcases are passing. There seems to be some error in figuring out which testcases are failing for this kind of question. If you have someone available can you look at why that happens with this submission:\\n\\nThing to check:\\n1. Paste this submission\\n2. Run button says all 7 testcases passed\\n3. Submit and the evaluator will say 0 testcases passed\\n\\nNote that I know where the bug is and how to fix it. I have already submitted another solution which fixes the problem. However, I was troubled by the evaluator reporting 0 cases passing. Note also that yo can return the function that is getting assigned to `cancellable` from inside an IIFE to ensure even more isolation but the problem stays.\\n\\n```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\\n\\n# Actual solution that works\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(generator) {\\n    let isCancelled = false;\\n    let cancelledWithValue = false;\\n    let postCancellationValue;\\n    \\n    async function processGen(lastValue) {\\n        if (isCancelled) {\\n            return new Promise((res, rej) => { debugger; rej(\"Cancelled\") });\\n        } \\n        else if (cancelledWithValue) {\\n            return new Promise((res, rej) => { debugger; res(postCancellationValue) });\\n        }\\n        else \\n        {\\n            try {\\n                debugger\\n                const genyield = generator.next(lastValue);\\n                debugger\\n                if (!genyield.done) {\\n                    const promise = new Promise((res, rej) => {\\n                        genyield.value\\n                            .then((result) => {debugger; res(processGen(result))})\\n                            .catch(err => {\\n                                // console.log(err); \\n                                debugger\\n                                const genyield = generator.throw(err);\\n                                if (genyield.done) {\\n                                    genyield.value.then(res).catch(res);\\n                                } else {\\n                                    res(genyield.value.then(result => processGen(result)));\\n                                }\\n                            });\\n                    });\\n                    return promise;\\n                } else {\\n                    return genyield.value;\\n                }\\n            } catch (err) {\\n                // console.log(\"Catch cancel error\", err);\\n                return new Promise((res, rej) => { debugger; rej(err) })\\n            }\\n        }\\n    }\\n\\n    return [\\n        () => { \\n            try {\\n                const genyield = generator.throw(new Error(\"Cancellinig\"));\\n                cancelledWithValue = true;\\n                postCancellationValue = genyield.value;\\n                debugger\\n                console.log(genyield);\\n            } catch (err) {\\n                isCancelled = true;\\n                // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n            }\\n        }, \\n        processGen()\\n    ];\\n}\\n```\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n  let isCancelled = false;\\n  let cancelledWithValue = false;\\n  let postCancellationValue;\\n\\n  async function processGen(lastPromise) {\\n    if (isCancelled) {\\n      return new Promise((res, rej) => { rej(\"Cancelled\") });\\n    } \\n    else if (cancelledWithValue) {\\n      return new Promise((res, rej) => { res(postCancellationValue) });\\n    }\\n    else \\n    {\\n      let lastValue;\\n      let genyield;\\n      try {\\n        lastValue = await lastPromise;\\n        genyield = generator.next(lastValue);\\n      } catch (err) {\\n        lastValue = err;\\n        genyield = generator.throw(lastValue);\\n        console.log(\"Last promise did not resolve!\");\\n      }\\n\\n      try {\\n        if (!genyield.done && !isCancelled && !cancelledWithValue) {\\n            return processGen(genyield.value);\\n        } else if (isCancelled) {\\n            return Promise.reject(\"Cancelled\");\\n        } else if (cancelledWithValue) {\\n            return Promise.resolve(postCancellationValue);\\n        } else {\\n          return genyield.value;\\n        }\\n      } catch (err) {\\n        // console.log(\"Catch cancel error\", err);\\n        return new Promise((res, rej) => { rej(err) })\\n      }\\n    }\\n  }\\n\\n  return [\\n    () => { \\n      try {\\n        const genyield = generator.throw(\"Cancelled\");\\n        cancelledWithValue = true;\\n        postCancellationValue = genyield.value;\\n        console.log(genyield);\\n      } catch (err) {\\n        isCancelled = true;\\n        // console.log(\"Cancellining throw line\\'s error was not caught by generator\");\\n      }\\n    }, \\n    processGen()\\n  ];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440819,
                "title": "design-cancellable-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let reject = null, resolve = null;\\n\\n    let n, value;\\n    let promise = new Promise<T>(async (res,rej) => {\\n        reject = rej;\\n        resolve = res;\\n        try {\\n            for (n = generator.next(); !n.done; n = generator.next(value)) {\\n                value = await n.value;\\n            }\\n\\n            res(n.value);\\n\\n        } catch(err) {\\n            await handleError(err);\\n        }\\n    });\\n\\n    async function handleError(err) {\\n        try {\\n            console.log(\\'in handle err\\');\\n\\n            try {\\n                n = generator.throw(err);\\n            } catch(e) {\\n                reject(err);\\n                return;\\n            }\\n\\n            value = await n.value;\\n\\n            while(!n.done) {\\n                n = generator.next(value);\\n                value = await n.value;\\n                console.log(value, n.done);\\n            }\\n            value != void 0 ? resolve(value) : reject(err);\\n        } catch(e) {\\n            console.log(e, value);\\n\\n            await handleError(err)\\n        }\\n    }\\n\\n    const cancel = async () => {\\n        try {\\n            n = generator.throw(value);\\n            value = await n.value;\\n            resolve(value != void 0 ? value : \"Cancelled\");\\n        } catch(err) {\\n            reject(\"Cancelled\");\\n        }\\n\\n    }\\n\\n    return [cancel, promise];\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025306,
                "title": "recursive-solution-and-easy-to-understand",
                "content": "# Intuition\\n1. Ready the doc of Generator before you start to read or write the code:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw\\n2. Fully underatand how Promise works is the required skill\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n    let reject = null\\n    let accept = null\\n    let promise = new Promise((r, j) => {\\n        reject = j\\n        accept = r\\n        \\n        // A recursion to process generator.next()\\n        function process(value, done) {\\n          const g = generator.next(value)\\n          const valuePromise = Promise.resolve(g.value)\\n          if (g.done) {\\n            valuePromise.then(done).catch(reject)\\n            return\\n          }\\n\\n          // A recursion to process nested try catch in the generator function\\n          function processCatch(value) {\\n            try {\\n                const result = generator.throw(new Error(\\'Cancelled\\'))\\n                if (result.done) {\\n                  Promise.resolve(value).then(accept)\\n                } else {\\n                  Promise.resolve(result.value).then((v) => {\\n                    process(v, done)\\n                  }).catch((v) => {\\n                    processCatch(v)\\n                  })\\n                }\\n            } catch (err) {\\n              reject(value)\\n            }\\n          }\\n          valuePromise.then((value) => {\\n            process(value, done)\\n          }).catch(processCatch)\\n        }\\n        process(null, accept)\\n    })\\n    return [function() {\\n      try {\\n        const result = generator.throw(\\'Cancelled\\')\\n         if (result.done) {\\n            accept(result.value)\\n        } else {\\n            reject(\\'Cancelled\\')\\n        }\\n      } catch (err) {\\n        reject(err)\\n        return\\n      }\\n     \\n    }, promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951692,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Code\\n```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (generator) => {\\n  let resolve = () => {};\\n  let reject = () => {};\\n\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n\\n  const handleError = (e, shouldResolve) => {\\n    try {\\n      if (!shouldResolve) return generator.throw(e);\\n      resolve(generator.throw(e).value);\\n    } catch (err) {\\n      reject(err);\\n    }\\n  };\\n\\n  const handleLoop = (cur) => {\\n    if (!cur) return;\\n    if (cur.done) return resolve(cur.value);\\n    cur.value\\n      .then((val) => handleLoop(generator.next(val)))\\n      .catch((err) => handleLoop(handleError(err, false)));\\n  };\\n\\n  handleLoop({\\n    value: Promise.resolve(),\\n    done: false,\\n  });\\n\\n  return [() => handleError(\"Cancelled\", true), promise];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847351,
                "title": "posted-my-first-solution-on-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    let isCancelled = false\\n    \\n    function cancelFunction() {\\n        isCancelled = true\\n    }\\n    \\n    const promise = new Promise(async (resolve, reject) => {\\n        let resolvedValue\\n        try {\\n let { done, value: pr } = generator.next()\\n        if(done) {\\n            resolvedValue = pr\\n            resolve(resolvedValue)\\n        }\\n            while(done === false) {\\n                try {\\n                const value = await pr\\n                let d, v\\n                if(isCancelled) {\\n                    const { done: d1, value: v1 } = generator.throw(\\'Cancelled\\')\\n                    d = d1\\n                    v = v1\\n                }\\n                else {\\n                    const { done: d2, value: v2 } = generator.next(value)\\n                    d = d2\\n                    v = v2\\n                }\\n                resolvedValue = v\\n                done = d\\n                pr = v\\n                if(done) {\\n                    resolvedValue = pr\\n                    resolve(resolvedValue)\\n                }\\n            }\\n            catch(err) {\\n                try {\\n                    const { done: d1, value: v1 } = generator.throw(err)\\n                    if(d1) {\\n                        done = true\\n                        resolve(err)\\n                    }\\n                    else {\\n                        done = d1\\n                        pr = v1\\n                    }\\n                }\\n                catch (err) {\\n                    done = true\\n                    reject(err)\\n                }\\n            }\\n        }\\n        }\\n\\n        catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancelFunction, promise]\\n    \\n}\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742714,
                "title": "recursive-solution-without-using-async-await",
                "content": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Approach\\nI solved this problem without using async/await. Recursive `iterator` sets and reads a closure variable `rejected` and routes the value back to the iterator.\\n\\n# Code\\n```\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function (generator) {\\n    // this is a boilerplate to get a cancel function that rejects a `Promise` captured in the function closure.\\n    let cancelFn;\\n    const cancelPromise = new Promise((_, reject) => {\\n        cancelFn = () => reject(\"Cancelled\");\\n    });\\n    cancelPromise.catch(() => { });\\n\\n    let rejected = false\\n\\n    // helper functions used in promise chaining \\n    function reject(val) {\\n        rejected = true\\n        return val\\n    }\\n    function accept(val) {\\n        rejected = false\\n        return val\\n    }\\n\\n\\n    // recursive iterator\\n    function iterator(lastVal) {\\n        let res\\n        if (rejected) {\\n            res = generator.throw(lastVal)\\n        } else {\\n            try {\\n                res = generator.next(lastVal)\\n            } catch (e) {\\n                return Promise.reject(e)\\n            }\\n        }\\n        // once iterator is done just resolve it\\'s value\\n        if (res.done) {\\n            return Promise.resolve(res.value)\\n        }\\n        \\n        return Promise\\n            .race([Promise.resolve(res.value), cancelPromise]) // while iterator is not done, race it with cancel function\\n            .then(accept, reject) // set rejected true of false\\n            .then(iterator, iterator) // recursive call for resolved and rejected promise\\n    }\\n\\n    return [cancelFn, iterator()]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3672778,
                "title": "faster-and-easier-solution-to-undestand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnother quick and simple solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let isCancelled = false\\n    function cancel() {\\n        isCancelled = true\\n    }\\n\\n    const promise = new Promise<T>(async (resolve, reject) => {\\n        try {\\n            let lastYielded = generator.next()\\n            while (!lastYielded.done) {\\n                try {\\n                    const res = await lastYielded.value\\n                    lastYielded = isCancelled ? generator.throw(\"Cancelled\") : generator.next(res)\\n                } catch(err) {\\n                    lastYielded = generator.throw(err)\\n                }\\n            }\\n            resolve(lastYielded.value)\\n        } catch (err) {\\n            reject(err)\\n        }\\n    })\\n\\n    return [cancel, promise]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3632981,
                "title": "brief-explanation-in-typescript-using-try-catch-syntax",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`genCall` is a function which calls the next yielding element and if it is not done yielding it keeps calling itself in turns to the point of resolution.\\nSame functionality is needed when we throw something to generator which is handled by explicitThrow param which is by default false.\\nwhile cancelling we simply call `genCall( \"Cancelled\",true);` that handles the rest for us.\\n\\nNote within `genCall` there are two try catch blocks, first one simply rejects as, if there is some error that is now handled and happens during generator function execution it should be rejected. While in the second one we are seeking if there is some error thrown from the promise that is returned in that case we simply chain that value to next call. \\n# Code\\n```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let res,rej,done=false;  \\n    let promise: Promise<T> = new Promise(async (rs,rj)=>{\\n        rej=rj;\\n        res=rs\\n    })\\n    async function genCall(val?:any,explicitThrow:boolean=false){\\n     let genData;\\n     try{\\n     genData = explicitThrow?generator.throw(val): generator.next(val);\\n    }catch(err){\\n        rej(err);\\n        return;\\n    }\\n     try{\\n        if(genData.done){\\n            let result= await genData.value\\n            done=true;\\n            res(result);\\n            return;\\n        }\\n        else{\\n              let result= await genData.value\\n              genCall(result);\\n        }\\n     }\\n     catch(err){\\n                  genCall( err,true);\\n     }\\n\\n    }\\n    genCall();\\n    return [()=>{    \\n                try {\\n                    genCall( \"Cancelled\",true);\\n                } \\n                catch (e) {\\n                    rej(e);\\n                }\\n    },promise]\\n};\\n\\n/**\\n * function* tasks() {\\n *   const val = yield new Promise(resolve => resolve(2 + 2));\\n *   yield new Promise(resolve => setTimeout(resolve, 100));\\n *   return val + 1;\\n * }\\n * const [cancel, promise] = cancellable(tasks());\\n * setTimeout(cancel, 50);\\n * promise.catch(console.log); // logs \"Cancelled\" at t=50ms\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3622155,
                "title": "using-recursion",
                "content": "# Intuition\\nSolution using recursion\\n\\n\\n# Code\\n```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// A RECURSIVE VERSION\\n\\n/**\\n * @param {Generator} generator\\n * @return {[Function, Promise]}\\n */\\nvar cancellable = function(generator) {\\n\\n    var promiseResolve;\\n    var promiseReject\\n\\n    var handleNextPromise = function({ value, done}) {\\n        if(done) promiseResolve(value);\\n        else value\\n        .then( resolved => handleNextPromise(generator.next(resolved)))\\n        .catch(err => {\\n            try { handleNextPromise(generator.throw(err)) }\\n            catch {promiseReject(err)}\\n        });\\n    }\\n\\n    var promise = new Promise(\\n        (resolve, reject) => {\\n            promiseResolve = resolve;\\n            promiseReject = reject;\\n            handleNextPromise(generator.next(undefined));\\n        }\\n    );\\n\\n    var cancel = () => {\\n        try {\\n            var {value: lastValue, done: lastDone} = generator.throw(\"Cancelled\");\\n            promiseResolve(lastValue)\\n        } catch(generatorError) {\\n            promiseReject(generatorError);\\n        }\\n    }\\n\\n    return [cancel, promise];\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606837,
                "title": "efficient-cancellable-promises-in-typescript-achieving-control-and-flexibility-in-asynchronous",
                "content": "# Intuition\\nThe code is implementing a cancellable promise in JavaScript. It makes use of generators and promises to achieve this. The `cancellable` function takes a generator as an argument. This generator is expected to yield promises. The `cancellable` function returns a pair consisting of a cancel function and a promise. When the cancel function is called, the promise gets rejected with the reason \\'Cancelled\\'.\\n\\n# Approach\\nThe `cancellable` function starts by initializing some variables. It then creates a promise which will be returned and used for the computation. This promise is handled by an `async` function which is immediately invoked. This function calls `next` on the generator and enters a loop. Inside the loop, it waits for the promise yielded by the generator to be fulfilled or for the cancel promise to be fulfilled, whichever happens first. If the cancel promise is fulfilled, an error is thrown which is caught and rethrown to the generator. The loop continues until the generator is done.\\n\\nIf the cancel function is called, it rejects the cancel promise, which causes the promise race to resolve with an error. This error is then propagated through the generator, causing the computation to be cancelled.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n), where n is the number of promises yielded by the generator. This is because we\\'re going through each yielded promise one by one.\\n- Space complexity: The space complexity is O(1), as we\\'re only using a constant amount of space. No matter the number of promises yielded by the generator, we\\'re only storing a constant amount of variables.\\n\\n# Code\\n\\n```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\\n    let cancelRequested = false;\\n    let resolveFunc: (value: T | PromiseLike<T>) => void;\\n    let rejectFunc: (reason?: any) => void;\\n    let cancelFunc: () => void;\\n\\n    const promise = new Promise<T>((resolve, reject) => {\\n        resolveFunc = resolve;\\n        rejectFunc = reject;\\n\\n        const cancelPromise = new Promise((_, reject) => {\\n            cancelFunc = () => reject(\\'Cancelled\\');\\n        });\\n\\n        const run = async () => {\\n            try {\\n                let result = generator.next();\\n                while (true) {\\n                    if (result.done) {\\n                        resolveFunc(result.value);\\n                        return;\\n                    }\\n                    try {\\n                        const value = await Promise.race([result.value, cancelPromise]);\\n                        result = generator.next(value);\\n                    } catch (err) {\\n                        result = generator.throw(err);\\n                    }\\n                }\\n            } catch (err) {\\n                rejectFunc(err);\\n            }\\n        };\\n\\n        run();\\n    });\\n\\n    const cancel = () => {\\n        cancelRequested = true;\\n        cancelFunc();\\n    };\\n\\n    return [cancel, promise];\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1877960,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1886735,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            },
            {
                "id": 1941911,
                "content": [
                    {
                        "username": "Hbaf",
                        "content": "> You may assume the generator function will only yield promises\\n\\nYou may not. Fist example throws that away"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "True"
                    },
                    {
                        "username": "shrinivas2",
                        "content": "One of the test case fails when run with the other tests but passes on its own. :("
                    },
                    {
                        "username": "umarf22",
                        "content": "The explanation could have been better. It\\'s quite difficult to understand. Why write a wall of text instead of organising the steps into a list of points?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Counter II",
        "question_content": "<p>Write a function&nbsp;<code>createCounter</code>. It should accept an initial integer&nbsp;<code>init</code>. It should return an object with three functions.</p>\n\n<p>The three functions are:</p>\n\n<ul>\n\t<li><code>increment()</code>&nbsp;increases&nbsp;the current value by 1 and then returns it.</li>\n\t<li><code>decrement()</code>&nbsp;reduces the current value by 1 and then returns it.</li>\n\t<li><code>reset()</code>&nbsp;sets the current value to&nbsp;<code>init</code>&nbsp;and then returns it.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> init = 5, calls = [&quot;increment&quot;,&quot;reset&quot;,&quot;decrement&quot;]\n<strong>Output:</strong> [6,5,4]\n<strong>Explanation:</strong>\nconst counter = createCounter(5);\ncounter.increment(); // 6\ncounter.reset(); // 5\ncounter.decrement(); // 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> init = 0, calls = [&quot;increment&quot;,&quot;increment&quot;,&quot;decrement&quot;,&quot;reset&quot;,&quot;reset&quot;]\n<strong>Output:</strong> [1,2,1,0,0]\n<strong>Explanation:</strong>\nconst counter = createCounter(0);\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.decrement(); // 1\ncounter.reset(); // 0\ncounter.reset(); // 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-1000 &lt;= init &lt;= 1000</code></li>\n\t<li><code>0 &lt;= calls.length &lt;= 1000</code></li>\n\t<li><code>calls[i]</code> is one of &quot;increment&quot;, &quot;decrement&quot; and&nbsp;&quot;reset&quot;</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494650,
                "title": "day3-o-1-solving-it-in-3-different-ways-and-which-one-is-the-best-way",
                "content": "From the question we can decipher that we need to have three functions `increment(), decrement() and reset()`. Now let\\'s think which one will be appropriate method to solve this question.\\n***\\n## 1. Using Traditional Function\\n* A **traditional function** is defined using the `function` keyword. It can be a **named function** or an **anonymous function** assigned to a variable. \\n* In the following code we have created three functions  `increment()`, `decrement()` and `reset()` using the `function` keyword. Inside this function we need to do the appropriate operation that was instructed in the question i.e. for `increment()` we need to return the `currentvalue+1`, similarly in `decrement()` we need to return the `currentvalue-1` and in `reset()` we need to assign `originalvalue` to the `currentvalue`.\\n```\\nvar createCounter = function(init) {\\n  let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## 2. Using Arrow Function\\n* An **arrow function** is a shorter syntax for defining functions, introduced in ES6. \\n* It uses the **=> syntax** instead of the function keyword, and has some differences in behavior compared to traditional functions, such as **inheriting** the `this` value from the **surrounding context**\\n* For better understanding please read this posts : **Arrow function**(6min read) by **[@Jatin](https://leetcode.com/problems/create-hello-world-function/discuss/3486895/DAY(O(1))-Why-you-should-prefer-arrow-function-syntax!)** and **Closure on Counter-1**(8min read) problem by **[@Jatin](https://leetcode.com/problems/counter/discuss/3491300/Day2O(1)greaterUnderstanding-Closure-in-easy-way-and-its-practical-uses!!)**\\n\\n```\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## 3. Using Class\\n* A **class** is a template for creating objects with a set of properties and methods.\\n* In `ES6`, `classes` were introduced as syntactic sugar over the prototype-based inheritance model but shortly after that It **provided a way to support inheritance and can have static methods and properties, getters and setters, and more**. Thus they provided a way to write object-oriented code in a more concise and organized way.\\n\\n* In the following example the `Couter` is the name of the class.\\n\\t*  The constructor method is a special method that is called when an **object is created based on the class**.\\n\\t*  It initializes the object with properties `init` and `presentCount`. The `increment()`, `decrement()`and `reset()` method are regular methods that can be **called on an instance** of the `Counter` class to get the output\\n\\t* To create an object based on a class we use the `new` operator i.e. we create an object called `createCounter` based on the `Counter` class, passing in the `init` value as **arguments to the constructor**.\\n\\n```\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.presentCount = init;\\n  }\\n\\n  increment() {\\n    this.presentCount += 1;\\n    return this.presentCount;\\n  }\\n\\n  decrement() {\\n    this.presentCount -= 1;\\n    return this.presentCount;\\n  }\\n\\n  reset() {\\n    this.presentCount = this.init;\\n    return this.presentCount;\\n  }\\n}\\n\\nvar createCounter = function(init) {\\n  return new Counter(init);\\n};\\n```\\n**Time and Space: O(1)**\\n***\\n## In conclusion which one is the better way??\\n* **Classes** are useful for creating objects with shared behavior.\\n*  **Traditional functions** are useful for reusable chunks of code\\n*   **Arrow functions** are useful for short, concise functions or when preserving the value of `this` is important.\\n* Thus, I believe that classes are the best way to implement this types of problems in real life as they give flexibility of scaling with the shared behaviour properties. \\n***\\nYou can support this article by upvoitng \\u2B06\\u2B06!!\\n***\\nHere\\'s my [github link](https://github.com/Jatin-Shihora) where I keep my solutions.\\n***",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n  let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n```\n```\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n```\n```\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.presentCount = init;\\n  }\\n\\n  increment() {\\n    this.presentCount += 1;\\n    return this.presentCount;\\n  }\\n\\n  decrement() {\\n    this.presentCount -= 1;\\n    return this.presentCount;\\n  }\\n\\n  reset() {\\n    this.presentCount = this.init;\\n    return this.presentCount;\\n  }\\n}\\n\\nvar createCounter = function(init) {\\n  return new Counter(init);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495319,
                "title": "2665-counter-ii-level-up-your-javascript-skills-with-these-intuitive-implementations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>The `createCounter` function creates a counter object that can be used to keep track of a count and perform operations on it. The returned object has three methods: `increment`, `decrement`, and `reset`, which respectively increase the count by 1, decrease the count by 1, and reset the count to its initial value.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>The `createCounter` function uses a closure to create a private `count` variable that is initialized to either the provided `init` value or 0 if no value is provided. It then defines three inner functions (`increment`, `decrement`, and `reset`) that operate on this count variable and return its new value. Finally, it returns an object containing these three functions as properties, providing a public interface for manipulating the count.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The `createCounter` function has a space complexity of O(1) as it creates a fixed number of variables (count, increment, decrement, reset) that are not dependent on the size of the input\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>Each instance of the counter object created by `createCounter` has a space complexity of O(1) as well, as it only contains three function properties and the count variable, which are all fixed-size.\\n\\n\\n# Code\\n```Javascript []\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let count = init || 0; // initialize count to 0 or given value\\n\\n  const increment = function() {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = function() {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = function() {\\n    count = init || 0;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n``` typescript []\\ninterface Counter {\\n  increment(): number;\\n  decrement(): number;\\n  reset(): number;\\n}\\n\\nconst createCounter = (init: number = 0): Counter => {\\n  let count: number = init;\\n\\n  const increment = (): number => {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = (): number => {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = (): number => {\\n    count = init;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\nconst counter: Counter = createCounter(5);\\n\\nconsole.log(counter.increment()); // 6\\nconsole.log(counter.reset()); // 5\\nconsole.log(counter.decrement()); // 4\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n> ##### There are several ways to implement a counter object with increment, decrement, and reset functionality in JavaScript. Here are a few alternative approaches:\\n\\n1. Using an ES6 class\\n```\\nclass Counter {\\n  constructor(init = 0) {\\n    this.count = init;\\n  }\\n\\n  increment() {\\n    return ++this.count;\\n  }\\n\\n  decrement() {\\n    return --this.count;\\n  }\\n\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n}\\n```\\n>Here, we define a `Counter` class with a constructor that takes an optional `init` parameter (defaulting to 0). We also define three methods (`increment`, `decrement`, and `reset`) that modify the `count` property and return its new value.\\n\\n\\n2. Using an object literal\\n```\\nconst counter = {\\n  count: 0,\\n  increment() {\\n    return ++this.count;\\n  },\\n  decrement() {\\n    return --this.count;\\n  },\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n};\\n\\n```\\n>Here, we define an object literal with a `count` property and three methods (`increment`, `decrement`, and `reset`) that modify the `count` property and return its new value.\\n3. Using a factory function\\n```\\nfunction createCounter(init = 0) {\\n  let count = init;\\n\\n  return {\\n    increment() {\\n      return ++count;\\n    },\\n    decrement() {\\n      return --count;\\n    },\\n    reset() {\\n      count = 0;\\n      return count;\\n    }\\n  };\\n}\\n```\\n>Here, we define a `createCounter` factory function that returns an object with three methods (`increment`, `decrement`, and `reset`) that modify a private `count` variable and return its new value.\\n\\n# Important topic to Learn\\n```\\n1. Closures: A closure is a function that has access to variables in\\n its outer lexical environment. The original implementation of the \\n`createCounter` function uses a closure to create a private `count`\\n variable that is shared by the `increment`, `decrement`, and `reset`\\n functions. Understanding closures is essential for writing clean \\nand efficient JavaScript code.\\n\\n2. Object-oriented programming (OOP): OOP is a programming paradigm \\nthat uses objects and classes to encapsulate data and behavior. The \\nES6 class-based implementation of the counter object demonstrates\\nhow to define a class with properties and methods, while the object \\nliteral and factory function approaches use object-based programming \\nto define a set of related methods.\\n\\n3. JavaScript syntax: Understanding basic JavaScript syntax is \\nessential for writing clean and readable code. The original \\nimplementation and alternative approaches use different syntax \\nelements, such as arrow functions, default parameter values, and \\nobject destructuring, that are common in modern JavaScript code.\\n\\n4. DOM manipulation: If you\\'re interested in front-end web \\ndevelopment, you\\'ll need to learn how to manipulate the Document \\nObject Model (DOM) using JavaScript. You can use a counter object to \\nupdate the text content or attributes of a HTML element in response \\nto user events, such as button clicks or key presses.\\n\\n```\\n\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```Javascript []\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let count = init || 0; // initialize count to 0 or given value\\n\\n  const increment = function() {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = function() {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = function() {\\n    count = init || 0;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n``` typescript []\\ninterface Counter {\\n  increment(): number;\\n  decrement(): number;\\n  reset(): number;\\n}\\n\\nconst createCounter = (init: number = 0): Counter => {\\n  let count: number = init;\\n\\n  const increment = (): number => {\\n    count++;\\n    return count;\\n  };\\n\\n  const decrement = (): number => {\\n    count--;\\n    return count;\\n  };\\n\\n  const reset = (): number => {\\n    count = init;\\n    return count;\\n  };\\n\\n  return { increment, decrement, reset };\\n};\\n\\nconst counter: Counter = createCounter(5);\\n\\nconsole.log(counter.increment()); // 6\\nconsole.log(counter.reset()); // 5\\nconsole.log(counter.decrement()); // 4\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nclass Counter {\\n  constructor(init = 0) {\\n    this.count = init;\\n  }\\n\\n  increment() {\\n    return ++this.count;\\n  }\\n\\n  decrement() {\\n    return --this.count;\\n  }\\n\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n}\\n```\n```\\nconst counter = {\\n  count: 0,\\n  increment() {\\n    return ++this.count;\\n  },\\n  decrement() {\\n    return --this.count;\\n  },\\n  reset() {\\n    this.count = 0;\\n    return this.count;\\n  }\\n};\\n\\n```\n```\\nfunction createCounter(init = 0) {\\n  let count = init;\\n\\n  return {\\n    increment() {\\n      return ++count;\\n    },\\n    decrement() {\\n      return --count;\\n    },\\n    reset() {\\n      count = 0;\\n      return count;\\n    }\\n  };\\n}\\n```\n```\\n1. Closures: A closure is a function that has access to variables in\\n its outer lexical environment. The original implementation of the \\n`createCounter` function uses a closure to create a private `count`\\n variable that is shared by the `increment`, `decrement`, and `reset`\\n functions. Understanding closures is essential for writing clean \\nand efficient JavaScript code.\\n\\n2. Object-oriented programming (OOP): OOP is a programming paradigm \\nthat uses objects and classes to encapsulate data and behavior. The \\nES6 class-based implementation of the counter object demonstrates\\nhow to define a class with properties and methods, while the object \\nliteral and factory function approaches use object-based programming \\nto define a set of related methods.\\n\\n3. JavaScript syntax: Understanding basic JavaScript syntax is \\nessential for writing clean and readable code. The original \\nimplementation and alternative approaches use different syntax \\nelements, such as arrow functions, default parameter values, and \\nobject destructuring, that are common in modern JavaScript code.\\n\\n4. DOM manipulation: If you\\'re interested in front-end web \\ndevelopment, you\\'ll need to learn how to manipulate the Document \\nObject Model (DOM) using JavaScript. You can use a counter object to \\nupdate the text content or attributes of a HTML element in response \\nto user events, such as button clicks or key presses.\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494506,
                "title": "solutions-in-javascript-and-typescript",
                "content": "# Approach\\n- You can use Prefix Increment/Decrement syntax to replace += 1 and -= 1. This syntax allows you to increment or decrement a number and return it at the same time.\\n- To combine the initialization of currentCount and its return, you can assign its initial value in the same line that you return it. In JavaScript, when you assign a value to a variable, it returns that value automatically. \\n- To make the code more concise, you can switch from function syntax to arrow syntax when defining the functions.\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/RbpZLA8F/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "# Approach\\n- You can use Prefix Increment/Decrement syntax to replace += 1 and -= 1. This syntax allows you to increment or decrement a number and return it at the same time.\\n- To combine the initialization of currentCount and its return, you can assign its initial value in the same line that you return it. In JavaScript, when you assign a value to a variable, it returns that value automatically. \\n- To make the code more concise, you can switch from function syntax to arrow syntax when defining the functions.\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/RbpZLA8F/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3485377,
                "title": "closure-3-lines",
                "content": "# Approach\\n```\\nfunction createCounter(init) {\\n    let value = init;\\n\\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init,\\n    }\\n};\\n```\\n\\n**NOTE #1:** Using the prefix increment/decrement updates `value` befure returing it.\\n\\n**NOTE #2:** When assigmnent used as return value, assignment is performed first, then the value of the variable to the left is returned.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ on each call\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction createCounter(init) {\\n    let value = init;\\n\\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484246,
                "title": "straight-forward-o-1",
                "content": "# Intuition\\nJust do it.\\n\\n# Approach\\nJust do it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    c = i = init\\n\\n    function increment() {\\n        return ++c\\n    }\\n\\n    function decrement() {\\n        return --c\\n    }\\n\\n    function reset() {\\n        return c = i\\n    }\\n    return {increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    c = i = init\\n\\n    function increment() {\\n        return ++c\\n    }\\n\\n    function decrement() {\\n        return --c\\n    }\\n\\n    function reset() {\\n        return c = i\\n    }\\n    return {increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494507,
                "title": "closure-counter-object-in-javascript",
                "content": "The `createCounter` function returns an object with three methods: `increment`, `decrement`, and `reset`.\\n\\nWhen `createCounter` is called with an initial value init, it creates a closure over a local variable count, which is initialized to init.\\n\\nThe increment method increases the value of count by `1`, and then returns the new value of count. The decrement method decreases the value of count by `1`, and then returns the new value of `count`. The `reset` method sets the value of count back to the initial value init, and then returns the new value of count.\\n\\nBecause each method is defined within the same closure, they all have access to the same `count` variable, and can modify it as needed.\\n\\nThis implementation allows you to create multiple independent counters, each with their own initial value and independent count variable.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n  let count = init;\\n\\n  return {\\n    increment: () => {\\n      count++;\\n      return count;\\n    },\\n\\n    decrement: () => {\\n      count--;\\n      return count;\\n    },\\n\\n    reset: () => {\\n      count = init;\\n      return count;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n  let count = init;\\n\\n  return {\\n    increment: () => {\\n      count++;\\n      return count;\\n    },\\n\\n    decrement: () => {\\n      count--;\\n      return count;\\n    },\\n\\n    reset: () => {\\n      count = init;\\n      return count;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494783,
                "title": "o-1-easy-solution-98-commented-with-examples",
                "content": "This code defines a function createCounter that takes an initial value init as a parameter and returns an object that contains three methods: **increment**, **decrement**, and **reset**.\\n\\nThe ans variable is initialized with the value of init. This variable is defined inside the **createCounter** function, so it is only accessible within the scope of the returned object.\\n\\n\\n* The  **increment**  method is an arrow function that **increments** the ans variable and returns its new value. The decrement method is also an arrow function that decrements the ans variable and returns its new value. Both these methods use the increment and decrement operators ++ and --, respectively.\\n\\n* The **reset** method is an arrow function that assigns the ans variable the value of init, effectively resetting the counter to its original value.\\n\\n* The **returned** object contains these three methods, and these methods can be used to manipulate the ans variable in different ways. For example, you can use the **increment** and **decrement** methods to increase or ***decrease*** the value of the counter, respectively, while the reset method can be used to reset the counter to its initial value.\\n\\nYou can create multiple counter objects with different initial values by calling the **createCounter** function with different init values.\\n\\n***Here is an example of it*** \\n```\\n// create a counter object starting from 5\\nconst counter = createCounter(5);\\n\\n// increment the counter by 1\\nconsole.log(counter.increment()); // output: 6\\n\\n// decrement the counter by 2\\nconsole.log(counter.decrement()); // output: 5\\nconsole.log(counter.decrement()); // output: 4\\n\\n// reset the counter to its initial value\\ncounter.reset();\\nconsole.log(counter.increment()); // output: 5\\n\\n```\\nIn this example, we create a counter object starting from the value 5 using the ***createCounter function***. We then use the increment method to increase the counter by 1 and print the result to the console, which outputs 6. We then use the ***decrement*** method twice to decrease the counter by 2 and print the results to the console, which outputs 5 and 4, respectively. Finally, we use the reset method to reset the counter to its initial value and then use the ***increment method*** to increase the counter by 1 and print the result to the console, which outputs 5.\\n\\n```\\n\\nvar createCounter = function(init) {\\n    var ans = init;\\n\\n    return {\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init,\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// create a counter object starting from 5\\nconst counter = createCounter(5);\\n\\n// increment the counter by 1\\nconsole.log(counter.increment()); // output: 6\\n\\n// decrement the counter by 2\\nconsole.log(counter.decrement()); // output: 5\\nconsole.log(counter.decrement()); // output: 4\\n\\n// reset the counter to its initial value\\ncounter.reset();\\nconsole.log(counter.increment()); // output: 5\\n\\n```\n```\\n\\nvar createCounter = function(init) {\\n    var ans = init;\\n\\n    return {\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init,\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493336,
                "title": "my-createcounter",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const counter = {\\n    c: init,\\n    t: init,\\n    increment() {\\n      return ++this.c;\\n    },\\n    reset() {\\n      this.c = this.t;\\n      return this.c;\\n    },\\n    decrement() {\\n      return --this.c;\\n    }\\n  };\\n  \\n  return counter;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const counter = {\\n    c: init,\\n    t: init,\\n    increment() {\\n      return ++this.c;\\n    },\\n    reset() {\\n      this.c = this.t;\\n      return this.c;\\n    },\\n    decrement() {\\n      return --this.c;\\n    }\\n  };\\n  \\n  return counter;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495296,
                "title": "easy-to-understand-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return{\\n        increment:function(){\\n            c++;\\n          return c;\\n        },\\n       decrement:function(){\\n           c--;\\n           return c;\\n       },\\n       reset:function(){\\n           c=init;\\n           return c;\\n       }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return{\\n        increment:function(){\\n            c++;\\n          return c;\\n        },\\n       decrement:function(){\\n           c--;\\n           return c;\\n       },\\n       reset:function(){\\n           c=init;\\n           return c;\\n       }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495271,
                "title": "javascript-day-3-of-30-days-challange",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    let resetVal = init;\\n\\n    let obj = {\\n        increment : () => ++counter,\\n        decrement : () => --counter,\\n        reset : () => counter = resetVal\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    let resetVal = init;\\n\\n    let obj = {\\n        increment : () => ++counter,\\n        decrement : () => --counter,\\n        reset : () => counter = resetVal\\n    }\\n\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596195,
                "title": "easiest-full-explanation",
                "content": "# Intuition\\nYou\\'re probbably thinking , damn that\\'s an easy problem. I just have to return 3 objects in a function. Well , not really .\\n\\nThe following leetcode problem is a practice on whats called\\n# Factory Method ( FM ) Design Pattern .\\nKeep reading I\\'ll explain in Depth and provide a solution\\n\\n# Approach\\nLet\\'s Solve this Problem using FM.\\n\\n# **Definition : What\\'s with the Factory Method ?**\\n1. It\\'s a creational Design Pattern : It allows us to create and return different objects\\n2. It provides a way to encapsulate the object creation process within a function.\\n# Use Cases : Why do we need it and what\\'s its advantages ?\\n\\n- To Organize our Code\\n- To provide Flexibility\\n- Saves time and the effort of duplication\\n\\n# STILL CONFUSED ? LET\\'S BREAK IT DOWN EVEN MORE AND LOOK AT OUR EXAMPLE IN THIS LEETCODE PROBLEM\\n\\nIn our code snippet , the \\'createCounter\\' function is a factory method . This factory method creates a counter object , let\\'s explore what\\'s happening :\\n\\n- When we call createCounter and pass an initial value, it returns an object.\\n- The returned object allows us to perform operations on the counter, such as incrementing, decrementing, and resetting its value.\\n- This way, we can create multiple independent counters by invoking the createCounter function with different initial values.\\n# NOW IT\\'S TIME FOR A RECAP\\n\\nThe factory method is like a special function that creates and gives you objects. Instead of directly creating objects yourself, you use this function, which knows how to create the objects you need.\\nThe factory function knows how to create the objects and returns them to you.\\n\\n# To create and use the Factory Method Design pattern we :\\n- Define a factory function\\n- Create a new instance of the desired object inside our function\\n- Return the created object\\n\\n\\nNow that\\'s it , hope you liked my explanation . Remmember to always look deep behind the problem itself and understand the entire Concept Hope I helped , Kindly upvote If I did : )\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497509,
                "title": "javascript-object-simplest-solution",
                "content": "```\\nvar createCounter = function(init) {\\n  var count = init;\\n  return {\\n    increment: () => {return ++count}, \\n    decrement: () => {return --count}, \\n    reset: () => {return count = init}\\n  };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n  var count = init;\\n  return {\\n    increment: () => {return ++count}, \\n    decrement: () => {return --count}, \\n    reset: () => {return count = init}\\n  };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494911,
                "title": "sort-easy-and-conscise-solution-using-closure-property-of-javascript",
                "content": "# Code\\n```\\nvar createCounter = function(init) {\\n    let curr = init;\\n    return { increment:()=>++curr, reset:()=>curr=init, decrement:()=>--curr};\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let curr = init;\\n    return { increment:()=>++curr, reset:()=>curr=init, decrement:()=>--curr};\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494625,
                "title": "easily-explained-in-3-step-javascript",
                "content": "# Intuition\\nIncrese and Decrese the value by `+1` and `-1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) In increment function use pre-increment function to increment the value at that step.\\n2) In decrement function use pre-decrement function to decrement the value ar that step.\\n3) Reset function is very important -> You should save your `init` value in a `variable`. When calling reset function make sure you first reset your `init` and then return.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` JavaSript []\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaSript []\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494525,
                "title": "direct-solution-beats-96",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return{\\n        increment :()=>++count,\\n        decrement :()=> --count,\\n        reset : ()=>count = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return{\\n        increment :()=>++count,\\n        decrement :()=> --count,\\n        reset : ()=>count = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497875,
                "title": "day-3-30-days-js-challenge-best-editorial-everything-explained-easy-to-understand",
                "content": "# Intuition\\nThe intuition behind this code is to create a counter object that allows you to perform three actions: $$increment$$ the counter by $$1$$, $$decrement$$ the counter by $$1$$, and $$reset$$ the counter to its initial value.\\n\\n# Approach\\nThe approach used in the code is to create a closure. The variable $$ans$$ is declared within the $$createCounter()$$ function and is assigned the initial value $$init$$. The returned object contains three functions that have access to this $$ans$$ variable through closure.\\n\\nHere\\'s an explanation of each function:\\n\\n1.$$increment()$$: This function increments the $$ans$$ variable by $$1$$ using the pre-increment operator $$(++)$$. It returns the incremented value of $$ans$$.\\n2.$$decrement()$$: This function decrements the $$ans$$ variable by $$1$$ using the pre-decrement operator $$(--)$$. It returns the decremented value of $$ans$$.\\n3.$$reset()$$: This function assigns the $$init$$ value to the $$ans$$ variable, effectively resetting it to its initial value. It does not return any value.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the $$increment()$$ and $$decrement()$$ functions is $$O(1)$$ because they only involve a single arithmetic operation. The $$reset()$$ function also has a time complexity of $$O(1)$$ as it simply assigns a value to a variable.\\n\\n- Space complexity:\\nThe space complexity of the code is $$O(1)$$ because it does not use any additional data structures that grow with the input. The $$ans$$ variable and the returned object are the only variables created, and they occupy constant space regardless of the input value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    //creating ans variable\\n    var ans = init;\\n    //returning object to a function\\n    return{\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n$$Please \\\\space Upvote \\\\space the \\\\space Solution \\\\space if \\\\space you \\\\space liked \\\\space it...$$\\n![abc.png](https://assets.leetcode.com/users/images/8a68ea47-48e3-4005-965a-37385eb8b506_1683488530.294573.png)\\n\\n$$Thank \\\\space you \\\\space so \\\\space much...$$\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    //creating ans variable\\n    var ans = init;\\n    //returning object to a function\\n    return{\\n        increment: () => ++ans,\\n        decrement: () => --ans,\\n        reset: () => ans = init\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497177,
                "title": "js-simplest-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param { number } init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let state = init\\n    return {\\n        increment: () => ++state,\\n        decrement: () => --state,\\n        reset: () => state = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param { number } init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function(init) {\\n    let state = init\\n    return {\\n        increment: () => ++state,\\n        decrement: () => --state,\\n        reset: () => state = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495324,
                "title": "beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let count = init;\\n\\n  return {\\n    increment() {\\n      count += 1;\\n      return count;\\n    },\\n    decrement() {\\n      count -= 1;\\n      return count;\\n    },\\n    reset() {\\n      count = init;\\n      return count;\\n    }\\n  };  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let count = init;\\n\\n  return {\\n    increment() {\\n      count += 1;\\n      return count;\\n    },\\n    decrement() {\\n      count -= 1;\\n      return count;\\n    },\\n    reset() {\\n      count = init;\\n      return count;\\n    }\\n  };  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494774,
                "title": "java-script-solution-for-counter-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe createCounter function initializes and returns a new Counter object with an initial value passed as a parameter.\\n\\nThe Counter class has the following methods:\\n\\nincrement(): Increases the current count by 1 and returns the updated count.\\ndecrement(): Decreases the current count by 1 and returns the updated count.\\nreset(): Resets the current count to the initial value and returns the new count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The createCounter function takes an initial value as a parameter and returns a new instance of the Counter class, initializing it with the initial value.\\n- The Counter class maintains two properties: init, which stores the initial value passed to the constructor, and currentCount, which stores the current count.\\n- The increment method increases the currentCount by 1 and returns the updated count.\\n- The decrement method decreases the currentCount by 1 and returns the updated count.\\n- The reset method resets the currentCount to the init value and returns the new count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of each method (increment, decrement, reset) is O(1) since the operations involve simple arithmetic and assignment, which take constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the counter object stores a constant number of variables (init and currentCount), regardless of the number of operations performed.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.currentCount = init;\\n  }\\n\\n  increment() {\\n    this.currentCount += 1;\\n    return this.currentCount;\\n  }\\n\\n  decrement() {\\n    this.currentCount -= 1;\\n    return this.currentCount;\\n  }\\n\\n  reset() {\\n    this.currentCount = this.init;\\n    return this.currentCount;\\n  }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\nclass Counter {\\n  constructor(init) {\\n    this.init = init;\\n    this.currentCount = init;\\n  }\\n\\n  increment() {\\n    this.currentCount += 1;\\n    return this.currentCount;\\n  }\\n\\n  decrement() {\\n    this.currentCount -= 1;\\n    return this.currentCount;\\n  }\\n\\n  reset() {\\n    this.currentCount = this.init;\\n    return this.currentCount;\\n  }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494538,
                "title": "simple-solution-create-functions-and-return-object-of-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n// let val= init;\\nvar createCounter = function(init) {\\n    i=init;\\n    function increment(){\\n        i++;\\n        return i;\\n    }\\n    function decrement(){\\n        i--;\\n        return i;\\n    }\\n    function reset(){\\n        i=init;\\n        return i;\\n    }\\n    let obj={\\n        increment,\\n        decrement,\\n        reset\\n    };\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n// let val= init;\\nvar createCounter = function(init) {\\n    i=init;\\n    function increment(){\\n        i++;\\n        return i;\\n    }\\n    function decrement(){\\n        i--;\\n        return i;\\n    }\\n    function reset(){\\n        i=init;\\n        return i;\\n    }\\n    let obj={\\n        increment,\\n        decrement,\\n        reset\\n    };\\n    return obj;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886292,
                "title": "short-and-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835122,
                "title": "easy-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init;\\n    \\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init;\\n    \\n    return {\\n        increment: () => ++value,\\n        decrement: () => --value,\\n        reset: () => value = init, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823102,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640241,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const value=init;\\n    return {\\n        increment: ()=> {\\n            return ++init\\n        },\\n        decrement: ()=>{\\n           return --init\\n        },\\n        reset: ()=> {\\n            init=value\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const value=init;\\n    return {\\n        increment: ()=> {\\n            return ++init\\n        },\\n        decrement: ()=>{\\n           return --init\\n        },\\n        reset: ()=> {\\n            init=value\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567010,
                "title": "day-3-of-js-challenge-beats-92-04-easy-solution-using-arrow-functions",
                "content": "# Intuition\\nWe use arrow function inorder to print the output according to the different functions given.\\nIncrement - we add 1 to the value\\nDecrement - we subtract 1 from the value\\nreset - we print the original value\\n\\n# Approach\\nwe have declared 3 arrow functions that perform the necessary action and return the value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    return{\\n    increment: () => { current+=1; return current;},\\n    decrement: () => { current-=1; return current;},\\n    reset: () => { current=init; return current},\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\nKindly upvote if you found it helpful! Happy learning!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    return{\\n    increment: () => { current+=1; return current;},\\n    decrement: () => { current-=1; return current;},\\n    reset: () => { current=init; return current},\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504421,
                "title": "typescript-very-fast-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Beats 90%. -->\\n\\n# Approach\\n<!-- Beats 90%. -->\\n\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let _init = init;\\n    return {\\n        increment: () => ++_init,\\n        decrement: () => --_init,\\n        reset: () => _init = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let _init = init;\\n    return {\\n        increment: () => ++_init,\\n        decrement: () => --_init,\\n        reset: () => _init = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3501381,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n let current = init;\\n\\n  function increment() {\\n    return ++current;\\n  }\\n\\n  function decrement() {\\n    return --current;\\n  }\\n\\n  function reset() {\\n    current = init;\\n    return current;\\n  }\\n\\n  return { increment, decrement, reset };    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n let current = init;\\n\\n  function increment() {\\n    return ++current;\\n  }\\n\\n  function decrement() {\\n    return --current;\\n  }\\n\\n  function reset() {\\n    current = init;\\n    return current;\\n  }\\n\\n  return { increment, decrement, reset };    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496974,
                "title": "easy-javascript-solution",
                "content": "# Approach\\nThe createCounter function returns an object with three functions: increment, decrement, and reset. These functions have access to a count variable that is initialized to the value of init. Each function modifies the count variable and returns the new value.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment: function(){\\n            count++;\\n            return count;\\n        },\\n        decrement: function(){\\n            count--;\\n            return count;\\n        },\\n        reset: function(){\\n            count = init;\\n            return count;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment: function(){\\n            count++;\\n            return count;\\n        },\\n        decrement: function(){\\n            count--;\\n            return count;\\n        },\\n        reset: function(){\\n            count = init;\\n            return count;\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496313,
                "title": "javascript-beats-81-4-if-you-believe-leetcode",
                "content": "# Intuition\\n\\nIt is based on LeetCode hint. LeetCode Hint tells you directly that you need to return the JavaScript object. Based on this knowledge I have decided to try to return JSON that will have an arrow functions depending on the keywords. \\n\\nAnd that was the solution! :)\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n\\n\\n    return {\\n        increment: () => {\\n            num++;\\n            return num;\\n        },\\n        reset: () => {\\n            num = init;\\n            return num;\\n        },\\n        decrement: () => {\\n            num--;\\n            return num;\\n        }\\n    }    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n\\n\\n    return {\\n        increment: () => {\\n            num++;\\n            return num;\\n        },\\n        reset: () => {\\n            num = init;\\n            return num;\\n        },\\n        decrement: () => {\\n            num--;\\n            return num;\\n        }\\n    }    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496058,
                "title": "closure-3-lines-in-javascript-100",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        \\n        let count = init\\n        return{increment: () => ++count,\\n        decrement: () => --count,\\n        reset: () => count = init,\\n        }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        \\n        let count = init\\n        return{increment: () => ++count,\\n        decrement: () => --count,\\n        reset: () => count = init,\\n        }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495786,
                "title": "easy-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var n=init\\n    return{\\n        increment:()=>++n,\\n        decrement:()=>--n,\\n        reset:()=>n=init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var n=init\\n    return{\\n        increment:()=>++n,\\n        decrement:()=>--n,\\n        reset:()=>n=init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495385,
                "title": "js-o-o",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init\\n    return {\\n        increment: function() {\\n            currentCount += 1;\\n            return currentCount;\\n        },\\n        decrement: function() {\\n            currentCount -= 1;\\n            return currentCount;\\n        },\\n        reset: function() {\\n            currentCount = init;\\n            return currentCount;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init\\n    return {\\n        increment: function() {\\n            currentCount += 1;\\n            return currentCount;\\n        },\\n        decrement: function() {\\n            currentCount -= 1;\\n            return currentCount;\\n        },\\n        reset: function() {\\n            currentCount = init;\\n            return currentCount;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495368,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIncrement, increases the value and return it,\\nDecrement, decreases the value and return it,\\nReset, return the actual value\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3495310,
                "title": "easy-simple-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter = init;\\n    return {\\n        increment : ()=>{\\n            counter++;\\n            return counter;\\n        },\\n        decrement : ()=>{\\n            counter--;\\n            return counter;\\n        },\\n        reset : ()=> {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter = init;\\n    return {\\n        increment : ()=>{\\n            counter++;\\n            return counter;\\n        },\\n        decrement : ()=>{\\n            counter--;\\n            return counter;\\n        },\\n        reset : ()=> {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494785,
                "title": "day-3-happy-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n//  * @param {integer} init\\n//  * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    function increment(){\\n        count++;\\n        return count;\\n    }\\n    function decrement(){\\n        count--;\\n        return count;\\n    }\\n    function reset(){\\n        count = init;\\n        return count;\\n    }\\n    return { increment, decrement, reset };\\n};\\n    \\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n//  * @param {integer} init\\n//  * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    function increment(){\\n        count++;\\n        return count;\\n    }\\n    function decrement(){\\n        count--;\\n        return count;\\n    }\\n    function reset(){\\n        count = init;\\n        return count;\\n    }\\n    return { increment, decrement, reset };\\n};\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494767,
                "title": "how-to-approach-this-problem-three-line-typescript-code-o-1-closure",
                "content": "# Intuition\\nFor solving thing problem we are going to use closure concept. As we go through the problem, two thing is sure ->\\n\\nWe need to store starting init value in variable because when we implement reset function we need them that value.\\n\\nAnd also store current value, which will change when we call increment or decrement or reset function.\\n\\n# Approach\\n1. We are going to create two variable which will store init value and current value.\\n2. After that we will create three function increment, decrement, rest.\\n3. return these function.\\n\\n# Complexity\\n- Time complexity:\\nWe are not performing any special type of operation which depend on user input. Then we can say Time Complexity is $$O(1)$$\\n\\n- Space complexity:\\nWe are just creating two variable and it\\'s not depend user how many time call this function. Then we can Space Complexity is $$O(1)$$\\n\\n# Code\\nJavascript\\n```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    let value = init;\\n    const increment = () => ++value;\\n    const decrement = () => --value;\\n    const reset = () => (value = resetValue);\\n    return {increment,decrement,reset};\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\nTypescript\\n```typescript\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const resetValue = init;\\n    let currentValue = init;\\n    return {\\n        increment: (): number => ++currentValue,\\n        decrement: (): number => --currentValue,\\n        reset: (): number => currentValue = resetValue,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    let value = init;\\n    const increment = () => ++value;\\n    const decrement = () => --value;\\n    const reset = () => (value = resetValue);\\n    return {increment,decrement,reset};\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n```typescript\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const resetValue = init;\\n    let currentValue = init;\\n    return {\\n        increment: (): number => ++currentValue,\\n        decrement: (): number => --currentValue,\\n        reset: (): number => currentValue = resetValue,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494668,
                "title": "simple-easy-solution-with-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can take a temp variable, assign it to the value of init. Then write 3 function as increment() which will increment the value by 1, reset() the will reset the value back to original, and decrement() which will decrement the value by 1. And then finaly return the temp variable; \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n      let temp=init;\\n    return {\\n        increment(){\\n            return ++temp;\\n        },\\n        decrement(){\\n            return --temp;\\n        },\\n        reset(){\\n            temp=init;\\n            return temp;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n      let temp=init;\\n    return {\\n        increment(){\\n            return ++temp;\\n        },\\n        decrement(){\\n            return --temp;\\n        },\\n        reset(){\\n            temp=init;\\n            return temp;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494562,
                "title": "easy-js-solution-with-explain-closure",
                "content": "# Intuition\\nThe goal of the problem is to create a constructor function that returns an object with methods for incrementing, decrementing, and resetting a counter value. Closures allow maintaining state between function calls.\\n\\n# Approach\\n1. Create a createCounter function with an init argument, which will initialize the starting value of the counter.\\n2. Inside the createCounter function, create a counter variable and set its value equal to init.\\n3. Return an object with increment, decrement, and reset methods, which modify the counter value accordingly and return it.\\n4. Use closure to retain the counter value between function calls.\\n\\n# Complexity\\n- Time and space complexity:\\n- O(1) - bcs it\\'s just simple math\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function () {\\n            return ++counter;\\n        },\\n        decrement: function () {\\n            return --counter;\\n        },\\n        reset: function () {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function () {\\n            return ++counter;\\n        },\\n        decrement: function () {\\n            return --counter;\\n        },\\n        reset: function () {\\n            counter = init;\\n            return counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3494501,
                "title": "closure-easy-to-understand-implementation",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {increment, decrement, reset};\\n\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {increment, decrement, reset};\\n\\n};\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488461,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return {\\n        increment(){\\n            return ++count;\\n        },\\n        decrement(){\\n            return --count;\\n        },\\n        reset(){\\n            count=init;\\n            return count;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count=init;\\n    return {\\n        increment(){\\n            return ++count;\\n        },\\n        decrement(){\\n            return --count;\\n        },\\n        reset(){\\n            count=init;\\n            return count;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486119,
                "title": "class-based-implementation",
                "content": "\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n class Counter {\\n     constructor(init){\\n         this.initVal = init;\\n         this.val = this.initVal;\\n     }\\n\\n     increment(){\\n         return this.val+=1;\\n     }\\n\\n     decrement(){\\n         return this.val-=1;\\n     }\\n\\n     reset(){\\n         return this.val = this.initVal;\\n     }\\n }\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n class Counter {\\n     constructor(init){\\n         this.initVal = init;\\n         this.val = this.initVal;\\n     }\\n\\n     increment(){\\n         return this.val+=1;\\n     }\\n\\n     decrement(){\\n         return this.val-=1;\\n     }\\n\\n     reset(){\\n         return this.val = this.initVal;\\n     }\\n }\\nvar createCounter = function(init) {\\n    return new Counter(init);\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484840,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const original = init\\n  const increment = () => ++init\\n  const decrement = () => --init\\n  const reset = () => init = original\\n\\n  return { increment, decrement, reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  const original = init\\n  const increment = () => ++init\\n  const decrement = () => --init\\n  const reset = () => init = original\\n\\n  return { increment, decrement, reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098752,
                "title": "clean-and-easy-approach-step-wise-explanation",
                "content": "# Intuition\\nStep 1 : First read the question.\\nStep 2 : It says return an object so we use \"return {}\", curly braces are symbol of object literals.\\nStep 3 : Now an object consists of key-value pairs so, our \\'key\\' will be the \\'function name\\' and value will be the function implementation.\\nStep 4 : For the code of function implementation just follow what question demands like increment, decrement or reset.\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    var temp = init;\\n    return {\\n        increment : function(){\\n            return ++temp;\\n        },\\n        decrement : function(){\\n            return --temp;\\n        },\\n        reset : function(){\\n            temp = init;\\n            return temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var temp = init;\\n    return {\\n        increment : function(){\\n            return ++temp;\\n        },\\n        decrement : function(){\\n            return --temp;\\n        },\\n        reset : function(){\\n            temp = init;\\n            return temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097956,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var x=init;\\n    var calls={\\n         reset:function(){\\n             init=x;\\n            return init;\\n        },\\n        increment:function(){\\n    init++;\\n          return init;\\n        },\\n        decrement:function(){\\n           init--;\\n            return init;\\n        },\\n    }\\n    return calls;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var x=init;\\n    var calls={\\n         reset:function(){\\n             init=x;\\n            return init;\\n        },\\n        increment:function(){\\n    init++;\\n          return init;\\n        },\\n        decrement:function(){\\n           init--;\\n            return init;\\n        },\\n    }\\n    return calls;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096443,
                "title": "counter-ii-javascript-solution-by-bharadwaj",
                "content": "# Approach\\nFunctional\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095973,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const initialValue = init;\\n    let currentValue = init;\\n    const increment = ()  => {\\n      currentValue += 1;\\n      return currentValue;\\n    }\\n    const decrement = ()  => {\\n      currentValue -= 1;\\n      return currentValue;\\n    }\\n    const reset = ()  => {\\n      currentValue = initialValue;\\n      return currentValue;\\n    }\\n\\n    return {increment,decrement,reset};\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const initialValue = init;\\n    let currentValue = init;\\n    const increment = ()  => {\\n      currentValue += 1;\\n      return currentValue;\\n    }\\n    const decrement = ()  => {\\n      currentValue -= 1;\\n      return currentValue;\\n    }\\n    const reset = ()  => {\\n      currentValue = initialValue;\\n      return currentValue;\\n    }\\n\\n    return {increment,decrement,reset};\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094618,
                "title": "operation-counter-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const currentNum = init\\n   return {\\n    increment: ()=>{\\n        return init+=1\\n    },\\n    decrement: ()=>{\\n        return init-=1\\n    },\\n    reset: ()=>{\\n        return init = currentNum\\n    }\\n   }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const currentNum = init\\n   return {\\n    increment: ()=>{\\n        return init+=1\\n    },\\n    decrement: ()=>{\\n        return init-=1\\n    },\\n    reset: ()=>{\\n        return init = currentNum\\n    }\\n   }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094075,
                "title": "simple-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- understanding sub functions much better\\n- had to use temp: function() {} instead of temp: () => {}\\n- maybe it has something to do with arrow functions not taking in this.x?\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = (init) => {\\n    return {\\n        x : init,\\n        increment: function() {\\n            this.x++;\\n            return this.x;\\n        },\\n        decrement: function()  {\\n            this.x--;\\n            return this.x;\\n        },\\n        reset: function() {\\n            this.x = init;\\n            return init;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = (init) => {\\n    return {\\n        x : init,\\n        increment: function() {\\n            this.x++;\\n            return this.x;\\n        },\\n        decrement: function()  {\\n            this.x--;\\n            return this.x;\\n        },\\n        reset: function() {\\n            this.x = init;\\n            return init;\\n        }\\n\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091297,
                "title": "counter-ii",
                "content": "# Intuition\\nhere is a JavaScript function to create a counter object with three functions: increment(), decrement(), and reset():\\n# Approach\\nTo use the createCounter() function, simply pass in the initial value of the counter as an argument. The function will return a counter object with three functions: increment(), decrement(), and reset().\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n  class Counter {\\n    constructor(init) {\\n      this.value = init;\\n    }\\n\\n    increment() {\\n      this.value += 1;\\n      return this.value;\\n    }\\n\\n    decrement() {\\n      this.value -= 1;\\n      return this.value;\\n    }\\n\\n    reset() {\\n      this.value = init;\\n      return this.value;\\n    }\\n  }\\n\\n  return new Counter(init);\\n}\\n\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n\\nFor example, the following code creates a counter object with an initial value of 5:\\n\\n```\\n const counter = createCounter(5)\\n```\\nYou can then use the increment(), decrement(), and reset() functions to modify the value of the counter:\\n\\n```\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n  class Counter {\\n    constructor(init) {\\n      this.value = init;\\n    }\\n\\n    increment() {\\n      this.value += 1;\\n      return this.value;\\n    }\\n\\n    decrement() {\\n      this.value -= 1;\\n      return this.value;\\n    }\\n\\n    reset() {\\n      this.value = init;\\n      return this.value;\\n    }\\n  }\\n\\n  return new Counter(init);\\n}\\n\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\n```\\n const counter = createCounter(5)\\n```\n```\\n  counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090026,
                "title": "short-and-easy-approach",
                "content": "\\n```\\nvar createCounter = function(init) {\\n    var initialVal = init;\\n    var currVal = init;\\n    return {\\n        increment : function(){\\n            return ++currVal;\\n        },\\n        decrement : function(){\\n            return --currVal;\\n        },\\n        reset : function(){\\n            currVal = initialVal;\\n            return currVal;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var initialVal = init;\\n    var currVal = init;\\n    return {\\n        increment : function(){\\n            return ++currVal;\\n        },\\n        decrement : function(){\\n            return --currVal;\\n        },\\n        reset : function(){\\n            currVal = initialVal;\\n            return currVal;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088922,
                "title": "counter2-with-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n    \\n    function increment () {\\n        return ++count\\n    }\\n    function decrement() {\\n        return --count\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088908,
                "title": "counter-with-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let count= init\\n        if (-1000 <= init <= 1000){\\n             return {\\n                 increment:()=> ++count,\\n                 reset:()=> count=init,\\n                 decrement:()=>--count\\n             }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let count= init\\n        if (-1000 <= init <= 1000){\\n             return {\\n                 increment:()=> ++count,\\n                 reset:()=> count=init,\\n                 decrement:()=>--count\\n             }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088021,
                "title": "easy-and-the-shortest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function (init) {\\n  // Creating variable\\n  let currentCount = init;\\n  // return an object\\n  return {\\n    // increment\\n    increment: () => (currentCount += 1),\\n    // decrement\\n    decrement: () => (currentCount -= 1),\\n    // reset\\n    reset: () => (currentCount = init),\\n  };\\n};\\n\\nconst counter = createCounter(5);\\nconsole.log(\\n  counter.increment(), // 6\\n  counter.reset(), // 5\\n  counter.decrement()\\n); // 4;\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = function (init) {\\n  // Creating variable\\n  let currentCount = init;\\n  // return an object\\n  return {\\n    // increment\\n    increment: () => (currentCount += 1),\\n    // decrement\\n    decrement: () => (currentCount -= 1),\\n    // reset\\n    reset: () => (currentCount = init),\\n  };\\n};\\n\\nconst counter = createCounter(5);\\nconsole.log(\\n  counter.increment(), // 6\\n  counter.reset(), // 5\\n  counter.decrement()\\n); // 4;\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087506,
                "title": "neercode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n = init;\\n    return{\\n        increment: () => n+=1, decrement: () => n-=1, reset: () => (n=init),\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084932,
                "title": "my-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let val = init;\\n    return {\\n      increment: () => ++val,\\n       decrement: () => --val,\\n       reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let val = init;\\n    return {\\n      increment: () => ++val,\\n       decrement: () => --val,\\n       reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083797,
                "title": "counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment(){\\n        return ++count;\\n    }\\n\\n    function decrement(){\\n        return --count;\\n    }\\n\\n    function reset() {\\n        count = init;\\n        return count;\\n    }\\n\\n    return{\\n        increment : increment,\\n        decrement : decrement,\\n        reset : reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment(){\\n        return ++count;\\n    }\\n\\n    function decrement(){\\n        return --count;\\n    }\\n\\n    function reset() {\\n        count = init;\\n        return count;\\n    }\\n\\n    return{\\n        increment : increment,\\n        decrement : decrement,\\n        reset : reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077733,
                "title": "counter2-simple-solution",
                "content": "# Intuition\\nThe goal of this problem is to create a counter object that has three functions: increment(), decrement(), and reset(). These functions should manipulate and return the current value of the counter based on an initial value provided when creating the counter object.\\n\\n# Approach\\nThe approach involves creating a counter object using a JavaScript function. This function takes an initial value init as a parameter and returns an object with three methods:\\n\\n-increment(): This method increases the current value of the counter by 1 and then returns the updated value.\\n\\n-decrement(): This method decreases the current value of the counter by 1 and then returns the updated value.\\n\\n-reset(): This method resets the current value of the counter to its initial value provided during object creation and returns the initial value.\\n\\nTo achieve this, we store the initial value in a separate variable (initial) inside the closure of the returned object, and the other methods (increment, decrement, and reset) manipulate and access this init value.\\n\\n# Complexity\\nThe time complexity of the increment() and decrement() methods is O(1) since they only involve simple arithmetic operations.\\n\\nThe reset() method is also O(1) because it involves a single assignment operation.\\n\\n# Space complexity:\\nThe space complexity is O(1) as we\\'re only storing a constant number of variables (init and initial) regardless of the input size.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var initial = init;\\n  return {\\n    increment: function() {\\n      init++;\\n      return init;\\n    },\\n\\n    decrement: function() {\\n      init--;\\n      return init;\\n    },\\n\\n    reset: function() {\\n      init = initial\\n      return init;\\n    }\\n  };\\n};\\n \\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var initial = init;\\n  return {\\n    increment: function() {\\n      init++;\\n      return init;\\n    },\\n\\n    decrement: function() {\\n      init--;\\n      return init;\\n    },\\n\\n    reset: function() {\\n      init = initial\\n      return init;\\n    }\\n  };\\n};\\n \\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077426,
                "title": "i-love-this-tests",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init;\\n    \\n    function increment(){\\n         count++;\\n         return count;\\n    }\\n\\n     function decrement(){\\n          count--;\\n         return  count;\\n    }\\n\\n    function reset(){\\n         count= init;\\n     return count\\n    }\\n\\nreturn {\\n    increment,\\n    decrement,\\n    reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init;\\n    \\n    function increment(){\\n         count++;\\n         return count;\\n    }\\n\\n     function decrement(){\\n          count--;\\n         return  count;\\n    }\\n\\n    function reset(){\\n         count= init;\\n     return count\\n    }\\n\\nreturn {\\n    increment,\\n    decrement,\\n    reset }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074243,
                "title": "it-is-solve-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072862,
                "title": "counter-problem-in-java-script-use-method-channing",
                "content": "# Intuition\\nIn this proble we have to make the three method \\n\\n# Approach\\nhere we return and object of method which have properties of function \\n\\n# Complexity\\n- Time complexity:  O(1)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return {\\n        no: init,\\n        increment : function(){\\n            this.no +=1;\\n            return this.no\\n        },\\n        decrement : function(){\\n            this.no -=1;\\n            return this.no\\n        },\\nreset : function(){\\n    this.no = init\\n     return this.no\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    return {\\n        no: init,\\n        increment : function(){\\n            this.no +=1;\\n            return this.no\\n        },\\n        decrement : function(){\\n            this.no -=1;\\n            return this.no\\n        },\\nreset : function(){\\n    this.no = init\\n     return this.no\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072359,
                "title": "2665-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar createCounter = function(init) {\\n    const resetVal = init;\\n    return {\\n        increment : () => ++init,\\n        decrement: () => --init,\\n        reset: () => init = resetVal,\\n    }\\n};\\nconst counter = createCounter(5)\\n console.log(counter.increment()); // 6\\n console.log(counter.reset()); // 5\\n console.log(counter.decrement()); // 4\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    const resetVal = init;\\n    return {\\n        increment : () => ++init,\\n        decrement: () => --init,\\n        reset: () => init = resetVal,\\n    }\\n};\\nconst counter = createCounter(5)\\n console.log(counter.increment()); // 6\\n console.log(counter.reset()); // 5\\n console.log(counter.decrement()); // 4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069493,
                "title": "2665-counter-ii-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var currentVal = init;\\n    const objThree = {\\n      increment: (() => {\\n        return init = init + 1\\n      }),\\n      decrement: (() => {\\n        return init = init - 1\\n      }),\\n      reset: (() => {\\n        return init = currentVal\\n      }), \\n    }\\n    \\n    return objThree;\\n};\\n\\n\\n\\nconst counter = createCounter(5)\\ncounter.increment(); // 6\\ncounter.reset(); // 5\\ncounter.decrement(); // 4\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var currentVal = init;\\n    const objThree = {\\n      increment: (() => {\\n        return init = init + 1\\n      }),\\n      decrement: (() => {\\n        return init = init - 1\\n      }),\\n      reset: (() => {\\n        return init = currentVal\\n      }), \\n    }\\n    \\n    return objThree;\\n};\\n\\n\\n\\nconst counter = createCounter(5)\\ncounter.increment(); // 6\\ncounter.reset(); // 5\\ncounter.decrement(); // 4\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069044,
                "title": "counter-ii-js-solution",
                "content": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    function increment(){\\n        num += 1\\n        return num\\n    }\\n    function reset(){\\n        num = init\\n        return num\\n    }\\n    function decrement(){\\n        num -= 1\\n        return num\\n    }\\n    return { increment, reset, decrement }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    function increment(){\\n        num += 1\\n        return num\\n    }\\n    function reset(){\\n        num = init\\n        return num\\n    }\\n    function decrement(){\\n        num -= 1\\n        return num\\n    }\\n    return { increment, reset, decrement }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 4068200,
                "title": "2-easy-ways",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   \\n    let count = init;\\n\\n    // const increment = () => ++count\\n    // const decrement = () => --count\\n    // const reset = () => {\\n    //   count = init\\n    //   return init\\n    // }\\n    // return { increment, decrement, reset}\\n\\n    \\n    //*****OR**** */\\n\\n    return {\\n      increment: () => ++count,\\n      decrement: () => --count,\\n      reset: () => count = init\\n      }\\n\\n  }\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   \\n    let count = init;\\n\\n    // const increment = () => ++count\\n    // const decrement = () => --count\\n    // const reset = () => {\\n    //   count = init\\n    //   return init\\n    // }\\n    // return { increment, decrement, reset}\\n\\n    \\n    //*****OR**** */\\n\\n    return {\\n      increment: () => ++count,\\n      decrement: () => --count,\\n      reset: () => count = init\\n      }\\n\\n  }\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067001,
                "title": "beginner-friendly-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let value = init;\\n        return {\\n        increment: () => {\\n            return ++value;\\n        },\\n        decrement: () => {\\n            return --value;\\n        },\\n        reset: () => {\\n            value = init;\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n        let value = init;\\n        return {\\n        increment: () => {\\n            return ++value;\\n        },\\n        decrement: () => {\\n            return --value;\\n        },\\n        reset: () => {\\n            value = init;\\n            return value\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062017,
                "title": "counter-ii-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init\\n    return {\\n            reset : () =>{\\n            return x = init;\\n        },\\n        increment : () =>{\\n            return ++x ;\\n        },\\n        decrement : () =>{\\n            return --x ;\\n        }, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init\\n    return {\\n            reset : () =>{\\n            return x = init;\\n        },\\n        increment : () =>{\\n            return ++x ;\\n        },\\n        decrement : () =>{\\n            return --x ;\\n        }, \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060644,
                "title": "arrow-function-to-createcounter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init;\\n    return {\\n        increment: () => currentCount += 1,\\n        decrement: () => currentCount -= 1,\\n        reset: () => currentCount = init\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentCount = init;\\n    return {\\n        increment: () => currentCount += 1,\\n        decrement: () => currentCount -= 1,\\n        reset: () => currentCount = init\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060321,
                "title": "74-beats",
                "content": "# Intuition\\n74% beats\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let numbers = init;\\n    return{\\n        increment: ()=>{\\n            // numbers++;\\n            return ++numbers;\\n        },\\n        decrement: ()=>{\\n            // numbers--;\\n            return --numbers;\\n        },\\n        reset: ()=>{\\n            // numbers = init;\\n            return (numbers = init);\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let numbers = init;\\n    return{\\n        increment: ()=>{\\n            // numbers++;\\n            return ++numbers;\\n        },\\n        decrement: ()=>{\\n            // numbers--;\\n            return --numbers;\\n        },\\n        reset: ()=>{\\n            // numbers = init;\\n            return (numbers = init);\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057660,
                "title": "good-to-remember-the-difference-between-pre-post-increment-decrement",
                "content": "# Code\\n```\\nconst createCounter = (init) => {\\n  let CurrentInit = init;\\n  return {\\n    increment: () => ++CurrentInit,\\n    decrement: () => --CurrentInit,\\n    reset: () => CurrentInit = init,\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst createCounter = (init) => {\\n  let CurrentInit = init;\\n  return {\\n    increment: () => ++CurrentInit,\\n    decrement: () => --CurrentInit,\\n    reset: () => CurrentInit = init,\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055906,
                "title": "solution-with-easy-peasy-explanation",
                "content": "# Intuition\\nFor the very basic steps, you know that you need to increment init, decrement init and then have it stored in another variable so you can reset it.\\n\\n# Approach\\n2 concepts are useful here. First is closure, which means that when a function is called from inside another function, the variables of the outer functions are retained in further calls, in simpler terms, it will remember. So here, you can be carefree about accessing init variable. \\n\\nNext is Pass by Value, by default in JS, primitive data types are passed by value, so you can easily create a new variable called \"og\" (stand for original) in this case and use that to reset init. There you go, easy peasy now that you know the concepts. Happy Coding!\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nlet createCounter = function(init) {\\n    const og = init\\n    return {\\n        increment : function(){\\n            init++\\n            return init\\n        },\\n        decrement : ()=>{\\n             init--\\n             return init\\n            \\n        },\\n        reset : ()=>{\\n            init = og\\n            return init\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nlet createCounter = function(init) {\\n    const og = init\\n    return {\\n        increment : function(){\\n            init++\\n            return init\\n        },\\n        decrement : ()=>{\\n             init--\\n             return init\\n            \\n        },\\n        reset : ()=>{\\n            init = og\\n            return init\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055875,
                "title": "2665-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let curent = init;\\n    return{\\n        increment:() => ++init,\\n        decrement:() => --init,\\n        reset:() =>  init = curent\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let curent = init;\\n    return{\\n        increment:() => ++init,\\n        decrement:() => --init,\\n        reset:() =>  init = curent\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055237,
                "title": "counter-object-implementation-with-javascript",
                "content": "# Intuition\\nThe problem is to create a counter object that can be initialized with an initial value and provides methods to increment, decrement, and reset the counter.\\n\\n# Approach\\nI have implemented a closure-based approach to create the counter object. The `createCounter` function takes an initial value (`init`) and returns an object with three methods: `increment`, `decrement`, and `reset`. These methods allow manipulating the counter value as per the requirements.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity for each of the methods (`increment`, `decrement`, and `reset`) is O(1) because they involve simple arithmetic operations and assignment, which take constant time.\\n\\n\\n- Space complexity:\\nThe space complexity of the counter object created by `createCounter` is O(1). It only stores the current counter value and a few functions, which do not depend on the size of the input.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n\\n  return {\\n    increment: () => ++current,\\n    decrement: () => --current,\\n    reset: () => {\\n      current = init;\\n      return current;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n\\n  return {\\n    increment: () => ++current,\\n    decrement: () => --current,\\n    reset: () => {\\n      current = init;\\n      return current;\\n    }\\n  };\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054209,
                "title": "easy-approch",
                "content": "# Intuition\\nThe problem is asking us to create a counter object that can increment, decrement, and reset a value. The initial value of the counter is provided as an argument when creating the counter object.\\n\\n# Approach\\nWe can approach this problem by creating a closure in JavaScript. We initialize a variable `num` with the provided initial value (`init`) and return an object with three functions: `increment`, `decrement`, and `reset`. These functions modify and return the `num` variable accordingly.\\n\\n- `increment` function: This function increments the `num` variable by 1 and returns the new value.\\n- `decrement` function: This function decrements the `num` variable by 1 and returns the new value.\\n- `reset` function: This function sets the `num` variable back to its initial value (`init`) and returns that value.\\n\\n# Complexity\\n- Time complexity: All three operations (increment, decrement, reset) have a time complexity of O(1) because they involve simple arithmetic operations on a single variable.\\n- Space complexity: The space complexity is O(1) as we only use a single variable `num` and a few function references.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: function() {\\n            return ++num;\\n        },\\n        decrement: function() {\\n            return --num;\\n        },\\n        reset: function() {\\n            num = init;\\n            return num;\\n        }\\n    }\\n};\\n\\n/**\\n * Example usage:\\n * const counter = createCounter(5);\\n * console.log(counter.increment()); // Output: 6\\n * console.log(counter.reset());     // Output: 5\\n * console.log(counter.decrement()); // Output: 4\\n */\\n```\\n\\nYou can create a counter object with an initial value, use the `increment`, `decrement`, and `reset` functions as shown in the example usage, and observe how the counter behaves.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: function() {\\n            return ++num;\\n        },\\n        decrement: function() {\\n            return --num;\\n        },\\n        reset: function() {\\n            num = init;\\n            return num;\\n        }\\n    }\\n};\\n\\n/**\\n * Example usage:\\n * const counter = createCounter(5);\\n * console.log(counter.increment()); // Output: 6\\n * console.log(counter.reset());     // Output: 5\\n * console.log(counter.decrement()); // Output: 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047863,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init\\n    return {\\n        increment:() => {\\n            count++\\n            return count\\n        },\\n        decrement:() => {\\n            count--\\n            return count\\n        },\\n        reset:() => {\\n            count = init\\n            return count\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var count = init\\n    return {\\n        increment:() => {\\n            count++\\n            return count\\n        },\\n        decrement:() => {\\n            count--\\n            return count\\n        },\\n        reset:() => {\\n            count = init\\n            return count\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046850,
                "title": "creating-a-counter-object-in-javascript-with-pre-increment-pre-decrement-and-reset-functions",
                "content": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this problem is to create a counter object that can be incremented, decremented, and reset to its initial value. To achieve this, we can use a closure in JavaScript to encapsulate the current value of the counter.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI used a closure to create a `createCounter` function that takes an initial value and returns an object with three methods:\\n1. `increment`: Increments the counter by 1 using pre-increment.\\n2. `decrement`: Decrements the counter by 1 using pre-decrement.\\n3. `reset`: Resets the counter to its initial value and returns the reset value.\\n\\nUsing pre-increment and pre-decrement ensures that the counter is updated before returning the new value, providing the desired behavior.\\n\\nAdditionally, I chose to reset the counter to its initial value first and then return the reset value in the `reset` method. This design choice simplifies the usage of the `reset` function. By resetting first, you can immediately access the reset value without the need for additional steps. This aligns with the principle of making functions as straightforward and predictable as possible.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  - The time complexity of each method (increment, decrement, and reset) is O(1) because they involve simple arithmetic operations that take a constant amount of time.\\n\\n- Space complexity: O(1)\\n  - The space complexity of the `createCounter` function is O(1) because it only creates a single object with three methods and a single variable (`currentValue`) regardless of the input.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init - The initial value of the counter.\\n * @return {Object} - An object with increment, decrement, and reset methods.\\n */\\nvar createCounter = function (init) {\\n    let currentValue = init; // Initialize the currentValue with the provided initial value.\\n    return {\\n        increment: () => ++currentValue, // Increment the currentValue and return the new value using pre-increment.\\n        decrement: () => --currentValue, // Decrement the currentValue and return the new value using pre-decrement.\\n        reset: () => {\\n            currentValue = init; // Reset the currentValue to the initial value first.\\n            return currentValue; // Return the reset value.\\n        }\\n    }\\n};\\n\\n// Example usage:\\nconst counter = createCounter(5);\\nconsole.log(counter.increment()); // Output: 6\\nconsole.log(counter.reset()); // Output: 5\\nconsole.log(counter.decrement()); // Output: 4\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\n<!-- Provide a brief description of your initial thoughts and strategies for solving this problem. -->\\n\\nThe goal of this problem is to create a counter object that can be incremented, decremented, and reset to its initial value. To achieve this, we can use a closure in JavaScript to encapsulate the current value of the counter.\\n\\n# Approach\\n<!-- Describe the approach you took to solve the problem. -->\\n\\nI used a closure to create a `createCounter` function that takes an initial value and returns an object with three methods:\\n1. `increment`: Increments the counter by 1 using pre-increment.\\n2. `decrement`: Decrements the counter by 1 using pre-decrement.\\n3. `reset`: Resets the counter to its initial value and returns the reset value.\\n\\nUsing pre-increment and pre-decrement ensures that the counter is updated before returning the new value, providing the desired behavior.\\n\\nAdditionally, I chose to reset the counter to its initial value first and then return the reset value in the `reset` method. This design choice simplifies the usage of the `reset` function. By resetting first, you can immediately access the reset value without the need for additional steps. This aligns with the principle of making functions as straightforward and predictable as possible.\\n\\n# Complexity\\n- Time complexity: O(1)\\n  - The time complexity of each method (increment, decrement, and reset) is O(1) because they involve simple arithmetic operations that take a constant amount of time.\\n\\n- Space complexity: O(1)\\n  - The space complexity of the `createCounter` function is O(1) because it only creates a single object with three methods and a single variable (`currentValue`) regardless of the input.\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init - The initial value of the counter.\\n * @return {Object} - An object with increment, decrement, and reset methods.\\n */\\nvar createCounter = function (init) {\\n    let currentValue = init; // Initialize the currentValue with the provided initial value.\\n    return {\\n        increment: () => ++currentValue, // Increment the currentValue and return the new value using pre-increment.\\n        decrement: () => --currentValue, // Decrement the currentValue and return the new value using pre-decrement.\\n        reset: () => {\\n            currentValue = init; // Reset the currentValue to the initial value first.\\n            return currentValue; // Return the reset value.\\n        }\\n    }\\n};\\n\\n// Example usage:\\nconst counter = createCounter(5);\\nconsole.log(counter.increment()); // Output: 6\\nconsole.log(counter.reset()); // Output: 5\\nconsole.log(counter.decrement()); // Output: 4\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4044929,
                "title": "counter-ii-using-pre-increment",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take an object as return statement\\n2. Have three **Key:Value** pairs, having names increment, decrement, reset\\n3. Use **Pre increment to first execute the operation and then return value** rather than preincrement\\n\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentVal = init\\n    return {\\n        increment: () => ++presentVal,\\n        decrement: () => --presentVal,\\n        reset: () => presentVal = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentVal = init\\n    return {\\n        increment: () => ++presentVal,\\n        decrement: () => --presentVal,\\n        reset: () => presentVal = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041750,
                "title": "easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init\\n    \\n    return {\\n        reset: () => value = init,\\n        increment: () => ++value,\\n        decrement: () => --value\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let value = init\\n    \\n    return {\\n        reset: () => value = init,\\n        increment: () => ++value,\\n        decrement: () => --value\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040316,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentVal = init;\\n    return {\\n        increment: () => {\\n            return ++currentVal;\\n        },\\n        decrement: () => {\\n            return --currentVal;\\n        },\\n        reset: () => {\\n            currentVal = init;\\n            return currentVal;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentVal = init;\\n    return {\\n        increment: () => {\\n            return ++currentVal;\\n        },\\n        decrement: () => {\\n            return --currentVal;\\n        },\\n        reset: () => {\\n            currentVal = init;\\n            return currentVal;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039671,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n   var createCounter = function(init) {\\n       let i = init;\\n  return {\\n      increment() {\\n          return ++i;\\n      },\\ndecrement() {\\n          return --i;\\n      },\\n       reset(){\\n            i = init;\\n            return i;\\n        }\\n\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\n   var createCounter = function(init) {\\n       let i = init;\\n  return {\\n      increment() {\\n          return ++i;\\n      },\\ndecrement() {\\n          return --i;\\n      },\\n       reset(){\\n            i = init;\\n            return i;\\n        }\\n\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038154,
                "title": "simple-and-easy-to-understand",
                "content": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  let n = init;\\n  return {\\n    increment: () => {\\n      return ++n;\\n    },\\n    decrement: () => {\\n      return --n;\\n    },\\n    reset: () => {\\n      n = init;\\n      return n;\\n    }\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n  let n = init;\\n  return {\\n    increment: () => {\\n      return ++n;\\n    },\\n    decrement: () => {\\n      return --n;\\n    },\\n    reset: () => {\\n      n = init;\\n      return n;\\n    }\\n  }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037426,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original = init\\n    return {\\n        increment() {\\n            init++\\n            return init\\n        },\\n        reset() {\\n            init = original\\n            return init\\n        },\\n        decrement() {\\n            init--\\n            return init\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original = init\\n    return {\\n        increment() {\\n            init++\\n            return init\\n        },\\n        reset() {\\n            init = original\\n            return init\\n        },\\n        decrement() {\\n            init--\\n            return init\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037329,
                "title": "easy-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init;\\n    function increment() {\\n        x = x+1;\\n        return x\\n    };\\n    function decrement() {\\n        x = x-1;\\n        return x\\n    };\\n\\n    function reset(){\\n        x = init;\\n        return x\\n    };\\n\\n    return { increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let x = init;\\n    function increment() {\\n        x = x+1;\\n        return x\\n    };\\n    function decrement() {\\n        x = x-1;\\n        return x\\n    };\\n\\n    function reset(){\\n        x = init;\\n        return x\\n    };\\n\\n    return { increment, decrement, reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035108,
                "title": "simple-js-solution",
                "content": "```\\nvar createCounter = function(init) {\\n    var val = init;\\n    return {\\n        increment: () => {\\n            return ++val;\\n        },\\n        decrement: () => {\\n            return --val;\\n        },\\n        reset: () => {\\n            val = init;\\n            return val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    var val = init;\\n    return {\\n        increment: () => {\\n            return ++val;\\n        },\\n        decrement: () => {\\n            return --val;\\n        },\\n        reset: () => {\\n            val = init;\\n            return val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034990,
                "title": "much-easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a=init;\\n    function increment(){\\n        return ++a\\n    }\\n    function decrement(){\\n        return --a\\n    }\\n    function reset(){\\n        return a=init\\n    }\\n    return{increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a=init;\\n    function increment(){\\n        return ++a\\n    }\\n    function decrement(){\\n        return --a\\n    }\\n    function reset(){\\n        return a=init\\n    }\\n    return{increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034374,
                "title": "js-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n    let startNumber = init;\\n\\n    return {\\n        increment: () => startNumber += 1,\\n        decrement: () => startNumber -= 1,\\n        reset: () => startNumber = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nfunction createCounter(init) {\\n    let startNumber = init;\\n\\n    return {\\n        increment: () => startNumber += 1,\\n        decrement: () => startNumber -= 1,\\n        reset: () => startNumber = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034021,
                "title": "js-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    const x = init;\\n    return {\\n        increment: function() {\\n            return ++init;\\n        },\\n        decrement: function() {\\n            return --init;\\n        },\\n        reset: function() {\\n            init = x;\\n            return init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    const x = init;\\n    return {\\n        increment: function() {\\n            return ++init;\\n        },\\n        decrement: function() {\\n            return --init;\\n        },\\n        reset: function() {\\n            init = x;\\n            return init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033889,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original=init\\n    let value=init\\n    return {\\n        increment:()=>{\\n            value+=1\\n            return value\\n        },\\n        reset:()=>{\\n            value=original\\n            return value\\n        },\\n        decrement:()=>{\\n            value-=1\\n            return value\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let original=init\\n    let value=init\\n    return {\\n        increment:()=>{\\n            value+=1\\n            return value\\n        },\\n        reset:()=>{\\n            value=original\\n            return value\\n        },\\n        decrement:()=>{\\n            value-=1\\n            return value\\n        }\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029317,
                "title": "outplay-99-69-memory",
                "content": "# Approach\\n`inc` increased and returned init\\n`dec` decreased and returned init\\n`reset` converted init to the og value\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return {\\n        increment:()=> ++init,\\n        decrement:()=>--init,\\n        reset:()=>init=c\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let c=init;\\n    return {\\n        increment:()=> ++init,\\n        decrement:()=>--init,\\n        reset:()=>init=c\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027377,
                "title": "best-js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let num = init;\\n    return {\\n        \"increment\": () => ++num,\\n        \"decrement\": () => --num,\\n        \"reset\": () => {num = init; return init}\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let num = init;\\n    return {\\n        \"increment\": () => ++num,\\n        \"decrement\": () => --num,\\n        \"reset\": () => {num = init; return init}\\n    }\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025475,
                "title": "counter",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let currVal = init;\\n    return {\\n        increment: () => {\\n            currVal++;\\n            return currVal;\\n        },\\n        reset: () => {\\n            currVal = init;\\n            return currVal;\\n        },\\n        decrement: () => {\\n            currVal--;\\n            return currVal;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let currVal = init;\\n    return {\\n        increment: () => {\\n            currVal++;\\n            return currVal;\\n        },\\n        reset: () => {\\n            currVal = init;\\n            return currVal;\\n        },\\n        decrement: () => {\\n            currVal--;\\n            return currVal;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022641,
                "title": "counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init;\\n\\n  function increment() {\\n    return ++presentCount;\\n  }\\n\\n  function decrement() {\\n      return --presentCount;\\n  }\\n\\n  function reset() {\\n      return (presentCount = init);\\n  }\\n\\n  return { increment, decrement, reset };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021430,
                "title": "simple-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return {\\n        increment: () => {\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: () => {\\n            currentValue = currentValue - 1;\\n            return currentValue;\\n        },\\n        reset: () => {\\n            currentValue = init;\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return {\\n        increment: () => {\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: () => {\\n            currentValue = currentValue - 1;\\n            return currentValue;\\n        },\\n        reset: () => {\\n            currentValue = init;\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021108,
                "title": "best-way-for-reset-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a= init;\\n    return{\\n        increment : function(){\\n            return ++a;\\n        },\\n        reset : function(){\\n            a= init;\\n            return a;\\n        },\\n        decrement : function(){\\n            return --a;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let a= init;\\n    return{\\n        increment : function(){\\n            return ++a;\\n        },\\n        reset : function(){\\n            a= init;\\n            return a;\\n        },\\n        decrement : function(){\\n            return --a;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020985,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    class Count {\\n            constructor() {\\n                this.init = init;\\n            }\\n\\n            increment() {\\n                this.init++;\\n                return this.init;\\n            }\\n\\n            decrement() {\\n                this.init--;\\n                return this.init;\\n            }\\n\\n            reset() {\\n                this.init = init;\\n                return this.init;\\n            }\\n        }\\n\\n    return new Count;\\n};\\n\\nconst counter = new createCounter(10);\\nconsole.log(counter.increment());\\nconsole.log(counter.reset());\\nconsole.log(counter.decrement());\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    class Count {\\n            constructor() {\\n                this.init = init;\\n            }\\n\\n            increment() {\\n                this.init++;\\n                return this.init;\\n            }\\n\\n            decrement() {\\n                this.init--;\\n                return this.init;\\n            }\\n\\n            reset() {\\n                this.init = init;\\n                return this.init;\\n            }\\n        }\\n\\n    return new Count;\\n};\\n\\nconst counter = new createCounter(10);\\nconsole.log(counter.increment());\\nconsole.log(counter.reset());\\nconsole.log(counter.decrement());\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020606,
                "title": "solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter=init;\\n    return{\\n        increment:function(){\\n            return ++counter;\\n        },\\n        reset:function(){\\n            counter=init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            return --counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var counter=init;\\n    return{\\n        increment:function(){\\n            return ++counter;\\n        },\\n        reset:function(){\\n            counter=init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            return --counter;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020054,
                "title": "counter-using-ts-and-js-fully-explained",
                "content": "# Approach\\n1- capture init (integer) and store it in a new variable\\n2- storing in new variable helps you reset the state to orignal else you will end up in getting the wring answer.\\n3- then on each function return the expected result \\n4- for information newVal+=1 === newVal++\\n5- REad the commented code also\\n6- there you see how we are storing simple integer in array\\n7- thats it...\\n\\n# TYPESCRIPT\\n\\n# Code\\n```ts\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let newVal = init;\\n    function increment (){\\n        return newVal +=1\\n    }\\n    function decrement (){\\n        return newVal -=1\\n    }\\n    function reset (){\\n        newVal = init;\\n        return newVal\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n```\\n\\n# JAVASCRIPT\\n\\n# Code\\n```js\\nconst createCounter = (init) => {\\n  let newVal  = init\\n  function increase() {    \\n    return newVal+=1;\\n  }\\n  function decrease() {\\n    return newVal-=1;\\n  }\\n  function reset() {    \\n    newVal= init\\n    return init;\\n  }\\n\\n  return {\\n    increase,\\n    decrease,\\n    reset,\\n  };\\n};\\n/*\\nconst init = 0;\\nconst counter = createCounter(init);\\nconst result = [];\\nresult.push(counter.increase());\\nresult.push(counter.increase());\\nresult.push(counter.decrease());\\nresult.push(counter.reset());\\nresult.push(counter.reset());\\nconsole.log(\"\\uD83D\\uDE80 ~ file: app.js:26 ~ result:\", result) -->\\n*/\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let newVal = init;\\n    function increment (){\\n        return newVal +=1\\n    }\\n    function decrement (){\\n        return newVal -=1\\n    }\\n    function reset (){\\n        newVal = init;\\n        return newVal\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n```\n```js\\nconst createCounter = (init) => {\\n  let newVal  = init\\n  function increase() {    \\n    return newVal+=1;\\n  }\\n  function decrease() {\\n    return newVal-=1;\\n  }\\n  function reset() {    \\n    newVal= init\\n    return init;\\n  }\\n\\n  return {\\n    increase,\\n    decrease,\\n    reset,\\n  };\\n};\\n/*\\nconst init = 0;\\nconst counter = createCounter(init);\\nconst result = [];\\nresult.push(counter.increase());\\nresult.push(counter.increase());\\nresult.push(counter.decrease());\\nresult.push(counter.reset());\\nresult.push(counter.reset());\\nconsole.log(\"\\uD83D\\uDE80 ~ file: app.js:26 ~ result:\", result) -->\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016831,
                "title": "simplest-code",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    \\n    function reset () {\\n        counter = init\\n        return counter\\n    }\\n\\n    return {\\n        increment: ()=> ++counter,\\n        decrement: ()=> --counter,\\n        reset: ()=> reset()\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter = init;\\n    \\n    function reset () {\\n        counter = init\\n        return counter\\n    }\\n\\n    return {\\n        increment: ()=> ++counter,\\n        decrement: ()=> --counter,\\n        reset: ()=> reset()\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014396,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {\\n       increment,\\n       decrement,\\n       reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nconst createCounter = (init) => {\\n    let count = init;\\n\\n    const increment = () => {\\n        count++;\\n        return count;\\n    }\\n\\n    const decrement = () => {\\n        count--;\\n        return count;\\n    }\\n\\n    const reset = () => {\\n        count = init;\\n        return count;\\n    }\\n\\n    return {\\n       increment,\\n       decrement,\\n       reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013390,
                "title": "javascript-detailed-explaination-easy-to-understand",
                "content": "# Intuition\\nThe `createCounter` function is designed to create a counter object with an initial value `init`. This counter object has three methods: `increment`, `decrement`, and `reset`, which respectively increase the value by 1, decrease the value by 1, and reset the value to the initial `init`.\\n\\n# Approach\\nWe have implemented the `createCounter` function that returns an object with three methods:\\n1. `increment()`: This method increments the `value` property of the counter object by 1 and then returns the updated value.\\n\\n2. `decrement()`: This method decrements the `value` property of the counter object by 1 and then returns the updated value.\\n\\n3. `reset()`: This method sets the `value` property of the counter object back to the initial `init` value and then returns the updated value.\\n\\nWe\\'ve used the `this` keyword to access the `value` property within each method.\\n\\n# Complexity\\n- Time complexity: All three methods, `increment`, `decrement`, and `reset`, have constant time complexity, i.e., O(1), as they perform simple value updates.\\n\\n- Space complexity: The `createCounter` function returns an object with three methods, but their memory usage is negligible. Therefore, the space complexity is also O(1).\\n\\n# Code\\n```javascript\\n/**\\n * @param {integer} init\\n * @return {Object}\\n */\\nvar createCounter = function(init) {\\n    return {\\n        value: init,\\n        increment() {\\n            return ++this.value;\\n        },\\n        decrement() {\\n            return --this.value;\\n        },\\n        reset() {\\n            this.value = init;\\n            return this.value;\\n        }\\n    };\\n};\\n\\n// Example usages:\\nconst counter1 = createCounter(5);\\nconsole.log(counter1.increment()); // 6\\nconsole.log(counter1.reset()); // 5\\nconsole.log(counter1.decrement()); // 4\\n\\nconst counter2 = createCounter(0);\\nconsole.log(counter2.increment()); // 1\\nconsole.log(counter2.increment()); // 2\\nconsole.log(counter2.decrement()); // 1\\nconsole.log(counter2.reset()); // 0\\nconsole.log(counter2.reset()); // 0\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {integer} init\\n * @return {Object}\\n */\\nvar createCounter = function(init) {\\n    return {\\n        value: init,\\n        increment() {\\n            return ++this.value;\\n        },\\n        decrement() {\\n            return --this.value;\\n        },\\n        reset() {\\n            this.value = init;\\n            return this.value;\\n        }\\n    };\\n};\\n\\n// Example usages:\\nconst counter1 = createCounter(5);\\nconsole.log(counter1.increment()); // 6\\nconsole.log(counter1.reset()); // 5\\nconsole.log(counter1.decrement()); // 4\\n\\nconst counter2 = createCounter(0);\\nconsole.log(counter2.increment()); // 1\\nconsole.log(counter2.increment()); // 2\\nconsole.log(counter2.decrement()); // 1\\nconsole.log(counter2.reset()); // 0\\nconsole.log(counter2.reset()); // 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012651,
                "title": "counter-ii-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let rs = init, curr = init;\\n    var op = {\\n        \"increment\": function() {\\n            return ++curr;\\n        },\\n        \"decrement\": function() {\\n            return --curr;\\n        },\\n        \"reset\": function() {\\n            curr = rs;\\n            return curr;\\n        }\\n    };\\n    return op;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let rs = init, curr = init;\\n    var op = {\\n        \"increment\": function() {\\n            return ++curr;\\n        },\\n        \"decrement\": function() {\\n            return --curr;\\n        },\\n        \"reset\": function() {\\n            curr = rs;\\n            return curr;\\n        }\\n    };\\n    return op;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010139,
                "title": "object-return",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let restore=init;\\n    return {\\n        increment:()=>{\\n        return restore+=1;\\n        },\\n        decrement:()=>{\\n         return restore-=1;\\n        },\\n        reset:()=>{\\n         return restore=init;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let restore=init;\\n    return {\\n        increment:()=>{\\n        return restore+=1;\\n        },\\n        decrement:()=>{\\n         return restore-=1;\\n        },\\n        reset:()=>{\\n         return restore=init;\\n\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009954,
                "title": "simple-solution-with-explanation",
                "content": "# Explanation\\n\\nBy Looking at the example, we know createCounter should return an object that has three attributes i.e. `increment`, `decrement`, and `reset`. Since `reset` has to reset the value to the initial value passed, we should create a reference to the initial value before we increase or decrease.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let initVal = init;\\n\\n  return {\\n    increment: () => {\\n      return ++initVal;\\n    },\\n    reset: () => {\\n      initVal = init;\\n      return initVal;\\n    },\\n    decrement: () => {\\n      return --initVal;\\n    },\\n  };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let initVal = init;\\n\\n  return {\\n    increment: () => {\\n      return ++initVal;\\n    },\\n    reset: () => {\\n      initVal = init;\\n      return initVal;\\n    },\\n    decrement: () => {\\n      return --initVal;\\n    },\\n  };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006921,
                "title": "easy-must-check-this",
                "content": "# Intuition\\nWe need function that  returns an object with three methods: increment, decrement, and reset. When you call these methods, they perform the respective operations and return the updated current value.\\n\\n# Approach\\nThis function returns an object with three methods: increment, decrement, and reset. When you call these methods, they perform the respective operations and return the updated current value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let currentValue = init;\\n return {\\n    increment: function () {\\n      currentValue++;\\n      return currentValue;\\n    },\\n    decrement: function () {\\n      currentValue--;\\n      return currentValue;\\n    },\\n    reset: function () {\\n      currentValue = init;\\n      return currentValue;\\n    },\\n\\n   } \\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n![killlakill-upvote.gif](https://assets.leetcode.com/users/images/ef409f66-3cf5-4d30-a804-afa8f9af9870_1693939067.415885.gif)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   let currentValue = init;\\n return {\\n    increment: function () {\\n      currentValue++;\\n      return currentValue;\\n    },\\n    decrement: function () {\\n      currentValue--;\\n      return currentValue;\\n    },\\n    reset: function () {\\n      currentValue = init;\\n      return currentValue;\\n    },\\n\\n   } \\n};\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006827,
                "title": "2-simple-and-easy-javascript-solution",
                "content": "# Code\\n1st approach -->\\n```\\n// Runtime 59ms Beats 67.12% of users\\n// Memory 44.28MB Beats 81.87% of users\\nvar createCounter = function(init) {\\n    let num = init;\\n    let obj = {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n    \\n    return obj;\\n};\\n\\n```\\n2nd approach -->\\n```\\n// Runtime 50ms Beats 94.63% of users\\n// Memory 44.10MB Beats 91.99% of users\\nlet createCounter = function(init) {\\n    let i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Runtime 59ms Beats 67.12% of users\\n// Memory 44.28MB Beats 81.87% of users\\nvar createCounter = function(init) {\\n    let num = init;\\n    let obj = {\\n        increment: () => num = num + 1,\\n        reset: () => num = init,\\n        decrement: () => num = num - 1\\n    }\\n    \\n    return obj;\\n};\\n\\n```\n```\\n// Runtime 50ms Beats 94.63% of users\\n// Memory 44.10MB Beats 91.99% of users\\nlet createCounter = function(init) {\\n    let i = init;\\n    function increment(){\\n        return ++init;\\n    }\\n    function decrement(){\\n        return --init;\\n    }\\n    function reset(){\\n        init = i;\\n        return init;\\n    }\\n    return{increment, decrement, reset}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005439,
                "title": "this-is-simple-here-we-are-setting-a-value-and-then-increment-and-decrement-using-arrow-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let i=0;\\n     return{\\n          increment:()=>init + ++i,\\n          decrement:()=>init + --i,\\n          reset:()=> {i=0;\\n          return init ;\\n          }\\n          \\n     }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n     let i=0;\\n     return{\\n          increment:()=>init + ++i,\\n          decrement:()=>init + --i,\\n          reset:()=> {i=0;\\n          return init ;\\n          }\\n          \\n     }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004243,
                "title": "counter-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    //store the initial value on another value in case of reset function\\n\\n    let initval = init\\n\\n    //the required functions \\n\\n    return {\\n        increment: ()=> ++init,\\n        decrement : () => --init,\\n        reset: ()=> init = initval\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    //store the initial value on another value in case of reset function\\n\\n    let initval = init\\n\\n    //the required functions \\n\\n    return {\\n        increment: ()=> ++init,\\n        decrement : () => --init,\\n        reset: ()=> init = initval\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4000896,
                "title": "javascript-method-chaining",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->can Do using method chaining approach.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let newInt = init;\\n    return {\\n        increment: ()=> {\\nnewInt+=1;\\n            return newInt;\\n        },\\n        reset:()=>{\\n           newInt=init;\\n            return newInt;\\n        },\\n        decrement: ()=>{\\n            newInt-=1;\\n            return newInt;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let newInt = init;\\n    return {\\n        increment: ()=> {\\nnewInt+=1;\\n            return newInt;\\n        },\\n        reset:()=>{\\n           newInt=init;\\n            return newInt;\\n        },\\n        decrement: ()=>{\\n            newInt-=1;\\n            return newInt;\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999105,
                "title": "normal-day-in-developers-life",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let cnt = init ;\\n    return {\\n        increment(){\\n            return ++cnt\\n        },\\n        decrement(){\\n            return --cnt\\n        },\\n        reset(){\\n            return cnt = init\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let cnt = init ;\\n    return {\\n        increment(){\\n            return ++cnt\\n        },\\n        decrement(){\\n            return --cnt\\n        },\\n        reset(){\\n            return cnt = init\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998338,
                "title": "3-lines-javascript-code-for-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let temp = init;\\n    return{\\n        increment: () => init+=1,\\n        decrement:() => init-=1,\\n        reset: () => init = temp\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let temp = init;\\n    return{\\n        increment: () => init+=1,\\n        decrement:() => init-=1,\\n        reset: () => init = temp\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998099,
                "title": "to-the-point-and-straight-to-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n=init; \\n    let count={increment : function inc(){\\n       return ++n;\\n    },decrement : function dec(){\\n     return --n;\\n\\n    },\\n    reset : function reset(){\\n        return (n=init);\\n    }}\\n    return count;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let n=init; \\n    let count={increment : function inc(){\\n       return ++n;\\n    },decrement : function dec(){\\n     return --n;\\n\\n    },\\n    reset : function reset(){\\n        return (n=init);\\n    }}\\n    return count;\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997967,
                "title": "counter-ii-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current_count =init;\\n    return {\\n        increment:function(){\\n            return ++current_count;\\n        },\\n        decrement:function(){\\n            return --current_count;\\n        },\\n        reset:function(){\\n            return (current_count =init);\\n        }\\n\\n    }\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current_count =init;\\n    return {\\n        increment:function(){\\n            return ++current_count;\\n        },\\n        decrement:function(){\\n            return --current_count;\\n        },\\n        reset:function(){\\n            return (current_count =init);\\n        }\\n\\n    }\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996340,
                "title": "ok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    \\n    let counter= init;\\n    const object = {\\n        \\n        increment:function(){\\n            counter++;\\n            return counter;\\n        },\\n        reset:function(){\\n            counter= init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            counter--;\\n            return counter;\\n        }\\n    \\n    }\\n        \\n      return object;  \\n    \\n};\\n\\ntry{\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n counter.reset(); // 5\\n  counter.decrement(); // 4\\n}catch(e){\\n    console.log(e.message)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    \\n    let counter= init;\\n    const object = {\\n        \\n        increment:function(){\\n            counter++;\\n            return counter;\\n        },\\n        reset:function(){\\n            counter= init;\\n            return counter;\\n        },\\n        decrement:function(){\\n            counter--;\\n            return counter;\\n        }\\n    \\n    }\\n        \\n      return object;  \\n    \\n};\\n\\ntry{\\n const counter = createCounter(5)\\n  counter.increment(); // 6\\n counter.reset(); // 5\\n  counter.decrement(); // 4\\n}catch(e){\\n    console.log(e.message)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996231,
                "title": "javascript-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let initialValue = init;\\n    return {\\n        increment: ()=>{\\n            init = init+1\\n            return init \\n        },\\n        decrement: ()=> {\\n            init = init-1\\n            return init \\n        },\\n        reset: ()=> {\\n            init = initialValue\\n            return init \\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let initialValue = init;\\n    return {\\n        increment: ()=>{\\n            init = init+1\\n            return init \\n        },\\n        decrement: ()=> {\\n            init = init-1\\n            return init \\n        },\\n        reset: ()=> {\\n            init = initialValue\\n            return init \\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3990723,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num+1,\\n        reset: () => num = init,\\n        decrement: () => num = num-1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init;\\n    return {\\n        increment: () => num = num+1,\\n        reset: () => num = init,\\n        decrement: () => num = num-1\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985409,
                "title": "ans-2665",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment () {\\n        return ++count\\n\\n    }\\n    function decrement() {\\n         return --count\\n\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }   \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let count = init;\\n\\n    function increment () {\\n        return ++count\\n\\n    }\\n    function decrement() {\\n         return --count\\n\\n    }\\n    function reset () {\\n        return count = init;\\n    }\\n    return {\\n        increment, decrement, reset\\n    }   \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985110,
                "title": "counter-ii",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let current = init\\n    return {\\n        increment: function () {\\n            current += 1;\\n            return current;\\n        },\\n        decrement: function () {\\n            current -= 1;\\n            return current;\\n        },\\n        reset: function () {\\n            current = init;\\n            return current;\\n        }\\n    }\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n    let current = init\\n    return {\\n        increment: function () {\\n            current += 1;\\n            return current;\\n        },\\n        decrement: function () {\\n            current -= 1;\\n            return current;\\n        },\\n        reset: function () {\\n            current = init;\\n            return current;\\n        }\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3982547,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have to keep the `init` value for `reset`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, I stored the `init` value in `n`. And I implement three functions. In particular, I include initialization process in `reset()`.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    let n = init;\\n\\n    return {\\n        increment(){\\n            return ++n;\\n        },\\n        decrement(){\\n            return --n;\\n        },\\n        reset(){\\n            return n = init;\\n        }\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n\\n    let n = init;\\n\\n    return {\\n        increment(){\\n            return ++n;\\n        },\\n        decrement(){\\n            return --n;\\n        },\\n        reset(){\\n            return n = init;\\n        }\\n    }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982004,
                "title": "use-the-some-variable-for-the-storing-the-value-before-the-return-statement",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    general=init\\n    return {\\n        increment: () => {\\n            general++\\n            return general;\\n        }, reset : ()=>{\\n            general=init;\\n            return general;\\n        },\\n        decrement: () => {\\n              general--\\n             \\n             return general\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    general=init\\n    return {\\n        increment: () => {\\n            general++\\n            return general;\\n        }, reset : ()=>{\\n            general=init;\\n            return general;\\n        },\\n        decrement: () => {\\n              general--\\n             \\n             return general\\n        }\\n        \\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981724,
                "title": "js-beats-78-of-coders-simplest-easiest-optimal-solution-using-arrow-function",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let pre = init;\\n    return {\\n        increment: () => ++pre,\\n        decrement: () => --pre,\\n        reset: () => pre = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let pre = init;\\n    return {\\n        increment: () => ++pre,\\n        decrement: () => --pre,\\n        reset: () => pre = init\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3979308,
                "title": "johnny",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    let totalCalls = 0;\\n    const initFix = init;\\n    if(-1000 <= init || init <= 1000){\\n        if(++totalCalls > 1000){ return \"total calls not to exceed 1000\"; }\\n        return {\\n            increment: function(){\\n                return ++current;\\n            }, \\n            decrement: function(){\\n                return --current;\\n            }, \\n            reset: function (){\\n                current = initFix;\\n                return current;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let current = init;\\n    let totalCalls = 0;\\n    const initFix = init;\\n    if(-1000 <= init || init <= 1000){\\n        if(++totalCalls > 1000){ return \"total calls not to exceed 1000\"; }\\n        return {\\n            increment: function(){\\n                return ++current;\\n            }, \\n            decrement: function(){\\n                return --current;\\n            }, \\n            reset: function (){\\n                current = initFix;\\n                return current;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978873,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let r=init;\\n    return {\\n        increment:function(){\\n            return ++r;\\n        },\\n        reset:function(){\\n            r=init;\\n            return r;\\n        },\\n        decrement:function(){\\n            return --r;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let r=init;\\n    return {\\n        increment:function(){\\n            return ++r;\\n        },\\n        reset:function(){\\n            r=init;\\n            return r;\\n        },\\n        decrement:function(){\\n            return --r;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978183,
                "title": "nice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nlet i = init\\n    return {\\n    increment: ()=>{\\n   return ++i\\n    },\\n    decrement: ()=>{\\n    return --i\\n    },\\n    reset: ()=>{\\n    return i = init\\n    }}};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nlet i = init\\n    return {\\n    increment: ()=>{\\n   return ++i\\n    },\\n    decrement: ()=>{\\n    return --i\\n    },\\n    reset: ()=>{\\n    return i = init\\n    }}};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977579,
                "title": "counter-ii-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977571,
                "title": "counter-ii-object",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\nvar curr=init;\\n  return{\\n        increment:()=>{\\n               return curr+=1;\\n\\n        },\\n         decrement:()=>{\\n               return  curr=curr-1\\n         },\\n         reset:()=>{\\n               return  curr=init\\n         }\\n\\n  }  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973195,
                "title": "concept-of-closures-and-objects-in-js",
                "content": "# Intuition\\nremember:\\nIn closures we have the referece to the parent variables.\\nwithin the object in three methods one by one, we are not copying the value and making the change,instead the change is made to the original value, as we are pointing to the same varibale.\\n\\nNeed to make two variables to keep track of the values, one for the reset value, at any  point of time, we can reset the current value to reset value.\\n```\\nlet resetVal = init;\\nlet value = resetVal;\\n// manipulate the value , increment it, decrement, whatever logic you perform, once there is a need to reset it to its initial ,\\nsimply // do this\\nvalue = resetVal;\\n```\\n# Approach\\ndefine three methods:\\n```\\nfunction increment (){...}\\nfunction decrement (){...}\\nfunction reset (){...}\\n```\\nand just return the object with these three methods:\\n```\\nreturn {\\nincrement: increment,\\ndecrement: decrement,\\nreset: reset\\n};\\n```\\ndo not be confuse here, because we are just passing the reference to the methods in the object.\\n\\nHope it helps, if yes, please upvote.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let resetVal = init; \\n    let value = resetVal; \\n\\n    function increment(){\\n        return ++value;    \\n    }\\n    function reset(){\\n        value = resetVal; \\n        return value; \\n    }\\n    function decrement(){\\n        return --value; \\n    }\\n    return {\\n        increment: increment,\\n        decrement: decrement,\\n        reset: reset\\n    };\\n};\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet resetVal = init;\\nlet value = resetVal;\\n// manipulate the value , increment it, decrement, whatever logic you perform, once there is a need to reset it to its initial ,\\nsimply // do this\\nvalue = resetVal;\\n```\n```\\nfunction increment (){...}\\nfunction decrement (){...}\\nfunction reset (){...}\\n```\n```\\nreturn {\\nincrement: increment,\\ndecrement: decrement,\\nreset: reset\\n};\\n```\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let resetVal = init; \\n    let value = resetVal; \\n\\n    function increment(){\\n        return ++value;    \\n    }\\n    function reset(){\\n        value = resetVal; \\n        return value; \\n    }\\n    function decrement(){\\n        return --value; \\n    }\\n    return {\\n        increment: increment,\\n        decrement: decrement,\\n        reset: reset\\n    };\\n};\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972407,
                "title": "clean-easy-solution",
                "content": "# Approach\\nStore the original variable separately which will be called upon reset.\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    let val = init\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    let val = init\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972132,
                "title": "solution-using-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n\\treturn {\\n\\t\\tinit: init,\\n\\t\\tincrement: function () {\\n\\t\\t\\treturn (this.init = this.init + 1)\\n\\t\\t},\\n\\t\\treset: function () {\\n\\t\\t\\treturn (this.init = init)\\n\\t\\t},\\n\\t\\tdecrement: function () {\\n\\t\\t\\treturn (this.init = this.init - 1)\\n\\t\\t},\\n\\t}\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function (init) {\\n\\treturn {\\n\\t\\tinit: init,\\n\\t\\tincrement: function () {\\n\\t\\t\\treturn (this.init = this.init + 1)\\n\\t\\t},\\n\\t\\treset: function () {\\n\\t\\t\\treturn (this.init = init)\\n\\t\\t},\\n\\t\\tdecrement: function () {\\n\\t\\t\\treturn (this.init = this.init - 1)\\n\\t\\t},\\n\\t}\\n}\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968582,
                "title": "js-solution-with-prefix-increment-and-decrement",
                "content": "\\n# Code\\n```\\nvar createCounter = function(init) {\\n    let result = init;\\n    return {\\n        increment: function() {\\n            return ++result;\\n        },\\n        decrement: function() {\\n            return --result;\\n        },\\n        reset: function() {\\n            result = init;\\n            return result;   \\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar createCounter = function(init) {\\n    let result = init;\\n    return {\\n        increment: function() {\\n            return ++result;\\n        },\\n        decrement: function() {\\n            return --result;\\n        },\\n        reset: function() {\\n            result = init;\\n            return result;   \\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966413,
                "title": "concise-and-modern-code",
                "content": "# Intuition\\nThe Thought was simple to use as minimum statements as possible.\\n\\n# Approach\\nUsed the modern arrow function syntax with increment operators.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = resetValue;\\n            return init;\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const resetValue = init;\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = resetValue;\\n            return init;\\n        },\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964317,
                "title": "counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    return {\\n   increment: () => num = num + 1,\\n    reset: () => num = init,\\n    decrement: () => num = num - 1\\n}\\n};\\n\\n\\n const counter = createCounter(5)\\n counter.increment(); // 6\\n counter.reset(); // 5\\n counter.decrement(); // 4\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let num = init\\n    return {\\n   increment: () => num = num + 1,\\n    reset: () => num = init,\\n    decrement: () => num = num - 1\\n}\\n};\\n\\n\\n const counter = createCounter(5)\\n counter.increment(); // 6\\n counter.reset(); // 5\\n counter.decrement(); // 4\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963953,
                "title": "simple-ts",
                "content": "# Code\\n```\\ninterface ReturnObj {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    const initCopy = init\\n\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = initCopy\\n            return init\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface ReturnObj {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nconst createCounter = (init: number): ReturnObj => {\\n    const initCopy = init\\n\\n    return {\\n        increment: () => ++init,\\n        decrement: () => --init,\\n        reset: () => {\\n            init = initCopy\\n            return init\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3963436,
                "title": "solution",
                "content": "# Intuition\\nmy first leetcode code that actually worked lol, i am sorry if its not upto the mark\\n# Code\\n\\nvar createCounter = function(init,cur) {\\n    cur=init\\n    return{\\n        increment: ()=>{\\n            return init=init+1;\\n        },\\n        decrement: ()=>{\\n            return init=init-1;\\n        },\\n        reset: ()=>{\\n            return init= cur;\\n        }\\n\\n    }\\n    \\n};\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nmy first leetcode code that actually worked lol, i am sorry if its not upto the mark\\n# Code\\n\\nvar createCounter = function(init,cur) {\\n    cur=init\\n    return{\\n        increment: ()=>{\\n            return init=init+1;\\n        },\\n        decrement: ()=>{\\n            return init=init-1;\\n        },\\n        reset: ()=>{\\n            return init= cur;\\n        }\\n\\n    }\\n    \\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3959373,
                "title": "simple-solution-to-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val = init;\\n    return {\\n        increment : () => {\\n            return ++val;\\n        },\\n        decrement : () => {\\n            return --val;\\n        },\\n        reset : () => {\\n            return val = init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val = init;\\n    return {\\n        increment : () => {\\n            return ++val;\\n        },\\n        decrement : () => {\\n            return --val;\\n        },\\n        reset : () => {\\n            return val = init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957960,
                "title": "counter-ii-solution",
                "content": "# Intuition\\nincrement(): Increase the current value by 1 and then return it.\\ndecrement(): Decrease the current value by 1 and then return it.\\nreset(): Set the current value to the initial value (init) and then return it.\\nKeeping these actions in mind, it\\'s important to note that the initial value of init needs to be preserved for the reset() operation. To achieve this, we can initialize a separate variable, count, with the initial value. This variable will be used to maintain the current value during the increment and decrement operations.\\n\\nBefore seeing the solution keep in mind the this Intution part and try again you can do it. it\\'s easy \\n\\n\\n# Approach\\nTo approach this problem, it\\'s helpful to read the provided instructions carefully and translate them into a step-by-step process for each of the required methods: increment(), decrement(), and reset().\\n\\n\\n# Complexity\\nTime complexity: O(1) - Each method performs a constant number of operations regardless of the input value.\\n\\nSpace complexity: O(1) - The additional space used is independent of the input and remains constant.\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\nlet createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment(){\\n            return ++count;\\n\\n        },\\n        decrement(){\\n            return --count;\\n\\n        },\\n        reset(){\\n          count = init;\\n          return count;\\n         \\n        },\\n    }\\n\\n    \\n     \\n };\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\n\\nlet createCounter = function(init) {\\n    let count = init;\\n    return {\\n        increment(){\\n            return ++count;\\n\\n        },\\n        decrement(){\\n            return --count;\\n\\n        },\\n        reset(){\\n          count = init;\\n          return count;\\n         \\n        },\\n    }\\n\\n    \\n     \\n };\\n\\n\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949017,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let presentCount = init\\n    return {\\n        increment:()=> ++presentCount,\\n        decrement:()=> --presentCount,\\n        reset:()=> presentCount = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947272,
                "title": "solution-using-es6-style",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter=init\\n    const increment=()=>{\\n        counter+=1;\\n    return counter\\n    }\\n    const decrement=()=>{\\n        counter-=1;\\n        return counter}\\n    const reset=()=>{counter=init\\n    return counter}\\n    return {increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let counter=init\\n    const increment=()=>{\\n        counter+=1;\\n    return counter\\n    }\\n    const decrement=()=>{\\n        counter-=1;\\n        return counter}\\n    const reset=()=>{counter=init\\n    return counter}\\n    return {increment,decrement,reset}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3945454,
                "title": "easy-approach",
                "content": "# Intuition\\n If you know chaining it would be child play really\\n# Approach\\nApproach see down what its actually asking then accordingly you do the task\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const originalValue = init;\\n    return{\\n        increment: ()=>{\\n            return ++init;\\n        },\\n        reset: ()=>{\\n            return init = originalValue; \\n        },\\n        decrement: ()=>{\\n            return --init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    const originalValue = init;\\n    return{\\n        increment: ()=>{\\n            return ++init;\\n        },\\n        reset: ()=>{\\n            return init = originalValue; \\n        },\\n        decrement: ()=>{\\n            return --init;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944911,
                "title": "counter-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let totalcount = init;\\n    increment = () => {\\n        totalcount++;\\n        return totalcount;\\n    }\\n    decrement = () => {\\n        totalcount--;\\n        return totalcount;\\n    }\\n     \\n    reset =() => {\\n        totalcount = init;\\n        return totalcount;\\n    }\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let totalcount = init;\\n    increment = () => {\\n        totalcount++;\\n        return totalcount;\\n    }\\n    decrement = () => {\\n        totalcount--;\\n        return totalcount;\\n    }\\n     \\n    reset =() => {\\n        totalcount = init;\\n        return totalcount;\\n    }\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944645,
                "title": "test",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const start = init;\\n    return {\\n        increment: () => {\\n            init += 1\\n            return init\\n        },\\n        decrement: () => {\\n            return init -= 1\\n        },\\n        reset: () => {\\n            init = start\\n             return init\\n        }\\n    }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    const start = init;\\n    return {\\n        increment: () => {\\n            init += 1\\n            return init\\n        },\\n        decrement: () => {\\n            return init -= 1\\n        },\\n        reset: () => {\\n            init = start\\n             return init\\n        }\\n    }\\n}\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944435,
                "title": "30-days-of-javascript-counter-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var curr = init;\\n    return{\\n        increment: function(){\\n            curr = curr + 1;\\n            return curr;\\n        },\\n        decrement: function(){\\n            curr--;\\n            return curr;\\n        },\\n        reset: function(){\\n            curr = init;\\n            return curr;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```\\n**PLEASE UpVOTE**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    var curr = init;\\n    return{\\n        increment: function(){\\n            curr = curr + 1;\\n            return curr;\\n        },\\n        decrement: function(){\\n            curr--;\\n            return curr;\\n        },\\n        reset: function(){\\n            curr = init;\\n            return curr;\\n        }\\n    }\\n    \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3943389,
                "title": "easy-to-understand-solution",
                "content": "# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let i = init;\\n  reset=()=>{\\n    i = init\\n    return i;\\n  }\\n  \\n  increment = () => ++i;\\n  decrement = () => --i;\\n  \\n  return {increment,decrement,reset};  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n  let i = init;\\n  reset=()=>{\\n    i = init\\n    return i;\\n  }\\n  \\n  increment = () => ++i;\\n  decrement = () => --i;\\n  \\n  return {increment,decrement,reset};  \\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942062,
                "title": "simplest-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const original = init;\\n    let value = init;\\n\\n    return {\\n        increment: function() {\\n            return ++value;\\n        },\\n        decrement: function() {\\n            return --value;\\n        },\\n        reset: function() {\\n            value = original;\\n            return original;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n   const original = init;\\n    let value = init;\\n\\n    return {\\n        increment: function() {\\n            return ++value;\\n        },\\n        decrement: function() {\\n            return --value;\\n        },\\n        reset: function() {\\n            value = original;\\n            return original;\\n        }\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940454,
                "title": "clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let current = Number(init);\\n\\n    const increment = () => ++current;\\n\\n    const decrement = () => --current;\\n\\n    const reset = () => {\\n        current = Number(init);\\n        return init;\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let current = Number(init);\\n\\n    const increment = () => ++current;\\n\\n    const decrement = () => --current;\\n\\n    const reset = () => {\\n        current = Number(init);\\n        return init;\\n    }\\n\\n    return {\\n        increment,\\n        decrement,\\n        reset\\n    };\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937735,
                "title": "2665-javascript-solution-for-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val=init;\\n    function increment(){\\n        val++;\\n        return val\\n    }\\n    function decrement(){\\n        val--;\\n        return val\\n    }\\n    function reset(){\\n        val=init;\\n        return val\\n    }\\n    return{\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let val=init;\\n    function increment(){\\n        val++;\\n        return val\\n    }\\n    function decrement(){\\n        val--;\\n        return val\\n    }\\n    function reset(){\\n        val=init;\\n        return val\\n    }\\n    return{\\n        increment,\\n        decrement,\\n        reset\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936285,
                "title": "30-days-of-javascript-counter-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore a copy of initial value into a variable and update according to the functions requirments.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First Make a Variable named currentValue to store initial value\\n2) in functions return block, create three function increment, decrement and reset.\\n3) Now Follow The Problem requirment and update and return currentValue in functions.\\n4) In reset, Reset the currentValue to it\\'s initial value\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return{\\n        increment: function(){\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: function(){\\n            currentValue--;\\n            return currentValue;\\n        },\\n        reset: function(){\\n            currentValue = init\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let currentValue = init;\\n    return{\\n        increment: function(){\\n            currentValue = currentValue + 1;\\n            return currentValue;\\n        },\\n        decrement: function(){\\n            currentValue--;\\n            return currentValue;\\n        },\\n        reset: function(){\\n            currentValue = init\\n            return currentValue;\\n        }\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924517,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {integer} init                                \\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    // let val = init\\n    // let count = 0\\n    // console.log(count++)\\n    let val = init\\n   return{\\n       increment:()=>{\\n           return ++init\\n       },\\n       decrement:()=>{\\n           return --init\\n       },\\n       reset:()=>{\\n           return init = val\\n       }\\n   }\\n\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init                                \\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    // let val = init\\n    // let count = 0\\n    // console.log(count++)\\n    let val = init\\n   return{\\n       increment:()=>{\\n           return ++init\\n       },\\n       decrement:()=>{\\n           return --init\\n       },\\n       reset:()=>{\\n           return init = val\\n       }\\n   }\\n\\n\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923237,
                "title": "typescript-minimalistic-code",
                "content": "# Code\\n```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let val = init;\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype ReturnObj = {\\n    increment: () => number,\\n    decrement: () => number,\\n    reset: () => number,\\n}\\n\\nfunction createCounter(init: number): ReturnObj {\\n    let val = init;\\n    return {\\n        increment: () => ++val,\\n        decrement: () => --val,\\n        reset: () => val = init,\\n    }\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3920972,
                "title": "beginner-friendly-approach",
                "content": "# Intuition\\nuse a const to store value of init for reset function. we can directly increment or decrement the value of init and reset the value using the const we declared.\\n# Complexity\\nbeats 80% in both time complexity and space complexity.\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n    const a=init;\\n    return{\\n        increment: ()=> ++init,\\n        reset: ()=> init=a,\\n        decrement: ()=>--init\\n        }\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nuse a const to store value of init for reset function. we can directly increment or decrement the value of init and reset the value using the const we declared.\\n# Complexity\\nbeats 80% in both time complexity and space complexity.\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n    const a=init;\\n    return{\\n        increment: ()=> ++init,\\n        reset: ()=> init=a,\\n        decrement: ()=>--init\\n        }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3916749,
                "title": "shortest-and-easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar createCounter = function(init) {\\n let num = init;\\n   return {\\n       increment: ()=>{\\n           return ++num ;\\n       },\\n       reset: ()=>{\\n           return num = init;\\n       },\\n         decrement: ()=>{\\n           return --num;\\n       },\\n         \\n   } \\n};\\n\\n\\n  const counter = createCounter(5)\\n counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar createCounter = function(init) {\\n let num = init;\\n   return {\\n       increment: ()=>{\\n           return ++num ;\\n       },\\n       reset: ()=>{\\n           return num = init;\\n       },\\n         decrement: ()=>{\\n           return --num;\\n       },\\n         \\n   } \\n};\\n\\n\\n  const counter = createCounter(5)\\n counter.increment(); // 6\\n  counter.reset(); // 5\\n  counter.decrement(); // 4\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916350,
                "title": "easy-javascript-solution",
                "content": "> If you like vote up\\n\\n# Code\\n```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let i=init;\\n    function increment(){\\n        i++\\n        return i;\\n    }\\n    function reset(){\\n        i=init\\n        return init\\n    }\\n    function decrement(){\\n        i--\\n        return i\\n    }\\n    return {\"increment\":increment,\"reset\":reset,\"decrement\":decrement}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {integer} init\\n * @return { increment: Function, decrement: Function, reset: Function }\\n */\\nvar createCounter = function(init) {\\n    let i=init;\\n    function increment(){\\n        i++\\n        return i;\\n    }\\n    function reset(){\\n        i=init\\n        return init\\n    }\\n    function decrement(){\\n        i--\\n        return i\\n    }\\n    return {\"increment\":increment,\"reset\":reset,\"decrement\":decrement}\\n};\\n\\n/**\\n * const counter = createCounter(5)\\n * counter.increment(); // 6\\n * counter.reset(); // 5\\n * counter.decrement(); // 4\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1882561,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885855,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886327,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2037503,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886326,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886103,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885727,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2069468,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2024731,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2003921,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1882561,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885855,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886327,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2037503,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886326,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1886103,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1885727,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2069468,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2024731,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 2003921,
                "content": [
                    {
                        "username": "najwer23",
                        "content": "Variables declared inside a closure are not garbage collected! \\n\\nAnd it is important in SPA and nodeJS server\\n\\n"
                    },
                    {
                        "username": "devvrat02",
                        "content": "Yes it is"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Finally got a chance to use the pre increment and decrement operators outside of school somewhere. \\uD83C\\uDF1F"
                    },
                    {
                        "username": "harshitdongre043",
                        "content": "Just Read it twice easy \\nThe three functions are:\\n\\nincrement() increases the current value by 1 and then returns it.\\ndecrement() reduces the current value by 1 and then returns it.\\nreset() sets the current value to init and then returns it.\\n "
                    },
                    {
                        "username": "jaya_p",
                        "content": "var createCounter = function(init) {\n    let count = init\n    \n         function increment(){\n             count++;\n             return count;\n        }\n\n         function decrement(){\n              count--;\n             return  count;\n        }\n\n        function reset(){\n             count= init;\n         return count\n        }\n\n    return {\n        increment,\n        decrement,\n        reset }\n};\n\n var counter = createCounter(0);\n\n counter.increment(); \n counter.increment();\n counter.decrement();\n counter.reset(); \n counter.reset(); \n\n var counter2 = createCounter(5);\n counter2.increment(); \n counter2.reset(); \n counter2.decrement(); \n\n\n\n"
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "nice to see you can use object function as class function"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Can someone explain how reset is returning currentCount in reset()\\n\\n `var createCounter = function(init) {\\n  let currentCount = init;\\n  return {\\n    increment: () => ++currentCount,\\n    decrement: () => --currentCount,\\n    reset: () => (currentCount = init),\\n  }\\n};`"
                    },
                    {
                        "username": "NaiNonTH",
                        "content": "[@happybarnwal007](/happybarnwal007) Keep in mind, the \\'init\\' value is not constant, which means it can be affected with the increment and decrement functions"
                    },
                    {
                        "username": "happybarnwal007",
                        "content": "[@Mister_CK](/Mister_CK) why is it necessary to do currentCount=init and why  not directly return the init in reset. Its showing error if i am doing directly"
                    },
                    {
                        "username": "cJayesh",
                        "content": "[@Mister_CK](/Mister_CK) Thanks!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "when you use an arrow function without accolades like :\\n```\\nreset: () => (currentCount = init), \\n```\\nthe return is implied, so it\\'s equivalent to:\\n```\\nreset: () =>{ return (currentCount = init) }, \\n```\\nFurthermore, `currentCount = init` returns the value of init. \\nLastly, you don\\'t need the parentheses, so you can do it like:\\n```\\nreset: () => currentCount = init,\\n```"
                    },
                    {
                        "username": "AiyanFaras",
                        "content": "can anybody explain whats wong with my code?\\n \\nvar counter = {\\n        \"increment\": function(){\\n            return cur+1;\\n        },\\n        \"decrement\": function(){\\n            return cur-1;\\n        },\\n        \"reset\": function(){\\n            cur =init;\\n            return cur;\\n        }}\\n        return counter;"
                    },
                    {
                        "username": "SukhrobCode",
                        "content": "Hi \\uD83D\\uDD90\\n var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: () => ++counter,\\n        decrement: () => --counter,\\n        reset: () => (counter = init),\\n    }\\n}"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "[@Mister_CK](/Mister_CK) what does increment : in front of function mean in jS???\\n"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "firstly, you don't want to use \"\", change it to just `increment: function`\nsecondly, you are returning cur+1. But you are not actually changing cur. So if you do a multiple operations of increment, the value will always be the original + 1.\nWhat you want to do is to change the value of cur and return that, like:\n```\nincrement: function(){\nreturn cur = cur+1;\n},\n```\nEven smoother would be to use pre/post-increment operator, this is functionally equivalent, it just looks nicer:\n```\nincrement: function(){\nreturn ++cur;\n},\n```\nnote that the ++ comes in front of the cur, because you want to first increment and then return the incremented value. \nAlso if you don't use { } you don't need to add return and you can put it on one line if you make it an arrow function like this:\n```\nincrement: () => ++cur,\n```\nps: if you put three backticks (```) on a separate line above and below your code snippet, it gets formatted nicely like this."
                    },
                    {
                        "username": "hossien014",
                        "content": "to much esey"
                    },
                    {
                        "username": "Umarwaru",
                        "content": "Is this not the proper way to use methods? I thought it methods would work for this problem. \\n\\n```\\nvar createCounter = function(init) {\\n\\n    if (init <= -1000 || init >= 1000)\\n    return;\\n\\t\\t\\n    const counter = {\\n\\t\\t\\n        increment:  (init) => {\\n            return init++\\n        },\\n\\t\\t\\t\\t\\n        decrement: (init) => {\\n            return init--\\n        },\\n\\t\\t\\t\\t\\n        reset: (init) => {\\n            return init\\n        }\\n\\t\\t\\t\\t\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "What is the wrong with my code:\\nvar createCounter = function(init) {\\n    return {\\n        increment: () =>  init + 1  ,\\n        decrement: () =>  init - 1,\\n         reset: () =>   init,\\n    }\\n};"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you need to store a value in a variable that you can increment, so that it remains there between function calls, now you are using whatever value init is every time. You need something like the output I have here\\n```\\nvar createCounter = function(init) {\\n    let output = init\\n    return {\\n        increment: () => ++output,\\n        decrement:() => --output, \\n        reset: () => output = init\\n    }    \\n\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1989045,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1984897,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1976245,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1966499,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1936923,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1915150,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1912508,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1886460,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1886012,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            },
            {
                "id": 1885922,
                "content": [
                    {
                        "username": "praneshkamthe2919",
                        "content": "pre-increment / decrement for this solution, pre updates the value first and then gives the updated value, post increment/decrement returns the value then increments / decrements. "
                    },
                    {
                        "username": "user7069l",
                        "content": "why my solution is only working for the second case?\\n\\n ```var createCounter = function(init) {\\n    let counter = init;\\n    return {\\n        increment: function(){\\n            counter++;\\n            return counter;\\n        },\\n        decrement: function(){\\n            counter--;\\n            return counter;\\n        },\\n        reset: function(){\\n            return init;\\n        }\\n    }\\n};\\n"
                    },
                    {
                        "username": "user9957jV",
                        "content": "reset: function(){\\n           counter = init;\\n           return init;\\n       }\\n\\nPlease add this. This will work."
                    },
                    {
                        "username": "ercanK",
                        "content": "Your `reset` function is not correct. \"`reset()` sets the current value to `init` and then returns it.\", i.e. after reset, current value should restart from `init`."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "You are not alone who messed up this problem and regret later. just store that init somewhere and manipulate it!"
                    },
                    {
                        "username": "saikiranchikkala20",
                        "content": "var createcounter=function(init){\\nlet count=init\\nfunction increment(){\\n    return ++count\\n   \\n}\\nfunction decrement(){\\n    return --count\\n}\\nfunction reset( ){\\n    count=init\\n    return count;\\n}\\n\\nreturn{\\n    increment:increment,\\n    decrement:decrement,\\n    reset:reset,\\n}\\n}\\n\\ncan someone explain whats wrong in this?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "Day - 4 \\uD83D\\uDE05"
                    },
                    {
                        "username": "user7117Is",
                        "content": "How can I understand weird behavior of this code:\\nvar createCounter = function(init) {\\n    const counter={\\n        currentCount:init,\\n        increment:()=>++this.currentCount,\\n        decrement:()=>--this.currentCount,\\n        reset:()=>this.currentCount=init\\n    }\\n    return counter\\n};\\n\\nI understand exposing currentCount is a problem, which I realised a bit later. But now I am interested in understanding its behavior"
                    },
                    {
                        "username": "mishamio",
                        "content": "would it be possible to solve it for fn with an arbitrary number of parameters? I got stuck for a while here cuz I thought that it was the requirement."
                    },
                    {
                        "username": "VaseemBhai",
                        "content": "I\\'ve received these kinds of counter related questions during my interviews. It\\'s like a starter question to test waters I guess.."
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "Hey Guys Done Day 3 \\uD83D\\uDE01\\n.\\n.\\nHint : \\nval = init\\nStep 1 : pre increment\\nStep 2 : pre decrement\\nStep 3 : initialize with val"
                    },
                    {
                        "username": "devvrat02",
                        "content": "If a person worked on redux or created apis then they are using this regularly in a way.  "
                    }
                ]
            }
        ]
    },
    {
        "title": "Array of Objects to Matrix",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1902848,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903293,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903150,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1891351,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902985,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903197,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903309,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902757,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902979,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1905253,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902848,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903293,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903150,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1891351,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902985,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903197,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1903309,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902757,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1902979,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            },
            {
                "id": 1905253,
                "content": [
                    {
                        "username": "cartesPerforees",
                        "content": "wh... why?"
                    },
                    {
                        "username": "dviewy",
                        "content": "Good bye JavaScript Challenge :)"
                    },
                    {
                        "username": "dviewy",
                        "content": "Welcome back JavaScript Challenge! :D\\n\\n\\u0410fter three days of brute-force coding, I managed to solve the problem"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "++1"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "got stuck on test case 77, it has huge input, and the Output/Expected sections are not completely rendered in results. This makes hard to understand what was wrong with my solution.\nAfter spending some time found that there were 2 headers `\"name\" ` and `\"name.0\"`. Since `name` is a string , my solution was wrongly interpreting that string as array, and for header `\"name.0\"` was adding first letter to the output. \nAdditional test case with input\n```js\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\n```\nand Expected\n```js\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\n```\nwould made my life much easier. Hope this helps somebody else"
                    },
                    {
                        "username": "usajjad123",
                        "content": "Thanks for sharing this, I was already scratching my head on this one. You\\'re the MVP!"
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Great testcase. Thanks for sharing."
                    },
                    {
                        "username": "ahtoh_",
                        "content": "In the condition of the problem, it should be noted that there is no symbol \".\" in the name of the properties of objects.\\nsimple example:\\narr = [\\n  {\\n    [\"a.b\"]: 1,\\n    a: { b: 2 },\\n  }\\n]\\nwhat will be the answer?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can use backticks to format your code, what you wrote is not valid input. Assuming you ment something like this:\n`[{[\"a.b\"]: 1, \"a\": { \"b\": 2 }}]` yields: `unhashable type: 'list'`\nor this:\n`[{\"a.b\": 1, \"a\": { \"b\": 2 }}]` yields: `[[\"a.b\"],[2]]`\nthat passes. but that is indeed a weird edge case, because the 1 disappears. Which  is probably not what you want in your code. \n"
                    },
                    {
                        "username": "AntonBorzenko",
                        "content": "The function signature is incorrect in Typescript. Actual is:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[] {\\n```\\nBut expected:\\n```typescript\\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\\n```"
                    },
                    {
                        "username": "aman1320",
                        "content": "Who categorized this  super hard problem in medium ???"
                    },
                    {
                        "username": "rcomesan",
                        "content": "If you're lost, try the following approach:\n`1) gather all unique paths`\n`2) sort them in lexicographically ascending order`\n`3) go over each path in sorted order, and for each row populate the output matrix`"
                    },
                    {
                        "username": "justforfunby",
                        "content": "Could someone explain why this is the wrong answer?\\nInput:\\n[[[[1]]],[[2]],[3]]\\nOutput:\\n [[\"0\",\"0.0\",\"0.0.0\"],[[[1]],[1],1],[[2],2,\"\"],[3,\"\",\"\"]]\\nExpected:\\n[[\"0\",\"0.0\",\"0.0.0\"],[\"\",\"\",1],[\"\",2,\"\"],[3,\"\",\"\"]]"
                    },
                    {
                        "username": "soupracer",
                        "content": "[@justforfunby](/justforfunby) Yes, you\\'re right, since \"0\" is a valid path in the object. I guess they should clarify whether the values in the object have to be primitive values and not objects/arrays."
                    },
                    {
                        "username": "justforfunby",
                        "content": "[@soupracer](/soupracer) \\nbut `[[[1]]][\"0\"]` should be `[[1]]` not `\"\"`"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in `arr`.\" For example, `[[[1]]]` is an object in `arr`, which is represented by a row. In this object you only find \"1\", hence, [\"\", \"\", 1] is a row in `arr`. That is how I interpret it."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Testcase fails despite me returning expected output (highlighted expected and actual output with browser's find feature):\n<img src=\"https://i.ibb.co/RDWFcKv/image.png\" alt=\"image\" border=\"0\" />\n\nI admit, that my solution is far from optimal. But it had given actual output that exactly matches expected, so what gives?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "[@danlavrushko](/danlavrushko) Thanks for this testcase, it was, in fact, not passed by my code.\\nAlas, even after me changing the code to handle it correctly, I still have the exact same problem. :idk:"
                    },
                    {
                        "username": "danlavrushko",
                        "content": "[@Artem Diachenko](/Dzuchun) it looks like I had the same issue, I\\'ve posted a separate comment here. In short, try this test case \\n```js\\n[{ \"name\": \"John\" }, { \"name\": [ false ] }]\\n```\\nthe correct result should be \\n```js\\n[[\"name\", \"name.0\"],[\"John\",\"\"],[\"\",false]]\\n```"
                    },
                    {
                        "username": "soupracer",
                        "content": "The output looks truncated, so it\\'s impossible to say if they are exact. Is there a way to expand them? "
                    },
                    {
                        "username": "agora94",
                        "content": "I feel like the description does not give enough info/constraints. I have the following questions unanswered:\n-If two objects inside arr both have matching key/value pairs, do we overwrite or append? I.e should arr=[{'a':1}, {'a':1}] return [['a'],[1]] or [['a'],[1],[1]]\n-If one object has another object under key 'a', can we expect all subsequent occurrences of 'a' to map to an object, or can we get different levels of nesting like [{'a':{'b':2},{'a':1}]?"
                    },
                    {
                        "username": "soupracer",
                        "content": "\"Each of the remaining rows corresponds to an object in arr. \"\\n\\nSo I would guess the second array you presented, with regards to your first question.\\n\\nWouldn\\'t the full path be `a.a` to the nested object, in your 2nd question?"
                    }
                ]
            }
        ]
    }
]