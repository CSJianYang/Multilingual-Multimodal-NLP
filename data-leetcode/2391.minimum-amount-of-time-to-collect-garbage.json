[
    {
        "title": "Minimum Amount of Time to Collect Garbage",
        "question_content": "You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.\nYou are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.\nThere are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.\nOnly one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.\nReturn the minimum number of minutes needed to pick up all the garbage.\n&nbsp;\nExample 1:\n\nInput: garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\nOutput: 21\nExplanation:\nThe paper garbage truck:\n1. Travels from house 0 to house 1\n2. Collects the paper garbage at house 1\n3. Travels from house 1 to house 2\n4. Collects the paper garbage at house 2\nAltogether, it takes 8 minutes to pick up all the paper garbage.\nThe glass garbage truck:\n1. Collects the glass garbage at house 0\n2. Travels from house 0 to house 1\n3. Travels from house 1 to house 2\n4. Collects the glass garbage at house 2\n5. Travels from house 2 to house 3\n6. Collects the glass garbage at house 3\nAltogether, it takes 13 minutes to pick up all the glass garbage.\nSince there is no metal garbage, we do not need to consider the metal garbage truck.\nTherefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.\n\nExample 2:\n\nInput: garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\nOutput: 37\nExplanation:\nThe metal garbage truck takes 7 minutes to pick up all the metal garbage.\nThe paper garbage truck takes 15 minutes to pick up all the paper garbage.\nThe glass garbage truck takes 15 minutes to pick up all the glass garbage.\nIt takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.\n\n&nbsp;\nConstraints:\n\n\t2 <= garbage.length <= 105\n\tgarbage[i] consists of only the letters 'M', 'P', and 'G'.\n\t1 <= garbage[i].length <= 10\n\ttravel.length == garbage.length - 1\n\t1 <= travel[i] <= 100",
        "solutions": [
            {
                "id": 2492774,
                "title": "java-c-python-explanation-with-observations",
                "content": "# **Intuition**\\nObservation 1:\\n\"While one truck is driving or picking up garbage, the other two trucks cannot do anything.\"\\nWe can simply sum up the total running time for each truck,\\nthey don\\'t affect each other.\\n\\n\\nObservation 2:\\n\"Picking up one unit of any type of garbage takes 1 minute.\"\\nWe don\\'t care how many units for each type,\\nwe only care the total amount.\\n\\nObservation 3:\\n\"however, they do not need to visit every house.\"\\nWe only care the position of the last garbage for each type\\n<br>\\n\\n# **Explanation**\\n1. Firstly sum up the amount of gabages in total.\\n2. Second find up the last position for each type.\\n3. Calculate the prefix sum array of the travel distance.\\n3. Sum up the distance for each type of garbage.\\n<br>\\n\\n# **Complexity**\\nTime `O(garbage + travel)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int last[] = new int[128], res = 0;\\n        for (int i = 0; i < garbage.length; ++i) {\\n            res += garbage[i].length();\\n            for (int j = 0; j < garbage[i].length(); ++j)\\n                last[garbage[i].charAt(j)] = i;\\n        }\\n        for (int j = 1; j < travel.length; ++j)\\n            travel[j] += travel[j - 1];\\n        for (int c : \"PGM\".toCharArray())\\n            if (last[c] > 0)\\n                res += travel[last[c] - 1];\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int last[128] = {}, res = 0;\\n        for (int i = 0; i < garbage.size(); ++i) {\\n            res += garbage[i].size();\\n            for (char c : garbage[i])\\n                last[c] = i;\\n        }\\n        for (int j = 1; j < travel.size(); ++j)\\n            travel[j] += travel[j - 1];\\n        for (int c : \"PGM\")\\n            if (last[c])\\n                res += travel[last[c] - 1];\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def garbageCollection(self, A: List[str], travel: List[int]) -> int:\\n        last = {c: i for i,pgm in enumerate(A) for c in pgm}\\n        dis = list(accumulate(travel, initial = 0))\\n        return sum(map(len, A)) + sum(dis[last.get(c, 0)] for c in \\'PGM\\')\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int last[] = new int[128], res = 0;\\n        for (int i = 0; i < garbage.length; ++i) {\\n            res += garbage[i].length();\\n            for (int j = 0; j < garbage[i].length(); ++j)\\n                last[garbage[i].charAt(j)] = i;\\n        }\\n        for (int j = 1; j < travel.length; ++j)\\n            travel[j] += travel[j - 1];\\n        for (int c : \"PGM\".toCharArray())\\n            if (last[c] > 0)\\n                res += travel[last[c] - 1];\\n        return res;\\n    }\\n```\n```cpp\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int last[128] = {}, res = 0;\\n        for (int i = 0; i < garbage.size(); ++i) {\\n            res += garbage[i].size();\\n            for (char c : garbage[i])\\n                last[c] = i;\\n        }\\n        for (int j = 1; j < travel.size(); ++j)\\n            travel[j] += travel[j - 1];\\n        for (int c : \"PGM\")\\n            if (last[c])\\n                res += travel[last[c] - 1];\\n        return res;\\n    }\\n```\n```py\\n    def garbageCollection(self, A: List[str], travel: List[int]) -> int:\\n        last = {c: i for i,pgm in enumerate(A) for c in pgm}\\n        dis = list(accumulate(travel, initial = 0))\\n        return sum(map(len, A)) + sum(dis[last.get(c, 0)] for c in \\'PGM\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492857,
                "title": "using-map-count-very-easy-and-simple-to-understand",
                "content": "<b> Up Vote if you like the solution\\n\\n1. Count all the garbage size irrespective of type - as each garbage is taking 1min\\n2. Keep tracking last g, p, m visited house - as we do not need to move further.\\n```\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int count = 0;\\n        int lastp = 0, lastm = 0, lastg = 0;\\n        for(int i = 0; i < garbage.size(); ++i){\\n            for(auto c: garbage[i]){\\n                count++;\\n                if(c == \\'M\\') lastm = i;\\n                else if(c == \\'G\\') lastg = i;\\n                else lastp = i;\\n            }\\n        }\\n        for(int i = 1; i < travel.size(); ++i){\\n            travel[i] += travel[i-1];\\n        }\\n        int ans = count;\\n        if(lastm > 0) ans+= travel[lastm-1];\\n        if(lastg > 0) ans+= travel[lastg-1];\\n        if(lastp > 0) ans+= travel[lastp-1];\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int count = 0;\\n        int lastp = 0, lastm = 0, lastg = 0;\\n        for(int i = 0; i < garbage.size(); ++i){\\n            for(auto c: garbage[i]){\\n                count++;\\n                if(c == \\'M\\') lastm = i;\\n                else if(c == \\'G\\') lastg = i;\\n                else lastp = i;\\n            }\\n        }\\n        for(int i = 1; i < travel.size(); ++i){\\n            travel[i] += travel[i-1];\\n        }\\n        int ans = count;\\n        if(lastm > 0) ans+= travel[lastm-1];\\n        if(lastg > 0) ans+= travel[lastg-1];\\n        if(lastp > 0) ans+= travel[lastp-1];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492716,
                "title": "find-last-index-java",
                "content": "**Solution:**\\n* for every character add 1 to your sum for pickup time.\\n* find the last index of each type of garbage, use prefix sum to find travel time till that index.\\n\\n**Code:**\\n\\n    public int garbageCollection(String[] gar, int[] travel) {\\n        int p=0, m=0, g=0, sum=0;\\n\\n        for(int i=0; i<gar.length; i++){\\n            for(char ch : gar[i].toCharArray()){\\n                if(ch==\\'P\\') p = i;\\n                else if(ch==\\'M\\') m = i;\\n                else if(ch==\\'G\\') g = i;\\n                sum++;                         // add 1 min for every pick-up\\n            }\\n        }\\n        \\n        for(int i=1; i<travel.length; i++)\\n            travel[i] = travel[i]+travel[i-1];\\n        \\n\\t\\tif(p!=0) sum+= travel[p-1];           // travel time till last P\\n        if(m!=0) sum += travel[m-1];          // travel time till last M\\n        if(g!=0) sum += travel[g-1];           // travel time till last G\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "**Solution:**\\n* for every character add 1 to your sum for pickup time.\\n* find the last index of each type of garbage, use prefix sum to find travel time till that index.\\n\\n**Code:**\\n\\n    public int garbageCollection(String[] gar, int[] travel) {\\n        int p=0, m=0, g=0, sum=0;\\n\\n        for(int i=0; i<gar.length; i++){\\n            for(char ch : gar[i].toCharArray()){\\n                if(ch==\\'P\\') p = i;\\n                else if(ch==\\'M\\') m = i;\\n                else if(ch==\\'G\\') g = i;\\n                sum++;                         // add 1 min for every pick-up\\n            }\\n        }\\n        \\n        for(int i=1; i<travel.length; i++)\\n            travel[i] = travel[i]+travel[i-1];\\n        \\n\\t\\tif(p!=0) sum+= travel[p-1];           // travel time till last P\\n        if(m!=0) sum += travel[m-1];          // travel time till last M\\n        if(g!=0) sum += travel[g-1];           // travel time till last G\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2948533,
                "title": "beats-100-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int totalTime = 0;\\n        int len = garbage.length;\\n        totalTime+=1*garbage[0].length();\\n        for(int i = 1; i<len; i++){\\n            totalTime+=1*garbage[i].length();\\n            totalTime+=3*travel[i-1]; \\n        }\\n        boolean foundG = garbage[len-1].contains(\"G\");\\n        boolean foundP = garbage[len-1].contains(\"P\");\\n        boolean foundM = garbage[len-1].contains(\"M\");\\n        for(int i = len-1; i>=1; i--){\\n            if(!foundG)foundG = garbage[i].contains(\"G\");\\n            if(!foundP)foundP = garbage[i].contains(\"P\");\\n            if(!foundM)foundM = garbage[i].contains(\"M\");\\n            if(foundP && foundG && foundM)break;\\n            if(!foundG)totalTime-=travel[i-1];\\n            if(!foundP)totalTime-=travel[i-1];\\n            if(!foundM)totalTime-=travel[i-1];\\n        }\\n        return totalTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int totalTime = 0;\\n        int len = garbage.length;\\n        totalTime+=1*garbage[0].length();\\n        for(int i = 1; i<len; i++){\\n            totalTime+=1*garbage[i].length();\\n            totalTime+=3*travel[i-1]; \\n        }\\n        boolean foundG = garbage[len-1].contains(\"G\");\\n        boolean foundP = garbage[len-1].contains(\"P\");\\n        boolean foundM = garbage[len-1].contains(\"M\");\\n        for(int i = len-1; i>=1; i--){\\n            if(!foundG)foundG = garbage[i].contains(\"G\");\\n            if(!foundP)foundP = garbage[i].contains(\"P\");\\n            if(!foundM)foundM = garbage[i].contains(\"M\");\\n            if(foundP && foundG && foundM)break;\\n            if(!foundG)totalTime-=travel[i-1];\\n            if(!foundP)totalTime-=travel[i-1];\\n            if(!foundM)totalTime-=travel[i-1];\\n        }\\n        return totalTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493527,
                "title": "python-explained-solution-easy",
                "content": "Calculate count of paper,glass and metal and total time taken to collecte each one of them. \\nTotal time taken can be calculated by the index of the last house with that item and adding the total time taken to reach that house.\\nAdd all value and return.\\n\\n**CODE:**\\n```\\ndef garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n    count_paper,count_glass,count_metal=0,0,0\\n    paper_idx,glass_idx,metal_idx=-1,-1,-1\\n\\n    for i in range(len(garbage)):\\n        if \\'P\\' in garbage[i]:\\n            # update index and count of paper\\n            paper_idx=i\\n            count_paper+=garbage[i].count(\\'P\\')\\n        if \\'G\\' in garbage[i]:\\n            # update index and count of glass\\n            glass_idx=i\\n            count_glass+=garbage[i].count(\\'G\\')\\n        if \\'M\\' in garbage[i]:\\n            # update index and count of metal\\n            metal_idx=i\\n            count_metal+=garbage[i].count(\\'M\\')\\n\\n    # calculate cumulative time\\n    time=[]\\n    time.append(0)\\n    for i in range(len(travel)):\\n        time.append(time[-1]+travel[i])\\n\\n    res=0\\n    res+=(time[paper_idx] if paper_idx!=-1 else 0) +(time[glass_idx] if glass_idx!=-1 else 0) + (time[metal_idx] if metal_idx!=-1 else 0)\\n    \\n    res+=count_paper+count_glass+count_metal\\n    return res\\n```\\n**Time Complexity:- O(N)**\\n\\n```\\ntime=[]\\ntime.append(0)\\nfor i in range(len(travel)):\\n\\t\\ttime.append(time[-1]+travel[i])\\nres=0\\nfor type in [\"P\",\"G\",\"M\"]:\\n\\tcnt=0\\n\\tidx=0\\n\\tfor i in range(len(garbage)):\\n\\t\\tif type in garbage[i]:\\n\\t\\t\\t# update index and count\\n\\t\\t\\tidx=i\\n\\t\\t\\tcnt+=garbage[i].count(type)\\n\\tres+=cnt+time[idx]\\nreturn res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\ndef garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n    count_paper,count_glass,count_metal=0,0,0\\n    paper_idx,glass_idx,metal_idx=-1,-1,-1\\n\\n    for i in range(len(garbage)):\\n        if \\'P\\' in garbage[i]:\\n            # update index and count of paper\\n            paper_idx=i\\n            count_paper+=garbage[i].count(\\'P\\')\\n        if \\'G\\' in garbage[i]:\\n            # update index and count of glass\\n            glass_idx=i\\n            count_glass+=garbage[i].count(\\'G\\')\\n        if \\'M\\' in garbage[i]:\\n            # update index and count of metal\\n            metal_idx=i\\n            count_metal+=garbage[i].count(\\'M\\')\\n\\n    # calculate cumulative time\\n    time=[]\\n    time.append(0)\\n    for i in range(len(travel)):\\n        time.append(time[-1]+travel[i])\\n\\n    res=0\\n    res+=(time[paper_idx] if paper_idx!=-1 else 0) +(time[glass_idx] if glass_idx!=-1 else 0) + (time[metal_idx] if metal_idx!=-1 else 0)\\n    \\n    res+=count_paper+count_glass+count_metal\\n    return res\\n```\n```\\ntime=[]\\ntime.append(0)\\nfor i in range(len(travel)):\\n\\t\\ttime.append(time[-1]+travel[i])\\nres=0\\nfor type in [\"P\",\"G\",\"M\"]:\\n\\tcnt=0\\n\\tidx=0\\n\\tfor i in range(len(garbage)):\\n\\t\\tif type in garbage[i]:\\n\\t\\t\\t# update index and count\\n\\t\\t\\tidx=i\\n\\t\\t\\tcnt+=garbage[i].count(type)\\n\\tres+=cnt+time[idx]\\nreturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492819,
                "title": "prefix-sum",
                "content": "We need to track the distance to the last house with the garbage of each type.\\n\\n**C++**\\n```cpp\\nint garbageCollection(vector<string>& garb, vector<int>& travel) {\\n    int dist[128] = {};\\n    partial_sum(begin(travel), end(travel), begin(travel));\\n    for (int i = 1; i < garb.size(); ++i)\\n        for (auto g : garb[i])\\n            dist[g] = travel[i - 1];\\n    return accumulate(begin(garb), end(garb), 0, [](int sz, const auto& g) { return sz + g.size(); })\\n        + accumulate(begin(dist), end(dist), 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint garbageCollection(vector<string>& garb, vector<int>& travel) {\\n    int dist[128] = {};\\n    partial_sum(begin(travel), end(travel), begin(travel));\\n    for (int i = 1; i < garb.size(); ++i)\\n        for (auto g : garb[i])\\n            dist[g] = travel[i - 1];\\n    return accumulate(begin(garb), end(garb), 0, [](int sz, const auto& g) { return sz + g.size(); })\\n        + accumulate(begin(dist), end(dist), 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493358,
                "title": "c-count-easy-efficient-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int garbageCollection(vector<string>& gar, vector<int>& tra) \\n    {\\n        int cnt=0;\\n        int last_g=0, last_p=0, last_m=0;\\n            \\n        for(int i=0; i<gar.size(); i++)\\n        {\\n            for(auto it:gar[i])\\n            {\\n                //finding last index of a type of garbage\\n                if(it==\\'M\\') last_m=i;\\n                else if(it==\\'P\\') last_p=i;\\n                else last_g=i;\\n                cnt++; //for any type of garbage it take 1 unit time\\n            }\\n        }\\n        \\n        int tot=cnt;\\n        \\n        //use the prefix sum to find time taken in traveling\\n        int sum=0;\\n        for(int i=0; i<tra.size(); i++)\\n        {\\n            sum += tra[i];\\n            if(last_g==i+1) tot += sum;\\n            if(last_p==i+1) tot += sum;\\n            if(last_m==i+1) tot += sum;   \\n        }\\n        return tot;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int garbageCollection(vector<string>& gar, vector<int>& tra) \\n    {\\n        int cnt=0;\\n        int last_g=0, last_p=0, last_m=0;\\n            \\n        for(int i=0; i<gar.size(); i++)\\n        {\\n            for(auto it:gar[i])\\n            {\\n                //finding last index of a type of garbage\\n                if(it==\\'M\\') last_m=i;\\n                else if(it==\\'P\\') last_p=i;\\n                else last_g=i;\\n                cnt++; //for any type of garbage it take 1 unit time\\n            }\\n        }\\n        \\n        int tot=cnt;\\n        \\n        //use the prefix sum to find time taken in traveling\\n        int sum=0;\\n        for(int i=0; i<tra.size(); i++)\\n        {\\n            sum += tra[i];\\n            if(last_g==i+1) tot += sum;\\n            if(last_p==i+1) tot += sum;\\n            if(last_m==i+1) tot += sum;   \\n        }\\n        return tot;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492963,
                "title": "java-python-3-prefix-sum-of-travel-time",
                "content": "The time cost of each truck includes the following `2` parts:\\n1. Gabage pick up time: depends on the total units of the specific type of gabage at all houses;\\n2. Travel time: depends on the time cost from house `0` to the last house that has the type of gabage corresponding to the truck. We can use prefix sum to compute it.\\n\\n\\n```java\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int n = garbage.length, k = 0, pickupTime = 0;\\n        int[] prefixSum = new int[n];\\n        for (int t : travel) {\\n            prefixSum[k + 1] = prefixSum[k++] + t;\\n        }\\n        Map<Character, Integer> truckToTime = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            pickupTime += garbage[i].length();\\n            for (char c : garbage[i].toCharArray()) {\\n                truckToTime.put(c, prefixSum[i]);\\n            }\\n        }\\n        return pickupTime + truckToTime.values().stream().mapToInt(i -> i).sum();\\n    }\\n```\\n\\n```python\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        prefix_sum = [0]\\n        for t in travel:\\n            prefix_sum.append(prefix_sum[-1] + t)\\n        truck_to_time = {}\\n        for i, g in enumerate(garbage):\\n            for c in g:\\n                truck_to_time[c] = prefix_sum[i]\\n        return sum(truck_to_time.values()) + sum(map(len, garbage))\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = garbage.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int n = garbage.length, k = 0, pickupTime = 0;\\n        int[] prefixSum = new int[n];\\n        for (int t : travel) {\\n            prefixSum[k + 1] = prefixSum[k++] + t;\\n        }\\n        Map<Character, Integer> truckToTime = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            pickupTime += garbage[i].length();\\n            for (char c : garbage[i].toCharArray()) {\\n                truckToTime.put(c, prefixSum[i]);\\n            }\\n        }\\n        return pickupTime + truckToTime.values().stream().mapToInt(i -> i).sum();\\n    }\\n```\n```python\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        prefix_sum = [0]\\n        for t in travel:\\n            prefix_sum.append(prefix_sum[-1] + t)\\n        truck_to_time = {}\\n        for i, g in enumerate(garbage):\\n            for c in g:\\n                truck_to_time[c] = prefix_sum[i]\\n        return sum(truck_to_time.values()) + sum(map(len, garbage))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492748,
                "title": "easy-c-code-with-intuition-optimization-complexity-analysis",
                "content": "\\n# Intuition\\n\\nLet\\'s say we find time taken for one type. \\n- We start from first house, then check if this house has that grabage or not. If it has we pickup the garbage and calculate cost to travel to this house from last house which had same garbage.\\n- Otherwise, we just go to next house.\\n\\nWe repreat this process three times, once for each type, Papre, Glass, and Metal.\\n\\n<br />\\n    \\n# Some Optimizations:\\n\\n- Either you can calculate cost to travel from \\'ith\\' house to \\'jth\\' house on traversing from \\'i\\' to \\'j\\' in travel array every time. Or you can keep **prefix sum array** to find travel cost between two indices in constant time.\\n    We keep previous house marked and move forward to next house when a house with same type of garbage comes, we calculate travel cost from prev house to current in constant time.\\n\\n- This is minor optimization, To find if current house has \\'X\\' type of garbage or not, either you can traverse on string every time in for loop. Or you can keep this result precomputed in a hashmap.\\n\\n<br />\\n    \\n# Code:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans = 0;\\n        int n = garbage.size();\\n        int m = travel.size();\\n        \\n        // Precomputation: To find time to travel from i to j house in O(1).\\n        vector<int> prefix(m + 1, 0);\\n        for (int i = 0; i < m; ++i) {\\n            prefix[i + 1] = prefix[i] + travel[i];\\n        }\\n        \\n        // Precomputation: Mark is a house has that garbage.\\n        vector<unordered_map<char,int>> have (n, unordered_map<char,int>());\\n        for (int i = 0; i < n; ++i) {\\n            for (auto garb : garbage[i]) {\\n                have[i][garb]++;\\n            }\\n        }\\n        \\n        // For each type of the truck.\\n        for (auto type : {\\'P\\', \\'G\\', \\'M\\'}) {\\n            int prevHouse = 0;\\n            for (int currHouse = 0; currHouse < n; ++currHouse) {\\n                // Check is current house has that type of waste.\\n                if (have[currHouse][type] > 0) {\\n                    // Then we need 1 min for each item of that type to pick up.\\n                    ans += have[currHouse][type];\\n                    \\n                    // If we are at first house we don\\'t add time taken to travel from prev location to current location.\\n                    if (currHouse != 0) {\\n                        // Otherwise we add and update prev location variable.\\n                        ans += prefix[currHouse] - prefix[prevHouse];\\n                        prevHouse = currHouse;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<br />\\n\\n### If `N` is size of garbage array, `L` is length of garbage array string, and `M` is length of travel array.\\n    \\n# Time Complexity:\\n\\n- We traverse on travel array once which takes `O(M)` time.\\n- Then, we traverse on garbage array strings once which will take `O(N * L)` time.\\n- Then, we traverse on gargabe array 3 times for each type of garbage, which takes `O(3 * N)` time.\\n- Thus, overall complexity, `O((M) + (N * L) + (3 * N)) = O(M + NL)`. \\n\\n<br />\\n    \\n# Space Complexity:\\n    \\n- We have use two arrays `prefix` of size `M + 1` and `have` of size `3 * N`.\\n- Thus, overall complexity, `O((M + 1) + (3 * N)) = O(M + N)`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans = 0;\\n        int n = garbage.size();\\n        int m = travel.size();\\n        \\n        // Precomputation: To find time to travel from i to j house in O(1).\\n        vector<int> prefix(m + 1, 0);\\n        for (int i = 0; i < m; ++i) {\\n            prefix[i + 1] = prefix[i] + travel[i];\\n        }\\n        \\n        // Precomputation: Mark is a house has that garbage.\\n        vector<unordered_map<char,int>> have (n, unordered_map<char,int>());\\n        for (int i = 0; i < n; ++i) {\\n            for (auto garb : garbage[i]) {\\n                have[i][garb]++;\\n            }\\n        }\\n        \\n        // For each type of the truck.\\n        for (auto type : {\\'P\\', \\'G\\', \\'M\\'}) {\\n            int prevHouse = 0;\\n            for (int currHouse = 0; currHouse < n; ++currHouse) {\\n                // Check is current house has that type of waste.\\n                if (have[currHouse][type] > 0) {\\n                    // Then we need 1 min for each item of that type to pick up.\\n                    ans += have[currHouse][type];\\n                    \\n                    // If we are at first house we don\\'t add time taken to travel from prev location to current location.\\n                    if (currHouse != 0) {\\n                        // Otherwise we add and update prev location variable.\\n                        ans += prefix[currHouse] - prefix[prevHouse];\\n                        prevHouse = currHouse;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127798,
                "title": "c-prefix-sum-o-n-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConcept is to use prefix sum as we have given time from one to another house instead xounting one by one from one to other house just find the last index at which certain type of grabage is present  and count all the units of garbage presnt while traversing . \\nAt last or answer will be total garbage units + time of each grabage upto its last index i.e where its lastly presnt. \\nSo have prefix sum of time and when u find the last occurece of a agrbage just add that time upto that index in our answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum\\n# Complexity\\n- Time complexity:$$O(N*10)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garb, vector<int>& trav) {\\n        int sum=0;\\n        int k=0;\\n        int mi=-1,gi=-1,pi=-1;\\n        for(int i=1;i<trav.size();i++)trav[i]=trav[i-1]+trav[i];\\n        for(auto x:garb){\\n            for(auto c:x){\\n                sum++;\\n                if(c==\\'M\\')mi=k;\\n                if(c==\\'P\\')pi=k;\\n                if(c==\\'G\\')gi=k;\\n            }\\n            k++;\\n        }\\n         sum+= ((mi>0)?trav[mi-1]:0);\\n         sum+= ((gi>0)?trav[gi-1]:0);\\n         sum+= ((pi>0)?trav[pi-1]:0);\\n        return sum;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garb, vector<int>& trav) {\\n        int sum=0;\\n        int k=0;\\n        int mi=-1,gi=-1,pi=-1;\\n        for(int i=1;i<trav.size();i++)trav[i]=trav[i-1]+trav[i];\\n        for(auto x:garb){\\n            for(auto c:x){\\n                sum++;\\n                if(c==\\'M\\')mi=k;\\n                if(c==\\'P\\')pi=k;\\n                if(c==\\'G\\')gi=k;\\n            }\\n            k++;\\n        }\\n         sum+= ((mi>0)?trav[mi-1]:0);\\n         sum+= ((gi>0)?trav[gi-1]:0);\\n         sum+= ((pi>0)?trav[pi-1]:0);\\n        return sum;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593490,
                "title": "easy-javascript-solution-16-lines",
                "content": "```\\nconst garbageCollection = (garbage, travel) => {\\n  let travelTime = 0\\n  garbage = garbage.reverse()\\n  \\n  for (const type of [\\'G\\', \\'P\\', \\'M\\']) {\\n    const lastHouseWithGarbage = garbage.findIndex(house => house.includes(type))\\n    \\n    if (lastHouseWithGarbage === -1) {\\n      continue\\n    }\\n\\n    travelTime += travel.slice(0, garbage.length - lastHouseWithGarbage - 1).reduce((acc, num) => acc + num, 0)\\n  }\\n\\n  return garbage.join(\\'\\').length + travelTime\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst garbageCollection = (garbage, travel) => {\\n  let travelTime = 0\\n  garbage = garbage.reverse()\\n  \\n  for (const type of [\\'G\\', \\'P\\', \\'M\\']) {\\n    const lastHouseWithGarbage = garbage.findIndex(house => house.includes(type))\\n    \\n    if (lastHouseWithGarbage === -1) {\\n      continue\\n    }\\n\\n    travelTime += travel.slice(0, garbage.length - lastHouseWithGarbage - 1).reduce((acc, num) => acc + num, 0)\\n  }\\n\\n  return garbage.join(\\'\\').length + travelTime\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492878,
                "title": "adhoc-2-pass-with-explanation-o-1-space",
                "content": "**Intuition**\\n    Just a adhoc problem by seeing how the test cases are working.\\n    \\n**Observation**\\n    \\n  1. We have to take either all **\\'M\\'** or all **\\'P\\'** or all **\\'G\\'** together at one iteration.\\n  2. The **time of travel after the last position of each character from left will not be counted in total cost**.\\n    \\n  They just confused by saying it a **minimum time**, there is no **minimum**.\\n  They just told to **follow the algorithm** and return the **total cost by following given rules.**\\n    \\n  For fullfilling the second point, I used 3 variables to keep a mark of last occurence from **left**.\\n  This mark for each will **prevent us from increasing cost of pick after the last occurence of a character is reached**.\\n    \\n  Now we just have to do 3 iteration each for **\\'M\\'**, **\\'P\\'** and **\\'G\\'** and collect total cost\\n  \\n **Time** - O(`n * 10`) [In worst case]\\n **Space** - O(`1`)\\n<iframe src=\"https://leetcode.com/playground/cs6xPPHJ/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Intuition**\\n    Just a adhoc problem by seeing how the test cases are working.\\n    \\n**Observation**\\n    \\n  1. We have to take either all **\\'M\\'** or all **\\'P\\'** or all **\\'G\\'** together at one iteration.\\n  2. The **time of travel after the last position of each character from left will not be counted in total cost**.\\n    \\n  They just confused by saying it a **minimum time**, there is no **minimum**.\\n  They just told to **follow the algorithm** and return the **total cost by following given rules.**\\n    \\n  For fullfilling the second point, I used 3 variables to keep a mark of last occurence from **left**.\\n  This mark for each will **prevent us from increasing cost of pick after the last occurence of a character is reached**.\\n    \\n  Now we just have to do 3 iteration each for **\\'M\\'**, **\\'P\\'** and **\\'G\\'** and collect total cost\\n  \\n **Time** - O(`n * 10`) [In worst case]\\n **Space** - O(`1`)\\n<iframe src=\"https://leetcode.com/playground/cs6xPPHJ/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2555618,
                "title": "easy-python-solution-using-prefix-sum",
                "content": "Important observation:\\nAs For commute time, we only care about when a specific kind of garbage **last appears**. Because we can skip the remaining if that kind of garbage doesn\\'t appear anymore.\\nTo make things easier, we will use **prefix sum** to help us do the calculation.\\n\\nTherefore, the algorithm is very intuitive: \\n1) Go through the garbage list\\na. Increment the res by the size of the garbage, because a unit will cost 1 minute\\nb. Update indexes. After traversal, the indexes should be where each garbage last appears\\n2) increment the res by calculating the commute time using prefix sum and indexes\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n\\t\\t\\t# add 0 to prefix because for the first house the commute time is 0\\n            prefix = [0]\\n            cur = 0\\n            for time in travel:\\n                cur += time\\n                prefix.append(cur)\\n\\t\\t\\t# the default index is zero\\n\\t\\t\\t# it does not mean each grabage appears in the first house, only for calculation convenience\\n            M_idx, G_idx, P_idx = 0, 0, 0\\n            res = 0\\n            for i in range(len(garbage)):\\n                res += len(garbage[i])\\n                if \"M\" in garbage[i]:\\n                    M_idx = i\\n                if \"G\" in garbage[i]:\\n                    G_idx = i\\n                if \"P\" in garbage[i]:\\n                    P_idx = i\\n            res += prefix[M_idx]\\n            res += prefix[G_idx]\\n            res += prefix[P_idx]\\n            \\n            return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n\\t\\t\\t# add 0 to prefix because for the first house the commute time is 0\\n            prefix = [0]\\n            cur = 0\\n            for time in travel:\\n                cur += time\\n                prefix.append(cur)\\n\\t\\t\\t# the default index is zero\\n\\t\\t\\t# it does not mean each grabage appears in the first house, only for calculation convenience\\n            M_idx, G_idx, P_idx = 0, 0, 0\\n            res = 0\\n            for i in range(len(garbage)):\\n                res += len(garbage[i])\\n                if \"M\" in garbage[i]:\\n                    M_idx = i\\n                if \"G\" in garbage[i]:\\n                    G_idx = i\\n                if \"P\" in garbage[i]:\\n                    P_idx = i\\n            res += prefix[M_idx]\\n            res += prefix[G_idx]\\n            res += prefix[P_idx]\\n            \\n            return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492775,
                "title": "implementation-hashmap",
                "content": "\\n\\nSimply Find the limit for every \\'P\\',\\'M\\' and \\'G\\'\\n\\nthen loop for every garbage of type \\'P\\',\\'M\\' and \\'G\\' and add count of the garbage of current string and time cost till current house \\n\\n\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        long ans=0;\\n        \\n        int limit_m=-1,limit_p=-1,limit_g=-1;\\n        \\n        for(int i=garbage.length-1; i>=0; i--){\\n            \\n            if(limit_m>-1 && limit_g>-1 && limit_p>-1) break;\\n            \\n            for(char ch:garbage[i].toCharArray()){\\n                if(ch==\\'M\\' && limit_m==-1) limit_m=i;\\n                \\n                if(ch==\\'P\\' && limit_p==-1) limit_p=i;\\n                \\n                if(ch==\\'G\\' && limit_g==-1) limit_g=i;\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<=limit_m; i++){\\n            HashMap<Character,Integer> map=getCount(garbage[i]);\\n            \\n            int trcl=(i==0)?0:travel[i-1];\\n            \\n            if(map.containsKey(\\'M\\')){\\n                ans+=map.get(\\'M\\');\\n            }\\n            ans+=trcl;\\n        }\\n        \\n        for(int i=0; i<=limit_p; i++){\\n            HashMap<Character,Integer> map=getCount(garbage[i]);\\n            \\n            int trcl=(i==0)?0:travel[i-1];\\n            \\n\\n            \\n            if(map.containsKey(\\'P\\')){\\n                ans+=map.get(\\'P\\');\\n            }\\n            \\n\\n            \\n            ans+=trcl;\\n        }\\n        \\n        for(int i=0; i<=limit_g; i++){\\n            HashMap<Character,Integer> map=getCount(garbage[i]);\\n            \\n            int trcl=(i==0)?0:travel[i-1];\\n            \\n            if(map.containsKey(\\'G\\')){\\n                ans+=map.get(\\'G\\');\\n            }\\n            \\n            ans+=trcl;\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n    HashMap<Character,Integer> getCount(String str){\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        \\n        for(char ch:str.toCharArray()){\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        \\n        return map;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        long ans=0;\\n        \\n        int limit_m=-1,limit_p=-1,limit_g=-1;\\n        \\n        for(int i=garbage.length-1; i>=0; i--){\\n            \\n            if(limit_m>-1 && limit_g>-1 && limit_p>-1) break;\\n            \\n            for(char ch:garbage[i].toCharArray()){\\n                if(ch==\\'M\\' && limit_m==-1) limit_m=i;\\n                \\n                if(ch==\\'P\\' && limit_p==-1) limit_p=i;\\n                \\n                if(ch==\\'G\\' && limit_g==-1) limit_g=i;\\n            }\\n        }\\n        \\n        \\n        for(int i=0; i<=limit_m; i++){\\n            HashMap<Character,Integer> map=getCount(garbage[i]);\\n            \\n            int trcl=(i==0)?0:travel[i-1];\\n            \\n            if(map.containsKey(\\'M\\')){\\n                ans+=map.get(\\'M\\');\\n            }\\n            ans+=trcl;\\n        }\\n        \\n        for(int i=0; i<=limit_p; i++){\\n            HashMap<Character,Integer> map=getCount(garbage[i]);\\n            \\n            int trcl=(i==0)?0:travel[i-1];\\n            \\n\\n            \\n            if(map.containsKey(\\'P\\')){\\n                ans+=map.get(\\'P\\');\\n            }\\n            \\n\\n            \\n            ans+=trcl;\\n        }\\n        \\n        for(int i=0; i<=limit_g; i++){\\n            HashMap<Character,Integer> map=getCount(garbage[i]);\\n            \\n            int trcl=(i==0)?0:travel[i-1];\\n            \\n            if(map.containsKey(\\'G\\')){\\n                ans+=map.get(\\'G\\');\\n            }\\n            \\n            ans+=trcl;\\n        }\\n        \\n        return (int)ans;\\n    }\\n    \\n    HashMap<Character,Integer> getCount(String str){\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        \\n        for(char ch:str.toCharArray()){\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        \\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496578,
                "title": "easy-approach-c-o-n",
                "content": "```\\nvoid countFreq(string s, int &G, int &P, int &M){\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'G\\') G++;\\n            else if(s[i]==\\'M\\') M++;\\n            else if(s[i]==\\'P\\') P++;\\n        }\\n    }\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n=garbage.size();\\n        int t=travel.size();\\n        int G=0,P=0,M=0;\\n        countFreq(garbage[n-1],G,P,M);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(G!=0) G += travel[i];\\n            if(M!=0) M += travel[i];\\n            if(P!=0) P += travel[i];\\n            \\n            countFreq(garbage[i],G,P,M);\\n        }\\n        return G+M+P;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid countFreq(string s, int &G, int &P, int &M){\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'G\\') G++;\\n            else if(s[i]==\\'M\\') M++;\\n            else if(s[i]==\\'P\\') P++;\\n        }\\n    }\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n=garbage.size();\\n        int t=travel.size();\\n        int G=0,P=0,M=0;\\n        countFreq(garbage[n-1],G,P,M);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(G!=0) G += travel[i];\\n            if(M!=0) M += travel[i];\\n            if(P!=0) P += travel[i];\\n            \\n            countFreq(garbage[i],G,P,M);\\n        }\\n        return G+M+P;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493001,
                "title": "idea-explained-counting-and-prefix-sum-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is simple, we need to count the number of different type of garbages at each house and travel time to reach a house.\\n* Also, a garbage truck of some type will only stop at a house if it has garbage of that type, else move to next house.\\n\\n* If a truck stops at a particular house, we can use a prefix sum of travel time to get time to reach current house from previous stop. \\n\\t* Use 3 variables or an array to keep track of previous visited house of each type of garbage.\\n* So, time required by truck of a particular type to pick garbage from current house is :\\n\\t* Time to travel from previous house from which garbage of this type was picked\\n\\t* And number of garbages of current type i.e type of truck.\\n* Sum up the travel time for each type of trucks and return total travel time\\n# Code : \\n\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = travel.size();\\n        vector<int> prefixSum(n+1, 0);\\n        \\n\\t\\t// Prefix sum of travel time from [0 to ith] house\\n        for(int i=0; i<n; i++) {\\n            prefixSum[i+1] = travel[i] + prefixSum[i];\\n        }\\n        \\n\\t\\t// To keep track of previous visited house of each type of garbage\\n        unordered_map<char, int> prevIdx;\\n        \\n        int idx = 0, totalTime = 0;\\n\\n        for(auto& house : garbage) {\\n            int metalCount = 0, glassCount = 0, paperCount = 0;\\n            \\n\\t\\t\\t// Count the number of garbage of each type\\n            for(auto& type : house) {\\n                if(type == \\'M\\') metalCount++;\\n                else if(type == \\'P\\') paperCount++;\\n                else if(type == \\'G\\') glassCount++;\\n            }\\n            \\n\\t\\t\\t// If metal type is present in current house, then only pick else skip\\n            if(metalCount) {\\n\\t\\t\\t\\t// Sum of travel time from previous house to current\\n\\t\\t\\t\\t// And time to pick all metal type garbage\\n                totalTime += prefixSum[idx] - prefixSum[prevIdx[\\'M\\']] + metalCount;\\n                prevIdx[\\'M\\'] = idx;\\n            }\\n            \\n\\t\\t\\t// If glass type is present in current house, then only pick else skip\\n            if(glassCount) {\\n\\t\\t\\t\\t// Sum of travel time from previous house to current\\n\\t\\t\\t\\t// And time to pick all glass type garbage\\n                totalTime += prefixSum[idx] - prefixSum[prevIdx[\\'G\\']] + glassCount;\\n                prevIdx[\\'G\\'] = idx;    \\n            }\\n            \\n\\t\\t\\t// If paper type is present in current house, then only pick else skip\\n            if(paperCount) {\\n\\t\\t\\t\\t// Sum of travel time from previous house to current\\n\\t\\t\\t\\t// And time to pick all paper type garbage\\n                totalTime += prefixSum[idx] - prefixSum[prevIdx[\\'P\\']] + paperCount;\\n                prevIdx[\\'P\\'] = idx;\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        \\n        return totalTime;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* **TIme :** `O(N)`, to travel over all houses and pick garbage\\n* **Space :** `O(N)`, to store prefix sum\\n\\n***If you find this helful, do give it a like :)***",
                "solutionTags": [
                    "Counting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = travel.size();\\n        vector<int> prefixSum(n+1, 0);\\n        \\n\\t\\t// Prefix sum of travel time from [0 to ith] house\\n        for(int i=0; i<n; i++) {\\n            prefixSum[i+1] = travel[i] + prefixSum[i];\\n        }\\n        \\n\\t\\t// To keep track of previous visited house of each type of garbage\\n        unordered_map<char, int> prevIdx;\\n        \\n        int idx = 0, totalTime = 0;\\n\\n        for(auto& house : garbage) {\\n            int metalCount = 0, glassCount = 0, paperCount = 0;\\n            \\n\\t\\t\\t// Count the number of garbage of each type\\n            for(auto& type : house) {\\n                if(type == \\'M\\') metalCount++;\\n                else if(type == \\'P\\') paperCount++;\\n                else if(type == \\'G\\') glassCount++;\\n            }\\n            \\n\\t\\t\\t// If metal type is present in current house, then only pick else skip\\n            if(metalCount) {\\n\\t\\t\\t\\t// Sum of travel time from previous house to current\\n\\t\\t\\t\\t// And time to pick all metal type garbage\\n                totalTime += prefixSum[idx] - prefixSum[prevIdx[\\'M\\']] + metalCount;\\n                prevIdx[\\'M\\'] = idx;\\n            }\\n            \\n\\t\\t\\t// If glass type is present in current house, then only pick else skip\\n            if(glassCount) {\\n\\t\\t\\t\\t// Sum of travel time from previous house to current\\n\\t\\t\\t\\t// And time to pick all glass type garbage\\n                totalTime += prefixSum[idx] - prefixSum[prevIdx[\\'G\\']] + glassCount;\\n                prevIdx[\\'G\\'] = idx;    \\n            }\\n            \\n\\t\\t\\t// If paper type is present in current house, then only pick else skip\\n            if(paperCount) {\\n\\t\\t\\t\\t// Sum of travel time from previous house to current\\n\\t\\t\\t\\t// And time to pick all paper type garbage\\n                totalTime += prefixSum[idx] - prefixSum[prevIdx[\\'P\\']] + paperCount;\\n                prevIdx[\\'P\\'] = idx;\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        \\n        return totalTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377582,
                "title": "c-easy-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int cnt=0,last_p=0,last_g=0,last_m=0;\\n        for(int i=0;i<garbage.size();i++){\\n            for(auto c:garbage[i]){\\n  // count the all character beacuse it must be take 1 minutes to collect it;\\n                 cnt++;\\n// find the last index of \\'p\\' ;\\n// so we move only upto that last character;\\n                if(c==\\'P\\') last_p=i;\\n// find the last index of \\'g\\' ;\\n// so we move only upto that last character;\\n                 else if(c==\\'G\\') last_g=i;\\n// find the last index of \\'m\\' ;\\n// so we move only upto that last character;\\n                 else last_m=i;\\n            }\\n        }\\n        for(int i=1;i<travel.size();i++){\\n// prefixsum of all element of travel (array);\\n           travel[i]+=travel[i-1];\\n        }\\n        int ans=cnt;\\n    // sum of minute to travel from one house(zero indexing house ) \\n// to last indexing of particular types of garbage; \\n        if(last_p>0) ans+=travel[last_p-1];\\n        if(last_g>0) ans+=travel[last_g-1];\\n        if(last_m>0) ans+=travel[last_m-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int cnt=0,last_p=0,last_g=0,last_m=0;\\n        for(int i=0;i<garbage.size();i++){\\n            for(auto c:garbage[i]){\\n  // count the all character beacuse it must be take 1 minutes to collect it;\\n                 cnt++;\\n// find the last index of \\'p\\' ;\\n// so we move only upto that last character;\\n                if(c==\\'P\\') last_p=i;\\n// find the last index of \\'g\\' ;\\n// so we move only upto that last character;\\n                 else if(c==\\'G\\') last_g=i;\\n// find the last index of \\'m\\' ;\\n// so we move only upto that last character;\\n                 else last_m=i;\\n            }\\n        }\\n        for(int i=1;i<travel.size();i++){\\n// prefixsum of all element of travel (array);\\n           travel[i]+=travel[i-1];\\n        }\\n        int ans=cnt;\\n    // sum of minute to travel from one house(zero indexing house ) \\n// to last indexing of particular types of garbage; \\n        if(last_p>0) ans+=travel[last_p-1];\\n        if(last_g>0) ans+=travel[last_g-1];\\n        if(last_m>0) ans+=travel[last_m-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108260,
                "title": "c-10-lines-most-optimized-o-n-o-1",
                "content": "# Intuition\\nWe start from last house, then check if this house has that grabage or not. If it has we pickup the garbage and calculate cost to travel to this house which had same garbage. and keep adding cost to travel now onwards to the first house.\\nOtherwise, we just go to next house.\\n\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:O(n) For traversing garbage array only once.\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        bool fg=false,fp=false,fm=false;\\n        int g=0,p=0,m=0;\\n        for(int i=garbage.size()-1;i>=0;i--)\\n        {\\n            for(char c:garbage[i])\\n            {\\n                if(c==\\'G\\'){g++; fg=true;}\\n                else if(c==\\'P\\'){ p++;fp=true;}\\n                else if(c==\\'M\\') {m++; fm=true;}\\n            }\\n            if (i!=0 && fg==true)g+=travel[i-1];\\n            if (i!=0 && fp==true)p+=travel[i-1];\\n            if (i!=0 && fm==true)m+=travel[i-1];\\n        }\\n        return g+m+p;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        bool fg=false,fp=false,fm=false;\\n        int g=0,p=0,m=0;\\n        for(int i=garbage.size()-1;i>=0;i--)\\n        {\\n            for(char c:garbage[i])\\n            {\\n                if(c==\\'G\\'){g++; fg=true;}",
                "codeTag": "Java"
            },
            {
                "id": 2771750,
                "title": "python-well-explained-simple-solution",
                "content": "1. As mentioned in the hint we fist calculate the maximum index for each catagory where at least 1 unit of garbage of that type is present. \\n\\n2. Here IN takes O(1) because the categopries are constant\\nthen we take the sum of the travel array unilt that index for each category and then add it into our result.\\n\\n3. we will also add the length of every element in the garbage to the result as it take 1 unit of time to \\ncollect it. \\n\\n4. If the any category is only present at the 0th index or doest exist in our garbage list at all we dont need to add the sum of tavel array as the garbage truk wont need any time to travel\\n\\n***Leve an upvote if this helps!!!***\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        l,m,p,g,res=0,0,0,0,0\\n        for i in range(len(garbage)):\\n            if \\'M\\' in garbage[i] and m<i:\\n                m=i\\n            if \\'P\\' in garbage[i] and p<i:\\n                p=i\\n            if \\'G\\' in garbage[i] and g<i:\\n                g=i\\n            l+=len(garbage[i])\\n        if m!=0:\\n            res=sum(travel[:m])\\n        if p!=0:\\n            res+=sum(travel[:p])\\n        if g!=0:\\n            res+=sum(travel[:g])\\n        return res+l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        l,m,p,g,res=0,0,0,0,0\\n        for i in range(len(garbage)):\\n            if \\'M\\' in garbage[i] and m<i:\\n                m=i\\n            if \\'P\\' in garbage[i] and p<i:\\n                p=i\\n            if \\'G\\' in garbage[i] and g<i:\\n                g=i\\n            l+=len(garbage[i])\\n        if m!=0:\\n            res=sum(travel[:m])\\n        if p!=0:\\n            res+=sum(travel[:p])\\n        if g!=0:\\n            res+=sum(travel[:g])\\n        return res+l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498990,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        int n = garbage.size();\\n        \\n        // find the last position of each type of garbage\\n        \\n        int g_end = -1;\\n        \\n        int p_end = -1;\\n        \\n        int m_end = -1;\\n        \\n        // garbage count will store the no. of garbages\\n        \\n        int garbage_count = 0;\\n       \\n        for(int i = 0; i < n; i++)\\n        {\\n            string str = garbage[i];\\n            \\n            // update the garbage count\\n            \\n            garbage_count += str.size();\\n            \\n            // update the position of each type of garbage\\n            \\n            for(auto x : str)\\n            {\\n                if(x == \\'G\\')\\n                {\\n                    g_end = i;\\n                }\\n                else if(x == \\'P\\')\\n                {\\n                    p_end = i;\\n                }\\n                else if(x == \\'M\\')\\n                {\\n                    m_end = i;\\n                }  \\n            }\\n        }\\n        \\n        // find prefix sum for travel array\\n        \\n        for(int i = 1; i < n - 1; i++)\\n        {\\n            travel[i] += travel[i - 1];\\n        }\\n        \\n        // find the travel time\\n        \\n        int travel_time = 0;\\n        \\n        if(g_end > 0)\\n        {\\n            travel_time += travel[g_end - 1];\\n        }\\n        \\n        if(p_end > 0)\\n        {\\n            travel_time += travel[p_end - 1];\\n        }\\n        \\n        if(m_end > 0)\\n        {\\n            travel_time += travel[m_end - 1];\\n        }\\n        \\n        // time to collect the garbage will be equal to garbage_count\\n        \\n        // picking up a garbage will take 1 unit of time\\n        \\n        // return total_time\\n        \\n        return travel_time + garbage_count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        int n = garbage.size();\\n        \\n        // find the last position of each type of garbage\\n        \\n        int g_end = -1;\\n        \\n        int p_end = -1;\\n        \\n        int m_end = -1;\\n        \\n        // garbage count will store the no. of garbages\\n        \\n        int garbage_count = 0;\\n       \\n        for(int i = 0; i < n; i++)\\n        {\\n            string str = garbage[i];\\n            \\n            // update the garbage count\\n            \\n            garbage_count += str.size();\\n            \\n            // update the position of each type of garbage\\n            \\n            for(auto x : str)\\n            {\\n                if(x == \\'G\\')\\n                {\\n                    g_end = i;\\n                }\\n                else if(x == \\'P\\')\\n                {\\n                    p_end = i;\\n                }\\n                else if(x == \\'M\\')\\n                {\\n                    m_end = i;\\n                }  \\n            }\\n        }\\n        \\n        // find prefix sum for travel array\\n        \\n        for(int i = 1; i < n - 1; i++)\\n        {\\n            travel[i] += travel[i - 1];\\n        }\\n        \\n        // find the travel time\\n        \\n        int travel_time = 0;\\n        \\n        if(g_end > 0)\\n        {\\n            travel_time += travel[g_end - 1];\\n        }\\n        \\n        if(p_end > 0)\\n        {\\n            travel_time += travel[p_end - 1];\\n        }\\n        \\n        if(m_end > 0)\\n        {\\n            travel_time += travel[m_end - 1];\\n        }\\n        \\n        // time to collect the garbage will be equal to garbage_count\\n        \\n        // picking up a garbage will take 1 unit of time\\n        \\n        // return total_time\\n        \\n        return travel_time + garbage_count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495201,
                "title": "easy-c-code-beats-100-submission-o-1-space-prefix-sum",
                "content": "```\\nint garbageCollection(vector<string>&v, vector<int>& t) {\\n        int i,n=v.size(),m=-1,g=-1,p=-1,ans=0;\\n        for(i=n-1;i>=0;i--){\\n            for(char c : v[i]){\\n                // storing the last index of each char \\'P\\',\\'M\\',\\'G\\';\\n                if(c==\\'P\\' && p==-1)p=i;\\n                if(c==\\'G\\' && g==-1)g=i;\\n                if(c==\\'M\\' && m==-1)m=i;\\n                ans++; // incrementing ans by 1 bcoz every garbage needs 1 min to be collected; \\n            }\\n        }\\n        for(i=1;i<n-1;i++){\\n            t[i]+=t[i-1]; // prefix sum;\\n        }\\n        if(p>0)ans+=t[p-1]; \\n        // truck collecting garbage \\'P\\' needs to travel till the house number p , so add the time taken to reach that house and do the same thing for other two trucks;\\n        if(g>0)ans+=t[g-1];\\n        if(m>0)ans+=t[m-1];\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint garbageCollection(vector<string>&v, vector<int>& t) {\\n        int i,n=v.size(),m=-1,g=-1,p=-1,ans=0;\\n        for(i=n-1;i>=0;i--){\\n            for(char c : v[i]){\\n                // storing the last index of each char \\'P\\',\\'M\\',\\'G\\';\\n                if(c==\\'P\\' && p==-1)p=i;\\n                if(c==\\'G\\' && g==-1)g=i;\\n                if(c==\\'M\\' && m==-1)m=i;\\n                ans++; // incrementing ans by 1 bcoz every garbage needs 1 min to be collected; \\n            }\\n        }\\n        for(i=1;i<n-1;i++){\\n            t[i]+=t[i-1]; // prefix sum;\\n        }\\n        if(p>0)ans+=t[p-1]; \\n        // truck collecting garbage \\'P\\' needs to travel till the house number p , so add the time taken to reach that house and do the same thing for other two trucks;\\n        if(g>0)ans+=t[g-1];\\n        if(m>0)ans+=t[m-1];\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2493217,
                "title": "java-easy-solution-using-map",
                "content": "# Java Easy Solution using HashMap\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int ans=0;\\n        //Creating a map to store type of garbage and where it is found\\n        HashMap<Character,List<Integer>> map=new HashMap<Character,List<Integer>>();\\n        char[] var=new char[3];\\n        var[0]=\\'M\\';\\n        var[1]=\\'P\\';\\n        var[2]=\\'G\\';\\n        //Creating an empty arraylist for each type of garbage\\n        for(int i=0;i<var.length;i++){\\n            List<Integer> list=new ArrayList<Integer>();\\n            map.put(var[i],list);\\n        }\\n        \\n        //Itertaing over each position and updating the map\\n        for(int i=0;i<garbage.length;i++){\\n            for(int j=0;j<garbage[i].length();j++){\\n                if(map.containsKey(garbage[i].charAt(j))){\\n                    List<Integer> a=map.get(garbage[i].charAt(j));\\n                    a.add(i);\\n                }\\n                else{\\n                    List<Integer> a=new ArrayList<Integer>();\\n                    a.add(i);\\n                    map.put(garbage[i].charAt(j),a);\\n                }\\n            }\\n        }\\n        \\n        //Iterating over each type of metal\\n        for(int i=0;i<var.length;i++){\\n            //Accesing the list of postiions for that garbage\\n            List<Integer> list=map.get(var[i]);\\n            int j=0;\\n            //Total minutes require for a particular type of garbage is tore in ans1\\n            int ans1=0;\\n            int pos=0;\\n            //Iterating over list\\n            while(j<list.size()){\\n                //If different postion so adding the travel time to ans1\\n                if(list.get(j)!=pos){\\n                    for(int k=pos;k<list.get(j);k++){\\n                        ans1+=travel[k];\\n                    }\\n                    ans1++;\\n                    pos=list.get(j);\\n                }\\n                //Adding the garbage collection time to ans\\n                else{\\n                    ans1++;\\n                }\\n                ++j;\\n            }\\n            //Adding ans to ans1\\n            ans+=ans1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int ans=0;\\n        //Creating a map to store type of garbage and where it is found\\n        HashMap<Character,List<Integer>> map=new HashMap<Character,List<Integer>>();\\n        char[] var=new char[3];\\n        var[0]=\\'M\\';\\n        var[1]=\\'P\\';\\n        var[2]=\\'G\\';\\n        //Creating an empty arraylist for each type of garbage\\n        for(int i=0;i<var.length;i++){\\n            List<Integer> list=new ArrayList<Integer>();\\n            map.put(var[i],list);\\n        }\\n        \\n        //Itertaing over each position and updating the map\\n        for(int i=0;i<garbage.length;i++){\\n            for(int j=0;j<garbage[i].length();j++){\\n                if(map.containsKey(garbage[i].charAt(j))){\\n                    List<Integer> a=map.get(garbage[i].charAt(j));\\n                    a.add(i);\\n                }\\n                else{\\n                    List<Integer> a=new ArrayList<Integer>();\\n                    a.add(i);\\n                    map.put(garbage[i].charAt(j),a);\\n                }\\n            }\\n        }\\n        \\n        //Iterating over each type of metal\\n        for(int i=0;i<var.length;i++){\\n            //Accesing the list of postiions for that garbage\\n            List<Integer> list=map.get(var[i]);\\n            int j=0;\\n            //Total minutes require for a particular type of garbage is tore in ans1\\n            int ans1=0;\\n            int pos=0;\\n            //Iterating over list\\n            while(j<list.size()){\\n                //If different postion so adding the travel time to ans1\\n                if(list.get(j)!=pos){\\n                    for(int k=pos;k<list.get(j);k++){\\n                        ans1+=travel[k];\\n                    }\\n                    ans1++;\\n                    pos=list.get(j);\\n                }\\n                //Adding the garbage collection time to ans\\n                else{\\n                    ans1++;\\n                }\\n                ++j;\\n            }\\n            //Adding ans to ans1\\n            ans+=ans1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493213,
                "title": "c-using-hashmap-beginner-friendly-east-to-understand-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTime(vector<string>& garbage, vector<int>& travel, char type, unordered_map<char, int> &mpp){\\n        int minute = 0;\\n        \\n        //every house\\n        for(int i=0; i<garbage.size(); i++){\\n            if(mpp[type]>0){    //if that type of garbage remains to collect\\n                \\n                //garbage at a particular house\\n                for(int j=0; j<garbage[i].size(); j++){\\n                    if(garbage[i][j]== type){\\n                        minute++;\\n                        mpp[type]--;\\n                    }\\n                }\\n                \\n                //add travelling cost if same type of garbage yet to collect\\n                if(mpp[type]>0)\\n                    minute += travel[i];\\n            }    \\n        }\\n        \\n        return minute;\\n    }\\n    \\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //to track whether all the garbage collected of same type\\n        unordered_map<char, int> mpp;\\n        for(auto it: garbage){\\n            for(auto jt: it)\\n                mpp[jt]++;\\n        }\\n        \\n        vector<char> type = {\\'P\\', \\'G\\', \\'M\\'};    //paper, glass, metal\\n        int minutes = 0;\\n        for(int i=0; i<type.size(); i++){\\n            minutes += findTime(garbage, travel, type[i], mpp);\\n        }\\n        \\n        return minutes;\\n    }\\n};\\n```\\n\\nPlease do upvote if you like the soln:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTime(vector<string>& garbage, vector<int>& travel, char type, unordered_map<char, int> &mpp){\\n        int minute = 0;\\n        \\n        //every house\\n        for(int i=0; i<garbage.size(); i++){\\n            if(mpp[type]>0){    //if that type of garbage remains to collect\\n                \\n                //garbage at a particular house\\n                for(int j=0; j<garbage[i].size(); j++){\\n                    if(garbage[i][j]== type){\\n                        minute++;\\n                        mpp[type]--;\\n                    }\\n                }\\n                \\n                //add travelling cost if same type of garbage yet to collect\\n                if(mpp[type]>0)\\n                    minute += travel[i];\\n            }    \\n        }\\n        \\n        return minute;\\n    }\\n    \\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //to track whether all the garbage collected of same type\\n        unordered_map<char, int> mpp;\\n        for(auto it: garbage){\\n            for(auto jt: it)\\n                mpp[jt]++;\\n        }\\n        \\n        vector<char> type = {\\'P\\', \\'G\\', \\'M\\'};    //paper, glass, metal\\n        int minutes = 0;\\n        for(int i=0; i<type.size(); i++){\\n            minutes += findTime(garbage, travel, type[i], mpp);\\n        }\\n        \\n        return minutes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493180,
                "title": "python-explained",
                "content": "Just keep track of last occuarnce of each garbage type.\\nSince we know the number of types we can set a multiplier from start.\\nAnd since each of garbage takes same amount of time and each truck takes same amount of time to travel we can just append our solution and just decrease multiplier if last occurance of garbage is achieved.\\n\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        last=[\"\",\"\",\"\"]\\n        for v,i in enumerate(garbage):\\n            if \\'M\\' in i:\\n                last[0]=v\\n            if \\'P\\' in i:\\n                last[1]=v\\n            if \\'G\\' in i:\\n                last[2]=v\\n        while \\'\\' in last:\\n            last.remove(\\'\\')        \\n        t=len(last)\\n        sol=len(garbage[0])\\n        t-=last.count(0)\\n        for i in range(1,len(garbage)):\\n            sol+=len(garbage[i])\\n            sol+=(t*travel[i-1])\\n            t-=last.count(i)\\n        return sol\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        last=[\"\",\"\",\"\"]\\n        for v,i in enumerate(garbage):\\n            if \\'M\\' in i:\\n                last[0]=v\\n            if \\'P\\' in i:\\n                last[1]=v\\n            if \\'G\\' in i:\\n                last[2]=v\\n        while \\'\\' in last:\\n            last.remove(\\'\\')        \\n        t=len(last)\\n        sol=len(garbage[0])\\n        t-=last.count(0)\\n        for i in range(1,len(garbage)):\\n            sol+=len(garbage[i])\\n            sol+=(t*travel[i-1])\\n            t-=last.count(i)\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493177,
                "title": "c-brute-force-full-explain-prefix-sum-map-easy-and-readable",
                "content": "Please  UPVOTE if you like it and thanks\\n**The idea is to traverse from right and calculate total time for three of trucks :**\\nBut How : \\ntimem : total time for M garbage\\ntimem = last occurence of M + no. of M;\\nBut why last occurence : becz M\\'s truck have to wait for last M garbage using prefix sum of total time array\\nand why no. of M : becz how much time to collect = 1* no. of M (1 min-> time to collect one M)\\n**Simlarly calc for G and P**\\nif calculated particular garbage then not looking for that garbage \\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& t) \\n    {\\n        unordered_map<char,int> m;\\n        for(auto e:garbage)\\n        {\\n            for(auto f:e)\\n            {\\n                m[f]++;\\n            }\\n        }\\n        \\n        int timem=0,timeg=0,timep=0;\\n        int n=garbage.size();\\n        vector<int> pre(t.size(),0);\\n        \\n        pre[0]=t[0];\\n        for(int i=1;i<t.size();i++)\\n        {\\n            pre[i]=pre[i-1]+t[i];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=garbage[i].size()-1;j>=0;j--)\\n            {\\n                if(garbage[i][j]==\\'P\\' && timep==0)\\n                {\\n                    if(i-1<0)\\n                    {\\n                        timep=m[garbage[i][j]];\\n                    }\\n                    else\\n                    {\\n                        timep=pre[i-1]+m[garbage[i][j]];\\n                    }\\n                    \\n                }\\n                else if(garbage[i][j]==\\'G\\' && timeg==0)\\n                {\\n                    if(i-1<0)\\n                    {\\n                        timeg=m[garbage[i][j]];\\n                    }\\n                    else\\n                    {\\n                        timeg=pre[i-1]+m[garbage[i][j]];\\n                    }\\n                }\\n                else if(garbage[i][j]==\\'M\\' && timem==0)\\n                {\\n                    if(i-1<0)\\n                    {\\n                        timem=m[garbage[i][j]];\\n                    }\\n                    else\\n                    {\\n                        timem=pre[i-1]+m[garbage[i][j]];\\n                    }\\n                }\\n            }\\n        }\\n        return timep+timem+timeg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& t) \\n    {\\n        unordered_map<char,int> m;\\n        for(auto e:garbage)\\n        {\\n            for(auto f:e)\\n            {\\n                m[f]++;\\n            }\\n        }\\n        \\n        int timem=0,timeg=0,timep=0;\\n        int n=garbage.size();\\n        vector<int> pre(t.size(),0);\\n        \\n        pre[0]=t[0];\\n        for(int i=1;i<t.size();i++)\\n        {\\n            pre[i]=pre[i-1]+t[i];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=garbage[i].size()-1;j>=0;j--)\\n            {\\n                if(garbage[i][j]==\\'P\\' && timep==0)\\n                {\\n                    if(i-1<0)\\n                    {\\n                        timep=m[garbage[i][j]];\\n                    }\\n                    else\\n                    {\\n                        timep=pre[i-1]+m[garbage[i][j]];\\n                    }\\n                    \\n                }\\n                else if(garbage[i][j]==\\'G\\' && timeg==0)\\n                {\\n                    if(i-1<0)\\n                    {\\n                        timeg=m[garbage[i][j]];\\n                    }\\n                    else\\n                    {\\n                        timeg=pre[i-1]+m[garbage[i][j]];\\n                    }\\n                }\\n                else if(garbage[i][j]==\\'M\\' && timem==0)\\n                {\\n                    if(i-1<0)\\n                    {\\n                        timem=m[garbage[i][j]];\\n                    }\\n                    else\\n                    {\\n                        timem=pre[i-1]+m[garbage[i][j]];\\n                    }\\n                }\\n            }\\n        }\\n        return timep+timem+timeg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492828,
                "title": "cpp-easy-prefix-sum",
                "content": "**Intuition :** Just a simple greedy problem my approach was bit different though.\\nI calculated `prefix sum` of `travel`.\\nAnd simply I keep adding number of particular garbages occurs for any type in my answer\\nand after that I started from back and kept looking which which garbage is occuring where for the first time .\\n\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& g, vector<int>& t) {\\n        int n=g.size(),ans=0;\\n        for(int i=1;i<t.size();i++)t[i]+=t[i-1];\\n        for(string &s:g){\\n            ans+=(int)s.length();\\n        }\\n        bool taken[3]={false,false,false};\\n        for(int i=n-1;i>0;i--){\\n            bool flag[3]={false,false,false};\\n            for(char c:g[i]){\\n                if(c==\\'M\\')flag[0]=true;\\n                else if(c==\\'P\\')flag[1]=true;\\n                else flag[2]=true;\\n            }\\n            for(int j=0;j<3;j++){\\n                if(flag[j] && !taken[j])ans+=t[i-1],taken[j]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& g, vector<int>& t) {\\n        int n=g.size(),ans=0;\\n        for(int i=1;i<t.size();i++)t[i]+=t[i-1];\\n        for(string &s:g){\\n            ans+=(int)s.length();\\n        }\\n        bool taken[3]={false,false,false};\\n        for(int i=n-1;i>0;i--){\\n            bool flag[3]={false,false,false};\\n            for(char c:g[i]){\\n                if(c==\\'M\\')flag[0]=true;\\n                else if(c==\\'P\\')flag[1]=true;\\n                else flag[2]=true;\\n            }\\n            for(int j=0;j<3;j++){\\n                if(flag[j] && !taken[j])ans+=t[i-1],taken[j]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492802,
                "title": "python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/ea6bc01b091cbf032b9c7ac2d3c09cb4f5cd0d2d) for solutions of weekly 308.\\n\\n**Intuition**\\nThe total time can be decomposed into 1) time to collect gargage and 2) time to travel to next stop. \\nHere, the first component is simply the sum of length of strings in `garbage`. The second component depends on the last stop for each garbage type. For convenience, I use prefix sum to compute them. \\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`\\n\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        ans = sum(map(len, garbage))\\n        prefix = list(accumulate(travel, initial=0))\\n        for ch in \"MPG\": \\n            ii = 0 \\n            for i, s in enumerate(garbage): \\n                if ch in s: ii = i \\n            ans += prefix[ii]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        ans = sum(map(len, garbage))\\n        prefix = list(accumulate(travel, initial=0))\\n        for ch in \"MPG\": \\n            ii = 0 \\n            for i, s in enumerate(garbage): \\n                if ch in s: ii = i \\n            ans += prefix[ii]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018015,
                "title": "c-cpp-simple-logic",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n       \\n        int n=garbage.size();\\n\\n        int p=0;\\n        int m=0;\\n        int g=0;\\n\\n        int p_travel_cost=0;\\n        int m_travel_cost=0;\\n        int g_travel_cost=0;\\n\\n        int temp=0;\\n        int temp1=0;\\n        int temp2=0;\\n\\n        for(int i=0;i<n;i++) \\n        {\\n\\n\\n             for(auto it:garbage[i])\\n            {\\n                if(it == \\'P\\' )\\n                { \\n                   p++;\\n                   temp=i;\\n\\n                }\\n                 if(it == \\'G\\' )\\n                { \\n                   g++;\\n                   temp1=i;\\n                }\\n                 if(it == \\'M\\' )\\n                { \\n                   m++;\\n                   temp2=i;\\n                }\\n            }\\n\\n\\n\\n\\n        }\\n        \\n       \\n    \\n      for(int l=0;l<temp;l++){\\n          p_travel_cost += travel[l];\\n      }\\n\\n     \\n      for(int l=0;l<temp1;l++){\\n          m_travel_cost += travel[l];\\n      }\\n\\n        \\n     \\n      for(int l=0;l<temp2;l++){\\n          g_travel_cost += travel[l];\\n      }\\n\\n      \\n\\n        return (p+p_travel_cost)+(m+m_travel_cost)+(g+g_travel_cost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n       \\n        int n=garbage.size();\\n\\n        int p=0;\\n        int m=0;\\n        int g=0;\\n\\n        int p_travel_cost=0;\\n        int m_travel_cost=0;\\n        int g_travel_cost=0;\\n\\n        int temp=0;\\n        int temp1=0;\\n        int temp2=0;\\n\\n        for(int i=0;i<n;i++) \\n        {\\n\\n\\n             for(auto it:garbage[i])\\n            {\\n                if(it == \\'P\\' )\\n                { \\n                   p++;\\n                   temp=i;\\n\\n                }\\n                 if(it == \\'G\\' )\\n                { \\n                   g++;\\n                   temp1=i;\\n                }\\n                 if(it == \\'M\\' )\\n                { \\n                   m++;\\n                   temp2=i;\\n                }\\n            }\\n\\n\\n\\n\\n        }\\n        \\n       \\n    \\n      for(int l=0;l<temp;l++){\\n          p_travel_cost += travel[l];\\n      }\\n\\n     \\n      for(int l=0;l<temp1;l++){\\n          m_travel_cost += travel[l];\\n      }\\n\\n        \\n     \\n      for(int l=0;l<temp2;l++){\\n          g_travel_cost += travel[l];\\n      }\\n\\n      \\n\\n        return (p+p_travel_cost)+(m+m_travel_cost)+(g+g_travel_cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660324,
                "title": "python-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code is implementing a garbage collection algorithm that calculates the total distance traveled by a garbage truck based on the type of garbage collected at each house and the travel distances between consecutive houses. The types of garbage are \\'G\\', \\'P\\', and \\'M\\', representing different categories of waste. The algorithm calculates the distance traveled for each type of garbage and returns the sum of these distances.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a function fn(Type) that takes a parameter Type representing the type of garbage. This function iterates over the garbage list, which contains the type of garbage at each house. For each house, it counts the number of times the specified Type occurs in the garbage string.\\n\\nIf the count is not zero (indicating that the current house has the specified Type of garbage), it calculates the distance traveled by summing the values in the travel list from the current position (curr) to the current house (number). It adds this distance to the total variable. Then, it updates curr to the current house and adds the count of the Type to the total variable.\\n\\nFinally, the algorithm calls fn for each type of garbage (\\'G\\', \\'P\\', and \\'M\\'), and sums the returned distances to obtain the total distance traveled by the garbage truck.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: The algorithm iterates over the garbage list once and performs string counting operations for each house. The sum of the distances in the travel list is calculated for each house with non-zero count. Therefore, the overall time complexity is O(n), where n is the length of the garbage list\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: The algorithm uses a constant amount of extra space, regardless of the input size. Hence, the space complexity is O(1).\\n# Code\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        def fn(Type):\\n            total=0\\n            curr=0\\n            for number,house in enumerate(garbage):\\n                times=house.count(Type)\\n                if times!=0:\\n                    distance=sum(travel[curr:number])\\n                    total+=distance\\n                    curr=number\\n                    total+=times\\n            return total\\n        ans=fn(\\'G\\')+fn(\\'P\\')+fn(\\'M\\')\\n        return ans\\n                        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        def fn(Type):\\n            total=0\\n            curr=0\\n            for number,house in enumerate(garbage):\\n                times=house.count(Type)\\n                if times!=0:\\n                    distance=sum(travel[curr:number])\\n                    total+=distance\\n                    curr=number\\n                    total+=times\\n            return total\\n        ans=fn(\\'G\\')+fn(\\'P\\')+fn(\\'M\\')\\n        return ans\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459795,
                "title": "easy-java-solution-beats-97-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int ans = 0;\\n        \\n        int g = 0, m = 0, p = 0;\\n\\n        for(int i = garbage.length-1;i >= 0;i--){\\n            if(garbage[i].contains(\"G\")){\\n                g = i;\\n                break;\\n            }\\n        }\\n        for(int i = garbage.length-1;i >= 0;i--){\\n            if(garbage[i].contains(\"P\")){\\n                p = i;\\n                break;\\n            }\\n        }\\n        for(int i = garbage.length-1;i >= 0;i--){\\n            if(garbage[i].contains(\"M\")){\\n                m = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = 0;i < garbage.length;i++){\\n            ans += garbage[i].length();\\n        }\\n\\n        for(int i = 1;i < travel.length;i++){\\n            travel[i] += travel[i-1];\\n        }\\n\\n        if(p != 0){\\n            ans += travel[p-1];\\n        }\\n        if(g != 0){\\n            ans += travel[g-1];\\n        }\\n        if(m != 0){\\n            ans += travel[m-1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int ans = 0;\\n        \\n        int g = 0, m = 0, p = 0;\\n\\n        for(int i = garbage.length-1;i >= 0;i--){\\n            if(garbage[i].contains(\"G\")){\\n                g = i;\\n                break;\\n            }\\n        }\\n        for(int i = garbage.length-1;i >= 0;i--){\\n            if(garbage[i].contains(\"P\")){\\n                p = i;\\n                break;\\n            }\\n        }\\n        for(int i = garbage.length-1;i >= 0;i--){\\n            if(garbage[i].contains(\"M\")){\\n                m = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = 0;i < garbage.length;i++){\\n            ans += garbage[i].length();\\n        }\\n\\n        for(int i = 1;i < travel.length;i++){\\n            travel[i] += travel[i-1];\\n        }\\n\\n        if(p != 0){\\n            ans += travel[p-1];\\n        }\\n        if(g != 0){\\n            ans += travel[g-1];\\n        }\\n        if(m != 0){\\n            ans += travel[m-1];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232649,
                "title": "java-solution-in-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        return fun(garbage,\\'M\\',travel) + fun(garbage,\\'P\\',travel) + fun(garbage,\\'G\\',travel);\\n    }\\n\\n    public int fun(String[] garbage, char c,int[] travel){\\n        int m = 0;\\n        int step = 0;\\n        int x = 0;\\n        for(int i = 0; i < garbage.length; i++){\\n            if(i !=0 ){\\n                step += travel[i-1];\\n            }\\n            for(int j = 0; j < garbage[i].length(); j++){\\n                if(garbage[i].charAt(j) == c){\\n                    m += step+1;\\n                    step = 0;\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        return fun(garbage,\\'M\\',travel) + fun(garbage,\\'P\\',travel) + fun(garbage,\\'G\\',travel);\\n    }\\n\\n    public int fun(String[] garbage, char c,int[] travel){\\n        int m = 0;\\n        int step = 0;\\n        int x = 0;\\n        for(int i = 0; i < garbage.length; i++){\\n            if(i !=0 ){\\n                step += travel[i-1];\\n            }\\n            for(int j = 0; j < garbage[i].length(); j++){\\n                if(garbage[i].charAt(j) == c){\\n                    m += step+1;\\n                    step = 0;\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030756,
                "title": "c-o-n-m-solution-constant-space",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& gar, vector<int>& travel) {\\n        int sum = 0;\\n        bool gbool = false, pbool = false, mbool = false;\\n        for(auto i : gar) {\\n            sum += i.size();\\n        }\\n        int g = -1, m = -1, p = -1;\\n        for(int i=gar.size()-1;i>=0;i--) {\\n            for(int j=0;j<gar[i].size();j++) {\\n                if(gar[i][j] == \\'G\\' && !gbool) {\\n                    g = i - 1;\\n                    gbool = true;\\n                }\\n                else if(gar[i][j] == \\'P\\' && !pbool) {\\n                    p = i - 1;\\n                    pbool = true;\\n                }\\n                else if(gar[i][j] == \\'M\\' && !mbool) {\\n                    m = i - 1;\\n                    mbool = true;\\n                }\\n            }\\n            if(gbool && pbool && mbool) break;\\n        }\\n        for(int i=0;i<=g;i++) {\\n            sum += travel[i];\\n        }\\n        for(int i=0;i<=p;i++) {\\n            sum += travel[i];\\n        }\\n        for(int i=0;i<=m;i++) {\\n            sum += travel[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& gar, vector<int>& travel) {\\n        int sum = 0;\\n        bool gbool = false, pbool = false, mbool = false;\\n        for(auto i : gar) {\\n            sum += i.size();\\n        }\\n        int g = -1, m = -1, p = -1;\\n        for(int i=gar.size()-1;i>=0;i--) {\\n            for(int j=0;j<gar[i].size();j++) {\\n                if(gar[i][j] == \\'G\\' && !gbool) {\\n                    g = i - 1;\\n                    gbool = true;\\n                }\\n                else if(gar[i][j] == \\'P\\' && !pbool) {\\n                    p = i - 1;\\n                    pbool = true;\\n                }\\n                else if(gar[i][j] == \\'M\\' && !mbool) {\\n                    m = i - 1;\\n                    mbool = true;\\n                }\\n            }\\n            if(gbool && pbool && mbool) break;\\n        }\\n        for(int i=0;i<=g;i++) {\\n            sum += travel[i];\\n        }\\n        for(int i=0;i<=p;i++) {\\n            sum += travel[i];\\n        }\\n        for(int i=0;i<=m;i++) {\\n            sum += travel[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001864,
                "title": "short-clean-hashmap-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        Map<String,Integer> map = new HashMap();\\n        for(int i=1; i<travel.length; i++)  travel[i] += travel[i-1];\\n        for(int i=1; i<garbage.length; i++){\\n            if(garbage[i].contains(\"M\"))    map.put(\"M\", travel[i-1]);\\n            if(garbage[i].contains(\"P\"))    map.put(\"P\", travel[i-1]);\\n            if(garbage[i].contains(\"G\"))    map.put(\"G\", travel[i-1]);\\n        }\\n        String s = String.join(\"\",garbage);\\n        for(char c: s.toCharArray())    map.put(c+\"\",map.getOrDefault(c+\"\",0)+1);\\n        int mnts = 0;\\n        for(int val: map.values())  mnts += val;\\n        return mnts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        Map<String,Integer> map = new HashMap();\\n        for(int i=1; i<travel.length; i++)  travel[i] += travel[i-1];\\n        for(int i=1; i<garbage.length; i++){\\n            if(garbage[i].contains(\"M\"))    map.put(\"M\", travel[i-1]);\\n            if(garbage[i].contains(\"P\"))    map.put(\"P\", travel[i-1]);\\n            if(garbage[i].contains(\"G\"))    map.put(\"G\", travel[i-1]);\\n        }\\n        String s = String.join(\"\",garbage);\\n        for(char c: s.toCharArray())    map.put(c+\"\",map.getOrDefault(c+\"\",0)+1);\\n        int mnts = 0;\\n        for(int val: map.values())  mnts += val;\\n        return mnts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948575,
                "title": "simple-java-solution-faster-than-97",
                "content": "\\n```\\nclass Solution {\\n    public int garbageCollection(String[] g, int[] travel) {\\n          int ans = getTimeForGarbage(g,travel,\\'M\\')+getTimeForGarbage(g,travel,\\'G\\')+getTimeForGarbage(g,travel,\\'P\\');\\n          return ans;    \\n\\n    }\\n        private static int getTimeForGarbage(String[] g, int[] travel, Character gType){\\n            int n = g.length;\\n            int lastHouseToVisit = -1;\\n            int totalTime = 0;\\n            for(int i =0;i<n;i++){\\n                if(g[i].indexOf(gType)!=-1){\\n                    lastHouseToVisit = i;\\n                }\\n            }\\n            if(lastHouseToVisit ==-1){\\n                return 0 ;\\n            }\\n            totalTime=0;\\n            for(int i =0;i<=lastHouseToVisit;i++){\\n                totalTime += getCount(g[i],gType);\\n                if(i-1>=0){\\n                    totalTime += travel[i-1];\\n                }\\n            }\\n            return totalTime;\\n        }\\n\\n        private static int getCount(String s, Character gType){\\n            int total = 0;\\n            for(int i=0;i<s.length(); i++){\\n                if(gType == s.charAt(i)){\\n                    total++;\\n                }\\n            }\\n            return total;\\n        }     \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] g, int[] travel) {\\n          int ans = getTimeForGarbage(g,travel,\\'M\\')+getTimeForGarbage(g,travel,\\'G\\')+getTimeForGarbage(g,travel,\\'P\\');\\n          return ans;    \\n\\n    }\\n        private static int getTimeForGarbage(String[] g, int[] travel, Character gType){\\n            int n = g.length;\\n            int lastHouseToVisit = -1;\\n            int totalTime = 0;\\n            for(int i =0;i<n;i++){\\n                if(g[i].indexOf(gType)!=-1){\\n                    lastHouseToVisit = i;\\n                }\\n            }\\n            if(lastHouseToVisit ==-1){\\n                return 0 ;\\n            }\\n            totalTime=0;\\n            for(int i =0;i<=lastHouseToVisit;i++){\\n                totalTime += getCount(g[i],gType);\\n                if(i-1>=0){\\n                    totalTime += travel[i-1];\\n                }\\n            }\\n            return totalTime;\\n        }\\n\\n        private static int getCount(String s, Character gType){\\n            int total = 0;\\n            for(int i=0;i<s.length(); i++){\\n                if(gType == s.charAt(i)){\\n                    total++;\\n                }\\n            }\\n            return total;\\n        }     \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495801,
                "title": "simulation",
                "content": "##### *Java*\\n```java\\npublic int garbageCollection(String[] garbage, int[] travel) {\\n        int totalTime = 0;\\n\\n        for (int house = 0, metal = 0, glass = 0, plastic = 0; house < garbage.length; ++house) {\\n            String currentHouse = garbage[house];\\n            if (currentHouse.contains(\"M\")) {\\n                totalTime += (travelTime(metal, house, travel) + garbageCollectionTime(currentHouse, \\'M\\'));\\n                metal = house;\\n            }\\n            if (currentHouse.contains(\"G\")) {\\n                totalTime += (travelTime(glass, house, travel) + garbageCollectionTime(currentHouse, \\'G\\'));\\n                glass = house;\\n            }\\n            if (currentHouse.contains(\"P\")) {\\n                totalTime += (travelTime(plastic, house, travel) + garbageCollectionTime(currentHouse, \\'P\\'));\\n                plastic = house;\\n            }\\n        }\\n\\n        return totalTime;\\n    }\\n\\n    private int travelTime(int start, int end, int[] travel) {\\n        int time = 0;\\n        for (int stop = start; stop < end; ++stop) \\n            time += travel[stop];\\n        \\n        return time;\\n    }\\n\\n\\n    private int garbageCollectionTime(String house, Character type) {\\n        return (int) house.chars().filter(c -> c == type).count();\\n    }\\n```\\n\\nC++\\n\\n```c++\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int totalTime = 0;\\n\\n        for (int house = 0, metal = 0, glass = 0, plastic = 0; house < garbage.size(); ++house) {\\n            string currentHouse = garbage[house];\\n            if (currentHouse.find(\\'M\\') != string::npos) {\\n                totalTime += (travelTime(metal, house, travel) + garbageCollectionTime(currentHouse, \\'M\\'));\\n                metal = house;\\n            }\\n            if (currentHouse.find(\\'G\\') != string::npos) {\\n                totalTime += (travelTime(glass, house, travel) + garbageCollectionTime(currentHouse, \\'G\\'));\\n                glass = house;\\n            }\\n            if (currentHouse.find(\\'P\\') != string::npos) {\\n                totalTime += (travelTime(plastic, house, travel) + garbageCollectionTime(currentHouse, \\'P\\'));\\n                plastic = house;\\n            }\\n        }\\n\\n        return totalTime;\\n    }\\n\\nprivate:\\n    int travelTime(int start, int end, vector<int>& travel) {\\n        int time = 0;\\n        for (int stop = start; stop < end; ++stop) \\n            time += travel[stop];\\n        \\n        return time;\\n    }\\n\\n\\nprivate:\\n    int garbageCollectionTime(string house, char type) {\\n        return count(house.begin(), house.end(), type);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int garbageCollection(String[] garbage, int[] travel) {\\n        int totalTime = 0;\\n\\n        for (int house = 0, metal = 0, glass = 0, plastic = 0; house < garbage.length; ++house) {\\n            String currentHouse = garbage[house];\\n            if (currentHouse.contains(\"M\")) {\\n                totalTime += (travelTime(metal, house, travel) + garbageCollectionTime(currentHouse, \\'M\\'));\\n                metal = house;\\n            }\\n            if (currentHouse.contains(\"G\")) {\\n                totalTime += (travelTime(glass, house, travel) + garbageCollectionTime(currentHouse, \\'G\\'));\\n                glass = house;\\n            }\\n            if (currentHouse.contains(\"P\")) {\\n                totalTime += (travelTime(plastic, house, travel) + garbageCollectionTime(currentHouse, \\'P\\'));\\n                plastic = house;\\n            }\\n        }\\n\\n        return totalTime;\\n    }\\n\\n    private int travelTime(int start, int end, int[] travel) {\\n        int time = 0;\\n        for (int stop = start; stop < end; ++stop) \\n            time += travel[stop];\\n        \\n        return time;\\n    }\\n\\n\\n    private int garbageCollectionTime(String house, Character type) {\\n        return (int) house.chars().filter(c -> c == type).count();\\n    }\\n```\n```c++\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int totalTime = 0;\\n\\n        for (int house = 0, metal = 0, glass = 0, plastic = 0; house < garbage.size(); ++house) {\\n            string currentHouse = garbage[house];\\n            if (currentHouse.find(\\'M\\') != string::npos) {\\n                totalTime += (travelTime(metal, house, travel) + garbageCollectionTime(currentHouse, \\'M\\'));\\n                metal = house;\\n            }\\n            if (currentHouse.find(\\'G\\') != string::npos) {\\n                totalTime += (travelTime(glass, house, travel) + garbageCollectionTime(currentHouse, \\'G\\'));\\n                glass = house;\\n            }\\n            if (currentHouse.find(\\'P\\') != string::npos) {\\n                totalTime += (travelTime(plastic, house, travel) + garbageCollectionTime(currentHouse, \\'P\\'));\\n                plastic = house;\\n            }\\n        }\\n\\n        return totalTime;\\n    }\\n\\nprivate:\\n    int travelTime(int start, int end, vector<int>& travel) {\\n        int time = 0;\\n        for (int stop = start; stop < end; ++stop) \\n            time += travel[stop];\\n        \\n        return time;\\n    }\\n\\n\\nprivate:\\n    int garbageCollectionTime(string house, char type) {\\n        return count(house.begin(), house.end(), type);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494700,
                "title": "o-1-memory-o-n-time",
                "content": "Only 1 garbage truck can move at a time. This directly tells us that this problem **IS NOT A DP** because we can calculate it with simulations/greedy.\\n\\nEvery truck must move one index at a time, stopping at the latest index that has it\\'s material type (paper, glass, etc). Because from that point onwards there is no point in incurring the cost of traveling, it won\\'t clean any more garbage.\\n\\nTo know the last index of every type, let\\'s find it and store it in a pointer.\\n\\nAt any point we must collect all the garbage, and trucks that didn\\'t find the latest material continue driving.\\n\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        last_paper_index = 0\\n        last_metal_index = 0\\n        last_glass_index = 0\\n        \\n        n = len(garbage)\\n        for i, s in enumerate(garbage):\\n            for c in s:\\n                if c == \\'M\\': last_metal_index = i\\n                if c == \\'P\\': last_paper_index = i\\n                if c == \\'G\\': last_glass_index = i\\n         \\n        S = 0\\n        for i in range(n):\\n            S += len(garbage[i])\\n            \\n            if i < last_paper_index: S += travel[i]\\n            if i < last_metal_index: S += travel[i]\\n            if i < last_glass_index: S += travel[i]\\n            \\n        return S\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        last_paper_index = 0\\n        last_metal_index = 0\\n        last_glass_index = 0\\n        \\n        n = len(garbage)\\n        for i, s in enumerate(garbage):\\n            for c in s:\\n                if c == \\'M\\': last_metal_index = i\\n                if c == \\'P\\': last_paper_index = i\\n                if c == \\'G\\': last_glass_index = i\\n         \\n        S = 0\\n        for i in range(n):\\n            S += len(garbage[i])\\n            \\n            if i < last_paper_index: S += travel[i]\\n            if i < last_metal_index: S += travel[i]\\n            if i < last_glass_index: S += travel[i]\\n            \\n        return S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494664,
                "title": "o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        // vector<char> t={\\'G\\',\\'P\\'};\\n        vector<pair<char,int>> t;\\n        t.push_back({\\'M\\',-1});\\n          t.push_back({\\'P\\',-1});\\n          t.push_back({\\'G\\',-1});\\n        int n=garbage.size();\\n        int ans=0;\\n    // int n=garbage.size();\\n        for(int i=n-1;i>=0;i--){\\n            int m=0;\\n            int p=0;\\n            int g=0;\\n            for(auto x:garbage[i]){\\n                if(x==\\'M\\') m++;\\n                else if(x==\\'G\\') g++;\\n                else p++;\\n            }\\n            \\n            if(m>0){\\n                t[0].second=max(t[0].second,i);\\n            }\\n            if(p>0){\\n                t[1].second=max(t[1].second,i);\\n            }\\n            if(g>0){\\n                t[2].second=max(t[2].second,i);\\n            }\\n        }\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<=t[i].second;j++){\\n                int c=0;\\n                for(char x:garbage[j]) {\\n                    if(x==t[i].first) c++;\\n                }\\n                // cout<<c<<\" j:\"<<j<<endl;\\n                if(j!=t[i].second){\\n                    \\n                    ans=ans +(c+travel[j]);\\n                    // cout<<ans<<\" j:\"<<j<<endl;\\n                }else{\\n                    ans+=c;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        // vector<char> t={\\'G\\',\\'P\\'};\\n        vector<pair<char,int>> t;\\n        t.push_back({\\'M\\',-1});\\n          t.push_back({\\'P\\',-1});\\n          t.push_back({\\'G\\',-1});\\n        int n=garbage.size();\\n        int ans=0;\\n    // int n=garbage.size();\\n        for(int i=n-1;i>=0;i--){\\n            int m=0;\\n            int p=0;\\n            int g=0;\\n            for(auto x:garbage[i]){\\n                if(x==\\'M\\') m++;\\n                else if(x==\\'G\\') g++;\\n                else p++;\\n            }\\n            \\n            if(m>0){\\n                t[0].second=max(t[0].second,i);\\n            }\\n            if(p>0){\\n                t[1].second=max(t[1].second,i);\\n            }\\n            if(g>0){\\n                t[2].second=max(t[2].second,i);\\n            }\\n        }\\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<=t[i].second;j++){\\n                int c=0;\\n                for(char x:garbage[j]) {\\n                    if(x==t[i].first) c++;\\n                }\\n                // cout<<c<<\" j:\"<<j<<endl;\\n                if(j!=t[i].second){\\n                    \\n                    ans=ans +(c+travel[j]);\\n                    // cout<<ans<<\" j:\"<<j<<endl;\\n                }else{\\n                    ans+=c;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2493848,
                "title": "swift-solution-brute-force-o-n",
                "content": "```\\nclass Solution {\\n    func garbageCollection(_ garbage: [String], _ travel: [Int]) -> Int {\\n        \"MGP\".map{ collectGarbage(garbage, travel + [0], type: $0) }.reduce(0, +)\\n    }\\n    \\n    private func collectGarbage(_ garbage: [String], _ travel: [Int], type: Character) -> Int {\\n        var time = 0\\n        var res = 0\\n        for i in 0..<garbage.count {\\n            let n = garbage[i].filter{ $0 == type }.count\\n            if n > 0 {\\n                time += n\\n                res = time\\n            }\\n            time += travel[i]\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func garbageCollection(_ garbage: [String], _ travel: [Int]) -> Int {\\n        \"MGP\".map{ collectGarbage(garbage, travel + [0], type: $0) }.reduce(0, +)\\n    }\\n    \\n    private func collectGarbage(_ garbage: [String], _ travel: [Int], type: Character) -> Int {\\n        var time = 0\\n        var res = 0\\n        for i in 0..<garbage.count {\\n            let n = garbage[i].filter{ $0 == type }.count\\n            if n > 0 {\\n                time += n\\n                res = time\\n            }\\n            time += travel[i]\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493187,
                "title": "python-easy-approach-prefix-sum-hashmap",
                "content": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        from collections import defaultdict\\n\\n        ans = 0\\n        lastH = {}\\n        num = defaultdict(int)\\n\\n        for i in range(len(garbage)):\\n            for char in garbage[i]:\\n                num[char] += 1\\n                lastH[char] = i\\n                \\n        pref = []\\n        res = 0\\n        for x in travel:\\n            res += x\\n            pref.append(res)\\n\\n        ans = sum(num.values())\\n        for k, v in lastH.items():\\n            if lastH[k] != 0:\\n                ans += pref[lastH[k] - 1]\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        from collections import defaultdict\\n\\n        ans = 0\\n        lastH = {}\\n        num = defaultdict(int)\\n\\n        for i in range(len(garbage)):\\n            for char in garbage[i]:\\n                num[char] += 1\\n                lastH[char] = i\\n                \\n        pref = []\\n        res = 0\\n        for x in travel:\\n            res += x\\n            pref.append(res)\\n\\n        ans = sum(num.values())\\n        for k, v in lastH.items():\\n            if lastH[k] != 0:\\n                ans += pref[lastH[k] - 1]\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492809,
                "title": "c-very-easy-solution-o-n-space-o-1",
                "content": "```\\n//at first just store last index of Metal , paper , glass\\n//rest see the code\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& gar, vector<int>& travel) {\\n        \\n         int glass=-1,paper=-1,metal=-1; //storing last index of each garbage\\n        \\n        for(int i=0;i<gar.size();i++)\\n        {\\n            int m=0,p=0,g=0;\\n            \\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'M\\')\\n                m=1;\\n                \\n                else if(it==\\'P\\')\\n                    p=1;\\n                \\n                else g=1;\\n            }\\n            if(g)\\n                glass=i;\\n            \\n            if(p)\\n                paper=i;\\n            \\n            if(m)\\n                metal=i;\\n        }\\n        \\n        int ans=0;\\n        \\n        \\n        // for glass\\n        for(int i=0;i<=glass;i++)\\n        {\\n            int g=0;\\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'G\\')\\n                    g++;\\n            }\\n            \\n           ans+=g;\\n            if(i>0)    //because we start from i=0 so no time spent at i=0\\n                ans+=travel[i-1];                   \\n        }\\n        \\n        // for paper\\n         for(int i=0;i<=paper;i++)\\n        {\\n            int p=0;\\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'P\\')\\n                    p++;\\n            }\\n            \\n           ans+=p;\\n            if(i>0)\\n                ans+=travel[i-1];                   \\n        }\\n        \\n        \\n         // for metal\\n         for(int i=0;i<=metal;i++)\\n        {\\n            int m=0;\\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'M\\')\\n                    m++;\\n            }\\n            \\n           ans+=m;\\n            if(i>0)\\n                ans+=travel[i-1];                   \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//at first just store last index of Metal , paper , glass\\n//rest see the code\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& gar, vector<int>& travel) {\\n        \\n         int glass=-1,paper=-1,metal=-1; //storing last index of each garbage\\n        \\n        for(int i=0;i<gar.size();i++)\\n        {\\n            int m=0,p=0,g=0;\\n            \\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'M\\')\\n                m=1;\\n                \\n                else if(it==\\'P\\')\\n                    p=1;\\n                \\n                else g=1;\\n            }\\n            if(g)\\n                glass=i;\\n            \\n            if(p)\\n                paper=i;\\n            \\n            if(m)\\n                metal=i;\\n        }\\n        \\n        int ans=0;\\n        \\n        \\n        // for glass\\n        for(int i=0;i<=glass;i++)\\n        {\\n            int g=0;\\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'G\\')\\n                    g++;\\n            }\\n            \\n           ans+=g;\\n            if(i>0)    //because we start from i=0 so no time spent at i=0\\n                ans+=travel[i-1];                   \\n        }\\n        \\n        // for paper\\n         for(int i=0;i<=paper;i++)\\n        {\\n            int p=0;\\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'P\\')\\n                    p++;\\n            }\\n            \\n           ans+=p;\\n            if(i>0)\\n                ans+=travel[i-1];                   \\n        }\\n        \\n        \\n         // for metal\\n         for(int i=0;i<=metal;i++)\\n        {\\n            int m=0;\\n            for(auto it:gar[i])\\n            {\\n                if(it==\\'M\\')\\n                    m++;\\n            }\\n            \\n           ans+=m;\\n            if(i>0)\\n                ans+=travel[i-1];                   \\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492799,
                "title": "c-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        map<int,vector<int>> house;\\n        vector<int> last(3);\\n        for(int i=0;i<garbage.size();i++){\\n           house[i]={0,0,0}; \\n            for(char& c:garbage[i]){\\n                if(c==\\'G\\')\\n                {\\n                    house[i][0]++;\\n                    last[0]=i;\\n                }\\n                if(c==\\'M\\')\\n                {\\n                    house[i][1]++;\\n                    last[1]=i;\\n                }\\n                if(c==\\'P\\')\\n                {\\n                    house[i][2]++;\\n                    last[2]=i;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        ans=house[0][0]+house[0][1]+house[0][2];\\n        for(int i=0;i<3;i++){\\n           for(int j=1;j<garbage.size();j++){\\n               if(last[i]>=j){\\n                 ans+=travel[j-1]+house[j][i];  \\n               }else break;\\n               \\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        map<int,vector<int>> house;\\n        vector<int> last(3);\\n        for(int i=0;i<garbage.size();i++){\\n           house[i]={0,0,0}; \\n            for(char& c:garbage[i]){\\n                if(c==\\'G\\')\\n                {\\n                    house[i][0]++;\\n                    last[0]=i;\\n                }\\n                if(c==\\'M\\')\\n                {\\n                    house[i][1]++;\\n                    last[1]=i;\\n                }\\n                if(c==\\'P\\')\\n                {\\n                    house[i][2]++;\\n                    last[2]=i;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        ans=house[0][0]+house[0][1]+house[0][2];\\n        for(int i=0;i<3;i++){\\n           for(int j=1;j<garbage.size();j++){\\n               if(last[i]>=j){\\n                 ans+=travel[j-1]+house[j][i];  \\n               }else break;\\n               \\n           }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835036,
                "title": "99-faster-86-less-memory-clean-explained-c-code",
                "content": "# Intuition\\nAll kinds of elements take same amount of time to be picked up, their difference only matters to calculate the no. of trips to be made.\\nSo calculate the last index (and eventually time) upto which truck will need to go for each type of garbage.\\n# Approach\\nCalculate prefix travel array, travel[i] = time required to reach ith house starting from 0th house\\nint M,P,G are the last house indices at which respective garbage will be found, for ex- if M=4 then metal garbage truck will not need to go further than the 4th house.\\n\\nAdd up each string length = total time for \"collecting\" garbage\\nAdd up travel[M-1] travel[P-1] travel[G-1] for the time of travelling.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote! If you like the explanation and solution, it means a lot! \\uD83E\\uDD70\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool contains(char z, string s)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == z)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int garbageCollection(vector<string> &garbage, vector<int> &travel)\\n    {\\n        int n = garbage.size(), m = travel.size();\\n\\n        for (int i = 1; i < m; i++)\\n            travel[i] += travel[i - 1];\\n\\n        int time = 0;\\n        int M = 0, P = 0, G = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (contains(\\'M\\', garbage[i]))\\n                M = i;\\n\\n            if (contains(\\'P\\', garbage[i]))\\n                P = i;\\n\\n            if (contains(\\'G\\', garbage[i]))\\n                G = i;\\n\\n            time += garbage[i].size();\\n        }\\n\\n        if (M != 0)\\n            time += travel[M - 1];\\n        if (P != 0)\\n            time += travel[P - 1];\\n        if (G != 0)\\n            time += travel[G - 1];\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool contains(char z, string s)\\n    {\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == z)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int garbageCollection(vector<string> &garbage, vector<int> &travel)\\n    {\\n        int n = garbage.size(), m = travel.size();\\n\\n        for (int i = 1; i < m; i++)\\n            travel[i] += travel[i - 1];\\n\\n        int time = 0;\\n        int M = 0, P = 0, G = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (contains(\\'M\\', garbage[i]))\\n                M = i;\\n\\n            if (contains(\\'P\\', garbage[i]))\\n                P = i;\\n\\n            if (contains(\\'G\\', garbage[i]))\\n                G = i;\\n\\n            time += garbage[i].size();\\n        }\\n\\n        if (M != 0)\\n            time += travel[M - 1];\\n        if (P != 0)\\n            time += travel[P - 1];\\n        if (G != 0)\\n            time += travel[G - 1];\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510627,
                "title": "easy-peasy-implementation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size();\\n        int ans = 0;\\n        int m = 0, g = 0, p = 0;\\n        for(auto ch:garbage[0]){\\n            if(ch == \\'M\\') m++;\\n            else if(ch == \\'G\\') g++;\\n            else p++;\\n        }\\n        int cost_m = 0;\\n        int cost_g = 0;\\n        int cost_p = 0;\\n        for(int i=1; i<n; i++){\\n            cost_m += travel[i-1];\\n            cost_g += travel[i-1];\\n            cost_p += travel[i-1];\\n            int flag1=0, flag2=0, flag3=0;\\n            for(auto ch:garbage[i]){\\n                if(ch == \\'M\\'){\\n                    flag1 = 1;\\n                    m++;\\n                }\\n                else if(ch == \\'G\\'){\\n                    flag2 = 1;\\n                    g++;\\n                }\\n                else{\\n                    flag3 = 1;\\n                    p++;\\n                }\\n            }\\n            if(flag1){\\n                m += cost_m;\\n                cost_m = 0;\\n            }\\n            if(flag2){\\n                g += cost_g;\\n                cost_g = 0;\\n            }\\n            if(flag3){\\n                p += cost_p;\\n                cost_p = 0;\\n            }\\n        }\\n        ans = m + p + g;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size();\\n        int ans = 0;\\n        int m = 0, g = 0, p = 0;\\n        for(auto ch:garbage[0]){\\n            if(ch == \\'M\\') m++;\\n            else if(ch == \\'G\\') g++;\\n            else p++;\\n        }\\n        int cost_m = 0;\\n        int cost_g = 0;\\n        int cost_p = 0;\\n        for(int i=1; i<n; i++){\\n            cost_m += travel[i-1];\\n            cost_g += travel[i-1];\\n            cost_p += travel[i-1];\\n            int flag1=0, flag2=0, flag3=0;\\n            for(auto ch:garbage[i]){\\n                if(ch == \\'M\\'){\\n                    flag1 = 1;\\n                    m++;\\n                }\\n                else if(ch == \\'G\\'){\\n                    flag2 = 1;\\n                    g++;\\n                }\\n                else{\\n                    flag3 = 1;\\n                    p++;\\n                }\\n            }\\n            if(flag1){\\n                m += cost_m;\\n                cost_m = 0;\\n            }\\n            if(flag2){\\n                g += cost_g;\\n                cost_g = 0;\\n            }\\n            if(flag3){\\n                p += cost_p;\\n                cost_p = 0;\\n            }\\n        }\\n        ans = m + p + g;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507731,
                "title": "prefix-sum-java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        for(int i=1;i<travel.length;i++){\\n            travel[i]+=travel[i-1];\\n        }\\n\\n        int p=0;\\n        int m=0;\\n        int g=0;\\n        int ans=0;\\n        for(int i=garbage.length-1;i>=0;i--){\\n            if(garbage[i].contains(\"P\")){\\n                p=i;\\n                break;\\n            }\\n        }\\n         for(int i=garbage.length-1;i>=0;i--){\\n            if(garbage[i].contains(\"M\")){\\n                m=i;\\n                break;\\n            }\\n        }\\n         for(int i=garbage.length-1;i>=0;i--){\\n            if(garbage[i].contains(\"G\")){\\n                g=i;\\n                break;\\n            }\\n        }\\n\\n        for(int i=0;i<garbage.length;i++){\\n            ans+=garbage[i].length();\\n        }\\n\\n        if(p!=0){\\n            ans+=travel[p-1];\\n        }\\n        if(m!=0){\\n            ans+=travel[m-1];\\n        }\\n        if(g!=0){\\n            ans+=travel[g-1];\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        for(int i=1;i<travel.length;i++){\\n            travel[i]+=travel[i-1];\\n        }\\n\\n        int p=0;\\n        int m=0;\\n        int g=0;\\n        int ans=0;\\n        for(int i=garbage.length-1;i>=0;i--){\\n            if(garbage[i].contains(\"P\")){\\n                p=i;\\n                break;\\n            }\\n        }\\n         for(int i=garbage.length-1;i>=0;i--){\\n            if(garbage[i].contains(\"M\")){\\n                m=i;\\n                break;\\n            }\\n        }\\n         for(int i=garbage.length-1;i>=0;i--){\\n            if(garbage[i].contains(\"G\")){\\n                g=i;\\n                break;\\n            }\\n        }\\n\\n        for(int i=0;i<garbage.length;i++){\\n            ans+=garbage[i].length();\\n        }\\n\\n        if(p!=0){\\n            ans+=travel[p-1];\\n        }\\n        if(m!=0){\\n            ans+=travel[m-1];\\n        }\\n        if(g!=0){\\n            ans+=travel[g-1];\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422616,
                "title": "minimum-amount-of-time-to-collect-garbage-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int i, j, k, time=0, idxg=-1, idxp=-1, idxm=-1;\\n        time = garbage[0].length();\\n\\n        for(i=1 ; i<travel.size() ; i++)\\n        {\\n            travel[i] += travel[i-1];\\n        }\\n\\n        for(i=1 ; i<garbage.size() ; i++)\\n        {\\n            for(j=0 ; j<garbage[i].length() ; j++)\\n            {\\n                if(garbage[i][j]==\\'G\\')\\n                {\\n                    time += 1;\\n                    idxg = i-1;\\n                }\\n                else if(garbage[i][j]==\\'P\\')\\n                {\\n                    time += 1;\\n                    idxp = i-1;\\n                }\\n                else if(garbage[i][j]==\\'M\\')\\n                {\\n                    time += 1;\\n                    idxm = i-1;\\n                }\\n            }\\n            cout<<time<<endl;\\n        }\\n        cout<<idxg<<\" \"<<idxp<<\" \"<<idxm<<endl;\\n        if(idxg>=0)\\n            time += travel[idxg];\\n        if(idxp>=0)\\n            time += travel[idxp];\\n        if(idxm>=0)\\n            time += travel[idxm];\\n        return time;\\n    }\\n};\\n\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int i, j, k, time=0, idxg=-1, idxp=-1, idxm=-1;\\n        time = garbage[0].length();\\n\\n        for(i=1 ; i<travel.size() ; i++)\\n        {\\n            travel[i] += travel[i-1];\\n        }\\n\\n        for(i=1 ; i<garbage.size() ; i++)\\n        {\\n            for(j=0 ; j<garbage[i].length() ; j++)\\n            {\\n                if(garbage[i][j]==\\'G\\')\\n                {\\n                    time += 1;\\n                    idxg = i-1;\\n                }\\n                else if(garbage[i][j]==\\'P\\')\\n                {\\n                    time += 1;\\n                    idxp = i-1;\\n                }\\n                else if(garbage[i][j]==\\'M\\')\\n                {\\n                    time += 1;\\n                    idxm = i-1;\\n                }\\n            }\\n            cout<<time<<endl;\\n        }\\n        cout<<idxg<<\" \"<<idxp<<\" \"<<idxm<<endl;\\n        if(idxg>=0)\\n            time += travel[idxg];\\n        if(idxp>=0)\\n            time += travel[idxp];\\n        if(idxm>=0)\\n            time += travel[idxm];\\n        return time;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3365182,
                "title": "easy-to-understanding-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tint garbageCollection(vector<string> &garbage, vector<int> &travel)\\n\\t{\\n\\t\\tint answer = 0;\\n\\t\\tint k = 0;\\n\\t\\tint mSum = -1, gSum = -1, pSum = -1;\\n\\t\\tfor (int i = 1; i < travel.size(); i++)\\n\\t\\t{\\n\\n\\t\\t\\ttravel[i] = travel[i - 1] + travel[i];\\n\\t\\t}\\n\\t\\tfor (auto x : garbage)\\n\\t\\t{\\n\\t\\t\\tfor (auto c : x)\\n\\t\\t\\t{\\n\\t\\t\\t\\tanswer++;\\n\\t\\t\\t\\tif (c == \\'M\\')\\n\\t\\t\\t\\t\\tmSum = k;\\n\\t\\t\\t\\tif (c == \\'P\\')\\n\\t\\t\\t\\t\\tpSum = k;\\n\\t\\t\\t\\tif (c == \\'G\\')\\n\\t\\t\\t\\t\\tgSum = k;\\n\\t\\t\\t}\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tanswer += ((gSum > 0) ? travel[gSum - 1] : 0);\\n\\t\\tanswer += ((mSum > 0) ? travel[mSum - 1] : 0);\\n\\t\\tanswer += ((pSum > 0) ? travel[pSum - 1] : 0);\\n\\t\\treturn answer;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint garbageCollection(vector<string> &garbage, vector<int> &travel)\\n\\t{\\n\\t\\tint answer = 0;\\n\\t\\tint k = 0;\\n\\t\\tint mSum = -1, gSum = -1, pSum = -1;\\n\\t\\tfor (int i = 1; i < travel.size(); i++)\\n\\t\\t{\\n\\n\\t\\t\\ttravel[i] = travel[i - 1] + travel[i];\\n\\t\\t}\\n\\t\\tfor (auto x : garbage)\\n\\t\\t{\\n\\t\\t\\tfor (auto c : x)\\n\\t\\t\\t{\\n\\t\\t\\t\\tanswer++;\\n\\t\\t\\t\\tif (c == \\'M\\')\\n\\t\\t\\t\\t\\tmSum = k;\\n\\t\\t\\t\\tif (c == \\'P\\')\\n\\t\\t\\t\\t\\tpSum = k;\\n\\t\\t\\t\\tif (c == \\'G\\')\\n\\t\\t\\t\\t\\tgSum = k;\\n\\t\\t\\t}\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tanswer += ((gSum > 0) ? travel[gSum - 1] : 0);\\n\\t\\tanswer += ((mSum > 0) ? travel[mSum - 1] : 0);\\n\\t\\tanswer += ((pSum > 0) ? travel[pSum - 1] : 0);\\n\\t\\treturn answer;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047863,
                "title": "python3-one-liner-beats-100-o-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to know two things about our garbage collection:\\n\\nThe number of bins to collect (1 minute each), and the number of houses each truck must travel to in order to collect all bins of their waste type (`travel` summed up to the last house that has the truck\\'s type of waste).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe number of bins can be obtained by finding the length of the string formed by joining each bin string in `garbage`.\\n\\nThe last house to be visited by each truck is the first element starting from the end of `garbage` that has the truck\\'s type of waste [see https://stackoverflow.com/a/6890255].\\n```\\nnext(i for i in reversed(range(len(garbage))) if w in garbage[i])\\n```\\nWe want to sum the travel vector up to this point. To prevent issues when the waste type is not at any house, a single-line if-else is used.\\n\\nWe sum `travel` up to this index, and then sum over all waste types.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:     \\n        return len(\\'\\'.join(garbage) + sum([sum(travel[:next(i for i in reversed(range(len(garbage))) if w in garbage[i])]) if w in \\'\\'.join(garbage) else 0 for w in \"MPG\"]))\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnext(i for i in reversed(range(len(garbage))) if w in garbage[i])\\n```\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:     \\n        return len(\\'\\'.join(garbage) + sum([sum(travel[:next(i for i in reversed(range(len(garbage))) if w in garbage[i])]) if w in \\'\\'.join(garbage) else 0 for w in \"MPG\"]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035539,
                "title": "faster-than-99-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int g=-1,p=-1,m=-1;\\n        int sum=0;\\n        for(int i=garbage.size()-1;i>=0;i--){\\n            sum+=garbage[i].size();\\n            if(g==-1){\\n                if(garbage[i].find(\\'G\\')!=-1){\\n                    g=i;\\n                }\\n            }\\n            if(p==-1){\\n                if(garbage[i].find(\\'P\\')!=-1){\\n                    p=i;\\n                }\\n            }\\n            if(m==-1){\\n                if(garbage[i].find(\\'M\\')!=-1){\\n                    m=i;\\n                }\\n            }\\n\\n        }\\n        int sm=0;\\n        for(int &i:travel){\\n            sm+=i;\\n            i=sm;\\n        }\\n        int ans=0;\\n        if(m>0)ans+=travel[m-1];\\n        if(g>0)ans+=travel[g-1];\\n        if(p>0)ans+=travel[p-1];\\n       \\n        return ans+sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int g=-1,p=-1,m=-1;\\n        int sum=0;\\n        for(int i=garbage.size()-1;i>=0;i--){\\n            sum+=garbage[i].size();\\n            if(g==-1){\\n                if(garbage[i].find(\\'G\\')!=-1){\\n                    g=i;\\n                }\\n            }\\n            if(p==-1){\\n                if(garbage[i].find(\\'P\\')!=-1){\\n                    p=i;\\n                }\\n            }\\n            if(m==-1){\\n                if(garbage[i].find(\\'M\\')!=-1){\\n                    m=i;\\n                }\\n            }\\n\\n        }\\n        int sm=0;\\n        for(int &i:travel){\\n            sm+=i;\\n            i=sm;\\n        }\\n        int ans=0;\\n        if(m>0)ans+=travel[m-1];\\n        if(g>0)ans+=travel[g-1];\\n        if(p>0)ans+=travel[p-1];\\n       \\n        return ans+sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989690,
                "title": "very-easy-to-understand-solution-using-python-arrays",
                "content": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        travel.insert(0, 0)\\n        answer, trash = [0, 0, 0], [0, 0, 0]\\n        for i, v in enumerate(garbage):\\n            trash = [trash[0]+travel[i], trash[1]+travel[i], trash[2]+travel[i]]\\n            paper, glass, metal = v.count(\\'P\\'), v.count(\\'G\\'), v.count(\\'M\\')\\n            if paper:\\n                answer[0]+=paper+trash[0]\\n                trash[0]=0\\n            if glass:\\n                answer[1]+=glass+trash[1]\\n                trash[1]=0\\n            if metal:\\n                answer[2]+=metal+trash[2]\\n                trash[2]=0\\n        return sum(answer)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        travel.insert(0, 0)\\n        answer, trash = [0, 0, 0], [0, 0, 0]\\n        for i, v in enumerate(garbage):\\n            trash = [trash[0]+travel[i], trash[1]+travel[i], trash[2]+travel[i]]\\n            paper, glass, metal = v.count(\\'P\\'), v.count(\\'G\\'), v.count(\\'M\\')\\n            if paper:\\n                answer[0]+=paper+trash[0]\\n                trash[0]=0\\n            if glass:\\n                answer[1]+=glass+trash[1]\\n                trash[1]=0\\n            if metal:\\n                answer[2]+=metal+trash[2]\\n                trash[2]=0\\n        return sum(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609550,
                "title": "java-solution-prefix-sum-easy",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int glassLastIdx = 0, plasticLastIdx = 0, metalLastIdx = 0;\\n        int totalTime = 0;\\n\\n        for (int i = 0; i < garbage.length; i++) {\\n            // if m/g/p seen at current index, its the last index its been seen for now\\n            for (char c : garbage[i].toCharArray()) {\\n                if (c == \\'P\\') plasticLastIdx = i;\\n                if (c == \\'M\\') metalLastIdx = i;\\n                if (c == \\'G\\') glassLastIdx = i;\\n\\t\\t\\t\\t// totalTime++;         // +1 for each pick\\n            }\\n            // number of minutes taken = length of the strings for each garbage[i]\\n            totalTime += garbage[i].length();\\n        }\\n        \\n        // creating a prefix sum array for travel time\\n        for (int i = 1; i < travel.length; i++) {\\n            travel[i] += travel[i - 1];\\n        }\\n        \\n        // adding LastIndex - 1 because travel time of i-th house is given by travel[i - 1]\\n        totalTime += (metalLastIdx == 0) ? 0 : travel[metalLastIdx - 1];\\n        totalTime += (plasticLastIdx == 0) ? 0 : travel[plasticLastIdx - 1];\\n        totalTime += (glassLastIdx == 0) ? 0 : travel[glassLastIdx - 1];\\n\\n        return totalTime;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int glassLastIdx = 0, plasticLastIdx = 0, metalLastIdx = 0;\\n        int totalTime = 0;\\n\\n        for (int i = 0; i < garbage.length; i++) {\\n            // if m/g/p seen at current index, its the last index its been seen for now\\n            for (char c : garbage[i].toCharArray()) {\\n                if (c == \\'P\\') plasticLastIdx = i;\\n                if (c == \\'M\\') metalLastIdx = i;\\n                if (c == \\'G\\') glassLastIdx = i;\\n\\t\\t\\t\\t// totalTime++;         // +1 for each pick\\n            }\\n            // number of minutes taken = length of the strings for each garbage[i]\\n            totalTime += garbage[i].length();\\n        }\\n        \\n        // creating a prefix sum array for travel time\\n        for (int i = 1; i < travel.length; i++) {\\n            travel[i] += travel[i - 1];\\n        }\\n        \\n        // adding LastIndex - 1 because travel time of i-th house is given by travel[i - 1]\\n        totalTime += (metalLastIdx == 0) ? 0 : travel[metalLastIdx - 1];\\n        totalTime += (plasticLastIdx == 0) ? 0 : travel[plasticLastIdx - 1];\\n        totalTime += (glassLastIdx == 0) ? 0 : travel[glassLastIdx - 1];\\n\\n        return totalTime;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597863,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\n       unordered_map<char,int> mp;\\n        int ans=0;\\n\\t\\t\\n       for(int i=0;i<garbage.size();i++){\\n           for(int j=0;j<garbage[i].length();j++){\\n               mp[garbage[i][j]]=i;\\n               ans++;\\n           }\\n       }\\n\\t   \\n        for(int i=1;i<travel.size();i++){\\n            travel[i]=travel[i]+travel[i-1];\\n        }\\n\\t\\t\\n\\t\\t\\n        if(mp[\\'G\\']!=0) ans+=travel[mp[\\'G\\']-1];\\n        if(mp[\\'M\\']!=0) ans+=travel[mp[\\'M\\']-1];\\n        if(mp[\\'P\\']!=0) ans+=travel[mp[\\'P\\']-1];\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\n       unordered_map<char,int> mp;\\n        int ans=0;\\n\\t\\t\\n       for(int i=0;i<garbage.size();i++){\\n           for(int j=0;j<garbage[i].length();j++){\\n               mp[garbage[i][j]]=i;\\n               ans++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2546437,
                "title": "python-faster-than-97",
                "content": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        st=\\'\\'\\n        for xx in garbage:\\n            st+=xx\\n        ans=0\\n        x=-1\\n        y=-1\\n        z=-1\\n        for i in range(len(garbage)):\\n            if \"P\" in garbage[i]:\\n                x=(i)\\n            if \"G\" in garbage[i]:\\n                y=(i)\\n            if \"M\" in garbage[i]:\\n                z=(i)\\n        for j in range(x):\\n            ans+=travel[j]\\n        for k in range(y):\\n            ans+=travel[k]\\n        for l in range(z):\\n            ans+=travel[l]\\n        ans+=len(st)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        st=\\'\\'\\n        for xx in garbage:\\n            st+=xx\\n        ans=0\\n        x=-1\\n        y=-1\\n        z=-1\\n        for i in range(len(garbage)):\\n            if \"P\" in garbage[i]:\\n                x=(i)\\n            if \"G\" in garbage[i]:\\n                y=(i)\\n            if \"M\" in garbage[i]:\\n                z=(i)\\n        for j in range(x):\\n            ans+=travel[j]\\n        for k in range(y):\\n            ans+=travel[k]\\n        for l in range(z):\\n            ans+=travel[l]\\n        ans+=len(st)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509292,
                "title": "easy-understand-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size(), m = travel.size();\\n        int last[26] = {}, ans = 0;\\n        for (int i = 0; i < n; ++ i) {\\n            ans += garbage[i].size();\\n            for (int j = 0; j < garbage[i].size(); ++ j) last[garbage[i][j] - \\'A\\'] = i;\\n        }\\n        for (int i = 1; i < m; ++ i) travel[i] += travel[i - 1];\\n        string dict = \"MPG\";\\n        for (auto &c : dict)\\n            if (last[c - \\'A\\']) ans += travel[last[c - \\'A\\'] - 1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size(), m = travel.size();\\n        int last[26] = {}, ans = 0;\\n        for (int i = 0; i < n; ++ i) {\\n            ans += garbage[i].size();\\n            for (int j = 0; j < garbage[i].size(); ++ j) last[garbage[i][j] - \\'A\\'] = i;\\n        }\\n        for (int i = 1; i < m; ++ i) travel[i] += travel[i - 1];\\n        string dict = \"MPG\";\\n        for (auto &c : dict)\\n            if (last[c - \\'A\\']) ans += travel[last[c - \\'A\\'] - 1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503916,
                "title": "c-calculate-time-for-each-type-of-truck",
                "content": "* Find the farthest index , where each type of truck will go to collect grabage of respective types.\\n\\n* For example consider- > `[\"PPM\",\"PMG\",\"GGM\",\"GP\"]`. Then The truck collecting `Metal` will only go upto 3rd house. There is absolutely no reason for this truck to go and visit the last house too. Therefore, this saves time for `Metal` Truck.\\n\\n* Similaly, we find the farthest index upto which each truck is required to go.\\n\\n* We calculate the time taken by each truck with the help of **getTime** function.\\n\\n* Answer will be sum total of time taken by all the three trucks.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>travel ;\\n    vector<string> rem ;\\n    int getTime(char c , int bound){\\n        int timer = 0 ;\\n        \\n        for(int i = 0 ; i <= bound ; ++i ){\\n            //count for number of chars of c \\n            int cnt = count(begin(rem[i]),end(rem[i]),c) ;\\n            timer += cnt ;\\n            if(i != bound and i < travel.size()) timer += travel[i] ;\\n        }\\n        \\n        return timer ;\\n    }\\n    \\n    int garbageCollection(vector<string>& rem, vector<int>& travel) {\\n        this->rem = rem ;\\n        this->travel = travel ;\\n        int mi = 0 , gi = 0 ,pi = 0 ;\\n        \\n        for(int i = rem.size() - 1 ; i >= 0 ; --i ){\\n            int M = count(begin(rem[i]),end(rem[i]),\\'M\\') ;\\n            int P = count(begin(rem[i]),end(rem[i]),\\'P\\') ;\\n            int G = count(begin(rem[i]),end(rem[i]),\\'G\\') ;\\n            \\n            if(M and !mi) mi = i ;\\n            if(P and !pi) pi = i ;\\n            if(G and !gi) gi = i ;\\n        }\\n        \\n        int M = getTime(\\'M\\',mi) ; \\n        int P = getTime(\\'P\\',pi) ;\\n        int G = getTime(\\'G\\',gi) ;\\n        \\n        return  M + P + G ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>travel ;\\n    vector<string> rem ;\\n    int getTime(char c , int bound){\\n        int timer = 0 ;\\n        \\n        for(int i = 0 ; i <= bound ; ++i ){\\n            //count for number of chars of c \\n            int cnt = count(begin(rem[i]),end(rem[i]),c) ;\\n            timer += cnt ;\\n            if(i != bound and i < travel.size()) timer += travel[i] ;\\n        }\\n        \\n        return timer ;\\n    }\\n    \\n    int garbageCollection(vector<string>& rem, vector<int>& travel) {\\n        this->rem = rem ;\\n        this->travel = travel ;\\n        int mi = 0 , gi = 0 ,pi = 0 ;\\n        \\n        for(int i = rem.size() - 1 ; i >= 0 ; --i ){\\n            int M = count(begin(rem[i]),end(rem[i]),\\'M\\') ;\\n            int P = count(begin(rem[i]),end(rem[i]),\\'P\\') ;\\n            int G = count(begin(rem[i]),end(rem[i]),\\'G\\') ;\\n            \\n            if(M and !mi) mi = i ;\\n            if(P and !pi) pi = i ;\\n            if(G and !gi) gi = i ;\\n        }\\n        \\n        int M = getTime(\\'M\\',mi) ; \\n        int P = getTime(\\'P\\',pi) ;\\n        int G = getTime(\\'G\\',gi) ;\\n        \\n        return  M + P + G ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499300,
                "title": "c-prefix-sum-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        for(int i=1;i<travel.size();i++)\\n        {\\n            travel[i]+=travel[i-1];\\n        }\\n        int res=0;\\n        res+=fun(garbage,travel,\\'G\\');\\n        res+=fun(garbage,travel,\\'P\\');\\n        res+=fun(garbage,travel,\\'M\\');\\n        return res;\\n    }\\n    int fun(vector<string>& garbage, vector<int>& travel,char p)\\n    {\\n        int res=0;\\n        int ind=-1;\\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            int c=0;\\n            for(auto x:garbage[i])\\n            {\\n                if(x==p)\\n                {\\n                    ind=i-1;// upto which the last house we visited to pickup\\n                    c++;\\n                }\\n            }\\n            res+=c;// pickup time\\n        }\\n        if(ind!=-1)\\n            res+=travel[ind];// time to visit between houses\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        for(int i=1;i<travel.size();i++)\\n        {\\n            travel[i]+=travel[i-1];\\n        }\\n        int res=0;\\n        res+=fun(garbage,travel,\\'G\\');\\n        res+=fun(garbage,travel,\\'P\\');\\n        res+=fun(garbage,travel,\\'M\\');\\n        return res;\\n    }\\n    int fun(vector<string>& garbage, vector<int>& travel,char p)\\n    {\\n        int res=0;\\n        int ind=-1;\\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            int c=0;\\n            for(auto x:garbage[i])\\n            {\\n                if(x==p)\\n                {\\n                    ind=i-1;// upto which the last house we visited to pickup\\n                    c++;\\n                }\\n            }\\n            res+=c;// pickup time\\n        }\\n        if(ind!=-1)\\n            res+=travel[ind];// time to visit between houses\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495822,
                "title": "c-solution-with-intuition",
                "content": "When you carefully read the problem there are certain observations:\\n\\n\\t\\t1. Each garbage truck starts at house 0 and must visit each house in order.\\n\\t\\t2. In order here means you cannot skip a house in between. To reach house 4 you need to travel from 0 - 1 - 2 - 3 - 4. \\n\\t\\t2. Only one garbage truck may be used at any given moment.\\n\\t\\t3. By this observation we can say that each truck will pick it\\'s respective garbage and during that time all other trucks will wait. \\nSo finally the answer will include sum of time taken by each truck to pick their repective garbage.\\n\\nNow by above observation, its clear that each truck will start from 0 and go to the house till which it needs to pick the grabage.\\nAnd we know each truck is associated with its grbage type. \\nSo we can say that the maximum distance a truck will travel will be the house at which it has the last of its garbage type.\\nAlso whenever we pick garbage it takes us 1unit time.\\nNow by all the above points the answer will be, \\n* \\tfor each truck\\n\\t* \\tanswer += The time its take to reach the last house of it\\'s garbage type + the number of garbage type present at each house. \\n\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char, int>occ; // calculate the number of times each garbage type appears\\n        unordered_map<char, int>pos; // last position of each garbage type \\n        \\n\\t\\t//calculating occ and pos\\n\\t\\tfor(int i=0; i<garbage.size(); i++){\\n            string temp = garbage[i];\\n            for(int j=0; j<temp.size(); j++){\\n                occ[temp[j]]++;\\n                pos[temp[j]] = i;\\n            }\\n        }\\n        \\n\\t\\t//travel is modified such that it gives the time required to reach the ith house\\n        for(int i=1; i<travel.size(); i++){\\n            travel[i] = travel[i-1] + travel[i];\\n        }\\n        \\n        int ans = 0;\\n\\t\\t\\n\\t\\t// calculate for each type of truck\\n        for(auto ch: {\\'M\\', \\'P\\', \\'G\\'}){\\n            int dist = pos[ch] == 0 ? 0 : travel[pos[ch]-1], count = occ[ch];\\n            ans += (dist + count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\nThanks for reading it. Hope it helps !!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char, int>occ; // calculate the number of times each garbage type appears\\n        unordered_map<char, int>pos; // last position of each garbage type \\n        \\n\\t\\t//calculating occ and pos\\n\\t\\tfor(int i=0; i<garbage.size(); i++){\\n            string temp = garbage[i];\\n            for(int j=0; j<temp.size(); j++){\\n                occ[temp[j]]++;\\n                pos[temp[j]] = i;\\n            }\\n        }\\n        \\n\\t\\t//travel is modified such that it gives the time required to reach the ith house\\n        for(int i=1; i<travel.size(); i++){\\n            travel[i] = travel[i-1] + travel[i];\\n        }\\n        \\n        int ans = 0;\\n\\t\\t\\n\\t\\t// calculate for each type of truck\\n        for(auto ch: {\\'M\\', \\'P\\', \\'G\\'}){\\n            int dist = pos[ch] == 0 ? 0 : travel[pos[ch]-1], count = occ[ch];\\n            ans += (dist + count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494493,
                "title": "constant-space-java-solution",
                "content": "```\\nclass Solution {\\n    public int garbageCollection(String[] g, int[] t) {\\n        int a[]=new int[3];\\n        int k=g.length;\\n        String c[] = {\"M\", \"P\", \"G\"};\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=k-1;j>=0;j--)\\n            {\\n                if(g[j].contains(c[i]))\\n                {\\n                    a[i]=j;\\n                    break;\\n                }\\n            }\\n        }\\n        int s=0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<a[i];j++)\\n            {\\n                s+=t[j];\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            s+=g[i].length();\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int garbageCollection(String[] g, int[] t) {\\n        int a[]=new int[3];\\n        int k=g.length;\\n        String c[] = {\"M\", \"P\", \"G\"}",
                "codeTag": "Java"
            },
            {
                "id": 2494353,
                "title": "rust",
                "content": "This is my unaltered submission to the 2022-08-28 Weekly Contest 308. We have to know how many \\'P\\'s, \\'M\\'s and \\'G\\'s there are in total (1 minute to process each letter). We also want to know the position of the last of each letter, since then the truck doesn\\'t have to travel further. We need to know the sum of travel times to each stop, because the truck has to travel to each stop in turn. So we\\'ll compute the prefix sum of travel times ((O(n)) as well as the sum of number of letters (O(n * k), where k is the maximum length of `garbage[i]`, and the last positions of the respective letters (O(n * k)). The total time is then the sum of the number of letters plus the sum of the corresponding prefix sum for the last stop for each letter.\\n\\nTime: O(n * k)\\nSpace: O(n) for vector of prefix sums\\n\\nComment: I could have made things simpler by not splitting the sums of letters and just having something like `total_len += s.len()`, not that it would make any difference to big-O time complexity.\\n\\n```\\nimpl Solution {\\n    pub fn garbage_collection(garbage: Vec<String>, travel: Vec<i32>) -> i32 {\\n        let mut acc = 0;\\n        let travel: Vec<i32> = std::iter::once(0).chain(travel.into_iter().map(|t| { acc += t; acc })).collect();\\n        let (p, m, g, last_p, last_m, last_g) = garbage.into_iter().enumerate().fold((0, 0, 0, 0, 0, 0), |(mut p, mut m, mut g, mut last_p, mut last_m, mut last_g), (i, s)| {\\n            for &b in s.as_bytes() {\\n                match b {\\n                    b\\'P\\' => { p += 1; last_p = i; },\\n                    b\\'M\\' => { m += 1; last_m = i; },\\n                    _ => { g += 1; last_g = i; },\\n                }\\n            }\\n            (p, m, g, last_p, last_m, last_g)\\n        });\\n        p + m + g + travel[last_p] + travel[last_m] + travel[last_g]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn garbage_collection(garbage: Vec<String>, travel: Vec<i32>) -> i32 {\\n        let mut acc = 0;\\n        let travel: Vec<i32> = std::iter::once(0).chain(travel.into_iter().map(|t| { acc += t; acc })).collect();\\n        let (p, m, g, last_p, last_m, last_g) = garbage.into_iter().enumerate().fold((0, 0, 0, 0, 0, 0), |(mut p, mut m, mut g, mut last_p, mut last_m, mut last_g), (i, s)| {\\n            for &b in s.as_bytes() {\\n                match b {\\n                    b\\'P\\' => { p += 1; last_p = i; },\\n                    b\\'M\\' => { m += 1; last_m = i; },\\n                    _ => { g += 1; last_g = i; },\\n                }\\n            }\\n            (p, m, g, last_p, last_m, last_g)\\n        });\\n        p + m + g + travel[last_p] + travel[last_m] + travel[last_g]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493658,
                "title": "c-most-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int cntp=0,cntm=0,cntg=0,indg=0,indp=0,indm=0; // cntg,cntp,cntm used for counting no of characters of Garbage,Paper,Metal\\n\\t\\t//indg,indp,indm for storing last index of occurence  of Garbage,Paper ,Metal\\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            string str=garbage[i];\\n            for(int j=0;j<str.size();j++)\\n            {\\n                if(str[j]==\\'G\\')\\n                {\\n                    cntg++;\\n                    indg=i;\\n                }\\n                if(str[j]==\\'P\\')\\n                {\\n                     cntp++;\\n                    indp=i;\\n                }\\n                if(str[j]==\\'M\\')\\n                {\\n                      cntm++;\\n                      indm=i;\\n                }\\n            }\\n        }\\n        long long s=0; // s-> for evaluating the total time taken\\n            for(int i=0;i<indg;i++)\\n            s+=travel[i];\\n            for(int i=0;i<indm;i++)\\n            s+=travel[i];\\n            for(int i=0;i<indp;i++)\\n            s+=travel[i];\\n        return s+cntp+cntm+cntg;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int cntp=0,cntm=0,cntg=0,indg=0,indp=0,indm=0; // cntg,cntp,cntm used for counting no of characters of Garbage,Paper,Metal\\n\\t\\t//indg,indp,indm for storing last index of occurence  of Garbage,Paper ,Metal\\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            string str=garbage[i];\\n            for(int j=0;j<str.size();j++)\\n            {\\n                if(str[j]==\\'G\\')\\n                {\\n                    cntg++;\\n                    indg=i;\\n                }\\n                if(str[j]==\\'P\\')\\n                {\\n                     cntp++;\\n                    indp=i;\\n                }\\n                if(str[j]==\\'M\\')\\n                {\\n                      cntm++;\\n                      indm=i;\\n                }\\n            }\\n        }\\n        long long s=0; // s-> for evaluating the total time taken\\n            for(int i=0;i<indg;i++)\\n            s+=travel[i];\\n            for(int i=0;i<indm;i++)\\n            s+=travel[i];\\n            for(int i=0;i<indp;i++)\\n            s+=travel[i];\\n        return s+cntp+cntm+cntg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493564,
                "title": "2-pass-3-loops-but-linear-complexity-c-solution",
                "content": "Please do **upvote** and **share**.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string> &garbage, vector<int> &travel) {\\n        int ans = 0;\\n        for (char c : \"MPG\") {\\n            int temp = 0, lastIdx = 0;\\n            for (int i = 0; i < garbage.size(); i++) {\\n                for (char x : garbage[i]) {\\n                    if (x == c) {\\n                        temp++;\\n                        lastIdx = i;\\n                    }\\n                }\\n                if (i < travel.size()) temp += travel[i];\\n            }\\n            for (int i = garbage.size() - 2; i >= lastIdx; i--) {\\n                temp -= travel[i];\\n            }\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity : **O(garbage.length)**\\nSpace Complexity: **O(1)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string> &garbage, vector<int> &travel) {\\n        int ans = 0;\\n        for (char c : \"MPG\") {\\n            int temp = 0, lastIdx = 0;\\n            for (int i = 0; i < garbage.size(); i++) {\\n                for (char x : garbage[i]) {\\n                    if (x == c) {\\n                        temp++;\\n                        lastIdx = i;\\n                    }\\n                }\\n                if (i < travel.size()) temp += travel[i];\\n            }\\n            for (int i = garbage.size() - 2; i >= lastIdx; i--) {\\n                temp -= travel[i];\\n            }\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493422,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        int g = 0, p = 0, m = 0;\\n        int gt = -1, pt = -1, mt = -1;\\n        for (int i = 0; i < garbage.size(); i++)\\n        {\\n            for (auto& ch : garbage[i])\\n            {\\n                if (ch == \\'G\\')\\n                    g++, gt = i - 1;\\n                else if (ch == \\'P\\')\\n                    p++, pt = i - 1;\\n                else\\n                    m++, mt = i - 1;\\n            }\\n        }\\n        \\n        for (int i = 1; i < travel.size(); i++)\\n            travel[i] += travel[i - 1];\\n        \\n        int travelTime = (gt == -1 ? 0 : travel[gt]) + (pt == -1 ? 0 : travel[pt]) + (mt == -1 ? 0 : travel[mt]);\\n        int pickupTime = g + p + m;\\n        \\n        return travelTime + pickupTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        int g = 0, p = 0, m = 0;\\n        int gt = -1, pt = -1, mt = -1;\\n        for (int i = 0; i < garbage.size(); i++)\\n        {\\n            for (auto& ch : garbage[i])\\n            {\\n                if (ch == \\'G\\')\\n                    g++, gt = i - 1;\\n                else if (ch == \\'P\\')\\n                    p++, pt = i - 1;\\n                else\\n                    m++, mt = i - 1;\\n            }\\n        }\\n        \\n        for (int i = 1; i < travel.size(); i++)\\n            travel[i] += travel[i - 1];\\n        \\n        int travelTime = (gt == -1 ? 0 : travel[gt]) + (pt == -1 ? 0 : travel[pt]) + (mt == -1 ? 0 : travel[mt]);\\n        int pickupTime = g + p + m;\\n        \\n        return travelTime + pickupTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493330,
                "title": "rust-simple-loop",
                "content": "~~~\\nimpl Solution {\\n    pub fn garbage_collection(garbage: Vec<String>, travel: Vec<i32>) -> i32 {\\n        let n = garbage.len();\\n        let mut sum = vec![0; n];\\n        for i in 1..n {\\n            sum[i] = sum[i - 1] + travel[i - 1];\\n        }\\n        \\n        let (mut g, mut m, mut p, mut cnt) = (0, 0, 0, 0);\\n        \\n        for i in 0..n {\\n            cnt += garbage[i].len() as i32;\\n            for c in garbage[i].chars() {\\n                if c == \\'G\\' { g = sum[i]; }\\n                if c == \\'M\\' { m = sum[i]; }\\n                if c == \\'P\\' { p = sum[i]; }\\n            }\\n        }\\n        \\n        g + m + p + cnt\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn garbage_collection(garbage: Vec<String>, travel: Vec<i32>) -> i32 {\\n        let n = garbage.len();\\n        let mut sum = vec![0; n];\\n        for i in 1..n {\\n            sum[i] = sum[i - 1] + travel[i - 1];\\n        }\\n        \\n        let (mut g, mut m, mut p, mut cnt) = (0, 0, 0, 0);\\n        \\n        for i in 0..n {\\n            cnt += garbage[i].len() as i32;\\n            for c in garbage[i].chars() {\\n                if c == \\'G\\' { g = sum[i]; }\\n                if c == \\'M\\' { m = sum[i]; }\\n                if c == \\'P\\' { p = sum[i]; }\\n            }\\n        }\\n        \\n        g + m + p + cnt\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2492821,
                "title": "easy-python-clean-solution",
                "content": "```\\n    def garbageCollection(self, garbage, travel):\\n        \"\"\"\\n        :type garbage: List[str]\\n        :type travel: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getTime(t):\\n            total = 0\\n            timeTravel = 0\\n            for i in range(len(garbage)):\\n                cnt = garbage[i].count(t) \\n                if cnt > 0:\\n                    total += cnt\\n                    total += timeTravel\\n                    timeTravel = 0\\n                if i != len(garbage) - 1:\\n                    timeTravel += travel[i]\\n            return total\\n        \\n        return getTime(\\'M\\') + getTime(\\'P\\') + getTime(\\'G\\')\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def garbageCollection(self, garbage, travel):\\n        \"\"\"\\n        :type garbage: List[str]\\n        :type travel: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def getTime(t):\\n            total = 0\\n            timeTravel = 0\\n            for i in range(len(garbage)):\\n                cnt = garbage[i].count(t) \\n                if cnt > 0:\\n                    total += cnt\\n                    total += timeTravel\\n                    timeTravel = 0\\n                if i != len(garbage) - 1:\\n                    timeTravel += travel[i]\\n            return total\\n        \\n        return getTime(\\'M\\') + getTime(\\'P\\') + getTime(\\'G\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492820,
                "title": "c-2d-array-trivial-fast-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        int size_gb = garbage.size();\\n        \\n        // 2d arrya to hold house and garbage size from i house\\n        vector<vector<int>> m(size_gb, vector<int>(3, 0));\\n        int ans=0;\\n        \\n        for(int i=0; i<size_gb; i++){\\n            for(int j=0; j<garbage[i].size(); j++){\\n               if(garbage[i][j]==\\'M\\') m[i][0]++;\\n                else if(garbage[i][j]==\\'P\\') m[i][1]++;\\n                else if(garbage[i][j]==\\'G\\') m[i][2]++;\\n            }\\n        }\\n        \\n        // 3 garbage trucks\\n        for(int i=0; i<3; i++){\\n            int petrol = 0;\\n            int j=0;\\n            \\n            for(; j<size_gb-1; j++){\\n                // add petrol and other values if and only if garbage is found at the house\\n                if(m[j][i]){\\n                    ans +=(petrol + m[j][i]);\\n                    pet = travel[j];\\n                } else {\\n                    petrol += travel[j];\\n                }\\n            }\\n            \\n            // edge case for last house\\n            if(m[j][i]>0){\\n                ans +=(petrol + m[j][i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        int size_gb = garbage.size();\\n        \\n        // 2d arrya to hold house and garbage size from i house\\n        vector<vector<int>> m(size_gb, vector<int>(3, 0));\\n        int ans=0;\\n        \\n        for(int i=0; i<size_gb; i++){\\n            for(int j=0; j<garbage[i].size(); j++){\\n               if(garbage[i][j]==\\'M\\') m[i][0]++;\\n                else if(garbage[i][j]==\\'P\\') m[i][1]++;\\n                else if(garbage[i][j]==\\'G\\') m[i][2]++;\\n            }\\n        }\\n        \\n        // 3 garbage trucks\\n        for(int i=0; i<3; i++){\\n            int petrol = 0;\\n            int j=0;\\n            \\n            for(; j<size_gb-1; j++){\\n                // add petrol and other values if and only if garbage is found at the house\\n                if(m[j][i]){\\n                    ans +=(petrol + m[j][i]);\\n                    pet = travel[j];\\n                } else {\\n                    petrol += travel[j];\\n                }\\n            }\\n            \\n            // edge case for last house\\n            if(m[j][i]>0){\\n                ans +=(petrol + m[j][i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492758,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int total = 0;\\n        return helper(garbage, travel, \\'M\\') + helper(garbage, travel, \\'P\\') + helper(garbage, travel, \\'G\\');\\n    }\\n    \\n    public int helper(String[] g, int[] t, char type) {\\n        int answer = 0;\\n        int lastIdx = lastIdx(g, type);\\n        for (int i = 0; i <= lastIdx; i++) {\\n            int count = 0;\\n            for (char c : g[i].toCharArray()) {\\n                if (c == type) {\\n                    count++;\\n                }\\n            }\\n            //  garbage at this house\\n            answer += count;\\n            //  time taken to reach the next house\\n            if (i < g.length - 1) answer += t[i];\\n            if (i == lastIdx) {\\n                //  no need to add the time taken to reach the next house as this is the last house\\n                if (i < g.length - 1) answer -= t[i];\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public int lastIdx(String[] g, char c) {\\n        for (int i = g.length - 1; i >= 0; i--) {\\n            for (char ch : g[i].toCharArray()) {\\n                if (ch == c) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int total = 0;\\n        return helper(garbage, travel, \\'M\\') + helper(garbage, travel, \\'P\\') + helper(garbage, travel, \\'G\\');\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4037147,
                "title": "easy-to-understand-solution-with-explanation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can only reduce time by not going to all the houses. a truck has to go only till the largest index where its type of garbage is present.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will add the number of garbages present to the ans cause we have to pick all the garbage and each takes one minute. no deduction can be done on this.\\n\\nthen we will iterate through the array from the end and find the largest index that a truck has to go to. once found we will not update it. once all three are found we will break from the loop.\\n\\nnow add the travel time for all the trucks in our ans.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans = 0;\\n\\n        for(string s: garbage){\\n            ans += s.size();\\n        }\\n\\n        int gm = -1,gp = -1,gg = -1;\\n\\n        for(int i = garbage.size()-1; i >= 0; i--){\\n            if(gm != -1 && gp != -1 && gg != -1) break;\\n            string s = garbage[i];\\n            for(char c: s){\\n                if(gg == -1 && c == \\'G\\') gg = i;\\n                else if(gp == -1 && c == \\'P\\') gp = i;\\n                else if(gm == -1 && c == \\'M\\') gm = i;\\n            }\\n        }\\n\\n        if(gm > 0){\\n            for(int i = 0; i < gm; i++){\\n                ans += travel[i];\\n            }\\n        }\\n        if(gp > 0){\\n            for(int i = 0; i < gp; i++){\\n                ans += travel[i];\\n            }\\n        }\\n        if(gg > 0){\\n            for(int i = 0; i < gg; i++){\\n                ans += travel[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans = 0;\\n\\n        for(string s: garbage){\\n            ans += s.size();\\n        }\\n\\n        int gm = -1,gp = -1,gg = -1;\\n\\n        for(int i = garbage.size()-1; i >= 0; i--){\\n            if(gm != -1 && gp != -1 && gg != -1) break;\\n            string s = garbage[i];\\n            for(char c: s){\\n                if(gg == -1 && c == \\'G\\') gg = i;\\n                else if(gp == -1 && c == \\'P\\') gp = i;\\n                else if(gm == -1 && c == \\'M\\') gm = i;\\n            }\\n        }\\n\\n        if(gm > 0){\\n            for(int i = 0; i < gm; i++){\\n                ans += travel[i];\\n            }\\n        }\\n        if(gp > 0){\\n            for(int i = 0; i < gp; i++){\\n                ans += travel[i];\\n            }\\n        }\\n        if(gg > 0){\\n            for(int i = 0; i < gg; i++){\\n                ans += travel[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028657,
                "title": "o-1-space-o-n-time-very-efficient-solution",
                "content": "### We just need to find last occurence of M,P and G.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garb, vector<int>& t) {\\n        int m=-1,p=-1,g=-1,ans=0,Tsum=0;\\n        for(int i=0;i<garb.size();i++){\\n            if (garb[i].find(\\'M\\') != string::npos){m=i;}\\n            if (garb[i].find(\\'G\\') != string::npos){g=i;}\\n            if (garb[i].find(\\'P\\') != string::npos){p=i;}\\n            ans+=garb[i].size();\\n        }\\n        for(int i=1;i<garb.size();i++){\\n            Tsum+=t[i-1];\\n            if(m==i){ans+=Tsum;}\\n            if(g==i){ans+=Tsum;}\\n            if(p==i){ans+=Tsum;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garb, vector<int>& t) {\\n        int m=-1,p=-1,g=-1,ans=0,Tsum=0;\\n        for(int i=0;i<garb.size();i++){\\n            if (garb[i].find(\\'M\\') != string::npos){m=i;}\\n            if (garb[i].find(\\'G\\') != string::npos){g=i;}\\n            if (garb[i].find(\\'P\\') != string::npos){p=i;}\\n            ans+=garb[i].size();\\n        }\\n        for(int i=1;i<garb.size();i++){\\n            Tsum+=t[i-1];\\n            if(m==i){ans+=Tsum;}\\n            if(g==i){ans+=Tsum;}\\n            if(p==i){ans+=Tsum;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614132,
                "title": "go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInverted traversal. When G or P or M is found, it is time to start the computation.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n * m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nfunc garbageCollection(garbage []string, travel []int) int {\\n    g, m, p := 0, 0, 0\\n    cost := 0\\n\\tfor i := len(garbage) - 1; i >= 0; i-- {\\n\\t\\tfor _, _g := range garbage[i] {\\n\\t\\t\\tif _g == \\'G\\' {\\n                g++\\n\\t\\t\\t}\\n\\t\\t\\tif _g == \\'M\\' {\\n                m++\\n\\t\\t\\t}\\n\\t\\t\\tif _g == \\'P\\' {\\n                p++\\n\\t\\t\\t}\\n\\t\\t}\\n        if g > 0 && i != 0{\\n            cost += travel[i-1]\\n        }\\n        if m > 0 && i != 0{\\n            cost += travel[i-1]\\n        }\\n        if p > 0 && i != 0{\\n            cost += travel[i-1]\\n        }\\n\\t}\\n\\treturn g + m + p + cost\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc garbageCollection(garbage []string, travel []int) int {\\n    g, m, p := 0, 0, 0\\n    cost := 0\\n\\tfor i := len(garbage) - 1; i >= 0; i-- {\\n\\t\\tfor _, _g := range garbage[i] {\\n\\t\\t\\tif _g == \\'G\\' {\\n                g++\\n\\t\\t\\t}\\n\\t\\t\\tif _g == \\'M\\' {\\n                m++\\n\\t\\t\\t}\\n\\t\\t\\tif _g == \\'P\\' {\\n                p++\\n\\t\\t\\t}\\n\\t\\t}\\n        if g > 0 && i != 0{\\n            cost += travel[i-1]\\n        }\\n        if m > 0 && i != 0{\\n            cost += travel[i-1]\\n        }\\n        if p > 0 && i != 0{\\n            cost += travel[i-1]\\n        }\\n\\t}\\n\\treturn g + m + p + cost\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576769,
                "title": "implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int m = -1, p = -1, g = -1, n = size(garbage), ans = 0;\\n        struct Garbage{\\n            int g,p,m;\\n        };\\n        map<int,Garbage> mp;\\n        for(int i=n-1; i>=0; --i){\\n            string e = garbage[i];\\n            for(char&ee: e){\\n                if(ee == \\'G\\'){\\n                    if(g == -1) g = i;\\n                    mp[i].g++;\\n                }\\n                else if(ee == \\'M\\'){\\n                    if(m == -1) m = i;\\n                    mp[i].m++;\\n                }    \\n                else if(ee == \\'P\\'){\\n                    if(p == -1) p = i;\\n                    mp[i].p++;\\n                }\\n            }\\n        }\\n        // metal\\n        if(m != -1){\\n            for(int i=0; i<m; ++i)\\n                ans += mp[i].m + travel[i];\\n            ans += mp[m].m;\\n        }\\n        // paper\\n        if(p != -1){\\n            for(int i=0; i<p; ++i)\\n                ans += mp[i].p + travel[i];\\n            ans += mp[p].p;\\n        }\\n        // glass\\n        if(g != -1){\\n            for(int i=0; i<g; ++i){\\n                ans += mp[i].g + travel[i];\\n            }\\n            ans += mp[g].g;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int m = -1, p = -1, g = -1, n = size(garbage), ans = 0;\\n        struct Garbage{\\n            int g,p,m;\\n        };\\n        map<int,Garbage> mp;\\n        for(int i=n-1; i>=0; --i){\\n            string e = garbage[i];\\n            for(char&ee: e){\\n                if(ee == \\'G\\'){\\n                    if(g == -1) g = i;\\n                    mp[i].g++;\\n                }\\n                else if(ee == \\'M\\'){\\n                    if(m == -1) m = i;\\n                    mp[i].m++;\\n                }    \\n                else if(ee == \\'P\\'){\\n                    if(p == -1) p = i;\\n                    mp[i].p++;\\n                }\\n            }\\n        }\\n        // metal\\n        if(m != -1){\\n            for(int i=0; i<m; ++i)\\n                ans += mp[i].m + travel[i];\\n            ans += mp[m].m;\\n        }\\n        // paper\\n        if(p != -1){\\n            for(int i=0; i<p; ++i)\\n                ans += mp[i].p + travel[i];\\n            ans += mp[p].p;\\n        }\\n        // glass\\n        if(g != -1){\\n            for(int i=0; i<g; ++i){\\n                ans += mp[i].g + travel[i];\\n            }\\n            ans += mp[g].g;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404872,
                "title": "simple-c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        // Prefix Sum of travel to find the time taken by truck\\n        // to reach the city from the start\\n        for(int i=0;i<travel.size();i++) {\\n            if(i > 0) travel[i] += travel[i-1];\\n        }\\n\\n        // To get the count of different garbages\\n        int g=0,p=0,m=0;\\n        // To determine the last city of each garbage\\n        int gl=0,pl=0,ml=0;\\n        // To store the answer\\n        int ans = 0;\\n        for(int i=garbage.size()-1;i>=0;i--) {\\n            for(int j=0;j<garbage[i].size();j++) {\\n                if(garbage[i][j] == \\'G\\') {\\n                    if(gl == 0) {\\n                        if(i > 0) ans += travel[i-1];\\n                        gl = 1;\\n                    }\\n                    g++;\\n                } \\n                else if(garbage[i][j] == \\'P\\') {\\n                    if(pl == 0) {\\n                        if(i > 0) ans += travel[i-1];\\n                        pl = 1;\\n                    }\\n                    p++;\\n                }\\n                else {\\n                    if(ml == 0) {\\n                        if(i > 0) ans += travel[i-1];\\n                        ml = 1;\\n                    }\\n                    m++;\\n                }\\n            }\\n        }\\n        // Add all garbages to the final answer\\n        ans += (g+m+p);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        // Prefix Sum of travel to find the time taken by truck\\n        // to reach the city from the start\\n        for(int i=0;i<travel.size();i++) {\\n            if(i > 0) travel[i] += travel[i-1];\\n        }\\n\\n        // To get the count of different garbages\\n        int g=0,p=0,m=0;\\n        // To determine the last city of each garbage\\n        int gl=0,pl=0,ml=0;\\n        // To store the answer\\n        int ans = 0;\\n        for(int i=garbage.size()-1;i>=0;i--) {\\n            for(int j=0;j<garbage[i].size();j++) {\\n                if(garbage[i][j] == \\'G\\') {\\n                    if(gl == 0) {\\n                        if(i > 0) ans += travel[i-1];\\n                        gl = 1;\\n                    }\\n                    g++;\\n                } \\n                else if(garbage[i][j] == \\'P\\') {\\n                    if(pl == 0) {\\n                        if(i > 0) ans += travel[i-1];\\n                        pl = 1;\\n                    }\\n                    p++;\\n                }\\n                else {\\n                    if(ml == 0) {\\n                        if(i > 0) ans += travel[i-1];\\n                        ml = 1;\\n                    }\\n                    m++;\\n                }\\n            }\\n        }\\n        // Add all garbages to the final answer\\n        ans += (g+m+p);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404440,
                "title": "simple-c-code-by-fun2s",
                "content": "\\n\\n# C++ CODE \\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& t) {\\n        \\n        int n=garbage.size();\\n        int count=0;\\n        vector<int>travel;\\n        travel.push_back(0);\\n        for(int i=0;i<t.size();i++){\\n            travel.push_back(t[i]);\\n        }\\n        bool visitedP=0,visitedG=0,visitedM=0;\\n        for(int i=n-1;i>=0;i--){\\n             for(int j=0;j<garbage[i].size();j++){\\n            if(garbage[i][j]==\\'P\\'){\\n                count++;\\n                visitedP=1;\\n            }\\n        \\n             }\\n             if(visitedP)\\n             count+=travel[i];\\n            //  else continue;\\n             \\n        }\\n         for(int i=n-1;i>=0;i--){\\n             for(int j=0;j<garbage[i].size();j++){\\n            if(garbage[i][j]==\\'G\\'){\\n                count++;\\n                visitedG=1;\\n            }\\n             }\\n             if(visitedG)\\n             count+=travel[i];\\n            //  else continue;\\n        }\\n         for(int i=n-1;i>=0;i--){\\n             for(int j=0;j<garbage[i].size();j++){\\n            if(garbage[i][j]==\\'M\\'){\\n                count++;\\n                visitedM=1;\\n            }\\n             }\\n             if(visitedM)\\n             count+=travel[i];\\n            //  else continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& t) {\\n        \\n        int n=garbage.size();\\n        int count=0;\\n        vector<int>travel;\\n        travel.push_back(0);\\n        for(int i=0;i<t.size();i++){\\n            travel.push_back(t[i]);\\n        }\\n        bool visitedP=0,visitedG=0,visitedM=0;\\n        for(int i=n-1;i>=0;i--){\\n             for(int j=0;j<garbage[i].size();j++){\\n            if(garbage[i][j]==\\'P\\'){\\n                count++;\\n                visitedP=1;\\n            }\\n        \\n             }\\n             if(visitedP)\\n             count+=travel[i];\\n            //  else continue;\\n             \\n        }\\n         for(int i=n-1;i>=0;i--){\\n             for(int j=0;j<garbage[i].size();j++){\\n            if(garbage[i][j]==\\'G\\'){\\n                count++;\\n                visitedG=1;\\n            }\\n             }\\n             if(visitedG)\\n             count+=travel[i];\\n            //  else continue;\\n        }\\n         for(int i=n-1;i>=0;i--){\\n             for(int j=0;j<garbage[i].size();j++){\\n            if(garbage[i][j]==\\'M\\'){\\n                count++;\\n                visitedM=1;\\n            }\\n             }\\n             if(visitedM)\\n             count+=travel[i];\\n            //  else continue;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403661,
                "title": "fully-explained-python",
                "content": "# Intuition\\nWe only want to consider going till last house if we keep getting the garbage according to truck else dont consider going upto that house.\\n`eg -> G P GP PP`\\nthe G truck wont go till last as there is no G type of garbage to collect so time travel to going till last house wont be considered for G type truck but\\n`eg -> G P GP PP PM GM MM`\\nif G is found later on we have to consider all the time required to reach upto that house\\n`why? because in question we are asked to maintain the order of visit, i.e to visit the later specific house we need to visit all in the route.`\\nso we maintain a curr time and a maxtime\\ncurr time will store all the travel time required\\nif on reaching certain house we find the type of garbage collected by the truck update the maxtime for the specific truck\\n`maxtime = currtime (travel time to reach till there) + count of garbage(count * 1 min)`\\nand update curr time \\nreturn the sum of maxtime of all trucks as the min time required\\n# Code\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        currTimeG = 0\\n        currTimeP = 0\\n        currTimeM = 0\\n        travel = [0] + travel\\n        maxTimeM, maxTimeP, maxTimeG = 0, 0, 0\\n        for i, char in enumerate(garbage):\\n            currTimeG += travel[i]\\n            currTimeP += travel[i]\\n            currTimeM += travel[i]\\n            if char.count(\\'G\\') > 0:\\n                maxTimeG = char.count(\\'G\\') + currTimeG\\n                currTimeG = maxTimeG\\n            if char.count(\\'P\\') > 0:\\n                maxTimeP = char.count(\\'P\\') + currTimeP\\n                currTimeP = maxTimeP\\n            if char.count(\\'M\\') > 0:\\n                maxTimeM = char.count(\\'M\\') + currTimeM\\n                currTimeM = maxTimeM\\n        return (maxTimeM + maxTimeG + maxTimeP)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        currTimeG = 0\\n        currTimeP = 0\\n        currTimeM = 0\\n        travel = [0] + travel\\n        maxTimeM, maxTimeP, maxTimeG = 0, 0, 0\\n        for i, char in enumerate(garbage):\\n            currTimeG += travel[i]\\n            currTimeP += travel[i]\\n            currTimeM += travel[i]\\n            if char.count(\\'G\\') > 0:\\n                maxTimeG = char.count(\\'G\\') + currTimeG\\n                currTimeG = maxTimeG\\n            if char.count(\\'P\\') > 0:\\n                maxTimeP = char.count(\\'P\\') + currTimeP\\n                currTimeP = maxTimeP\\n            if char.count(\\'M\\') > 0:\\n                maxTimeM = char.count(\\'M\\') + currTimeM\\n                currTimeM = maxTimeM\\n        return (maxTimeM + maxTimeG + maxTimeP)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403342,
                "title": "easy-explanation-beginner-level-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Hashmap\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char,vector<int>>mp;\\n\\n        for(int i = 0 ; i<garbage.size() ; i++){\\n            for(int j = 0 ; j < garbage[i].size() ; j++){\\n                mp[garbage[i][j]].push_back(i);\\n            }\\n        }\\n\\n        int n = travel.size();\\n        vector<int>fair(n+1,0);\\n        for(int i = 1 ; i<=n ; i++){\\n            fair[i] = travel[i-1]+fair[i-1];\\n        }\\n        int time = 0;\\n\\n        for(auto it: mp){\\n            time += (it.second.size());\\n            time += fair[it.second[it.second.size()-1]];\\n        }\\n\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char,vector<int>>mp;\\n\\n        for(int i = 0 ; i<garbage.size() ; i++){\\n            for(int j = 0 ; j < garbage[i].size() ; j++){\\n                mp[garbage[i][j]].push_back(i);\\n            }\\n        }\\n\\n        int n = travel.size();\\n        vector<int>fair(n+1,0);\\n        for(int i = 1 ; i<=n ; i++){\\n            fair[i] = travel[i-1]+fair[i-1];\\n        }\\n        int time = 0;\\n\\n        for(auto it: mp){\\n            time += (it.second.size());\\n            time += fair[it.second[it.second.size()-1]];\\n        }\\n\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363533,
                "title": "c-easy-solution-100-beat-in-runtime-100-beat-in-memory",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public void TotalGarbage(string garbage, int[] count)\\n    {\\n        for(int i = 0; i < garbage.Length; i++) \\n        {\\n            if(garbage[i] == \\'G\\') count[0]++;\\n            else if(garbage[i] == \\'P\\') count[1]++;\\n            else count[2]++;\\n        }\\n    }\\n\\n    public int GarbageCollection(string[] garbage, int[] travel) \\n    {\\n        int[] highestVisit = new int[3];\\n        int[] count = new int[3];\\n        int[] allHouseVisit = new int[garbage.Length];\\n        int totalTime = 0;\\n\\n        for(int i = garbage.Length - 1; i >= 0; i--)\\n        {\\n            TotalGarbage(garbage[i], count);\\n            for(int j = 0; j < 3; j++) if(count[j] > 0 && highestVisit[j] == 0) highestVisit[j] = i;\\n        }\\n        \\n        allHouseVisit[0] = 0;\\n\\n        for(int i = 0; i < travel.Length; i++)\\n        {\\n            allHouseVisit[i + 1] = travel[i] + allHouseVisit[i];\\n        }\\n\\n        for(int i = 0; i < 3; i++) totalTime += count[i] + allHouseVisit[highestVisit[i]];\\n\\n        return totalTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public void TotalGarbage(string garbage, int[] count)\\n    {\\n        for(int i = 0; i < garbage.Length; i++) \\n        {\\n            if(garbage[i] == \\'G\\') count[0]++;\\n            else if(garbage[i] == \\'P\\') count[1]++;\\n            else count[2]++;\\n        }\\n    }\\n\\n    public int GarbageCollection(string[] garbage, int[] travel) \\n    {\\n        int[] highestVisit = new int[3];\\n        int[] count = new int[3];\\n        int[] allHouseVisit = new int[garbage.Length];\\n        int totalTime = 0;\\n\\n        for(int i = garbage.Length - 1; i >= 0; i--)\\n        {\\n            TotalGarbage(garbage[i], count);\\n            for(int j = 0; j < 3; j++) if(count[j] > 0 && highestVisit[j] == 0) highestVisit[j] = i;\\n        }\\n        \\n        allHouseVisit[0] = 0;\\n\\n        for(int i = 0; i < travel.Length; i++)\\n        {\\n            allHouseVisit[i + 1] = travel[i] + allHouseVisit[i];\\n        }\\n\\n        for(int i = 0; i < 3; i++) totalTime += count[i] + allHouseVisit[highestVisit[i]];\\n\\n        return totalTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301490,
                "title": "c-easy-way-beginner-friendly-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n       unordered_map<char,int>ump;\\n       int totalMin=0;\\n       int G=-1,M=-1,P=-1;\\n       int indx=0;\\n        // to add the values in the hash map\\n       for(auto g:garbage){\\n           for(int i=0;i<g.size();i++){\\n               ump[g[i]]+=1;\\n                //to find out the index of the values..\\n               if(g[i]==\\'G\\'){\\n                   G=indx;\\n               }\\n               \\n               if(g[i]==\\'M\\'){\\n                   M=indx;\\n               }\\n\\n               if(g[i]==\\'P\\'){\\n                   P=indx;\\n               }\\n           }\\n                indx++;\\n       }\\n           // cout<<P<<\" \"<<M<<\" \"<<G<<endl;\\n       \\n    //    for(auto &it:ump){\\n    //        cout<<it.first<<\" \"<<it.second<<endl;\\n    //    }\\n    if(P !=-1){\\n        for(int i=P-1;i>=0;i--){\\n            totalMin +=travel[i];\\n        }\\n    }\\n    if(M!=-1){\\n        for(int i=M-1;i>=0;i--){\\n            totalMin +=travel[i];\\n        }\\n    }\\n    if(G!=-1){\\n        for(int i=G-1;i>=0;i--){\\n            totalMin +=travel[i];\\n        }\\n    }\\n    for(auto it:ump){\\n        totalMin+=it.second;\\n    }\\n\\n\\n       return totalMin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n       unordered_map<char,int>ump;\\n       int totalMin=0;\\n       int G=-1,M=-1,P=-1;\\n       int indx=0;\\n        // to add the values in the hash map\\n       for(auto g:garbage){\\n           for(int i=0;i<g.size();i++){\\n               ump[g[i]]+=1;\\n                //to find out the index of the values..\\n               if(g[i]==\\'G\\'){\\n                   G=indx;\\n               }\\n               \\n               if(g[i]==\\'M\\'){\\n                   M=indx;\\n               }\\n\\n               if(g[i]==\\'P\\'){\\n                   P=indx;\\n               }\\n           }\\n                indx++;\\n       }\\n           // cout<<P<<\" \"<<M<<\" \"<<G<<endl;\\n       \\n    //    for(auto &it:ump){\\n    //        cout<<it.first<<\" \"<<it.second<<endl;\\n    //    }\\n    if(P !=-1){\\n        for(int i=P-1;i>=0;i--){\\n            totalMin +=travel[i];\\n        }\\n    }\\n    if(M!=-1){\\n        for(int i=M-1;i>=0;i--){\\n            totalMin +=travel[i];\\n        }\\n    }\\n    if(G!=-1){\\n        for(int i=G-1;i>=0;i--){\\n            totalMin +=travel[i];\\n        }\\n    }\\n    for(auto it:ump){\\n        totalMin+=it.second;\\n    }\\n\\n\\n       return totalMin;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3299398,
                "title": "brute-force-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        //we will make a vector of prefix vector\\n         vector<int>prefix;\\n         prefix.push_back(travel[0]);\\n         for(int i=1;i<travel.size();i++)\\n         {\\n             prefix.push_back(prefix[i-1]+travel[i]);\\n         }\\n         //we need to know about the last position till we are\\n         //getting the metal paper and glass garbage\\n  \\n         //the three index will keep the track of the last index \\n         //at which metal or glass paper garbage exist\\n         int metal = INT_MIN;\\n         int glass = INT_MIN;\\n         int paper = INT_MIN;\\n\\n         //we will store \\n         vector<unordered_map<char,int>>v(garbage.size());\\n\\n         for(int i=0;i<garbage.size();i++)\\n         {\\n             string str = garbage[i];\\n             for(int j=0;j<str.length();j++)\\n             {\\n                 if(str[j] == \\'G\\') glass = max(glass,i);\\n                 else if(str[j] == \\'M\\') metal = max(metal,i);\\n                 else if(str[j] == \\'P\\') paper = max(paper ,i);\\n\\n                 v[i][str[j]]++;\\n             }\\n         }\\n         //making the prefix sum \\n         int time = 0;\\n\\n         //making ans for the glass truck\\n         if(glass == 0)\\n         {\\n             time = time + v[0][\\'G\\'];\\n         }\\n         else if(glass > 0)\\n         {\\n             time = time + prefix[glass-1];\\n             for(int i=0;i<=glass;i++)\\n             {\\n                 time = time + v[i][\\'G\\'];\\n             }\\n         }\\n        \\n        //making the ans for the paper truck\\n         if(paper == 0)\\n         {\\n             time = time + v[0][\\'P\\'];\\n         }\\n         else if(paper > 0)\\n         {\\n             time = time + prefix[paper-1];\\n             for(int i=0;i<=paper;i++)\\n             {\\n                 time = time + v[i][\\'P\\'];\\n             }\\n         }\\n\\n         //making the ans for the metal truck\\n         if(metal == 0)\\n         {\\n             time = time + v[0][\\'M\\'];\\n         }\\n         else if(metal > 0)\\n         {\\n             time = time + prefix[metal-1];\\n             for(int i=0;i<=metal;i++)\\n             {\\n                 time = time + v[i][\\'M\\'];\\n             }\\n         }\\n\\n        return time;\\n             \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        //we will make a vector of prefix vector\\n         vector<int>prefix;\\n         prefix.push_back(travel[0]);\\n         for(int i=1;i<travel.size();i++)\\n         {\\n             prefix.push_back(prefix[i-1]+travel[i]);\\n         }\\n         //we need to know about the last position till we are\\n         //getting the metal paper and glass garbage\\n  \\n         //the three index will keep the track of the last index \\n         //at which metal or glass paper garbage exist\\n         int metal = INT_MIN;\\n         int glass = INT_MIN;\\n         int paper = INT_MIN;\\n\\n         //we will store \\n         vector<unordered_map<char,int>>v(garbage.size());\\n\\n         for(int i=0;i<garbage.size();i++)\\n         {\\n             string str = garbage[i];\\n             for(int j=0;j<str.length();j++)\\n             {\\n                 if(str[j] == \\'G\\') glass = max(glass,i);\\n                 else if(str[j] == \\'M\\') metal = max(metal,i);\\n                 else if(str[j] == \\'P\\') paper = max(paper ,i);\\n\\n                 v[i][str[j]]++;\\n             }\\n         }\\n         //making the prefix sum \\n         int time = 0;\\n\\n         //making ans for the glass truck\\n         if(glass == 0)\\n         {\\n             time = time + v[0][\\'G\\'];\\n         }\\n         else if(glass > 0)\\n         {\\n             time = time + prefix[glass-1];\\n             for(int i=0;i<=glass;i++)\\n             {\\n                 time = time + v[i][\\'G\\'];\\n             }\\n         }\\n        \\n        //making the ans for the paper truck\\n         if(paper == 0)\\n         {\\n             time = time + v[0][\\'P\\'];\\n         }\\n         else if(paper > 0)\\n         {\\n             time = time + prefix[paper-1];\\n             for(int i=0;i<=paper;i++)\\n             {\\n                 time = time + v[i][\\'P\\'];\\n             }\\n         }\\n\\n         //making the ans for the metal truck\\n         if(metal == 0)\\n         {\\n             time = time + v[0][\\'M\\'];\\n         }\\n         else if(metal > 0)\\n         {\\n             time = time + prefix[metal-1];\\n             for(int i=0;i<=metal;i++)\\n             {\\n                 time = time + v[i][\\'M\\'];\\n             }\\n         }\\n\\n        return time;\\n             \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298549,
                "title": "c-easy-explained-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nThe function first counts the number of each type of garbage in all locations. It then iterates through each location and collects the garbage, updating the total distance traveled accordingly. If there is any garbage left in a location after it has been collected, the function calculates the distance traveled to the next location and adds it to the total distance traveled.\\n\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int gtm = 0, gtp = 0, gtg = 0;\\n        int summ = 0, sump = 0, sumg = 0;\\n        for (auto x : garbage) {\\n            for (auto y : x) {\\n                if (y == \\'G\\') sumg++;\\n                else if (y == \\'P\\') sump++;\\n                else if (y == \\'M\\') summ++;\\n            }\\n        }\\n        int i = 0;\\n        for (auto x : garbage) {\\n            for (auto y : x) \\n                if (y == \\'G\\') gtg++,sumg--;\\n                else if (y == \\'M\\') gtm++, summ--;\\n                else if (y == \\'P\\') gtp++, sump--;\\n            if (sumg > 0)\\n                gtg += travel[i];\\n            if (summ > 0)\\n                gtm += travel[i];\\n            if (sump > 0)\\n                gtp += travel[i];\\n            i++;\\n        }\\n        return gtm + gtg + gtp;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int gtm = 0, gtp = 0, gtg = 0;\\n        int summ = 0, sump = 0, sumg = 0;\\n        for (auto x : garbage) {\\n            for (auto y : x) {\\n                if (y == \\'G\\') sumg++;\\n                else if (y == \\'P\\') sump++;\\n                else if (y == \\'M\\') summ++;\\n            }\\n        }\\n        int i = 0;\\n        for (auto x : garbage) {\\n            for (auto y : x) \\n                if (y == \\'G\\') gtg++,sumg--;\\n                else if (y == \\'M\\') gtm++, summ--;\\n                else if (y == \\'P\\') gtp++, sump--;\\n            if (sumg > 0)\\n                gtg += travel[i];\\n            if (summ > 0)\\n                gtm += travel[i];\\n            if (sump > 0)\\n                gtp += travel[i];\\n            i++;\\n        }\\n        return gtm + gtg + gtp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147865,
                "title": "o-1-space-o-n-10-time",
                "content": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //a truck will stop if it finds no garbage further\\n        //Prefix Sum Question\\n        int n = travel.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            travel[i] = travel[i] + travel[i-1];\\n        }\\n        //time to collect 1 unit of garbage = 1 so total time = total unit of garbages\\n        int ans = 0;\\n        int gl = garbage.size();\\n        for(int i=0;i<gl;i++)\\n        {\\n            ans+=garbage[i].size();\\n        }\\n        //Finding last indices of each type of garbage\\n        int p=0;\\n        int g=0;\\n        int m=0;\\n        for(int i=1;i<gl;i++) //starting from 1 because trucks already at 0\\n        {\\n            string s = garbage[i];\\n            bool p1=false;\\n            bool g1=false;\\n            bool m1=false;\\n            for(int j =0;j<s.size();j++)\\n            {\\n                if(s[j]==\\'P\\')\\n                    p1=true;\\n                if(s[j]==\\'G\\')\\n                    g1=true;\\n                if(s[j]==\\'M\\')\\n                    m1=true;\\n            }\\n            if(p1) p=i;\\n            if(g1) g=i;\\n            if(m1) m=i;\\n        }\\n        if(p) ans+=travel[p-1];\\n        if(g) ans+=travel[g-1];\\n        if(m) ans+=travel[m-1];\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //a truck will stop if it finds no garbage further\\n        //Prefix Sum Question\\n        int n = travel.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            travel[i] = travel[i] + travel[i-1];\\n        }\\n        //time to collect 1 unit of garbage = 1 so total time = total unit of garbages\\n        int ans = 0;\\n        int gl = garbage.size();\\n        for(int i=0;i<gl;i++)\\n        {\\n            ans+=garbage[i].size();\\n        }\\n        //Finding last indices of each type of garbage\\n        int p=0;\\n        int g=0;\\n        int m=0;\\n        for(int i=1;i<gl;i++) //starting from 1 because trucks already at 0\\n        {\\n            string s = garbage[i];\\n            bool p1=false;\\n            bool g1=false;\\n            bool m1=false;\\n            for(int j =0;j<s.size();j++)\\n            {\\n                if(s[j]==\\'P\\')\\n                    p1=true;\\n                if(s[j]==\\'G\\')\\n                    g1=true;\\n                if(s[j]==\\'M\\')\\n                    m1=true;\\n            }\\n            if(p1) p=i;\\n            if(g1) g=i;\\n            if(m1) m=i;\\n        }\\n        if(p) ans+=travel[p-1];\\n        if(g) ans+=travel[g-1];\\n        if(m) ans+=travel[m-1];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3140305,
                "title": "simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& g, vector<int>& t) {\\n        int n = t.size();\\n        vector<int> v(n+1);\\n        v[0] = 0;\\n        \\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i] = t[i-1];\\n        }\\n        \\n        \\n        \\n        int res = 0;\\n        \\n        int temp=0;\\n         for(int i =0;i<g.size();i++)\\n        {\\n             temp+=v[i];\\n            if(g[i].find(\\'P\\')!=-1)\\n            {\\n                int c = count(g[i].begin(),g[i].end(),\\'P\\');\\n                res+=c;\\n                res+=temp;\\n                temp=0;\\n                \\n            }\\n        }\\n        \\n        temp=0;\\n        for(int i =0;i<g.size();i++)\\n        {\\n            temp+=v[i];\\n            if(g[i].find(\\'G\\')!=-1)\\n            {\\n                int c = count(g[i].begin(),g[i].end(),\\'G\\');\\n                res+=c;\\n                res+=temp;\\n                temp=0;\\n                \\n            }\\n            \\n        }\\n        \\n        temp=0;\\n        for(int i =0;i<g.size();i++)\\n        {\\n            temp+=v[i];\\n            if(g[i].find(\\'M\\')!=-1)\\n            {\\n                int c = count(g[i].begin(),g[i].end(),\\'M\\');\\n                res+=c;\\n                res+=temp;\\n                temp=0;\\n                \\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& g, vector<int>& t) {\\n        int n = t.size();\\n        vector<int> v(n+1);\\n        v[0] = 0;\\n        \\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i] = t[i-1];\\n        }\\n        \\n        \\n        \\n        int res = 0;\\n        \\n        int temp=0;\\n         for(int i =0;i<g.size();i++)\\n        {\\n             temp+=v[i];\\n            if(g[i].find(\\'P\\')!=-1)\\n            {\\n                int c = count(g[i].begin(),g[i].end(),\\'P\\');\\n                res+=c;\\n                res+=temp;\\n                temp=0;\\n                \\n            }\\n        }\\n        \\n        temp=0;\\n        for(int i =0;i<g.size();i++)\\n        {\\n            temp+=v[i];\\n            if(g[i].find(\\'G\\')!=-1)\\n            {\\n                int c = count(g[i].begin(),g[i].end(),\\'G\\');\\n                res+=c;\\n                res+=temp;\\n                temp=0;\\n                \\n            }\\n            \\n        }\\n        \\n        temp=0;\\n        for(int i =0;i<g.size();i++)\\n        {\\n            temp+=v[i];\\n            if(g[i].find(\\'M\\')!=-1)\\n            {\\n                int c = count(g[i].begin(),g[i].end(),\\'M\\');\\n                res+=c;\\n                res+=temp;\\n                temp=0;\\n                \\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088164,
                "title": "time-complexity-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    func garbageCollection(_ garbage: [String], _ travel: [Int]) -> Int {\\n        var totalTime = 0\\n        var end = garbage.count - 1\\n        var p = 0\\n        var g = 0\\n        var m = 0\\n\\n        while end >= 0 {\\n            let string = garbage[end]\\n            var pickCount = 0\\n\\n            string.forEach {\\n                if $0 == \"M\" {\\n                    m = max(m, end)\\n                } else if $0 == \"G\" {\\n                    g = max(g, end)\\n                } else {\\n                    p = max(p, end)\\n                }\\n                pickCount += 1\\n            }\\n            \\n            var type = 0\\n\\n            type += m >= end ? 1 : 0\\n            type += g >= end ? 1 : 0\\n            type += p >= end ? 1 : 0\\n            totalTime += end == 0 ? pickCount : pickCount + type * travel[end - 1]\\n            \\n            end -= 1\\n        }\\n        \\n        return totalTime\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func garbageCollection(_ garbage: [String], _ travel: [Int]) -> Int {\\n        var totalTime = 0\\n        var end = garbage.count - 1\\n        var p = 0\\n        var g = 0\\n        var m = 0\\n\\n        while end >= 0 {\\n            let string = garbage[end]\\n            var pickCount = 0\\n\\n            string.forEach {\\n                if $0 == \"M\" {\\n                    m = max(m, end)\\n                } else if $0 == \"G\" {\\n                    g = max(g, end)\\n                } else {\\n                    p = max(p, end)\\n                }\\n                pickCount += 1\\n            }\\n            \\n            var type = 0\\n\\n            type += m >= end ? 1 : 0\\n            type += g >= end ? 1 : 0\\n            type += p >= end ? 1 : 0\\n            totalTime += end == 0 ? pickCount : pickCount + type * travel[end - 1]\\n            \\n            end -= 1\\n        }\\n        \\n        return totalTime\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054083,
                "title": "easy-solution-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<garbage.size();i++){\\n            for(int j=0;j<garbage[i].length();j++){\\n                m[garbage[i][j]]++;\\n            }\\n        }\\n        for(auto it=m.begin();it!=m.end();it++){\\n            char ch=it->first;\\n            int curr=0;\\n            for(int i=0;i<garbage.size();i++){\\n                for(int j=0;j<garbage[i].length();j++){\\n                    if(garbage[i][j]==ch){\\n                        curr++;\\n                        m[ch]--;\\n                    }\\n                }\\n                if(i==0 && m[ch]==0){\\n                    break;\\n                }\\n                if(i!=0 && m[ch]>=0){\\n                    curr+=travel[i-1];\\n                    if(m[ch]==0)break;\\n                }\\n            }\\n            cout<<curr;\\n            ans+=curr;\\n            \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        map<char,int>m;\\n        int ans=0;\\n        for(int i=0;i<garbage.size();i++){\\n            for(int j=0;j<garbage[i].length();j++){\\n                m[garbage[i][j]]++;\\n            }\\n        }\\n        for(auto it=m.begin();it!=m.end();it++){\\n            char ch=it->first;\\n            int curr=0;\\n            for(int i=0;i<garbage.size();i++){\\n                for(int j=0;j<garbage[i].length();j++){\\n                    if(garbage[i][j]==ch){\\n                        curr++;\\n                        m[ch]--;\\n                    }\\n                }\\n                if(i==0 && m[ch]==0){\\n                    break;\\n                }\\n                if(i!=0 && m[ch]>=0){\\n                    curr+=travel[i-1];\\n                    if(m[ch]==0)break;\\n                }\\n            }\\n            cout<<curr;\\n            ans+=curr;\\n            \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3040577,
                "title": "ruby-solution",
                "content": "```\\ndef garbage_collection(garbage, travel)\\n    time = 0\\n    [\\'M\\', \\'G\\', \\'P\\'].each do |type|\\n        house = garbage.size - 1\\n        house -= 1 while garbage[house].count(type) == 0 && house >= 0 # find furthest house where this garbage appears\\n        next if house < 0\\n\\t\\t\\n        time += travel[0..house - 1].sum unless house == 0 # add up all travel times\\n        garbage[0..house].each { |h| time += h.count(type) } # add a minute for each occurence of this garbage type\\n    end\\n\\n    time\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef garbage_collection(garbage, travel)\\n    time = 0\\n    [\\'M\\', \\'G\\', \\'P\\'].each do |type|\\n        house = garbage.size - 1\\n        house -= 1 while garbage[house].count(type) == 0 && house >= 0 # find furthest house where this garbage appears\\n        next if house < 0\\n\\t\\t\\n        time += travel[0..house - 1].sum unless house == 0 # add up all travel times\\n        garbage[0..house].each { |h| time += h.count(type) } # add a minute for each occurence of this garbage type\\n    end\\n\\n    time\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3023271,
                "title": "easily-understandable-java-beats-100-easy-explanation",
                "content": "Assume Every house has GPM till the end and count total time\\n\\nThen Start from last Node, Check if the Waste(G,P,M) is there or not\\nIf not there remove the time added for it.\\nif there stop checking further as the driver has to go till there \\n\\nTime Complexity : O(n) \\nSpace Complexity : O(n)\\n# Code\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int len=garbage.length;\\n       int time=garbage[0].length();\\n       for(int i=1;i<garbage.length;i++)\\n       {\\n          time+=garbage[i].length();\\n          time+=3*travel[i-1];\\n       }\\n       boolean g=garbage[len-1].contains(\"G\");\\n       boolean p=garbage[len-1].contains(\"P\");\\n       boolean m=garbage[len-1].contains(\"M\");\\n       int t=garbage.length-1;\\n       while(g==false)\\n       {\\n           if(t==0)\\n           break;\\n           if(garbage[t].contains(\"G\"))\\n            break;\\n            else\\n            time-=travel[t-1];\\n            t--;\\n       }\\n       t=len-1;\\n       while(p==false)\\n       {\\n           if(t==0)\\n           break;\\n            if(garbage[t].contains(\"P\"))\\n            break;\\n            else\\n            time-=travel[t-1];\\n            t--;\\n       }\\n       t=len-1;\\n       while(m==false)\\n       {\\n           if(t==0)\\n           break;\\n            if(garbage[t].contains(\"M\"))\\n            break;\\n            else\\n            time-=travel[t-1];\\n            t--;\\n       }\\n       return time;\\n    }\\n}\\n```\\nplease upvote if you find it useful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int len=garbage.length;\\n       int time=garbage[0].length();\\n       for(int i=1;i<garbage.length;i++)\\n       {\\n          time+=garbage[i].length();\\n          time+=3*travel[i-1];\\n       }\\n       boolean g=garbage[len-1].contains(\"G\");\\n       boolean p=garbage[len-1].contains(\"P\");\\n       boolean m=garbage[len-1].contains(\"M\");\\n       int t=garbage.length-1;\\n       while(g==false)\\n       {\\n           if(t==0)\\n           break;\\n           if(garbage[t].contains(\"G\"))\\n            break;\\n            else\\n            time-=travel[t-1];\\n            t--;\\n       }\\n       t=len-1;\\n       while(p==false)\\n       {\\n           if(t==0)\\n           break;\\n            if(garbage[t].contains(\"P\"))\\n            break;\\n            else\\n            time-=travel[t-1];\\n            t--;\\n       }\\n       t=len-1;\\n       while(m==false)\\n       {\\n           if(t==0)\\n           break;\\n            if(garbage[t].contains(\"M\"))\\n            break;\\n            else\\n            time-=travel[t-1];\\n            t--;\\n       }\\n       return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940390,
                "title": "c-o-n-easy-solution-using-unordered-map",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans = 0;\\n        ans += garbage[0].size();\\n        for(int i = 1; i < travel.size(); i++) travel[i] += travel[i-1];\\n        unordered_map<int, pair<int, int>> mp;\\n\\n        for(int i = 1; i < garbage.size(); i++) {\\n            for(int j = 0; j < garbage[i].size(); j++) {\\n                mp[garbage[i][j] - \\'A\\'].first++; //frequency of respective garbage type\\n                mp[garbage[i][j] - \\'A\\'].second = i; //last index of respective garbage type\\n            }\\n        }\\n        if(mp[6].second != 0) ans += mp[6].first+travel[mp[6].second-1]; //for G\\n        if(mp[12].second != 0) ans += mp[12].first+travel[mp[12].second-1]; //for M\\n        if(mp[15].second != 0) ans += mp[15].first+travel[mp[15].second-1]; //for P\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans = 0;\\n        ans += garbage[0].size();\\n        for(int i = 1; i < travel.size(); i++) travel[i] += travel[i-1];\\n        unordered_map<int, pair<int, int>> mp;\\n\\n        for(int i = 1; i < garbage.size(); i++) {\\n            for(int j = 0; j < garbage[i].size(); j++) {\\n                mp[garbage[i][j] - \\'A\\'].first++; //frequency of respective garbage type\\n                mp[garbage[i][j] - \\'A\\'].second = i; //last index of respective garbage type\\n            }\\n        }\\n        if(mp[6].second != 0) ans += mp[6].first+travel[mp[6].second-1]; //for G\\n        if(mp[12].second != 0) ans += mp[12].first+travel[mp[12].second-1]; //for M\\n        if(mp[15].second != 0) ans += mp[15].first+travel[mp[15].second-1]; //for P\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909884,
                "title": "easy-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char,int> m;\\n\\n       unordered_map<char,int> house;\\n        vector<char> vec{\\'M\\',\\'G\\',\\'P\\'};\\n        \\n\\n        for(auto ele:vec){\\n           \\n           for(int i=0;i<garbage.size();i++){\\n               for(auto j:garbage[i]){\\n                   if(ele==j) house[ele]=i;\\n               }\\n           }\\n\\n        }\\n        \\n        int ans=0;\\n\\n        for(auto ele:vec){\\n\\n            for(int i=0;i<garbage.size();i++){\\n\\n                if(house[ele]>=i){\\n\\n                    int count=0;\\n\\n                    for(auto k:garbage[i]){\\n                        if(ele==k) count++;\\n                    }\\n                    if(i==0) ans+=count;\\n\\n                    else ans+=count+travel[i-1];\\n\\n                }\\n            }\\n        }\\n        \\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char,int> m;\\n\\n       unordered_map<char,int> house;\\n        vector<char> vec{\\'M\\',\\'G\\',\\'P\\'};\\n        \\n\\n        for(auto ele:vec){\\n           \\n           for(int i=0;i<garbage.size();i++){\\n               for(auto j:garbage[i]){\\n                   if(ele==j) house[ele]=i;\\n               }\\n           }\\n\\n        }\\n        \\n        int ans=0;\\n\\n        for(auto ele:vec){\\n\\n            for(int i=0;i<garbage.size();i++){\\n\\n                if(house[ele]>=i){\\n\\n                    int count=0;\\n\\n                    for(auto k:garbage[i]){\\n                        if(ele==k) count++;\\n                    }\\n                    if(i==0) ans+=count;\\n\\n                    else ans+=count+travel[i-1];\\n\\n                }\\n            }\\n        }\\n        \\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902078,
                "title": "easy-prefix-sum-c-solution-98-faster-with-time-and-space-complexity",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        int ans=0,sum=0,m=-1,p=-1,g=-1;\\n        vector<int> pre;\\n        pre.push_back(0);\\n        for(auto x:travel)\\n        {\\n          sum+=x;\\n          pre.push_back(sum);\\n        }\\n        for(int i=0;i<garbage.size();i++)\\n        { \\n            ans+=garbage[i].size();\\n            for(auto x:garbage[i])\\n            {\\n              if(x==\\'M\\')\\n              {\\n                m=i;\\n              }\\n              if(x==\\'P\\')\\n              {\\n                p=i;\\n              }\\n              if(x==\\'G\\')\\n              {\\n                g=i;\\n              }\\n            } \\n        }\\n        if(m!=-1) ans+=pre[m];\\n        if(p!=-1) ans+=pre[p];\\n        if(g!=-1) ans+=pre[g];\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        int ans=0,sum=0,m=-1,p=-1,g=-1;\\n        vector<int> pre;\\n        pre.push_back(0);\\n        for(auto x:travel)\\n        {\\n          sum+=x;\\n          pre.push_back(sum);\\n        }\\n        for(int i=0;i<garbage.size();i++)\\n        { \\n            ans+=garbage[i].size();\\n            for(auto x:garbage[i])\\n            {\\n              if(x==\\'M\\')\\n              {\\n                m=i;\\n              }\\n              if(x==\\'P\\')\\n              {\\n                p=i;\\n              }\\n              if(x==\\'G\\')\\n              {\\n                g=i;\\n              }\\n            } \\n        }\\n        if(m!=-1) ans+=pre[m];\\n        if(p!=-1) ans+=pre[p];\\n        if(g!=-1) ans+=pre[g];\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776725,
                "title": "javascript-beginner-friendly-solution",
                "content": "```\\nvar garbageCollection = function(garbage, travel) {\\n    let time = 0;\\n    let carM = 0;\\n    let carG = 0;\\n    let carP = 0;\\n    for(let i=0; i<garbage.length; i++) {\\n        for(let j=0; j<garbage[i].length; j++) {\\n            let garbageType = garbage[i];\\n            if(garbageType[j] === \"M\") {\\n                time += 1;\\n            }\\n            if(garbageType[j] === \"P\") {\\n                time += 1;\\n            }\\n            if(garbageType[j] === \"G\") {\\n                time += 1;\\n            }\\n        }\\n        if(garbage[i].includes(\"M\")) {\\n            for(let k=carM; k<i; k++) {\\n                time += travel[k];\\n            }\\n            carM=i;\\n        }\\n        if(garbage[i].includes(\"P\")) {\\n            for(let k=carP; k<i; k++) {\\n                time += travel[k];\\n            }\\n            carP=i;\\n        }\\n        if(garbage[i].includes(\"G\")) {\\n            for(let k=carG; k<i; k++) {\\n                time += travel[k];\\n            }\\n            carG=i;\\n        }\\n    }\\n    return time;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar garbageCollection = function(garbage, travel) {\\n    let time = 0;\\n    let carM = 0;\\n    let carG = 0;\\n    let carP = 0;\\n    for(let i=0; i<garbage.length; i++) {\\n        for(let j=0; j<garbage[i].length; j++) {\\n            let garbageType = garbage[i];\\n            if(garbageType[j] === \"M\") {\\n                time += 1;\\n            }\\n            if(garbageType[j] === \"P\") {\\n                time += 1;\\n            }\\n            if(garbageType[j] === \"G\") {\\n                time += 1;\\n            }\\n        }\\n        if(garbage[i].includes(\"M\")) {\\n            for(let k=carM; k<i; k++) {\\n                time += travel[k];\\n            }\\n            carM=i;\\n        }\\n        if(garbage[i].includes(\"P\")) {\\n            for(let k=carP; k<i; k++) {\\n                time += travel[k];\\n            }\\n            carP=i;\\n        }\\n        if(garbage[i].includes(\"G\")) {\\n            for(let k=carG; k<i; k++) {\\n                time += travel[k];\\n            }\\n            carG=i;\\n        }\\n    }\\n    return time;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743847,
                "title": "runtime-194-ms-faster-than-99-04-memory-102-2-mb-less-than-48-07-of-c-online-submissions",
                "content": "-> As the garbage truck\\'s job is to collect all the garbage that means every character in the garbage string array will be counted because each of the character shows that it takes 1 min time\\n-> Now modify the travel array to store total number of time to visit each house from house 0 to house n\\n->For each type of garbage, find the house with highest index that has atleast 1 unit of that type of garbage\\n->Now use the modified travel array to get the total amount of time to visit the house and add it to your answer then break (do this for each type of garbage)\\n\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans=0;\\n        for(int i=garbage.size()-1;i>=0;i--)\\n        {\\n            string s=garbage[i];\\n            ans+=s.size();\\n        }\\n        if(t.size()>1)                                // modifying travel array\\n        {\\n         for(int i=0;i<travel.size()-1;i++)\\n         {\\n            travel[i+1]+=travel[i];\\n         }\\n        }\\n        \\n        for(int i=garbage.size()-1;i>0;i--)           //Finding highest index for Glass type garbage\\n        {\\n            string s=garbage[i];\\n            char c=\\'G\\';\\n            if(s.find(c)!=string::npos)\\n            {\\n                ans+=travel[i-1];\\n                break;\\n            }\\n        }\\n        for(int i=garbage.size()-1;i>0;i--)          //Finding highest index for Paper type garbage\\n        {\\n            string s=garbage[i];\\n            char c=\\'P\\';\\n            if(s.find(c)!=string::npos)\\n            {\\n                ans+=travel[i-1];\\n                break;\\n            }\\n        }\\n        for(int i=garbage.size()-1;i>0;i--)          //Finding highest index for Metal type garbage\\n        {\\n            string s=garbage[i];\\n            char c=\\'M\\';\\n            if(s.find(c)!=string::npos)\\n            {\\n                ans+=travel[i-1];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int ans=0;\\n        for(int i=garbage.size()-1;i>=0;i--)\\n        {\\n            string s=garbage[i];\\n            ans+=s.size();\\n        }\\n        if(t.size()>1)                                // modifying travel array\\n        {\\n         for(int i=0;i<travel.size()-1;i++)\\n         {\\n            travel[i+1]+=travel[i];\\n         }\\n        }\\n        \\n        for(int i=garbage.size()-1;i>0;i--)           //Finding highest index for Glass type garbage\\n        {\\n            string s=garbage[i];\\n            char c=\\'G\\';\\n            if(s.find(c)!=string::npos)\\n            {\\n                ans+=travel[i-1];\\n                break;\\n            }\\n        }\\n        for(int i=garbage.size()-1;i>0;i--)          //Finding highest index for Paper type garbage\\n        {\\n            string s=garbage[i];\\n            char c=\\'P\\';\\n            if(s.find(c)!=string::npos)\\n            {\\n                ans+=travel[i-1];\\n                break;\\n            }\\n        }\\n        for(int i=garbage.size()-1;i>0;i--)          //Finding highest index for Metal type garbage\\n        {\\n            string s=garbage[i];\\n            char c=\\'M\\';\\n            if(s.find(c)!=string::npos)\\n            {\\n                ans+=travel[i-1];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729496,
                "title": "97-faster-heavily-commented-o-n-time-o-1-space-clean-code-prefix-sum",
                "content": "```\\nvar garbageCollection = function(garbage, travel) {\\n    \\n    let indxG = -1, indxP = -1, indxM = -1;\\n    let time = 0;\\n    // Prefix sum of travel time\\n    for(let i = 1; i < travel.length; i++){\\n        travel[i] += travel[i-1] \\n    }\\n    // sum up the length of strings in Garbege to compute colletion time\\n    for(let i=0; i < garbage.length; i++){\\n        time += garbage[i].length;\\n\\t\\t// update the last seen index of \\'G\\', \\'P\\' and \\'M\\' garbeges\\n        if(garbage[i].includes(\\'G\\')) indxG = i;\\n        if(garbage[i].includes(\\'P\\')) indxP = i;\\n        if(garbage[i].includes(\\'M\\')) indxM = i;\\n    }\\n    // increament the time with the travel time\\n    if(--indxG >= 0) time += travel[indxG];\\n    if(--indxP >= 0) time += travel[indxP];\\n    if(--indxM >= 0) time += travel[indxM];\\n    return time;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar garbageCollection = function(garbage, travel) {\\n    \\n    let indxG = -1, indxP = -1, indxM = -1;\\n    let time = 0;\\n    // Prefix sum of travel time\\n    for(let i = 1; i < travel.length; i++){\\n        travel[i] += travel[i-1] \\n    }\\n    // sum up the length of strings in Garbege to compute colletion time\\n    for(let i=0; i < garbage.length; i++){\\n        time += garbage[i].length;\\n\\t\\t// update the last seen index of \\'G\\', \\'P\\' and \\'M\\' garbeges\\n        if(garbage[i].includes(\\'G\\')) indxG = i;\\n        if(garbage[i].includes(\\'P\\')) indxP = i;\\n        if(garbage[i].includes(\\'M\\')) indxM = i;\\n    }\\n    // increament the time with the travel time\\n    if(--indxG >= 0) time += travel[indxG];\\n    if(--indxP >= 0) time += travel[indxP];\\n    if(--indxM >= 0) time += travel[indxM];\\n    return time;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2696875,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        m = p = g = -1\\n        self.time = 0\\n        T = [0]\\n        for t in travel: T.append(t)\\n        \\n        for i, house in enumerate(garbage):\\n            if \\'M\\' in house: m = i\\n            if \\'P\\' in house: p = i\\n            if \\'G\\' in house: g = i\\n                \\n        def DFS(type, x):\\n            for i, house in enumerate(garbage):\\n                if i > x: break\\n                self.time += T[i]\\n                if type in house: self.time += house.count(type)\\n        \\n        DFS(\\'M\\', m)\\n        DFS(\\'P\\', p)\\n        DFS(\\'G\\', g)\\n        \\n        return self.time\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        m = p = g = -1\\n        self.time = 0\\n        T = [0]\\n        for t in travel: T.append(t)\\n        \\n        for i, house in enumerate(garbage):\\n            if \\'M\\' in house: m = i\\n            if \\'P\\' in house: p = i\\n            if \\'G\\' in house: g = i\\n                \\n        def DFS(type, x):\\n            for i, house in enumerate(garbage):\\n                if i > x: break\\n                self.time += T[i]\\n                if type in house: self.time += house.count(type)\\n        \\n        DFS(\\'M\\', m)\\n        DFS(\\'P\\', p)\\n        DFS(\\'G\\', g)\\n        \\n        return self.time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663879,
                "title": "rust-22-ms-fastest-100-concise-solution-using-smart-counting-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/815668646/) employs a smart counting technique to calculate total time. It demonstrated **22 ms runtime (100.00%)** and used **9.3 MB memory (25.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::iter::once;\\n\\nimpl Solution \\n{\\n    pub fn garbage_collection(garbage: Vec<String>, travel: Vec<i32>) -> i32 \\n    {\\n        let mut total_time = 0;\\n        \\n        // [1] to detect the last house where each type of garbage\\n        //     was seen, we use binary flags for \\'P\\', \\'G\\' and \\'M\\'\\n        let mut seen_garbage: i32 = 0;\\n        \\n        // [2] iterate over all houses & times in reverse order\\n        //     using zipped iterator; in the cycle, we update data\\n        //     on seen garbage types and count time depending on  \\n        //     the number of gabage units and seen garbage types\\n        //     (notice the Rusty trick with \\'once\\' dummy iterator \\n        //     to make both iterators have the same length)\\n        for (t, house) in travel.into_iter().rev().chain(once(0))\\n                                .zip(garbage.into_iter().rev())\\n        {\\n            for b in house.bytes()\\n            {\\n                // [3] for P,G,M mod (%) operation gives 0,1,2\\n                seen_garbage |= 1 << (b % 5);\\n                \\n                // [4] if all garbage types were seen, no need to continue;\\n                //     8 = 0b00000111 (all 3 binary flags are set)\\n                if seen_garbage == 8 { break; }\\n            }\\n            \\n            total_time += house.len() as i32 + seen_garbage.count_ones() as i32 * t;\\n        }\\n        \\n        return total_time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::iter::once;\\n\\nimpl Solution \\n{\\n    pub fn garbage_collection(garbage: Vec<String>, travel: Vec<i32>) -> i32 \\n    {\\n        let mut total_time = 0;\\n        \\n        // [1] to detect the last house where each type of garbage\\n        //     was seen, we use binary flags for \\'P\\', \\'G\\' and \\'M\\'\\n        let mut seen_garbage: i32 = 0;\\n        \\n        // [2] iterate over all houses & times in reverse order\\n        //     using zipped iterator; in the cycle, we update data\\n        //     on seen garbage types and count time depending on  \\n        //     the number of gabage units and seen garbage types\\n        //     (notice the Rusty trick with \\'once\\' dummy iterator \\n        //     to make both iterators have the same length)\\n        for (t, house) in travel.into_iter().rev().chain(once(0))\\n                                .zip(garbage.into_iter().rev())\\n        {\\n            for b in house.bytes()\\n            {\\n                // [3] for P,G,M mod (%) operation gives 0,1,2\\n                seen_garbage |= 1 << (b % 5);\\n                \\n                // [4] if all garbage types were seen, no need to continue;\\n                //     8 = 0b00000111 (all 3 binary flags are set)\\n                if seen_garbage == 8 { break; }\\n            }\\n            \\n            total_time += house.len() as i32 + seen_garbage.count_ones() as i32 * t;\\n        }\\n        \\n        return total_time;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663577,
                "title": "python-very-fast-concise-solution-using-smart-counting-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/815632204/) employs a smart counting technique to calculate total time. It demonstrated **890 ms runtime (98.71%)** and used **36.3 MB memory (57.23%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        total_time   = 0\\n        \\n        # [1] to detect the last house where each type of garbage\\n        #     was seen, we use a set of chars (\\'M\\', \\'P\\', \\'G\\')\\n        seen_garbage = set()\\n        \\n        # [2] iterate over all (except the 0th) houses in reverse\\n        #     order using zipped iterator; in the cycle, we update\\n        #     data on seen garbage types and count time depending\\n        #     on the number of gabage units and seen garbage types\\n        for house, t in zip(reversed(garbage), reversed(travel)):\\n            \\n            for g in house: seen_garbage.add(g)\\n                \\n            total_time += len(house)\\n            total_time += len(seen_garbage) * t\\n        \\n        # [3] count the contribution from the 0th house\\n        total_time += len(garbage[0])\\n        \\n        return total_time\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        total_time   = 0\\n        \\n        # [1] to detect the last house where each type of garbage\\n        #     was seen, we use a set of chars (\\'M\\', \\'P\\', \\'G\\')\\n        seen_garbage = set()\\n        \\n        # [2] iterate over all (except the 0th) houses in reverse\\n        #     order using zipped iterator; in the cycle, we update\\n        #     data on seen garbage types and count time depending\\n        #     on the number of gabage units and seen garbage types\\n        for house, t in zip(reversed(garbage), reversed(travel)):\\n            \\n            for g in house: seen_garbage.add(g)\\n                \\n            total_time += len(house)\\n            total_time += len(seen_garbage) * t\\n        \\n        # [3] count the contribution from the 0th house\\n        total_time += len(garbage[0])\\n        \\n        return total_time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640803,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        counter = 0 \\n        garbageDict = {}\\n        for i in range(len(garbage)) : \\n            counter += len(garbage[i])\\n            if \\'G\\' in garbage[i] : \\n                garbageDict[\\'G\\'] = i\\n            if \\'P\\' in garbage[i] : \\n                garbageDict[\\'P\\'] = i\\n            if \\'M\\' in garbage[i] : \\n                garbageDict[\\'M\\'] = i\\n        \\n        for key in garbageDict.keys() : \\n            counter += sum(travel[:garbageDict[key]])\\n            \\n        return counter \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        counter = 0 \\n        garbageDict = {}\\n        for i in range(len(garbage)) : \\n            counter += len(garbage[i])\\n            if \\'G\\' in garbage[i] : \\n                garbageDict[\\'G\\'] = i\\n            if \\'P\\' in garbage[i] : \\n                garbageDict[\\'P\\'] = i\\n            if \\'M\\' in garbage[i] : \\n                garbageDict[\\'M\\'] = i\\n        \\n        for key in garbageDict.keys() : \\n            counter += sum(travel[:garbageDict[key]])\\n            \\n        return counter \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630552,
                "title": "c-easy-to-undersatand-step-by-step",
                "content": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size(), ans = 0, in1=-1, in2=-1, in3=-1;\\n        for(int i=0;i<n;i++) ans+=garbage[i].size();\\n        for(int i=0;i<n;i++){\\n            for(auto j:garbage[i]){\\n                if(j==\\'G\\') in1=i;\\n                if(j==\\'M\\') in2=i;\\n                if(j==\\'P\\') in3=i;\\n            }   \\n        }\\n        \\n        for(int i=0;i<in1;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in2;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in3;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size(), ans = 0, in1=-1, in2=-1, in3=-1;\\n        for(int i=0;i<n;i++) ans+=garbage[i].size();\\n        for(int i=0;i<n;i++){\\n            for(auto j:garbage[i]){\\n                if(j==\\'G\\') in1=i;\\n                if(j==\\'M\\') in2=i;\\n                if(j==\\'P\\') in3=i;\\n            }   \\n        }\\n        \\n        for(int i=0;i<in1;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in2;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in3;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2622204,
                "title": "c-best-soln-beats-99-soln-in-time-and-95-soln-in-space",
                "content": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size(), ans = 0, in1=-1, in2=-1, in3=-1;\\n        for(int i=0;i<n;i++) ans+=garbage[i].size();\\n        for(int i=0;i<n;i++){\\n            for(auto j:garbage[i]){\\n                if(j==\\'G\\') in1=i;\\n                if(j==\\'M\\') in2=i;\\n                if(j==\\'P\\') in3=i;\\n            }   \\n        }\\n        \\n        for(int i=0;i<in1;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in2;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in3;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size(), ans = 0, in1=-1, in2=-1, in3=-1;\\n        for(int i=0;i<n;i++) ans+=garbage[i].size();\\n        for(int i=0;i<n;i++){\\n            for(auto j:garbage[i]){\\n                if(j==\\'G\\') in1=i;\\n                if(j==\\'M\\') in2=i;\\n                if(j==\\'P\\') in3=i;\\n            }   \\n        }\\n        \\n        for(int i=0;i<in1;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in2;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        for(int i=0;i<in3;i++) ans+=travel[i];\\n        cout<<ans<<endl;\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2600985,
                "title": "minimum-amount-of-time-to-collect-garbage-c-easy-understanding-explanation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n //basically hme  garbage ke char ka total ands  g jis position par end end ho rha h wha tak ka travel ka sum using  prefix sum and aise hi p anf metal ke lye\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        vector<int>prefix(travel.size(),0);\\n        prefix[0] =travel[0];\\n        for(int i=1;i<travel.size();i++){\\n            prefix[i] = prefix[i-1]+travel[i];\\n        }\\n        \\n        int ans =0;\\n        int g=0;//glass \\n        int m= 0;  //metal\\n        int p =0;  //plastic \\n        \\n        for(int i=0;i<garbage.size();i++){\\n             \\n            string current = garbage[i];\\n            \\n            for(auto x:current){\\n                if(x==\\'M\\')\\n                    m=i; //m=4;\\n                if(x==\\'G\\')\\n                    g=i;\\n                if(x==\\'P\\')\\n                    p=i;\\n            }\\n            ans += current.size();\\n        }\\n        \\n        if(g>=1)\\n            ans+=prefix[g-1];\\n        if(m>=1)\\n            ans += prefix[m-1];\\n        if(p>=1)\\n            ans += prefix[p-1];\\n        \\n        return ans;\\n        \\n            \\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n //basically hme  garbage ke char ka total ands  g jis position par end end ho rha h wha tak ka travel ka sum using  prefix sum and aise hi p anf metal ke lye\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        vector<int>prefix(travel.size(),0);\\n        prefix[0] =travel[0];\\n        for(int i=1;i<travel.size();i++){\\n            prefix[i] = prefix[i-1]+travel[i];\\n        }\\n        \\n        int ans =0;\\n        int g=0;//glass \\n        int m= 0;  //metal\\n        int p =0;  //plastic \\n        \\n        for(int i=0;i<garbage.size();i++){\\n             \\n            string current = garbage[i];\\n            \\n            for(auto x:current){\\n                if(x==\\'M\\')\\n                    m=i; //m=4;\\n                if(x==\\'G\\')\\n                    g=i;\\n                if(x==\\'P\\')\\n                    p=i;\\n            }\\n            ans += current.size();\\n        }\\n        \\n        if(g>=1)\\n            ans+=prefix[g-1];\\n        if(m>=1)\\n            ans += prefix[m-1];\\n        if(p>=1)\\n            ans += prefix[p-1];\\n        \\n        return ans;\\n        \\n            \\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556952,
                "title": "80-space-beats-c-time-o-garbage-length-max-garbage-i-length",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int i,n = garbage.size();\\n        int ansg = 0,ansm = 0,ansp = 0;\\n        for(auto &i: garbage[n-1]){\\n            if(i==\\'G\\'){\\n                ansg++;\\n            }else if(i==\\'M\\')ansm++;\\n            else ansp++;\\n        }\\n        // cout<<ansg<<\" \"<<ansp<<\" \"<<ansm<<endl;\\n        for(i = n-2; i>= 0; i--){\\n            if(ansg)ansg += travel[i];\\n            if(ansm)ansm += travel[i];\\n            if(ansp)ansp += travel[i];\\n            for(auto &j: garbage[i]){\\n                if(j==\\'G\\'){\\n                    ansg++;\\n                }else if(j==\\'M\\')ansm++;\\n                else ansp++;\\n            }\\n            // cout<<ansg<<\" \"<<ansp<<\" \"<<ansm<<endl;\\n        }\\n        return (ansg+ansm+ansp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int i,n = garbage.size();\\n        int ansg = 0,ansm = 0,ansp = 0;\\n        for(auto &i: garbage[n-1]){\\n            if(i==\\'G\\'){\\n                ansg++;\\n            }else if(i==\\'M\\')ansm++;\\n            else ansp++;\\n        }\\n        // cout<<ansg<<\" \"<<ansp<<\" \"<<ansm<<endl;\\n        for(i = n-2; i>= 0; i--){\\n            if(ansg)ansg += travel[i];\\n            if(ansm)ansm += travel[i];\\n            if(ansp)ansp += travel[i];\\n            for(auto &j: garbage[i]){\\n                if(j==\\'G\\'){\\n                    ansg++;\\n                }else if(j==\\'M\\')ansm++;\\n                else ansp++;\\n            }\\n            // cout<<ansg<<\" \"<<ansp<<\" \"<<ansm<<endl;\\n        }\\n        return (ansg+ansm+ansp);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2549781,
                "title": "c-prefix-last-index",
                "content": "```\\n int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char, int> count;\\n        unordered_map<char, int> dest;\\n        vector<int> prefix(travel.size()+1, 0);\\n        int sum = 0, ans = 0;;\\n        \\n        prefix[0] = 0;\\n        for(int i = 0; i < travel.size(); i++){\\n            sum += travel[i];\\n            prefix[i+1] = sum;\\n        }\\n        \\n        for(int i = 0; i < garbage.size(); i++){\\n            string str = garbage[i];\\n            int index = 0;\\n            while(index < str.length()){\\n                count[str[index]]++;\\n                dest[str[index]] = i;\\n                index++;\\n            }\\n        }\\n        \\n        for(auto x : dest){\\n            ans += (prefix[x.second] + count[x.first]);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        unordered_map<char, int> count;\\n        unordered_map<char, int> dest;\\n        vector<int> prefix(travel.size()+1, 0);\\n        int sum = 0, ans = 0;;\\n        \\n        prefix[0] = 0;\\n        for(int i = 0; i < travel.size(); i++){\\n            sum += travel[i];\\n            prefix[i+1] = sum;\\n        }\\n        \\n        for(int i = 0; i < garbage.size(); i++){\\n            string str = garbage[i];\\n            int index = 0;\\n            while(index < str.length()){\\n                count[str[index]]++;\\n                dest[str[index]] = i;\\n                index++;\\n            }\\n        }\\n        \\n        for(auto x : dest){\\n            ans += (prefix[x.second] + count[x.first]);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545325,
                "title": "golang-prefix-sum",
                "content": "```\\nfunc garbageCollection(garbage []string, travel []int) int {\\n  \\n    pre := make([]int , len(travel)+1)\\n    \\n    for i:=1;i<len(pre);i++ {\\n        pre[i] = pre[i-1] + travel[i-1]\\n    }\\n    \\n    \\n    last_p := 0\\n    last_g := 0\\n    last_m := 0\\n    \\n    ans := 0\\n    \\n    for i:=0;i<len(garbage);i++ {\\n        \\n        for j:=0;j<len(garbage[i]);j++{\\n            \\n            if garbage[i][j] == \\'G\\' {\\n                last_g = i\\n                ans++\\n            }else if garbage[i][j] == \\'M\\' {\\n                last_m = i\\n                ans++\\n            }else{\\n                last_p = i\\n                ans++\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    ans += (pre[last_p] + pre[last_g] + pre[last_m])\\n    \\n    return ans\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc garbageCollection(garbage []string, travel []int) int {\\n  \\n    pre := make([]int , len(travel)+1)\\n    \\n    for i:=1;i<len(pre);i++ {\\n        pre[i] = pre[i-1] + travel[i-1]\\n    }\\n    \\n    \\n    last_p := 0\\n    last_g := 0\\n    last_m := 0\\n    \\n    ans := 0\\n    \\n    for i:=0;i<len(garbage);i++ {\\n        \\n        for j:=0;j<len(garbage[i]);j++{\\n            \\n            if garbage[i][j] == \\'G\\' {\\n                last_g = i\\n                ans++\\n            }else if garbage[i][j] == \\'M\\' {\\n                last_m = i\\n                ans++\\n            }else{\\n                last_p = i\\n                ans++\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    ans += (pre[last_p] + pre[last_g] + pre[last_m])\\n    \\n    return ans\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2544125,
                "title": "c-easy-to-understand",
                "content": "THIS IS NOT MY SOLUTION WELL THIS IS A GOOD APPROACH HENCE I SHARED THIS APPROACH \\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        long long ans = 0;\\n        vector<vector<int>>vec(garbage.size(),vector<int>(3,0));\\n        \\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            string s = garbage[i];\\n            for(char c:s)\\n            {\\n                if(c == \\'G\\')\\n                    vec[i][0]++;\\n                else if(c == \\'M\\')\\n                    vec[i][1]++;\\n                else\\n                    vec[i][2]++;\\n            }\\n        }\\n        \\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            string s = garbage[i];\\n            for(char c:s)\\n            {\\n                ans += 1;\\n            }\\n        }\\n        \\n       \\n        \\n        int maxg = 0,maxm=0,maxp=0;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i][0] != 0)\\n                maxg = max(i,maxg);\\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i][1] != 0)\\n                maxm = max(i,maxm);\\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i][2] != 0)\\n                maxp = max(i,maxp);\\n        }\\n        \\n        \\n        for(int i=1;i<=maxg;i++)\\n        {\\n            ans += travel[i-1];\\n        }\\n        for(int i=1;i<=maxm;i++)\\n        {\\n            ans += travel[i-1];\\n        }\\n        for(int i=1;i<=maxp;i++)\\n        {\\n            ans += travel[i-1];\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        long long ans = 0;\\n        vector<vector<int>>vec(garbage.size(),vector<int>(3,0));\\n        \\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            string s = garbage[i];\\n            for(char c:s)\\n            {\\n                if(c == \\'G\\')\\n                    vec[i][0]++;\\n                else if(c == \\'M\\')\\n                    vec[i][1]++;\\n                else\\n                    vec[i][2]++;\\n            }\\n        }\\n        \\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            string s = garbage[i];\\n            for(char c:s)\\n            {\\n                ans += 1;\\n            }\\n        }\\n        \\n       \\n        \\n        int maxg = 0,maxm=0,maxp=0;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i][0] != 0)\\n                maxg = max(i,maxg);\\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i][1] != 0)\\n                maxm = max(i,maxm);\\n        }\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i][2] != 0)\\n                maxp = max(i,maxp);\\n        }\\n        \\n        \\n        for(int i=1;i<=maxg;i++)\\n        {\\n            ans += travel[i-1];\\n        }\\n        for(int i=1;i<=maxm;i++)\\n        {\\n            ans += travel[i-1];\\n        }\\n        for(int i=1;i<=maxp;i++)\\n        {\\n            ans += travel[i-1];\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532574,
                "title": "c",
                "content": "Runtime: 185 ms, faster than 95.45% of C online submissions for Minimum Amount of Time to Collect Garbage.\\nMemory Usage: 27.8 MB, less than 31.82% of C online submissions for Minimum Amount of Time to Collect Garbage.\\n```\\nint garbageCollection(char ** garbage, int garbageSize, int* travel, int travelSize){\\n    int totalBag = 0;\\n    bool Mflag = false, Pflag = false, Gflag = false;\\n    int len;\\n    int ans = 0;\\n    \\n    for(int i = garbageSize -1; i >= 0; i-- ){\\n        len = strlen(garbage[i]); \\n        totalBag += len;\\n        for(int j = 0; j < len ;j++)\\n        if(!Mflag || !Pflag || !Gflag){\\n            for(int j = 0; j < len; j++){\\n                if(!Mflag && garbage[i][j]== \\'M\\'){\\n                    Mflag = true;    \\n                    for(int k = i - 1; k >=0; k--){\\n                        ans += travel[k];\\n                    }\\n                }\\n                else if(!Pflag && garbage[i][j]== \\'P\\'){\\n                    Pflag = true;    \\n                    for(int k = i - 1; k >=0; k--){\\n                        ans += travel[k];\\n                    }\\n                }\\n                else if(!Gflag && garbage[i][j]== \\'G\\'){\\n                    Gflag = true;    \\n                    for(int k = i - 1; k >=0; k--){\\n                        ans += travel[k];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans += totalBag;\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint garbageCollection(char ** garbage, int garbageSize, int* travel, int travelSize){\\n    int totalBag = 0;\\n    bool Mflag = false, Pflag = false, Gflag = false;\\n    int len;\\n    int ans = 0;\\n    \\n    for(int i = garbageSize -1; i >= 0; i-- ){\\n        len = strlen(garbage[i]); \\n        totalBag += len;\\n        for(int j = 0; j < len ;j++)\\n        if(!Mflag || !Pflag || !Gflag){\\n            for(int j = 0; j < len; j++){\\n                if(!Mflag && garbage[i][j]== \\'M\\'){\\n                    Mflag = true;    \\n                    for(int k = i - 1; k >=0; k--){\\n                        ans += travel[k];\\n                    }\\n                }\\n                else if(!Pflag && garbage[i][j]== \\'P\\'){\\n                    Pflag = true;    \\n                    for(int k = i - 1; k >=0; k--){\\n                        ans += travel[k];\\n                    }\\n                }\\n                else if(!Gflag && garbage[i][j]== \\'G\\'){\\n                    Gflag = true;    \\n                    for(int k = i - 1; k >=0; k--){\\n                        ans += travel[k];\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    ans += totalBag;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2523721,
                "title": "begginer-friendly-simple-easy-to-undestand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\t\\tint countm=0,countp=0,countg=0;\\n\\t\\t\\tint lastm=0,lastp=0,lastg=0;\\n\\t\\t\\tfor(int i=0;i<garbage.size();i++){\\n\\t\\t\\t\\tfor(auto j:garbage[i]){\\n\\t\\t\\t\\t\\tif(j==\\'M\\'){\\n\\t\\t\\t\\t\\t\\tcountm++;\\n\\t\\t\\t\\t\\t\\tlastm=i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(j==\\'P\\'){\\n\\t\\t\\t\\t\\t\\tcountp++;\\n\\t\\t\\t\\t\\t\\tlastp=i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(j==\\'G\\'){\\n\\t\\t\\t\\t\\t\\tcountg++;\\n\\t\\t\\t\\t\\t\\tlastg=i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<long long> prefix(travel.size()+1,0);\\n\\t\\t\\tfor(int i=1;i<travel.size()+1;i++){\\n\\t\\t\\t\\tprefix[i] = travel[i-1]+prefix[i-1];\\n\\t\\t\\t}\\n\\t\\t\\treturn prefix[lastm]+prefix[lastp]+prefix[lastg]+countm+countp+countg;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\t\\tint countm=0,countp=0,countg=0;\\n\\t\\t\\tint lastm=0,lastp=0,lastg=0;\\n\\t\\t\\tfor(int i=0;i<garbage.size();i++){\\n\\t\\t\\t\\tfor(auto j:garbage[i]){\\n\\t\\t\\t\\t\\tif(j==\\'M\\'){\\n\\t\\t\\t\\t\\t\\tcountm++;\\n\\t\\t\\t\\t\\t\\tlastm=i;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2522471,
                "title": "very-easy-solution-with-python-94-faster",
                "content": "The solution is very simple. Count all the number of Paper, Glass, Metal to individual varibles.\\nWhile Looping through individual list item I kept track of position of Each item found. Thus by using list slicing I calculated the distance.\\nnote: add 0 at start of the Travel list cause the time taken to travel first house is Zero.\\n\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        \\n\\n        travel.insert(0,0)\\n        pointer = 0\\n        metal=paper=glass= 0\\n        m_last = p_last = g_last = 0\\n\\n        for bag in garbage:\\n            for item in bag:\\n                if item == \"G\":\\n                    glass += 1\\n                    g_last = pointer\\n                elif item == \"P\":\\n                    paper += 1\\n                    p_last = pointer\\n                elif item == \"M\":\\n                    metal += 1\\n                    m_last = pointer\\n            pointer += 1\\n\\n\\n        \\n        result = paper+glass+metal+sum(travel[:p_last+1:])+sum(travel[:g_last+1:])+sum(travel[:m_last+1:])\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n        \\n\\n        travel.insert(0,0)\\n        pointer = 0\\n        metal=paper=glass= 0\\n        m_last = p_last = g_last = 0\\n\\n        for bag in garbage:\\n            for item in bag:\\n                if item == \"G\":\\n                    glass += 1\\n                    g_last = pointer\\n                elif item == \"P\":\\n                    paper += 1\\n                    p_last = pointer\\n                elif item == \"M\":\\n                    metal += 1\\n                    m_last = pointer\\n            pointer += 1\\n\\n\\n        \\n        result = paper+glass+metal+sum(travel[:p_last+1:])+sum(travel[:g_last+1:])+sum(travel[:m_last+1:])\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522150,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTravelTime(int idx, int ch, vector<vector<int>>&freq, vector<int>&travel){\\n        int count = 0;\\n        \\n        for(int i = 0;i < idx;i++){\\n            count += travel[i] + freq[i][ch];//adding picking time for ch type garbage and time for moving from i to i + 1 house\\n        }\\n\\t\\tcount += freq[idx][ch];//At last house we do not need to add travel time as we will not go further only add picking time of that garbage \\n        return count;\\n    }\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\tvector<vector<int>>freq;             //Store the frequency of every type of garbage at every house\\n        \\n\\t\\tint last_M = -1, last_P = -1, last_G = -1;  //Store the last index of every type of garbage at any house\\n        \\n        for(int i = 0;i < garbage.size();i++){\\n            int ct_M = count(garbage[i].begin(), garbage[i].end(), \\'M\\');\\n            int ct_P = count(garbage[i].begin(), garbage[i].end(), \\'P\\');\\n            int ct_G = count(garbage[i].begin(), garbage[i].end(), \\'G\\');\\n            \\n            if(ct_M != 0)last_M = i;\\n            if(ct_P != 0)last_P = i;\\n            if(ct_G != 0)last_G = i;\\n            \\n            freq.push_back({ct_M, ct_P, ct_G});\\n            \\n        }\\n        \\n        int totalTime = 0;\\n        \\n        if(last_M != -1){\\n            totalTime += countTravelTime(last_M, 0, freq, travel);// 0 means we stored count of M type garbage at 0th index in freq[i] array\\n        }\\n        if(last_P != -1){\\n            totalTime += countTravelTime(last_P, 1, freq, travel);\\n        }\\n        if(last_G != -1){\\n            totalTime += countTravelTime(last_G, 2, freq, travel);\\n        }\\n        \\n        return totalTime;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTravelTime(int idx, int ch, vector<vector<int>>&freq, vector<int>&travel){\\n        int count = 0;\\n        \\n        for(int i = 0;i < idx;i++){\\n            count += travel[i] + freq[i][ch];//adding picking time for ch type garbage and time for moving from i to i + 1 house\\n        }\\n\\t\\tcount += freq[idx][ch];//At last house we do not need to add travel time as we will not go further only add picking time of that garbage \\n        return count;\\n    }\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\tvector<vector<int>>freq;             //Store the frequency of every type of garbage at every house\\n        \\n\\t\\tint last_M = -1, last_P = -1, last_G = -1;  //Store the last index of every type of garbage at any house\\n        \\n        for(int i = 0;i < garbage.size();i++){\\n            int ct_M = count(garbage[i].begin(), garbage[i].end(), \\'M\\');\\n            int ct_P = count(garbage[i].begin(), garbage[i].end(), \\'P\\');\\n            int ct_G = count(garbage[i].begin(), garbage[i].end(), \\'G\\');\\n            \\n            if(ct_M != 0)last_M = i;\\n            if(ct_P != 0)last_P = i;\\n            if(ct_G != 0)last_G = i;\\n            \\n            freq.push_back({ct_M, ct_P, ct_G});\\n            \\n        }\\n        \\n        int totalTime = 0;\\n        \\n        if(last_M != -1){\\n            totalTime += countTravelTime(last_M, 0, freq, travel);// 0 means we stored count of M type garbage at 0th index in freq[i] array\\n        }\\n        if(last_P != -1){\\n            totalTime += countTravelTime(last_P, 1, freq, travel);\\n        }\\n        if(last_G != -1){\\n            totalTime += countTravelTime(last_G, 2, freq, travel);\\n        }\\n        \\n        return totalTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518107,
                "title": "cpp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint garbageCollection(vector<string>& gg, vector<int>& t) {\\n\\t\\t\\tt.insert(t.begin(),0);\\n\\t\\t\\tint p = 0,g = 0, m =0 ;\\n\\t\\t\\tint ti = gg[0].length();\\n\\t\\t\\tfor(int i = 1;i<gg.size();i++){\\n\\t\\t\\t\\tti+=gg[i].length();\\n\\t\\t\\t\\tt[i] += t[i-1];\\n\\t\\t\\t\\tfor(char c : gg[i]){\\n\\t\\t\\t\\t\\tif(c == \\'P\\') p = i;\\n\\t\\t\\t\\t\\tif(c == \\'G\\') g = i;\\n\\t\\t\\t\\t\\tif(c == \\'M\\') m = i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ti+t[p]+t[g]+t[m];\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint garbageCollection(vector<string>& gg, vector<int>& t) {\\n\\t\\t\\tt.insert(t.begin(),0);\\n\\t\\t\\tint p = 0,g = 0, m =0 ;\\n\\t\\t\\tint ti = gg[0].length();\\n\\t\\t\\tfor(int i = 1;i<gg.size();i++){\\n\\t\\t\\t\\tti+=gg[i].length();\\n\\t\\t\\t\\tt[i] += t[i-1];\\n\\t\\t\\t\\tfor(char c : gg[i]){\\n\\t\\t\\t\\t\\tif(c == \\'P\\') p = i;\\n\\t\\t\\t\\t\\tif(c == \\'G\\') g = i;\\n\\t\\t\\t\\t\\tif(c == \\'M\\') m = i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2513601,
                "title": "python-simple-reversed-traversal-100-space-98-time",
                "content": "Simple solution based on a traversal of the lists in reversed order.\\n\\n**Main intuition:**\\nThe idea is that we need each truck to continue driving to the next house until they need to pick up some garbage at a house later in the list.\\nTo avoid checking in advance until what point each truck is needed, we can simply traverse the houses backwards, and keep track of all the trucks that are needed from that house and earlier.\\n\\nWe use the three boolean variables `g`, `m`, `p` to track whether the trucks are needed at this point, and we keep checking whether each of them is needed until the last occurrence in the list (first in the reversed traversal) is found.\\n\\n![image](https://assets.leetcode.com/users/images/6d22fef1-b05d-4163-bcbc-a9c66c883ced_1662029796.0353255.png)\\n\\n\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        g = m = p = False  # whether each truck should drive until the current house\\n        time = 0  # total time needed\\n        \\n        # starting from the last house and going backwards, we track which trucks should drive until there by looking at the garbage content.\\n        while len(travel):\\n            t = travel.pop()  # travel cost to the current house\\n            s = garbage.pop()  # garbage string for the current house\\n            \\n            # if at least one truck was not needed for all houses after the current, check if it is needed in this house (and thus for all previous houses).\\n            if sum([g, m, p]) < 3:\\n                if \\'G\\' in s:\\n                    g = True\\n                if \\'M\\' in s:\\n                    m = True\\n                if \\'P\\' in s:\\n                    p = True\\n                        \\n            # add to the time cost the number of garbage items in this house and the travel costs for the number of tracks that need to drive until here\\n            time += sum([g, m, p]) * t + len(s)\\n            \\n        # add the garbage cost for the initial house, where no driving time is needed\\n        time = time + len(garbage[0])  \\n        \\n        return time\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        g = m = p = False  # whether each truck should drive until the current house\\n        time = 0  # total time needed\\n        \\n        # starting from the last house and going backwards, we track which trucks should drive until there by looking at the garbage content.\\n        while len(travel):\\n            t = travel.pop()  # travel cost to the current house\\n            s = garbage.pop()  # garbage string for the current house\\n            \\n            # if at least one truck was not needed for all houses after the current, check if it is needed in this house (and thus for all previous houses).\\n            if sum([g, m, p]) < 3:\\n                if \\'G\\' in s:\\n                    g = True\\n                if \\'M\\' in s:\\n                    m = True\\n                if \\'P\\' in s:\\n                    p = True\\n                        \\n            # add to the time cost the number of garbage items in this house and the travel costs for the number of tracks that need to drive until here\\n            time += sum([g, m, p]) * t + len(s)\\n            \\n        # add the garbage cost for the initial house, where no driving time is needed\\n        time = time + len(garbage[0])  \\n        \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507285,
                "title": "javascript-solution",
                "content": "```\\nvar solution = function (garbage, travel) {\\n\\tconst type = [\\'G\\', \\'P\\', \\'M\\'];\\n\\n\\tlet total = garbage.join(\\'\\').length;\\n\\n\\tconst lastIdx = (g) => {\\n\\t\\tlet idx = 0;\\n\\t\\tfor (let i = garbage.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (garbage[i].includes(g)) {\\n\\t\\t\\t\\tidx = i;\\n\\t\\t\\t\\treturn idx;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\ttype.map((g) => {\\n\\t\\ttotal += [...travel].splice(0, lastIdx(g)).reduce((c, a) => c + a, 0);\\n\\t});\\n\\n\\treturn total;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar solution = function (garbage, travel) {\\n\\tconst type = [\\'G\\', \\'P\\', \\'M\\'];\\n\\n\\tlet total = garbage.join(\\'\\').length;\\n\\n\\tconst lastIdx = (g) => {\\n\\t\\tlet idx = 0;\\n\\t\\tfor (let i = garbage.length - 1; i >= 0; i--) {\\n\\t\\t\\tif (garbage[i].includes(g)) {\\n\\t\\t\\t\\tidx = i;\\n\\t\\t\\t\\treturn idx;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\ttype.map((g) => {\\n\\t\\ttotal += [...travel].splice(0, lastIdx(g)).reduce((c, a) => c + a, 0);\\n\\t});\\n\\n\\treturn total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2505544,
                "title": "python-easy-solution",
                "content": "\\n\\nclass Solution:\\n    \\n\\tdef garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n\\t\\ttime = 0\\n        d = {\"G\" : 0, \"M\": 0, \"P\": 0}\\n        f1, f2, f3 = 0, 0, 0\\n        for i in range(len(garbage)):\\n            for ele in garbage[i]:\\n                if ele == \"G\":\\n                    time += 1\\n                    last_G = i\\n                    f1 = 1\\n                    \\n                elif ele == \"M\":\\n                    time += 1\\n                    last_M = i\\n                    f2 = 1\\n                    \\n                elif ele == \"P\":\\n                    time += 1\\n                    last_P = i\\n                    f3 = 1\\n                    \\n        #time += travel[ : last_G] +   travel[ : last_M] + travel[: last_P]\\n        if f1 == 1:\\n            time += sum(travel[ : last_G])\\n        if f2 == 1:\\n            time += sum(travel[ : last_M])\\n        if f3 == 1:\\n            time += sum(travel[ : last_P])\\n        return time\\n            \\n        \\n        \\n        return time\\n\\t\\t\\n\\t\\t\\n# \\tPls upvote if you like the solution!",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n\\tdef garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        \\n\\t\\ttime = 0\\n        d = {\"G\" : 0, \"M\": 0, \"P\": 0}",
                "codeTag": "Java"
            },
            {
                "id": 2504967,
                "title": "c-count-each-and-their-last-appearing-indices-easy",
                "content": "```\\nhere the basic idea is to count each of \\'M\\' , \\'G\\' , \\'P\\' and also the indices of their last occurences, so that we know upto which place we have to move. Also, used prefix sum to encounter less calculation and time optimisation\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& g, vector<int>& t) {\\n        for(int i=1;i<t.size();i++)t[i]+=t[i-1];\\n        int ans=0;\\n        int gl=0,p=0,m=0;//last idx\\n        int cgl=0,cp=0,cm=0;// count of each\\n        for(int i=0;i<g.size();i++){\\n            for(int j=0;j<g[i].size();j++){\\n                if(g[i][j]==\\'M\\'){\\n                    m=i;\\n                    cm++;\\n                }\\n                else if(g[i][j]==\\'P\\'){\\n                    p=i;\\n                    cp++;\\n                }\\n                else if(g[i][j]==\\'G\\'){\\n                    gl=i;\\n                    cgl++;\\n                }\\n            }\\n        }\\n        if(m-1>=0)ans+=t[m-1];\\n        if(p-1>=0)ans+=t[p-1];\\n        if(gl-1>=0)ans+=t[gl-1];\\n        \\n        //cout<<t[m]<<\" \"<<t[p]<<\" \"<<t[gl]<<\" \"<<cgl<<\" \"<<cp<<\" \"<<cm; \\n        ans+=(cgl+cp+cm);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nhere the basic idea is to count each of \\'M\\' , \\'G\\' , \\'P\\' and also the indices of their last occurences, so that we know upto which place we have to move. Also, used prefix sum to encounter less calculation and time optimisation\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& g, vector<int>& t) {\\n        for(int i=1;i<t.size();i++)t[i]+=t[i-1];\\n        int ans=0;\\n        int gl=0,p=0,m=0;//last idx\\n        int cgl=0,cp=0,cm=0;// count of each\\n        for(int i=0;i<g.size();i++){\\n            for(int j=0;j<g[i].size();j++){\\n                if(g[i][j]==\\'M\\'){\\n                    m=i;\\n                    cm++;\\n                }\\n                else if(g[i][j]==\\'P\\'){\\n                    p=i;\\n                    cp++;\\n                }\\n                else if(g[i][j]==\\'G\\'){\\n                    gl=i;\\n                    cgl++;\\n                }\\n            }\\n        }\\n        if(m-1>=0)ans+=t[m-1];\\n        if(p-1>=0)ans+=t[p-1];\\n        if(gl-1>=0)ans+=t[gl-1];\\n        \\n        //cout<<t[m]<<\" \"<<t[p]<<\" \"<<t[gl]<<\" \"<<cgl<<\" \"<<cp<<\" \"<<cm; \\n        ans+=(cgl+cp+cm);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2503346,
                "title": "start-from-last-no-need-to-find-the-index-of-each-type-one-pass-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        Approach : \\n            1. Start from last and keep on checking if there is an item in that house, increase the count of it.\\n            2. Post traversing each house for all the items, we need to check which one\\'s count should be increased by travel[i-1]. This is for the reason that if any item had occured from last even once, we need to include it\\'s travel[i-1] value in each house as we are looking from back.\\n            3. At last add all counts to get the result. \\n        \\n        Time : O(N)\\n        Space : O(1)\\n    */\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size();\\n        int res_m = 0;\\n        int res_p = 0;\\n        int res_g = 0;\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            string curr = garbage[i];\\n            int curr_len = curr.size();\\n            for (int j = 0; j < curr_len; ++j) {\\n                if (curr[j] == \\'M\\') {\\n                    res_m += 1;\\n                }\\n                else if (curr[j] == \\'P\\') {\\n                    res_p += 1;\\n                }\\n                else {\\n                    res_g += 1;\\n                }\\n            }\\n                \\n            if (res_m != 0 && i != 0) {\\n                res_m += travel[i-1];\\n            }\\n\\n            if (res_p != 0 && i != 0) {\\n                res_p += travel[i-1];\\n            }\\n            if (res_g != 0 && i != 0) {\\n                res_g += travel[i-1];\\n            }\\n        }\\n        return res_m + res_p + res_g;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Approach : \\n            1. Start from last and keep on checking if there is an item in that house, increase the count of it.\\n            2. Post traversing each house for all the items, we need to check which one\\'s count should be increased by travel[i-1]. This is for the reason that if any item had occured from last even once, we need to include it\\'s travel[i-1] value in each house as we are looking from back.\\n            3. At last add all counts to get the result. \\n        \\n        Time : O(N)\\n        Space : O(1)\\n    */\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int n = garbage.size();\\n        int res_m = 0;\\n        int res_p = 0;\\n        int res_g = 0;\\n        \\n        for (int i = n-1; i >= 0; --i) {\\n            string curr = garbage[i];\\n            int curr_len = curr.size();\\n            for (int j = 0; j < curr_len; ++j) {\\n                if (curr[j] == \\'M\\') {\\n                    res_m += 1;\\n                }\\n                else if (curr[j] == \\'P\\') {\\n                    res_p += 1;\\n                }\\n                else {\\n                    res_g += 1;\\n                }\\n            }\\n                \\n            if (res_m != 0 && i != 0) {\\n                res_m += travel[i-1];\\n            }\\n\\n            if (res_p != 0 && i != 0) {\\n                res_p += travel[i-1];\\n            }\\n            if (res_g != 0 && i != 0) {\\n                res_g += travel[i-1];\\n            }\\n        }\\n        return res_m + res_p + res_g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499980,
                "title": "c-single-pass-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& str, vector<int>& travel) {\\n        int ans = 0;\\n        int maxG = 0,maxP = 0,maxM = 0;\\n        travel.emplace(travel.begin(),0);\\n        for(int i = 1;i<travel.size();i++) travel[i] += travel[i - 1];\\n        int n = str.size();\\n        for(int i = 0;i<n;i++){\\n            int g = 0,p = 0,m = 0;\\n            for(char &c:str[i]){\\n                if(c == \\'G\\') g++;\\n                else if(c == \\'P\\') p++;\\n                else m++;\\n            }\\n            if(g) maxG = i;\\n            if(p) maxP = i;\\n            if(m) maxM = i;\\n            ans += g + p + m;\\n        }\\n        \\n        return ans + travel[maxG] + travel[maxP] + travel[maxM];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& str, vector<int>& travel) {\\n        int ans = 0;\\n        int maxG = 0,maxP = 0,maxM = 0;\\n        travel.emplace(travel.begin(),0);\\n        for(int i = 1;i<travel.size();i++) travel[i] += travel[i - 1];\\n        int n = str.size();\\n        for(int i = 0;i<n;i++){\\n            int g = 0,p = 0,m = 0;\\n            for(char &c:str[i]){\\n                if(c == \\'G\\') g++;\\n                else if(c == \\'P\\') p++;\\n                else m++;\\n            }\\n            if(g) maxG = i;\\n            if(p) maxP = i;\\n            if(m) maxM = i;\\n            ans += g + p + m;\\n        }\\n        \\n        return ans + travel[maxG] + travel[maxP] + travel[maxM];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496978,
                "title": "java-100-faster-bottom-up-approach",
                "content": "**Logic:**\\n1. For counting the travels:  if a truck has reached any point/index, this means it must have travelled all the indexes up to that point.\\n2. For collecting garbage: count the length of the string at every index because each of the truck types take 1 min to pick up the garbage.\\n\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        boolean M = false;\\n        boolean P = false;\\n        boolean G = false;\\n        int i = garbage.length - 1;\\n        int j = travel.length - 1;\\n        int res = 0;\\n        while(i >= 0) {\\n            if(M || garbage[i].contains(\"M\")) M = true;\\n            if(P || garbage[i].contains(\"P\")) P = true;\\n            if(G || garbage[i].contains(\"G\")) G = true;\\n            res += garbage[i].length();\\n            if(j >=0) {\\n                res += countMinutes(M, travel[j]);\\n                res += countMinutes(P, travel[j]);\\n                res += countMinutes(G, travel[j]);\\n                j--;\\n            }\\n            i--;\\n        }\\n        return res;\\n    }\\n    public int countMinutes(boolean x, int k) {\\n        if(x) return k;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        boolean M = false;\\n        boolean P = false;\\n        boolean G = false;\\n        int i = garbage.length - 1;\\n        int j = travel.length - 1;\\n        int res = 0;\\n        while(i >= 0) {\\n            if(M || garbage[i].contains(\"M\")) M = true;\\n            if(P || garbage[i].contains(\"P\")) P = true;\\n            if(G || garbage[i].contains(\"G\")) G = true;\\n            res += garbage[i].length();\\n            if(j >=0) {\\n                res += countMinutes(M, travel[j]);\\n                res += countMinutes(P, travel[j]);\\n                res += countMinutes(G, travel[j]);\\n                j--;\\n            }\\n            i--;\\n        }\\n        return res;\\n    }\\n    public int countMinutes(boolean x, int k) {\\n        if(x) return k;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495752,
                "title": "c-prefixsum-fast-easy-to-understand",
                "content": "First we can find the sum of all the garbage available.We have to find the maximum index at which the particular garbage is present . Inserted 0 in the beginning of the travel vector because if a particular garbage is not present at a index greater than 0 then the truck should travel 0 distance.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //prefixsum the travel vector because if one wants to go to index 3 it needs to travel from 0->1->2->3 which\\n\\t\\t//requires all the travel distance till index 3.\\n        for(int i=1;i<travel.size();i++){\\n            travel[i]+=travel[i-1];\\n        }\\n        //if the garbage is not present at index>0\\n        travel.insert(travel.begin(),0);\\n        int sum=0;//total picking time for the garbage \\n        int metal_index=0,paper_index=0,glass_index=0; //maximum index at which a particular garbage is present.\\n        for(int i=0;i<garbage.size();i++){\\n            for(auto ch:garbage[i]){\\n                if(ch==\\'M\\')\\n                    metal_index=max(metal_index,i); \\n                else if(ch==\\'G\\')\\n                    glass_index=max(glass_index,i);\\n                else\\n                    paper_index=max(paper_index,i);\\n            }\\n            sum+=garbage[i].size();\\n        }\\n\\t\\t//total time taken = time taken for picking garbage(sum) +  total distance travelled by the truck \\n        int ans=travel[metal_index] + travel[glass_index] + travel[paper_index] + sum;\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //prefixsum the travel vector because if one wants to go to index 3 it needs to travel from 0->1->2->3 which\\n\\t\\t//requires all the travel distance till index 3.\\n        for(int i=1;i<travel.size();i++){\\n            travel[i]+=travel[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2495660,
                "title": "if-u-want-to-laugh-look-at-my-solution",
                "content": "**upvote if it helped \\uD83E\\uDD23**\\n## Could this be any more NAIVE \\uD83E\\uDD2D \\n\\n------------------------------------------CODE---------------------------------------------------------------------------------\\n```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int sum = 0;\\n        \\n        int[] arr = new int[3];\\n        int[][] mat = new int[garbage.length][3];\\n        for(int i=0;i<garbage.length;i++){\\n            String str = garbage[i];\\n            for(char ch : str.toCharArray()){\\n                if(ch==\\'G\\'){\\n                    mat[i][0]++;\\n                    arr[0]++;\\n                }\\n                else if(ch==\\'M\\'){\\n                    mat[i][1]++;\\n                    arr[1]++;\\n                }\\n                else if(ch==\\'P\\'){\\n                    mat[i][2]++;\\n                    arr[2]++;\\n                }\\n            }\\n        }\\n        \\n        // for G truck\\n        if(arr[0]>0){\\n        for(int i=0;i<garbage.length;i++){\\n            if(arr[0]==0)\\n                break;\\n            if(i>0 && arr[0]!=0)\\n                 sum+=travel[i-1];\\n            if(mat[i][0]!=0){\\n                sum+=mat[i][0];\\n                arr[0] -= mat[i][0];\\n            }\\n            \\n            \\n        }\\n        }\\n        \\n        // for M truck\\n        if(arr[1]>0){\\n        for(int i=0;i<garbage.length;i++){\\n            if(arr[1]==0)\\n                break;\\n            if(i>0 && arr[1]!=0)\\n                 sum+=travel[i-1];\\n            if(mat[i][1]!=0){\\n                sum+=mat[i][1];\\n                arr[1] -= mat[i][1];\\n            }\\n            \\n        }\\n        }\\n        \\n        // for P truck\\n        if(arr[2]>0){\\n        for(int i=0;i<garbage.length;i++){\\n            if(arr[2]==0)\\n                break;\\n             if(i>0 && arr[2]!=0)\\n                 sum+=travel[i-1];\\n            if(mat[i][2]!=0){\\n                sum+=mat[i][2];\\n                arr[2] -= mat[i][2];\\n            }\\n            \\n        }\\n        }\\n       \\n        return sum;\\n    }\\n}\\n```\\n\\n*OKAY, let me explain it too now \\uD83E\\uDD23*\\nApproach : \\ncreated a 2-d array to store the count of \\'G\\', \\'M\\', \\'P\\' as 0th, 1st, and 2nd index respectively for each row where row represents ith string of garbage array i.e., garbage[i]\\narr[] represents the total count of \\'G\\', \\'M\\', \\'P\\' in the garbage[]  as 0th, 1st, and 2nd index respectively\\nso we will check if arr[i]!=0 which means truck has to travel \\nkeep substracting the mat[i][0] from arr[0] and mat[i][1] from arr[1] and likewise for 2nd index, to keep track of the remaining same type of garbage to be picked\\nsince one truck can go at a time so we use 3 for loops separately\\ntravel will be added only if i>0 which means no travel cost for 0th house\\n**okay now u understand the logic, please make it better for yourself \\uD83E\\uDD23**\\n-------------------thanks---------------\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nOKAY chill, here is the better and concise solution\\n**Explanation**\\nFirstly sum up the amount of gabages in total.\\nSecond find up the last position for each type.\\nCalculate the prefix sum array of the travel distance.\\nSum up the distance for each type of garbage.\\n\\n**Complexity\\nTime O(garbage + travel)\\nSpace O(1)**\\n\\n\\n**Java**\\n\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int last[] = new int[128], res = 0;\\n        for (int i = 0; i < garbage.length; ++i) {\\n            res += garbage[i].length();\\n            for (int j = 0; j < garbage[i].length(); ++j)\\n                last[garbage[i].charAt(j)] = i;\\n        }\\n        for (int j = 1; j < travel.length; ++j)\\n            travel[j] += travel[j - 1];\\n        for (int c : \"PGM\".toCharArray())\\n            if (last[c] > 0)\\n                res += travel[last[c] - 1];\\n        return res;\\n    }\\n\\t\\n**C++**\\n\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int last[128] = {}, res = 0;\\n        for (int i = 0; i < garbage.size(); ++i) {\\n            res += garbage[i].size();\\n            for (char c : garbage[i])\\n                last[c] = i;\\n        }\\n        for (int j = 1; j < travel.size(); ++j)\\n            travel[j] += travel[j - 1];\\n        for (int c : \"PGM\")\\n            if (last[c])\\n                res += travel[last[c] - 1];\\n        return res;\\n    }\\n\\t\\nENJOYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        int sum = 0;\\n        \\n        int[] arr = new int[3];\\n        int[][] mat = new int[garbage.length][3];\\n        for(int i=0;i<garbage.length;i++){\\n            String str = garbage[i];\\n            for(char ch : str.toCharArray()){\\n                if(ch==\\'G\\'){\\n                    mat[i][0]++;\\n                    arr[0]++;\\n                }\\n                else if(ch==\\'M\\'){\\n                    mat[i][1]++;\\n                    arr[1]++;\\n                }\\n                else if(ch==\\'P\\'){\\n                    mat[i][2]++;\\n                    arr[2]++;\\n                }\\n            }\\n        }\\n        \\n        // for G truck\\n        if(arr[0]>0){\\n        for(int i=0;i<garbage.length;i++){\\n            if(arr[0]==0)\\n                break;\\n            if(i>0 && arr[0]!=0)\\n                 sum+=travel[i-1];\\n            if(mat[i][0]!=0){\\n                sum+=mat[i][0];\\n                arr[0] -= mat[i][0];\\n            }\\n            \\n            \\n        }\\n        }\\n        \\n        // for M truck\\n        if(arr[1]>0){\\n        for(int i=0;i<garbage.length;i++){\\n            if(arr[1]==0)\\n                break;\\n            if(i>0 && arr[1]!=0)\\n                 sum+=travel[i-1];\\n            if(mat[i][1]!=0){\\n                sum+=mat[i][1];\\n                arr[1] -= mat[i][1];\\n            }\\n            \\n        }\\n        }\\n        \\n        // for P truck\\n        if(arr[2]>0){\\n        for(int i=0;i<garbage.length;i++){\\n            if(arr[2]==0)\\n                break;\\n             if(i>0 && arr[2]!=0)\\n                 sum+=travel[i-1];\\n            if(mat[i][2]!=0){\\n                sum+=mat[i][2];\\n                arr[2] -= mat[i][2];\\n            }\\n            \\n        }\\n        }\\n       \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494981,
                "title": "python-simple-python-solution-using-prefix-sum-and-hashmap",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 2151 ms, faster than 25.00% of Python3 online submissions for Minimum Amount of Time to Collect Garbage.\\n# Memory Usage: 36.3 MB, less than 25.00% of Python3 online submissions for Minimum Amount of Time to Collect Garbage.\\n\\n\\tclass Solution:\\n\\t\\tdef garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tprefix_sum = []\\n\\n\\t\\t\\tfor i in range(len(travel)):\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tprefix_sum.append(travel[0])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprefix_sum.append(prefix_sum[ i - 1 ] + travel[i])\\n\\n\\t\\t\\tfrequency = {\\'P\\': [0,0], \\'M\\': [0,0], \\'G\\': [0,0]}\\n\\n\\t\\t\\tfor i in range(len(garbage)):\\n\\n\\t\\t\\t\\tG_Count = garbage[i].count(\\'G\\')\\n\\t\\t\\t\\tP_Count = garbage[i].count(\\'P\\')\\n\\t\\t\\t\\tM_Count = garbage[i].count(\\'M\\')\\n\\n\\t\\t\\t\\tif \\'P\\' in garbage[i]:\\n\\t\\t\\t\\t\\tfrequency[\\'P\\'][0] = frequency[\\'P\\'][0] + P_Count\\n\\t\\t\\t\\t\\tfrequency[\\'P\\'][1] = i\\n\\n\\t\\t\\t\\tif \\'M\\' in garbage[i]:\\n\\t\\t\\t\\t\\tfrequency[\\'M\\'][0] = frequency[\\'M\\'][0] + M_Count\\n\\t\\t\\t\\t\\tfrequency[\\'M\\'][1] = i\\n\\n\\t\\t\\t\\tif \\'G\\' in garbage[i]:\\n\\t\\t\\t\\t\\tfrequency[\\'G\\'][0] = frequency[\\'G\\'][0] + G_Count\\n\\t\\t\\t\\t\\tfrequency[\\'G\\'][1] = i\\n\\n\\t\\t\\tfor key in frequency:\\n\\n\\t\\t\\t\\tfrequency_count, last_index = frequency[key]\\n\\n\\t\\t\\t\\tresult = result + frequency_count\\n\\n\\t\\t\\t\\tif last_index != 0:\\n\\n\\t\\t\\t\\t\\tresult = result + prefix_sum[last_index - 1]\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n\\t\\tdef garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tprefix_sum = []\\n\\n\\t\\t\\tfor i in range(len(travel)):\\n\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\tprefix_sum.append(travel[0])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tprefix_sum.append(prefix_sum[ i - 1 ] + travel[i])\\n\\n\\t\\t\\tfrequency = {\\'P\\': [0,0], \\'M\\': [0,0], \\'G\\': [0,0]}",
                "codeTag": "Java"
            },
            {
                "id": 2494803,
                "title": "easy-understanding-python-o-1-space",
                "content": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        res=0\\n        temp=[-1,-1,-1]\\n        #     G,M,P\\n        for i in range(len(garbage)):\\n            for j in garbage[i]:\\n                res+=1\\n                if j==\"G\":\\n                    temp[0]=i\\n                elif j==\"M\":\\n                    temp[1]=i\\n                else:\\n                    temp[2]=i\\n        \\n        for i in range(3):\\n            if temp[i]==-1:\\n                continue\\n            res+=sum(travel[0:temp[i]])\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        res=0\\n        temp=[-1,-1,-1]\\n        #     G,M,P\\n        for i in range(len(garbage)):\\n            for j in garbage[i]:\\n                res+=1\\n                if j==\"G\":\\n                    temp[0]=i\\n                elif j==\"M\":\\n                    temp[1]=i\\n                else:\\n                    temp[2]=i\\n        \\n        for i in range(3):\\n            if temp[i]==-1:\\n                continue\\n            res+=sum(travel[0:temp[i]])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494760,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\t\\n\\t\\tint n = garbage.size();\\n\\t\\t\\n\\t\\tvector<vector<int>>mat(n,vector<int>(3,0));\\n        // 0-->M , 1-->P , 2-->G\\n\\t\\t\\n\\t\\tint lm=-1,lp=-1,lg=-1; // last indexes of m , p and g \\n\\t\\t\\n\\t\\tfor(int i=0 ; i<n ; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0 ; j<garbage[i].size() ; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(garbage[i][j] == \\'M\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlm=i;\\n\\t\\t\\t\\t\\tmat[i][0]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(garbage[i][j] == \\'P\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlp=i;\\n\\t\\t\\t\\t\\tmat[i][1]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlg=i;\\n\\t\\t\\t\\t\\tmat[i][2]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// values are stored upto now \\n\\t\\t\\n\\t\\tint time = 0;\\n\\t\\tint i=0;\\n\\t\\t// time for m \\n\\t\\twhile(i<lm)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[i][0];\\n\\t\\t\\ttime+=travel[i];\\n            i++;\\n\\t\\t}\\n\\t\\tif(lm!=-1)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[lm][0];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// time for p\\n\\t\\ti=0;\\n\\t\\twhile(i<lp)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[i][1];\\n\\t\\t\\ttime+=travel[i];\\n            i++;\\n\\t\\t}\\n\\t\\tif(lp!=-1)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[lp][1];\\n\\t\\t}\\n        \\n\\t\\t// time for g\\n\\t\\ti=0;\\n\\t\\twhile(i<lg)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[i][2];\\n\\t\\t\\ttime+=travel[i];\\n            i++;\\n\\t\\t}\\n\\t\\tif(lg!=-1)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[lg][2];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn time;\\n\\t\\t\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\t\\n\\t\\tint n = garbage.size();\\n\\t\\t\\n\\t\\tvector<vector<int>>mat(n,vector<int>(3,0));\\n        // 0-->M , 1-->P , 2-->G\\n\\t\\t\\n\\t\\tint lm=-1,lp=-1,lg=-1; // last indexes of m , p and g \\n\\t\\t\\n\\t\\tfor(int i=0 ; i<n ; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0 ; j<garbage[i].size() ; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(garbage[i][j] == \\'M\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlm=i;\\n\\t\\t\\t\\t\\tmat[i][0]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(garbage[i][j] == \\'P\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlp=i;\\n\\t\\t\\t\\t\\tmat[i][1]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlg=i;\\n\\t\\t\\t\\t\\tmat[i][2]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t// values are stored upto now \\n\\t\\t\\n\\t\\tint time = 0;\\n\\t\\tint i=0;\\n\\t\\t// time for m \\n\\t\\twhile(i<lm)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[i][0];\\n\\t\\t\\ttime+=travel[i];\\n            i++;\\n\\t\\t}\\n\\t\\tif(lm!=-1)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[lm][0];\\n\\t\\t}\\n\\t\\t\\n\\t\\t// time for p\\n\\t\\ti=0;\\n\\t\\twhile(i<lp)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[i][1];\\n\\t\\t\\ttime+=travel[i];\\n            i++;\\n\\t\\t}\\n\\t\\tif(lp!=-1)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[lp][1];\\n\\t\\t}\\n        \\n\\t\\t// time for g\\n\\t\\ti=0;\\n\\t\\twhile(i<lg)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[i][2];\\n\\t\\t\\ttime+=travel[i];\\n            i++;\\n\\t\\t}\\n\\t\\tif(lg!=-1)\\n\\t\\t{\\n\\t\\t\\ttime+=mat[lg][2];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn time;\\n\\t\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494561,
                "title": "minimum-amount-of-time-to-collect-garbage-java-solution",
                "content": "```\\nclass Solution {\\n    public int units(String house, char garbage){\\n        int unit = 0;\\n        for(int i = 0; i < house.length(); i++){\\n            if(garbage == house.charAt(i)) unit++;\\n        }\\n        return unit;\\n    }\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        // let g, m and p store result of G, M and P\\n        int g = 0, m = 0, p = 0, i = 0,\\n        // let gi,mi and pi store last indeces upto which truck has to go\\n        gi = 0, mi = 0, pi = 0;\\n        //maintaining the units of garbage for g, m, p\\n        for(String house: garbage){\\n            int munit = units(house, \\'M\\');m+=munit;\\n            int punit = units(house, \\'P\\');p+=punit;\\n            int gunit = units(house, \\'G\\');g+=gunit;\\n            if(munit != 0) mi = i;\\n            if(punit != 0) pi = i;\\n            if(gunit != 0) gi = i;\\n            i++;\\n        }\\n        //adding the travel units\\n        while(mi--!=0){\\n            m+=travel[mi];\\n        }\\n        while(pi--!=0){\\n            p+=travel[pi];\\n        }\\n        while(gi--!=0){\\n            g+=travel[gi];\\n        }\\n        return m+g+p;\\n    }\\n}\\n\\n// Time complexity: O(n*s + m) \\n// n = length of garbage array\\n// s =  length of string garbage[i]\\n// m = length of travel array\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int units(String house, char garbage){\\n        int unit = 0;\\n        for(int i = 0; i < house.length(); i++){\\n            if(garbage == house.charAt(i)) unit++;\\n        }\\n        return unit;\\n    }\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        // let g, m and p store result of G, M and P\\n        int g = 0, m = 0, p = 0, i = 0,\\n        // let gi,mi and pi store last indeces upto which truck has to go\\n        gi = 0, mi = 0, pi = 0;\\n        //maintaining the units of garbage for g, m, p\\n        for(String house: garbage){\\n            int munit = units(house, \\'M\\');m+=munit;\\n            int punit = units(house, \\'P\\');p+=punit;\\n            int gunit = units(house, \\'G\\');g+=gunit;\\n            if(munit != 0) mi = i;\\n            if(punit != 0) pi = i;\\n            if(gunit != 0) gi = i;\\n            i++;\\n        }\\n        //adding the travel units\\n        while(mi--!=0){\\n            m+=travel[mi];\\n        }\\n        while(pi--!=0){\\n            p+=travel[pi];\\n        }\\n        while(gi--!=0){\\n            g+=travel[gi];\\n        }\\n        return m+g+p;\\n    }\\n}\\n\\n// Time complexity: O(n*s + m) \\n// n = length of garbage array\\n// s =  length of string garbage[i]\\n// m = length of travel array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494382,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        // let g, m and p store result of G, M and P\\n        int g = 0, m = 0, p = 0;\\n        // let gEnd,mEnd and pEnd store last indeces upto which truck has to go\\n        int gEnd = -1, mEnd = -1, pEnd = -1;\\n        for (int i = 0; i < garbage.length; i++) {\\n            for (int j = 0; j < garbage[i].length(); j++) {\\n                if (garbage[i].charAt(j) == \\'G\\') {\\n                    g++;\\n                    // update gEnd to index i - 1\\n                    gEnd = i - 1;\\n                } else if (garbage[i].charAt(j) == \\'M\\') {\\n                    m++;\\n                    // update mEnd to index i - 1\\n                    mEnd = i - 1;\\n                } else {\\n                    p++;\\n                    // update pEnd to index i - 1\\n                    pEnd = i - 1;\\n                }\\n            }\\n        }\\n        // calculate sum of travel upto each points\\n        while (gEnd >= 0 || mEnd >= 0 || pEnd >= 0) {\\n            if (gEnd >= 0) g += travel[gEnd--];\\n            if (mEnd >= 0) m += travel[mEnd--];\\n            if (pEnd >= 0) p += travel[pEnd--];\\n        }\\n        return g + m + p;\\n    }\\n\\n    public int sum(int nums[], int end) {\\n        int sum = 0;\\n        for (int i = 0; i <= end; i++) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n\\n// Time complexity: O(n*s) for traversing all strings + O(m) for traversing through travel array\\n// n=> number of garbage strings\\n// s = > length of garbage string\\n// m=> length of travel array\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int garbageCollection(String[] garbage, int[] travel) {\\n        // let g, m and p store result of G, M and P\\n        int g = 0, m = 0, p = 0;\\n        // let gEnd,mEnd and pEnd store last indeces upto which truck has to go\\n        int gEnd = -1, mEnd = -1, pEnd = -1;\\n        for (int i = 0; i < garbage.length; i++) {\\n            for (int j = 0; j < garbage[i].length(); j++) {\\n                if (garbage[i].charAt(j) == \\'G\\') {\\n                    g++;\\n                    // update gEnd to index i - 1\\n                    gEnd = i - 1;\\n                } else if (garbage[i].charAt(j) == \\'M\\') {\\n                    m++;\\n                    // update mEnd to index i - 1\\n                    mEnd = i - 1;\\n                } else {\\n                    p++;\\n                    // update pEnd to index i - 1\\n                    pEnd = i - 1;\\n                }\\n            }\\n        }\\n        // calculate sum of travel upto each points\\n        while (gEnd >= 0 || mEnd >= 0 || pEnd >= 0) {\\n            if (gEnd >= 0) g += travel[gEnd--];\\n            if (mEnd >= 0) m += travel[mEnd--];\\n            if (pEnd >= 0) p += travel[pEnd--];\\n        }\\n        return g + m + p;\\n    }\\n\\n    public int sum(int nums[], int end) {\\n        int sum = 0;\\n        for (int i = 0; i <= end; i++) {\\n            sum += nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n\\n// Time complexity: O(n*s) for traversing all strings + O(m) for traversing through travel array\\n// n=> number of garbage strings\\n// s = > length of garbage string\\n// m=> length of travel array\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494146,
                "title": "find-the-last-index",
                "content": "```\\nclass Solution {\\n    func garbageCollection(_ garbage: [String], _ travel: [Int]) -> Int {\\n        let n = garbage.count\\n        // M, P, G\\n        var indexs = [0,0,0]\\n        var count = 0\\n        for i in 0..<n {\\n            let items = Array(garbage[i])\\n            count += items.count\\n            if items.contains(\"M\") {\\n                indexs[0] = i\\n            }\\n            if items.contains(\"P\") {\\n                indexs[1] = i\\n            } \\n            if items.contains(\"G\") {\\n                indexs[2] = i\\n            }\\n        }\\n        for i in 0..<travel.count {\\n            for j in 0..<3 {\\n                if i <= indexs[j]-1 {\\n                    count += travel[i]\\n                }   \\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func garbageCollection(_ garbage: [String], _ travel: [Int]) -> Int {\\n        let n = garbage.count\\n        // M, P, G\\n        var indexs = [0,0,0]\\n        var count = 0\\n        for i in 0..<n {\\n            let items = Array(garbage[i])\\n            count += items.count\\n            if items.contains(\"M\") {\\n                indexs[0] = i\\n            }\\n            if items.contains(\"P\") {\\n                indexs[1] = i\\n            } \\n            if items.contains(\"G\") {\\n                indexs[2] = i\\n            }\\n        }\\n        for i in 0..<travel.count {\\n            for j in 0..<3 {\\n                if i <= indexs[j]-1 {\\n                    count += travel[i]\\n                }   \\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494058,
                "title": "c-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        vector<vector<int>> mpp; //  <house number , {no. of metal, no. of paper, no. of glass (in that house number)}>\\n        \\n        int lastM = 0, lastP = 0, lastG = 0;\\n        for(int i=0;i<garbage.size();i++) {\\n            int m = 0, p = 0, g = 0;\\n            for(char &ch:garbage[i]) {\\n                if(ch == \\'M\\')   {\\n                    m++;\\n                    lastM = i;\\n                }\\n                else if(ch == \\'P\\') {\\n                    p++;\\n                    lastP = i;\\n                }\\n                else {\\n                    g++;\\n                    lastG = i;\\n                }\\n            }\\n            mpp.push_back({m,p,g});\\n        }\\n        \\n        int m = mpp[0][0], p = mpp[0][1], g = mpp[0][2];\\n        for(int i=1;i<garbage.size();i++) {\\n            if(i <= lastM) m += travel[i-1] + mpp[i][0];\\n            if(i <= lastP) p += travel[i-1] + mpp[i][1];\\n            if(i <= lastG) g += travel[i-1] + mpp[i][2];\\n        }\\n        return m+p+g;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        vector<vector<int>> mpp; //  <house number , {no. of metal, no. of paper, no. of glass (in that house number)}>\\n        \\n        int lastM = 0, lastP = 0, lastG = 0;\\n        for(int i=0;i<garbage.size();i++) {\\n            int m = 0, p = 0, g = 0;\\n            for(char &ch:garbage[i]) {\\n                if(ch == \\'M\\')   {\\n                    m++;\\n                    lastM = i;\\n                }\\n                else if(ch == \\'P\\') {\\n                    p++;\\n                    lastP = i;\\n                }\\n                else {\\n                    g++;\\n                    lastG = i;\\n                }\\n            }\\n            mpp.push_back({m,p,g});\\n        }\\n        \\n        int m = mpp[0][0], p = mpp[0][1], g = mpp[0][2];\\n        for(int i=1;i<garbage.size();i++) {\\n            if(i <= lastM) m += travel[i-1] + mpp[i][0];\\n            if(i <= lastP) p += travel[i-1] + mpp[i][1];\\n            if(i <= lastG) g += travel[i-1] + mpp[i][2];\\n        }\\n        return m+p+g;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493901,
                "title": "easy-java-explantion-o-n-faster-than-100-of-java-submissions",
                "content": "Runtime: 24 ms, faster than 100.00% of Java online submissions for Minimum Amount of Time to Collect Garbage.\\nMemory Usage: 68.2 MB, less than 100.00% of Java online submissions for Minimum Amount of Time to Collect Garbage.\\n\\n\\nexplanation:\\nTime taken will be of 2 types \\n1st to pickup anytype of garbage and\\n2nd to travel from house to house.\\n\\n\\n1st part\\n\\nAs given in problem for all type of garbage time taken to pick it up is 1 min,\\nso if we know count of all charaters present in \"garbage\" array we know how much time will be required to pick total garbages.\\nthis is achieved in  last statement of first loop\\n\\t\\t\\t\\tsum=sum+garbage[i].length();\\n\\t\\t\\t\\t\\n2nd part\\nTruck for collecting paper will only have to go till last house where paper garbage is available.\\nsame is the case for metal and glass.\\nso if we have last location of house with paper garbage, last location of house with glass garbage, last location of house with metal garbage then we can use Travel array to find out how much time is required to travel till the last house.\\n1st part of 1st loop is used to find index of last house with paper, glass, metal.\\n\\n2nd loop is used to find total time to travel till the last house with paper garbage,\\nglass garbage, metal garbage\\n\\n\\nIn code pl=last location of P, \\n\\t\\t\\t gl=last location of G,\\n\\t\\t\\t ml=last location of M,\\n\\t\\t\\t \\n\\t\\t\\t p=travel time for paper truck\\n\\t\\t\\t g=travel time for glass truck\\n\\t\\t\\t m=travel time for metal truck\\n\\t\\t\\t \\n\\t\\t\\t sum=time,\\n\\t\\t\\t \\nEasy to understand code:\\n\\n\\nclass Solution {\\n        public int garbageCollection(String[] garbage, int[] travel) {\\n     \\n        int ml=0,pl=0,gl=0;\\n        int sum=0;\\n        int p=0,g=0,m=0;\\n        \\n        for(int i=garbage.length-1;i>=0;i--){\\n            \\n            if(garbage[i].indexOf(\"P\")!=-1 && pl==0)pl=i;\\n            if(garbage[i].indexOf(\"G\")!=-1 && gl==0)gl=i;\\n            if(garbage[i].indexOf(\"M\")!=-1 && ml==0)ml=i;\\n            sum=sum+garbage[i].length();\\n        }\\n        for(int i=0;i<travel.length;i++){\\n            \\n            if(i<pl)p=p+travel[i];\\n            if(i<gl)g=g+travel[i];\\n            if(i<ml)m=m+travel[i];\\n        }\\n        return p+g+m+sum;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\nwe can reduce the variables p, g, m.\\nOptimized Code :\\n\\nclass Solution {\\n        public int garbageCollection(String[] garbage, int[] travel) {\\n     \\n        int ml=0,pl=0,gl=0;\\n        int sum=0;\\n        \\n        for(int i=garbage.length-1;i>=0;i--){\\n            \\n            if(garbage[i].indexOf(\"P\")!=-1 && pl==0)pl=i;\\n            if(garbage[i].indexOf(\"G\")!=-1 && gl==0)gl=i;\\n            if(garbage[i].indexOf(\"M\")!=-1 && ml==0)ml=i;\\n            sum=sum+garbage[i].length();\\n        }\\n        for(int i=0;i<travel.length;i++){\\n            \\n            if(i<pl)sum=sum+travel[i];\\n            if(i<gl)sum=sum+travel[i];\\n            if(i<ml)sum=sum+travel[i];\\n        }\\n        return sum;\\n    }\\n}\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int garbageCollection(String[] garbage, int[] travel) {\\n     \\n        int ml=0,pl=0,gl=0;\\n        int sum=0;\\n        int p=0,g=0,m=0;\\n        \\n        for(int i=garbage.length-1;i>=0;i--){\\n            \\n            if(garbage[i].indexOf(\"P\")!=-1 && pl==0)pl=i;\\n            if(garbage[i].indexOf(\"G\")!=-1 && gl==0)gl=i;\\n            if(garbage[i].indexOf(\"M\")!=-1 && ml==0)ml=i;\\n            sum=sum+garbage[i].length();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2493727,
                "title": "easy-c-code-with-optimization-and-prefix-sum",
                "content": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {  \\n        int res = 0;\\n        int sum = 0;\\n        \\n        for(int i=1;i<travel.size();i++){\\n            travel[i] += travel[i-1];\\n        }\\n        \\n        int mIndex = 0,pIndex = 0,gIndex = 0;\\n        \\n        for(int i = 0; i < garbage.size() ; i++){\\n            string str = garbage[i];\\n            res += str.length();\\n            \\n            for(int j = 0; j < str.length(); j++){\\n                if(str[j] == \\'M\\')  mIndex = i;\\n                if(str[j] == \\'P\\')  pIndex = i;\\n                if(str[j] == \\'G\\')  gIndex = i;\\n            }\\n        }\\n        \\n        if(mIndex != 0)  res += (mIndex == travel.size() ? travel[travel.size() - 1] : travel[mIndex-1]);\\n       \\n        if(pIndex != 0)  res += (pIndex == travel.size() ? travel[travel.size() - 1] : travel[pIndex-1]);            \\n        \\n        if(gIndex != 0)  res += (gIndex == travel.size() ? travel[travel.size() - 1] : travel[gIndex-1]);\\n        \\n        return res;\\n    }\\n```\\n\\n**Please upvote if you understood my solution**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {  \\n        int res = 0;\\n        int sum = 0;\\n        \\n        for(int i=1;i<travel.size();i++){\\n            travel[i] += travel[i-1];\\n        }\\n        \\n        int mIndex = 0,pIndex = 0,gIndex = 0;\\n        \\n        for(int i = 0; i < garbage.size() ; i++){\\n            string str = garbage[i];\\n            res += str.length();\\n            \\n            for(int j = 0; j < str.length(); j++){\\n                if(str[j] == \\'M\\')  mIndex = i;\\n                if(str[j] == \\'P\\')  pIndex = i;\\n                if(str[j] == \\'G\\')  gIndex = i;\\n            }\\n        }\\n        \\n        if(mIndex != 0)  res += (mIndex == travel.size() ? travel[travel.size() - 1] : travel[mIndex-1]);\\n       \\n        if(pIndex != 0)  res += (pIndex == travel.size() ? travel[travel.size() - 1] : travel[pIndex-1]);            \\n        \\n        if(gIndex != 0)  res += (gIndex == travel.size() ? travel[travel.size() - 1] : travel[gIndex-1]);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493702,
                "title": "easy-solution",
                "content": "public int garbageCollection(String[] gss, int[] travel) {\\n        \\n    int sum = 0;\\n        int p=0, g=0, m=0;\\n        \\n        //This Loop to provide last occurance of \\'P\\', \\'M\\' OR \\'G\\'\\n        //Count all the garbage\\n        \\n        for(int i = 0; i < gss.length; i++){\\n            for(char ch : gss[i].toCharArray()){\\n                if(ch == \\'P\\')\\n                    p = i;\\n                if(ch == \\'G\\')\\n                    g = i;\\n                if(ch == \\'M\\')\\n                    m = i;\\n                \\n                sum++;\\n            }\\n        }\\n        \\n        for(int i = 1 ; i < travel.length; i++){\\n            travel[i] += travel[i-1];\\n        }\\n        \\n        \\n        if( p != 0 )\\n            sum += travel[p-1];\\n        \\n        if( g != 0 )\\n            sum += travel[g-1];\\n        \\n        if( m != 0 )\\n            sum += travel[m-1];\\n        \\n            return sum;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int garbageCollection(String[] gss, int[] travel) {\\n        \\n    int sum = 0;\\n        int p=0, g=0, m=0;\\n        \\n        //This Loop to provide last occurance of \\'P\\', \\'M\\' OR \\'G\\'\\n        //Count all the garbage\\n        \\n        for(int i = 0; i < gss.length; i++){\\n            for(char ch : gss[i].toCharArray()){\\n                if(ch == \\'P\\')\\n                    p = i;\\n                if(ch == \\'G\\')\\n                    g = i;\\n                if(ch == \\'M\\')\\n                    m = i;\\n                \\n                sum++;\\n            }\\n        }\\n        \\n        for(int i = 1 ; i < travel.length; i++){\\n            travel[i] += travel[i-1];\\n        }\\n        \\n        \\n        if( p != 0 )\\n            sum += travel[p-1];\\n        \\n        if( g != 0 )\\n            sum += travel[g-1];\\n        \\n        if( m != 0 )\\n            sum += travel[m-1];\\n        \\n            return sum;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2493546,
                "title": "c-no-prefix-sum-easy-to-understand-o-1-space",
                "content": "**Just count the total garbage of each type present. then iterate over every string.**\\n```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int tm,tp,tg;\\n        tm = tp = tg = 0;\\n        int ans = 0;\\n        \\n        for(auto &g: garbage){\\n            for(auto &ty : g){\\n                if(ty==\\'M\\') tm++;\\n                else if(ty==\\'P\\') tp++;\\n                else tg++;\\n            }\\n        }\\n        \\n        for(int i=0;i<garbage.size();i++){\\n            for(auto &g: garbage[i]){\\n                if(g==\\'M\\'){\\n                    tm--;\\n                }else if(g==\\'P\\'){\\n                    tp--;\\n                }else{\\n                    tg--;\\n                }\\n\\t\\t\\t\\tans++; // any of the garbage must picked up\\n            }\\n            \\n\\t\\t\\t// if total of any kind is left then only add time to move truck to next house\\n            ans += tm>0 ? travel[i] : 0; \\n            ans += tp>0 ? travel[i] : 0;\\n            ans += tg>0 ? travel[i] : 0;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n**Upvote if you liked the solution.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int tm,tp,tg;\\n        tm = tp = tg = 0;\\n        int ans = 0;\\n        \\n        for(auto &g: garbage){\\n            for(auto &ty : g){\\n                if(ty==\\'M\\') tm++;\\n                else if(ty==\\'P\\') tp++;\\n                else tg++;\\n            }\\n        }\\n        \\n        for(int i=0;i<garbage.size();i++){\\n            for(auto &g: garbage[i]){\\n                if(g==\\'M\\'){\\n                    tm--;\\n                }else if(g==\\'P\\'){\\n                    tp--;\\n                }else{\\n                    tg--;\\n                }\\n\\t\\t\\t\\tans++; // any of the garbage must picked up\\n            }\\n            \\n\\t\\t\\t// if total of any kind is left then only add time to move truck to next house\\n            ans += tm>0 ? travel[i] : 0; \\n            ans += tp>0 ? travel[i] : 0;\\n            ans += tg>0 ? travel[i] : 0;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493506,
                "title": "c-easy-brute-force",
                "content": "\\n\\'\\'\\'\\n\\t\\n\\tint garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        int time=0;\\n        int M=0;\\n        int P=0;\\n        int G=0;\\n        int ans=0;\\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            for(int j=0;j<garbage[i].length();j++)\\n            {\\n                ans++;\\n                if(garbage[i][j]==\\'M\\') M=i;\\n                if(garbage[i][j]==\\'P\\') P=i;\\n                if(garbage[i][j]==\\'G\\') G=i;\\n            }\\n        }\\n        for(int i=0;i<travel.size();i++)\\n        {\\n            if(M>0)\\n            {\\n                ans+=travel[i];\\n                M--;\\n            }\\n            if(P>0)\\n            {\\n                ans+=travel[i];\\n                P--;\\n            }\\n            if(G>0)\\n            {\\n                ans+=travel[i];\\n                G--;\\n            }\\n        }\\n        return ans;   \\n    }",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\t\\n\\tint garbageCollection(vector<string>& garbage, vector<int>& travel) \\n    {\\n        int time=0;\\n        int M=0;\\n        int P=0;\\n        int G=0;\\n        int ans=0;\\n        for(int i=0;i<garbage.size();i++)\\n        {\\n            for(int j=0;j<garbage[i].length();j++)\\n            {\\n                ans++;\\n                if(garbage[i][j]==\\'M\\') M=i;\\n                if(garbage[i][j]==\\'P\\') P=i;\\n                if(garbage[i][j]==\\'G\\') G=i;\\n            }\\n        }\\n        for(int i=0;i<travel.size();i++)\\n        {\\n            if(M>0)\\n            {\\n                ans+=travel[i];\\n                M--;\\n            }\\n            if(P>0)\\n            {\\n                ans+=travel[i];\\n                P--;\\n            }\\n            if(G>0)\\n            {\\n                ans+=travel[i];\\n                G--;\\n            }\\n        }\\n        return ans;   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2493469,
                "title": "c-solution-time-o-n-memory-o-1-easy-to-understand-running-sum",
                "content": "```C#\\npublic class Solution {\\n    public int GarbageCollection(string[] garbage, int[] travel) {\\n        int ans = 0, paperTravelCosts = 0, metalTravelCosts = 0, glassTravelCosts = 0, sum = 0;\\n        int[] travelCosts = new int[3];\\n        for (int i = 0; i < garbage.Length; i++)\\n        {\\n            int paper = 0, metal = 0, glass = 0;\\n            for (int j = 0; j < garbage[i].Length; j++)\\n            {\\n                if (garbage[i][j] == \\'P\\') paper++;\\n                else if (garbage[i][j] == \\'M\\') metal++;\\n                else if (garbage[i][j] == \\'G\\') glass++;\\n            }\\n\\n            ans += paper + metal + glass;\\n            if (paper != 0) paperTravelCosts = sum;\\n            if (metal != 0) metalTravelCosts = sum;\\n            if (glass != 0) glassTravelCosts = sum;\\n            \\n            if (i < travel.Length) sum += travel[i];\\n        }\\n\\n        return ans + paperTravelCosts + metalTravelCosts + glassTravelCosts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public int GarbageCollection(string[] garbage, int[] travel) {\\n        int ans = 0, paperTravelCosts = 0, metalTravelCosts = 0, glassTravelCosts = 0, sum = 0;\\n        int[] travelCosts = new int[3];\\n        for (int i = 0; i < garbage.Length; i++)\\n        {\\n            int paper = 0, metal = 0, glass = 0;\\n            for (int j = 0; j < garbage[i].Length; j++)\\n            {\\n                if (garbage[i][j] == \\'P\\') paper++;\\n                else if (garbage[i][j] == \\'M\\') metal++;\\n                else if (garbage[i][j] == \\'G\\') glass++;\\n            }\\n\\n            ans += paper + metal + glass;\\n            if (paper != 0) paperTravelCosts = sum;\\n            if (metal != 0) metalTravelCosts = sum;\\n            if (glass != 0) glassTravelCosts = sum;\\n            \\n            if (i < travel.Length) sum += travel[i];\\n        }\\n\\n        return ans + paperTravelCosts + metalTravelCosts + glassTravelCosts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493396,
                "title": "python-9-line-short-solution",
                "content": "```\\nclass Solution:\\n    def timeForType(self, garbageType, garbage, travel):\\n        for i,g in zip(range(len(garbage)-1,-1,-1), garbage[::-1]):\\n            if garbageType in g:\\n                return sum(travel[:i+1])\\n        return 0\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        travel.insert(0,0)    \\n        return len(\\'\\'.join(garbage)) + sum([self.timeForType(t, garbage, travel) for t in \"PGM\" ])\\n  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def timeForType(self, garbageType, garbage, travel):\\n        for i,g in zip(range(len(garbage)-1,-1,-1), garbage[::-1]):\\n            if garbageType in g:\\n                return sum(travel[:i+1])\\n        return 0\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        travel.insert(0,0)    \\n        return len(\\'\\'.join(garbage)) + sum([self.timeForType(t, garbage, travel) for t in \"PGM\" ])\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493383,
                "title": "c-easy-code-with-explanation-using-preffix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int total_time = 0, cnt = 0, trav_time = 0;\\n        int mIdx = 0, gIdx = 0, pIdx = 0;\\n        \\n        // Caculating total garbage to pick and the farthest index upto which each of the G P M vehicles have to go\\n        for(int i = 0 ; i < garbage.size() ; i++){\\n            for(int j = 0 ; j < garbage[i].size() ; j++){\\n                if(garbage[i][j] == \\'G\\'){cnt++; gIdx = i;}\\n                else if(garbage[i][j] == \\'M\\'){cnt++; mIdx = i;}\\n                else if(garbage[i][j] == \\'P\\'){cnt++; pIdx = i;};                \\n            }\\n        }\\n        \\n        // Calculating preffix sum for precomputation of travel time till i\\'th index for each query\\n        for(int i = 1 ; i < travel.size() ; i++)travel[i] = travel[i] + travel[i - 1];\\n        \\n        // If index is 0 no need to travel\\n        if(pIdx > 0)trav_time += travel[pIdx - 1];\\n        if(gIdx > 0)trav_time += travel[gIdx - 1];\\n        if(mIdx > 0)trav_time += travel[mIdx - 1];  \\n        \\n        return cnt + trav_time;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int total_time = 0, cnt = 0, trav_time = 0;\\n        int mIdx = 0, gIdx = 0, pIdx = 0;\\n        \\n        // Caculating total garbage to pick and the farthest index upto which each of the G P M vehicles have to go\\n        for(int i = 0 ; i < garbage.size() ; i++){\\n            for(int j = 0 ; j < garbage[i].size() ; j++){\\n                if(garbage[i][j] == \\'G\\'){cnt++; gIdx = i;}\\n                else if(garbage[i][j] == \\'M\\'){cnt++; mIdx = i;}\\n                else if(garbage[i][j] == \\'P\\'){cnt++; pIdx = i;};                \\n            }\\n        }\\n        \\n        // Calculating preffix sum for precomputation of travel time till i\\'th index for each query\\n        for(int i = 1 ; i < travel.size() ; i++)travel[i] = travel[i] + travel[i - 1];\\n        \\n        // If index is 0 no need to travel\\n        if(pIdx > 0)trav_time += travel[pIdx - 1];\\n        if(gIdx > 0)trav_time += travel[gIdx - 1];\\n        if(mIdx > 0)trav_time += travel[mIdx - 1];  \\n        \\n        return cnt + trav_time;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493353,
                "title": "simple-c-solution-in-o-n",
                "content": "So the approch is simple just check from the last index to first and in between if the count of the garbage,glass and papper is 0 that means they don\\'t need to visit that house. \\n\\nHence just travel from last if the count !=0 means they need to collect the garbage so add the travel time to it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n            \\n        int x=0,y=0,z=0;\\n        for(int i=garbage.size()-1;i>=0;i--)\\n        {\\n          \\n            for(int j=0;j<garbage[i].size();j++)\\n            {\\n                if(garbage[i][j]==\\'M\\')\\n                    x++;\\n                else if(garbage[i][j]==\\'G\\')\\n                    y++;\\n                else\\n                    z++;\\n            }\\n            \\n            if(x!=0)\\n            {\\n                if(i>0)\\n                    x+=travel[i-1];\\n            }\\n            if(y!=0)\\n            {\\n                if(i>0)\\n                    y+=travel[i-1];\\n            }\\n            if(z!=0)\\n            {\\n                if(i>0)\\n                    z+=travel[i-1];\\n            }\\n       \\n        }\\n        \\n        return x+y+z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n            \\n        int x=0,y=0,z=0;\\n        for(int i=garbage.size()-1;i>=0;i--)\\n        {\\n          \\n            for(int j=0;j<garbage[i].size();j++)\\n            {\\n                if(garbage[i][j]==\\'M\\')\\n                    x++;\\n                else if(garbage[i][j]==\\'G\\')\\n                    y++;\\n                else\\n                    z++;\\n            }\\n            \\n            if(x!=0)\\n            {\\n                if(i>0)\\n                    x+=travel[i-1];\\n            }\\n            if(y!=0)\\n            {\\n                if(i>0)\\n                    y+=travel[i-1];\\n            }\\n            if(z!=0)\\n            {\\n                if(i>0)\\n                    z+=travel[i-1];\\n            }\\n       \\n        }\\n        \\n        return x+y+z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493152,
                "title": "easy-to-understand-python-solution-using-counter",
                "content": "NOTE: *\"cost\" here represents \"time\"*\\n\\nKey points:\\n\\n- At each house, we store the type of garbage and it\\'s count using a Counter.\\n- For each type of garbage truck, we store the cost to travel to that house in a temporary variable and only add it to our total cost if we find the type of garbage that our truck collects in that house. This helps in cases where we do not have the particular type of garbage our truck collects for all the remaining houses, and as a consequence we don\\'t need to travel these houses.\\n\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        travel = [0]+travel\\n        \\n        for i in range(len(garbage)):\\n            garbage[i] = Counter(garbage[i])\\n            \\n        total_cost = 0\\n        tmp_cost_p, tmp_cost_g, tmp_cost_m = 0, 0, 0\\n        \\n        for i,counter in enumerate(garbage):\\n            tmp_cost_p += travel[i]\\n            if counter[\"P\"]:\\n                total_cost+=counter[\"P\"]\\n                total_cost+=tmp_cost_p\\n                tmp_cost_p = 0\\n                \\n        for i,counter in enumerate(garbage):\\n            tmp_cost_g += travel[i]\\n            if counter[\"G\"]:\\n                total_cost+=counter[\"G\"]\\n                total_cost+=tmp_cost_g\\n                tmp_cost_g = 0\\n                \\n        for i,counter in enumerate(garbage):\\n            tmp_cost_m += travel[i]\\n            if counter[\"M\"]:\\n                total_cost+=counter[\"M\"]\\n                total_cost+=tmp_cost_m\\n                tmp_cost_m = 0\\n                \\n        return total_cost\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        travel = [0]+travel\\n        \\n        for i in range(len(garbage)):\\n            garbage[i] = Counter(garbage[i])\\n            \\n        total_cost = 0\\n        tmp_cost_p, tmp_cost_g, tmp_cost_m = 0, 0, 0\\n        \\n        for i,counter in enumerate(garbage):\\n            tmp_cost_p += travel[i]\\n            if counter[\"P\"]:\\n                total_cost+=counter[\"P\"]\\n                total_cost+=tmp_cost_p\\n                tmp_cost_p = 0\\n                \\n        for i,counter in enumerate(garbage):\\n            tmp_cost_g += travel[i]\\n            if counter[\"G\"]:\\n                total_cost+=counter[\"G\"]\\n                total_cost+=tmp_cost_g\\n                tmp_cost_g = 0\\n                \\n        for i,counter in enumerate(garbage):\\n            tmp_cost_m += travel[i]\\n            if counter[\"M\"]:\\n                total_cost+=counter[\"M\"]\\n                total_cost+=tmp_cost_m\\n                tmp_cost_m = 0\\n                \\n        return total_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493095,
                "title": "prefix-sum-c-solution",
                "content": "```\\nclass Solution {\\n#define ll long long\\npublic:\\n\\tint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\tunordered_map<char, ll> map;\\n\\t\\tll m = garbage.size();\\n\\t\\tll N = travel.size();\\n\\t\\tvector<ll> preSum(N + 1, 0);\\n\\t\\tfor (ll i = 0; i < N; ++i)\\n\\t\\t\\tpreSum[i + 1] = preSum[i] + travel[i];\\n\\t\\tll M = 0, G = 0, P = 0;\\n\\t\\tfor (ll i = 0; i < m; ++i) {\\n\\t\\t\\tfor (auto &it : garbage[i]) {\\n\\t\\t\\t\\tif (it == \\'G\\') map[\\'G\\'] = max(map[\\'G\\'], i), G++;\\n\\t\\t\\t\\tif (it == \\'M\\') map[\\'M\\'] = max(map[\\'M\\'], i), M++;\\n\\t\\t\\t\\tif (it == \\'P\\') map[\\'P\\'] = max(map[\\'P\\'], i), P++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tll res = P + M + G;\\n\\t\\tfor (auto &it : map) {\\n\\t\\t\\tll index = it.second;\\n\\t\\t\\tres += preSum[index];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n#define ll long long\\npublic:\\n\\tint garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n\\t\\tunordered_map<char, ll> map;\\n\\t\\tll m = garbage.size();\\n\\t\\tll N = travel.size();\\n\\t\\tvector<ll> preSum(N + 1, 0);\\n\\t\\tfor (ll i = 0; i < N; ++i)\\n\\t\\t\\tpreSum[i + 1] = preSum[i] + travel[i];\\n\\t\\tll M = 0, G = 0, P = 0;\\n\\t\\tfor (ll i = 0; i < m; ++i) {\\n\\t\\t\\tfor (auto &it : garbage[i]) {\\n\\t\\t\\t\\tif (it == \\'G\\') map[\\'G\\'] = max(map[\\'G\\'], i), G++;\\n\\t\\t\\t\\tif (it == \\'M\\') map[\\'M\\'] = max(map[\\'M\\'], i), M++;\\n\\t\\t\\t\\tif (it == \\'P\\') map[\\'P\\'] = max(map[\\'P\\'], i), P++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tll res = P + M + G;\\n\\t\\tfor (auto &it : map) {\\n\\t\\t\\tll index = it.second;\\n\\t\\t\\tres += preSum[index];\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493090,
                "title": "simple-intuition-no-prefix-sum-no-complicated-logic",
                "content": "### Simple Verbose C++ Solution\\n\\nSimple intuition\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int garbageCollection(vector<string> &garbage, vector<int> &travel)\\n    {\\n        int g = 0, m = 0, p = 0, gt = 0, mt = 0, pt = 0, ans = 0;\\n        g += count(garbage[0].begin(), garbage[0].end(), \\'G\\');\\n        m += count(garbage[0].begin(), garbage[0].end(), \\'M\\');\\n        p += count(garbage[0].begin(), garbage[0].end(), \\'P\\');\\n        ans = g + m + p;\\n\\n        g = 0;\\n        m = 0;\\n        p = 0;\\n\\n        for(int i = 1; i < garbage.size(); i++)\\n        {\\n            string s = garbage[i];\\n            g += count(s.begin(), s.end(), \\'G\\');\\n            m += count(s.begin(), s.end(), \\'M\\');\\n            p += count(s.begin(), s.end(), \\'P\\');\\n\\n            gt += travel[i - 1];\\n            mt += travel[i - 1];\\n            pt += travel[i - 1];\\n            if(g != 0)\\n            {\\n                ans += (g + gt); \\n                gt = 0;\\n                g = 0;\\n            }\\n            if(m != 0)\\n            {\\n                ans += (m + mt); \\n                mt = 0;\\n                m = 0;\\n            }\\n            if(p != 0)\\n            {\\n                ans += (p + pt); \\n                pt = 0;\\n                p = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int garbageCollection(vector<string> &garbage, vector<int> &travel)\\n    {\\n        int g = 0, m = 0, p = 0, gt = 0, mt = 0, pt = 0, ans = 0;\\n        g += count(garbage[0].begin(), garbage[0].end(), \\'G\\');\\n        m += count(garbage[0].begin(), garbage[0].end(), \\'M\\');\\n        p += count(garbage[0].begin(), garbage[0].end(), \\'P\\');\\n        ans = g + m + p;\\n\\n        g = 0;\\n        m = 0;\\n        p = 0;\\n\\n        for(int i = 1; i < garbage.size(); i++)\\n        {\\n            string s = garbage[i];\\n            g += count(s.begin(), s.end(), \\'G\\');\\n            m += count(s.begin(), s.end(), \\'M\\');\\n            p += count(s.begin(), s.end(), \\'P\\');\\n\\n            gt += travel[i - 1];\\n            mt += travel[i - 1];\\n            pt += travel[i - 1];\\n            if(g != 0)\\n            {\\n                ans += (g + gt); \\n                gt = 0;\\n                g = 0;\\n            }\\n            if(m != 0)\\n            {\\n                ans += (m + mt); \\n                mt = 0;\\n                m = 0;\\n            }\\n            if(p != 0)\\n            {\\n                ans += (p + pt); \\n                pt = 0;\\n                p = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492964,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int garbageCollection(vector<string>& v, vector<int>& t) {\\n        ll ans=0, sz = v.size(), g = -1, s = -1, p = -1;\\n        vi(vi(ll))psv(sz, vi(ll)(3, 0));\\n        vi(ll)psc(sz, 0);\\n        for (ll i = 0;i < sz;++i) {\\n            ll gt = 0, pt = 0, st = 0;\\n            for (char ch : v[i]) {\\n                if (ch == \\'G\\') {\\n                    ++gt;\\n                }\\n                else if (ch == \\'P\\') {\\n                    ++pt;\\n                }\\n                else {\\n                    ++st;\\n                }\\n            }\\n            if (gt > 0) {\\n                g = i;\\n            }\\n            if (st > 0) {\\n                s = i;\\n            }\\n            if (pt > 0) {\\n                p = i;\\n            }\\n            psv[i][0] = gt, psv[i][1] = st;psv[i][2] = pt;\\n            if (i > 0) {\\n                psv[i][0] += psv[i - 1][0], psv[i][1] += psv[i - 1][1];psv[i][2] += psv[i - 1][2];\\n                psc[i] = psc[i - 1] + t[i - 1];\\n            }\\n        }\\n        if (g > -1) {\\n            ans += psc[g] + psv[g][0];\\n        }\\n        if (s > -1) {\\n            ans += psc[s] + psv[s][1];\\n        }\\n        if (p > -1) {\\n            ans += psc[p] + psv[p][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    int garbageCollection(vector<string>& v, vector<int>& t) {\\n        ll ans=0, sz = v.size(), g = -1, s = -1, p = -1;\\n        vi(vi(ll))psv(sz, vi(ll)(3, 0));\\n        vi(ll)psc(sz, 0);\\n        for (ll i = 0;i < sz;++i) {\\n            ll gt = 0, pt = 0, st = 0;\\n            for (char ch : v[i]) {\\n                if (ch == \\'G\\') {\\n                    ++gt;\\n                }\\n                else if (ch == \\'P\\') {\\n                    ++pt;\\n                }\\n                else {\\n                    ++st;\\n                }\\n            }\\n            if (gt > 0) {\\n                g = i;\\n            }\\n            if (st > 0) {\\n                s = i;\\n            }\\n            if (pt > 0) {\\n                p = i;\\n            }\\n            psv[i][0] = gt, psv[i][1] = st;psv[i][2] = pt;\\n            if (i > 0) {\\n                psv[i][0] += psv[i - 1][0], psv[i][1] += psv[i - 1][1];psv[i][2] += psv[i - 1][2];\\n                psc[i] = psc[i - 1] + t[i - 1];\\n            }\\n        }\\n        if (g > -1) {\\n            ans += psc[g] + psv[g][0];\\n        }\\n        if (s > -1) {\\n            ans += psc[s] + psv[s][1];\\n        }\\n        if (p > -1) {\\n            ans += psc[p] + psv[p][2];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492875,
                "title": "c-frequency-count-o-n-solution",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        vector<vector<int>> freq(garbage.size(),vector<int> (3,0)); // frequency for each type of garbage for all indexes\\n        \\n        int lastM=-1, lastP=-1, lastG=-1; // to keep track of last indexes where the respective trucks have to move\\n        for(int i=0;i<garbage.size();i++){\\n            for(int j=0;j<garbage[i].length();j++){\\n                if(garbage[i][j] == \\'M\\') freq[i][0]++, lastM=i;\\n                if(garbage[i][j] == \\'P\\') freq[i][1]++, lastP=i;\\n                if(garbage[i][j] == \\'G\\') freq[i][2]++, lastG=i;\\n            }\\n        }\\n        \\n        int t=0;\\n        for(int i=0;i<garbage.size();i++){\\n            if(i<=lastM) t += freq[i][0] + (i>0 ? travel[i-1]:0);\\n            if(i<=lastP) t += freq[i][1] + (i>0 ? travel[i-1]:0);\\n            if(i<=lastG) t += freq[i][2] + (i>0 ? travel[i-1]:0);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        vector<vector<int>> freq(garbage.size(),vector<int> (3,0)); // frequency for each type of garbage for all indexes\\n        \\n        int lastM=-1, lastP=-1, lastG=-1; // to keep track of last indexes where the respective trucks have to move\\n        for(int i=0;i<garbage.size();i++){\\n            for(int j=0;j<garbage[i].length();j++){\\n                if(garbage[i][j] == \\'M\\') freq[i][0]++, lastM=i;\\n                if(garbage[i][j] == \\'P\\') freq[i][1]++, lastP=i;\\n                if(garbage[i][j] == \\'G\\') freq[i][2]++, lastG=i;\\n            }\\n        }\\n        \\n        int t=0;\\n        for(int i=0;i<garbage.size();i++){\\n            if(i<=lastM) t += freq[i][0] + (i>0 ? travel[i-1]:0);\\n            if(i<=lastP) t += freq[i][1] + (i>0 ? travel[i-1]:0);\\n            if(i<=lastG) t += freq[i][2] + (i>0 ? travel[i-1]:0);\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492860,
                "title": "two-hash-tables-with-explanation-and-complexity-analysis",
                "content": "##### Rationale\\n* We could maintain two Hash Tables to maintain the total distances the three trucks cover and the total garbage they pick\\n* We maintain the total distance we\\'ve covered (from house 0) with a variable (think about prefix array)\\n* At any time, we could iterate over the garbage collection, and update the `total_garbage_picked` for the type and replace the total distance covered for the type\\n* At last, we could sum up all the work that we\\'ve done\\n\\n##### Complexities\\n* Time: `O(n)`\\n* Space: `O(1)`\\n\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        total_distance_travelled = defaultdict(int)\\n        total_garbage_picked = defaultdict(int)\\n        \\n        distance_travelled = 0\\n        \\n        for index, grbg in enumerate(garbage):\\n            if index > 0:\\n                distance_travelled += travel[index - 1]\\n                \\n            for garbage_type in grbg:\\n                total_garbage_picked[garbage_type] += 1 \\n                total_distance_travelled[garbage_type] = distance_travelled\\n                    \\n        count = 0 \\n        for garbage_type in \"MPG\":\\n            count += total_garbage_picked[garbage_type] + total_distance_travelled[garbage_type]\\n            \\n        return count\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        total_distance_travelled = defaultdict(int)\\n        total_garbage_picked = defaultdict(int)\\n        \\n        distance_travelled = 0\\n        \\n        for index, grbg in enumerate(garbage):\\n            if index > 0:\\n                distance_travelled += travel[index - 1]\\n                \\n            for garbage_type in grbg:\\n                total_garbage_picked[garbage_type] += 1 \\n                total_distance_travelled[garbage_type] = distance_travelled\\n                    \\n        count = 0 \\n        for garbage_type in \"MPG\":\\n            count += total_garbage_picked[garbage_type] + total_distance_travelled[garbage_type]\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492750,
                "title": "python-with-explanation-time-o-n-m-n-len-gabrage-m-len-gabrage-i",
                "content": "Simply count the total number of gabrage, and then store the longest house that contains each type of the gabrage. Adding the travel time for each truck.\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        M = P = G = 0\\n        res = 0\\n        for i,gar in enumerate(garbage):\\n            count =Counter(gar)\\n            if count[\\'G\\']!=0:\\n                G = i\\n            if count[\\'P\\']!=0:\\n                P = i\\n            if count[\\'M\\']!=0:\\n                M = i\\n            res += sum(count.values())\\n        res += sum(travel[:M])\\n        res += sum(travel[:P])\\n        res += sum(travel[:G])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        M = P = G = 0\\n        res = 0\\n        for i,gar in enumerate(garbage):\\n            count =Counter(gar)\\n            if count[\\'G\\']!=0:\\n                G = i\\n            if count[\\'P\\']!=0:\\n                P = i\\n            if count[\\'M\\']!=0:\\n                M = i\\n            res += sum(count.values())\\n        res += sum(travel[:M])\\n        res += sum(travel[:P])\\n        res += sum(travel[:G])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492711,
                "title": "java-one-loop-solution",
                "content": "Check for end to start and mark it.\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n```\\nclass Solution {\\n  public int garbageCollection(String[] garbage, int[] travel) {\\n    final int n = garbage.length;\\n    int minutes = 0;\\n\\n    int[] prefix = new int[n];\\n\\n    for (int i = 1; i < n; i++) {\\n      prefix[i] += prefix[i - 1] + travel[i - 1];\\n    }\\n\\n    // \\'M\\', \\'P\\' and \\'G\\'\\n    boolean[] seen = new boolean[3];\\n    for (int i = n - 1; i >= 0; i--) {\\n      for (char c : garbage[i].toCharArray()) {\\n        minutes++;\\n        switch (c) {\\n          case \\'M\\':\\n            if (!seen[0]) {\\n              seen[0] = true;\\n              minutes += prefix[i];\\n            }\\n            break;\\n          case \\'P\\':\\n            if (!seen[1]) {\\n              seen[1] = true;\\n              minutes += prefix[i];\\n            }\\n            break;\\n          default:\\n            // G\\n            if (!seen[2]) {\\n              seen[2] = true;\\n              minutes += prefix[i];\\n            }\\n        }\\n      }\\n    }\\n\\n    return minutes;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n  public int garbageCollection(String[] garbage, int[] travel) {\\n    final int n = garbage.length;\\n    int minutes = 0;\\n\\n    int[] prefix = new int[n];\\n\\n    for (int i = 1; i < n; i++) {\\n      prefix[i] += prefix[i - 1] + travel[i - 1];\\n    }\\n\\n    // \\'M\\', \\'P\\' and \\'G\\'\\n    boolean[] seen = new boolean[3];\\n    for (int i = n - 1; i >= 0; i--) {\\n      for (char c : garbage[i].toCharArray()) {\\n        minutes++;\\n        switch (c) {\\n          case \\'M\\':\\n            if (!seen[0]) {\\n              seen[0] = true;\\n              minutes += prefix[i];\\n            }\\n            break;\\n          case \\'P\\':\\n            if (!seen[1]) {\\n              seen[1] = true;\\n              minutes += prefix[i];\\n            }\\n            break;\\n          default:\\n            // G\\n            if (!seen[2]) {\\n              seen[2] = true;\\n              minutes += prefix[i];\\n            }\\n        }\\n      }\\n    }\\n\\n    return minutes;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098777,
                "title": "minimum-time-to-collect-garbage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //pikup time store\\n        int pickM=0;\\n        int pickP=0;\\n        int pickG=0;\\n\\n        //time taken store\\n        int travelM=0;\\n        int travelP=0;\\n        int travelG=0;\\n\\n        //last occured store\\n        int lastM=0;\\n        int lastP=0;\\n        int lastG=0;\\n\\n        //so two timing we have to find pickup time and travel  time\\n\\n        //pick up time\\n\\n        for(int j=0;j<garbage.size();j++){\\n            string current=garbage[j];\\n            for(int i=0;i<current.length();i++){\\n                char ch=current[i];\\n                if(ch==\\'P\\'){\\n                    pickP++;\\n                    lastP=j;\\n                }\\n                else if(ch==\\'M\\'){\\n                    pickM++;\\n                    lastM=j;\\n                }\\n                else if(ch==\\'G\\'){\\n                    pickG++;\\n                    lastG=j;\\n                }\\n            }\\n        }\\n\\n        //travel time\\n        for(int i=0;i<lastP;i++){\\n            travelP+=travel[i];\\n        }\\n        for(int i=0;i<lastM;i++){\\n            travelM+=travel[i];\\n        }\\n        for(int i=0;i<lastG;i++){\\n            travelG+=travel[i];\\n        }\\n        int ans=(pickP+travelP)+(pickM+travelM)+(pickG+travelG);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        //pikup time store\\n        int pickM=0;\\n        int pickP=0;\\n        int pickG=0;\\n\\n        //time taken store\\n        int travelM=0;\\n        int travelP=0;\\n        int travelG=0;\\n\\n        //last occured store\\n        int lastM=0;\\n        int lastP=0;\\n        int lastG=0;\\n\\n        //so two timing we have to find pickup time and travel  time\\n\\n        //pick up time\\n\\n        for(int j=0;j<garbage.size();j++){\\n            string current=garbage[j];\\n            for(int i=0;i<current.length();i++){\\n                char ch=current[i];\\n                if(ch==\\'P\\'){\\n                    pickP++;\\n                    lastP=j;\\n                }\\n                else if(ch==\\'M\\'){\\n                    pickM++;\\n                    lastM=j;\\n                }\\n                else if(ch==\\'G\\'){\\n                    pickG++;\\n                    lastG=j;\\n                }\\n            }\\n        }\\n\\n        //travel time\\n        for(int i=0;i<lastP;i++){\\n            travelP+=travel[i];\\n        }\\n        for(int i=0;i<lastM;i++){\\n            travelM+=travel[i];\\n        }\\n        for(int i=0;i<lastG;i++){\\n            travelG+=travel[i];\\n        }\\n        int ans=(pickP+travelP)+(pickM+travelM)+(pickG+travelG);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097113,
                "title": "c-solution-of-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int pp = 0; \\n        int pm = 0; \\n        int pg = 0; \\n\\n        int tp =0;\\n        int tm =0;\\n        int tg =0;\\n\\n        int lp= 0;\\n        int lg= 0;\\n        int lm= 0;\\n\\n        for(int i = 0; i<garbage.size(); i++){\\n            string curr = garbage[i];\\n            for(int j =0; j<curr.length(); j++){\\n                char ch = curr[j]; \\n                if(ch == \\'P\\'){\\n                    pp++;\\n                    lp  = i; \\n                }\\n                else if(ch == \\'G\\'){\\n                    pg++;\\n                    lg = i; \\n                }\\n                else if(ch == \\'M\\'){\\n                    pm++;\\n                    lm = i; \\n                }\\n\\n            }\\n        }\\n\\n        for(int i = 0; i <lp; i++)\\n        {\\n            tp += travel[i]; \\n        }   \\n        for(int i = 0; i <lg; i++)\\n        {\\n            tg += travel[i]; \\n        }   \\n        for(int i = 0; i <lm; i++)\\n        {\\n            tm += travel[i]; \\n        }   \\n        \\n        int ans = (pp + tp) +(pg + tg ) + (pm + tm);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int pp = 0; \\n        int pm = 0; \\n        int pg = 0; \\n\\n        int tp =0;\\n        int tm =0;\\n        int tg =0;\\n\\n        int lp= 0;\\n        int lg= 0;\\n        int lm= 0;\\n\\n        for(int i = 0; i<garbage.size(); i++){\\n            string curr = garbage[i];\\n            for(int j =0; j<curr.length(); j++){\\n                char ch = curr[j]; \\n                if(ch == \\'P\\'){\\n                    pp++;\\n                    lp  = i; \\n                }\\n                else if(ch == \\'G\\'){\\n                    pg++;\\n                    lg = i; \\n                }\\n                else if(ch == \\'M\\'){\\n                    pm++;\\n                    lm = i; \\n                }\\n\\n            }\\n        }\\n\\n        for(int i = 0; i <lp; i++)\\n        {\\n            tp += travel[i]; \\n        }   \\n        for(int i = 0; i <lg; i++)\\n        {\\n            tg += travel[i]; \\n        }   \\n        for(int i = 0; i <lm; i++)\\n        {\\n            tm += travel[i]; \\n        }   \\n        \\n        int ans = (pp + tp) +(pg + tg ) + (pm + tm);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097086,
                "title": "solution-to-minimum-amount-of-time-to-collect-garbage-c",
                "content": "\\n# Approach\\nThe code starts by initializing several variables to keep track of the counts of different types of garbage (P, G, M), as well as the travel distances for each type. It then iterates through the garbage vector, which presumably contains a series of strings representing garbage collected at different positions. For each character in these strings, it checks if it\\'s \\'P\\', \\'G\\', or \\'M\\' and increments the respective count variables. Additionally, it keeps track of the last position (index) where each type of garbage was encountered.\\n\\nAfter processing all the garbage strings, it calculates the travel distances for \\'P\\', \\'G\\', and \\'M\\' by summing the travel values from the travel vector for positions up to the last occurrence of each type of garbage. Finally, it computes the answer as the sum of pick counts and travel distances for each type of garbage and returns the result.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        int pickP = 0;\\n        int pickM = 0;\\n        int pickG = 0;\\n\\n        int travelP = 0;\\n        int travelM = 0;\\n        int travelG = 0;\\n        \\n        int lastP = 0;\\n        int lastM = 0;\\n        int lastG = 0;\\n\\n        for (int i=0;i<garbage.size();i++){\\n            string curr = garbage[i];\\n\\n            for (int j=0;j<curr.length();j++){\\n                char ch = curr[j];\\n\\n\\n                if (ch ==\\'P\\'){\\n                    pickP++;\\n                    lastP = i;\\n                }\\n                if (ch ==\\'G\\'){\\n                    pickG++;\\n                    lastG = i;\\n                }\\n                if (ch ==\\'M\\'){\\n                    pickM++;\\n                    lastM = i;\\n                }\\n\\n            }\\n        }\\n        for (int i =0;i<lastP;i++){\\n            travelP+=travel[i];\\n        }\\n        for (int i =0;i<lastG;i++){\\n            travelG+=travel[i];\\n        }\\n        for (int i =0;i<lastM;i++){\\n            travelM+=travel[i];\\n        }\\n        int ans = (pickP + travelP) + (pickG + travelG) + (pickM + travelM);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        int pickP = 0;\\n        int pickM = 0;\\n        int pickG = 0;\\n\\n        int travelP = 0;\\n        int travelM = 0;\\n        int travelG = 0;\\n        \\n        int lastP = 0;\\n        int lastM = 0;\\n        int lastG = 0;\\n\\n        for (int i=0;i<garbage.size();i++){\\n            string curr = garbage[i];\\n\\n            for (int j=0;j<curr.length();j++){\\n                char ch = curr[j];\\n\\n\\n                if (ch ==\\'P\\'){\\n                    pickP++;\\n                    lastP = i;\\n                }\\n                if (ch ==\\'G\\'){\\n                    pickG++;\\n                    lastG = i;\\n                }\\n                if (ch ==\\'M\\'){\\n                    pickM++;\\n                    lastM = i;\\n                }\\n\\n            }\\n        }\\n        for (int i =0;i<lastP;i++){\\n            travelP+=travel[i];\\n        }\\n        for (int i =0;i<lastG;i++){\\n            travelG+=travel[i];\\n        }\\n        for (int i =0;i<lastM;i++){\\n            travelM+=travel[i];\\n        }\\n        int ans = (pickP + travelP) + (pickG + travelG) + (pickM + travelM);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091681,
                "title": "very-simple-straight-forward-100-c-easy-simple-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is described the comments but we just have to do three things\\n1. find the number of garbage\\n2. the last occurence of each type of garbage\\n3. add them and return them\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstraight forward we just find the above three things\\ndo the prefix sum of the travel as it gives the combined time till the commute \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(garbage) or O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// what we did here was to add the minute for all the present garbage as it is added to the time, then we found the last occurences as to which house contains the last of G P or M so that we could add the commute time till that house in order to add it to the total time.\\n\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int count=0;\\n        int lastG=0,lastM=0,lastP=0;\\n        for(int i=0; i<garbage.size(); i++)\\n        {\\n            for(auto c: garbage[i])\\n            {\\n                count=count+1;\\n                if(c ==\\'G\\')\\n                {\\n                    lastG=i;\\n                }\\n                if(c ==\\'M\\')\\n                {\\n                    lastM=i;\\n                }\\n                if(c ==\\'P\\')\\n                {\\n                    lastP=i;\\n                }\\n            }\\n        }\\n        for(int j=1; j<travel.size(); j++)\\n        {\\n            travel[j]+=travel[j-1];\\n        }\\n        int ans=count;\\n        if(lastG>0)\\n        {\\n            ans+=travel[lastG-1];\\n        }\\n        if(lastM>0)\\n        {\\n            ans+=travel[lastM-1];\\n        }\\n        if(lastP>0)\\n        {\\n            ans+=travel[lastP-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// what we did here was to add the minute for all the present garbage as it is added to the time, then we found the last occurences as to which house contains the last of G P or M so that we could add the commute time till that house in order to add it to the total time.\\n\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int count=0;\\n        int lastG=0,lastM=0,lastP=0;\\n        for(int i=0; i<garbage.size(); i++)\\n        {\\n            for(auto c: garbage[i])\\n            {\\n                count=count+1;\\n                if(c ==\\'G\\')\\n                {\\n                    lastG=i;\\n                }\\n                if(c ==\\'M\\')\\n                {\\n                    lastM=i;\\n                }\\n                if(c ==\\'P\\')\\n                {\\n                    lastP=i;\\n                }\\n            }\\n        }\\n        for(int j=1; j<travel.size(); j++)\\n        {\\n            travel[j]+=travel[j-1];\\n        }\\n        int ans=count;\\n        if(lastG>0)\\n        {\\n            ans+=travel[lastG-1];\\n        }\\n        if(lastM>0)\\n        {\\n            ans+=travel[lastM-1];\\n        }\\n        if(lastP>0)\\n        {\\n            ans+=travel[lastP-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091679,
                "title": "very-simple-straight-forward-100-c-easy-simple-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is described the comments but we just have to do three things\\n1. find the number of garbage\\n2. the last occurence of each type of garbage\\n3. add them and return them\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstraight forward we just find the above three things\\ndo the prefix sum of the travel as it gives the combined time till the commute \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(garbage) or O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// what we did here was to add the minute for all the present garbage as it is added to the time, then we found the last occurences as to which house contains the last of G P or M so that we could add the commute time till that house in order to add it to the total time.\\n\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int count=0;\\n        int lastG=0,lastM=0,lastP=0;\\n        for(int i=0; i<garbage.size(); i++)\\n        {\\n            for(auto c: garbage[i])\\n            {\\n                count=count+1;\\n                if(c ==\\'G\\')\\n                {\\n                    lastG=i;\\n                }\\n                if(c ==\\'M\\')\\n                {\\n                    lastM=i;\\n                }\\n                if(c ==\\'P\\')\\n                {\\n                    lastP=i;\\n                }\\n            }\\n        }\\n        for(int j=1; j<travel.size(); j++)\\n        {\\n            travel[j]+=travel[j-1];\\n        }\\n        int ans=count;\\n        if(lastG>0)\\n        {\\n            ans+=travel[lastG-1];\\n        }\\n        if(lastM>0)\\n        {\\n            ans+=travel[lastM-1];\\n        }\\n        if(lastP>0)\\n        {\\n            ans+=travel[lastP-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// what we did here was to add the minute for all the present garbage as it is added to the time, then we found the last occurences as to which house contains the last of G P or M so that we could add the commute time till that house in order to add it to the total time.\\n\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int count=0;\\n        int lastG=0,lastM=0,lastP=0;\\n        for(int i=0; i<garbage.size(); i++)\\n        {\\n            for(auto c: garbage[i])\\n            {\\n                count=count+1;\\n                if(c ==\\'G\\')\\n                {\\n                    lastG=i;\\n                }\\n                if(c ==\\'M\\')\\n                {\\n                    lastM=i;\\n                }\\n                if(c ==\\'P\\')\\n                {\\n                    lastP=i;\\n                }\\n            }\\n        }\\n        for(int j=1; j<travel.size(); j++)\\n        {\\n            travel[j]+=travel[j-1];\\n        }\\n        int ans=count;\\n        if(lastG>0)\\n        {\\n            ans+=travel[lastG-1];\\n        }\\n        if(lastM>0)\\n        {\\n            ans+=travel[lastM-1];\\n        }\\n        if(lastP>0)\\n        {\\n            ans+=travel[lastP-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091392,
                "title": "python-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        g = [list(lst) for lst in garbage]\\n        res = 0\\n        for trash in [\"M\", \"P\", \"G\"]:\\n            useless_time = 0\\n            for ind, station in enumerate(garbage[1:]):\\n                useless_time += travel[ind]\\n                if trash in station:\\n                    res += useless_time\\n                    useless_time = 0\\n            print(res, useless_time)\\n        res += sum([len(lst) for lst in garbage])\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\\n        g = [list(lst) for lst in garbage]\\n        res = 0\\n        for trash in [\"M\", \"P\", \"G\"]:\\n            useless_time = 0\\n            for ind, station in enumerate(garbage[1:]):\\n                useless_time += travel[ind]\\n                if trash in station:\\n                    res += useless_time\\n                    useless_time = 0\\n            print(res, useless_time)\\n        res += sum([len(lst) for lst in garbage])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089805,
                "title": "javascript-time-complexity-beats-100",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string[]} garbage\\n * @param {number[]} travel\\n * @return {number}\\n */\\nvar garbageCollection = function(garbage, travel) {\\n    let travelSum = [0]\\n    let sum = 0\\n    travel.forEach(a => {\\n        sum += a\\n        travelSum.push(sum)\\n    })\\n    //Create an array in which value of index i represents the minutes taken to reach that ith house.\\n    travelSum.reverse()\\n    let minutes = garbage.join(\"\").length //The total minutes taken to collect all the garbage.\\n    garbage.reverse()\\n    for(const type of [\"G\",\"P\",\"M\"]){\\n        //couldn\\'t use findLastIndex so had to reverse both the arrays :(\\n        let a = garbage.findIndex(h => h.includes(type)) //Find the last index(house) with the type of garbage\\n        if(a != -1){\\n            minutes += travelSum[a] //Add the minutes taken to reach that index(house)\\n        }\\n    }\\n    return minutes\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} garbage\\n * @param {number[]} travel\\n * @return {number}\\n */\\nvar garbageCollection = function(garbage, travel) {\\n    let travelSum = [0]\\n    let sum = 0\\n    travel.forEach(a => {\\n        sum += a\\n        travelSum.push(sum)\\n    })\\n    //Create an array in which value of index i represents the minutes taken to reach that ith house.\\n    travelSum.reverse()\\n    let minutes = garbage.join(\"\").length //The total minutes taken to collect all the garbage.\\n    garbage.reverse()\\n    for(const type of [\"G\",\"P\",\"M\"]){\\n        //couldn\\'t use findLastIndex so had to reverse both the arrays :(\\n        let a = garbage.findIndex(h => h.includes(type)) //Find the last index(house) with the type of garbage\\n        if(a != -1){\\n            minutes += travelSum[a] //Add the minutes taken to reach that index(house)\\n        }\\n    }\\n    return minutes\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087367,
                "title": "memory-beats-100-of-users-with-python",
                "content": "It just worked, am only submitting it because it beats 100% of users with python\\n\\n# Code\\n```\\nclass Solution(object):\\n    def garbageCollection(self, garbage, travel):\\n        \"\"\"\\n        :type garbage: List[str]\\n        :type travel: List[int]\\n        :rtype: int\\n        \"\"\"\\n        paper_time = self.time_to_collect_garbage(\"P\", garbage, travel)\\n        glass_time = self.time_to_collect_garbage(\"G\", garbage, travel)\\n        metal_time = self.time_to_collect_garbage(\"M\", garbage, travel)\\n        return paper_time + glass_time + metal_time\\n    \\n    def time_to_collect_garbage(self, garbage_type, garbage, travel):\\n        \"\"\"\\n        Returns the total amount of time needed to collect certain type of garbage\\n        :garbage_type: the type of garbage, \"M\", \"P\", \"G\"\\n        :houses: an array of houses with the garbages\\n        :travel: times it take to move from one house to another\\n        \"\"\"\\n        current_garbage = 0\\n        current_travel_time = 0\\n        time = 0\\n        temp_time = 0\\n        while current_garbage < len(garbage):\\n            if self.count_garbage(garbage_type, garbage[current_garbage]) > 0:\\n                time += self.count_garbage(garbage_type, garbage[current_garbage]) * 1 + temp_time\\n                temp_time = 0\\n            # else:\\n            if current_travel_time < len(travel):\\n                temp_time += travel[current_travel_time]\\n            current_travel_time += 1\\n            current_garbage += 1\\n        return time\\n                \\n    def count_garbage(self, garbage_type, garbage):\\n        \"\"\"\\n        Counts the amount of certain garbage in a given garbage\\n        \"\"\"\\n        total = 0\\n        for i in range(0, len(garbage)):\\n            if garbage[i] == garbage_type:\\n                total += 1\\n        return total\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def garbageCollection(self, garbage, travel):\\n        \"\"\"\\n        :type garbage: List[str]\\n        :type travel: List[int]\\n        :rtype: int\\n        \"\"\"\\n        paper_time = self.time_to_collect_garbage(\"P\", garbage, travel)\\n        glass_time = self.time_to_collect_garbage(\"G\", garbage, travel)\\n        metal_time = self.time_to_collect_garbage(\"M\", garbage, travel)\\n        return paper_time + glass_time + metal_time\\n    \\n    def time_to_collect_garbage(self, garbage_type, garbage, travel):\\n        \"\"\"\\n        Returns the total amount of time needed to collect certain type of garbage\\n        :garbage_type: the type of garbage, \"M\", \"P\", \"G\"\\n        :houses: an array of houses with the garbages\\n        :travel: times it take to move from one house to another\\n        \"\"\"\\n        current_garbage = 0\\n        current_travel_time = 0\\n        time = 0\\n        temp_time = 0\\n        while current_garbage < len(garbage):\\n            if self.count_garbage(garbage_type, garbage[current_garbage]) > 0:\\n                time += self.count_garbage(garbage_type, garbage[current_garbage]) * 1 + temp_time\\n                temp_time = 0\\n            # else:\\n            if current_travel_time < len(travel):\\n                temp_time += travel[current_travel_time]\\n            current_travel_time += 1\\n            current_garbage += 1\\n        return time\\n                \\n    def count_garbage(self, garbage_type, garbage):\\n        \"\"\"\\n        Counts the amount of certain garbage in a given garbage\\n        \"\"\"\\n        total = 0\\n        for i in range(0, len(garbage)):\\n            if garbage[i] == garbage_type:\\n                total += 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082335,
                "title": "o-n-js-solution-runtime-beats-98-8-using-for-loop-only",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} garbage\\n * @param {number[]} travel\\n * @return {number}\\n */\\nvar garbageCollection = function(garbage, travel) {\\n    let travelTime = 0;\\n    let len = garbage[0].length;\\n\\n    for(let i=0, j=1; i<travel.length; i++){\\n        travelTime += travel[i];\\n        len += garbage[j++].length;\\n    }\\n    travelTime *= 3;\\n\\n    let flagM = 0, flagP = 0, flagG = 0;\\n    for(let i=garbage.length-1; i>0; i--){\\n        if(!garbage[i].includes(\\'M\\') && !flagM)\\n            travelTime -= travel[i-1];\\n        else\\n            flagM = 1;\\n\\n        if(!garbage[i].includes(\\'P\\') && !flagP)\\n            travelTime -= travel[i-1];\\n        else\\n            flagP = 1;\\n\\n        if(!garbage[i].includes(\\'G\\') && !flagG)\\n            travelTime -= travel[i-1];\\n        else\\n            flagG = 1;\\n    }\\n    return len+travelTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} garbage\\n * @param {number[]} travel\\n * @return {number}\\n */\\nvar garbageCollection = function(garbage, travel) {\\n    let travelTime = 0;\\n    let len = garbage[0].length;\\n\\n    for(let i=0, j=1; i<travel.length; i++){\\n        travelTime += travel[i];\\n        len += garbage[j++].length;\\n    }\\n    travelTime *= 3;\\n\\n    let flagM = 0, flagP = 0, flagG = 0;\\n    for(let i=garbage.length-1; i>0; i--){\\n        if(!garbage[i].includes(\\'M\\') && !flagM)\\n            travelTime -= travel[i-1];\\n        else\\n            flagM = 1;\\n\\n        if(!garbage[i].includes(\\'P\\') && !flagP)\\n            travelTime -= travel[i-1];\\n        else\\n            flagP = 1;\\n\\n        if(!garbage[i].includes(\\'G\\') && !flagG)\\n            travelTime -= travel[i-1];\\n        else\\n            flagG = 1;\\n    }\\n    return len+travelTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081648,
                "title": "easy-to-understand-approach-simple-approach-c",
                "content": "# Intuition\\nCount the number of P, G and M by traversing all the strings and also store the max_index for P, G and M.\\n\\n# Approach\\neasy to understand approach\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\nwhere N is size of garbage array,\\nand M is maximum length of string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int paper_time = 0;\\n        int glass_time = 0;\\n        int metal_time = 0;\\n        int count_p = 0, max_index_p = 0;\\n        int count_g = 0, max_index_g = 0;\\n        int count_m = 0, max_index_m = 0;\\n        int k=0;\\n        for(auto str : garbage){\\n            for(int i=0 ; i<str.size() ; ++i){\\n                if(str[i] == \\'P\\'){\\n                    count_p++;\\n                    max_index_p = max(max_index_p, k);\\n                } else  if(str[i] == \\'G\\'){\\n                    count_g++;\\n                    max_index_g = max(max_index_g, k);\\n                } else {\\n                    count_m++;\\n                    max_index_m = max(max_index_m, k);\\n                }\\n            }\\n            k++;\\n        }\\n        for(int i=1 ; i<travel.size() ; i++){\\n            travel[i] = travel[i] + travel[i-1];\\n        }\\n\\n\\n        //Count the time to travel from house 0 to max_index house\\n        if(max_index_p-1 >= 0)\\n            paper_time = travel[max_index_p-1];\\n        if(max_index_g-1 >= 0)\\n            glass_time = travel[max_index_g-1];\\n        if(max_index_m-1 >= 0)\\n            metal_time = travel[max_index_m-1];\\n\\n        return paper_time + glass_time + metal_time + count_p + count_g + count_m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        int paper_time = 0;\\n        int glass_time = 0;\\n        int metal_time = 0;\\n        int count_p = 0, max_index_p = 0;\\n        int count_g = 0, max_index_g = 0;\\n        int count_m = 0, max_index_m = 0;\\n        int k=0;\\n        for(auto str : garbage){\\n            for(int i=0 ; i<str.size() ; ++i){\\n                if(str[i] == \\'P\\'){\\n                    count_p++;\\n                    max_index_p = max(max_index_p, k);\\n                } else  if(str[i] == \\'G\\'){\\n                    count_g++;\\n                    max_index_g = max(max_index_g, k);\\n                } else {\\n                    count_m++;\\n                    max_index_m = max(max_index_m, k);\\n                }\\n            }\\n            k++;\\n        }\\n        for(int i=1 ; i<travel.size() ; i++){\\n            travel[i] = travel[i] + travel[i-1];\\n        }\\n\\n\\n        //Count the time to travel from house 0 to max_index house\\n        if(max_index_p-1 >= 0)\\n            paper_time = travel[max_index_p-1];\\n        if(max_index_g-1 >= 0)\\n            glass_time = travel[max_index_g-1];\\n        if(max_index_m-1 >= 0)\\n            metal_time = travel[max_index_m-1];\\n\\n        return paper_time + glass_time + metal_time + count_p + count_g + count_m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075980,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} garbage\\n * @param {number[]} travel\\n * @return {number}\\n */\\n\\n\\nconst countAmount = (garbage, travel, garbageType) => {\\n  const isGarbageExists = garbage.join().includes(garbageType);\\n  let garbageAmountMinutes = 0;\\n\\n  if (isGarbageExists) {\\n      for (let f = 0; f < garbage.length; f++) {\\n          const houseGarbages = garbage[f];\\n\\n          for (let index = 0; index < houseGarbages.length; index++) {\\n              const garbageTypeInner = houseGarbages[index];\\n\\n              if (garbageType === garbageTypeInner) {\\n                garbageAmountMinutes = garbageAmountMinutes + 1;\\n                  }\\n              }\\n          }\\n\\n    for (let k = 0; k < garbage.length; k++) {\\n\\n      for (let index = k + 1; index < garbage.length; index++) {\\n        const element = garbage[index];\\n\\n\\n        if (element.includes(garbageType)) {\\n          const timeTravelToHouse = travel[k];\\n\\n          garbageAmountMinutes = garbageAmountMinutes + timeTravelToHouse;\\n          break;\\n        }\\n      }\\n    }\\n  } \\n\\n\\n\\n  return garbageAmountMinutes;\\n}\\n\\n\\nvar garbageCollection = function(garbage, travel) {\\n\\n  const timeAmountP = countAmount(garbage, travel, \"P\");\\n  const timeAmountM = countAmount(garbage, travel, \"M\");\\n  const timeAmountG = countAmount(garbage, travel, \"G\");\\n\\n\\n  return timeAmountG + timeAmountM + timeAmountP;\\n};\\n    \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} garbage\\n * @param {number[]} travel\\n * @return {number}\\n */\\n\\n\\nconst countAmount = (garbage, travel, garbageType) => {\\n  const isGarbageExists = garbage.join().includes(garbageType);\\n  let garbageAmountMinutes = 0;\\n\\n  if (isGarbageExists) {\\n      for (let f = 0; f < garbage.length; f++) {\\n          const houseGarbages = garbage[f];\\n\\n          for (let index = 0; index < houseGarbages.length; index++) {\\n              const garbageTypeInner = houseGarbages[index];\\n\\n              if (garbageType === garbageTypeInner) {\\n                garbageAmountMinutes = garbageAmountMinutes + 1;\\n                  }\\n              }\\n          }\\n\\n    for (let k = 0; k < garbage.length; k++) {\\n\\n      for (let index = k + 1; index < garbage.length; index++) {\\n        const element = garbage[index];\\n\\n\\n        if (element.includes(garbageType)) {\\n          const timeTravelToHouse = travel[k];\\n\\n          garbageAmountMinutes = garbageAmountMinutes + timeTravelToHouse;\\n          break;\\n        }\\n      }\\n    }\\n  } \\n\\n\\n\\n  return garbageAmountMinutes;\\n}\\n\\n\\nvar garbageCollection = function(garbage, travel) {\\n\\n  const timeAmountP = countAmount(garbage, travel, \"P\");\\n  const timeAmountM = countAmount(garbage, travel, \"M\");\\n  const timeAmountG = countAmount(garbage, travel, \"G\");\\n\\n\\n  return timeAmountG + timeAmountM + timeAmountP;\\n};\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075978,
                "title": "similar-but-different-approach-c-easy-to-understand",
                "content": "I have crafted this solution with simplicity in mind to aid understanding, as I am a beginner. Feel free to optimize it as needed. Happy coding! ;) and don\\'t forget that semicolon;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        \\n        int Ptime =0;\\n        int Gtime =0;\\n        int Mtime =0;\\n        int LPtime = 0;\\n        int LGtime = 0;\\n        int LMtime = 0;\\n\\n        travel.push_back(0);\\n        for(int i =0;i<garbage.size();i++){\\n                bool Mgarbage = 0;\\n                bool Ggarbage = 0;\\n                bool Pgarbage = 0;\\n\\n                    for(auto j:garbage[i]){\\n                        if(j == \\'G\\'){\\n                            Gtime++;LGtime++;\\n                            Ggarbage =1;\\n                        }else if(j == \\'P\\'){\\n                            Ptime++;\\n                            Pgarbage = 1;\\n                            LPtime++;\\n                        }else{\\n                            Mtime++;LMtime++;\\n                            Mgarbage =1;\\n                        }\\n                    }\\n\\n            if(Pgarbage) LPtime = Ptime;\\n            if(Mgarbage) LMtime = Mtime;\\n            if(Ggarbage) LGtime = Gtime;\\n                \\n            Mtime+= travel[i];\\n            Gtime+=travel[i];\\n            Ptime+= travel[i];\\n        }\\n        return LMtime+LPtime+LGtime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\\n        \\n        \\n        int Ptime =0;\\n        int Gtime =0;\\n        int Mtime =0;\\n        int LPtime = 0;\\n        int LGtime = 0;\\n        int LMtime = 0;\\n\\n        travel.push_back(0);\\n        for(int i =0;i<garbage.size();i++){\\n                bool Mgarbage = 0;\\n                bool Ggarbage = 0;\\n                bool Pgarbage = 0;\\n\\n                    for(auto j:garbage[i]){\\n                        if(j == \\'G\\'){\\n                            Gtime++;LGtime++;\\n                            Ggarbage =1;\\n                        }else if(j == \\'P\\'){\\n                            Ptime++;\\n                            Pgarbage = 1;\\n                            LPtime++;\\n                        }else{\\n                            Mtime++;LMtime++;\\n                            Mgarbage =1;\\n                        }\\n                    }\\n\\n            if(Pgarbage) LPtime = Ptime;\\n            if(Mgarbage) LMtime = Mtime;\\n            if(Ggarbage) LGtime = Gtime;\\n                \\n            Mtime+= travel[i];\\n            Gtime+=travel[i];\\n            Ptime+= travel[i];\\n        }\\n        return LMtime+LPtime+LGtime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1799541,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1830464,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1965875,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1931088,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1997212,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1861120,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1966927,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1958333,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            },
            {
                "id": 1898972,
                "content": [
                    {
                        "username": "District_12",
                        "content": "I really like this problem! Good job!"
                    },
                    {
                        "username": "tejesh1220",
                        "content": "then explain the question"
                    },
                    {
                        "username": "godfriend",
                        "content": "I don\\'t Understand the Question"
                    },
                    {
                        "username": "izzypz",
                        "content": "Yeah you\\u2019re not the only one brother"
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "So, it is clearly said that we *must visit each house **in order***, but we *do **not** need to visit every house.* Understandable, each truck starts at house 0 and move to house 1 and so on, but there is no need to visit every house\nSO, please explain me example 1:\nI understand movements of paper garbage truck. In the end it doesn't move to the last house (no paper there)\nBut WHY glass garbage truck moves from house 0 to house 1? Why? No glass here, why should we spend minutes on going there? If we skip this house (and this strategy seems logically in order not to spend extra time), then we can pick all the garbage in 19 minutes.\nI'll be glad if you explain this, thanks in advance "
                    },
                    {
                        "username": "semyonf1l1pp0v",
                        "content": "[@Krishrx](/Krishrx) Yeah, it seems to be like that. Thank you"
                    },
                    {
                        "username": "Krishrx",
                        "content": "[@semyonf1l1pp0v](/semyonf1l1pp0v) I think in order to reach house 2 the only way is from house 1 right... as mentioned in question (we must visit each house in order).we can't just jump from house 0 to house 2.eventhough it takes extra minutes."
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "I am confused about the examples\\' outputs, and how they arrived at those numbers "
                    },
                    {
                        "username": "sdsohaibali",
                        "content": "[@jkrippy](/jkrippy) Thanks! "
                    },
                    {
                        "username": "jkrippy",
                        "content": "I was confused too until I realized the truck can collect multiple bins at a house.  Sharing in case this helps someone else too."
                    },
                    {
                        "username": "xunil_revol",
                        "content": "very misleading problem statement, there can be no minimum time or even any different times possible to finish the job ."
                    },
                    {
                        "username": "IdanZ",
                        "content": "Yeah I\\'ve been trying to understand what they\\'ve meant by that lol"
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "Should have been marked easy"
                    },
                    {
                        "username": "guptasam318",
                        "content": "Really? tell me how to solve it :("
                    },
                    {
                        "username": "Krishrx",
                        "content": "Find the last position(index) of each garbage type(G,P,M) in garbage array."
                    },
                    {
                        "username": "maazzz",
                        "content": "mixture of prefix sum and little logical thinking."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "It shouldn\\'t be under medium category."
                    }
                ]
            }
        ]
    }
]