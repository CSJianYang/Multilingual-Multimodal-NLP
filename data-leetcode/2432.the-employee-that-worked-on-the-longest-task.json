[
    {
        "title": "The Employee That Worked on the Longest Task",
        "question_content": "There are n employees, each with a unique id from 0 to n - 1.\nYou are given a 2D integer array logs where logs[i] = [idi, leaveTimei] where:\n\n\tidi is the id of the employee that worked on the ith task, and\n\tleaveTimei is the time at which the employee finished the ith task. All the values leaveTimei are unique.\n\nNote that the ith task starts the moment right after the (i - 1)th task ends, and the 0th task starts at time 0.\nReturn the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them.\n&nbsp;\nExample 1:\n\nInput: n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]\nOutput: 1\nExplanation: \nTask 0 started at 0 and ended at 3 with 3 units of times.\nTask 1 started at 3 and ended at 5 with 2 units of times.\nTask 2 started at 5 and ended at 9 with 4 units of times.\nTask 3 started at 9 and ended at 15 with 6 units of times.\nThe task with the longest time is task 3 and the employee with id 1 is the one that worked on it, so we return 1.\n\nExample 2:\n\nInput: n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]\nOutput: 3\nExplanation: \nTask 0 started at 0 and ended at 1 with 1 unit of times.\nTask 1 started at 1 and ended at 7 with 6 units of times.\nTask 2 started at 7 and ended at 12 with 5 units of times.\nTask 3 started at 12 and ended at 17 with 5 units of times.\nThe tasks with the longest time is task 1. The employee that worked on it is 3, so we return 3.\n\nExample 3:\n\nInput: n = 2, logs = [[0,10],[1,20]]\nOutput: 0\nExplanation: \nTask 0 started at 0 and ended at 10 with 10 units of times.\nTask 1 started at 10 and ended at 20 with 10 units of times.\nThe tasks with the longest time are tasks 0 and 1. The employees that worked on them are 0 and 1, so we return the smallest id 0.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 500\n\t1 <= logs.length <= 500\n\tlogs[i].length == 2\n\t0 <= idi <= n - 1\n\t1 <= leaveTimei <= 500\n\tidi != idi+1\n\tleaveTimei are sorted in a strictly increasing order.",
        "solutions": [
            {
                "id": 2679352,
                "title": "python3-simple-o-n-beginner-friendly",
                "content": "All we need to do is to find the smallest id (logs[i][0]) which has the maximum logs[i][1]-logs[i-1][1] \\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        res = logs[0][0]\\n        Max = logs[0][1]\\n        for i in range(1,len(logs)):\\n            if logs[i][1]-logs[i-1][1]>Max:\\n                res = logs[i][0]\\n                Max = logs[i][1]-logs[i-1][1]\\n            elif logs[i][1]-logs[i-1][1]==Max and res>logs[i][0]:\\n                res = logs[i][0]\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        res = logs[0][0]\\n        Max = logs[0][1]\\n        for i in range(1,len(logs)):\\n            if logs[i][1]-logs[i-1][1]>Max:\\n                res = logs[i][0]\\n                Max = logs[i][1]-logs[i-1][1]\\n            elif logs[i][1]-logs[i-1][1]==Max and res>logs[i][0]:\\n                res = logs[i][0]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678850,
                "title": "lexicographical-smallest-one-pass",
                "content": "On the Way , we just need to update **lexicographical small id** with greatest duration.\\n\\n> If the array was unsorted in terms of leaving time, then we would have sorted it , so as to get the time in increasing order.\\n\\n# C++\\n    int hardestWorker(int n, vector<vector<int>>& A) {\\n        int len = a[0][1], id = a[0][0];\\n        for (int i = 1; i < size(A); i++){\\n            int curr = A[i][1] - A[i - 1][1];\\n            if (curr > len || curr == len and id > A[i][0])  len = curr, id = A[i][0]; \\n        }\\n        return id;\\n    }\\n# Java\\n    public int hardestWorker(int n, int[][] a) {\\n        int len = a[0][1], id = a[0][0];\\n        for (int i = 1; i < a.length; i++){\\n            int curr = a[i][1] - a[i - 1][1];\\n            if (curr > len || curr == len && id > a[i][0]){\\n                len = curr;\\n                id = a[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n# Python\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        # smallest id with longest time\\n        time , i_d = logs[0][1] , logs[0][0]  \\n        for i in range(1,len(logs)):\\n            gap= logs[i][1] - logs[i-1][1]\\n            if gap > time or gap == time and i_d > logs[i][0]:\\n                time , i_d = gap , logs[i][0]\\n        return i_d\\nTime - O(`n`)\\nSpace - O(`1`)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "On the Way , we just need to update **lexicographical small id** with greatest duration.\\n\\n> If the array was unsorted in terms of leaving time, then we would have sorted it , so as to get the time in increasing order.\\n\\n# C++\\n    int hardestWorker(int n, vector<vector<int>>& A) {\\n        int len = a[0][1], id = a[0][0];\\n        for (int i = 1; i < size(A); i++){\\n            int curr = A[i][1] - A[i - 1][1];\\n            if (curr > len || curr == len and id > A[i][0])  len = curr, id = A[i][0]; \\n        }\\n        return id;\\n    }\\n# Java\\n    public int hardestWorker(int n, int[][] a) {\\n        int len = a[0][1], id = a[0][0];\\n        for (int i = 1; i < a.length; i++){\\n            int curr = a[i][1] - a[i - 1][1];\\n            if (curr > len || curr == len && id > a[i][0]){\\n                len = curr;\\n                id = a[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n# Python\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        # smallest id with longest time\\n        time , i_d = logs[0][1] , logs[0][0]  \\n        for i in range(1,len(logs)):\\n            gap= logs[i][1] - logs[i-1][1]\\n            if gap > time or gap == time and i_d > logs[i][0]:\\n                time , i_d = gap , logs[i][0]\\n        return i_d\\nTime - O(`n`)\\nSpace - O(`1`)",
                "codeTag": "Python3"
            },
            {
                "id": 2682319,
                "title": "python-3-5-lines-one-pass-t-m-312ms-13-8mb",
                "content": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n         \\n        prev, ans = 0, (0,0)\\n\\t\\t\\n        for id, curr in logs:\\n            ans = min(ans,(prev-curr,id))\\n            prev = curr\\n\\n        return ans[1]\\n```\\n[https://leetcode.com/submissions/detail/818733728/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n         \\n        prev, ans = 0, (0,0)\\n\\t\\t\\n        for id, curr in logs:\\n            ans = min(ans,(prev-curr,id))\\n            prev = curr\\n\\n        return ans[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678858,
                "title": "loop-vs-max-element",
                "content": "#### Loop\\n**C++**\\n```cpp\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n    int end = 0, id = 0, max_t = 0;\\n    for (auto &l : logs) {\\n        if (max_t <= l[1] - end) {\\n            id = max_t < l[1] - end ? l[0] : min(id, l[0]);\\n            max_t = l[1] - end;\\n        }\\n        end = l[1];\\n    }\\n    return id;\\n}\\n```\\n#### Max Element\\n**C++**\\n```cpp\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n    int max_t = 0;\\n    for (auto &l : logs) {\\n        l[1] = l[1] - max_t;\\n        max_t += l[1];\\n    }\\n    return (*max_element(begin(logs), end(logs), [](const auto &l1, const auto &l2) {\\n        return l1[1] == l2[1] ? l1[0] > l2[0] : l1[1] < l2[1];\\n    }))[0];\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n    int end = 0, id = 0, max_t = 0;\\n    for (auto &l : logs) {\\n        if (max_t <= l[1] - end) {\\n            id = max_t < l[1] - end ? l[0] : min(id, l[0]);\\n            max_t = l[1] - end;\\n        }\\n        end = l[1];\\n    }\\n    return id;\\n}\\n```\n```cpp\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n    int max_t = 0;\\n    for (auto &l : logs) {\\n        l[1] = l[1] - max_t;\\n        max_t += l[1];\\n    }\\n    return (*max_element(begin(logs), end(logs), [](const auto &l1, const auto &l2) {\\n        return l1[1] == l2[1] ? l1[0] > l2[0] : l1[1] < l2[1];\\n    }))[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693491,
                "title": "python-elegant-short-no-indexes-99-32-faster",
                "content": "![image](https://assets.leetcode.com/users/images/53cd3bda-8ee8-4cbe-8d7c-6b4eb5ea02da_1665559451.2513933.png)\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        best_id = best_time = start = 0\\n\\n        for emp_id, end in logs:\\n            time = end - start\\n            if time > best_time or (time == best_time and best_id > emp_id):\\n                best_id = emp_id\\n                best_time = time\\n            start = end\\n\\n        return best_id\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        best_id = best_time = start = 0\\n\\n        for emp_id, end in logs:\\n            time = end - start\\n            if time > best_time or (time == best_time and best_id > emp_id):\\n                best_id = emp_id\\n                best_time = time\\n            start = end\\n\\n        return best_id\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678871,
                "title": "c-simple-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n       int d=logs[0][1];\\n        \\n        int ind=logs[0][0];\\n        \\n        for(int i=1;i<=logs.size()-1;i++)\\n        {\\n            int res =logs[i][1]-logs[i-1][1];\\n            \\n            if(res==d)\\n            {\\n                \\n                ind=min(ind,logs[i][0]);\\n                \\n            }\\n            \\n            if(res >d)\\n            {\\n                d=res;\\n                \\n                ind=logs[i][0];\\n                \\n            }\\n        }\\n        \\n        return ind;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n       int d=logs[0][1];\\n        \\n        int ind=logs[0][0];\\n        \\n        for(int i=1;i<=logs.size()-1;i++)\\n        {\\n            int res =logs[i][1]-logs[i-1][1];\\n            \\n            if(res==d)\\n            {\\n                \\n                ind=min(ind,logs[i][0]);\\n                \\n            }\\n            \\n            if(res >d)\\n            {\\n                d=res;\\n                \\n                ind=logs[i][0];\\n                \\n            }\\n        }\\n        \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681230,
                "title": "linear-scan",
                "content": "# Intuition\\nAs the logs are already sorted accorign to the Leaving Time.\\nWith a linear scan we can just comput the log with largest time and find the corrosponding min employee id.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe  maintain a `last` variable which is initially `0` which stores the leaving time of last log.\\n`period = log[1] - last`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int last = 0, emp = 0, larg = 0, period;\\n        for(vector<int>& log: logs) {\\n            period = log[1] - last;\\n            if(larg == period)\\n                emp = min(emp, log[0]);\\n            else if(larg < period) {\\n                larg = period;\\n                emp = log[0];\\n            }\\n            last = log[1];\\n        }\\n        return emp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int last = 0, emp = 0, larg = 0, period;\\n        for(vector<int>& log: logs) {\\n            period = log[1] - last;\\n            if(larg == period)\\n                emp = min(emp, log[0]);\\n            else if(larg < period) {\\n                larg = period;\\n                emp = log[0];\\n            }\\n            last = log[1];\\n        }\\n        return emp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679018,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n   public int hardestWorker(int n, int[][] logs) {\\n\\n      if (logs.length == 0) return 0;\\n\\n      int res = logs[0][0];                                              // Will track of Employee Id\\n\\n      int maxTime = logs[0][1] - 0;                                     // MaxTime seen so far\\n\\n      for (int i = 1; i < logs.length; i++) {\\n\\n         int time = logs[i][1] - logs[i - 1][1];                       // Current Task time   \\n\\n         if (maxTime == time) {\\n            res = res < logs[i][0] ? res : logs[i][0];\\n         } else if (maxTime < time) {\\n            maxTime = logs[i][1] - logs[i - 1][1];\\n            res = logs[i][0];\\n         }\\n      }\\n\\n      return res;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int hardestWorker(int n, int[][] logs) {\\n\\n      if (logs.length == 0) return 0;\\n\\n      int res = logs[0][0];                                              // Will track of Employee Id\\n\\n      int maxTime = logs[0][1] - 0;                                     // MaxTime seen so far\\n\\n      for (int i = 1; i < logs.length; i++) {\\n\\n         int time = logs[i][1] - logs[i - 1][1];                       // Current Task time   \\n\\n         if (maxTime == time) {\\n            res = res < logs[i][0] ? res : logs[i][0];\\n         } else if (maxTime < time) {\\n            maxTime = logs[i][1] - logs[i - 1][1];\\n            res = logs[i][0];\\n         }\\n      }\\n\\n      return res;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687110,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max_val = logs[0][1], id = logs[0][0];\\n        for(int i=1; i<logs.length; i++){\\n            int time_req = logs[i][1] - logs[i-1][1];\\n            if(time_req >= max_val){\\n                if(time_req == max_val){\\n                    id = Math.min(id, logs[i][0]);\\n                }else{\\n                    max_val = time_req;\\n                    id = logs[i][0];\\n                }\\n            }\\n        }\\n        return id;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar hardestWorker = function(n, logs) {\\n    let max_val = logs[0][1], id = logs[0][0];\\n    for(let i=1; i<logs.length; i++){\\n        let time_req = logs[i][1] - logs[i-1][1];\\n        if(time_req >= max_val){\\n            if(time_req == max_val){\\n                id = Math.min(id, logs[i][0]);\\n            }else{\\n                max_val = time_req;\\n                id = logs[i][0];\\n            }\\n        }\\n    }\\n    return id;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def hardestWorker(self, n, logs):\\n        max_val, eid = logs[0][1], logs[0][0]\\n        for i in range(1, len(logs)):\\n            time_req = logs[i][1] - logs[i-1][1]\\n            if time_req >= max_val:\\n                if time_req == max_val:\\n                    eid = min(eid, logs[i][0])\\n                else:\\n                    max_val = time_req\\n                    eid = logs[i][0]\\n        return eid\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max_val = logs[0][1], id = logs[0][0];\\n        for(int i=1; i<logs.length; i++){\\n            int time_req = logs[i][1] - logs[i-1][1];\\n            if(time_req >= max_val){\\n                if(time_req == max_val){\\n                    id = Math.min(id, logs[i][0]);\\n                }else{\\n                    max_val = time_req;\\n                    id = logs[i][0];\\n                }\\n            }\\n        }\\n        return id;\\n    }\\n}\\n```\n```\\nvar hardestWorker = function(n, logs) {\\n    let max_val = logs[0][1], id = logs[0][0];\\n    for(let i=1; i<logs.length; i++){\\n        let time_req = logs[i][1] - logs[i-1][1];\\n        if(time_req >= max_val){\\n            if(time_req == max_val){\\n                id = Math.min(id, logs[i][0]);\\n            }else{\\n                max_val = time_req;\\n                id = logs[i][0];\\n            }\\n        }\\n    }\\n    return id;\\n};\\n```\n```\\nclass Solution(object):\\n    def hardestWorker(self, n, logs):\\n        max_val, eid = logs[0][1], logs[0][0]\\n        for i in range(1, len(logs)):\\n            time_req = logs[i][1] - logs[i-1][1]\\n            if time_req >= max_val:\\n                if time_req == max_val:\\n                    eid = min(eid, logs[i][0])\\n                else:\\n                    max_val = time_req\\n                    eid = logs[i][0]\\n        return eid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678912,
                "title": "easy-to-understand-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n       int ans = logs[0][0];    // initializing answer with id of first employee \\n       int max_time = logs[0][1];  // time first employee worked\\n        \\n        for(int i=1;i<logs.size();i++)\\n        {\\n            int cur = logs[i][1]-logs[i-1][1];  // time that current employee spent on work\\n            \\n            if(cur>max_time)   // if time of current employee is greater than max time so far update the answer and max time\\n            {\\n                max_time = cur;\\n                ans = logs[i][0];\\n            }\\n            else if(cur==max_time) // if time of current employee is same as max time so far choose employee with smaller id as answer\\n            {\\n                ans = min(ans,logs[i][0]);\\n            }\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n       int ans = logs[0][0];    // initializing answer with id of first employee \\n       int max_time = logs[0][1];  // time first employee worked\\n        \\n        for(int i=1;i<logs.size();i++)\\n        {\\n            int cur = logs[i][1]-logs[i-1][1];  // time that current employee spent on work\\n            \\n            if(cur>max_time)   // if time of current employee is greater than max time so far update the answer and max time\\n            {\\n                max_time = cur;\\n                ans = logs[i][0];\\n            }\\n            else if(cur==max_time) // if time of current employee is same as max time so far choose employee with smaller id as answer\\n            {\\n                ans = min(ans,logs[i][0]);\\n            }\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682157,
                "title": "c-single-pass-straight-forward-clean-code",
                "content": "### Approach 1: single pass, straight forward\\n\\nThis could code be a little bit more compact, but I like unpacking the input and giving it things meaningful names.\\n\\n```cpp\\n    static int hardestWorker(int n, const vector<vector<int>>& logs) {\\n        int start_time = 0;\\n        int worker = n;\\n        int longest_task = 0;\\n        for (const vector<int>& log : logs) {\\n            const int id = log[0];\\n            const int end_time = log[1];\\n            const int time = end_time - start_time;\\n            \\n            if (time > longest_task || time == longest_task && id < worker) {\\n                worker = id;\\n                longest_task = time;\\n            }\\n\\n            start_time = end_time;\\n        }\\n        return worker;\\n    }\\n```\\t\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(size(logs))$$ we need to look at all the entries in ```logs```.\\n  * Space complexity: $$O(1)$$ only a few integers as state.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks  joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/Nqm4jJcyBf)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int hardestWorker(int n, const vector<vector<int>>& logs) {\\n        int start_time = 0;\\n        int worker = n;\\n        int longest_task = 0;\\n        for (const vector<int>& log : logs) {\\n            const int id = log[0];\\n            const int end_time = log[1];\\n            const int time = end_time - start_time;\\n            \\n            if (time > longest_task || time == longest_task && id < worker) {\\n                worker = id;\\n                longest_task = time;\\n            }\\n\\n            start_time = end_time;\\n        }\\n        return worker;\\n    }\\n```\n```logs```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679148,
                "title": "python-explained-o-n",
                "content": "# Approach\\n- We can iterate through the logs while calculating current task-duration as `logs[i][1]-logs[i-1][1]` for each task and largest task duration as `max_time`.\\n- Now we will find smallest `id` among all the largest task duration.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        times = [logs[0][1]]\\n        max_time = times[0]\\n        for i in range(1, len(logs)):\\n            times.append(logs[i][1]-logs[i-1][1])\\n            max_time = max(max_time, times[i])\\n            \\n        id = 500     \\n        for i in range(len(times)):\\n            if times[i] == max_time:\\n                id = min(id, logs[i][0])\\n                \\n        return id\\n```\\n----------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        times = [logs[0][1]]\\n        max_time = times[0]\\n        for i in range(1, len(logs)):\\n            times.append(logs[i][1]-logs[i-1][1])\\n            max_time = max(max_time, times[i])\\n            \\n        id = 500     \\n        for i in range(len(times)):\\n            if times[i] == max_time:\\n                id = min(id, logs[i][0])\\n                \\n        return id\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678893,
                "title": "c-single-iteration-o-1",
                "content": "```\\nint hardestWorker(int n, vector<vector<int>>& log) {\\n        \\n        int emplID = 0 ;\\n        emplID = log[0][0];\\n        \\n        int lastTime = 0 ;\\n        lastTime = log[0][1]-0 ;\\n        \\n        int maxTime = INT_MIN ;\\n        maxTime = lastTime;\\n        \\n        for( int i=1 ; i<log.size() ; i++ ){\\n            \\n            int temp = log[i][1] - lastTime ;\\n            \\n            if( maxTime < temp ) {\\n                maxTime = temp ;\\n                emplID = log[i][0] ;\\n            }\\n            if( maxTime == temp ) {\\n                emplID = min(log[i][0], emplID) ;\\n            }\\n            \\n            lastTime = log[i][1];\\n        }\\n        \\n        return emplID ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint hardestWorker(int n, vector<vector<int>>& log) {\\n        \\n        int emplID = 0 ;\\n        emplID = log[0][0];\\n        \\n        int lastTime = 0 ;\\n        lastTime = log[0][1]-0 ;\\n        \\n        int maxTime = INT_MIN ;\\n        maxTime = lastTime;\\n        \\n        for( int i=1 ; i<log.size() ; i++ ){\\n            \\n            int temp = log[i][1] - lastTime ;\\n            \\n            if( maxTime < temp ) {\\n                maxTime = temp ;\\n                emplID = log[i][0] ;\\n            }\\n            if( maxTime == temp ) {\\n                emplID = min(log[i][0], emplID) ;\\n            }\\n            \\n            lastTime = log[i][1];\\n        }\\n        \\n        return emplID ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678829,
                "title": "c-simple-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n        int id=INT_MAX, maxi=INT_MIN, last=0;\\n        \\n        for(int i=0; i<logs.size(); i++)\\n        {\\n            if((logs[i][1] - last) > maxi || ((logs[i][1] - last)==maxi && id > logs[i][0]))\\n            {\\n                maxi = (logs[i][1] - last);\\n                id = logs[i][0];\\n            } \\n            last = logs[i][1];\\n        }\\n        return id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n        int id=INT_MAX, maxi=INT_MIN, last=0;\\n        \\n        for(int i=0; i<logs.size(); i++)\\n        {\\n            if((logs[i][1] - last) > maxi || ((logs[i][1] - last)==maxi && id > logs[i][0]))\\n            {\\n                maxi = (logs[i][1] - last);\\n                id = logs[i][0];\\n            } \\n            last = logs[i][1];\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686641,
                "title": "c-o-n-solution-without-maps-simplest",
                "content": "# Do Upvote If Found Helpful\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int emp=logs[0][0];\\n        int tm=logs[0][1];\\n        \\n        for(int i=1;i<logs.size();i++){\\n            int diff = logs[i][1]-logs[i-1][1];\\n            \\n            if(diff > tm){\\n                tm = diff;\\n                emp = logs[i][0];\\n            }\\n            else if(diff==tm){\\n                emp = min(emp,logs[i][0]);\\n            }\\n            \\n        }\\n        \\n        return emp;\\n    }\\n\\t};\\n\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int emp=logs[0][0];\\n        int tm=logs[0][1];\\n        \\n        for(int i=1;i<logs.size();i++){\\n            int diff = logs[i][1]-logs[i-1][1];\\n            \\n            if(diff > tm){\\n                tm = diff;\\n                emp = logs[i][0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2686377,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs)\\n    {\\n       int res=logs[0][0];\\n        int ans=logs[0][1];\\n        for(int i=1;i<logs.size();i++)\\n        {\\n            int d=abs(logs[i-1][1]-logs[i][1]);\\n            if(d==ans)\\n            {\\n                res=min(res,logs[i][0]);\\n            }\\n            else if(d>ans)\\n            {\\n                ans=d;\\n                res=logs[i][0];\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs)\\n    {\\n       int res=logs[0][0];\\n        int ans=logs[0][1];\\n        for(int i=1;i<logs.size();i++)\\n        {\\n            int d=abs(logs[i-1][1]-logs[i][1]);\\n            if(d==ans)\\n            {\\n                res=min(res,logs[i][0]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2681673,
                "title": "power-of-c-stl",
                "content": "**We will strore time_taken to complete a task**\\n**and also store the respected ID corresponding to the time_taken**\\n**Map will store the time_taken in ascending order so we will take the last value from map which is MAXIMUM**\\n**and SET corresponding to that MAXIMUM value will store the MINIMUM ID at beginning**\\n\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        map<int, set<int>> m1;\\n        int prev = 0;\\n        for(auto &it: logs){\\n            m1[int(abs(prev - it[1]))].insert(it[0]);\\n            prev = it[1];\\n        }\\n        auto it = m1.rbegin();\\n        return  *(it->second.begin());\\n    }\\n};\\n```\\n\\n# just trying to give a diffrent solution #",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        map<int, set<int>> m1;\\n        int prev = 0;\\n        for(auto &it: logs){\\n            m1[int(abs(prev - it[1]))].insert(it[0]);\\n            prev = it[1];\\n        }\\n        auto it = m1.rbegin();\\n        return  *(it->second.begin());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680342,
                "title": "java-one-pass-solution",
                "content": "What is the use of giving n?\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1], id = logs[0][0];\\n        for(int i = 1; i < logs.length; i++){\\n            int time = logs[i][1] - logs[i - 1][1];\\n            if(time > max){\\n                max = time;\\n                id = logs[i][0];\\n            }else if(time == max && id > logs[i][0]){\\n                max = time;\\n                id = logs[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1], id = logs[0][0];\\n        for(int i = 1; i < logs.length; i++){\\n            int time = logs[i][1] - logs[i - 1][1];\\n            if(time > max){\\n                max = time;\\n                id = logs[i][0];\\n            }else if(time == max && id > logs[i][0]){\\n                max = time;\\n                id = logs[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680192,
                "title": "python-straightforward-easy-to-understand-solution",
                "content": "`O(n)` \\n1 - change logs by substituting the end and start times\\n2 - find the longest one between durations\\n```\\nlogs = [[log[0], log[1] - logs[idx-1][1] if idx > 0 else log[1]] for idx, log in enumerate(logs)]\\nlongest = max(logs, key=lambda x: (x[1], -x[0]))\\nreturn longest[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nlogs = [[log[0], log[1] - logs[idx-1][1] if idx > 0 else log[1]] for idx, log in enumerate(logs)]\\nlongest = max(logs, key=lambda x: (x[1], -x[0]))\\nreturn longest[0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679566,
                "title": "java-2-approaches",
                "content": "### **Please Upvote** :D\\n##### 1. Normal iteration:\\n* We check the prefix difference at each iteraton.\\n* If it\\'s more than previous difference, we update it and get the ```id```.\\n* If its same then we update the ```id``` with the minimum ```id```.\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int diff = logs[0][1];\\n        int finalId = logs[0][0];\\n\\n        for(int i = 1; i < logs.length; i++){\\n            int currDiff = logs[i][1] - logs[i - 1][1];\\n\\n            if(currDiff > diff){\\n                diff = currDiff;\\n                finalId = logs[i][0];\\n            }\\n\\n            if(currDiff == diff){\\n                finalId = Math.min(finalId, logs[i][0]);\\n            }\\n        }\\n\\n        return finalId;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n##### 2. Using a treemap:\\n* We convert the logs array in such a way that the ```logs[i][1]``` is no more the prefix sum. This will give us the actual duration each employee worked for.\\n```logs = [[0,3],[2,5],[0,9],[1,15]]``` will become ```[[0,3],[2,2],[0,4],[1,6]]```.\\n\\n* We create a treemap and put the working duration as key and a list which will contains ids off all employees who has the same working duration as value. *(A treemap will sort the keyset (the working durations) for us)*\\nSo for ```[[0,3],[2,2],[0,4],[1,6]]``` the map would be ```{2=[2], 3=[0], 4=[0], 6=[1]}```.\\n\\n* We return the **minimum value** in the list mapped to the **last key** element in the map. Because the last key element is the *highest working duration* and minimum value in the list is the *minimum id value of all employee ids who worked for same duration* (if any).\\n\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int l = logs.length;\\n        for (int i = l - 1; i > 0 ; i--) {\\n            logs[i][1] -= logs[i - 1][1];\\n        }\\n\\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\\n\\n        for (int i = 0; i < l; i++) {\\n            map.putIfAbsent(logs[i][1], new ArrayList<>());\\n            map.get(logs[i][1]).add(logs[i][0]);\\n        }\\n\\n        return Collections.min(map.get(map.lastKey()));\\n    }\\n}\\n\\n// TC: O(n) + O(n * logk) => O(n * logk) - k is the size of treemap\\n// TC: O(k) - k is the size of treemap\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```id```\n```id```\n```id```\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int diff = logs[0][1];\\n        int finalId = logs[0][0];\\n\\n        for(int i = 1; i < logs.length; i++){\\n            int currDiff = logs[i][1] - logs[i - 1][1];\\n\\n            if(currDiff > diff){\\n                diff = currDiff;\\n                finalId = logs[i][0];\\n            }\\n\\n            if(currDiff == diff){\\n                finalId = Math.min(finalId, logs[i][0]);\\n            }\\n        }\\n\\n        return finalId;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n```logs[i][1]```\n```logs = [[0,3],[2,5],[0,9],[1,15]]```\n```[[0,3],[2,2],[0,4],[1,6]]```\n```[[0,3],[2,2],[0,4],[1,6]]```\n```{2=[2], 3=[0], 4=[0], 6=[1]}```\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int l = logs.length;\\n        for (int i = l - 1; i > 0 ; i--) {\\n            logs[i][1] -= logs[i - 1][1];\\n        }\\n\\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\\n\\n        for (int i = 0; i < l; i++) {\\n            map.putIfAbsent(logs[i][1], new ArrayList<>());\\n            map.get(logs[i][1]).add(logs[i][0]);\\n        }\\n\\n        return Collections.min(map.get(map.lastKey()));\\n    }\\n}\\n\\n// TC: O(n) + O(n * logk) => O(n * logk) - k is the size of treemap\\n// TC: O(k) - k is the size of treemap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678924,
                "title": "c-easy-to-understand",
                "content": "int hardestWorker(int n, vector<vector<int>>& logs) {\\n        \\n        int ans = logs[0][1];\\n        int id = logs[0][0];\\n        for(int i = 0 ; i < logs.size()-1 ; i++){\\n            int sub = logs[i+1][1] - logs[i][1];\\n            if(sub > ans){\\n                ans = sub;\\n                id = logs[i+1][0];\\n                \\n            }\\n            else if(sub==ans){\\n                id = min(id,logs[i+1][0]);\\n            }\\n            \\n            \\n        }\\n        return id;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int hardestWorker(int n, vector<vector<int>>& logs) {\\n        \\n        int ans = logs[0][1];\\n        int id = logs[0][0];\\n        for(int i = 0 ; i < logs.size()-1 ; i++){\\n            int sub = logs[i+1][1] - logs[i][1];\\n            if(sub > ans){\\n                ans = sub;\\n                id = logs[i+1][0];\\n                \\n            }\\n            else if(sub==ans){\\n                id = min(id,logs[i+1][0]);\\n            }\\n            \\n            \\n        }\\n        return id;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2678897,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int size = logs.size();\\n        int current = logs[0][1];\\n        int res = 0;\\n        map<int,set<int>> mp;\\n        mp[logs[0][1]].insert(logs[0][0]);\\n        for(int i = 1;i<size;i++){\\n            mp[logs[i][1] - current].insert(logs[i][0]);\\n            current = logs[i][1];\\n        }\\n        auto st = *(mp.rbegin());\\n        res = *(st.second.begin());\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int size = logs.size();\\n        int current = logs[0][1];\\n        int res = 0;\\n        map<int,set<int>> mp;\\n        mp[logs[0][1]].insert(logs[0][0]);\\n        for(int i = 1;i<size;i++){\\n            mp[logs[i][1] - current].insert(logs[i][0]);\\n            current = logs[i][1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2686358,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs)\\n    {\\n        int ans,res;\\n        vector<int>vvv=logs[0];\\n        ans=vvv[0];\\n        res=vvv[1];\\n        for(int i=1;i<logs.size();i++)\\n        {\\n            vector<int>vv=logs[i-1];\\n            vector<int>v=logs[i];\\n            int d=abs(v[1]-vv[1]);\\n            if(d==res)\\n            {\\n                ans=min(ans,v[0]);\\n\\n            }\\n            if(d>res)\\n            {\\n                res=d;\\n                ans=v[0];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs)\\n    {\\n        int ans,res;\\n        vector<int>vvv=logs[0];\\n        ans=vvv[0];\\n        res=vvv[1];\\n        for(int i=1;i<logs.size();i++)\\n        {\\n            vector<int>vv=logs[i-1];\\n            vector<int>v=logs[i];\\n            int d=abs(v[1]-vv[1]);\\n            if(d==res)\\n            {\\n                ans=min(ans,v[0]);\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2680996,
                "title": "c-simple-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDirect computation will have just `O(n)` time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple loop will do.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(n)`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(1)`\\n\\n# Code\\n```\\npublic class Solution {\\n    public int HardestWorker(int n, int[][] logs) {\\n        int prior = 0;\\n        int max = 0;\\n        int result = 0;\\n\\n        foreach (int[] item in logs) {\\n            int v = item[1] - prior;\\n\\n            if (v > max || v == max && result > item[0]) {\\n                max = v;\\n                result = item[0];\\n            }\\n            \\n            prior = item[1];\\n        }       \\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HardestWorker(int n, int[][] logs) {\\n        int prior = 0;\\n        int max = 0;\\n        int result = 0;\\n\\n        foreach (int[] item in logs) {\\n            int v = item[1] - prior;\\n\\n            if (v > max || v == max && result > item[0]) {\\n                max = v;\\n                result = item[0];\\n            }\\n            \\n            prior = item[1];\\n        }       \\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680575,
                "title": "c-using-pair-naive-approach",
                "content": "**C++**\\n     \\n\\t int hardestWorker(int n, vector<vector<int>>& logs) {\\n        vector<pair<int,int>> v;\\n        v.push_back({logs[0][0],logs[0][1]});\\n        for(int i=1;i<logs.size();i++){\\n           \\n                v.push_back({logs[i][0],(logs[i][1]-logs[i-1][1])});//get the id and units of time\\n            \\n        }\\n        int min=INT_MIN;int ans=0,r=8456;\\n        for(auto c:v){\\n            if(c.second>=min){\\n                if(c.second==min){\\n                    if(c.first<ans)ans=c.first;//if time taken are same return smallest ID\\n                }\\n                else\\n                { min=c.second;\\n                ans=c.first;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**C++**\\n     \\n\\t int hardestWorker(int n, vector<vector<int>>& logs) {\\n        vector<pair<int,int>> v;\\n        v.push_back({logs[0][0],logs[0][1]});\\n        for(int i=1;i<logs.size();i++){\\n           \\n                v.push_back({logs[i][0],(logs[i][1]-logs[i-1][1])});//get the id and units of time\\n            \\n        }\\n        int min=INT_MIN;int ans=0,r=8456;\\n        for(auto c:v){\\n            if(c.second>=min){\\n                if(c.second==min){\\n                    if(c.first<ans)ans=c.first;//if time taken are same return smallest ID\\n                }\\n                else\\n                { min=c.second;\\n                ans=c.first;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2679286,
                "title": "c-using-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int len = logs.size();\\n        \\n        unordered_map<long,long> mp;\\n        \\n        int diff=0;\\n        for(int i=0; i<len; i++)\\n        {\\n            if(i==0)\\n                mp[logs[i][0]] = logs[i][1];\\n            else{\\n                diff=logs[i][1] - logs[i-1][1];\\n                if(mp.find(logs[i][0]) != mp.end())\\n                {\\n                    if(diff > mp[logs[i][0]])\\n                        mp[logs[i][0]] = diff;\\n                }\\n                else{\\n                    mp[logs[i][0]] = logs[i][1] - logs[i-1][1];\\n                }\\n            }\\n        }\\n        \\n        long shift = INT_MIN;\\n        int empID;\\n        \\n        for(auto x: mp)\\n        {\\n            if(x.second >= shift)\\n            {\\n                if(x.second==shift)\\n                {\\n                    if(x.first < empID)\\n                        empID = x.first;\\n                }\\n                else\\n                {\\n                    shift = x.second;\\n                    empID = x.first;\\n                }\\n            }\\n        }\\n        return empID;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int len = logs.size();\\n        \\n        unordered_map<long,long> mp;\\n        \\n        int diff=0;\\n        for(int i=0; i<len; i++)\\n        {\\n            if(i==0)\\n                mp[logs[i][0]] = logs[i][1];\\n            else{\\n                diff=logs[i][1] - logs[i-1][1];\\n                if(mp.find(logs[i][0]) != mp.end())\\n                {\\n                    if(diff > mp[logs[i][0]])\\n                        mp[logs[i][0]] = diff;\\n                }\\n                else{\\n                    mp[logs[i][0]] = logs[i][1] - logs[i-1][1];\\n                }\\n            }\\n        }\\n        \\n        long shift = INT_MIN;\\n        int empID;\\n        \\n        for(auto x: mp)\\n        {\\n            if(x.second >= shift)\\n            {\\n                if(x.second==shift)\\n                {\\n                    if(x.first < empID)\\n                        empID = x.first;\\n                }\\n                else\\n                {\\n                    shift = x.second;\\n                    empID = x.first;\\n                }\\n            }\\n        }\\n        return empID;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679228,
                "title": "python-single-pass-make-comparisons-t-o-n-s-o-1",
                "content": "**Solution:**\\n\\n```python\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        max_time = logs[0][1]\\n        smallest_id = logs[0][0]\\n        \\n        for i in range(1, len(logs)):\\n            curr_diff = logs[i][1] - logs[i-1][1]\\n            if curr_diff >= max_time:\\n                if curr_diff == max_time:\\n                    smallest_id = min(smallest_id, logs[i][0])\\n                else:\\n                    smallest_id = logs[i][0]\\n                max_time = curr_diff\\n        \\n        return smallest_id\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        max_time = logs[0][1]\\n        smallest_id = logs[0][0]\\n        \\n        for i in range(1, len(logs)):\\n            curr_diff = logs[i][1] - logs[i-1][1]\\n            if curr_diff >= max_time:\\n                if curr_diff == max_time:\\n                    smallest_id = min(smallest_id, logs[i][0])\\n                else:\\n                    smallest_id = logs[i][0]\\n                max_time = curr_diff\\n        \\n        return smallest_id\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679074,
                "title": "python-solution-for-beginners",
                "content": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        diff= logs[0][1]-0\\n        id= logs[0][0]\\n        for i in range(1, len(logs)):\\n            ans= logs[i][1]- logs[i-1][1]\\n            if ans== diff:\\n                id= min(id, logs[i][0])\\n            if ans> diff:\\n                diff= ans\\n                id= logs[i][0]\\n        return id\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        diff= logs[0][1]-0\\n        id= logs[0][0]\\n        for i in range(1, len(logs)):\\n            ans= logs[i][1]- logs[i-1][1]\\n            if ans== diff:\\n                id= min(id, logs[i][0])\\n            if ans> diff:\\n                diff= ans\\n                id= logs[i][0]\\n        return id\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678832,
                "title": "python-task-time-difference",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        prevTime = 0\\n        longestTask = 0\\n        resultid = float(\"inf\")\\n        for eid, time in logs:\\n            taskTime = time - prevTime\\n            # print(taskTime)\\n            prevTime = time\\n            if taskTime > longestTask:\\n                longestTask = taskTime\\n                resultid = eid\\n            elif taskTime == longestTask:\\n                resultid = min(eid, resultid)\\n                \\n        return resultid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        prevTime = 0\\n        longestTask = 0\\n        resultid = float(\"inf\")\\n        for eid, time in logs:\\n            taskTime = time - prevTime\\n            # print(taskTime)\\n            prevTime = time\\n            if taskTime > longestTask:\\n                longestTask = taskTime\\n                resultid = eid\\n            elif taskTime == longestTask:\\n                resultid = min(eid, resultid)\\n                \\n        return resultid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521843,
                "title": "o-n-the-employee-that-worked-on-the-longest-task-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int i, id, time=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(i==0)\\n            {\\n                time = logs[0][1];\\n                id = logs[0][0];\\n            }\\n            else if(logs[i][1]-logs[i-1][1]==time && logs[i][0]<id)\\n            {\\n                id = logs[i][0];\\n            }\\n            else if(logs[i][1]-logs[i-1][1]>time)\\n            {\\n                time = logs[i][1]-logs[i-1][1];\\n                id = logs[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4e60749e-3d37-4d48-a353-bd72193c3829_1684036276.271389.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int i, id, time=0;\\n        for(i=0 ; i<logs.size() ; i++)\\n        {\\n            if(i==0)\\n            {\\n                time = logs[0][1];\\n                id = logs[0][0];\\n            }\\n            else if(logs[i][1]-logs[i-1][1]==time && logs[i][0]<id)\\n            {\\n                id = logs[i][0];\\n            }\\n            else if(logs[i][1]-logs[i-1][1]>time)\\n            {\\n                time = logs[i][1]-logs[i-1][1];\\n                id = logs[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303523,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let tempI = -1;\\n    let tempTime = 0;\\n\\n    let prevStart = 0;\\n    for (const [i, start] of logs) {\\n        const length = start - prevStart;\\n        if (length === tempTime) {\\n            tempI = Math.min(tempI, i);\\n        } else if (length > tempTime) {\\n            tempI = i;\\n            tempTime = length;\\n        }\\n        prevStart = start;\\n    }\\n\\n    return tempI;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let tempI = -1;\\n    let tempTime = 0;\\n\\n    let prevStart = 0;\\n    for (const [i, start] of logs) {\\n        const length = start - prevStart;\\n        if (length === tempTime) {\\n            tempI = Math.min(tempI, i);\\n        } else if (length > tempTime) {\\n            tempI = i;\\n            tempTime = length;\\n        }\\n        prevStart = start;\\n    }\\n\\n    return tempI;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2970012,
                "title": "95-faster-solution-and-easy-to-understand",
                "content": "![Screenshot 2022-12-30 at 10.56.58.png](https://assets.leetcode.com/users/images/9c1e8f0a-7694-4484-a3a7-514a16f30326_1672379856.9461722.png)\\n\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        ans = logs[0]\\n        for i in range(1, len(logs)):\\n            d = logs[i][1]-logs[i-1][1]\\n            if d>ans[1] or d==ans[1] and logs[i][0]<ans[0]: ans = [logs[i][0], d]\\n        return ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        ans = logs[0]\\n        for i in range(1, len(logs)):\\n            d = logs[i][1]-logs[i-1][1]\\n            if d>ans[1] or d==ans[1] and logs[i][0]<ans[0]: ans = [logs[i][0], d]\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685056,
                "title": "c-employee-that-worked-on-longest-task-optimized-solution",
                "content": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n          int work = logs[0][1];\\n        int id = logs[0][0];\\n\\n        int len = logs.size();\\n\\n        for(int i = 1; i < len; i++) {\\n            int diff = logs[i][1] - logs[i-1][1];\\n            if (diff > work) {\\n                id = logs[i][0];\\n                work = diff;\\n            }\\n            else if(diff == work) {\\n                if(id > logs[i][0])\\n                    id = logs[i][0];\\n                work = diff;\\n                }\\n                }\\n        return id;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n          int work = logs[0][1];\\n        int id = logs[0][0];\\n\\n        int len = logs.size();\\n\\n        for(int i = 1; i < len; i++) {\\n            int diff = logs[i][1] - logs[i-1][1];\\n            if (diff > work) {\\n                id = logs[i][0];\\n                work = diff;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2684424,
                "title": "easiest-way-to-understand-these-kind-of-problems",
                "content": "There is O(N) solution to this as well , but for those who tried by using sorting , this is the way to go . \\n\\n```\\n   static bool comp(const vector<int>&a , const vector<int>&b){\\n        return (a[2] > b[2]) || (a[2] == b[2] && a[0]<b[0]) ;\\n    }\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n      for(int i=0;i<logs.size();i++){\\n          if(i==0){\\n              logs[i].push_back(logs[i][1]);\\n          }\\n          else{\\n              logs[i].push_back(logs[i][1] - logs[i-1][1]);\\n          }\\n      }\\n      sort(logs.begin(),logs.end(),comp);\\n      return logs[0][0];  \\n```\\nFirstly, loop through the logs and as we know that at the first log , the initial time is 0 so just push back the same value . \\nSecond, we will apply our not so fancy logic of subtracting the current log time with the previous log time and store that in our same logs vector. \\nHey wait ??? hold on , why are you storing it ??? \\n\\nAlright the reason for storing it is , we need to sort these times based on the largest value difference  , if they are equal i need to sort them based on the ids. i.e., i store the differences as the 3rd column in every log . \\n\\n\\nand the fancy part of our code comes with the comp function which sorts the array . hope that logic is self explanatory",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n   static bool comp(const vector<int>&a , const vector<int>&b){\\n        return (a[2] > b[2]) || (a[2] == b[2] && a[0]<b[0]) ;\\n    }\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n      for(int i=0;i<logs.size();i++){\\n          if(i==0){\\n              logs[i].push_back(logs[i][1]);\\n          }\\n          else{\\n              logs[i].push_back(logs[i][1] - logs[i-1][1]);\\n          }\\n      }\\n      sort(logs.begin(),logs.end(),comp);\\n      return logs[0][0];  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2682777,
                "title": "most-easy-c-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        \\n        int N=logs.size();\\n        int cnt=logs[0][1];\\n        int ans=logs[0][0];\\n        for(int i=1;i<N;i++){\\n            int k=abs(logs[i-1][1]-logs[i][1] );\\n            if(k==cnt){\\n                ans=min(ans, logs[i][0]);\\n            }\\n            if(k > cnt){\\n                cnt=k;\\n               ans=logs[i][0];\\n            } \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        \\n        int N=logs.size();\\n        int cnt=logs[0][1];\\n        int ans=logs[0][0];\\n        for(int i=1;i<N;i++){\\n            int k=abs(logs[i-1][1]-logs[i][1] );\\n            if(k==cnt){\\n                ans=min(ans, logs[i][0]);\\n            }\\n            if(k > cnt){\\n                cnt=k;\\n               ans=logs[i][0];\\n            } \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682179,
                "title": "100-fast-simple-solution",
                "content": "```\\nvar hardestWorker = function(n, logs) {\\n    let highestTaskCompletionTime = 0\\n    let employeeId = 0\\n    \\n    let previousTaskCompletion = 0\\n    \\n    for ( task of logs) {\\n        const taskCompletionTime = task[1] - previousTaskCompletion\\n        \\n        if(taskCompletionTime > highestTaskCompletionTime) {\\n            highestTaskCompletionTime = taskCompletionTime\\n            employeeId = task[0]\\n        }\\n        \\n        if(taskCompletionTime === highestTaskCompletionTime && task[0] < employeeId) {\\n            employeeId = task[0]\\n        }\\n        \\n        previousTaskCompletion = task[1]\\n    }\\n    \\n    return employeeId\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hardestWorker = function(n, logs) {\\n    let highestTaskCompletionTime = 0\\n    let employeeId = 0\\n    \\n    let previousTaskCompletion = 0\\n    \\n    for ( task of logs) {\\n        const taskCompletionTime = task[1] - previousTaskCompletion\\n        \\n        if(taskCompletionTime > highestTaskCompletionTime) {\\n            highestTaskCompletionTime = taskCompletionTime\\n            employeeId = task[0]\\n        }\\n        \\n        if(taskCompletionTime === highestTaskCompletionTime && task[0] < employeeId) {\\n            employeeId = task[0]\\n        }\\n        \\n        previousTaskCompletion = task[1]\\n    }\\n    \\n    return employeeId\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681274,
                "title": "java-o-n-simple-solution",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] log) {\\n       //ids list stores the id\\'s present in log\\n        //diff list stores difference between the time intervals\\n        List<Integer> ids = new ArrayList<>(),diff = new ArrayList<>();\\n        \\n        ids.add(log[0][0]);\\n        diff.add(log[0][1]);\\n        //add id\\'s as well as differences of time intervals\\n        for(int i = 1;i<log.length;i++){\\n            ids.add(log[i][0]);\\n            diff.add(log[i][1]-log[i-1][1]);\\n            \\n        }\\n       //ans list stores id of a person who spent more time than anyone\\n        List<Integer> ans = new ArrayList<>();\\n        //Find the maximum time and add particular value that present in the id\\'s\\n        int max = Collections.max(diff);\\n        for(int i = 0;i<diff.size();i++){\\n            if(max == diff.get(i)){\\n                ans.add(ids.get(i));\\n            }\\n        }\\n        // just in case if we have same time spent we have to return \\n        //minimum id value \\n        return Collections.min(ans);\\n    }\\n}\\n//Time Complexity O(n) \\n//Space Complexity O(n) size of the list\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] log) {\\n       //ids list stores the id\\'s present in log\\n        //diff list stores difference between the time intervals\\n        List<Integer> ids = new ArrayList<>(),diff = new ArrayList<>();\\n        \\n        ids.add(log[0][0]);\\n        diff.add(log[0][1]);\\n        //add id\\'s as well as differences of time intervals\\n        for(int i = 1;i<log.length;i++){\\n            ids.add(log[i][0]);\\n            diff.add(log[i][1]-log[i-1][1]);\\n            \\n        }\\n       //ans list stores id of a person who spent more time than anyone\\n        List<Integer> ans = new ArrayList<>();\\n        //Find the maximum time and add particular value that present in the id\\'s\\n        int max = Collections.max(diff);\\n        for(int i = 0;i<diff.size();i++){\\n            if(max == diff.get(i)){\\n                ans.add(ids.get(i));\\n            }\\n        }\\n        // just in case if we have same time spent we have to return \\n        //minimum id value \\n        return Collections.min(ans);\\n    }\\n}\\n//Time Complexity O(n) \\n//Space Complexity O(n) size of the list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680984,
                "title": "java-solution-o-n-time-o-1-space-0ms-runtime-faster-than-100",
                "content": "```java \\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        \\n        int maxTime=logs[0][1];\\n        int id=logs[0][0];\\n        for(int i=1;i<logs.length;i++)\\n        {\\n           if(logs[i][1]-logs[i-1][1]>=maxTime){\\n               if(logs[i][1]-logs[i-1][1]==maxTime){\\n                   if(id>logs[i][0]){\\n                   id = logs[i][0];\\n                   }\\n               }\\n               else{\\n                   maxTime = logs[i][1]-logs[i-1][1];\\n                   id = logs[i][0];\\n               }\\n           }\\n        }\\n        return id;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        \\n        int maxTime=logs[0][1];\\n        int id=logs[0][0];\\n        for(int i=1;i<logs.length;i++)\\n        {\\n           if(logs[i][1]-logs[i-1][1]>=maxTime){\\n               if(logs[i][1]-logs[i-1][1]==maxTime){\\n                   if(id>logs[i][0]){\\n                   id = logs[i][0];\\n                   }",
                "codeTag": "Java"
            },
            {
                "id": 2680387,
                "title": "very-easy-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int ans=0;\\n        int id=logs[0][0];\\n        int time=logs[0][1]-0;\\n        for(int i=1;i<logs.size();i++){\\n            ans=logs[i][1]-logs[i-1][1];\\n            if(ans==time){\\n                id=min(id,logs[i][0]);\\n            }\\n            if(ans>time){\\n                time=ans;\\n                id=logs[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int ans=0;\\n        int id=logs[0][0];\\n        int time=logs[0][1]-0;\\n        for(int i=1;i<logs.size();i++){\\n            ans=logs[i][1]-logs[i-1][1];\\n            if(ans==time){\\n                id=min(id,logs[i][0]);\\n            }\\n            if(ans>time){\\n                time=ans;\\n                id=logs[i][0];\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680248,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int k, vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int prev = 0;\\n        \\n        int max_diff = 0;\\n        \\n        int max_id = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int diff = arr[i][1] - prev;\\n            \\n            if(diff > max_diff)\\n            {\\n                max_diff = diff;\\n                \\n                max_id = arr[i][0];\\n            }\\n            else if(diff == max_diff && max_id > arr[i][0])\\n            {\\n                max_id = arr[i][0];\\n            }\\n            \\n            prev = arr[i][1];\\n        }\\n        \\n        return max_id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int k, vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int prev = 0;\\n        \\n        int max_diff = 0;\\n        \\n        int max_id = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int diff = arr[i][1] - prev;\\n            \\n            if(diff > max_diff)\\n            {\\n                max_diff = diff;\\n                \\n                max_id = arr[i][0];\\n            }\\n            else if(diff == max_diff && max_id > arr[i][0])\\n            {\\n                max_id = arr[i][0];\\n            }\\n            \\n            prev = arr[i][1];\\n        }\\n        \\n        return max_id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679867,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max=logs[0][1]; //we get the max value difference\\n        for(int i=1;i<logs.length;i++){\\n            max=Math.max(max,logs[i][1]-logs[i-1][1]);\\n        }\\n        //take a list add id\\'s withb is equal to difference\\n        List<Integer> list=new ArrayList<>();\\n        if(max==logs[0][1]){\\n            list.add(logs[0][0]);\\n        }\\n        //similary go through entire logs array\\n        for(int i=1;i<logs.length;i++){\\n            if(logs[i][1]-logs[i-1][1]==max){\\n                list.add(logs[i][0]);\\n            }\\n        }\\n        //in case of example 3\\n        //difference is 10 units repeated in two times as per question we should get smallest id so we should sort list array\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max=logs[0][1]; //we get the max value difference\\n        for(int i=1;i<logs.length;i++){\\n            max=Math.max(max,logs[i][1]-logs[i-1][1]);\\n        }\\n        //take a list add id\\'s withb is equal to difference\\n        List<Integer> list=new ArrayList<>();\\n        if(max==logs[0][1]){\\n            list.add(logs[0][0]);\\n        }\\n        //similary go through entire logs array\\n        for(int i=1;i<logs.length;i++){\\n            if(logs[i][1]-logs[i-1][1]==max){\\n                list.add(logs[i][0]);\\n            }\\n        }\\n        //in case of example 3\\n        //difference is 10 units repeated in two times as per question we should get smallest id so we should sort list array\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679697,
                "title": "c-solution-the-employee-that-worked-on-the-longest-task",
                "content": "```\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n        int start=0, longest=0,ans=INT_MAX,ansi=INT_MAX;\\n        for(auto it: logs){\\n            int time = it[1]-start;\\n            start=it[1];\\n            ansi = it[0];\\n            if(time>longest) {\\n                longest = time;\\n                ans=it[0];\\n            }\\n            if(time==longest && ansi<=ans) ans= ansi;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n        int start=0, longest=0,ans=INT_MAX,ansi=INT_MAX;\\n        for(auto it: logs){\\n            int time = it[1]-start;\\n            start=it[1];\\n            ansi = it[0];\\n            if(time>longest) {\\n                longest = time;\\n                ans=it[0];\\n            }\\n            if(time==longest && ansi<=ans) ans= ansi;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679421,
                "title": "simplest-easiest-best-java-solution",
                "content": "# **Please Upvote if you like it**\\n**Hey guys don\\'t loose hope if you were not able to solve it in given time limit , it doesn\\'t matter , all that matters is your determination because of which you are here , trying to get the solution..of the problem and get that solved .\\nKeep up this spirit ! I was also able to solve only one question and that too after the time got over , lets see the approach :-**\\n\\n\\'\\'\\'\\nclass Solution {\\n\\n    public int hardestWorker(int n, int[][] logs) {\\n\\t\\n        Map<Integer,Integer> m  = new HashMap();\\n\\t\\t//keys are the leavetime and values are the ids in map\\n        for(int i=0;i<logs.length;i++){\\n            m.put(logs[i][1],logs[i][0]);\\n        }\\n        List<Integer> l = new ArrayList();\\n        //List<Integer> list = new ArrayList();\\n        int[] arr = new int[logs.length];\\n        arr[0]=logs[0][1];\\n\\t\\t//array to store differences of leavetimes\\n        for(int i=1;i<logs.length;i++){\\n             arr[i]=logs[i][1]-logs[i-1][1];\\n        }\\n        int max = Integer.MIN_VALUE;\\n        int temp=-1;\\n\\t\\t//finding maximum of those differences\\n        for(int i=0;i<arr.length;i++){\\n            \\n            if(arr[i]>max){\\n                max=arr[i];\\n                temp=i;\\n                \\n            }\\n           \\n        }\\n\\t\\t//storing values as same as the max difference from arr in arraylist \\'l\\'\\n        for(int i=0;i<arr.length;i++){\\n            \\n            if(arr[i]==max){\\n                l.add(i);\\n            }\\n        }\\n        \\n        //l.add(0,temp);\\n\\t\\t// checking for same leave time max differences using list in map and return the lowest id \\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<l.size();i++){\\n            if(m.get(logs[l.get(i)][1])<min){\\n                min=m.get(logs[l.get(i)][1]);\\n            }\\n            \\n      }\\n        return min;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\n    public int hardestWorker(int n, int[][] logs) {\\n\\t\\n        Map<Integer,Integer> m  = new HashMap();\\n\\t\\t//keys are the leavetime and values are the ids in map\\n        for(int i=0;i<logs.length;i++){\\n            m.put(logs[i][1],logs[i][0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2679406,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int prev_time = 0;\\n        int max_time = 0;\\n        int max_id = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            int time = logs[i][1] - prev_time;\\n            prev_time = logs[i][1];\\n            if(time > max_time){\\n                max_time = time;\\n                max_id = logs[i][0];\\n            }\\n            else if(time == max_time)\\n                max_id = min(max_id, logs[i][0]);\\n        }\\n        return max_id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int prev_time = 0;\\n        int max_time = 0;\\n        int max_id = 0;\\n        for(int i = 0; i < logs.size(); i++){\\n            int time = logs[i][1] - prev_time;\\n            prev_time = logs[i][1];\\n            if(time > max_time){\\n                max_time = time;\\n                max_id = logs[i][0];\\n            }\\n            else if(time == max_time)\\n                max_id = min(max_id, logs[i][0]);\\n        }\\n        return max_id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679389,
                "title": "c-simple-approach-with-comments",
                "content": "```\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n        int start_time = 0;\\n        int res_id = 0;\\n        int size = logs.size() - 1;\\n        int longest_time = 0;\\n\\n        for (int i = 0; i <= size; i++)\\n        {\\n            int id = logs[i][0];\\n            int end_time = logs[i][1];\\n            \\n            // total time taken in performing each task.\\n            int curr = end_time - start_time;\\n            \\n            // if the curr task takes more time than previous task.\\n            if (longest_time < curr)\\n            {\\n                longest_time = curr;\\n                res_id = id;\\n            }\\n            \\n            // If the both tasks takes the same amount of time , return the min id.\\n            if (longest_time == curr)\\n            {\\n                res_id = min(res_id, id);\\n            }\\n            \\n            // the end_time of the previous task will be the start of the next task.\\n            start_time = end_time;\\n        }\\n        return res_id;\\n    }\\n```\\n\\n**Time Complexity :- O(N)\\nSpace Complexity :- O(1)**\\n\\nIf you like the solution , please upvote it \\uD83D\\uDE01.\\nThank you \\uD83D\\uDC4D.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n        int start_time = 0;\\n        int res_id = 0;\\n        int size = logs.size() - 1;\\n        int longest_time = 0;\\n\\n        for (int i = 0; i <= size; i++)\\n        {\\n            int id = logs[i][0];\\n            int end_time = logs[i][1];\\n            \\n            // total time taken in performing each task.\\n            int curr = end_time - start_time;\\n            \\n            // if the curr task takes more time than previous task.\\n            if (longest_time < curr)\\n            {\\n                longest_time = curr;\\n                res_id = id;\\n            }\\n            \\n            // If the both tasks takes the same amount of time , return the min id.\\n            if (longest_time == curr)\\n            {\\n                res_id = min(res_id, id);\\n            }\\n            \\n            // the end_time of the previous task will be the start of the next task.\\n            start_time = end_time;\\n        }\\n        return res_id;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679245,
                "title": "python-hashmap-solution-easy-understanding",
                "content": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        i,j = 0,0\\n        hashmap = {}\\n        ids = []\\n        for idx,time in logs:\\n            hashmap[j] = abs(i-time)\\n            i = time\\n            j += 1\\n        values = list(hashmap.values())\\n        maxy = max(values)\\n        for key,value in hashmap.items():\\n            if value == maxy:\\n                ids.append(logs[key][0])\\n        return min(ids)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        i,j = 0,0\\n        hashmap = {}\\n        ids = []\\n        for idx,time in logs:\\n            hashmap[j] = abs(i-time)\\n            i = time\\n            j += 1\\n        values = list(hashmap.values())\\n        maxy = max(values)\\n        for key,value in hashmap.items():\\n            if value == maxy:\\n                ids.append(logs[key][0])\\n        return min(ids)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679110,
                "title": "rust-max-min-with-comments",
                "content": "This is my unrevised submission for the 2022-10-09 Weekly Contest 314. Compute the differences between the timestamps, and find the largest difference. If two differences are equal, then choose the lowest employee ID. Using `then` with a reversed comparison to get the lowest ID here.\\n\\nComment: I wanted to do a functional solution, but I should have gone for an imperative, since this took significantly longer to put together.\\n\\n```\\nimpl Solution {\\n    pub fn hardest_worker(n: i32, logs: Vec<Vec<i32>>) -> i32 {\\n        logs.into_iter().scan(0, |t, log| {\\n            let rez = Some((log[0], log[1] - *t));\\n            *t = log[1];\\n            rez\\n        }).max_by(|w1, w2| w1.1.cmp(&w2.1).then(w2.0.cmp(&w1.0))).unwrap().0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn hardest_worker(n: i32, logs: Vec<Vec<i32>>) -> i32 {\\n        logs.into_iter().scan(0, |t, log| {\\n            let rez = Some((log[0], log[1] - *t));\\n            *t = log[1];\\n            rez\\n        }).max_by(|w1, w2| w1.1.cmp(&w2.1).then(w2.0.cmp(&w1.0))).unwrap().0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2679001,
                "title": "java-accepted-logic-with-explaination",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n      \\n        int max = logs[0][1];\\n        int id = logs[0][0];\\n        //just traverse and keep track of larger unit time and\\n        //if they are equal then update our id to smaller within them\\n        for(int i = 1; i < logs.length ; i++){\\n            if(max <= logs[i][1]-logs[i-1][1]){\\n                if(max == logs[i][1]-logs[i-1][1]){\\n                    id = Math.min(id,logs[i][0]);\\n                }\\n                else{\\n                    max = Math.max(max,logs[i][1]-logs[i-1][1]);\\n                    id = logs[i][0];\\n                }\\n            }\\n        }\\n        \\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n      \\n        int max = logs[0][1];\\n        int id = logs[0][0];\\n        //just traverse and keep track of larger unit time and\\n        //if they are equal then update our id to smaller within them\\n        for(int i = 1; i < logs.length ; i++){\\n            if(max <= logs[i][1]-logs[i-1][1]){\\n                if(max == logs[i][1]-logs[i-1][1]){\\n                    id = Math.min(id,logs[i][0]);\\n                }\\n                else{\\n                    max = Math.max(max,logs[i][1]-logs[i-1][1]);\\n                    id = logs[i][0];\\n                }\\n            }\\n        }\\n        \\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678969,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        \\n        int maxTime = logs[0][1];\\n        int minEmp = logs[0][0];\\n        \\n        for(int i=1; i<logs.length; i++) {\\n            int timeTaken = logs[i][1] - logs[i-1][1];\\n            int empId = logs[i][0];\\n         \\n            if(timeTaken > maxTime) {\\n                maxTime = timeTaken;\\n                minEmp = empId;\\n            } else if(timeTaken == maxTime) {\\n                maxTime = timeTaken;\\n                minEmp = Math.min(empId, minEmp);\\n            }\\n        }\\n        \\n        return minEmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        \\n        int maxTime = logs[0][1];\\n        int minEmp = logs[0][0];\\n        \\n        for(int i=1; i<logs.length; i++) {\\n            int timeTaken = logs[i][1] - logs[i-1][1];\\n            int empId = logs[i][0];\\n         \\n            if(timeTaken > maxTime) {\\n                maxTime = timeTaken;\\n                minEmp = empId;\\n            } else if(timeTaken == maxTime) {\\n                maxTime = timeTaken;\\n                minEmp = Math.min(empId, minEmp);\\n            }\\n        }\\n        \\n        return minEmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678956,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        //output\\n        int out = -1;\\n        //longest task so far\\n        int currMax = 0;\\n        //start of the task\\n        int start = 0;\\n        \\n        for(int[] log : logs) {\\n            //calculate time the task took\\n            int time = log[1] - start;\\n            \\n            //if we found longer task or task of same length with lower id\\n            if(time > currMax || (time == currMax && out > log[0])) {\\n                //update output and longest task time\\n                currMax = time;\\n                out = log[0];\\n            }\\n            \\n            //update start for the next task\\n            start = log[1];\\n        }\\n        \\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        //output\\n        int out = -1;\\n        //longest task so far\\n        int currMax = 0;\\n        //start of the task\\n        int start = 0;\\n        \\n        for(int[] log : logs) {\\n            //calculate time the task took\\n            int time = log[1] - start;\\n            \\n            //if we found longer task or task of same length with lower id\\n            if(time > currMax || (time == currMax && out > log[0])) {\\n                //update output and longest task time\\n                currMax = time;\\n                out = log[0];\\n            }\\n            \\n            //update start for the next task\\n            start = log[1];\\n        }\\n        \\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678935,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>&v) {\\n        ll ans=v[0][0], pre=v[0][1];\\n        for(ll i=1;i<v.size();++i){\\n            ll res=v[i][1]-v[i-1][1];\\n            if(res>pre){\\n                pre=res, ans=v[i][0];\\n            }\\n            else if(res==pre){\\n                ans=min(ans, ll(v[i][0]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>&v) {\\n        ll ans=v[0][0], pre=v[0][1];\\n        for(ll i=1;i<v.size();++i){\\n            ll res=v[i][1]-v[i-1][1];\\n            if(res>pre){\\n                pre=res, ans=v[i][0];\\n            }\\n            else if(res==pre){\\n                ans=min(ans, ll(v[i][0]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678888,
                "title": "c-efficient-and-simple-approach",
                "content": "```\\n int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int initialtime=0;\\n        int preres=INT_MIN;\\n        int ans=n;\\n        for(int i=0;i<logs.size();i++){\\n            int currdiff=(logs[i][1]-initialtime);\\n            if(currdiff>preres){\\n                preres=currdiff;\\n                ans=i;\\n            }else if(currdiff==preres){\\n                if(logs[i][0]<logs[ans][0]){\\n                    ans=i;\\n                }\\n            }\\n            initialtime=logs[i][1];\\n        }\\n        return logs[ans][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int initialtime=0;\\n        int preres=INT_MIN;\\n        int ans=n;\\n        for(int i=0;i<logs.size();i++){\\n            int currdiff=(logs[i][1]-initialtime);\\n            if(currdiff>preres){\\n                preres=currdiff;\\n                ans=i;\\n            }else if(currdiff==preres){\\n                if(logs[i][0]<logs[ans][0]){\\n                    ans=i;\\n                }\\n            }\\n            initialtime=logs[i][1];\\n        }\\n        return logs[ans][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678870,
                "title": "the-employee-that-worked-on-the-longest-task-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int maxT = logs[0][1];\\n        int id=logs[0][0];\\n        int prev=logs[0][1];\\n        for(int i=1; i<logs.size(); i++){\\n\\t\\t//checking for tie\\n            if(logs[i][1]-prev==maxT){\\n\\t\\t//taking the smallest id\\n                id=min(logs[i][0], id);\\n            }\\n            else if(logs[i][1]-prev > maxT){\\n                id=logs[i][0];\\n                maxT = logs[i][1]-prev;\\n            }\\n            prev = logs[i][1];\\n        }\\n        return id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int maxT = logs[0][1];\\n        int id=logs[0][0];\\n        int prev=logs[0][1];\\n        for(int i=1; i<logs.size(); i++){\\n\\t\\t//checking for tie\\n            if(logs[i][1]-prev==maxT){\\n\\t\\t//taking the smallest id\\n                id=min(logs[i][0], id);\\n            }\\n            else if(logs[i][1]-prev > maxT){\\n                id=logs[i][0];\\n                maxT = logs[i][1]-prev;\\n            }\\n            prev = logs[i][1];\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678827,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int start=0;\\n        int id=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<logs.length;i++){\\n            int end=logs[i][1];\\n            int timetaken=end-start;\\n            if(max<timetaken){\\n                max=timetaken;\\n                id=logs[i][0];\\n            }\\n            else if(max==timetaken){\\n                id=Math.min(id,logs[i][0]);\\n            }\\n            start=end;\\n        }\\n        return id;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int start=0;\\n        int id=0;\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<logs.length;i++){\\n            int end=logs[i][1];\\n            int timetaken=end-start;\\n            if(max<timetaken){\\n                max=timetaken;\\n                id=logs[i][0];\\n            }\\n            else if(max==timetaken){\\n                id=Math.min(id,logs[i][0]);\\n            }\\n            start=end;\\n        }\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086829,
                "title": "c-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * 2432. The Employee That Worked on the Longest Task\\n *\\n * There are n employees, each with a unique id from 0 to n - 1.\\n * \\n * You are given a 2D integer array logs where logs[i] = \\n * [idi, leaveTimei] where:\\n * \\n * idi is the id of the employee that worked on the ith task, \\n * and leaveTimei is the time at which the employee finished \\n * the ith task. All the values leaveTimei are unique.\\n * Note that the ith task starts the moment right after the \\n * (i - 1)th task ends, and the 0th task starts at time 0.\\n * \\n * Return the id of the employee that worked the task with the \\n * longest time. If there is a tie between two or more employees, \\n * return the smallest id among them.\\n *\\n * 2 <= n <= 500\\n * 1 <= logs.length <= 500\\n * logs[i].length == 2\\n * 0 <= idi <= n - 1\\n * 1 <= leaveTimei <= 500\\n * idi != idi+1\\n * leaveTimei are sorted in a strictly increasing order.\\n */\\n\\nint hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n\\n    /*\\n     * Input:\\n     *  n,\\n     *  **logs,\\n     *  logsSize\\n     *  logsColSize\\n     */\\n\\n    int prev = 0, diff, max = INT_MIN, id = INT_MAX;\\n    \\n    for (int i = 0; i < logsSize; i++) {\\n    \\n        diff = logs[i][1] - prev;\\n        \\n        if (diff > max) {\\n            id = logs[i][0];\\n            max = diff;\\n        }\\n        else if (diff == max && logs[i][0] < id) {\\n            id = logs[i][0];\\n        }\\n        \\n        prev = logs[i][1];\\n    }\\n    \\n    /*\\n     * Output:\\n     *\\n     *  Return the id of the employee that worked the task with the \\n     *  longest time. If there is a tie between two or more employees, \\n     *  return the smallest id among them.\\n     */\\n\\n    return id;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n/*\\n * 2432. The Employee That Worked on the Longest Task\\n *\\n * There are n employees, each with a unique id from 0 to n - 1.\\n * \\n * You are given a 2D integer array logs where logs[i] = \\n * [idi, leaveTimei] where:\\n * \\n * idi is the id of the employee that worked on the ith task, \\n * and leaveTimei is the time at which the employee finished \\n * the ith task. All the values leaveTimei are unique.\\n * Note that the ith task starts the moment right after the \\n * (i - 1)th task ends, and the 0th task starts at time 0.\\n * \\n * Return the id of the employee that worked the task with the \\n * longest time. If there is a tie between two or more employees, \\n * return the smallest id among them.\\n *\\n * 2 <= n <= 500\\n * 1 <= logs.length <= 500\\n * logs[i].length == 2\\n * 0 <= idi <= n - 1\\n * 1 <= leaveTimei <= 500\\n * idi != idi+1\\n * leaveTimei are sorted in a strictly increasing order.\\n */\\n\\nint hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n\\n    /*\\n     * Input:\\n     *  n,\\n     *  **logs,\\n     *  logsSize\\n     *  logsColSize\\n     */\\n\\n    int prev = 0, diff, max = INT_MIN, id = INT_MAX;\\n    \\n    for (int i = 0; i < logsSize; i++) {\\n    \\n        diff = logs[i][1] - prev;\\n        \\n        if (diff > max) {\\n            id = logs[i][0];\\n            max = diff;\\n        }\\n        else if (diff == max && logs[i][0] < id) {\\n            id = logs[i][0];\\n        }\\n        \\n        prev = logs[i][1];\\n    }\\n    \\n    /*\\n     * Output:\\n     *\\n     *  Return the id of the employee that worked the task with the \\n     *  longest time. If there is a tie between two or more employees, \\n     *  return the smallest id among them.\\n     */\\n\\n    return id;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065748,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        \\n        int value, max=logs[0][1], id=logs[0][0], minId=logs[0][0];\\n        for(int i=1; i<logs.length; i++){\\n            value=logs[i][1]-logs[i-1][1];\\n            if(value>max){\\n                max=value;\\n                id=logs[i][0];\\n                minId=id;\\n               \\n            }\\n            else if(value==max){\\n                if(logs[i][0]>=minId)\\n                    minId=minId;\\n                else if(logs[i][0]<minId)\\n                    minId=logs[i][0];\\n            }\\n        }\\n        return minId;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        \\n        int value, max=logs[0][1], id=logs[0][0], minId=logs[0][0];\\n        for(int i=1; i<logs.length; i++){\\n            value=logs[i][1]-logs[i-1][1];\\n            if(value>max){\\n                max=value;\\n                id=logs[i][0];\\n                minId=id;\\n               \\n            }\\n            else if(value==max){\\n                if(logs[i][0]>=minId)\\n                    minId=minId;\\n                else if(logs[i][0]<minId)\\n                    minId=logs[i][0];\\n            }\\n        }\\n        return minId;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061645,
                "title": "too-easy-to-understand-beats-runtime-100-memory-98",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt might look difficult at first, but it is just csort of comparison. As constraint says, n >= 1, so assign the 0th index values to maxTime and id variable and then make a loop and change the value of maxTime and id as per the conditions.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/16bc4925-ac58-47a9-97fb-84162b31443d_1695064169.5658245.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        // read approach once\\n        int maxTime = logs[0][1];\\n        int id = logs[0][0];\\n        \\n        for(int i = 1; i < logs.length; i++){\\n            // if the current working time is greater than the stored working time, \\n            //than assign the current time difference and current id to the variables\\n            if((logs[i][1] - logs[i-1][1]) > maxTime){\\n                maxTime = logs[i][1] - logs[i-1][1];\\n                id = logs[i][0];\\n            }\\n            else if((logs[i][1] - logs[i-1][1]) == maxTime){\\n                // if conditions - change the value only when the current id\\n                // is smaller than the stored id\\n                if(id > logs[i][0]){\\n                    id = logs[i][0];\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        // read approach once\\n        int maxTime = logs[0][1];\\n        int id = logs[0][0];\\n        \\n        for(int i = 1; i < logs.length; i++){\\n            // if the current working time is greater than the stored working time, \\n            //than assign the current time difference and current id to the variables\\n            if((logs[i][1] - logs[i-1][1]) > maxTime){\\n                maxTime = logs[i][1] - logs[i-1][1];\\n                id = logs[i][0];\\n            }\\n            else if((logs[i][1] - logs[i-1][1]) == maxTime){\\n                // if conditions - change the value only when the current id\\n                // is smaller than the stored id\\n                if(id > logs[i][0]){\\n                    id = logs[i][0];\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056095,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int val = -1, max = 0, distance = 0, maxDistance = 0;\\n        for(int i=0; i<logs.length; i++)\\n        {\\n            for(int j=0; j<logs[0].length; j++){\\n                distance = logs[i][1] - max;\\n                max = logs[i][1];\\n                if(maxDistance < distance ||(maxDistance == distance && val>logs[i][0] )){\\n                    maxDistance = distance;\\n                    \\n                    val = logs[i][0];\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int val = -1, max = 0, distance = 0, maxDistance = 0;\\n        for(int i=0; i<logs.length; i++)\\n        {\\n            for(int j=0; j<logs[0].length; j++){\\n                distance = logs[i][1] - max;\\n                max = logs[i][1];\\n                if(maxDistance < distance ||(maxDistance == distance && val>logs[i][0] )){\\n                    maxDistance = distance;\\n                    \\n                    val = logs[i][0];\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031028,
                "title": "c-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse Multimap\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        multimap<int,int>mp;\\n        int start = 0;\\n        int end = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                start = logs[i][0];\\n                end = logs[i][1];\\n                mp.insert(make_pair(start,end));\\n            }\\n            else\\n            {\\n                start = logs[i][0];\\n                end = logs[i][1]-logs[i-1][1];\\n                mp.insert(make_pair(start,end));\\n            }\\n        }\\n        int large = 0;\\n        int id;\\n        vector<int>v;\\n        for(const auto&pair :mp)\\n        {\\n            if(large < pair.second)\\n            {\\n                large = pair.second;\\n                id = pair.first;\\n            }\\n        }\\n        for(const auto& pair:mp)\\n        {\\n            if(large == pair.second)\\n            {\\n                v.push_back(pair.first);\\n            }\\n        }\\n        return *min_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        multimap<int,int>mp;\\n        int start = 0;\\n        int end = 0;\\n        for(int i=0;i<logs.size();i++)\\n        {\\n            if(i==0)\\n            {\\n                start = logs[i][0];\\n                end = logs[i][1];\\n                mp.insert(make_pair(start,end));\\n            }\\n            else\\n            {\\n                start = logs[i][0];\\n                end = logs[i][1]-logs[i-1][1];\\n                mp.insert(make_pair(start,end));\\n            }\\n        }\\n        int large = 0;\\n        int id;\\n        vector<int>v;\\n        for(const auto&pair :mp)\\n        {\\n            if(large < pair.second)\\n            {\\n                large = pair.second;\\n                id = pair.first;\\n            }\\n        }\\n        for(const auto& pair:mp)\\n        {\\n            if(large == pair.second)\\n            {\\n                v.push_back(pair.first);\\n            }\\n        }\\n        return *min_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004393,
                "title": "python-beating-90-solutions-with-3-variable-only-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        emp=-1\\n        start=0\\n        maxi=0\\n        for i in logs:\\n            end=i[1]\\n            dur=end-start\\n            if maxi<dur:\\n                maxi=dur\\n                emp=i[0]\\n            elif maxi==dur:\\n                emp=min(i[0],emp)\\n            start=end\\n\\n        return emp\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        emp=-1\\n        start=0\\n        maxi=0\\n        for i in logs:\\n            end=i[1]\\n            dur=end-start\\n            if maxi<dur:\\n                maxi=dur\\n                emp=i[0]\\n            elif maxi==dur:\\n                emp=min(i[0],emp)\\n            start=end\\n\\n        return emp\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993537,
                "title": "c-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int mx=INT_MIN;\\n        for(int i=0; i<logs.size()-1; i++){\\n            if(i==0){\\n                mx=max(mx, logs[i][1]);\\n            }\\n            mx=max(mx, (logs[i+1][1]-logs[i][1]));\\n        }\\n        vector<int> id;\\n        for(int i=1; i<logs.size(); i++){\\n            if(mx==(logs[i][1]-logs[i-1][1])){\\n                id.push_back(logs[i][0]);\\n            }\\n            if(mx==logs[0][1]){\\n                id.push_back(logs[0][0]);\\n            }\\n        }\\n        if(id.size()==1){\\n            return id[0];\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<id.size(); i++){\\n            mn=min(mn, id[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int mx=INT_MIN;\\n        for(int i=0; i<logs.size()-1; i++){\\n            if(i==0){\\n                mx=max(mx, logs[i][1]);\\n            }\\n            mx=max(mx, (logs[i+1][1]-logs[i][1]));\\n        }\\n        vector<int> id;\\n        for(int i=1; i<logs.size(); i++){\\n            if(mx==(logs[i][1]-logs[i-1][1])){\\n                id.push_back(logs[i][0]);\\n            }\\n            if(mx==logs[0][1]){\\n                id.push_back(logs[0][0]);\\n            }\\n        }\\n        if(id.size()==1){\\n            return id[0];\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<id.size(); i++){\\n            mn=min(mn, id[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988550,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        d = {}\\n        logs = sorted(logs, key=lambda x: x[1])\\n\\n        d[0] = [logs[0][1], logs[0][0]]\\n\\n        for i in range(1,len(logs)):\\n            d[i] = [logs[i][1]-logs[i-1][1], logs[i][0]]\\n\\n        res = list(sorted(d.values(), key=lambda x:(x[0], -x[1])))\\n\\n        return res[-1][1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        d = {}\\n        logs = sorted(logs, key=lambda x: x[1])\\n\\n        d[0] = [logs[0][1], logs[0][0]]\\n\\n        for i in range(1,len(logs)):\\n            d[i] = [logs[i][1]-logs[i-1][1], logs[i][0]]\\n\\n        res = list(sorted(d.values(), key=lambda x:(x[0], -x[1])))\\n\\n        return res[-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975307,
                "title": "ez-to-understand-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n0(N)\\n\\n- Space complexity:\\n0(N)\\n\\n# Code\\n```\\nclass Solution {\\n    func hardestWorker(_ n: Int, _ logs: [[Int]]) -> Int {\\n        let n = logs.count\\n        var minimum = (Int.min, Int.min)\\n        var cur = 0\\n        for i in 0..<n {\\n           let time = logs[i][1] - cur\\n           cur = logs[i][1]\\n           if time == minimum.1 {\\n              if minimum.0 > logs[i][0] {\\n                  minimum.0 = logs[i][0]\\n              }\\n           }\\n           if time > minimum.1 {\\n               minimum.1 = time\\n                minimum.0 = logs[i][0]\\n           } \\n        }\\n        return minimum.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func hardestWorker(_ n: Int, _ logs: [[Int]]) -> Int {\\n        let n = logs.count\\n        var minimum = (Int.min, Int.min)\\n        var cur = 0\\n        for i in 0..<n {\\n           let time = logs[i][1] - cur\\n           cur = logs[i][1]\\n           if time == minimum.1 {\\n              if minimum.0 > logs[i][0] {\\n                  minimum.0 = logs[i][0]\\n              }\\n           }\\n           if time > minimum.1 {\\n               minimum.1 = time\\n                minimum.0 = logs[i][0]\\n           } \\n        }\\n        return minimum.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973173,
                "title": "python-beats-100-beginner-friendly-w-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/4cfa6517-9139-4e4c-adcd-d671720458c5_1693247042.3920164.png)\\n\\n# Approach\\nLoop through logs and subtract the current time by the previous time. Compare the new time to the max time. Return the max time at the end.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def hardestWorker(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        maxn = (logs[0][1], logs[0][0])\\n        # Initialize maxn which has the time and the id of task 1\\n        for i, (num1, num2) in enumerate(logs[0:]):\\n        # Loop through logs starting from index 1\\n            if num2 - logs[i-1][1] > maxn[0] or num2 - logs[i-1][1] == maxn[0] and maxn[1] > num1:\\n                # Check to see if the new time is better than the max time\\n                maxn = (num2 - logs[i-1][1], num1)\\n                # Change maxn accordingly\\n        return maxn[1]\\n        # Return the Id who worked for the longest time\\n```\\n**If this helped please upvote!!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def hardestWorker(self, n, logs):\\n        \"\"\"\\n        :type n: int\\n        :type logs: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        maxn = (logs[0][1], logs[0][0])\\n        # Initialize maxn which has the time and the id of task 1\\n        for i, (num1, num2) in enumerate(logs[0:]):\\n        # Loop through logs starting from index 1\\n            if num2 - logs[i-1][1] > maxn[0] or num2 - logs[i-1][1] == maxn[0] and maxn[1] > num1:\\n                # Check to see if the new time is better than the max time\\n                maxn = (num2 - logs[i-1][1], num1)\\n                # Change maxn accordingly\\n        return maxn[1]\\n        # Return the Id who worked for the longest time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965421,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n       \\n        int nn=logs.size();\\n        int current_time=logs[0][1];\\n        map<int,int>mp;\\n        mp[logs[0][0]]=logs[0][1];\\n        for(int i=1;i<nn;i++){\\n            if(logs[i][1]-logs[i-1][1]>=current_time){\\n                current_time=logs[i][1]-logs[i-1][1];\\n                mp[logs[i][0]]=(logs[i][1]-logs[i-1][1]);\\n            }\\n        }\\n\\n        int ans=INT_MAX;\\n        int curr_time=mp.begin()->second;\\n        for(auto it : mp){\\n            if(it.second==curr_time){\\n                ans=min(ans,it.first);\\n                curr_time=it.second;\\n            }\\n            else if(it.second>curr_time){\\n                ans=max(ans,it.first);\\n                curr_time=it.second;\\n            }\\n        }\\n        for(auto it : mp){\\n            cout<<it.first<<\"  \"<<it.second<<endl;\\n        }\\n        \\n        if(ans==INT_MAX) return 0;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n       \\n        int nn=logs.size();\\n        int current_time=logs[0][1];\\n        map<int,int>mp;\\n        mp[logs[0][0]]=logs[0][1];\\n        for(int i=1;i<nn;i++){\\n            if(logs[i][1]-logs[i-1][1]>=current_time){\\n                current_time=logs[i][1]-logs[i-1][1];\\n                mp[logs[i][0]]=(logs[i][1]-logs[i-1][1]);\\n            }\\n        }\\n\\n        int ans=INT_MAX;\\n        int curr_time=mp.begin()->second;\\n        for(auto it : mp){\\n            if(it.second==curr_time){\\n                ans=min(ans,it.first);\\n                curr_time=it.second;\\n            }\\n            else if(it.second>curr_time){\\n                ans=max(ans,it.first);\\n                curr_time=it.second;\\n            }\\n        }\\n        for(auto it : mp){\\n            cout<<it.first<<\"  \"<<it.second<<endl;\\n        }\\n        \\n        if(ans==INT_MAX) return 0;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3963915,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int ans=logs[0][0],max=logs[0][1];\\n        for(int i=1;i<logs.length;i++){\\n            if(logs[i][1]-logs[i-1][1]>max){\\n                max=logs[i][1]-logs[i-1][1];\\n                ans=logs[i][0];\\n            } else if(logs[i][1]-logs[i-1][1]==max&&ans>logs[i][0])\\n                ans=logs[i][0];\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int ans=logs[0][0],max=logs[0][1];\\n        for(int i=1;i<logs.length;i++){\\n            if(logs[i][1]-logs[i-1][1]>max){\\n                max=logs[i][1]-logs[i-1][1];\\n                ans=logs[i][0];\\n            } else if(logs[i][1]-logs[i-1][1]==max&&ans>logs[i][0])\\n                ans=logs[i][0];\\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959313,
                "title": "golang-3ms",
                "content": "Use 2 parameters to store value of id and max length\\nreplace the max id and max len when logs[i-1][1] > max length\\n```\\nfunc hardestWorker(n int, logs [][]int) int {\\n    maxId := logs[0][0]\\n    maxL := logs[0][1]\\n    for i:=1;i<len(logs);i++ {\\n        tmp := logs[i][1] - logs[i-1][1]\\n        if tmp > maxL {\\n            maxL = tmp\\n            maxId = logs[i][0]\\n        } else if tmp == maxL && logs[i][0] < maxId {\\n            maxId = logs[i][0]\\n        }\\n    }\\n    return maxId\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc hardestWorker(n int, logs [][]int) int {\\n    maxId := logs[0][0]\\n    maxL := logs[0][1]\\n    for i:=1;i<len(logs);i++ {\\n        tmp := logs[i][1] - logs[i-1][1]\\n        if tmp > maxL {\\n            maxL = tmp\\n            maxId = logs[i][0]\\n        } else if tmp == maxL && logs[i][0] < maxId {\\n            maxId = logs[i][0]\\n        }\\n    }\\n    return maxId\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913463,
                "title": "simple-cpp-solution-brute-force-approach-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsimply keep a track on time ans store the id as the ans if the time is max .\\nspecial case - when ans results to conflict then store the min id and hence a another if statement is also added here to keep a track of it.\\n\\n\\n\\nhope it helps .... :) !!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int maxi = logs[0][1];\\n        int id =logs[0][0];\\n        int row = logs.size() ;\\n        for(int i = 1 ; i<row;i++){\\n            if((logs[i][1]-logs[i-1][1])>maxi){\\n                maxi =logs[i][1]-logs[i-1][1] ;\\n                id=logs[i][0] ;\\n            }\\n            if((logs[i][1]-logs[i-1][1])==maxi){\\n                id = min(id,logs[i][0]);\\n            }\\n        }\\n        return id ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int maxi = logs[0][1];\\n        int id =logs[0][0];\\n        int row = logs.size() ;\\n        for(int i = 1 ; i<row;i++){\\n            if((logs[i][1]-logs[i-1][1])>maxi){\\n                maxi =logs[i][1]-logs[i-1][1] ;\\n                id=logs[i][0] ;\\n            }\\n            if((logs[i][1]-logs[i-1][1])==maxi){\\n                id = min(id,logs[i][0]);\\n            }\\n        }\\n        return id ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879308,
                "title": "java-1ms-beats-100-00",
                "content": "\\n\\n# Code\\n```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n\\n        int maxDuration = 0;\\n        int employeeID = -1; // what we\\'ll return\\n        int prevTimestamp = 0;\\n\\n        for (int[] logline : logs) {\\n            int curDuration = logline[1] - prevTimestamp;\\n            \\n            if (curDuration > maxDuration) {\\n                maxDuration = curDuration;\\n                employeeID = logline[0];\\n            } else if (curDuration == maxDuration) {\\n                if (logline[0] < employeeID) {\\n                    maxDuration = curDuration;\\n                    employeeID = logline[0];\\n                }\\n            }\\n\\n            prevTimestamp = logline[1];\\n        }\\n\\n        return employeeID;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 1ms Beats 100.00%\\n\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n\\n        int maxDuration = 0;\\n        int employeeID = -1; // what we\\'ll return\\n        int prevTimestamp = 0;\\n\\n        for (int[] logline : logs) {\\n            int curDuration = logline[1] - prevTimestamp;\\n            \\n            if (curDuration > maxDuration) {\\n                maxDuration = curDuration;\\n                employeeID = logline[0];\\n            } else if (curDuration == maxDuration) {\\n                if (logline[0] < employeeID) {\\n                    maxDuration = curDuration;\\n                    employeeID = logline[0];\\n                }\\n            }\\n\\n            prevTimestamp = logline[1];\\n        }\\n\\n        return employeeID;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849849,
                "title": "c-simple-and-easy-approach",
                "content": "# Intuition\\nWe have to return the id of the employee that worked the task with the longest time. If there is a tie between two or more employees, return the smallest id among them.\\n\\n# Approach\\nWe initialize max_time with value of logs[0][1] that is the time of the Task 0, and we initialize emp_id with value of logs[0][0] that is the id of employee working on Task 0, we run our loop from task 1 till last task, where we check whether that task duration is greater than max_time if that is the case we set max_time to the duration of that task and emp_id to the id of employee working on that task otherwise we check whether that taks duration is equal to max_time in case which we check if id of that employee is smaller than emp_id if so we set emp_id to the value of id of that employee, after the loop is completed we finally return emp_id.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int max_time = logs[0][1];\\n        int emp_id = logs[0][0];\\n        for(int i=1; i<logs.size(); i++)\\n        {\\n            if((logs[i][1]-logs[i-1][1])>max_time)\\n            {\\n                max_time = logs[i][1]-logs[i-1][1];\\n                emp_id = logs[i][0];\\n            }\\n            else if((logs[i][1]-logs[i-1][1])==max_time)\\n            {\\n                if(logs[i][0]<emp_id)\\n                {\\n                    emp_id = logs[i][0];\\n                }\\n            }\\n        }\\n        return emp_id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int max_time = logs[0][1];\\n        int emp_id = logs[0][0];\\n        for(int i=1; i<logs.size(); i++)\\n        {\\n            if((logs[i][1]-logs[i-1][1])>max_time)\\n            {\\n                max_time = logs[i][1]-logs[i-1][1];\\n                emp_id = logs[i][0];\\n            }\\n            else if((logs[i][1]-logs[i-1][1])==max_time)\\n            {\\n                if(logs[i][0]<emp_id)\\n                {\\n                    emp_id = logs[i][0];\\n                }\\n            }\\n        }\\n        return emp_id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843910,
                "title": "python-simple-logic",
                "content": "# Intuition\\nThink of maximum in list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReturn the maximum id employee of the unit time.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        L = [[logs[0][1], logs[0][0]]]\\n        for i in range(1, len(logs)):\\n            L.append([logs[i][1] - logs[i - 1][1], logs[i][0]])\\n        m = max(L)[0]\\n        l = []\\n        for j in L:\\n            if m == j[0]:\\n                l.append(j[1])\\n        return min(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        L = [[logs[0][1], logs[0][0]]]\\n        for i in range(1, len(logs)):\\n            L.append([logs[i][1] - logs[i - 1][1], logs[i][0]])\\n        m = max(L)[0]\\n        l = []\\n        for j in L:\\n            if m == j[0]:\\n                l.append(j[1])\\n        return min(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842397,
                "title": "java-linear-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int len = logs.length;\\n        int lastFinishTime = 0;\\n\\n        int maxDuration = 0;\\n        int id = n;\\n\\n        for(int i = 0; i < len; i++){\\n\\n            int currID = logs[i][0];\\n            int leaveTime = logs[i][1];\\n            int currDuration = leaveTime - lastFinishTime;\\n\\n            if(currDuration > maxDuration) {\\n                maxDuration = currDuration;\\n                id = currID;\\n            } else if(currDuration == maxDuration){\\n                id = Math.min(id, currID);\\n            }\\n\\n            lastFinishTime = leaveTime;\\n        }\\n\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int len = logs.length;\\n        int lastFinishTime = 0;\\n\\n        int maxDuration = 0;\\n        int id = n;\\n\\n        for(int i = 0; i < len; i++){\\n\\n            int currID = logs[i][0];\\n            int leaveTime = logs[i][1];\\n            int currDuration = leaveTime - lastFinishTime;\\n\\n            if(currDuration > maxDuration) {\\n                maxDuration = currDuration;\\n                id = currID;\\n            } else if(currDuration == maxDuration){\\n                id = Math.min(id, currID);\\n            }\\n\\n            lastFinishTime = leaveTime;\\n        }\\n\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832251,
                "title": "hash-table-and-for-loop",
                "content": "# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        times = {logs[0][0]: logs[0][1]}\\n        max_time = times[logs[0][0]]\\n        \\n        for i in range(1, len(logs)):\\n            times[logs[i][0]] = max(times.get(logs[i][0], 0), logs[i][1] - logs[i - 1][1])\\n            max_time = max(max_time, times[logs[i][0]])\\n        \\n        return min((key for key, value in times.items() if value == max_time))\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        times = {logs[0][0]: logs[0][1]}\\n        max_time = times[logs[0][0]]\\n        \\n        for i in range(1, len(logs)):\\n            times[logs[i][0]] = max(times.get(logs[i][0], 0), logs[i][1] - logs[i - 1][1])\\n            max_time = max(max_time, times[logs[i][0]])\\n        \\n        return min((key for key, value in times.items() if value == max_time))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829735,
                "title": "simple-o-n-java-traverse-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int res = logs[0][0];\\n        int currMax = logs[0][1];\\n        for (int i = 1; i < logs.length; i++) {\\n            //(Either strictly bigger than the previous max value) OR (there is a tie, return the smallest)\\n            if (logs[i][1] - logs[i - 1][1] > currMax || (logs[i][1] - logs[i - 1][1] == currMax && logs[i][0] < res)) {\\n                res = logs[i][0];\\n                currMax = logs[i][1] - logs[i - 1][1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int res = logs[0][0];\\n        int currMax = logs[0][1];\\n        for (int i = 1; i < logs.length; i++) {\\n            //(Either strictly bigger than the previous max value) OR (there is a tie, return the smallest)\\n            if (logs[i][1] - logs[i - 1][1] > currMax || (logs[i][1] - logs[i - 1][1] == currMax && logs[i][0] < res)) {\\n                res = logs[i][0];\\n                currMax = logs[i][1] - logs[i - 1][1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809430,
                "title": "simple-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int id=logs[0][0];\\n        int maxi=logs[0][1]-0;\\n\\n        for(int i=1;i<logs.size();i++){\\n            if(logs[i][1]-logs[i-1][1]>maxi){\\n                id=logs[i][0];\\n                maxi=logs[i][1]-logs[i-1][1];\\n                cout<<maxi<<\" \";\\n            }\\n            else if(logs[i][1]-logs[i-1][1]==maxi&& logs[i][0]<id){\\n                id=logs[i][0];\\n                \\n            }\\n        }\\n        return id;\\n    }\\n};\\n```\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/8ef230b7-00c9-433e-ae0a-cad67a74a941_1690196887.2294846.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int id=logs[0][0];\\n        int maxi=logs[0][1]-0;\\n\\n        for(int i=1;i<logs.size();i++){\\n            if(logs[i][1]-logs[i-1][1]>maxi){\\n                id=logs[i][0];\\n                maxi=logs[i][1]-logs[i-1][1];\\n                cout<<maxi<<\" \";\\n            }\\n            else if(logs[i][1]-logs[i-1][1]==maxi&& logs[i][0]<id){\\n                id=logs[i][0];\\n                \\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3799671,
                "title": "brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs)\\n     {\\n           int j=1;\\n           int i,index;\\n           int a[]=new int[logs.length];\\n           int start;\\n           int end;\\n           a[0]=logs[0][1];\\n           \\n\\n           for(i=0;i<logs.length-1;i++)\\n           {\\n             start=logs[i][j];\\n             end=logs[i+1][j];\\n             a[i+1]=end-start;\\n           } \\n           int max=a[0]  ;\\n            int id=logs[0][0];\\n            index=0;\\n            \\n           for(i=0;i<logs.length;i++)\\n           {\\n               \\n               if(a[i]>max)\\n               {\\n                   max=a[i];\\n                   \\n               id=logs[i][0];\\n              index=i;\\n                   \\n                   \\n               }\\n           }\\n              \\n                    \\n           for(int k=index+1;k<a.length;k++)\\n           {\\n               if(max==a[k])\\n               {\\n                   \\n                 if(logs[k][0]<id)\\n                 {\\n                     id=logs[k][0];\\n\\n                 }\\n             } \\n           }\\n           return id;\\n           \\n          \\n\\n           \\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs)\\n     {\\n           int j=1;\\n           int i,index;\\n           int a[]=new int[logs.length];\\n           int start;\\n           int end;\\n           a[0]=logs[0][1];\\n           \\n\\n           for(i=0;i<logs.length-1;i++)\\n           {\\n             start=logs[i][j];\\n             end=logs[i+1][j];\\n             a[i+1]=end-start;\\n           } \\n           int max=a[0]  ;\\n            int id=logs[0][0];\\n            index=0;\\n            \\n           for(i=0;i<logs.length;i++)\\n           {\\n               \\n               if(a[i]>max)\\n               {\\n                   max=a[i];\\n                   \\n               id=logs[i][0];\\n              index=i;\\n                   \\n                   \\n               }\\n           }\\n              \\n                    \\n           for(int k=index+1;k<a.length;k++)\\n           {\\n               if(max==a[k])\\n               {\\n                   \\n                 if(logs[k][0]<id)\\n                 {\\n                     id=logs[k][0];\\n\\n                 }\\n             } \\n           }\\n           return id;\\n           \\n          \\n\\n           \\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798980,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n , vector<vector<int>>&l){\\n        vector<int>v,w;\\n        v.push_back(l[0][1]);\\n        for(int i=1; i<l.size(); i++){\\n            v.push_back(l[i][1]-l[i-1][1]);\\n        }\\n        int mx=INT_MIN;\\n        for(auto i:v){\\n            if(i>mx){\\n                mx=i;\\n            }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]==mx){\\n                w.push_back(l[i][0]);\\n            }\\n        }\\n        sort(w.begin(),w.end());\\n        return w[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n , vector<vector<int>>&l){\\n        vector<int>v,w;\\n        v.push_back(l[0][1]);\\n        for(int i=1; i<l.size(); i++){\\n            v.push_back(l[i][1]-l[i-1][1]);\\n        }\\n        int mx=INT_MIN;\\n        for(auto i:v){\\n            if(i>mx){\\n                mx=i;\\n            }\\n        }\\n        for(int i=0; i<v.size(); i++){\\n            if(v[i]==mx){\\n                w.push_back(l[i][0]);\\n            }\\n        }\\n        sort(w.begin(),w.end());\\n        return w[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769661,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun hardestWorker(n: Int, logs: Array<IntArray>): Int {\\n        var bestWorkerId = logs[0][0]\\n        var maxTime = logs[0][1]\\n\\n        var i = 1\\n\\n        while (i < logs.size) {\\n            val currentTime = logs[i][1] - logs[i-1][1]\\n            val currentWorkerId = logs[i][0]\\n\\n            if (maxTime <= currentTime) {\\n                bestWorkerId = if (maxTime < currentTime) currentWorkerId\\n                                else Math.min(bestWorkerId, currentWorkerId)\\n                maxTime = currentTime\\n            }\\n\\n            i++\\n        }\\n\\n        return bestWorkerId\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun hardestWorker(n: Int, logs: Array<IntArray>): Int {\\n        var bestWorkerId = logs[0][0]\\n        var maxTime = logs[0][1]\\n\\n        var i = 1\\n\\n        while (i < logs.size) {\\n            val currentTime = logs[i][1] - logs[i-1][1]\\n            val currentWorkerId = logs[i][0]\\n\\n            if (maxTime <= currentTime) {\\n                bestWorkerId = if (maxTime < currentTime) currentWorkerId\\n                                else Math.min(bestWorkerId, currentWorkerId)\\n                maxTime = currentTime\\n            }\\n\\n            i++\\n        }\\n\\n        return bestWorkerId\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763176,
                "title": "beats-90-in-runtime-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        maxs = 0\\n        maxid = 0\\n        start = 0\\n        for i in logs:\\n            work = i[-1] - start\\n            logid=i[0]\\n            if work > maxs:\\n                maxs = work\\n                maxid = i[0]\\n            if work >= maxs and logid<maxid:\\n                 maxs = work\\n                 maxid = i[0]\\n            start = i[-1]  # Update start with the end time of the current log\\n        return maxid\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        maxs = 0\\n        maxid = 0\\n        start = 0\\n        for i in logs:\\n            work = i[-1] - start\\n            logid=i[0]\\n            if work > maxs:\\n                maxs = work\\n                maxid = i[0]\\n            if work >= maxs and logid<maxid:\\n                 maxs = work\\n                 maxid = i[0]\\n            start = i[-1]  # Update start with the end time of the current log\\n        return maxid\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760390,
                "title": "java-loop-traverse-efficient-time-100-compact",
                "content": "# Approach\\nsimple traverse of array and get id of longest work done by employee, but if same work happens again then compare the previous id with current id and keep minimum id as answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int prev = 0, max = 0, id = 0;\\n        for(int i=0; i<logs.length; i++){\\n            if(logs[i][1]-prev > max) {\\n                max = logs[i][1]-prev;\\n                id = logs[i][0];\\n            } else if(logs[i][1]-prev == max){\\n                if(logs[i][0] < id) id = logs[i][0];\\n            }\\n            prev = logs[i][1];\\n        }\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int prev = 0, max = 0, id = 0;\\n        for(int i=0; i<logs.length; i++){\\n            if(logs[i][1]-prev > max) {\\n                max = logs[i][1]-prev;\\n                id = logs[i][0];\\n            } else if(logs[i][1]-prev == max){\\n                if(logs[i][0] < id) id = logs[i][0];\\n            }\\n            prev = logs[i][1];\\n        }\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729600,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    if (logs.length == 0) return 0;\\n    let result = logs[0][0];\\n    let maxTime = logs[0][1] - 0;\\n\\n    for (let i = 1; i < logs.length; i++) {\\n      let time = logs[i][1] - logs[i - 1][1];  \\n      if (maxTime == time) {\\n         result = result < logs[i][0] ? result : logs[i][0];\\n      } else if (maxTime < time) {\\n         maxTime = logs[i][1] - logs[i - 1][1];\\n         result = logs[i][0];\\n      }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    if (logs.length == 0) return 0;\\n    let result = logs[0][0];\\n    let maxTime = logs[0][1] - 0;\\n\\n    for (let i = 1; i < logs.length; i++) {\\n      let time = logs[i][1] - logs[i - 1][1];  \\n      if (maxTime == time) {\\n         result = result < logs[i][0] ? result : logs[i][0];\\n      } else if (maxTime < time) {\\n         maxTime = logs[i][1] - logs[i - 1][1];\\n         result = logs[i][0];\\n      }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716054,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1];\\n        int id = logs[0][0];\\n        for(int i = 1; i < logs.length; i++) {\\n            int diff = logs[i][1] - logs[i-1][1];\\n            if(max == diff) {\\n                id = id < logs[i][0] ? id : logs[i][0];\\n            } else if(diff > max) {\\n                max = diff;\\n                id = logs[i][0];\\n            } \\n        }\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1];\\n        int id = logs[0][0];\\n        for(int i = 1; i < logs.length; i++) {\\n            int diff = logs[i][1] - logs[i-1][1];\\n            if(max == diff) {\\n                id = id < logs[i][0] ? id : logs[i][0];\\n            } else if(diff > max) {\\n                max = diff;\\n                id = logs[i][0];\\n            } \\n        }\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713986,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int ans = -1;\\n        int maxi = -1e9;\\n        int prevTime = 0;\\n        for (int i=0 ; i<logs.size() ; i++){\\n            int id = logs[i][0];\\n            int leaveTime = logs[i][1];\\n            int duration = leaveTime - prevTime;\\n            prevTime = leaveTime;\\n            if (maxi < duration){\\n                maxi = duration;\\n                ans = id;\\n            }\\n            else if (maxi == duration){\\n                ans = min(ans , id);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int ans = -1;\\n        int maxi = -1e9;\\n        int prevTime = 0;\\n        for (int i=0 ; i<logs.size() ; i++){\\n            int id = logs[i][0];\\n            int leaveTime = logs[i][1];\\n            int duration = leaveTime - prevTime;\\n            prevTime = leaveTime;\\n            if (maxi < duration){\\n                maxi = duration;\\n                ans = id;\\n            }\\n            else if (maxi == duration){\\n                ans = min(ans , id);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703776,
                "title": "very-easy-to-understand-simple-code-in-c-o-n",
                "content": "# Intuition\\nSimply, We need to find the employee who worked for more time i.e, ( working time = leave time-entry time) where entry time is nothing but the leaving time of the previous employee as mentioned in the question.\\n\\n# Approach\\nAs mentioned in the question, the entry time of first employee is 0 units. So the working of the first(i=0) employee will be nothing but his leaving time i.e, logs[0][1]-0. The working time of ith employee will be logs[i][1]-logs[i-1][1] where i runs from 1 to k-1 where k is the size of the vector. In this way we need to find for all other employees. I initialized the maxTime with logs[0][1]. If we find any other employee who worked for more time than this then we will update the maxTime and ID. If the working time of 2 employees are same then we will retuen the minimum ID among them.\\n# Complexity\\n- Time complexity:\\n O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n\\n        int MaxTime=logs[0][1];\\n        int ID=INT_MAX;\\n\\n        for(int i=1;i<logs.size();i++){\\n\\n          int diff=logs[i][1]-logs[i-1][1];\\n          if(diff>MaxTime){\\n            MaxTime=diff;\\n            ID=logs[i][0];\\n          }\\n\\n          if(diff==MaxTime){\\n            ID=min(ans,logs[i][0]);\\n          }\\n\\n          if(logs[0][1]>=MaxTime)\\n           ID=min(logs[0][0],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n\\n        int MaxTime=logs[0][1];\\n        int ID=INT_MAX;\\n\\n        for(int i=1;i<logs.size();i++){\\n\\n          int diff=logs[i][1]-logs[i-1][1];\\n          if(diff>MaxTime){\\n            MaxTime=diff;\\n            ID=logs[i][0];\\n          }\\n\\n          if(diff==MaxTime){\\n            ID=min(ans,logs[i][0]);\\n          }\\n\\n          if(logs[0][1]>=MaxTime)\\n           ID=min(logs[0][0],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702392,
                "title": "beginner-understandable-java-code-easy-peasy",
                "content": "# Read & Understand the Code \\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int maxtime = -1;int timetaken = 0;int id =logs[0][0];\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(i==0) maxtime = Math.max(maxtime,logs[i][1]);\\n            else \\n            {\\n                timetaken = logs[i][1] - logs[i-1][1];\\n                if(timetaken > maxtime) \\n                  {maxtime = Math.max(maxtime,timetaken);id = logs[i][0];}\\n                else if(timetaken == maxtime) \\n                {\\n                    id = Math.min(logs[i][0],id);\\n                }\\n            }\\n        }\\n        return id;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int maxtime = -1;int timetaken = 0;int id =logs[0][0];\\n        for(int i=0;i<logs.length;i++)\\n        {\\n            if(i==0) maxtime = Math.max(maxtime,logs[i][1]);\\n            else \\n            {\\n                timetaken = logs[i][1] - logs[i-1][1];\\n                if(timetaken > maxtime) \\n                  {maxtime = Math.max(maxtime,timetaken);id = logs[i][0];}\\n                else if(timetaken == maxtime) \\n                {\\n                    id = Math.min(logs[i][0],id);\\n                }\\n            }\\n        }\\n        return id;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679389,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int time = logs[0][1], mn = logs[0][0];\\n        for(int i=1; i<logs.size(); i++)\\n        {\\n            int val = logs[i][1] - logs[i-1][1];\\n            if(time < val){\\n                time = val;\\n                mn = logs[i][0];\\n            }\\n            else if(time==val){\\n                mn = min(mn, logs[i][0]);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int time = logs[0][1], mn = logs[0][0];\\n        for(int i=1; i<logs.size(); i++)\\n        {\\n            int val = logs[i][1] - logs[i-1][1];\\n            if(time < val){\\n                time = val;\\n                mn = logs[i][0];\\n            }\\n            else if(time==val){\\n                mn = min(mn, logs[i][0]);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642346,
                "title": "java-very-easy-solution-iterative-approach-o-n-time-o-1-space",
                "content": "# Approach\\n    assume first employee as the longest task worker.\\n    iterate over logs, check if current log is greater than or equal to max,\\n        - if greater than max, set max and id as current id\\n        - if current log is equal to max, assing id as min Id. \\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1];\\n        int id = logs[0][0];\\n        for(int i = 1; i< logs.length; i++) {\\n            int log = logs[i][1] - logs[i - 1][1];\\n            if(log > max){\\n                max = log;\\n                id = logs[i][0];\\n            }\\n            if(log == max) {\\n                id = Math.min(id, logs[i][0]);\\n            }\\n        }\\n\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1];\\n        int id = logs[0][0];\\n        for(int i = 1; i< logs.length; i++) {\\n            int log = logs[i][1] - logs[i - 1][1];\\n            if(log > max){\\n                max = log;\\n                id = logs[i][0];\\n            }\\n            if(log == max) {\\n                id = Math.min(id, logs[i][0]);\\n            }\\n        }\\n\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606399,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int HardestWorker(int n, int[][] logs) {\\n        int id = 0, longestTime = 0;\\n        for(int i = 0; i < logs.Length; i++) {\\n            int time = i > 0 ? logs[i][1] - logs[i - 1][1] : logs[i][1];\\n            if(time > longestTime) {\\n                longestTime = time;\\n                id = logs[i][0]; \\n            } else if(time == longestTime && id > logs[i][0]){\\n                id = logs[i][0];\\n            }\\n        }    \\n\\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int HardestWorker(int n, int[][] logs) {\\n        int id = 0, longestTime = 0;\\n        for(int i = 0; i < logs.Length; i++) {\\n            int time = i > 0 ? logs[i][1] - logs[i - 1][1] : logs[i][1];\\n            if(time > longestTime) {\\n                longestTime = time;\\n                id = logs[i][0]; \\n            } else if(time == longestTime && id > logs[i][0]){\\n                id = logs[i][0];\\n            }\\n        }    \\n\\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576935,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        auto result = logs[0][0], max = logs[0][1];\\n        for (auto i = 1; i < logs.size(); ++i)\\n            if (logs[i][1] - logs[i - 1][1] > max) {\\n                max = logs[i][1] - logs[i - 1][1];\\n                result = logs[i][0];\\n            } else if (logs[i][1] - logs[i - 1][1] == max) {\\n                result = min(result, logs[i][0]);\\n            }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        auto result = logs[0][0], max = logs[0][1];\\n        for (auto i = 1; i < logs.size(); ++i)\\n            if (logs[i][1] - logs[i - 1][1] > max) {\\n                max = logs[i][1] - logs[i - 1][1];\\n                result = logs[i][0];\\n            } else if (logs[i][1] - logs[i - 1][1] == max) {\\n                result = min(result, logs[i][0]);\\n            }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558985,
                "title": "simple-c-solution-using-hashmap",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        map<int,int> m;\\n        int e,maxi=INT_MIN;\\n        m[logs[0][0]]=logs[0][1];\\n        for(int i=1;i<logs.size();i++)\\n        m[logs[i][0]]=max(m[logs[i][0]],logs[i][1]-logs[i-1][1]);\\n        map<int,int>::iterator ir=m.begin();\\n        for(;ir!=m.end();ir++)\\n        {\\n            if(ir->second>maxi)\\n            {\\n                maxi=ir->second;\\n                e=ir->first;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        map<int,int> m;\\n        int e,maxi=INT_MIN;\\n        m[logs[0][0]]=logs[0][1];\\n        for(int i=1;i<logs.size();i++)\\n        m[logs[i][0]]=max(m[logs[i][0]],logs[i][1]-logs[i-1][1]);\\n        map<int,int>::iterator ir=m.begin();\\n        for(;ir!=m.end();ir++)\\n        {\\n            if(ir->second>maxi)\\n            {\\n                maxi=ir->second;\\n                e=ir->first;\\n            }\\n        }\\n        return e;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555028,
                "title": "python-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        maxWork=logs[0][1]\\n        EmpId=logs[0][0]\\n        for i in range(len(logs)-1):\\n            work=logs[i+1][1]-logs[i][1]         \\n            if work>maxWork:\\n                maxWork=work\\n                EmpId=logs[i+1][0]\\n            if work==maxWork:\\n                EmpId=min(EmpId,logs[i+1][0])\\n        return EmpId\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        maxWork=logs[0][1]\\n        EmpId=logs[0][0]\\n        for i in range(len(logs)-1):\\n            work=logs[i+1][1]-logs[i][1]         \\n            if work>maxWork:\\n                maxWork=work\\n                EmpId=logs[i+1][0]\\n            if work==maxWork:\\n                EmpId=min(EmpId,logs[i+1][0])\\n        return EmpId\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541935,
                "title": "java-unique-solution-min-heap-priority-queue",
                "content": "**Min Heap Priority Queue.**\\n\\nThe idea is only keep track of elements that exceed the maximum working time and we use a Min Heap priority queue to assign highest priority to the smallest id and dequeue it at the end.\\n\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        q.add(logs[0][0]);\\n        for (int i = 1; i < logs.length; i++) {\\n                if (logs[i][1] - logs[i - 1][1] > max) {\\n                    q.clear();\\n                    q.add(logs[i][0]);\\n                    max = logs[i][1] - logs[i - 1][1];\\n                } else if (logs[i][1] - logs[i - 1][1] == max) {\\n                    q.add(logs[i][0]);\\n                    max = logs[i][1] - logs[i - 1][1];\\n                }\\n        }\\n        return q.poll();\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1];\\n        Queue<Integer> q = new PriorityQueue<>();\\n        q.add(logs[0][0]);\\n        for (int i = 1; i < logs.length; i++) {\\n                if (logs[i][1] - logs[i - 1][1] > max) {\\n                    q.clear();\\n                    q.add(logs[i][0]);\\n                    max = logs[i][1] - logs[i - 1][1];\\n                } else if (logs[i][1] - logs[i - 1][1] == max) {\\n                    q.add(logs[i][0]);\\n                    max = logs[i][1] - logs[i - 1][1];\\n                }\\n        }\\n        return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517984,
                "title": "linear-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:    `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n      int ans, oldHours = 0,currHours = 0, start = 0;\\n      for(int i = 0; i < logs.size(); i++){\\n        currHours = logs[i][1] - start;\\n        if(oldHours <= currHours){\\n            if(oldHours == currHours){\\n                ans = min(ans, logs[i][0]);\\n            }else{\\n                ans = logs[i][0];\\n            }\\n            oldHours = currHours;\\n        }\\n        start = logs[i][1];\\n      }\\n\\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n      int ans, oldHours = 0,currHours = 0, start = 0;\\n      for(int i = 0; i < logs.size(); i++){\\n        currHours = logs[i][1] - start;\\n        if(oldHours <= currHours){\\n            if(oldHours == currHours){\\n                ans = min(ans, logs[i][0]);\\n            }else{\\n                ans = logs[i][0];\\n            }\\n            oldHours = currHours;\\n        }\\n        start = logs[i][1];\\n      }\\n\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513694,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1], id = logs[0][0];\\n        for(int i = 1; i < logs.length; i++){\\n            int time = logs[i][1] - logs[i - 1][1];\\n            if(time > max){\\n                max = time;\\n                id = logs[i][0];\\n            }else if(time == max && id > logs[i][0]){\\n                max = time;\\n                id = logs[i][0];\\n            }\\n        }\\n        return id; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max = logs[0][1], id = logs[0][0];\\n        for(int i = 1; i < logs.length; i++){\\n            int time = logs[i][1] - logs[i - 1][1];\\n            if(time > max){\\n                max = time;\\n                id = logs[i][0];\\n            }else if(time == max && id > logs[i][0]){\\n                max = time;\\n                id = logs[i][0];\\n            }\\n        }\\n        return id; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497041,
                "title": "come-lets-check-simple-java-solution-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max=logs[0][1];\\n        int index=logs[0][0];\\n        for(int i=1;i<logs.length;i++)\\n        { if(logs[i][1]-logs[i-1][1]>max)\\n           {\\n               max=logs[i][1]-logs[i-1][1];\\n               index=logs[i][0];\\n           }\\n           if(logs[i][1]-logs[i-1][1]==max)\\n           {\\n               if(logs[i][0]<index)\\n                index=logs[i][0];\\n           }\\n        }\\n          return index;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max=logs[0][1];\\n        int index=logs[0][0];\\n        for(int i=1;i<logs.length;i++)\\n        { if(logs[i][1]-logs[i-1][1]>max)\\n           {\\n               max=logs[i][1]-logs[i-1][1];\\n               index=logs[i][0];\\n           }\\n           if(logs[i][1]-logs[i-1][1]==max)\\n           {\\n               if(logs[i][0]<index)\\n                index=logs[i][0];\\n           }\\n        }\\n          return index;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496028,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university::ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) \\n    {\\n          \\n           int employeeid=logs[0][0];\\n      int endtime=logs[0][1];\\n\\n      if (logs.length>1) \\n      {\\n         for(int i=1;i<logs.length;i++) \\n         {\\n          \\n          if (logs[i][1]-logs[i-1][1]>endtime) \\n          {   \\n            //System.out.println(logs[i][1]);\\n             endtime= logs[i][1]-logs[i-1][1];\\n             employeeid=logs[i][0];\\n          }\\n          else if (logs[i][1]-logs[i-1][1]==endtime) \\n          {\\n           // System.out.println(\"equal \"+logs[i][1]);\\n              if (logs[i][0]<employeeid) \\n              {\\n                 employeeid=logs[i][0];\\n                 endtime=logs[i][1]-logs[i-1][1];\\n              }\\n          }\\n\\n         } \\n      }\\n\\n      //System.out.println(\"employeeid= \"+employeeid);\\n      //System.out.println(\"endtime= \"+endtime);\\n\\n  return employeeid;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) \\n    {\\n          \\n           int employeeid=logs[0][0];\\n      int endtime=logs[0][1];\\n\\n      if (logs.length>1) \\n      {\\n         for(int i=1;i<logs.length;i++) \\n         {\\n          \\n          if (logs[i][1]-logs[i-1][1]>endtime) \\n          {   \\n            //System.out.println(logs[i][1]);\\n             endtime= logs[i][1]-logs[i-1][1];\\n             employeeid=logs[i][0];\\n          }\\n          else if (logs[i][1]-logs[i-1][1]==endtime) \\n          {\\n           // System.out.println(\"equal \"+logs[i][1]);\\n              if (logs[i][0]<employeeid) \\n              {\\n                 employeeid=logs[i][0];\\n                 endtime=logs[i][1]-logs[i-1][1];\\n              }\\n          }\\n\\n         } \\n      }\\n\\n      //System.out.println(\"employeeid= \"+employeeid);\\n      //System.out.println(\"endtime= \"+endtime);\\n\\n  return employeeid;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489905,
                "title": "lc-2432-e-python3-a-plain-solution",
                "content": "Just write the process as requested.\\n\\n```Python3 []\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        res, max_time = logs[0][0], logs[0][1]\\n        for i in range(1, len(logs)):\\n            pres_id, pres_time = logs[i][0], logs[i][1] - logs[i-1][1]\\n            if pres_time >= max_time:\\n                res = pres_id if pres_time > max_time else min(res, pres_id)\\n                max_time = pres_time\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        res, max_time = logs[0][0], logs[0][1]\\n        for i in range(1, len(logs)):\\n            pres_id, pres_time = logs[i][0], logs[i][1] - logs[i-1][1]\\n            if pres_time >= max_time:\\n                res = pres_id if pres_time > max_time else min(res, pres_id)\\n                max_time = pres_time\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486214,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\ncomplexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int maxi=logs[0][1];\\n        int id=logs[0][0];\\n        for(int i=1;i<logs.size();i++){\\n            if(maxi<logs[i][1]-logs[i-1][1]){\\n                maxi=logs[i][1]-logs[i-1][1];\\n                \\n                id=logs[i][0];\\n            }else if(maxi==logs[i][1]-logs[i-1][1]){\\n                if(id>logs[i][0]){\\n                    id=logs[i][0];\\n                }\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int maxi=logs[0][1];\\n        int id=logs[0][0];\\n        for(int i=1;i<logs.size();i++){\\n            if(maxi<logs[i][1]-logs[i-1][1]){\\n                maxi=logs[i][1]-logs[i-1][1];\\n                \\n                id=logs[i][0];\\n            }else if(maxi==logs[i][1]-logs[i-1][1]){\\n                if(id>logs[i][0]){\\n                    id=logs[i][0];\\n                }\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475989,
                "title": "java-simple-solution-one-pass-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int hardestWorker(int n, int[][] logs) {\\n        int idOfEmployee = logs[0][0];\\n        int maxDifference = logs[0][1];\\n        for (int i = 1; i < logs.length; i++) {\\n            int currentDifference = logs[i][1] - logs[i - 1][1];\\n            if (maxDifference < currentDifference) {\\n                maxDifference = currentDifference;\\n                idOfEmployee = logs[i][0];\\n            } else if (maxDifference == currentDifference) {\\n                idOfEmployee = Math.min(idOfEmployee, logs[i][0]);\\n            }\\n        }\\n\\n        return idOfEmployee;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int hardestWorker(int n, int[][] logs) {\\n        int idOfEmployee = logs[0][0];\\n        int maxDifference = logs[0][1];\\n        for (int i = 1; i < logs.length; i++) {\\n            int currentDifference = logs[i][1] - logs[i - 1][1];\\n            if (maxDifference < currentDifference) {\\n                maxDifference = currentDifference;\\n                idOfEmployee = logs[i][0];\\n            } else if (maxDifference == currentDifference) {\\n                idOfEmployee = Math.min(idOfEmployee, logs[i][0]);\\n            }\\n        }\\n\\n        return idOfEmployee;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465884,
                "title": "2432-the-employee-that-worked-on-the-longest-task",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n//variabels\\nint lon=0,temp=0,id=0,loc=0;\\n\\n//loop for check elements in matrix\\nfor(int i=0;i<logsSize;i++){\\n  if(i!=0)\\n    lon=logs[i][1]-logs[i-1][1]; //calculate leave time without 0task\\n  else\\n    lon=logs[i][1]-lon; //calculate task 0\\n    \\n    if(lon>temp||i==0){ //check the greatest unit\\n        temp=lon;\\n        id=logs[i][0];\\n        loc=i;\\n    }\\n    else if(lon==temp){ //if units equal check the less id\\n        if(logs[loc][0]<logs[i][0]){\\n            id=logs[loc][0];\\n            //loc=i;\\n        }\\n        else{\\n            id=logs[i][0];\\n            loc=i;\\n        }\\n    }\\n}\\nreturn id; //return the output\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nint hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n//variabels\\nint lon=0,temp=0,id=0,loc=0;\\n\\n//loop for check elements in matrix\\nfor(int i=0;i<logsSize;i++){\\n  if(i!=0)\\n    lon=logs[i][1]-logs[i-1][1]; //calculate leave time without 0task\\n  else\\n    lon=logs[i][1]-lon; //calculate task 0\\n    \\n    if(lon>temp||i==0){ //check the greatest unit\\n        temp=lon;\\n        id=logs[i][0];\\n        loc=i;\\n    }\\n    else if(lon==temp){ //if units equal check the less id\\n        if(logs[loc][0]<logs[i][0]){\\n            id=logs[loc][0];\\n            //loc=i;\\n        }\\n        else{\\n            id=logs[i][0];\\n            loc=i;\\n        }\\n    }\\n}\\nreturn id; //return the output\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455707,
                "title": "straightforward-python-solution",
                "content": "1. We first change the format of the log from `[id, leaveTime]` to `[id, leaveTime, projectTime]`. \\n2. The `projectTime` of the first task is equal to its `leaveTime`, and the `projectTime` of subsequent tasks is equal to its `leaveTime` minus the `leaveTime` of the previous task.\\n3. We sort the logs according to the `projectTime` from large to small, and then return the `id` of the first task.\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        logs[0].append(logs[0][1])\\n        for i in range(1, len(logs)):\\n            logs[i].append(logs[i][1] - logs[i-1][1])\\n        return sorted(logs, key=lambda x: (-x[2], x[0]))[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        logs[0].append(logs[0][1])\\n        for i in range(1, len(logs)):\\n            logs[i].append(logs[i][1] - logs[i-1][1])\\n        return sorted(logs, key=lambda x: (-x[2], x[0]))[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454253,
                "title": "c-c-c-easy-to-understand",
                "content": "```CS []\\npublic int HardestWorker(int n, int[][] logs) \\n{\\n    int smallestId = logs[0][0];\\n    int longestTime = logs[0][1];\\n\\n    for(int i = 1; i < logs.Length; ++i)\\n    {\\n        int id = logs[i][0];\\n        int time = logs[i][1] - logs[i - 1][1];\\n        if(time > longestTime) \\n        {\\n            longestTime = time;\\n            smallestId = id;\\n        } \\n        else if(time == longestTime && id < smallestId) \\n        {\\n            smallestId = id;\\n        }\\n    }\\n\\n    return smallestId;\\n}\\n```\\n```C []\\nint hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n    int smallestId = logs[0][0];\\n    int longestTime = logs[0][1];\\n\\n    for(int i = 1; i < logsSize; ++i) {\\n        int id = logs[i][0];\\n        int time = logs[i][1] - logs[i - 1][1];\\n        if(time > longestTime) {\\n            longestTime = time;\\n            smallestId = id;\\n        } else if(time == longestTime && id < smallestId) {\\n            smallestId = id;\\n        }\\n    }\\n\\n    return smallestId;\\n}\\n```\\n```C++ []\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n    int smallestId = logs[0][0];\\n    int longestTime = logs[0][1];\\n\\n    for(int i = 1; i < logs.size(); ++i) {\\n        int id = logs[i][0];\\n        int time = logs[i][1] - logs[i - 1][1];\\n        if(time > longestTime) {\\n            longestTime = time;\\n            smallestId = id;\\n        } else if(time == longestTime && id < smallestId) {\\n            smallestId = id;\\n        }\\n    }\\n\\n    return smallestId;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "C#"
                ],
                "code": "```CS []\\npublic int HardestWorker(int n, int[][] logs) \\n{\\n    int smallestId = logs[0][0];\\n    int longestTime = logs[0][1];\\n\\n    for(int i = 1; i < logs.Length; ++i)\\n    {\\n        int id = logs[i][0];\\n        int time = logs[i][1] - logs[i - 1][1];\\n        if(time > longestTime) \\n        {\\n            longestTime = time;\\n            smallestId = id;\\n        } \\n        else if(time == longestTime && id < smallestId) \\n        {\\n            smallestId = id;\\n        }\\n    }\\n\\n    return smallestId;\\n}\\n```\n```C []\\nint hardestWorker(int n, int** logs, int logsSize, int* logsColSize){\\n    int smallestId = logs[0][0];\\n    int longestTime = logs[0][1];\\n\\n    for(int i = 1; i < logsSize; ++i) {\\n        int id = logs[i][0];\\n        int time = logs[i][1] - logs[i - 1][1];\\n        if(time > longestTime) {\\n            longestTime = time;\\n            smallestId = id;\\n        } else if(time == longestTime && id < smallestId) {\\n            smallestId = id;\\n        }\\n    }\\n\\n    return smallestId;\\n}\\n```\n```C++ []\\nint hardestWorker(int n, vector<vector<int>>& logs) {\\n    int smallestId = logs[0][0];\\n    int longestTime = logs[0][1];\\n\\n    for(int i = 1; i < logs.size(); ++i) {\\n        int id = logs[i][0];\\n        int time = logs[i][1] - logs[i - 1][1];\\n        if(time > longestTime) {\\n            longestTime = time;\\n            smallestId = id;\\n        } else if(time == longestTime && id < smallestId) {\\n            smallestId = id;\\n        }\\n    }\\n\\n    return smallestId;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445380,
                "title": "3-hashsets-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWithout hesitation, I will need hashSet to keep input information and hadle that in more comfortable way\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI create 3 hashSets to keep input information: Task-Time, Task-Employee, Employee-MaxTime. Then I fill those hashSets. The first task is handled separately because 0th task starts at time 0. Then it`s easy to find maxTime Task and find out what workers did the longest task. Then I return minimal employee id from the list of workers who did the longest task. It is not the fastest way to solve problem. But easy to understand.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        //task - time\\n        Map<Integer,Integer> timeMap = new HashMap<>();\\n        //task - employee\\n        Map<Integer,Integer> empMap = new HashMap<>();\\n        //emp - time\\n        Map<Integer,Integer> hardestTask = new HashMap<>();\\n\\n\\n        timeMap.put(0,logs[0][1]);\\n        empMap.put(0,logs[0][0]);\\n        hardestTask.put(logs[0][0],logs[0][1]);\\n\\n        for(int i=1;i<logs.length;i++){\\n            int time = logs[i][1]-logs[i-1][1];\\n            int employee = logs[i][0];\\n            int task = i;\\n            timeMap.put(task,time);\\n            empMap.put(task,logs[i][0]);\\n\\n            if(!hardestTask.containsKey(employee))\\n                hardestTask.put(employee,time);\\n            else {\\n                hardestTask.put(employee,Math.max(time,hardestTask.get(employee)));\\n            }\\n\\n        }\\n\\n        \\n        int maxTime = Collections.max(timeMap.entrySet(), Comparator.comparingInt(Map.Entry::getValue)).getValue();\\n        List<Integer>bestWorkers= new ArrayList<>();\\n        for(Integer el: hardestTask.keySet())\\n            if(hardestTask.get(el)==maxTime)bestWorkers.add(el);\\n\\n        return bestWorkers.stream().mapToInt(v->v).min().getAsInt();\\n\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        //task - time\\n        Map<Integer,Integer> timeMap = new HashMap<>();\\n        //task - employee\\n        Map<Integer,Integer> empMap = new HashMap<>();\\n        //emp - time\\n        Map<Integer,Integer> hardestTask = new HashMap<>();\\n\\n\\n        timeMap.put(0,logs[0][1]);\\n        empMap.put(0,logs[0][0]);\\n        hardestTask.put(logs[0][0],logs[0][1]);\\n\\n        for(int i=1;i<logs.length;i++){\\n            int time = logs[i][1]-logs[i-1][1];\\n            int employee = logs[i][0];\\n            int task = i;\\n            timeMap.put(task,time);\\n            empMap.put(task,logs[i][0]);\\n\\n            if(!hardestTask.containsKey(employee))\\n                hardestTask.put(employee,time);\\n            else {\\n                hardestTask.put(employee,Math.max(time,hardestTask.get(employee)));\\n            }\\n\\n        }\\n\\n        \\n        int maxTime = Collections.max(timeMap.entrySet(), Comparator.comparingInt(Map.Entry::getValue)).getValue();\\n        List<Integer>bestWorkers= new ArrayList<>();\\n        for(Integer el: hardestTask.keySet())\\n            if(hardestTask.get(el)==maxTime)bestWorkers.add(el);\\n\\n        return bestWorkers.stream().mapToInt(v->v).min().getAsInt();\\n\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438321,
                "title": "java-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n           int t  = logs[0][1];\\n        int id = logs[0][0];\\n        int[]a = new int[2];\\n        a[0] = t;\\n        a[1] = id;\\n        for (int i = 1; i < logs.length; i++) {\\n\\n            if(t < Math.abs(logs[i-1][1]-logs[i][1])) {\\n                t = Math.abs(logs[i - 1][1] - logs[i][1]);\\n                a[0] = t;\\n                a[1] = logs[i][0];\\n            }\\n             else if(t == Math.abs(logs[i-1][1]-logs[i][1])){\\n                t = Math.abs(logs[i - 1][1] - logs[i][1]);\\n                if(a[1] > logs[i][0]){\\n                        a[1] = logs[i][0];\\n                    }\\n                }\\n                }\\n\\nreturn a[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n           int t  = logs[0][1];\\n        int id = logs[0][0];\\n        int[]a = new int[2];\\n        a[0] = t;\\n        a[1] = id;\\n        for (int i = 1; i < logs.length; i++) {\\n\\n            if(t < Math.abs(logs[i-1][1]-logs[i][1])) {\\n                t = Math.abs(logs[i - 1][1] - logs[i][1]);\\n                a[0] = t;\\n                a[1] = logs[i][0];\\n            }\\n             else if(t == Math.abs(logs[i-1][1]-logs[i][1])){\\n                t = Math.abs(logs[i - 1][1] - logs[i][1]);\\n                if(a[1] > logs[i][0]){\\n                        a[1] = logs[i][0];\\n                    }\\n                }\\n                }\\n\\nreturn a[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424190,
                "title": "python-fast-clear-beats-97-53",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        \\n        empId, unit, lastLeaveTime = 0, 0, 0\\n\\n        for id, leaveTime in logs:\\n            \\n            div = leaveTime - lastLeaveTime \\n\\n            if div > unit:\\n                empId = id\\n                unit = div\\n            \\n            if div == unit and empId > id:\\n                empId = id\\n                unit = div\\n\\n            lastLeaveTime = leaveTime\\n\\n        return empId\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/e8a13d60-4e92-42d7-94a0-0f92defd4f6a_1681663990.4652176.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        \\n        empId, unit, lastLeaveTime = 0, 0, 0\\n\\n        for id, leaveTime in logs:\\n            \\n            div = leaveTime - lastLeaveTime \\n\\n            if div > unit:\\n                empId = id\\n                unit = div\\n            \\n            if div == unit and empId > id:\\n                empId = id\\n                unit = div\\n\\n            lastLeaveTime = leaveTime\\n\\n        return empId\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421705,
                "title": "beginner-friendly-easy-to-understand-beats-a-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n       int prev=0,w,d;\\n        int m=INT_MIN,ans=0,lo;\\n        for(int i=0;i<logs.size();i++){\\n            lo=logs[i][0];\\n          \\n            w=logs[i][1];\\n           \\n            d=w-prev;\\n           // cout<<prev<<\"\\\\n\";\\n            if(m<d){\\n               // cout<<lo<<\"\\\\n\";\\n            ans=(lo);    \\n            m=d;           \\n           \\n            }\\n            if(m==d){\\n             ans=min(lo,ans);    \\n            m=d;     \\n            }\\n            prev=w;\\n\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n       int prev=0,w,d;\\n        int m=INT_MIN,ans=0,lo;\\n        for(int i=0;i<logs.size();i++){\\n            lo=logs[i][0];\\n          \\n            w=logs[i][1];\\n           \\n            d=w-prev;\\n           // cout<<prev<<\"\\\\n\";\\n            if(m<d){\\n               // cout<<lo<<\"\\\\n\";\\n            ans=(lo);    \\n            m=d;           \\n           \\n            }\\n            if(m==d){\\n             ans=min(lo,ans);    \\n            m=d;     \\n            }\\n            prev=w;\\n\\n        }\\n                return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3400338,
                "title": "java-o-n-readable-solution",
                "content": "# Intuition\\nIterate over logs one-by-one\\nCalculate both longestHour and smallestEmployeeId.\\nReturn smallestEmployeeId\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int startTime = 0;\\n        int longestHour = 0;\\n        int smallestEmployeeId = Integer.MAX_VALUE;\\n        for (int[] log: logs) {\\n            int employeeId = log[0];\\n            int leaveTime = log[1];\\n            int workHour = leaveTime - startTime;\\n            if (workHour == longestHour) {\\n                smallestEmployeeId = Math.min(smallestEmployeeId, employeeId);\\n            } else if (workHour > longestHour){\\n                longestHour = workHour;\\n                smallestEmployeeId = employeeId;\\n            }\\n            startTime = leaveTime;\\n        }\\n\\n        return smallestEmployeeId;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int startTime = 0;\\n        int longestHour = 0;\\n        int smallestEmployeeId = Integer.MAX_VALUE;\\n        for (int[] log: logs) {\\n            int employeeId = log[0];\\n            int leaveTime = log[1];\\n            int workHour = leaveTime - startTime;\\n            if (workHour == longestHour) {\\n                smallestEmployeeId = Math.min(smallestEmployeeId, employeeId);\\n            } else if (workHour > longestHour){\\n                longestHour = workHour;\\n                smallestEmployeeId = employeeId;\\n            }\\n            startTime = leaveTime;\\n        }\\n\\n        return smallestEmployeeId;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379736,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        \\n        D = defaultdict(lambda:[])\\n\\n        longest = logs[0][1]\\n        D[longest].append(logs[0][0])\\n        for i,l in enumerate(logs):\\n            if i == 0 : continue \\n            longest = max(longest,(logs[i][1]-logs[i-1][1]))\\n            D[logs[i][1]-logs[i-1][1]].append(logs[i][0])\\n\\n        D[longest].sort()\\n        return D[longest][0]\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        \\n        D = defaultdict(lambda:[])\\n\\n        longest = logs[0][1]\\n        D[longest].append(logs[0][0])\\n        for i,l in enumerate(logs):\\n            if i == 0 : continue \\n            longest = max(longest,(logs[i][1]-logs[i-1][1]))\\n            D[logs[i][1]-logs[i-1][1]].append(logs[i][0])\\n\\n        D[longest].sort()\\n        return D[longest][0]\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362646,
                "title": "comparing-step-by-step",
                "content": "```\\nclass Solution {\\n  fun hardestWorker(n: Int, logs: Array<IntArray>): Int {\\n    var (last, lastTime) = logs[0]\\n    var max = lastTime\\n    for (i in 1 until logs.size) {\\n      val (next, nextTime) = logs[i]\\n      val diff = nextTime - lastTime\\n      when {\\n        diff > max -> { max = diff ; last = next }\\n        diff == max -> { last = Math.min(last, next) }\\n      }\\n      lastTime = nextTime\\n    }\\n    return last\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun hardestWorker(n: Int, logs: Array<IntArray>): Int {\\n    var (last, lastTime) = logs[0]\\n    var max = lastTime\\n    for (i in 1 until logs.size) {\\n      val (next, nextTime) = logs[i]\\n      val diff = nextTime - lastTime\\n      when {\\n        diff > max -> { max = diff ; last = next }\\n        diff == max -> { last = Math.min(last, next) }\\n      }\\n      lastTime = nextTime\\n    }\\n    return last\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349302,
                "title": "python-o-n-time-and-o-1-space-algorithm-to-identify-longest-work-hours",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the ID of the worker who worked the hardest, where \"hardest\" means the worker who worked the most extended hours. We are given a list of logs containing the worker\\'s ID and leave time. We need to iterate over the logs and calculate the work time for each worker, then keep track of the worker with the longest work time and return their ID.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the idi and max_work_time to the values of the first log in the list.\\n2. Iterate over the remaining logs, and for each log: \\n    - Calculate the work time for the worker by subtracting their start time from the previous worker\\'s end time. \\n    - If the current worker\\'s work time(cur_work_time) is greater than the current maximum work time(max_work_time), update both idi and max_work_time to the current worker\\'s ID and the current work time, respectively.  \\n    - If the current work time(cur_work_time) is equal to the current maximum work time(max_work_time), check if the current worker\\'s ID is smaller than the current idi. If it is, update the idi to the current worker\\'s ID.\\n3. Return the idi. \\n\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of logs in the input list\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1), which is constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        idi, max_work_time,  = logs[0]\\n        \\n        for i in range(1, len(logs)):\\n            cur_work_time = logs[i][1] - logs[i-1][1]\\n            if cur_work_time > max_work_time:\\n                idi = logs[i][0]\\n                max_work_time = cur_work_time\\n            if cur_work_time == max_work_time and idi > logs[i][0]:\\n                idi = logs[i][0]\\n        return idi\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        idi, max_work_time,  = logs[0]\\n        \\n        for i in range(1, len(logs)):\\n            cur_work_time = logs[i][1] - logs[i-1][1]\\n            if cur_work_time > max_work_time:\\n                idi = logs[i][0]\\n                max_work_time = cur_work_time\\n            if cur_work_time == max_work_time and idi > logs[i][0]:\\n                idi = logs[i][0]\\n        return idi\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338000,
                "title": "easy-good-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        mini=logs[0][1]\\n        ans=logs[0][0]\\n        for i in range(1,len(logs)):\\n            if logs[i][1]-logs[i-1][1]>mini:\\n                mini=logs[i][1]-logs[i-1][1]\\n                ans=logs[i][0]\\n            elif logs[i][1]-logs[i-1][1]==mini:\\n                ans=min(logs[i][0],ans)\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        mini=logs[0][1]\\n        ans=logs[0][0]\\n        for i in range(1,len(logs)):\\n            if logs[i][1]-logs[i-1][1]>mini:\\n                mini=logs[i][1]-logs[i-1][1]\\n                ans=logs[i][0]\\n            elif logs[i][1]-logs[i-1][1]==mini:\\n                ans=min(logs[i][0],ans)\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333956,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int prev = 0, longestTime = 0, ans = 0;\\n        for (auto& v : logs){\\n            if (longestTime < v[1] - prev)\\n                longestTime = v[1] - prev, ans = v[0];\\n            else if (longestTime == v[1] - prev)\\n                ans = min(ans, v[0]);\\n            prev = v[1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int prev = 0, longestTime = 0, ans = 0;\\n        for (auto& v : logs){\\n            if (longestTime < v[1] - prev)\\n                longestTime = v[1] - prev, ans = v[0];\\n            else if (longestTime == v[1] - prev)\\n                ans = min(ans, v[0]);\\n            prev = v[1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321035,
                "title": "beats-100-java-easy-to-understand-o-n-time-complexity",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n\\n        int start=0;\\n        int id=Integer.MAX_VALUE;\\n        int max=0;\\n\\n        for(int i[]:logs){\\n            int work=i[1]-start;\\n            start=i[1];\\n            if(work>=max){\\n                if(work==max){\\n                    id=Math.min(id,i[0]);\\n                }else{\\n                    id=i[0];\\n                    max=work;\\n                }\\n            }\\n        }\\n\\n        return id;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n\\n        int start=0;\\n        int id=Integer.MAX_VALUE;\\n        int max=0;\\n\\n        for(int i[]:logs){\\n            int work=i[1]-start;\\n            start=i[1];\\n            if(work>=max){\\n                if(work==max){\\n                    id=Math.min(id,i[0]);\\n                }else{\\n                    id=i[0];\\n                    max=work;\\n                }\\n            }\\n        }\\n\\n        return id;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312736,
                "title": "easy-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int ans = 0;\\n        int longestTask = 0;\\n        int taskStart = 0;\\n\\n        for (int[] log : logs) {\\n            int taskLength = log[1] - taskStart;\\n            taskStart = log[1];\\n\\n            if (longestTask < taskLength) {\\n                longestTask = taskLength;\\n                ans = log[0];\\n            } else if (longestTask == taskLength) {\\n                ans = Math.min(ans, log[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int ans = 0;\\n        int longestTask = 0;\\n        int taskStart = 0;\\n\\n        for (int[] log : logs) {\\n            int taskLength = log[1] - taskStart;\\n            taskStart = log[1];\\n\\n            if (longestTask < taskLength) {\\n                longestTask = taskLength;\\n                ans = log[0];\\n            } else if (longestTask == taskLength) {\\n                ans = Math.min(ans, log[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305977,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int id = logs[0][0];\\n        int max = logs[0][1];\\n        \\n        for (int i = 1; i<logs.length; i++)\\n        {\\n            int diff = logs[i][1] - logs[i-1][1];\\n            if (diff == max)\\n                id = Math.min(id, logs[i][0]);\\n            else if (diff > max)\\n            {\\n                id = logs[i][0];\\n                max = diff;\\n            }     \\n        }\\n        \\n        return id;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int id = logs[0][0];\\n        int max = logs[0][1];\\n        \\n        for (int i = 1; i<logs.length; i++)\\n        {\\n            int diff = logs[i][1] - logs[i-1][1];\\n            if (diff == max)\\n                id = Math.min(id, logs[i][0]);\\n            else if (diff > max)\\n            {\\n                id = logs[i][0];\\n                max = diff;\\n            }     \\n        }\\n        \\n        return id;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305662,
                "title": "same-one-line",
                "content": "# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\\n        return min([e for e in [[element[0], element[1] - (logs[i-1][1] if i > 0 else 0)] for i, element in enumerate(logs)] if e[1] == max([[element[0], element[1] - (logs[i-1][1] if i > 0 else 0)] for i, element in enumerate(logs)], key=lambda x: x[1])[1]], key=lambda x: x[0])[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\\n        return min([e for e in [[element[0], element[1] - (logs[i-1][1] if i > 0 else 0)] for i, element in enumerate(logs)] if e[1] == max([[element[0], element[1] - (logs[i-1][1] if i > 0 else 0)] for i, element in enumerate(logs)], key=lambda x: x[1])[1]], key=lambda x: x[0])[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292500,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn hardest_worker(n: i32, logs: Vec<Vec<i32>>) -> i32 {\\n         let mut units = Vec::new();\\n    let mut longest = 0;\\n    units.push(logs[0][1] - 0); b // units[0] is fixed value. \\n     for i in 1..logs.len() { \\n        units.push(logs[i][1] - logs[i-1][1]);\\n    }\\n  // code that exclude units that have same value, the smaller one has to be survived\\n    for i in 0..units.len() {\\n        for j in i+1..units.len() {\\n            if units[i] == units[j] {\\n                if logs[i][0] < logs[j][0] {\\n                    units[j] = 0;\\n                } else {\\n                    units[i] = 0;\\n                }\\n            }\\n        }\\n    }\\n//code that finds the longest one \\n    for i in 0..units.len() {\\n        if units[i as usize] > longest {\\n            longest = units[i as usize];\\n        }\\n    }\\n    \\n   logs[units.iter().position(|&x| x == longest).unwrap()][0]\\n    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn hardest_worker(n: i32, logs: Vec<Vec<i32>>) -> i32 {\\n         let mut units = Vec::new();\\n    let mut longest = 0;\\n    units.push(logs[0][1] - 0); b // units[0] is fixed value. \\n     for i in 1..logs.len() { \\n        units.push(logs[i][1] - logs[i-1][1]);\\n    }\\n  // code that exclude units that have same value, the smaller one has to be survived\\n    for i in 0..units.len() {\\n        for j in i+1..units.len() {\\n            if units[i] == units[j] {\\n                if logs[i][0] < logs[j][0] {\\n                    units[j] = 0;\\n                } else {\\n                    units[i] = 0;\\n                }\\n            }\\n        }\\n    }\\n//code that finds the longest one \\n    for i in 0..units.len() {\\n        if units[i as usize] > longest {\\n            longest = units[i as usize];\\n        }\\n    }\\n    \\n   logs[units.iter().position(|&x| x == longest).unwrap()][0]\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3284263,
                "title": "longest-task-javascript-time-o-n-space-o-1-72-ms",
                "content": "```\\n\\nvar hardestWorker = function(n, logs) {\\n    arr = [0, 0]\\n\\n    for (i = 0; i < logs.length; i++) {        \\n        i > 0 ? dif = logs[i][1] - logs[i-1][1] : dif = logs[i][1]        \\n\\n        if (arr[1] < dif) arr[1] = dif, arr[0] = logs[i][0]\\n        if (arr[1] == dif && arr[0] > logs[i][0]) arr[0] = logs[i][0]\\n    }\\n    \\n    return arr[0]\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar hardestWorker = function(n, logs) {\\n    arr = [0, 0]\\n\\n    for (i = 0; i < logs.length; i++) {        \\n        i > 0 ? dif = logs[i][1] - logs[i-1][1] : dif = logs[i][1]        \\n\\n        if (arr[1] < dif) arr[1] = dif, arr[0] = logs[i][0]\\n        if (arr[1] == dif && arr[0] > logs[i][0]) arr[0] = logs[i][0]\\n    }\\n    \\n    return arr[0]\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3272335,
                "title": "hardestworker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n        res = logs.map((item, index, array) => {\\n        if (index == 0) return item\\n        else {\\n            return [item[0], item[1] - array[index - 1][1]]\\n        }\\n    })\\n    resW = res.map(item=>item[1])\\n    x = Math.max(...resW)\\n    let arr = []\\n    res.map((item) => {\\n        if (item[1] == x) {\\n            arr.push(item[0])\\n        }\\n    })\\n    return Math.min(...arr)\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n        res = logs.map((item, index, array) => {\\n        if (index == 0) return item\\n        else {\\n            return [item[0], item[1] - array[index - 1][1]]\\n        }\\n    })\\n    resW = res.map(item=>item[1])\\n    x = Math.max(...resW)\\n    let arr = []\\n    res.map((item) => {\\n        if (item[1] == x) {\\n            arr.push(item[0])\\n        }\\n    })\\n    return Math.min(...arr)\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267060,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n        int id=INT_MAX, maxi=INT_MIN, last=0;\\n        \\n        for(int i=0; i<logs.size(); i++)\\n        {\\n            if((logs[i][1] - last) > maxi || ((logs[i][1] - last)==maxi && id > logs[i][0]))\\n            {\\n                maxi = (logs[i][1] - last);\\n                id = logs[i][0];\\n            } \\n            last = logs[i][1];\\n        }\\n        return id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n        int id=INT_MAX, maxi=INT_MIN, last=0;\\n        \\n        for(int i=0; i<logs.size(); i++)\\n        {\\n            if((logs[i][1] - last) > maxi || ((logs[i][1] - last)==maxi && id > logs[i][0]))\\n            {\\n                maxi = (logs[i][1] - last);\\n                id = logs[i][0];\\n            } \\n            last = logs[i][1];\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265260,
                "title": "easy-javascript-solution-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let st=0;\\n    let hardWorker=-1;\\n    let max=0;\\n    for(let log of logs){\\n        let time=log[1]-st;\\n        st=log[1];\\n        if(time>max){\\n            max=time;\\n            hardWorker=log[0];\\n        }else if(time==max){\\n            if(log[0]<hardWorker)\\n                hardWorker=log[0];\\n        }\\n    }\\n\\n    return hardWorker;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let st=0;\\n    let hardWorker=-1;\\n    let max=0;\\n    for(let log of logs){\\n        let time=log[1]-st;\\n        st=log[1];\\n        if(time>max){\\n            max=time;\\n            hardWorker=log[0];\\n        }else if(time==max){\\n            if(log[0]<hardWorker)\\n                hardWorker=log[0];\\n        }\\n    }\\n\\n    return hardWorker;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3264953,
                "title": "easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max=0;\\n        int add=0;\\n        int ans=0;\\n        int prev=0;\\n        for(int[] arr:logs){\\n         prev=Math.abs(prev-arr[1]);\\n         if(max==prev){\\n            if(ans>arr[0]) ans=arr[0];\\n          }\\n          \\n          if(max<prev){\\n            max=prev;\\n            \\n            ans=arr[0];\\n            \\n          }\\n          \\n          prev+=add;\\n          add=prev;\\n          \\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int max=0;\\n        int add=0;\\n        int ans=0;\\n        int prev=0;\\n        for(int[] arr:logs){\\n         prev=Math.abs(prev-arr[1]);\\n         if(max==prev){\\n            if(ans>arr[0]) ans=arr[0];\\n          }\\n          \\n          if(max<prev){\\n            max=prev;\\n            \\n            ans=arr[0];\\n            \\n          }\\n          \\n          prev+=add;\\n          add=prev;\\n          \\n\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245642,
                "title": "simple-linear-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int prev = 0, result, maxTime = std::numeric_limits < int >::min();\\n        for ( const auto& log : logs )\\n        {\\n            int currTime = log[1] - prev;\\n            if ( currTime > maxTime )\\n            {\\n                maxTime = currTime;\\n                result = log[0];\\n            }\\n            else if ( currTime == maxTime )\\n            {\\n                result = std::min(result, log[0]);\\n            }\\n            prev = log[1];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int prev = 0, result, maxTime = std::numeric_limits < int >::min();\\n        for ( const auto& log : logs )\\n        {\\n            int currTime = log[1] - prev;\\n            if ( currTime > maxTime )\\n            {\\n                maxTime = currTime;\\n                result = log[0];\\n            }\\n            else if ( currTime == maxTime )\\n            {\\n                result = std::min(result, log[0]);\\n            }\\n            prev = log[1];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234504,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1), No extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int startTime = 0, maxDuration = 0, resID = INT_MAX, size = logs.size();\\n        for(int i = 0; i < size; ++i){\\n            int currID = logs[i][0], endTime = logs[i][1];\\n            if(maxDuration < endTime - startTime){\\n                maxDuration = endTime - startTime;\\n                resID = currID;\\n            }\\n            else if(maxDuration == endTime - startTime)\\n                resID = min(resID, currID);\\n            startTime = endTime;\\n        }\\n        return resID;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int startTime = 0, maxDuration = 0, resID = INT_MAX, size = logs.size();\\n        for(int i = 0; i < size; ++i){\\n            int currID = logs[i][0], endTime = logs[i][1];\\n            if(maxDuration < endTime - startTime){\\n                maxDuration = endTime - startTime;\\n                resID = currID;\\n            }\\n            else if(maxDuration == endTime - startTime)\\n                resID = min(resID, currID);\\n            startTime = endTime;\\n        }\\n        return resID;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229295,
                "title": "python-3-readable-solution-single-pass",
                "content": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        logs = [[0, 0]] + logs\\n        durs = [[y[0], y[1] - x[1]] for x, y in zip(logs[:-1], logs[1:])] \\n        return max(durs, key=lambda _: (_[1], -_[0]))[0] # Max duration, min ID\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        logs = [[0, 0]] + logs\\n        durs = [[y[0], y[1] - x[1]] for x, y in zip(logs[:-1], logs[1:])] \\n        return max(durs, key=lambda _: (_[1], -_[0]))[0] # Max duration, min ID\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217167,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n         \\n         int result[]=new int[logs.length];\\n        //finding employee that worked on longest task\\n        int max=logs[0][1];\\n        int id=logs[0][0];\\n        \\n        for(int i=1;i<logs.length;i++){\\n           int unit_time=logs[i][1]-logs[i-1][1];\\n           if(unit_time>max){\\n               max=unit_time;\\n               id=logs[i][0];\\n           }\\n           if(unit_time==max&&logs[i][0]<id){\\n                  id=logs[i][0];\\n           }\\n        }\\nreturn id;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n         \\n         int result[]=new int[logs.length];\\n        //finding employee that worked on longest task\\n        int max=logs[0][1];\\n        int id=logs[0][0];\\n        \\n        for(int i=1;i<logs.length;i++){\\n           int unit_time=logs[i][1]-logs[i-1][1];\\n           if(unit_time>max){\\n               max=unit_time;\\n               id=logs[i][0];\\n           }\\n           if(unit_time==max&&logs[i][0]<id){\\n                  id=logs[i][0];\\n           }\\n        }\\nreturn id;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203533,
                "title": "solution-using-tuple-format",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def hardestWorker(self, n, logs):\\n        [ide, time] = logs[0]\\n        for i in range(1,len(logs)):\\n            if logs[i][1]-logs[i-1][1] > time:\\n                [ide, time] = [logs[i][0],logs[i][1]-logs[i-1][1]] \\n            elif logs[i][1]-logs[i-1][1] == time and logs[i][0] < ide:\\n                ide  = logs[i][0]\\n        return ide\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def hardestWorker(self, n, logs):\\n        [ide, time] = logs[0]\\n        for i in range(1,len(logs)):\\n            if logs[i][1]-logs[i-1][1] > time:\\n                [ide, time] = [logs[i][0],logs[i][1]-logs[i-1][1]] \\n            elif logs[i][1]-logs[i-1][1] == time and logs[i][0] < ide:\\n                ide  = logs[i][0]\\n        return ide\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202875,
                "title": "java-1ms-beats-100-and-clear-explanations",
                "content": "# Approach\\n1. Traverse the logs and keep track of hardestWorker and longestTask.\\n2. If current task worked on is longer than longestTask, set it and set the worker\\n3. If current task is as long as the longestTask known so far, set the harest worker to be min between these two workers.\\n4. Return hardest worker. \\n\\n# Complexity\\n- Time complexity:$$O(logs.length)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int hardestWorker = logs[0][0];\\n        int longestTask = logs[0][1];\\n        int taskLength;\\n        for(int i = 1; i < logs.length; i++) {\\n            taskLength = logs[i][1] - logs[i-1][1];\\n            if (taskLength > longestTask) {\\n                longestTask = taskLength;\\n                hardestWorker = logs[i][0];\\n            } else if (taskLength == longestTask) {\\n                hardestWorker = Math.min(hardestWorker, logs[i][0]);\\n            }\\n        }\\n        return hardestWorker;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int hardestWorker = logs[0][0];\\n        int longestTask = logs[0][1];\\n        int taskLength;\\n        for(int i = 1; i < logs.length; i++) {\\n            taskLength = logs[i][1] - logs[i-1][1];\\n            if (taskLength > longestTask) {\\n                longestTask = taskLength;\\n                hardestWorker = logs[i][0];\\n            } else if (taskLength == longestTask) {\\n                hardestWorker = Math.min(hardestWorker, logs[i][0]);\\n            }\\n        }\\n        return hardestWorker;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166835,
                "title": "scala-1-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def hardestWorker(n: Int, logs: Array[Array[Int]]): Int = \\n        (((0 +: logs.map(_(1)).toList).sliding(2).map(n => n.last - n.head).toList zip logs.map(_(0))).maxBy(n => (n._1, -n._2)))._2\\n\\n\\n        \\n    \\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def hardestWorker(n: Int, logs: Array[Array[Int]]): Int = \\n        (((0 +: logs.map(_(1)).toList).sliding(2).map(n => n.last - n.head).toList zip logs.map(_(0))).maxBy(n => (n._1, -n._2)))._2\\n\\n\\n        \\n    \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3153974,
                "title": "100-fast-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int prev = 0;\\n        int mx = -1;\\n        int idm = n;\\n        for (int[] log : logs) {\\n            int id = log[0];\\n            int end = log[1];\\n            if(end - prev > mx){\\n                mx = end-prev;\\n                idm = id;\\n            }\\n            else if(end - prev == mx) idm = Math.min(id, idm);\\n            prev = end;\\n        }\\n        return idm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int prev = 0;\\n        int mx = -1;\\n        int idm = n;\\n        for (int[] log : logs) {\\n            int id = log[0];\\n            int end = log[1];\\n            if(end - prev > mx){\\n                mx = end-prev;\\n                idm = id;\\n            }\\n            else if(end - prev == mx) idm = Math.min(id, idm);\\n            prev = end;\\n        }\\n        return idm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151258,
                "title": "easy-solution-javasction",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let max= -1;\\n    let ans = 0;\\n    let dur = 0;\\n    let time = 0;\\n    for(let i = 0;i<logs.length;i++){\\n        let duration = logs[i][1]-time;\\n        time = logs[i][1];\\n        if(duration===max&&ans>logs[i][0]){\\n            ans = logs[i][0]\\n        }\\n        else if(duration>max){\\n            max = duration;\\n            ans = logs[i][0]\\n            \\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let max= -1;\\n    let ans = 0;\\n    let dur = 0;\\n    let time = 0;\\n    for(let i = 0;i<logs.length;i++){\\n        let duration = logs[i][1]-time;\\n        time = logs[i][1];\\n        if(duration===max&&ans>logs[i][0]){\\n            ans = logs[i][0]\\n        }\\n        else if(duration>max){\\n            max = duration;\\n            ans = logs[i][0]\\n            \\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3151257,
                "title": "easy-solution-javasction",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let max= -1;\\n    let ans = 0;\\n    let dur = 0;\\n    let time = 0;\\n    for(let i = 0;i<logs.length;i++){\\n        let duration = logs[i][1]-time;\\n        time = logs[i][1];\\n        if(duration===max&&ans>logs[i][0]){\\n            ans = logs[i][0]\\n        }\\n        else if(duration>max){\\n            max = duration;\\n            ans = logs[i][0]\\n            \\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let max= -1;\\n    let ans = 0;\\n    let dur = 0;\\n    let time = 0;\\n    for(let i = 0;i<logs.length;i++){\\n        let duration = logs[i][1]-time;\\n        time = logs[i][1];\\n        if(duration===max&&ans>logs[i][0]){\\n            ans = logs[i][0]\\n        }\\n        else if(duration>max){\\n            max = duration;\\n            ans = logs[i][0]\\n            \\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3126715,
                "title": "beats-87-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        time = 0 \\n        worker = 0\\n        units = 0\\n\\n        for i in logs:\\n            if(i[1] - time > units):\\n                units = i[1]- time\\n                worker = i[0]\\n            elif(i[1] - time == units and i[0] < worker):\\n                worker = i[0]\\n            time = i[1]\\n\\n        # print(units)\\n        return worker\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        time = 0 \\n        worker = 0\\n        units = 0\\n\\n        for i in logs:\\n            if(i[1] - time > units):\\n                units = i[1]- time\\n                worker = i[0]\\n            elif(i[1] - time == units and i[0] < worker):\\n                worker = i[0]\\n            time = i[1]\\n\\n        # print(units)\\n        return worker\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124226,
                "title": "c-o-n-time-o-1-space-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int tookTime = 0;\\n        int maxTookTime = logs[0][1];\\n        int ansID = logs[0][0];\\n        for(int i = 1; i < logs.size(); i++){\\n            tookTime = logs[i][1] - logs[i-1][1];\\n            if(tookTime > maxTookTime){\\n                ansID = logs[i][0];\\n                maxTookTime = tookTime;\\n            }else if(tookTime == maxTookTime){\\n                ansID = logs[i][0] < ansID ? logs[i][0] : ansID;\\n            }\\n        }\\n        return ansID;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int tookTime = 0;\\n        int maxTookTime = logs[0][1];\\n        int ansID = logs[0][0];\\n        for(int i = 1; i < logs.size(); i++){\\n            tookTime = logs[i][1] - logs[i-1][1];\\n            if(tookTime > maxTookTime){\\n                ansID = logs[i][0];\\n                maxTookTime = tookTime;\\n            }else if(tookTime == maxTookTime){\\n                ansID = logs[i][0] < ansID ? logs[i][0] : ansID;\\n            }\\n        }\\n        return ansID;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093695,
                "title": "c-o-n-time-simple-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int id=INT_MAX,start=0,time=INT_MIN;\\n        vector<int>idd;\\n        for(auto &i:logs){\\n            if(i[1]-start> time)\\n                time=max(i[1]-start,time);\\n            start=i[1];\\n        }\\n        start=0;\\n        for(auto &i:logs){\\n            if(i[1]-start ==time) idd.push_back(i[0]);\\n            start=i[1];\\n        }\\n        for(auto &i:idd)\\n            id=min(id,i);\\n        return id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int id=INT_MAX,start=0,time=INT_MIN;\\n        vector<int>idd;\\n        for(auto &i:logs){\\n            if(i[1]-start> time)\\n                time=max(i[1]-start,time);\\n            start=i[1];\\n        }\\n        start=0;\\n        for(auto &i:logs){\\n            if(i[1]-start ==time) idd.push_back(i[0]);\\n            start=i[1];\\n        }\\n        for(auto &i:idd)\\n            id=min(id,i);\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087675,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int ans = INT_MAX;\\n        int maxDuration = INT_MIN;\\n        int end = 0;\\n        \\n        for(const auto &log : logs) {\\n            const int duration = log[1] - end;\\n            end = log[1];\\n            \\n            if(maxDuration <= duration) {\\n                if(maxDuration < duration) {\\n                    maxDuration = duration;\\n                    ans = log[0];\\n                } else {\\n                    ans = min(ans, log[0]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        int ans = INT_MAX;\\n        int maxDuration = INT_MIN;\\n        int end = 0;\\n        \\n        for(const auto &log : logs) {\\n            const int duration = log[1] - end;\\n            end = log[1];\\n            \\n            if(maxDuration <= duration) {\\n                if(maxDuration < duration) {\\n                    maxDuration = duration;\\n                    ans = log[0];\\n                } else {\\n                    ans = min(ans, log[0]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084905,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun hardestWorker(n: Int, logs: Array<IntArray>): Int {\\n        val n = logs.size\\n        var max = logs[0][1]\\n        var result = logs[0][0]\\n        for (i in 1..n-1) {\\n            var diff = logs[i][1]-logs[i-1][1]\\n            if (diff > max || diff == max && result > logs[i][0]) {\\n                max = diff\\n                result = logs[i][0]\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun hardestWorker(n: Int, logs: Array<IntArray>): Int {\\n        val n = logs.size\\n        var max = logs[0][1]\\n        var result = logs[0][0]\\n        for (i in 1..n-1) {\\n            var diff = logs[i][1]-logs[i-1][1]\\n            if (diff > max || diff == max && result > logs[i][0]) {\\n                max = diff\\n                result = logs[i][0]\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076947,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "# Code\\n```\\n\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n\\n        m, ID = logs[0][1], logs[0][0]\\n\\n        for i in range(1,len(logs)):\\n            units = logs[i][1] - logs[i-1][1]\\n\\n            # if multiples employees have same units of work\\n            # ID is the minimum of the employee ids\\n            if units == m:\\n                ID = min(ID, logs[i][0])\\n\\n            else:\\n                # computes the maximum units of work done by an \\n                # employee and stores it\\'s ID\\n                m, ID = max([m, ID], [units , logs[i][0]]) \\n            \\n        return ID\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n\\n        m, ID = logs[0][1], logs[0][0]\\n\\n        for i in range(1,len(logs)):\\n            units = logs[i][1] - logs[i-1][1]\\n\\n            # if multiples employees have same units of work\\n            # ID is the minimum of the employee ids\\n            if units == m:\\n                ID = min(ID, logs[i][0])\\n\\n            else:\\n                # computes the maximum units of work done by an \\n                # employee and stores it\\'s ID\\n                m, ID = max([m, ID], [units , logs[i][0]]) \\n            \\n        return ID\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074644,
                "title": "with-explanation-comments-time-73-ms-88-25-space-35-6-mb-50-20",
                "content": "Time: 73 ms (88.25%), Space: 35.6 MB (50.20%)\\nTC: O(n)\\nSC: O(1)\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        \\n        int id=logs[0][0], dis=logs[0][1];\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<logs.size();i++){\\n            \\n            //calc the difference between the current and the previous\\n            int temp=logs[i][1]-logs[i-1][1];\\n            \\n            //save the highest temporary time difference & get the smaller id if the time is equal\\n            if(temp>dis || (temp==dis && id>logs[i][0])){\\n                dis=temp;\\n                id=logs[i][0];\\n            }\\n        }\\n        \\n        return id;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        \\n        int id=logs[0][0], dis=logs[0][1];\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<logs.size();i++){\\n            \\n            //calc the difference between the current and the previous\\n            int temp=logs[i][1]-logs[i-1][1];\\n            \\n            //save the highest temporary time difference & get the smaller id if the time is equal\\n            if(temp>dis || (temp==dis && id>logs[i][0])){\\n                dis=temp;\\n                id=logs[i][0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3070707,
                "title": "99ms-runtime-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction hardestWorker(n: number, logs: number[][]): number {\\n    let max = 0;\\n    let minId = n;\\n\\n    for(let i=0; i<logs.length; i++){\\n        if(i===0){\\n            max = logs[i][1];\\n            minId = logs[i][0];\\n        }\\n        else {\\n            if(logs[i][1]-logs[i-1][1] > max){\\n                max = Math.max(max, logs[i][1]-logs[i-1][1]);\\n                minId = logs[i][0];\\n            }\\n            else if(logs[i][1]-logs[i-1][1] === max){\\n                minId = Math.min(minId, logs[i][0]);\\n            }\\n\\n        }\\n    }\\n\\n    return minId;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction hardestWorker(n: number, logs: number[][]): number {\\n    let max = 0;\\n    let minId = n;\\n\\n    for(let i=0; i<logs.length; i++){\\n        if(i===0){\\n            max = logs[i][1];\\n            minId = logs[i][0];\\n        }\\n        else {\\n            if(logs[i][1]-logs[i-1][1] > max){\\n                max = Math.max(max, logs[i][1]-logs[i-1][1]);\\n                minId = logs[i][0];\\n            }\\n            else if(logs[i][1]-logs[i-1][1] === max){\\n                minId = Math.min(minId, logs[i][0]);\\n            }\\n\\n        }\\n    }\\n\\n    return minId;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068728,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int start = 0, len = logs.length, max = Integer.MIN_VALUE, index = 0;\\n        for(int i=0; i<len; i++) {\\n            int curr = logs[i][1]-start;\\n            start = logs[i][1]; \\n            if(curr > max) {\\n                max = curr;\\n                index = i;\\n            }\\n            else if(curr == max) {\\n                if(logs[index][0] > logs[i][0]) index = i;\\n            }\\n        }\\n        return logs[index][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int start = 0, len = logs.length, max = Integer.MIN_VALUE, index = 0;\\n        for(int i=0; i<len; i++) {\\n            int curr = logs[i][1]-start;\\n            start = logs[i][1]; \\n            if(curr > max) {\\n                max = curr;\\n                index = i;\\n            }\\n            else if(curr == max) {\\n                if(logs[index][0] > logs[i][0]) index = i;\\n            }\\n        }\\n        return logs[index][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068515,
                "title": "easy-to-understand-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let employeeId = logs[0][0];\\n    let longestWorked = logs[0][1];\\n\\n    for(let i = 1; i < logs.length; i++) {\\n        const startLog = logs[i - 1];\\n        const endLog = logs[i];\\n        const worked = endLog[1] - startLog[1];\\n        const currentEmployeeId = endLog[0];\\n        if(worked > longestWorked) {\\n            longestWorked = worked;\\n            employeeId = currentEmployeeId;\\n        } else if (worked === longestWorked) {\\n            employeeId = Math.min(employeeId, currentEmployeeId);\\n        }\\n    }\\n    \\n    return employeeId;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} logs\\n * @return {number}\\n */\\nvar hardestWorker = function(n, logs) {\\n    let employeeId = logs[0][0];\\n    let longestWorked = logs[0][1];\\n\\n    for(let i = 1; i < logs.length; i++) {\\n        const startLog = logs[i - 1];\\n        const endLog = logs[i];\\n        const worked = endLog[1] - startLog[1];\\n        const currentEmployeeId = endLog[0];\\n        if(worked > longestWorked) {\\n            longestWorked = worked;\\n            employeeId = currentEmployeeId;\\n        } else if (worked === longestWorked) {\\n            employeeId = Math.min(employeeId, currentEmployeeId);\\n        }\\n    }\\n    \\n    return employeeId;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3067784,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func hardestWorker(_ n: Int, _ logs: [[Int]]) -> Int {\\n        zip([[-1, 0]] + logs.dropLast(), logs)\\n            .reduce(into: [Int: [Int]]()) { $0[$1.1[1] - $1.0[1], default: []].append($1.1[0]) }\\n            .sorted { $0.key > $1.key }\\n            .first!\\n            .value\\n            .sorted()\\n            .first!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func hardestWorker(_ n: Int, _ logs: [[Int]]) -> Int {\\n        zip([[-1, 0]] + logs.dropLast(), logs)\\n            .reduce(into: [Int: [Int]]()) { $0[$1.1[1] - $1.0[1], default: []].append($1.1[0]) }\\n            .sorted { $0.key > $1.key }\\n            .first!\\n            .value\\n            .sorted()\\n            .first!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064094,
                "title": "java-1ms-100-runtime-o-n",
                "content": "\\n\\n\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int longestPeriodOfWork = logs[0][1];\\n        int workerId = logs[0][0];\\n\\n        for (int i = 1; i < logs.length; i++) {\\n            int currentPeriodOfWork = logs[i][1] - logs[i-1][1];\\n            if (currentPeriodOfWork > longestPeriodOfWork) {\\n                longestPeriodOfWork = currentPeriodOfWork;\\n                workerId = logs[i][0];\\n            } else if (currentPeriodOfWork == longestPeriodOfWork) {\\n                workerId = workerId < logs[i][0] ? workerId : logs[i][0];\\n            }\\n        }\\n        return workerId;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int longestPeriodOfWork = logs[0][1];\\n        int workerId = logs[0][0];\\n\\n        for (int i = 1; i < logs.length; i++) {\\n            int currentPeriodOfWork = logs[i][1] - logs[i-1][1];\\n            if (currentPeriodOfWork > longestPeriodOfWork) {\\n                longestPeriodOfWork = currentPeriodOfWork;\\n                workerId = logs[i][0];\\n            } else if (currentPeriodOfWork == longestPeriodOfWork) {\\n                workerId = workerId < logs[i][0] ? workerId : logs[i][0];\\n            }\\n        }\\n        return workerId;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037196,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        map<int, int> my_map;\\n        for(int i=0;i<logs.size();i++) {\\n            if(i == 0) {\\n                my_map[logs[i][0]] = logs[i][1];\\n            }else {\\n                int time_interval = logs[i][1] - logs[i-1][1];\\n                my_map[logs[i][0]] = max(my_map[logs[i][0]], time_interval);\\n            }\\n        }\\n        \\n        int largest_time = 0;\\n        int index = -1;\\n        for(auto& ele: my_map) {\\n             if(ele.second > largest_time) {\\n                 index = ele.first;\\n                 largest_time = ele.second;\\n             }\\n        }\\n\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) {\\n        map<int, int> my_map;\\n        for(int i=0;i<logs.size();i++) {\\n            if(i == 0) {\\n                my_map[logs[i][0]] = logs[i][1];\\n            }else {\\n                int time_interval = logs[i][1] - logs[i-1][1];\\n                my_map[logs[i][0]] = max(my_map[logs[i][0]], time_interval);\\n            }\\n        }\\n        \\n        int largest_time = 0;\\n        int index = -1;\\n        for(auto& ele: my_map) {\\n             if(ele.second > largest_time) {\\n                 index = ele.first;\\n                 largest_time = ele.second;\\n             }\\n        }\\n\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026841,
                "title": "python-solution-with-zip",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPad `[-1, 0]` in front of `logs` for convenience. \\nIterate through the `logs` and calculate elapsed time.\\nIf a longer time is found, set the employee id to current one.\\nIf the elapsed time is equal current longest one, then set the employee id to the smallest one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n\\n        logs = [[-1, 0]] + logs\\n        longest = float(\"-inf\")\\n        res = -1\\n        for prev, curr in zip(logs, logs[1:]):\\n            units = curr[1] - prev[1]\\n            if units > longest:\\n                longest = max(longest, units)\\n                res = curr[0]\\n            elif units == longest:\\n                res = min(res, curr[0])\\n        return res\\n\\n```\\n**Please upvote if you found this helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n\\n        logs = [[-1, 0]] + logs\\n        longest = float(\"-inf\")\\n        res = -1\\n        for prev, curr in zip(logs, logs[1:]):\\n            units = curr[1] - prev[1]\\n            if units > longest:\\n                longest = max(longest, units)\\n                res = curr[0]\\n            elif units == longest:\\n                res = min(res, curr[0])\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013285,
                "title": "python-power-of-lists",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        out = [logs[0][1]-0]\\n        for i in range(1, len(logs)):\\n            out.append(logs[i][1] - logs[i-1][1])\\n        max_val = max(out)\\n        allx = []\\n        for v in out:\\n            if v == max_val:\\n                allx.append(logs[out.index(v)][0])\\n                out[out.index(v)] = \"$\"\\n        return min(allx)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\\n        out = [logs[0][1]-0]\\n        for i in range(1, len(logs)):\\n            out.append(logs[i][1] - logs[i-1][1])\\n        max_val = max(out)\\n        allx = []\\n        for v in out:\\n            if v == max_val:\\n                allx.append(logs[out.index(v)][0])\\n                out[out.index(v)] = \"$\"\\n        return min(allx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011263,
                "title": "100-time-compelxity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int empid =  logs[0][0];\\n        int resTime = logs[0][1];\\n\\n        for(int i =1;i<logs.length;i++){\\n            int id =  logs[i][0];\\n            int time  = logs[i][1];\\n            int timeTaken =  time - logs[i-1][1]; \\n            if(timeTaken>resTime){\\n                resTime = timeTaken;\\n                empid = id;\\n            } else if(timeTaken==resTime && id<empid){\\n                resTime = timeTaken;\\n                empid = id;\\n            }\\n        }\\n\\n        return empid;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int empid =  logs[0][0];\\n        int resTime = logs[0][1];\\n\\n        for(int i =1;i<logs.length;i++){\\n            int id =  logs[i][0];\\n            int time  = logs[i][1];\\n            int timeTaken =  time - logs[i-1][1]; \\n            if(timeTaken>resTime){\\n                resTime = timeTaken;\\n                empid = id;\\n            } else if(timeTaken==resTime && id<empid){\\n                resTime = timeTaken;\\n                empid = id;\\n            }\\n        }\\n\\n        return empid;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998992,
                "title": "java-easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int a= 0;\\n        int b= 0;\\n        int c= 0;\\n        for (int[] l: logs) {\\n            int t = l[1] - c;\\n            if (t >= b) \\n            {\\n                a = t == b? Math.min(a, l[0]) : l[0];\\n                b = t;\\n            }\\n            c = l[1];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int hardestWorker(int n, int[][] logs) {\\n        int a= 0;\\n        int b= 0;\\n        int c= 0;\\n        for (int[] l: logs) {\\n            int t = l[1] - c;\\n            if (t >= b) \\n            {\\n                a = t == b? Math.min(a, l[0]) : l[0];\\n                b = t;\\n            }\\n            c = l[1];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991721,
                "title": "c-easy-no-extra-space-with-proof",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/4e8ccbec-af1a-4667-a243-74e8563a91bc_1672740547.2533376.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n        int ans=0, a1=0,a2=0, u=-1;\\n        for(int i=0; i<logs.size(); i++){\\n            a2 = logs[i][1];\\n            if(a2-a1 > u){\\n                u=a2-a1;\\n                ans=logs[i][0];\\n            }\\n            else if(a2-a1==u && logs[i][0]<ans){\\n                ans=logs[i][0];\\n            }\\n            else{\\n                \\n            }\\n            a1=logs[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int hardestWorker(int n, vector<vector<int>>& logs) \\n    {\\n        int ans=0, a1=0,a2=0, u=-1;\\n        for(int i=0; i<logs.size(); i++){\\n            a2 = logs[i][1];\\n            if(a2-a1 > u){\\n                u=a2-a1;\\n                ans=logs[i][0];\\n            }\\n            else if(a2-a1==u && logs[i][0]<ans){\\n                ans=logs[i][0];\\n            }\\n            else{\\n                \\n            }\\n            a1=logs[i][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1741574,
                "content": [
                    {
                        "username": "smallGinger",
                        "content": "What\\'s the purpose of the first argument n then?"
                    },
                    {
                        "username": "victorliang85",
                        "content": "The value of n is irrelevant?"
                    },
                    {
                        "username": "Ashish_El",
                        "content": "[[0,10],[1,20]] here expected output is 0 and for [[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]]  expected output is 12 . In first case they took first maximum but in next case they took last max"
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "Time is same but 12 is lesser than 36.\nso 12 is answer\n"
                    },
                    {
                        "username": "ayush70781",
                        "content": "As we have to return the logs with minimum id if there is a tie in one or more entries."
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "n=70;\\nlogs=[[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]];\\n\\nmy output : 36\\n\\nthen why ans is 12"
                    },
                    {
                        "username": "untamed_coder",
                        "content": "the id with min value has to be returned in the case of same working time ..check for my solution for better reference "
                    },
                    {
                        "username": "Suffolk",
                        "content": "why them give me \\'n\\'? If id is already in logs array, we don\\'t need it."
                    }
                ]
            },
            {
                "id": 1763740,
                "content": [
                    {
                        "username": "smallGinger",
                        "content": "What\\'s the purpose of the first argument n then?"
                    },
                    {
                        "username": "victorliang85",
                        "content": "The value of n is irrelevant?"
                    },
                    {
                        "username": "Ashish_El",
                        "content": "[[0,10],[1,20]] here expected output is 0 and for [[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]]  expected output is 12 . In first case they took first maximum but in next case they took last max"
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "Time is same but 12 is lesser than 36.\nso 12 is answer\n"
                    },
                    {
                        "username": "ayush70781",
                        "content": "As we have to return the logs with minimum id if there is a tie in one or more entries."
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "n=70;\\nlogs=[[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]];\\n\\nmy output : 36\\n\\nthen why ans is 12"
                    },
                    {
                        "username": "untamed_coder",
                        "content": "the id with min value has to be returned in the case of same working time ..check for my solution for better reference "
                    },
                    {
                        "username": "Suffolk",
                        "content": "why them give me \\'n\\'? If id is already in logs array, we don\\'t need it."
                    }
                ]
            },
            {
                "id": 1637468,
                "content": [
                    {
                        "username": "smallGinger",
                        "content": "What\\'s the purpose of the first argument n then?"
                    },
                    {
                        "username": "victorliang85",
                        "content": "The value of n is irrelevant?"
                    },
                    {
                        "username": "Ashish_El",
                        "content": "[[0,10],[1,20]] here expected output is 0 and for [[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]]  expected output is 12 . In first case they took first maximum but in next case they took last max"
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "Time is same but 12 is lesser than 36.\nso 12 is answer\n"
                    },
                    {
                        "username": "ayush70781",
                        "content": "As we have to return the logs with minimum id if there is a tie in one or more entries."
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "n=70;\\nlogs=[[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]];\\n\\nmy output : 36\\n\\nthen why ans is 12"
                    },
                    {
                        "username": "untamed_coder",
                        "content": "the id with min value has to be returned in the case of same working time ..check for my solution for better reference "
                    },
                    {
                        "username": "Suffolk",
                        "content": "why them give me \\'n\\'? If id is already in logs array, we don\\'t need it."
                    }
                ]
            },
            {
                "id": 2000810,
                "content": [
                    {
                        "username": "smallGinger",
                        "content": "What\\'s the purpose of the first argument n then?"
                    },
                    {
                        "username": "victorliang85",
                        "content": "The value of n is irrelevant?"
                    },
                    {
                        "username": "Ashish_El",
                        "content": "[[0,10],[1,20]] here expected output is 0 and for [[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]]  expected output is 12 . In first case they took first maximum but in next case they took last max"
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "Time is same but 12 is lesser than 36.\nso 12 is answer\n"
                    },
                    {
                        "username": "ayush70781",
                        "content": "As we have to return the logs with minimum id if there is a tie in one or more entries."
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "n=70;\\nlogs=[[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]];\\n\\nmy output : 36\\n\\nthen why ans is 12"
                    },
                    {
                        "username": "untamed_coder",
                        "content": "the id with min value has to be returned in the case of same working time ..check for my solution for better reference "
                    },
                    {
                        "username": "Suffolk",
                        "content": "why them give me \\'n\\'? If id is already in logs array, we don\\'t need it."
                    }
                ]
            },
            {
                "id": 1831653,
                "content": [
                    {
                        "username": "smallGinger",
                        "content": "What\\'s the purpose of the first argument n then?"
                    },
                    {
                        "username": "victorliang85",
                        "content": "The value of n is irrelevant?"
                    },
                    {
                        "username": "Ashish_El",
                        "content": "[[0,10],[1,20]] here expected output is 0 and for [[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]]  expected output is 12 . In first case they took first maximum but in next case they took last max"
                    },
                    {
                        "username": "KARUPPIAH_AL",
                        "content": "Time is same but 12 is lesser than 36.\nso 12 is answer\n"
                    },
                    {
                        "username": "ayush70781",
                        "content": "As we have to return the logs with minimum id if there is a tie in one or more entries."
                    },
                    {
                        "username": "sujalpdevarathnam",
                        "content": "n=70;\\nlogs=[[36,3],[1,5],[12,8],[25,9],[53,11],[29,12],[52,14]];\\n\\nmy output : 36\\n\\nthen why ans is 12"
                    },
                    {
                        "username": "untamed_coder",
                        "content": "the id with min value has to be returned in the case of same working time ..check for my solution for better reference "
                    },
                    {
                        "username": "Suffolk",
                        "content": "why them give me \\'n\\'? If id is already in logs array, we don\\'t need it."
                    }
                ]
            }
        ]
    }
]