[
    {
        "title": "Add Binary",
        "question_content": "Given two binary strings a and b, return their sum as a binary string.\n&nbsp;\nExample 1:\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n&nbsp;\nConstraints:\n\n\t1 <= a.length, b.length <= 104\n\ta and b consist&nbsp;only of '0' or '1' characters.\n\tEach string does not contain leading zeros except for the zero itself.",
        "solutions": [
            {
                "id": 24488,
                "title": "short-ac-solution-in-java-with-explanation",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sb = new StringBuilder();\\n            int i = a.length() - 1, j = b.length() -1, carry = 0;\\n            while (i >= 0 || j >= 0) {\\n                int sum = carry;\\n                if (j >= 0) sum += b.charAt(j--) - '0';\\n                if (i >= 0) sum += a.charAt(i--) - '0';\\n                sb.append(sum % 2);\\n                carry = sum / 2;\\n            }\\n            if (carry != 0) sb.append(carry);\\n            return sb.reverse().toString();\\n        }\\n    }\\n\\nComputation from string usually can be simplified by using a carry as such.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sb = new StringBuilder();\\n            int i = a.length() - 1, j = b.length() -1, carry = 0;\\n            while (i >= 0 || j >= 0) {\\n                int sum = carry;\\n                if (j >= 0) sum += b.charAt(j--) - '0';\\n                if (i >= 0) sum += a.charAt(i--) - '0';\\n                sb.append(sum % 2);\\n                carry = sum / 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1679423,
                "title": "well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it",
                "content": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT INFO FOR YOU\\n```\\n* If, you are preperaing for `FACEBOOK interview` or will prepare. Then according to `LeetCode premium` it is no.4 most asked Question by **Facebook** as per now.\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\n`What question saying is, Given two binary strings a and b, return their sum as a binary string.`\\n\\n**Approach Explained :**\\n\\n**Summary of Below Explanation :**\\n\\n*The overall idea is to make up the short two strings with 00 to make the two strings have the same length, and then traverse and calculate from the end to get the final result.*\\n\\nLet\\'s understand with an **example** : Addition of **1 and 1** will lead to **carry 1** and **print 0** , Addition of **1 and 0** give us **1 as carry** will lead **print 0** , Addition of last remaning **carry 1** with no body will lead to **print 1** , So, we get something like **\"1 0 0\"** as answer\\nOne **key point** total addition will be 3 then print 1 and carry will remain 1\\n\\n**Detailed Explaination :**\\n\\nSo, first do we understand how do we perform **binary addition**. **Take an example**, given two numbers **\"11\" + \"1\"** where **\"11\"** is representing **\"3\"** & **\"1\"** is **\"1\"**, in decimal form. \\nNow let\\'s perform **binary addition** it\\'s very **similar to the decimal addition** that we do. In decimal what we do we add 2 numbers & if it goes beyond 9 we **take a carry**. And here also we have a **number in range 0 - 1**, **2 values over here** & in **Decimal range is 0 - 9**, **10 values** are there. So, in binary what it means is if result more **than 1**, there **is a carry** otherwise **no carry**.\\nLet me show you in diagram:\\n![image](https://assets.leetcode.com/users/images/fcd956d9-2703-41fe-90ad-57c49e227799_1641778567.285665.png)\\n\\n\\n* So, what\\'s going in diagram is **intially carry is \"0\"** we **add 1 + 1** we **get 2** which is more **then 1**, so there is a **carry of 1** and **result is 0**. Now we have **carry of 1**, **again 1 + 1 is 0**, and still left with **carry of 1**. And the **last carry** one will be **return as it is**. \\n* So, if you see this binary number it is **[2^2 * 1 + 2^1 * 0 + 2^0 * 0]** and this is the decimal coversion of **[1 0 0]** which **is 4**. \\n\\n![image](https://assets.leetcode.com/users/images/b12c2264-ddf0-4709-a761-4bfa3becdd95_1641779179.1482372.png)\\n\\n**Hope you got the point **\\n\\n*Now, let\\'s code it up:*\\n**code, each lne explained :** `Similar for C++, Java, Python` **{Only synatx difference}** approach is same\\n\\n* Step 1:\\n```\\n{\\n// First, create result name string and intially it is empty & in the end we gonna return it as our aswer\\n        StringBuilder res = new StringBuilder(); \\n        int i = a.length() - 1; // we crete i pointer for string a and we have to start adding from right to left \\n        int j = b.length() - 1; // similar pointer j for string b\\n        int carry = 0; // we create a carry, as we have to consider it as well\\n```\\n* Step 2:\\n```\\n// iterate over the loop until the both condition become false\\n        while(i >= 0 || j >= 0){ \\n            int sum = carry; // intialise our sum with carry;\\n            \\n            // Now, we subtract by \\'0\\' to convert the numbers from a char type into an int, so we can perform operations on the numbers\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            // taking carry;\\n            carry = sum > 1 ? 1 : 0; // getting carry depend on the quotient we get by dividing sum / 2 that will be our carry. Carry could be either 1 or 0 \\n\\t\\t\\t// if sum is 0 res is 1 & then carry would be 0;\\n            // if sum is 1 res is 1 & carry would be 0\\n            // if sum is 2 res is 0 & carry would be 1\\n            // if sum is 3 res is 1 & carry would be 1\\n            res.append(sum % 2); // just moduling the sum so, we can get remainder and add it into our result\\n        }\\n```\\n* Final Step:\\n```\\nif(carry != 0) res.append(carry); // we gonna add it into res until carry becomes 0;\\n        return res.reverse().toString(); // revese the answer we get & convt to string and return by the help of result;\\n```\\n* Let\\'s combine each line of code\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder res = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res.append(sum % 2);\\n        }\\n        if(carry != 0) res.append(carry);\\n        return res.reverse().toString();\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res += to_string(sum % 2);\\n        }\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = \"\"\\n        i, j, carry = len(a) - 1, len(b) - 1, 0\\n        while i >= 0 or j >= 0:\\n            sum = carry;\\n            if i >= 0 : sum += ord(a[i]) - ord(\\'0\\') # ord is use to get value of ASCII character\\n            if j >= 0 : sum += ord(b[j]) - ord(\\'0\\')\\n            i, j = i - 1, j - 1\\n            carry = 1 if sum > 1 else 0;\\n            res += str(sum % 2)\\n\\n        if carry != 0 : res += str(carry);\\n        return res[::-1]\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(max(M, N)), M & N is the length of string a, b;\\n\\n* **Space Complexity :-** BigO(max(M, N)), which is the size of \"res\" object\\n\\n**Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F**\\n`If you have some \\uD83E\\uDD14 doubts feel free to bug me`",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# IMPORTANT INFO FOR YOU\\n```\n```\\n{\\n// First, create result name string and intially it is empty & in the end we gonna return it as our aswer\\n        StringBuilder res = new StringBuilder(); \\n        int i = a.length() - 1; // we crete i pointer for string a and we have to start adding from right to left \\n        int j = b.length() - 1; // similar pointer j for string b\\n        int carry = 0; // we create a carry, as we have to consider it as well\\n```\n```\\n// iterate over the loop until the both condition become false\\n        while(i >= 0 || j >= 0){ \\n            int sum = carry; // intialise our sum with carry;\\n            \\n            // Now, we subtract by \\'0\\' to convert the numbers from a char type into an int, so we can perform operations on the numbers\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            // taking carry;\\n            carry = sum > 1 ? 1 : 0; // getting carry depend on the quotient we get by dividing sum / 2 that will be our carry. Carry could be either 1 or 0 \\n\\t\\t\\t// if sum is 0 res is 1 & then carry would be 0;\\n            // if sum is 1 res is 1 & carry would be 0\\n            // if sum is 2 res is 0 & carry would be 1\\n            // if sum is 3 res is 1 & carry would be 1\\n            res.append(sum % 2); // just moduling the sum so, we can get remainder and add it into our result\\n        }\\n```\n```\\nif(carry != 0) res.append(carry); // we gonna add it into res until carry becomes 0;\\n        return res.reverse().toString(); // revese the answer we get & convt to string and return by the help of result;\\n```\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder res = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a.charAt(i--) - \\'0\\';\\n            if(j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res.append(sum % 2);\\n        }\\n        if(carry != 0) res.append(carry);\\n        return res.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            res += to_string(sum % 2);\\n        }\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = \"\"\\n        i, j, carry = len(a) - 1, len(b) - 1, 0\\n        while i >= 0 or j >= 0:\\n            sum = carry;\\n            if i >= 0 : sum += ord(a[i]) - ord(\\'0\\') # ord is use to get value of ASCII character\\n            if j >= 0 : sum += ord(b[j]) - ord(\\'0\\')\\n            i, j = i - 1, j - 1\\n            carry = 1 if sum > 1 else 0;\\n            res += str(sum % 2)\\n\\n        if carry != 0 : res += str(carry);\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24475,
                "title": "short-code-by-c",
                "content": "    class Solution\\n    {\\n    public:\\n        string addBinary(string a, string b)\\n        {\\n            string s = \"\";\\n            \\n            int c = 0, i = a.size() - 1, j = b.size() - 1;\\n            while(i >= 0 || j >= 0 || c == 1)\\n            {\\n                c += i >= 0 ? a[i --] - '0' : 0;\\n                c += j >= 0 ? b[j --] - '0' : 0;\\n                s = char(c % 2 + '0') + s;\\n                c /= 2;\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        string addBinary(string a, string b)\\n        {\\n            string s = \"\";\\n            \\n            int c = 0, i = a.size() - 1, j = b.size() - 1;\\n            while(i >= 0 || j >= 0 || c == 1)\\n            {\\n                c += i >= 0 ? a[i --] - '0' : 0;\\n                c += j >= 0 ? b[j --] - '0' : 0;\\n                s = char(c % 2 + '0') + s;\\n                c /= 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3183205,
                "title": "1ms-beats-100-full-explanation-append-reverse-c-java-python3",
                "content": "# Intuition :\\n- We have to add two binary numbers (made up of 0\\'s and 1\\'s) and returns the result in binary.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- We start at the right end of each binary number, adding the digits and any carry-over value, and storing the result in a new string. \\n- Now we move to the next digit on the left and repeats the process until it has gone through all the digits in both binary numbers.\\n- If there is any carry-over value after adding all the digits,  append it to the end of the new string. \\n- Finally, the new string is reversed and returned as the sum of the two binary numbers.\\n<!-- Describe your approach to solving the problem. -->\\n# Explanation to Approach :\\n- Suppose we want to add two binary numbers - \"1010\" and \"1101\". \\n- To add these two numbers, we can use the given function as follows:\\n- First, we initialize a StringBuilder object to store the sum and two integer variables \\'carry\\' and \\'i\\' to keep track of the carry-over value and the current position in the first binary number (a), respectively. \\n- We also initialize another integer variable \\'j\\' to keep track of the current position in the second binary number (b). Here is how the code initializes these variables:\\n```\\nStringBuilder sb = new StringBuilder();\\nint carry = 0;\\nint i = a.length() - 1;\\nint j = b.length() - 1;\\n\\n```\\n- Next, we enter a while loop that iterates until we have processed all digits in both binary numbers and there is no more carry-over value left. In each iteration, we add the digits from both numbers at the current position and the carry-over value (if any), and append the result to the StringBuilder object. \\n- We also update the carry-over value based on the sum of the digits. Here is the code for this step:\\n```\\nwhile (i >= 0 || j >= 0 || carry == 1) {\\n    if (i >= 0) {\\n        carry += a.charAt(i--) - \\'0\\';\\n    }\\n    if (j >= 0) {\\n        carry += b.charAt(j--) - \\'0\\';\\n    }\\n    sb.append(carry % 2);\\n    carry /= 2;\\n}\\n\\n```\\n- In each iteration, the current position in each binary number is moved one digit to the left (if there are any digits left to process) by decrementing the value of i and j. \\n- If there is a carry-over value from the previous iteration or the addition of the two digits produces a carry-over value, we set the value of \\'carry\\' to 1; otherwise, we set it to 0. \\n- We also append the sum of the digits to the StringBuilder object by computing the remainder of \\'carry\\' divided by 2 (which is either 0 or 1). \\n- Finally, we update the value of \\'carry\\' by dividing it by 2 (which gives either 0 or 1) so that we can carry over any remaining value to the next iteration.\\n- After the while loop completes, we reverse the StringBuilder object and convert it to a string using the toString() method. \\n- This gives us the sum of the two binary numbers in binary format. Here is the final code:\\n```\\nreturn sb.reverse().toString();\\n\\n```\\n# Example : the sum of \"1010\" and \"1101\\n```\\n     1010\\n    +1101\\n    ______\\n    10111\\n```\\n\\n# Complexity\\n- Time complexity : O(max|a|,|b|)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(max|a|,|b|)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] \\n```C++ []\\nclass Solution {\\n public:\\n  string addBinary(string a, string b) {\\n    string ans;\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry) {\\n      if (i >= 0)\\n        carry += a[i--] - \\'0\\';\\n      if (j >= 0)\\n        carry += b[j--] - \\'0\\';\\n      ans += carry % 2 + \\'0\\';\\n      carry /= 2;\\n    }\\n\\n    reverse(begin(ans), end(ans));\\n    return ans;\\n  }\\n};\\n```\\n```Java []\\nclass Solution \\n{\\n  public String addBinary(String a, String b) \\n  {\\n    StringBuilder sb = new StringBuilder();\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry == 1) \\n    {\\n      if(i >= 0)\\n        carry += a.charAt(i--) - \\'0\\';\\n      if(j >= 0)\\n        carry += b.charAt(j--) - \\'0\\';\\n      sb.append(carry % 2);\\n      carry /= 2;\\n    }\\n    return sb.reverse().toString();\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def addBinary(self, a: str, b: str) -> str:\\n    s = []\\n    carry = 0\\n    i = len(a) - 1\\n    j = len(b) - 1\\n\\n    while i >= 0 or j >= 0 or carry:\\n      if i >= 0:\\n        carry += int(a[i])\\n        i -= 1\\n      if j >= 0:\\n        carry += int(b[j])\\n        j -= 1\\n      s.append(str(carry % 2))\\n      carry //= 2\\n\\n    return \\'\\'.join(reversed(s))\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/fe5d77d5-39f2-4839-9fcf-41c50106b04f_1676347139.1033723.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nStringBuilder sb = new StringBuilder();\\nint carry = 0;\\nint i = a.length() - 1;\\nint j = b.length() - 1;\\n\\n```\n```\\nwhile (i >= 0 || j >= 0 || carry == 1) {\\n    if (i >= 0) {\\n        carry += a.charAt(i--) - \\'0\\';\\n    }\\n    if (j >= 0) {\\n        carry += b.charAt(j--) - \\'0\\';\\n    }\\n    sb.append(carry % 2);\\n    carry /= 2;\\n}\\n\\n```\n```\\nreturn sb.reverse().toString();\\n\\n```\n```\\n     1010\\n    +1101\\n    ______\\n    10111\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  string addBinary(string a, string b) {\\n    string ans;\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry) {\\n      if (i >= 0)\\n        carry += a[i--] - \\'0\\';\\n      if (j >= 0)\\n        carry += b[j--] - \\'0\\';\\n      ans += carry % 2 + \\'0\\';\\n      carry /= 2;\\n    }\\n\\n    reverse(begin(ans), end(ans));\\n    return ans;\\n  }\\n};\\n```\n```Java []\\nclass Solution \\n{\\n  public String addBinary(String a, String b) \\n  {\\n    StringBuilder sb = new StringBuilder();\\n    int carry = 0;\\n    int i = a.length() - 1;\\n    int j = b.length() - 1;\\n\\n    while (i >= 0 || j >= 0 || carry == 1) \\n    {\\n      if(i >= 0)\\n        carry += a.charAt(i--) - \\'0\\';\\n      if(j >= 0)\\n        carry += b.charAt(j--) - \\'0\\';\\n      sb.append(carry % 2);\\n      carry /= 2;\\n    }\\n    return sb.reverse().toString();\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def addBinary(self, a: str, b: str) -> str:\\n    s = []\\n    carry = 0\\n    i = len(a) - 1\\n    j = len(b) - 1\\n\\n    while i >= 0 or j >= 0 or carry:\\n      if i >= 0:\\n        carry += int(a[i])\\n        i -= 1\\n      if j >= 0:\\n        carry += int(b[j])\\n        j -= 1\\n      s.append(str(carry % 2))\\n      carry //= 2\\n\\n    return \\'\\'.join(reversed(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279879,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \\'\\'\\n\\n        a = list(a)\\n        b = list(b)\\n\\n        while a or b or carry:\\n            if a:\\n                carry += int(a.pop())\\n            if b:\\n                carry += int(b.pop())\\n\\n            result += str(carry %2)\\n            carry //= 2\\n\\n        return result[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \\'\\'\\n\\n        a = list(a)\\n        b = list(b)\\n\\n        while a or b or carry:\\n            if a:\\n                carry += int(a.pop())\\n            if b:\\n                carry += int(b.pop())\\n\\n            result += str(carry %2)\\n            carry //= 2\\n\\n        return result[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680021,
                "title": "very-simple-o-n-c-solution",
                "content": "**Adding 2 binary bits :\\n0 + 0 = 0\\n1 + 0 = 1\\n0 + 1 = 1\\n1 + 1 = 10**\\n```\\nstring addBinary(string a, string b) {\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry = carry/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```\\n\\n\\n**Important point to note:**    (Reference - [here](http://codeforces.com/blog/entry/66660))\\n- `a = a + \"xy\"`\\xA0is O(N) while\\xA0`a += \"xy\"`\\xA0is O(1) (amortized).\\n    \\n    `a = a + \"xy\"`\\xA0creates a\\xA0`copy of a`, appends \"xy\" and then assigns it back to\\xA0`a`.\\n    \\n    `a += \"xy\"`\\xA0just appends \"xy\" to\\xA0`a`.\\n\\t\\nTherefore the time complexity of this approach is O(n).\\n\\n***Please Upvote, if you find the solution helpful!***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring addBinary(string a, string b) {\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry = carry/2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24500,
                "title": "an-accepted-concise-python-recursive-solution-10-lines",
                "content": "#add two binary from back to front, I think it is very self explained, when 1+1 we need a carry.\\n\\t#The time complex is O(m+n+c)\\uFF0Cit\\'s linear, where m=len(a)\\uFF0Cn=len(b) and c=\"count of carries, which is less than min(m,n)\".\\n\\n\\n       class Solution:\\n            def addBinary(self, a, b):\\n                if len(a)==0: return b\\n                if len(b)==0: return a\\n                if a[-1] == \\'1\\' and b[-1] == \\'1\\':\\n                    return self.addBinary(self.addBinary(a[0:-1],b[0:-1]),\\'1\\')+\\'0\\'\\n                if a[-1] == \\'0\\' and b[-1] == \\'0\\':\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'0\\'\\n                else:\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'1\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "#add two binary from back to front, I think it is very self explained, when 1+1 we need a carry.\\n\\t#The time complex is O(m+n+c)\\uFF0Cit\\'s linear, where m=len(a)\\uFF0Cn=len(b) and c=\"count of carries, which is less than min(m,n)\".\\n\\n\\n       class Solution:\\n            def addBinary(self, a, b):\\n                if len(a)==0: return b\\n                if len(b)==0: return a\\n                if a[-1] == \\'1\\' and b[-1] == \\'1\\':\\n                    return self.addBinary(self.addBinary(a[0:-1],b[0:-1]),\\'1\\')+\\'0\\'\\n                if a[-1] == \\'0\\' and b[-1] == \\'0\\':\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'0\\'\\n                else:\\n                    return self.addBinary(a[0:-1],b[0:-1])+\\'1\\'",
                "codeTag": "Java"
            },
            {
                "id": 3183091,
                "title": "c-explained-beginner-friendly-approach-self-explanatory-clean-code",
                "content": "\\n\\n# Code\\n\\n# Please Do Upvote!!!!\\n##### Connect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\\n\\n\\n**The Approach goes same as like how we add two binary numbers manually firstly we have to make sizes of both the strings equal ie. the smaller sized one is to be made equal by adding zeroes at its left. then we have to handle all the caes ie. ( 11, 10, 01, 00), and we will also require a carry that will store the carry, at every step we add the values at the positions along with carry using the boolean algebra, and store carry accordingly, finally if carry is \"1\", then obviously the sum that we are getting is one bit larger than the numbers we had earlier, finally return the string**\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string addBinary(string a, string b) {\\n        \\n        \\n        if(b.size() > a.size()) swap(a,b);\\n        \\n        \\n        while(b.size() < a.size()) b = \"0\" + b;\\n\\n        int carry = 0;\\n\\n        string res = \"\";\\n\\n        for(int i = b.size()-1; i >= 0 ; --i)\\n        {\\n             \\n             if(b[i] == \\'1\\' && a[i]==\\'1\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                \\n                else res = \"1\" + res;\\n                    \\n                carry = 1;\\n             }\\n\\n             else if(b[i] ==\\'0\\' && a[i] ==\\'0\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                 \\n                else\\n                {\\n                    res = \"1\" + res;\\n                    carry = 0;\\n                }\\n             }\\n\\n             else if((b[i]==\\'0\\' && a[i]==\\'1\\') || (b[i]==\\'1\\' && a[i] == \\'0\\'))\\n             {\\n                 \\n                if(carry == 0) res = \"1\" + res;\\n                 \\n                else res = \"0\" + res;\\n                 \\n             }\\n             \\n        }\\n        \\n        if(carry == 1) res = \"1\" + res;\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/98b7adbc-5abf-45f7-9b5b-538574194654_1676344687.6513524.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string addBinary(string a, string b) {\\n        \\n        \\n        if(b.size() > a.size()) swap(a,b);\\n        \\n        \\n        while(b.size() < a.size()) b = \"0\" + b;\\n\\n        int carry = 0;\\n\\n        string res = \"\";\\n\\n        for(int i = b.size()-1; i >= 0 ; --i)\\n        {\\n             \\n             if(b[i] == \\'1\\' && a[i]==\\'1\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                \\n                else res = \"1\" + res;\\n                    \\n                carry = 1;\\n             }\\n\\n             else if(b[i] ==\\'0\\' && a[i] ==\\'0\\')\\n             {\\n\\n                if(carry == 0) res = \"0\" + res;\\n                 \\n                else\\n                {\\n                    res = \"1\" + res;\\n                    carry = 0;\\n                }\\n             }\\n\\n             else if((b[i]==\\'0\\' && a[i]==\\'1\\') || (b[i]==\\'1\\' && a[i] == \\'0\\'))\\n             {\\n                 \\n                if(carry == 0) res = \"1\" + res;\\n                 \\n                else res = \"0\" + res;\\n                 \\n             }\\n             \\n        }\\n        \\n        if(carry == 1) res = \"1\" + res;\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385148,
                "title": "simple-javascript-solution-using-bigint",
                "content": "Greetings comrades:\\n\\nBelow is my boring but clear solution, using the proposed [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) object.\\n\\nThe idea is to use inputs, `a` and `b` to build two binary literals.  Calculating the sum is done by calling the `BigInt` function on our binary literals, adding them together and returning the sum with a call to the `toString` method with 2 as the argument, since we are working with binary numbers.\\n\\n```javascript\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  const aBin = `0b${a}`\\n  const bBin = `0b${b}`\\n  const sum = BigInt(aBin) + BigInt(bBin)\\n  return sum.toString(2)\\n};\\n```\\n\\nThanks for looking at my solution.  Comments/feedback is appreciated. :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  const aBin = `0b${a}`\\n  const bBin = `0b${b}`\\n  const sum = BigInt(aBin) + BigInt(bBin)\\n  return sum.toString(2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24524,
                "title": "simple-accepted-java-solution",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            if(a == null || a.isEmpty()) {\\n                return b;\\n            }\\n            if(b == null || b.isEmpty()) {\\n                return a;\\n            }\\n            char[] aArray = a.toCharArray();\\n            char[] bArray = b.toCharArray();\\n            StringBuilder stb = new StringBuilder();\\n    \\n            int i = aArray.length - 1;\\n            int j = bArray.length - 1;\\n            int aByte;\\n            int bByte;\\n            int carry = 0;\\n            int result;\\n    \\n            while(i > -1 || j > -1 || carry == 1) {\\n                aByte = (i > -1) ? Character.getNumericValue(aArray[i--]) : 0;\\n                bByte = (j > -1) ? Character.getNumericValue(bArray[j--]) : 0;\\n                result = aByte ^ bByte ^ carry;\\n                carry = ((aByte + bByte + carry) >= 2) ? 1 : 0;\\n                stb.append(result);\\n            }\\n            return stb.reverse().toString();\\n        }\\n    }\\n\\nAddition bits are calculated by xor. Carry bit is calculated as simple integer addition.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            if(a == null || a.isEmpty()) {\\n                return b;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3182882,
                "title": "super-easy-solution-full-explanation-c-python3-java-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\nLet\\'s understand with an example : Addition of 1 and 1 will lead to carry 1 and print 0 , Addition of 1 and 0 give us 1 as carry will lead print 0 , Addition of last remaning carry 1 with no body will lead to print 1 , So, we get something like \"1 0 0\" as answer\\nOne key point total addition will be 3 then print 1 and carry will remain 1.\\n\\n**Adding 2 binary bits :**\\n        0 + 0 = 0\\n        1 + 0 = 1\\n        0 + 1 = 1\\n        1 + 1 = 10\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Example :**\\n- So, what\\'s going in diagram is intially **carry is \"0\"** we **add 1 + 1** we **get 2** which is **more then 1**, so there is a **carry of 1 and result is 0**. Now we have **carry of 1, again 1 + 1 is 0**, and **still left with carry of 1**. And the last carry one will be **return as it is**.\\n- So, if you see this binary number it is **[2^2 * 1 + 2^1 * 0 + 2^0 * 0]** and this is the decimal coversion of **[1 0 0] which is 4.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(max(n, m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(n, m))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider\\uD83D\\uDC4D\\n                            Thanks for visiting\\uD83D\\uDE0A\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // Function to add two binary numbers represented as strings\\n    string addBinary(string a, string b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while(i >= 0 || j >= 0 || carry) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if(i >= 0) {\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if(j >= 0) {\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans += (carry % 2 + \\'0\\');\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    \\n    # Function to add two binary numbers represented as strings\\n    def addBinary(self, a, b):\\n        # List to store the result\\n        result = []\\n        # Variable to store the carry-over value\\n        carry = 0\\n        \\n        # Initialize two pointers to traverse the binary strings from right to left\\n        i, j = len(a)-1, len(b)-1\\n        \\n        # Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while i >= 0 or j >= 0 or carry:\\n            total = carry\\n            \\n            # Add the current binary digit in string a, if the pointer is still within bounds\\n            if i >= 0:\\n                total += int(a[i])\\n                i -= 1\\n            \\n            # Add the current binary digit in string b, if the pointer is still within bounds\\n            if j >= 0:\\n                total += int(b[j])\\n                j -= 1\\n            \\n            # Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            result.append(str(total % 2))\\n            \\n            # Calculate the next carry-over value by dividing the sum by 2\\n            carry = total // 2\\n            \\n        # Reverse the result and join the elements to form a single string\\n        return \\'\\'.join(reversed(result))\\n\\n```\\n```Java []\\nclass Solution {\\n    // Function to add two binary numbers represented as strings\\n    public String addBinary(String a, String b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder ans = new StringBuilder();\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if (i >= 0) {\\n                carry += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if (j >= 0) {\\n                carry += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans.append(carry % 2);\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        return ans.reverse().toString();\\n    }\\n}\\n\\n```\\n\\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // Function to add two binary numbers represented as strings\\n    string addBinary(string a, string b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length()-1;\\n        int j = b.length()-1;\\n        string ans;\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while(i >= 0 || j >= 0 || carry) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if(i >= 0) {\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if(j >= 0) {\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans += (carry % 2 + \\'0\\');\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    \\n    # Function to add two binary numbers represented as strings\\n    def addBinary(self, a, b):\\n        # List to store the result\\n        result = []\\n        # Variable to store the carry-over value\\n        carry = 0\\n        \\n        # Initialize two pointers to traverse the binary strings from right to left\\n        i, j = len(a)-1, len(b)-1\\n        \\n        # Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while i >= 0 or j >= 0 or carry:\\n            total = carry\\n            \\n            # Add the current binary digit in string a, if the pointer is still within bounds\\n            if i >= 0:\\n                total += int(a[i])\\n                i -= 1\\n            \\n            # Add the current binary digit in string b, if the pointer is still within bounds\\n            if j >= 0:\\n                total += int(b[j])\\n                j -= 1\\n            \\n            # Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            result.append(str(total % 2))\\n            \\n            # Calculate the next carry-over value by dividing the sum by 2\\n            carry = total // 2\\n            \\n        # Reverse the result and join the elements to form a single string\\n        return \\'\\'.join(reversed(result))\\n\\n```\n```Java []\\nclass Solution {\\n    // Function to add two binary numbers represented as strings\\n    public String addBinary(String a, String b) {\\n        // Initialize two pointers to traverse the binary strings from right to left\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder ans = new StringBuilder();\\n        int carry = 0;\\n        \\n        // Loop until both pointers have reached the beginning of their respective strings and there is no carry-over value left\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            // Add the current binary digit in string a, if the pointer is still within bounds\\n            if (i >= 0) {\\n                carry += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            \\n            // Add the current binary digit in string b, if the pointer is still within bounds\\n            if (j >= 0) {\\n                carry += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            \\n            // Calculate the next binary digit in the result by taking the remainder of the sum divided by 2\\n            ans.append(carry % 2);\\n            \\n            // Calculate the next carry-over value by dividing the sum by 2\\n            carry = carry / 2;\\n        }\\n        \\n        // Reverse the result and return it as a string\\n        return ans.reverse().toString();\\n    }\\n}\\n\\n```\n```\\n                        Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017596,
                "title": "detail-explanation-easy-single-line-97-faster",
                "content": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(\"0b\"+a) + BigInt(\"0b\"+b)).toString(2);\\n}\\n```\\n**BigInt is used to represent Integers greater than 2^53 -1.**\\n(2^53) - 1 is the Maximum Number Primitive which can be safely represented using JavaScript.\\nThis is represented by MAX_SAFE_INTEGER.\\n**We coule use parseInt(\"number\", base)** to convert the arguments \\'a\\' and \\'b\\' from binary base to decimal base and then add them together.\\nBut the **problem** here is, if we have integers, i.e a or b\\'s **binary value to be huge** (that is if the numbers passed to a or b is really big which is more than 2^52 -1), then **javascript can not process it as the max Number primitive it can work with safely is 2^53 -1 or lesser.**\\n\\nTherefore, we make use of BigInt to represent all kind of numbers, small to large Integers.\\nThe **BigInt object takes a String Integer literal** as argument and then **returns** us a number which is of the**BigInt datatype**.\\n\\nSo, here we need to pass the string (which should be an Integer Literal), as whichever base it is currently represented as.\\nIn our case we have \\'a\\' and \\'b\\' as binary numbers(strings).\\nWe need to tell **BigInt() that \\'a\\' and \\'b\\' are Binary numbers, so we append \\'0b\\' to the beginning of \\'a\\' and \\'b\\' and then pass them to BigInt().**\\nSimilarly, if we have Hexadecimal number we prefix \\'0x\\' and for Octal numbers we prefix \\'0o\\'.\\n\\nOnce we have converted our binary numbers \\'a\\' and \\'b\\' to BigInt datatype, we add them using normal addition (+) operator.\\n\\nNow, we use the **toString method to convert our BigInt number (sum calculated) to String which is a Binary, by passing the base we want to convert our argument to.**\\nstr.toString(2) converts the str string to Binary (base 2).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(\"0b\"+a) + BigInt(\"0b\"+b)).toString(2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743698,
                "title": "python-8-lines-neat-solution-explained",
                "content": "What we need to do in this problem is just add two numbers given in binary representation. How we can do it? Using usual schoolbook \\u0441olumnar addition of course! So, we need to start from the last column and add two digits and also not to forget about `carry`. We need to stop when we reached beginning of both numbers. `d1` and `d2` are current processed digits. We form `summ` string, adding element to the end and in the end we reverse it.\\n\\n**Complexity**: time complexity is `O(n + m)`, where `n` and `m` are lengths of numbers, space complexity is `O(max(m,n))`, because result will have this length.\\n\\n```\\nclass Solution:\\n    def addBinary(self, a, b):\\n        i, j, summ, carry = len(a) - 1, len(b) - 1, [], 0\\n        while i >= 0 or j >= 0 or carry:\\n            d1 = int(a[i]) if i >= 0 else 0\\n            d2 = int(b[j]) if j >= 0 else 0\\n            summ += [str((d1 + d2 + carry) % 2)]\\n            carry = (d1 + d2 + carry) // 2\\n            i, j = i-1, j-1 \\n        return \"\".join(summ[::-1])\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a, b):\\n        i, j, summ, carry = len(a) - 1, len(b) - 1, [], 0\\n        while i >= 0 or j >= 0 or carry:\\n            d1 = int(a[i]) if i >= 0 else 0\\n            d2 = int(b[j]) if j >= 0 else 0\\n            summ += [str((d1 + d2 + carry) % 2)]\\n            carry = (d1 + d2 + carry) // 2\\n            i, j = i-1, j-1 \\n        return \"\".join(summ[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24756,
                "title": "very-concise-c-solution-without-calculating-longest-string",
                "content": "I am not sure if this can be made even more concise (possibly yes), but I believe this is sufficiently concise without sacrificing readability.\\n\\n    string addBinary(string a, string b) \\n    {\\n        string result = \"\";\\n        int apos = a.size() - 1;\\n        int bpos = b.size() - 1;\\n        int adigit, bdigit, carry = 0;\\n        \\n        while (apos >= 0 || bpos >= 0 || carry == 1)\\n        {\\n            adigit = bdigit = 0;\\n            \\n            if (apos >= 0) adigit = a[apos--] == '1';\\n            if (bpos >= 0) bdigit = b[bpos--] == '1';\\n            \\n            // Another way: the digit is 1 if adigit + bdigit + carry == 1 or == 3, but I noticed that\\n            // XOR is more concise:\\n            result = static_cast<char>(adigit ^ bdigit ^ carry + '0') + result; \\n            carry = adigit + bdigit + carry >= 2;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "I am not sure if this can be made even more concise (possibly yes), but I believe this is sufficiently concise without sacrificing readability.\\n\\n    string addBinary(string a, string b) \\n    {\\n        string result = \"\";\\n        int apos = a.size() - 1;\\n        int bpos = b.size() - 1;\\n        int adigit, bdigit, carry = 0;\\n        \\n        while (apos >= 0 || bpos >= 0 || carry == 1)\\n        {\\n            adigit = bdigit = 0;\\n            \\n            if (apos >= 0) adigit = a[apos--] == '1';\\n            if (bpos >= 0) bdigit = b[bpos--] == '1';\\n            \\n            // Another way: the digit is 1 if adigit + bdigit + carry == 1 or == 3, but I noticed that\\n            // XOR is more concise:\\n            result = static_cast<char>(adigit ^ bdigit ^ carry + '0') + result; \\n            carry = adigit + bdigit + carry >= 2;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24759,
                "title": "tiny-clean-c-solution-quite-readable",
                "content": "    class Solution {\\n    public:\\n            string addBinary(string a, string b) {\\n                    string ret = \"\";\\n                    int carry = 0;\\n                    for (int i = a.size() - 1, j = b.size() - 1; i >= 0 || j >= 0; i--, j--) {\\n                            int m = (i >= 0 && a[i] == '1');\\n                            int n = (j >= 0 && b[j] == '1');\\n                            ret = to_string((m + n + carry) & 0x1) + ret;\\n                            carry = (m + n + carry) >> 1;\\n                    }\\n                    return carry ? '1' + ret : ret;\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n            string addBinary(string a, string b) {\\n                    string ret = \"\";\\n                    int carry = 0;\\n                    for (int i = a.size() - 1, j = b.size() - 1; i >= 0 || j >= 0; i--, j--) {\\n                            int m = (i >= 0 && a[i] == '1');\\n                            int n = (j >= 0 && b[j] == '1');\\n                            ret = to_string((m + n + carry) & 0x1) + ret;\\n                            carry = (m + n + carry) >> 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 24752,
                "title": "c-simple-solution",
                "content": "        \\n    string addBinary(string a, string b) {\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        string ret = \"\";\\n        while (i >= 0 || j >= 0 || carry!=0) {\\n            if (i >= 0) {\\n                carry += a[i]=='0'?0:1;\\n                i--;\\n            }\\n            if (j >= 0) {\\n                carry += b[j]=='0'?0:1;\\n                j--;\\n            }\\n            ret = ((carry%2)==0?\"0\":\"1\") + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    string addBinary(string a, string b) {\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        string ret = \"\";\\n        while (i >= 0 || j >= 0 || carry!=0) {\\n            if (i >= 0) {\\n                carry += a[i]=='0'?0:1;\\n                i--;\\n            }\\n            if (j >= 0) {\\n                carry += b[j]=='0'?0:1;\\n                j--;\\n            }\\n            ret = ((carry%2)==0?\"0\":\"1\") + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2783480,
                "title": "one-liner-in-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses the BigInteger class to add two binary numbers.\\n\\n# Complexity \\n- Time complexity: $$O(n)$$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\nreturn new java.math.BigInteger(a, 2).add(new java.math.BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```\\n### If you like the solution then please upvote me...........",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\nreturn new java.math.BigInteger(a, 2).add(new java.math.BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679429,
                "title": "python3-binary-addition-explained",
                "content": "To calculate the final result we use binary addition rules. For every bit:\\n> `0 + 0 = 0`\\n\\t`1 + 0 = 1`\\n\\t`1 + 1 = 0 (carry 1)`\\n\\t`1 + 1 + (carry 1) = 1 (carry 1)`\\n\\nTo simplify logic, there are couple of tricks here:\\n* The resulting bit is equal to `(aBit + bBit + carry) % 2`. That works because the bit becomes `1` only if the sum `(aBit + bBit + carry)` is greater than 2. Example: `1+1+1 = 3 => 3%2 = 1`\\n* Carry can be calculated as `(aBit + bBit + carry) // 2` (the result of division floor rounded). Example: `1+1+1 = 3 => carry = 3//2 = 1`\\n* Use negative index `i` here to iterate from the end (`list[-1]` gives the last element of the list). That allows us to have just one single index for both strings.\\n\\nSo we just iterate over characters of input strings and using addition rules calculater the result\\n\\nTime: **O(n)** - for scan\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 32 ms, faster than **80.60%** of Python3 online submissions for Add Binary.\\nMemory Usage: 14.3 MB, less than **55.41%** of Python3 online submissions for Add Binary.\\n\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        aL, bL = -len(a), -len(b)\\n        i, carry, res = -1, 0, \"\"\\n\\n        while i >= aL or i >= bL:\\n            aBit = int(a[i]) if i >= aL else 0\\n            bBit = int(b[i]) if i >= bL else 0\\n            \\n            sum = aBit + bBit + carry\\n            res = str(sum % 2) + res\\n            carry = sum // 2\\n\\n            i -= 1\\n            \\n        return \"1\" + res if carry else res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        aL, bL = -len(a), -len(b)\\n        i, carry, res = -1, 0, \"\"\\n\\n        while i >= aL or i >= bL:\\n            aBit = int(a[i]) if i >= aL else 0\\n            bBit = int(b[i]) if i >= bL else 0\\n            \\n            sum = aBit + bBit + carry\\n            res = str(sum % 2) + res\\n            carry = sum // 2\\n\\n            i -= 1\\n            \\n        return \"1\" + res if carry else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580924,
                "title": "clean-simple-c-solution-100-faster-100-memory",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        auto output = \"\"s;\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        while (i >= 0 || j >= 0 || carry) {\\n            if (i >= 0 && a[i--] == \\'1\\') ++carry;\\n            if (j >= 0 && b[j--] == \\'1\\') ++carry;\\n            output.insert(0, carry % 2 == 1 ? \"1\" : \"0\");\\n            carry /= 2;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        auto output = \"\"s;\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        while (i >= 0 || j >= 0 || carry) {\\n            if (i >= 0 && a[i--] == \\'1\\') ++carry;\\n            if (j >= 0 && b[j--] == \\'1\\') ++carry;\\n            output.insert(0, carry % 2 == 1 ? \"1\" : \"0\");\\n            carry /= 2;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24726,
                "title": "my-python-solution",
                "content": "\\n\\n    def addBinary(self, a, b):\\n        res, carry = '', 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry:\\n            curval = (i >= 0 and a[i] == '1') + (j >= 0 and b[j] == '1')\\n            carry, rem = divmod(curval + carry, 2)\\n            res = `rem` + res\\n            i -= 1\\n            j -= 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    def addBinary(self, a, b):\\n        res, carry = '', 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry:\\n            curval = (i >= 0 and a[i] == '1') + (j >= 0 and b[j] == '1')\\n            carry, rem = divmod(curval + carry, 2)\\n            res = `rem` + res\\n            i -= 1\\n            j -= 1\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 577148,
                "title": "simple-javascript-solution",
                "content": "```\\nlet addBinary = (a, b) => {\\n  // Truth Table\\n  // 1st + 2nd + carry = sum, new carry, decimal sum\\n  //   0 +  0  + 0 = 0, 0 (0)\\n  //   0 +  0  + 1 = 1, 0 (1)\\n  //   0 +  1  + 1 = 0, 1 (2)\\n  //   1 +  1  + 1 = 1, 1 (3)\\n\\n  let carry = 0;\\n  let result = \\'\\';\\n\\n  let len1 = a.length - 1;\\n  let len2 = b.length - 1;\\n\\n  for (; len1 >= 0 || len2 >= 0 || carry > 0; len1--, len2--) {\\n    let sum = (+a[len1] || 0) + (+b[len2] || 0) + carry;\\n    if (sum > 1) {\\n      sum = sum % 2;\\n      carry = 1;\\n    } else {\\n      carry = 0;\\n    }\\n    result = `${sum}${result}`;\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet addBinary = (a, b) => {\\n  // Truth Table\\n  // 1st + 2nd + carry = sum, new carry, decimal sum\\n  //   0 +  0  + 0 = 0, 0 (0)\\n  //   0 +  0  + 1 = 1, 0 (1)\\n  //   0 +  1  + 1 = 0, 1 (2)\\n  //   1 +  1  + 1 = 1, 1 (3)\\n\\n  let carry = 0;\\n  let result = \\'\\';\\n\\n  let len1 = a.length - 1;\\n  let len2 = b.length - 1;\\n\\n  for (; len1 >= 0 || len2 >= 0 || carry > 0; len1--, len2--) {\\n    let sum = (+a[len1] || 0) + (+b[len2] || 0) + carry;\\n    if (sum > 1) {\\n      sum = sum % 2;\\n      carry = 1;\\n    } else {\\n      carry = 0;\\n    }\\n    result = `${sum}${result}`;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24562,
                "title": "one-line-python-solution",
                "content": "    class Solution:\\n        def addBinary(self, a, b):\\n            return bin(eval('0b' + a) + eval('0b' + b))[2:]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def addBinary(self, a, b):\\n            return bin(eval('0b' + a) + eval('0b' + b))[2:]",
                "codeTag": "Java"
            },
            {
                "id": 24667,
                "title": "13-lines-easy-java-solution-simple-and-elegant",
                "content": "    public String addBinary(String a, String b) {\\n        int lena = a.length();\\n        int lenb = b.length();\\n        int i =0, carry = 0;\\n        String res = \"\";\\n        while(i<lena || i<lenb || carry!=0){\\n            int x = (i<lena) ? Character.getNumericValue(a.charAt(lena - 1 - i)) : 0;\\n            int y = (i<lenb) ? Character.getNumericValue(b.charAt(lenb - 1 - i)) : 0;\\n            res = (x + y + carry)%2 + res;\\n            carry = (x + y + carry)/2;\\n            i++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public String addBinary(String a, String b) {\\n        int lena = a.length();\\n        int lenb = b.length();\\n        int i =0, carry = 0;\\n        String res = \"\";\\n        while(i<lena || i<lenb || carry!=0){\\n            int x = (i<lena) ? Character.getNumericValue(a.charAt(lena - 1 - i)) : 0;\\n            int y = (i<lenb) ? Character.getNumericValue(b.charAt(lenb - 1 - i)) : 0;\\n            res = (x + y + carry)%2 + res;\\n            carry = (x + y + carry)/2;\\n            i++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 743586,
                "title": "self-explanatory-detailed-steps-2-solution-java-1-liner-using-biginteger",
                "content": "\\n**Approach:**\\n1. Intialize i & j index for a and from last character index of a & b\\n2. Loop over for both index until anyone reach 0, add last bit of both string along with carry intilized with 0. reminder from 2 is the new bit and divide by 2 is carry.\\n3. check if i >= 0 repeat for string a\\n4. check if j >= 0 repeat for string b\\n5. check if carry != 0 - add carry in sb.\\n6. return reverse of sb.\\n\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int sum = 0;\\n        while(i >= 0 && j >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(i >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(j >= 0) {\\n            sum = b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        if(carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n********\\n\\nWe can also combine 3 while loops used in above code into 1 like below.\\n\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        \\n        while (i >= 0 || j >= 0) {\\n            int sum = carry;\\n            if (i >= 0) sum += a.charAt(i--) - \\'0\\';\\n\\t\\t\\tif (j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        if (carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n\\n********\\n**1-Liner with BigInteger**\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```\\n\\n********\\nIf you have any doubt and question ask in comment. If you like solution upvote.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int sum = 0;\\n        while(i >= 0 && j >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(i >= 0) {\\n            sum = a.charAt(i--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        while(j >= 0) {\\n            sum = b.charAt(j--) - \\'0\\' + carry;\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        \\n        if(carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        \\n        while (i >= 0 || j >= 0) {\\n            int sum = carry;\\n            if (i >= 0) sum += a.charAt(i--) - \\'0\\';\\n\\t\\t\\tif (j >= 0) sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum % 2);\\n            carry = sum / 2;\\n        }\\n        if (carry != 0) sb.append(carry);\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307335,
                "title": "javascript-super-easy-to-understand-and-beat-92",
                "content": "```\\nvar addBinary = function(a, b) {\\n    a = a.split(\"\").reverse().join(\"\");\\n    b = b.split(\"\").reverse().join(\"\");\\n    len = a.length > b.length ? a.length : b.length;\\n    result = [];\\n    for(let i = 0; i < len; i += 1){\\n        num1 = Number(a[i] || 0);\\n        num2 = Number(b[i]) || 0;\\n        curr = Number(result[i]||0) + num1 + num2\\n        if(curr >= 2){\\n            result[i] = curr%2;\\n            result.push(1)\\n        }\\n        else{\\n            result[i] = curr\\n        }\\n    }\\n    return result.reverse().join(\"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    a = a.split(\"\").reverse().join(\"\");\\n    b = b.split(\"\").reverse().join(\"\");\\n    len = a.length > b.length ? a.length : b.length;\\n    result = [];\\n    for(let i = 0; i < len; i += 1){\\n        num1 = Number(a[i] || 0);\\n        num2 = Number(b[i]) || 0;\\n        curr = Number(result[i]||0) + num1 + num2\\n        if(curr >= 2){\\n            result[i] = curr%2;\\n            result.push(1)\\n        }\\n        else{\\n            result[i] = curr\\n        }\\n    }\\n    return result.reverse().join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236550,
                "title": "my-c-solution",
                "content": "```\\nchar* addBinary(char* a, char* b)\\n{\\n    int i, j, k, c = 0;\\n    char *res;\\n    \\n    i = strlen(a);\\n    j = strlen(b);\\n    k = i > j ? i : j;\\n    k += 2;\\n\\n    res = malloc(k * sizeof(char));\\n    \\n    i--;\\n    j--;\\n    res[--k] = \\'\\\\0\\';\\n    \\n    while (--k >= 0) {\\n        c += i >= 0 ? a[i--] - \\'0\\': 0;\\n        c += j >= 0 ? b[j--] - \\'0\\': 0;\\n        \\n        res[k] = c % 2 + \\'0\\';\\n        c /= 2;\\n    }\\n    \\n    if (res[0] == \\'0\\')\\n       memmove(res, res + 1, strlen(res) * sizeof(char));\\n    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* addBinary(char* a, char* b)\\n{\\n    int i, j, k, c = 0;\\n    char *res;\\n    \\n    i = strlen(a);\\n    j = strlen(b);\\n    k = i > j ? i : j;\\n    k += 2;\\n\\n    res = malloc(k * sizeof(char));\\n    \\n    i--;\\n    j--;\\n    res[--k] = \\'\\\\0\\';\\n    \\n    while (--k >= 0) {\\n        c += i >= 0 ? a[i--] - \\'0\\': 0;\\n        c += j >= 0 ? b[j--] - \\'0\\': 0;\\n        \\n        res[k] = c % 2 + \\'0\\';\\n        c /= 2;\\n    }\\n    \\n    if (res[0] == \\'0\\')\\n       memmove(res, res + 1, strlen(res) * sizeof(char));\\n    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798567,
                "title": "short-and-simple-logic-with-explanation-beats-100-c",
                "content": "```\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        while(i>=0 || j>=0)\\n        {\\n            int x = (i>=0)?a[i--]-\\'0\\':0; // subtract with 0, to convert it to int\\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            s.append(to_string(sum%2)); // 1+1 = 2, 2%2=0, this is enough to explain %2\\n            carry = sum/2;// 1+1=2, 2/2=1, carry is one, OR 1+0=1,1/2=0,carry = 0\\n        }\\n        if(carry>0)\\n               s.append(to_string(1));//if carry generated by last two digits is > 0, append in RESULT\\n        reverse(s.begin() , s.end()); //if you use insert() then reverse is not necessary\\n        return s;   \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        while(i>=0 || j>=0)\\n        {\\n            int x = (i>=0)?a[i--]-\\'0\\':0; // subtract with 0, to convert it to int\\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            s.append(to_string(sum%2)); // 1+1 = 2, 2%2=0, this is enough to explain %2\\n            carry = sum/2;// 1+1=2, 2/2=1, carry is one, OR 1+0=1,1/2=0,carry = 0\\n        }\\n        if(carry>0)\\n               s.append(to_string(1));//if carry generated by last two digits is > 0, append in RESULT\\n        reverse(s.begin() , s.end()); //if you use insert() then reverse is not necessary\\n        return s;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057915,
                "title": "fast-javascript-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    // we used BigInt() to convert binary to Integer. Syntax is BigInt(0b11) here `0b` is prefix and `11` is binary number\\n    let sum = BigInt(`0b${a}`) + BigInt(`0b${b}`);\\n    // sum is converted back to string using toString(2), here 2 is radix argument, so toString(2) converts to binary\\n    return sum.toString(2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    // we used BigInt() to convert binary to Integer. Syntax is BigInt(0b11) here `0b` is prefix and `11` is binary number\\n    let sum = BigInt(`0b${a}`) + BigInt(`0b${b}`);\\n    // sum is converted back to string using toString(2), here 2 is radix argument, so toString(2) converts to binary\\n    return sum.toString(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24659,
                "title": "simple-python-solution-76ms",
                "content": "I assume using `int` and `str` is okay, I think this is easy to understand.\\n\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = int(num_a) + int(num_b) + int(carry)\\n            result = str(val % 2) + result\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n\\n================== update ===============\\n\\nNo `int` and `str` version.\\n\\n    class Solution:\\n    # @param a, a string\\n    # @param b, a string\\n    # @return a string\\n    # 75ms\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry)\\n            result = \"%s%s\" % (val % 2, result)\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n    \\n    def to_int(self, c):\\n        if c == '1':\\n            return 1\\n        elif c == '0':\\n            return 0",
                "solutionTags": [
                    "Python"
                ],
                "code": "I assume using `int` and `str` is okay, I think this is easy to understand.\\n\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = int(num_a) + int(num_b) + int(carry)\\n            result = str(val % 2) + result\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n\\n================== update ===============\\n\\nNo `int` and `str` version.\\n\\n    class Solution:\\n    # @param a, a string\\n    # @param b, a string\\n    # @return a string\\n    # 75ms\\n    def addBinary(self, a, b):\\n        result = ''\\n        index = 0\\n        \\n        carry = '0'\\n        while index < max(len(a), len(b)) or carry == '1':\\n            num_a = a[-1 - index] if index < len(a) else '0'\\n            num_b = b[-1 - index] if index < len(b) else '0'\\n            \\n            val = self.to_int(num_a) + self.to_int(num_b) + self.to_int(carry)\\n            result = \"%s%s\" % (val % 2, result)\\n            \\n            carry = '1' if val > 1 else '0'\\n            index += 1\\n\\n        return result\\n    \\n    def to_int(self, c):\\n        if c == '1':\\n            return 1\\n        elif c == '0':\\n            return 0",
                "codeTag": "Java"
            },
            {
                "id": 3183112,
                "title": "day-45-c-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nThe intuition behind the given code is to perform binary addition by converting the binary strings to their integer equivalent and then adding them.\\n\\nThe given code first reverses the input binary strings \\'a\\' and \\'b\\' so that the least significant bit is at index 0, making it easier to calculate the corresponding decimal value of each bit using powers of 2. It then iterates over each bit of the reversed \\'a\\' and \\'b\\' and calculates the decimal value of each bit.\\n\\nIt does this by taking the integer equivalent of each binary digit (0 or 1), multiplying it by the corresponding power of 2 (2 raised to the index of the digit), and adding this to the running sum. The running sum is then added together to get the decimal value of the two binary strings.\\n\\nThe decimal sum is then converted back into a binary string by performing repeated division by 2 and recording the remainders in reverse order until the sum becomes zero. The binary string is then reversed and returned as the final output.\\n\\nWhile this approach can work for smaller binary numbers, it may not be suitable for larger binary strings as it can result in overflow errors due to the use of integer variables.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty string called result to store the binary sum of the two input strings.\\n2. Initialize a variable called carry to store the carry generated during the binary addition.\\n3. Start from the last digit of both input strings and move towards the left.\\n4. In each iteration, add the current digits of both strings and the carry generated in the previous iteration.\\n5. Compute the sum modulo 2 and append the result to the result string.\\n6. Compute the carry as the integer division of the sum by 2.\\n7. Repeat steps 4-6 until there are no more digits in both input strings and the carry is zero.\\n8. Reverse the result string and return it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string result = \"\";\\n        int carry = 0;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        while (i >= 0 || j >= 0 || carry) {\\n            int sum = carry;\\n            if (i >= 0) {\\n              sum += a[i] - \\'0\\';\\n              i--;\\n            }\\n            if (j >= 0) {\\n              sum += b[j] - \\'0\\';\\n              j--;\\n            }\\n            carry = sum / 2;\\n            result += to_string(sum % 2);\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        String result = \"\";\\n        int carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            int sum = carry;\\n            if (i >= 0) {\\n                sum += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            if (j >= 0) {\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            carry = sum / 2;\\n            result = (sum % 2) + result;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```\\n```Python []\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        result = \"\"\\n        carry = 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry != 0:\\n            sum = carry\\n            if i >= 0:\\n                sum += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                sum += int(b[j])\\n                j -= 1\\n            carry = sum // 2\\n            result = str(sum % 2) + result\\n        return result\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(max(n,m))** where n and m are the lengths of the input strings a and b respectively. We need to perform at most max(n,m) iterations to add the two strings.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(max(n,m))** for storing the result string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string result = \"\";\\n        int carry = 0;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        while (i >= 0 || j >= 0 || carry) {\\n            int sum = carry;\\n            if (i >= 0) {\\n              sum += a[i] - \\'0\\';\\n              i--;\\n            }\\n            if (j >= 0) {\\n              sum += b[j] - \\'0\\';\\n              j--;\\n            }\\n            carry = sum / 2;\\n            result += to_string(sum % 2);\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        String result = \"\";\\n        int carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        while (i >= 0 || j >= 0 || carry != 0) {\\n            int sum = carry;\\n            if (i >= 0) {\\n                sum += a.charAt(i) - \\'0\\';\\n                i--;\\n            }\\n            if (j >= 0) {\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;\\n            }\\n            carry = sum / 2;\\n            result = (sum % 2) + result;\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```\n```Python []\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        result = \"\"\\n        carry = 0\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0 or carry != 0:\\n            sum = carry\\n            if i >= 0:\\n                sum += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                sum += int(b[j])\\n                j -= 1\\n            carry = sum // 2\\n            result = str(sum % 2) + result\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680441,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        x=int(a,2)\\n        y=int(b,2)\\n        return bin(x+y)[2:]\\n```\\n\\nPlease UPVOTE if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        x=int(a,2)\\n        y=int(b,2)\\n        return bin(x+y)[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201676,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n\\t\\t\\tvar sb = new StringBuilder();\\n            var t = 0;\\n            for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0 || t > 0; i--, j--)\\n            {\\n                var av = i < 0 || a[i] == \\'0\\' ? 0 : 1;\\n                var bv = j < 0 || b[j] == \\'0\\' ? 0 : 1;\\n                sb.Insert(0, (av + bv + t) % 2);\\n                t = (av + bv + t) / 2;\\n            }\\n\\n            return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n\\t\\t\\tvar sb = new StringBuilder();\\n            var t = 0;\\n            for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0 || t > 0; i--, j--)\\n            {\\n                var av = i < 0 || a[i] == \\'0\\' ? 0 : 1;\\n                var bv = j < 0 || b[j] == \\'0\\' ? 0 : 1;\\n                sb.Insert(0, (av + bv + t) % 2);\\n                t = (av + bv + t) / 2;\\n            }\\n\\n            return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24770,
                "title": "python-easy-to-understand-solution-with-two-pointer",
                "content": "\\n    def addBinary(self, a, b):\\n        i, j, carry, res = len(a)-1, len(b)-1, 0, \"\"\\n        while i >= 0 or j >= 0 or carry:\\n            if i >= 0:\\n                carry += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                carry += int(b[j])\\n                j -= 1\\n            res = str(carry%2) + res\\n            carry //= 2\\n        return res",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def addBinary(self, a, b):\\n        i, j, carry, res = len(a)-1, len(b)-1, 0, \"\"\\n        while i >= 0 or j >= 0 or carry:\\n            if i >= 0:\\n                carry += int(a[i])\\n                i -= 1\\n            if j >= 0:\\n                carry += int(b[j])\\n                j -= 1\\n            res = str(carry%2) + res\\n            carry //= 2\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2061593,
                "title": "c-beginner-friendly",
                "content": "```\\nchar * addBinary(char * a, char * b){\\n    int sizeA = strlen(a);\\n    int sizeB = strlen(b);\\n    int sizeOutput = (sizeA > sizeB ? sizeA : sizeB) + 1;\\n    char * output = (char *)malloc(sizeOutput + 1);\\n    int sum = 0;\\n    \\n    output[sizeOutput] = \\'\\\\0\\';\\n    \\n    while(sizeA > 0 || sizeB > 0 || sum > 0) {\\n        \\n        if(sizeA > 0) {\\n            sum += a[--sizeA] - \\'0\\';\\n        }\\n        if(sizeB > 0) {\\n            sum += b[--sizeB] - \\'0\\';\\n        }\\n        output[--sizeOutput] = sum % 2 + \\'0\\';\\n        sum /= 2;\\n    }\\n    return output + sizeOutput;   \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * addBinary(char * a, char * b){\\n    int sizeA = strlen(a);\\n    int sizeB = strlen(b);\\n    int sizeOutput = (sizeA > sizeB ? sizeA : sizeB) + 1;\\n    char * output = (char *)malloc(sizeOutput + 1);\\n    int sum = 0;\\n    \\n    output[sizeOutput] = \\'\\\\0\\';\\n    \\n    while(sizeA > 0 || sizeB > 0 || sum > 0) {\\n        \\n        if(sizeA > 0) {\\n            sum += a[--sizeA] - \\'0\\';\\n        }\\n        if(sizeB > 0) {\\n            sum += b[--sizeB] - \\'0\\';\\n        }\\n        output[--sizeOutput] = sum % 2 + \\'0\\';\\n        sum /= 2;\\n    }\\n    return output + sizeOutput;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1915690,
                "title": "100-fastest-swift-solution-time-o-n-m-space-o-n-m",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n + m), where n is the length of the a and m is the length of the b.\\n    //   - space: O(n + m), where n is the length of the a and m is the length of the b.\\n\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        guard !a.isEmpty else { return b }\\n        guard !b.isEmpty else { return a }\\n\\n        var carry = 0\\n        let a = Array(a)\\n        let b = Array(b)\\n        var i = a.count - 1\\n        var j = b.count - 1\\n        var ans = [Int]()\\n\\n        while i >= 0 || j >= 0 || carry != 0 {\\n            var sum = carry\\n            if i >= 0, a[i] == \"1\" { sum += 1 }\\n            if j >= 0, b[j] == \"1\" { sum += 1 }\\n\\n            let digit = sum % 2\\n            carry = sum / 2\\n            ans.append(digit)\\n\\n            i -= 1\\n            j -= 1\\n        }\\n\\n        return ans.map { String($0) }.reversed().joined()\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n + m), where n is the length of the a and m is the length of the b.\\n    //   - space: O(n + m), where n is the length of the a and m is the length of the b.\\n\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        guard !a.isEmpty else { return b }\\n        guard !b.isEmpty else { return a }\\n\\n        var carry = 0\\n        let a = Array(a)\\n        let b = Array(b)\\n        var i = a.count - 1\\n        var j = b.count - 1\\n        var ans = [Int]()\\n\\n        while i >= 0 || j >= 0 || carry != 0 {\\n            var sum = carry\\n            if i >= 0, a[i] == \"1\" { sum += 1 }\\n            if j >= 0, b[j] == \"1\" { sum += 1 }\\n\\n            let digit = sum % 2\\n            carry = sum / 2\\n            ans.append(digit)\\n\\n            i -= 1\\n            j -= 1\\n        }\\n\\n        return ans.map { String($0) }.reversed().joined()\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633397,
                "title": "simple-easy-c-solution",
                "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n         \\n       string res;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0) {\\n            sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            res += to_string(sum % 2);  \\n\\t\\t\\t                                         \\n            carry = sum / 2;\\n            \\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\n\\n// if you like this solution please do upvote me //\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n         \\n       string res;\\n        int i = a.size() - 1, j = b.size() - 1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0) {\\n            sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            res += to_string(sum % 2);  \\n\\t\\t\\t                                         \\n            carry = sum / 2;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 538786,
                "title": "js-single-line-98-using-template-strings",
                "content": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(`0b${a}`) + BigInt(`0b${b}`)).toString(2)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    return (BigInt(`0b${a}`) + BigInt(`0b${b}`)).toString(2)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24708,
                "title": "another-simple-java",
                "content": "    public String addBinary(String a, String b) {\\n        if(a == null || b ==null)\\n            return a == null? b: a;\\n            \\n        int carry =0;\\n        StringBuilder sb = new StringBuilder();        \\n        \\n        for(int i = a.length()-1, j = b.length() -1;  i >=0 || j >=0 || carry >0 ; i --, j --){\\n            int sum = 0;\\n            sum += (i >=0) ? a.charAt(i) - '0' : 0;\\n            sum += (j >=0) ? b.charAt(j) - '0' : 0;\\n            sum += carry;\\n            \\n            carry = sum /2;\\n            sum %=2;\\n            sb.append(sum);\\n        }\\n        \\n        return sb.reverse().toString();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String addBinary(String a, String b) {\\n        if(a == null || b ==null)\\n            return a == null? b: a;\\n            \\n        int carry =0;\\n        StringBuilder sb = new StringBuilder();        \\n        \\n        for(int i = a.length()-1, j = b.length() -1;  i >=0 || j >=0 || carry >0 ; i --, j --){\\n            int sum = 0;\\n            sum += (i >=0) ? a.charAt(i) - '0' : 0;\\n            sum += (j >=0) ? b.charAt(j) - '0' : 0;\\n            sum += carry;\\n            \\n            carry = sum /2;\\n            sum %=2;\\n            sb.append(sum);\\n        }\\n        \\n        return sb.reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24783,
                "title": "simple-c-code-implementing-a-full-adder",
                "content": "    char* addBinary(char* a, char* b) {\\n    int la = strlen(a);\\n    int lb = strlen(b);\\n    int lr = la > lb ? la : lb;\\n    int carry = 0;\\n    char *res = (char*)calloc(lr + 2, sizeof(char));\\n    res[lr + 1] = '\\\\0';\\n    la--; lb--;\\n    while (la >= 0 || lb >= 0) {\\n        int ba = la >= 0 ? a[la--] - '0' : 0;\\n        int bb = lb >= 0 ? b[lb--] - '0' : 0;\\n        int br = ba ^ bb ^ carry;\\n        carry = (ba & bb) | (carry & (ba ^ bb));\\n        res[lr--] = br + '0';\\n    }\\n    if (!carry) return res + 1;\\n    res[0] = '1';\\n    return res;\\n}",
                "solutionTags": [],
                "code": "    char* addBinary(char* a, char* b) {\\n    int la = strlen(a);\\n    int lb = strlen(b);\\n    int lr = la > lb ? la : lb;\\n    int carry = 0;\\n    char *res = (char*)calloc(lr + 2, sizeof(char));\\n    res[lr + 1] = '\\\\0';\\n    la--; lb--;\\n    while (la >= 0 || lb >= 0) {\\n        int ba = la >= 0 ? a[la--] - '0' : 0;\\n        int bb = lb >= 0 ? b[lb--] - '0' : 0;\\n        int br = ba ^ bb ^ carry;\\n        carry = (ba & bb) | (carry & (ba ^ bb));\\n        res[lr--] = br + '0';\\n    }\\n    if (!carry) return res + 1;\\n    res[0] = '1';\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3519981,
                "title": "c-java-python-javascript-detailed-explanation-easy-to-understand",
                "content": "# Intuition:\\nThe problem is to add two binary numbers represented as strings, i.e., \"101\" + \"110\" should give \"1011\". We can start by aligning the two binary numbers by adding leading zeros to the shorter string so that both strings have equal lengths. Then we can add the digits from right to left and keep track of any carry generated. Finally, we add the carry to the leftmost position if any.\\n\\n# Approach:\\n1. Calculate the lengths of the two input strings.\\n2. If the length of string a is greater than that of string b, add leading zeros to string b to make its length equal to that of string a. Otherwise, add leading zeros to string a to make its length equal to that of string b.\\n3. Initialize carry to 0 and an empty string ans.\\n4. Traverse the two input strings from right to left, one character at a time.\\n5. For each character, add its value with the corresponding character from the other string and the carry.\\n6. Determine the value of the current bit and the carry generated.\\n7. Add the current bit to the left end of the ans string.\\n8. Finally, if there is any carry left, add it to the leftmost position of the ans string.\\n9. Return the ans string.\\n\\n# Complexity:\\n- Time Complexity: The algorithm has a time complexity of O(N), where N is the length of the longer input string. This is because we traverse the input strings once from right to left, which takes O(N) time. \\n- Space Complexity: The algorithm has a space complexity of O(N), where N is the length of the longer input string. This is because we store the result in an ans string which can have a maximum length of N+1.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int l1=a.length();\\n        int l2=b.length();\\n        if(a.length()>b.length()){\\n            int diff=(a.length()-b.length());\\n            for(int i=0;i<diff;i++){\\n                b=\"0\"+b;\\n            }\\n        }\\n        if(a.length()<b.length()){\\n            int diff=(b.length()-a.length());\\n            for(int i=0;i<diff;i++){\\n                a=\"0\"+a;\\n            }\\n        }\\n        int carry=0;\\n        string ans=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            cout<<a[i]<<\"+\"<<b[i]<<\"+\"<<carry<<endl;\\n            if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"0\"+ans;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n        }\\n        if(carry==1){\\n            ans=\"1\"+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# JAVA\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int l1 = a.length();\\n        int l2 = b.length();\\n        if (a.length() > b.length()) {\\n            int diff = a.length() - b.length();\\n            for (int i = 0; i < diff; i++) {\\n                b = \"0\" + b;\\n            }\\n        }\\n        if (a.length() < b.length()) {\\n            int diff = b.length() - a.length();\\n            for (int i = 0; i < diff; i++) {\\n                a = \"0\" + a;\\n            }\\n        }\\n        int carry = 0;\\n        String ans = \"\";\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n            if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            }\\n        }\\n        if (carry == 1) {\\n            ans = \"1\" + ans;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        l1 = len(a)\\n        l2 = len(b)\\n        if len(a) > len(b):\\n            diff = len(a) - len(b)\\n            for i in range(diff):\\n                b = \"0\" + b\\n        if len(a) < len(b):\\n            diff = len(b) - len(a)\\n            for i in range(diff):\\n                a = \"0\" + a\\n        carry = 0\\n        ans = \"\"\\n        for i in range(len(a) - 1, -1, -1):\\n            if a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"0\" + ans\\n            elif a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n        if carry == 1:\\n            ans = \"1\" + ans\\n        return ans\\n\\n```\\n\\n---\\n\\n# JavaScript\\n```\\nvar addBinary = function(a, b) {\\n    let l1 = a.length;\\n    let l2 = b.length;\\n    if (a.length > b.length) {\\n        let diff = a.length - b.length;\\n        for (let i = 0; i < diff; i++) {\\n            b = \"0\" + b;\\n        }\\n    }\\n    if (a.length < b.length) {\\n        let diff = b.length - a.length;\\n        for (let i = 0; i < diff; i++) {\\n            a = \"0\" + a;\\n        }\\n    }\\n    let carry = 0;\\n    let ans = \"\";\\n    for (let i = a.length - 1; i >= 0; i--) {\\n        if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        }\\n    }\\n    if (carry === 1) {\\n        ans = \"1\" + ans;\\n    }\\n    return ans; \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int l1=a.length();\\n        int l2=b.length();\\n        if(a.length()>b.length()){\\n            int diff=(a.length()-b.length());\\n            for(int i=0;i<diff;i++){\\n                b=\"0\"+b;\\n            }\\n        }\\n        if(a.length()<b.length()){\\n            int diff=(b.length()-a.length());\\n            for(int i=0;i<diff;i++){\\n                a=\"0\"+a;\\n            }\\n        }\\n        int carry=0;\\n        string ans=\"\";\\n        for(int i=a.length()-1;i>=0;i--){\\n            cout<<a[i]<<\"+\"<<b[i]<<\"+\"<<carry<<endl;\\n            if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"0\"+ans;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==1){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'0\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==1){\\n                ans=\"1\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'1\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"0\"+ans;\\n                carry=1;\\n            }\\n            else if(a[i]==\\'0\\' && b[i]==\\'1\\' && carry==0){\\n                ans=\"1\"+ans;\\n                carry=0;\\n            }\\n        }\\n        if(carry==1){\\n            ans=\"1\"+ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int l1 = a.length();\\n        int l2 = b.length();\\n        if (a.length() > b.length()) {\\n            int diff = a.length() - b.length();\\n            for (int i = 0; i < diff; i++) {\\n                b = \"0\" + b;\\n            }\\n        }\\n        if (a.length() < b.length()) {\\n            int diff = b.length() - a.length();\\n            for (int i = 0; i < diff; i++) {\\n                a = \"0\" + a;\\n            }\\n        }\\n        int carry = 0;\\n        String ans = \"\";\\n        for (int i = a.length() - 1; i >= 0; i--) {\\n            if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 1) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'0\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 1) {\\n                ans = \"1\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'1\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"0\" + ans;\\n                carry = 1;\\n            } else if (a.charAt(i) == \\'0\\' && b.charAt(i) == \\'1\\' && carry == 0) {\\n                ans = \"1\" + ans;\\n                carry = 0;\\n            }\\n        }\\n        if (carry == 1) {\\n            ans = \"1\" + ans;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        l1 = len(a)\\n        l2 = len(b)\\n        if len(a) > len(b):\\n            diff = len(a) - len(b)\\n            for i in range(diff):\\n                b = \"0\" + b\\n        if len(a) < len(b):\\n            diff = len(b) - len(a)\\n            for i in range(diff):\\n                a = \"0\" + a\\n        carry = 0\\n        ans = \"\"\\n        for i in range(len(a) - 1, -1, -1):\\n            if a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"0\" + ans\\n            elif a[i] == \\'0\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 1:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'0\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 1:\\n                ans = \"1\" + ans\\n                carry = 1\\n            elif a[i] == \\'1\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"0\" + ans\\n                carry = 1\\n            elif a[i] == \\'0\\' and b[i] == \\'1\\' and carry == 0:\\n                ans = \"1\" + ans\\n                carry = 0\\n        if carry == 1:\\n            ans = \"1\" + ans\\n        return ans\\n\\n```\n```\\nvar addBinary = function(a, b) {\\n    let l1 = a.length;\\n    let l2 = b.length;\\n    if (a.length > b.length) {\\n        let diff = a.length - b.length;\\n        for (let i = 0; i < diff; i++) {\\n            b = \"0\" + b;\\n        }\\n    }\\n    if (a.length < b.length) {\\n        let diff = b.length - a.length;\\n        for (let i = 0; i < diff; i++) {\\n            a = \"0\" + a;\\n        }\\n    }\\n    let carry = 0;\\n    let ans = \"\";\\n    for (let i = a.length - 1; i >= 0; i--) {\\n        if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 1) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'0\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 1) {\\n            ans = \"1\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'1\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"0\" + ans;\\n            carry = 1;\\n        } else if (a[i] === \\'0\\' && b[i] === \\'1\\' && carry === 0) {\\n            ans = \"1\" + ans;\\n            carry = 0;\\n        }\\n    }\\n    if (carry === 1) {\\n        ans = \"1\" + ans;\\n    }\\n    return ans; \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3183207,
                "title": "java-easy-solution-with-detailed-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We have to find the `sum` so we need to start from the **right** end of both the numbers.\\n- To start iterating from the right end of the strings we first calculated the last indices `indexA` & `indexB`\\n- To store the digits sum we initialized `digitSum=0`\\n- To store the carry we initialized `carry=0`\\n- Then we keep a check if `a` & `b` is non-Empty if yes we increase the `digitSum`\\n- To keep check of the `carry`, we check if `digitSum > 1`. If yes, that means there is a `carry` and it needs to be considered.\\n\\n- At last, we insert the calculated digit at the start of the StringBuilder.\\n- And then return the sum after converting it to String via `toString()`. \\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please give this an UPVOTE if you find it useful!\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sum= new StringBuilder(\"\");\\n        int indexA= a.length()-1;\\n        int indexB =b.length()-1;\\n        int carry=0;\\n        int digitSum=0;\\n        while(indexA >= 0 || indexB >= 0 || carry > 0 ){\\n            digitSum = carry;\\n            if(indexA >= 0) digitSum += a.charAt(indexA--)-\\'0\\';\\n            if(indexB >= 0) digitSum += b.charAt(indexB--)-\\'0\\';\\n            if(digitSum >1) carry=1;\\n            else carry=0;\\n            sum.insert(0, digitSum%2);\\n        }\\n        return sum.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sum= new StringBuilder(\"\");\\n        int indexA= a.length()-1;\\n        int indexB =b.length()-1;\\n        int carry=0;\\n        int digitSum=0;\\n        while(indexA >= 0 || indexB >= 0 || carry > 0 ){\\n            digitSum = carry;\\n            if(indexA >= 0) digitSum += a.charAt(indexA--)-\\'0\\';\\n            if(indexB >= 0) digitSum += b.charAt(indexB--)-\\'0\\';\\n            if(digitSum >1) carry=1;\\n            else carry=0;\\n            sum.insert(0, digitSum%2);\\n        }\\n        return sum.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372361,
                "title": "java-1ms-100-100-simple-explanation-without-converting-char-in-one-loop",
                "content": "```java\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        boolean carry = false;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\t\\t// Create a buffer with length equal to the bigger input String  + 1 to carry overflow\\n\\t\\t// Result of \\'11\\' + \\'1\\' = \\'100\\', so length(\\'11\\') + 1 = 3\\n        StringBuilder result = new StringBuilder(((i > j) ? i : j) + 1); \\n        \\n        while (i >= 0 || j >= 0) {\\n\\t\\t\\t// if one of the input is shorter, use \\'0\\' as operand. \\'11\\' + \\'1\\' = \\'11\\' + \\'01\\'\\n            char charA = (i >= 0) ? a.charAt(i--) : \\'0\\'; \\n            char charB = (j >= 0) ? b.charAt(j--) : \\'0\\';\\n            \\n\\t\\t\\t// Cases when adding Binary\\t\\t\\t\\n\\t\\t\\t// 0 + 0 = 0 \\n\\t\\t\\t// 1 + 0 = 1\\n\\t\\t\\t// 1 + 1 = 10 \\n\\t\\t\\t// 1 + 1 + 1 = 11\\n            if (charA == \\'1\\' && charB == \\'1\\') { // 1 + 1\\n\\t\\t\\t\\tresult = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 11 or 10 ?\\n\\t\\t\\t\\tcarry = true;\\n            } else if (charA == \\'0\\' && charB == \\'0\\') { // 0 + 0\\n                result = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 1 or 0 ?\\n                carry = false;\\n            } else { // 1 + 0 or 0 + 1\\n                result = (carry) ? result.append(\\'0\\') : result.append(\\'1\\'); // result is 10 or 1 ?\\n            }\\n        }\\n        \\n\\t\\t// carry overflow : \\'11\\' + \\'1\\' = \\'00\\' + 1 overflow = \\'001\\'\\n        if (carry) result.append(\\'1\\');\\n        \\n\\t\\t// reverse the result string : \\'11\\' + \\'1\\' = \\'001\\' , so reverse it to obtain \\'100\\'\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        boolean carry = false;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\t\\t// Create a buffer with length equal to the bigger input String  + 1 to carry overflow\\n\\t\\t// Result of \\'11\\' + \\'1\\' = \\'100\\', so length(\\'11\\') + 1 = 3\\n        StringBuilder result = new StringBuilder(((i > j) ? i : j) + 1); \\n        \\n        while (i >= 0 || j >= 0) {\\n\\t\\t\\t// if one of the input is shorter, use \\'0\\' as operand. \\'11\\' + \\'1\\' = \\'11\\' + \\'01\\'\\n            char charA = (i >= 0) ? a.charAt(i--) : \\'0\\'; \\n            char charB = (j >= 0) ? b.charAt(j--) : \\'0\\';\\n            \\n\\t\\t\\t// Cases when adding Binary\\t\\t\\t\\n\\t\\t\\t// 0 + 0 = 0 \\n\\t\\t\\t// 1 + 0 = 1\\n\\t\\t\\t// 1 + 1 = 10 \\n\\t\\t\\t// 1 + 1 + 1 = 11\\n            if (charA == \\'1\\' && charB == \\'1\\') { // 1 + 1\\n\\t\\t\\t\\tresult = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 11 or 10 ?\\n\\t\\t\\t\\tcarry = true;\\n            } else if (charA == \\'0\\' && charB == \\'0\\') { // 0 + 0\\n                result = (carry) ? result.append(\\'1\\') : result.append(\\'0\\'); // result is 1 or 0 ?\\n                carry = false;\\n            } else { // 1 + 0 or 0 + 1\\n                result = (carry) ? result.append(\\'0\\') : result.append(\\'1\\'); // result is 10 or 1 ?\\n            }\\n        }\\n        \\n\\t\\t// carry overflow : \\'11\\' + \\'1\\' = \\'00\\' + 1 overflow = \\'001\\'\\n        if (carry) result.append(\\'1\\');\\n        \\n\\t\\t// reverse the result string : \\'11\\' + \\'1\\' = \\'001\\' , so reverse it to obtain \\'100\\'\\n        return result.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24476,
                "title": "super-short-java-code",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sum = new StringBuilder();\\n            int i = a.length() - 1;\\n            int j = b.length() - 1;\\n            int carry = 0;\\n            while (i >= 0 || j >= 0 || carry == 1) {\\n                int digitA = i < 0 ? 0 : a.charAt(i--) - '0';\\n                int digitB = j < 0 ? 0 : b.charAt(j--) - '0';\\n                sum.insert(0, (digitA + digitB + carry) % 2);\\n                carry = (digitA + digitB + carry) / 2;\\n            }\\n            return sum.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder sum = new StringBuilder();\\n            int i = a.length() - 1;\\n            int j = b.length() - 1;\\n            int carry = 0;\\n            while (i >= 0 || j >= 0 || carry == 1) {\\n                int digitA = i < 0 ? 0 : a.charAt(i--) - '0';\\n                int digitB = j < 0 ? 0 : b.charAt(j--) - '0';\\n                sum.insert(0, (digitA + digitB + carry) % 2);\\n                carry = (digitA + digitB + carry) / 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 294845,
                "title": "one-line-java-solution",
                "content": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203758,
                "title": "very-simple-swift-solution",
                "content": "```\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        var a = a, b = b\\n        var carry = 0\\n        var result = \"\"\\n        while !a.isEmpty || !b.isEmpty || carry > 0 {\\n            let x = Int(a.isEmpty ? \"0\" : String(a.removeLast()))!\\n            let y = Int(b.isEmpty ? \"0\" : String(b.removeLast()))!\\n            let sum = x + y + carry\\n            result = String(sum % 2) + result\\n            carry = sum / 2\\n        }        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        var a = a, b = b\\n        var carry = 0\\n        var result = \"\"\\n        while !a.isEmpty || !b.isEmpty || carry > 0 {\\n            let x = Int(a.isEmpty ? \"0\" : String(a.removeLast()))!\\n            let y = Int(b.isEmpty ? \"0\" : String(b.removeLast()))!\\n            let sum = x + y + carry\\n            result = String(sum % 2) + result\\n            carry = sum / 2\\n        }        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24788,
                "title": "short-o-n-time-o-1-space-c-solution",
                "content": "I just write the sum into the longer one of the inputs. Don't worry about modifying them, as getting `string` means we're getting copies. The \"O(1) space\" of course refers to the space I use in addition to input and output. If the output doesn't need to be longer than the longer input, I even only use O(1) space in addition to only the input.\\n\\n    struct Solution {\\n        string addBinary(string a, string b) {\\n            if (a.size() < b.size())\\n                swap(a, b);\\n            int i = a.size(), j = b.size();\\n            while (i--) {\\n                if (j) a[i] += b[--j] & 1;\\n                if (a[i] > '1') {\\n                    a[i] -= 2;\\n                    if (i) a[i-1]++; else a = '1' + a;\\n                }\\n            }\\n            return a;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "I just write the sum into the longer one of the inputs. Don't worry about modifying them, as getting `string` means we're getting copies. The \"O(1) space\" of course refers to the space I use in addition to input and output. If the output doesn't need to be longer than the longer input, I even only use O(1) space in addition to only the input.\\n\\n    struct Solution {\\n        string addBinary(string a, string b) {\\n            if (a.size() < b.size())\\n                swap(a, b);\\n            int i = a.size(), j = b.size();\\n            while (i--) {\\n                if (j) a[i] += b[--j] & 1;\\n                if (a[i] > '1') {\\n                    a[i] -= 2;\\n                    if (i) a[i-1]++; else a = '1' + a;\\n                }\\n            }\\n            return a;\\n        }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3182944,
                "title": "python-3-one-lines-of-code-time-95-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is a simple implementation of converting binary numbers to integers, adding them, and then converting the sum back to binary. The conversion of binary to integer is done using the int() method with a base of 2, which means that it will treat the string as a binary number and return the equivalent integer. After adding the integers,\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a , 2) + int(b,2))[2:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a , 2) + int(b,2))[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637606,
                "title": "c-easy-to-understand-o-n-m-diagrammatic-representation",
                "content": "**Approach**\\n![image](https://assets.leetcode.com/users/images/ed94d72f-379a-4868-910b-ae5c2ac3606c_1664435071.5181186.png)\\n\\n``` \\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) \\n    {\\n        int n = a.size(), m = b.size();\\n        int i = n-1 , j = m-1;\\n        int carry = 0;\\n        string ans = \"\";\\n        while(i >= 0 || j >= 0)\\n        {\\n            int val1 = (i >= 0) ? a[i]-\\'0\\' : 0 ;\\n            int val2 = (j >= 0) ? b[j]-\\'0\\' : 0 ;\\n            \\n            int total = val1 + val2 + carry ;\\n            ans = to_string(total % 2) + ans ;\\n\\t\\t\\t/*\\n\\t\\t\\tif total = 3 means ans will be 1 since 1 + 1 + 1 = 1 with carry 1.\\n\\t\\t\\tif total = 2 then ans will be 0 since 1 + 1 = 0 with carry 1.\\n\\t\\t\\tif total = 1 means ans will be 1 since 0 + 1 = 1 with carry 0.\\n\\t\\t\\t*/\\n            carry = total/2 ;\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry)\\n        {\\n            ans = \\'1\\' + ans ;\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```\\n\\n**Time Complexity = O(N+M)**\\n**Space Comlexity = O(M)**\\n\\n**If you understood the approach then please do upvote!**\\n**Happy Coding!\\u2764\\uFE0F**",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) \\n    {\\n        int n = a.size(), m = b.size();\\n        int i = n-1 , j = m-1;\\n        int carry = 0;\\n        string ans = \"\";\\n        while(i >= 0 || j >= 0)\\n        {\\n            int val1 = (i >= 0) ? a[i]-\\'0\\' : 0 ;\\n            int val2 = (j >= 0) ? b[j]-\\'0\\' : 0 ;\\n            \\n            int total = val1 + val2 + carry ;\\n            ans = to_string(total % 2) + ans ;\\n\\t\\t\\t/*\\n\\t\\t\\tif total = 3 means ans will be 1 since 1 + 1 + 1 = 1 with carry 1.\\n\\t\\t\\tif total = 2 then ans will be 0 since 1 + 1 = 0 with carry 1.\\n\\t\\t\\tif total = 1 means ans will be 1 since 0 + 1 = 1 with carry 0.\\n\\t\\t\\t*/\\n            carry = total/2 ;\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry)\\n        {\\n            ans = \\'1\\' + ans ;\\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421832,
                "title": "python3-self-understandable",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        while len(b)<len(a):\\n            b=\\'0\\'+b\\n        while len(a)<len(b):\\n            a=\\'0\\'+a\\n        carry=0\\n        a=[int(i) for i in a]\\n        b=[int(i) for i in b]\\n        ans=\\'\\'\\n        for i in range(len(a)-1,-1,-1):\\n            val=a[i]+b[i]+carry\\n            if val==3:\\n                carry=1\\n                ans=\\'1\\'+ans\\n            elif val==2:\\n                carry=1\\n                ans=\\'0\\'+ans\\n            elif val==1:\\n                ans=\\'1\\'+ans\\n                carry=0\\n            else:\\n                ans=\\'0\\'+ans\\n        return str(carry)+ans if carry else ans\\n```\\n\\n***Do upvote if you found my solution helpful :)***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        while len(b)<len(a):\\n            b=\\'0\\'+b\\n        while len(a)<len(b):\\n            a=\\'0\\'+a\\n        carry=0\\n        a=[int(i) for i in a]\\n        b=[int(i) for i in b]\\n        ans=\\'\\'\\n        for i in range(len(a)-1,-1,-1):\\n            val=a[i]+b[i]+carry\\n            if val==3:\\n                carry=1\\n                ans=\\'1\\'+ans\\n            elif val==2:\\n                carry=1\\n                ans=\\'0\\'+ans\\n            elif val==1:\\n                ans=\\'1\\'+ans\\n                carry=0\\n            else:\\n                ans=\\'0\\'+ans\\n        return str(carry)+ans if carry else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061502,
                "title": "rust-one-liner",
                "content": "Just for fun seeing some Python solutions wanted to find out how terse this could be done in Rust. Behold:\\n\\n```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        format!(\"{:b}\", u128::from_str_radix(&a, 2).unwrap() + u128::from_str_radix(&b, 2).unwrap())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        format!(\"{:b}\", u128::from_str_radix(&a, 2).unwrap() + u128::from_str_radix(&b, 2).unwrap())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24671,
                "title": "my-0ms-c-solution-15-lines",
                "content": "    char* addBinary(char* a, char* b) {\\n    int lena = strlen(a), lenb = strlen(b), carry = 0;\\n    int lenc = lena > lenb?lena:lenb;\\n    char * c = malloc(lenc+2);\\n    c[lenc+1] = '\\\\0';\\n    while(lena || lenb ){\\n        if(lena) carry += (a[--lena]-'0');\\n        if(lenb) carry += (b[--lenb]-'0');\\n        c[lenc--] = (carry&1)+'0';\\n        carry >>= 1;\\n    }\\n    c[0] = carry+'0';\\n    return c+(carry^1);\\n    // for(int i = -1, j = 0;c[j] && !carry;c[++i] = c[++j]);\\n    // return c;\\n    }",
                "solutionTags": [],
                "code": "    char* addBinary(char* a, char* b) {\\n    int lena = strlen(a), lenb = strlen(b), carry = 0;\\n    int lenc = lena > lenb?lena:lenb;\\n    char * c = malloc(lenc+2);\\n    c[lenc+1] = '\\\\0';\\n    while(lena || lenb ){\\n        if(lena) carry += (a[--lena]-'0');\\n        if(lenb) carry += (b[--lenb]-'0');\\n        c[lenc--] = (carry&1)+'0';\\n        carry >>= 1;\\n    }\\n    c[0] = carry+'0';\\n    return c+(carry^1);\\n    // for(int i = -1, j = 0;c[j] && !carry;c[++i] = c[++j]);\\n    // return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24585,
                "title": "my-simple-4ms-java-solution-clean-and-consice",
                "content": "      public String addBinary(String a, String b) {\\n        int aLength = a.length();\\n        int bLength = b.length();\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        while(Math.max(aLength, bLength) > 0) {\\n          int aNum = aLength > 0 ? (a.charAt(aLength---1) - '0') : 0;\\n          int bNum = bLength > 0 ? (b.charAt(bLength---1) - '0') : 0;\\n          int cNum = aNum + bNum + carry;\\n          sb.append(cNum%2);\\n          carry = cNum / 2;\\n        }\\n        return (carry == 1)?sb.append(1).reverse().toString():sb.reverse().toString();\\n      }",
                "solutionTags": [
                    "Java"
                ],
                "code": "      public String addBinary(String a, String b) {\\n        int aLength = a.length();\\n        int bLength = b.length();\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        while(Math.max(aLength, bLength) > 0) {\\n          int aNum = aLength > 0 ? (a.charAt(aLength---1) - '0') : 0;\\n          int bNum = bLength > 0 ? (b.charAt(bLength---1) - '0') : 0;\\n          int cNum = aNum + bNum + carry;\\n          sb.append(cNum%2);\\n          carry = cNum / 2;\\n        }\\n        return (carry == 1)?sb.append(1).reverse().toString():sb.reverse().toString();\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 3059554,
                "title": "very-straightforward-c-solution",
                "content": "# Approach\\nStarting from the end of numbers `a` and `b`, sum the digits one by one in a loop while keeping track of a carry on each step. If one of the numbers ends, use a zero instead of a digit. In the end, reverse the result list and concatenate all digits to get the final number. That\\'s it!\\n\\n# Complexity\\n- Time complexity: $$O(Max(n,m))$$\\n\\n- Space complexity: $$O(Max(n,m))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var sum = new List<int>();\\n        for (int i = a.Length - 1, j = b.Length - 1, carry = 0; i >= 0 || j >= 0 || carry > 0;)\\n        {\\n            var firstDigit = i >= 0 ? a[i--] - \\'0\\' : 0;\\n            var secondDigit = j >= 0 ? b[j--] - \\'0\\' : 0;\\n            var sumDigit = firstDigit + secondDigit + carry;\\n            carry = sumDigit / 2;\\n            sum.Add(sumDigit % 2);\\n        }\\n        sum.Reverse();\\n        return String.Concat(sum);\\n    }\\n}\\n```\\n\\nPlease, upvote if the solution was useful for you!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var sum = new List<int>();\\n        for (int i = a.Length - 1, j = b.Length - 1, carry = 0; i >= 0 || j >= 0 || carry > 0;)\\n        {\\n            var firstDigit = i >= 0 ? a[i--] - \\'0\\' : 0;\\n            var secondDigit = j >= 0 ? b[j--] - \\'0\\' : 0;\\n            var sumDigit = firstDigit + secondDigit + carry;\\n            carry = sumDigit / 2;\\n            sum.Add(sumDigit % 2);\\n        }\\n        sum.Reverse();\\n        return String.Concat(sum);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243244,
                "title": "c-100-faster-0-ms-clean-code",
                "content": "***\\u2714C++ Implementation :***\\n\\n```\\n\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int carry = 0;\\n        string ans=\"\";\\n        int i=0;\\n        while(i<a.length() && i<b.length()){\\n            int sum = carry + (a[i] - \\'0\\') + (b[i]-\\'0\\');\\n            carry = sum>=2 ? 1 : 0;\\n            ans += (sum%2) + \\'0\\';\\n            i++;\\n        }\\n        \\n\\n            if(i<a.length()){\\n                while(i<a.length()){\\n                    int sum = carry + (a[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }else{\\n                while(i<b.length()){\\n                    int sum = carry + (b[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }\\n        \\n        if(carry) ans += carry + \\'0\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\t\\n```\\n\\nHope you liked it , kindly upvote :)\\n\\n## Happy Coding Fellas \\uD83E\\uDD17\\u270C\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int carry = 0;\\n        string ans=\"\";\\n        int i=0;\\n        while(i<a.length() && i<b.length()){\\n            int sum = carry + (a[i] - \\'0\\') + (b[i]-\\'0\\');\\n            carry = sum>=2 ? 1 : 0;\\n            ans += (sum%2) + \\'0\\';\\n            i++;\\n        }\\n        \\n\\n            if(i<a.length()){\\n                while(i<a.length()){\\n                    int sum = carry + (a[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }else{\\n                while(i<b.length()){\\n                    int sum = carry + (b[i] - \\'0\\');\\n                    carry = sum>=2 ? 1 : 0;\\n                    ans += (sum%2) + \\'0\\';\\n                    i++;\\n                }\\n            }\\n        \\n        if(carry) ans += carry + \\'0\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218664,
                "title": "java-bit-manipulation-xor-and-100-explanations",
                "content": "**1. What are the inputs ?**\\n- 3 numbers : `n1`, `n2`, `c(carry)`, are used to form a new number, denoted as `n`\\n\\n**2. What remains as output(in one digit)?**\\n- The least significant digit of n.\\n\\n**3. What gets to shift to more significant bits?**\\n- The most significant digit of n (since n can have at most two digits here, the highest digit).  \\n\\n\\n**4. Patterns of the least significant digit (denoted as `lowest`)**\\n- `lowest` = 0 if:\\n\\t-  any two of n1, n2, and carry are 1 OR\\n\\t-  all three are 0, \\n\\t-  which means an even number of 1s is needed to form a 0. \\n- `lowest` = 1 if :\\n\\t-  any one of n1, n2 and carry is 1 OR\\n\\t-  all three are 1\\n\\t-  which means an odd number of 1s is needed to form a 1. \\n- This leads us to the **XOR** operation. \\n\\t- 0 ^ 0 ^ 0 = 0\\n\\t- 0 ^ 0 ^ 1 = 1\\n\\t- 0 ^ 1 ^ 0 = 1\\n\\t- 0 ^ 1 ^ 1 = 0\\n\\t- 1 ^ 0 ^ 0  = 1\\n\\t- 1 ^ 0 ^ 1 = 0 \\n\\t- 1 ^ 1 ^ 0 = 0\\n\\t- 1 ^ 1 ^ 1 = 1 \\n\\n**5. Patterns of the most siginificant digit (denoted as `highest`) :**\\nLet\\'s go back to elementary arithmetic and think about :\\n- What is a carry? \\n\\t-  Carry is a number being transferred from a lower digit to a higher one.  \\n- Why do we need a carry ? \\n\\t- A number is too large for the lower digits to represent. \\n- Specifically, when do we need a carry in the binary system\\uFF1F\\n\\t- When a number is **larger than or equal to 2**. \\n- How to make sure the number `n` is at least two? \\n\\t- n is at least two = at least two components, n1, n2, and carry have values of 1. \\n\\t- Make use of the **&** operator. \\n\\t- Because only 1 & 1 = 1, all other cases 1 & 0, 0 & 0, 0 & 1 are 0. \\n```\\npublic String addBinary(String a, String b) {\\n\\tint pa = a.length() - 1, pb = b.length() - 1; \\n\\tint carry = 0;\\n\\tStringBuilder builder = new StringBuilder(); \\n\\n\\tint na, nb; \\n\\twhile (pa >= 0 || pb >= 0 || carry != 0) {\\n\\t\\tna = pa >= 0 ? a.charAt(pa) - \\'0\\' : 0;\\n\\t\\tnb = pb >= 0 ? b.charAt(pb) - \\'0\\' : 0;\\n\\t\\tbuilder.append(na ^ nb ^ carry);  // add lowest to output\\n\\t\\tcarry = (na & nb) | (na & carry) | (nb & carry);  // keeps highest as next carry \\n\\t\\tpa--;\\n\\t\\tpb--;\\n\\t}\\n\\n\\treturn builder.reverse().toString(); \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic String addBinary(String a, String b) {\\n\\tint pa = a.length() - 1, pb = b.length() - 1; \\n\\tint carry = 0;\\n\\tStringBuilder builder = new StringBuilder(); \\n\\n\\tint na, nb; \\n\\twhile (pa >= 0 || pb >= 0 || carry != 0) {\\n\\t\\tna = pa >= 0 ? a.charAt(pa) - \\'0\\' : 0;\\n\\t\\tnb = pb >= 0 ? b.charAt(pb) - \\'0\\' : 0;\\n\\t\\tbuilder.append(na ^ nb ^ carry);  // add lowest to output\\n\\t\\tcarry = (na & nb) | (na & carry) | (nb & carry);  // keeps highest as next carry \\n\\t\\tpa--;\\n\\t\\tpb--;\\n\\t}\\n\\n\\treturn builder.reverse().toString(); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3186596,
                "title": "have-you-thought-this-way-beats-100-self-explanatory-code",
                "content": "![3549-pepepopcorn.png](https://assets.leetcode.com/users/images/19cd7464-9788-4e2b-b03c-92c42adf55eb_1676405483.184702.png)\\n\\nVery easy indeed. But have you thought this way?\\n\\n# Approach\\nYou probably know that from decimal to binary:\\n0 -> 0\\n1 -> 1\\n2 -> 10\\n3 -> 11\\n\\nHow about we split them as sums of 1 and 0\\'s:\\n\\n| carry | ch1 | ch2 | sum | decimal value |\\n|-------|-----|-----|-----|-----|\\n| 0 | 0 | 0 | 0| 0 |\\n|0 | 0 | 1 | 1 | 1 |\\n|0 | 1 | 0 | 10 | 2 |\\n|1 | 1 | 1 | 11 | 3 |\\n\\nWe need to first distinguish the larger and smaller strings. For our solution, we will always determine **a** as smaller and **b** as larger. If they are not, we will swap them.\\n\\nThen, we will iterate the loop until the larger value >= 0. \\n- If the smaller value is < 0, we will assign ch1 = 0;\\n- Then we will sum all of them. Remind to sum the carry. At first the carry is 0.\\n- If the sum is either 0 or 1, carry will be 0.\\n- But if the sum is 2 or 3, the carry will be 1.\\n- The string appended will be 0 for sum = 2\\nand 1 for sum = 3.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\nWe declare a new StringBuilder and also a new temp variable while swapping the strings. These will require extra space. The size is dependent on the input length. That\\'s why O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int smaller = a.length()-1, larger = b.length()-1;\\n        if(smaller>larger){\\n            int tmp = smaller;\\n            smaller = larger;\\n            larger = tmp;\\n            String temp = a;\\n            a = b;\\n            b = temp;\\n        }\\n        int carry = 0;\\n        while(larger>=0){\\n            int ch1 = (smaller>=0)?a.charAt(smaller)-\\'0\\':0;\\n            int ch2 = b.charAt(larger)-\\'0\\';\\n            int sum = ch1 + ch2 + carry;\\n            // 2 = 10\\n            if(sum == 2){\\n                carry = 1;\\n                sb.append(\"0\");\\n            }\\n            // 3 = 11\\n            else if(sum == 3){\\n                carry = 1;\\n                sb.append(\"1\");\\n            }\\n            // 1 = 1, or, 0 = 0\\n            else{\\n                carry = 0;\\n                char ch = (char)(sum+\\'0\\');\\n                sb.append(ch);\\n            }\\n            smaller--;\\n            larger--;\\n        }\\n        // if there\\'s still one carry left!\\n        if(carry == 1){\\n            sb.append(\"1\");\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/a1a61be1-eb3e-4e69-8d8a-49ce68f4a13b_1676405549.70167.png)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int smaller = a.length()-1, larger = b.length()-1;\\n        if(smaller>larger){\\n            int tmp = smaller;\\n            smaller = larger;\\n            larger = tmp;\\n            String temp = a;\\n            a = b;\\n            b = temp;\\n        }\\n        int carry = 0;\\n        while(larger>=0){\\n            int ch1 = (smaller>=0)?a.charAt(smaller)-\\'0\\':0;\\n            int ch2 = b.charAt(larger)-\\'0\\';\\n            int sum = ch1 + ch2 + carry;\\n            // 2 = 10\\n            if(sum == 2){\\n                carry = 1;\\n                sb.append(\"0\");\\n            }\\n            // 3 = 11\\n            else if(sum == 3){\\n                carry = 1;\\n                sb.append(\"1\");\\n            }\\n            // 1 = 1, or, 0 = 0\\n            else{\\n                carry = 0;\\n                char ch = (char)(sum+\\'0\\');\\n                sb.append(ch);\\n            }\\n            smaller--;\\n            larger--;\\n        }\\n        // if there\\'s still one carry left!\\n        if(carry == 1){\\n            sb.append(\"1\");\\n        }\\n        \\n        sb.reverse();\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329387,
                "title": "solution-swift-add-binary",
                "content": "```swift\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        let arrA = Array(a), arrB = Array(b)\\n        var result = \"\", carry = 0, idx1 = arrA.count - 1, idx2 = arrB.count - 1\\n        \\n        while idx1 >= 0 || idx2 >= 0 || carry > 0 {\\n            var sum = carry\\n            idx1 >= 0 ? (sum += Int(\"\\\\(arrA[idx1])\")!, idx1 -= 1) : nil\\n            idx2 >= 0 ? (sum += Int(\"\\\\(arrB[idx2])\")!, idx2 -= 1) : nil\\n            result = \"\\\\(sum % 2)\" + result\\n            carry = sum / 2\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.016 (0.018) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.addBinary(\"11\", \"1\")\\n        XCTAssertEqual(value, \"100\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.addBinary(\"1010\", \"1011\")\\n        XCTAssertEqual(value, \"10101\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func addBinary(_ a: String, _ b: String) -> String {\\n        let arrA = Array(a), arrB = Array(b)\\n        var result = \"\", carry = 0, idx1 = arrA.count - 1, idx2 = arrB.count - 1\\n        \\n        while idx1 >= 0 || idx2 >= 0 || carry > 0 {\\n            var sum = carry\\n            idx1 >= 0 ? (sum += Int(\"\\\\(arrA[idx1])\")!, idx1 -= 1) : nil\\n            idx2 >= 0 ? (sum += Int(\"\\\\(arrB[idx2])\")!, idx2 -= 1) : nil\\n            result = \"\\\\(sum % 2)\" + result\\n            carry = sum / 2\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.addBinary(\"11\", \"1\")\\n        XCTAssertEqual(value, \"100\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.addBinary(\"1010\", \"1011\")\\n        XCTAssertEqual(value, \"10101\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695976,
                "title": "c-2-solutions-easy-to-understand-bit-manipulation-and-bit-by-bit-addition",
                "content": "**Addition Operation**\\n\\nStraight-forward solution where you add up the bits one at a time.\\n\\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] : \\'0\\';\\n            var c2 = n2 >= 0 ? b[n2] : \\'0\\';\\n            \\n            var sum = carry + (c1-\\'0\\') + (c2-\\'0\\');\\n            if(sum > 1) {\\n                carry = 1;\\n                sum = sum - 2;\\n            } else {\\n                carry = 0;\\n            }\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```\\n\\n**Bit Manipulation**\\n\\nA follow-up to this question is to solve this problem without using addition operation. We can use bit manipulation instead. The intuition is that to calculate carry, at least 2 of the 3 bits (carry, bit from string a, bit from string b) have to be 1. Therefore, you can do:\\n`carry = (c1 | carry ) & (c2 | carry) & (c1 | c2);`\\n\\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] - \\'0\\' : 0;\\n            var c2 = n2 >= 0 ? b[n2] - \\'0\\' : 0;\\n            \\n            var sum = (c1 ^ c2 ^ carry);\\n            carry = (c1 | carry ) & (c2 | carry) & (c1 | c2);\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n\\n        return result.ToString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] : \\'0\\';\\n            var c2 = n2 >= 0 ? b[n2] : \\'0\\';\\n            \\n            var sum = carry + (c1-\\'0\\') + (c2-\\'0\\');\\n            if(sum > 1) {\\n                carry = 1;\\n                sum = sum - 2;\\n            } else {\\n                carry = 0;\\n            }\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        var n1 = a.Length - 1;\\n        var n2 = b.Length - 1;\\n        var carry = 0;\\n        \\n        var result = new StringBuilder();\\n        while(carry > 0 || n1 >= 0 || n2 >= 0) {\\n            var c1 = n1 >= 0 ? a[n1] - \\'0\\' : 0;\\n            var c2 = n2 >= 0 ? b[n2] - \\'0\\' : 0;\\n            \\n            var sum = (c1 ^ c2 ^ carry);\\n            carry = (c1 | carry ) & (c2 | carry) & (c1 | c2);\\n            \\n            result.Insert(0, sum);\\n            \\n            n1--;\\n            n2--;\\n        }\\n\\n        return result.ToString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198691,
                "title": "java-one-liner",
                "content": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return new BigInteger(a, 2).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190723,
                "title": "5ms-java-solution-with-explanation-of-code-and-binary-adding",
                "content": "I didn\\u2019t like the other Java solutions posted, they seem to either use \\u201Ctricks\\u201D or don\\u2019t explain what\\u2019s going on. So first of all I\\u2019ll start by saying that if you haven\\u2019t noticed, it\\u2019s a lot harder to solve this problem concisely in Java than it is in Python or C++. Below is a 5ms solution, so only faster than 25% of solutions. I purposely haven\\u2019t optimized it to its max potential to keep it legible, but hopefully you can find a faster way of doing it.\\n\\n\\n\\\\\\n\\\\\\n***Arithmetic***  \\n\\\\\\nTo solve the problem, you need to know how arithmetic works for any base. Humans use base 10, so our number system is composed of the combination of numbers from 0-9. Think of the base as the amount of unique digits you can represent a number with, but make sure to include 0. Right now we are trying to make an adder for base 2, a.k.a binary.\\n\\nYou should already know how adding works, you start by adding two values from right to left. Let\\u2019s call this value the *sum*. If the *sum* exceeds the highest single integer you can represent them with ( for base 10: 9, binary: 1), you subtract the base from the *sum*  *n* amount of times, where *n* is the number of times you had to subtract base from *sum* be within the range of the integers you can represent. You then \\u201Ccarry over\\u201D the value of *n*, to be added to the next pair of integers.\\n\\n\\n\\\\\\n\\\\\\nA base 10 example:\\n\\nFor 27 + 27, you add 7+7 to get 14, which is greater than 9. So you subtract 10 once from 14, and now you have a carry of 1 and a final sum of 4. You now add one, two, and two to get 5. So your final answer is 54.\\n\\n\\\\\\nSo for binary a = \\u201C11\\u201D, b = \\u201C1\\u201D\\na: 11\\nb: 01\\n\\nFirst we add 1+1, which equals 2. Since 2 > 1, our highest integer, we set the value of the first place to to 2 - 2 (0), and carry over the base * 1 to the next addition. So our result right now is **0**, and we have a carry of 1 (our base times 1.)\\n\\nSo 1+0 is 0, but our carry is also 1. We add the carry to this sum, and now the value is 2 (1 + 0 + 1.) We do the same thing as last time, and set the sum to 2-2, and carry over the base*I, the amount of time we had to subtract 2 to get the value to be less than 2, yet again. Our result right now is **00**.\\n\\nWe are out of numbers to add, but we still have a carry of base, so we simply add that to the end. Our final result is then **100**.\\n\\n\\n\\n\\n\\nBy now you probably have a good idea of how to solve this problem, but there\\u2019s one case you have to watch out for: when the carry is greater than 1.\\n\\\\\\n\\\\\\nSo for binary a = \\u201C110\\u201D, b = \\u201C111\\u201D\\na: 110\\nb: 111\\n\\nFirst we add 0 + 1, and no carry, so our result is **1**\\nThen we add 1 + 1, since 2 > 1, we set our sum to 0 and carry over 1. Our result is now **01**\\n\\nNow we do 1+1 again, except with a carry of 1, so the real sum is 3. Since 3 > 1, we have to subtract 2 from it just once, but now the final sum is 1, not 0. Most people will try to implement a binary adder where you simply set the final value to 0 when the final sum is greater than 1, but that\\u2019s too naive of an approach. \\n\\nCheck out how I implemented it, after writing this I think I\\u2019ve found 10 new ways of making this more efficient, but I\\u2019ll let you have at it.\\n\\\\\\n\\\\\\n***Code***  \\n\\n` \\n\\n    public String addBinary(String a, String b) {\\n    // As another user pointed out, iterating across char arrays is faster than using\\n    // charAt(); So split into them and iterate with a single pointer.\\n    char[] aArray = a.toCharArray();\\n    int aLen = aArray.length;\\n\\t\\n    char[] bArray = b.toCharArray();\\n    int bLen = bArray.length;\\n\\n    int ptr = 0;\\n\\n    int carry=0;\\n    int aVal=0;\\n    int bVal=0;\\n    String strToReturn=\\u201C\\u201D;\\n\\n    while(ptr < aLen || ptr < bLen) {\\n      aVal=0; bVal=0; // Reset values after every pointer iteration.\\n      if(ptr < aLen)\\n        aVal = (aArray[aLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0; // Converts from char to integer\\n      if(ptr <bLen)\\n        bVal = (bArray[bLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0;\\n\\n      int finalVal = aVal +bVal + carry; // total after adding carry.\\n      if(finalVal > 1) {\\n        carry=finalVal-1;\\n        if(carry > 1) {finalVal = 1; carry=1; }\\n        else finalVal=0;\\n\\n      }\\n      else\\n          carry=0; // If either 0 or 1 after adding carry, just reset carry.\\n\\n      strToReturn=finalVal+\\u201D\\u201D+strToReturn; // Add to front of string.\\n      ptr++;\\n    }\\n    if(carry > 0) strToReturn=\\u201C1\\u201D+strToReturn; // If any leftover carry at the end, just append a \\u201C1\\u201D to the start.\\n    return strToReturn;\\n    }\\n`\\n\\n\\n",
                "solutionTags": [],
                "code": "I didn\\u2019t like the other Java solutions posted, they seem to either use \\u201Ctricks\\u201D or don\\u2019t explain what\\u2019s going on. So first of all I\\u2019ll start by saying that if you haven\\u2019t noticed, it\\u2019s a lot harder to solve this problem concisely in Java than it is in Python or C++. Below is a 5ms solution, so only faster than 25% of solutions. I purposely haven\\u2019t optimized it to its max potential to keep it legible, but hopefully you can find a faster way of doing it.\\n\\n\\n\\\\\\n\\\\\\n***Arithmetic***  \\n\\\\\\nTo solve the problem, you need to know how arithmetic works for any base. Humans use base 10, so our number system is composed of the combination of numbers from 0-9. Think of the base as the amount of unique digits you can represent a number with, but make sure to include 0. Right now we are trying to make an adder for base 2, a.k.a binary.\\n\\nYou should already know how adding works, you start by adding two values from right to left. Let\\u2019s call this value the *sum*. If the *sum* exceeds the highest single integer you can represent them with ( for base 10: 9, binary: 1), you subtract the base from the *sum*  *n* amount of times, where *n* is the number of times you had to subtract base from *sum* be within the range of the integers you can represent. You then \\u201Ccarry over\\u201D the value of *n*, to be added to the next pair of integers.\\n\\n\\n\\\\\\n\\\\\\nA base 10 example:\\n\\nFor 27 + 27, you add 7+7 to get 14, which is greater than 9. So you subtract 10 once from 14, and now you have a carry of 1 and a final sum of 4. You now add one, two, and two to get 5. So your final answer is 54.\\n\\n\\\\\\nSo for binary a = \\u201C11\\u201D, b = \\u201C1\\u201D\\na: 11\\nb: 01\\n\\nFirst we add 1+1, which equals 2. Since 2 > 1, our highest integer, we set the value of the first place to to 2 - 2 (0), and carry over the base * 1 to the next addition. So our result right now is **0**, and we have a carry of 1 (our base times 1.)\\n\\nSo 1+0 is 0, but our carry is also 1. We add the carry to this sum, and now the value is 2 (1 + 0 + 1.) We do the same thing as last time, and set the sum to 2-2, and carry over the base*I, the amount of time we had to subtract 2 to get the value to be less than 2, yet again. Our result right now is **00**.\\n\\nWe are out of numbers to add, but we still have a carry of base, so we simply add that to the end. Our final result is then **100**.\\n\\n\\n\\n\\n\\nBy now you probably have a good idea of how to solve this problem, but there\\u2019s one case you have to watch out for: when the carry is greater than 1.\\n\\\\\\n\\\\\\nSo for binary a = \\u201C110\\u201D, b = \\u201C111\\u201D\\na: 110\\nb: 111\\n\\nFirst we add 0 + 1, and no carry, so our result is **1**\\nThen we add 1 + 1, since 2 > 1, we set our sum to 0 and carry over 1. Our result is now **01**\\n\\nNow we do 1+1 again, except with a carry of 1, so the real sum is 3. Since 3 > 1, we have to subtract 2 from it just once, but now the final sum is 1, not 0. Most people will try to implement a binary adder where you simply set the final value to 0 when the final sum is greater than 1, but that\\u2019s too naive of an approach. \\n\\nCheck out how I implemented it, after writing this I think I\\u2019ve found 10 new ways of making this more efficient, but I\\u2019ll let you have at it.\\n\\\\\\n\\\\\\n***Code***  \\n\\n` \\n\\n    public String addBinary(String a, String b) {\\n    // As another user pointed out, iterating across char arrays is faster than using\\n    // charAt(); So split into them and iterate with a single pointer.\\n    char[] aArray = a.toCharArray();\\n    int aLen = aArray.length;\\n\\t\\n    char[] bArray = b.toCharArray();\\n    int bLen = bArray.length;\\n\\n    int ptr = 0;\\n\\n    int carry=0;\\n    int aVal=0;\\n    int bVal=0;\\n    String strToReturn=\\u201C\\u201D;\\n\\n    while(ptr < aLen || ptr < bLen) {\\n      aVal=0; bVal=0; // Reset values after every pointer iteration.\\n      if(ptr < aLen)\\n        aVal = (aArray[aLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0; // Converts from char to integer\\n      if(ptr <bLen)\\n        bVal = (bArray[bLen-1 -ptr] == \\u20181\\u2019) ? 1 : 0;\\n\\n      int finalVal = aVal +bVal + carry; // total after adding carry.\\n      if(finalVal > 1) {\\n        carry=finalVal-1;\\n        if(carry > 1) {finalVal = 1; carry=1; }\\n        else finalVal=0;\\n\\n      }\\n      else\\n          carry=0; // If either 0 or 1 after adding carry, just reset carry.\\n\\n      strToReturn=finalVal+\\u201D\\u201D+strToReturn; // Add to front of string.\\n      ptr++;\\n    }\\n    if(carry > 0) strToReturn=\\u201C1\\u201D+strToReturn; // If any leftover carry at the end, just append a \\u201C1\\u201D to the start.\\n    return strToReturn;\\n    }\\n`\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 24656,
                "title": "7-line-7ms-c-code-probably-shortest",
                "content": "it's important to write concise code\\n\\n    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            string res;\\n            int i = a.size(), j = b.size(), cur = 0;\\n            while(i || j || cur) {\\n                cur += (i ? a[(i--)-1] -'0' : 0) + (j ? b[(j--)-1] -'0' : 0);\\n                res = char(cur%2 + '0') + res;\\n                cur /= 2;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            string res;\\n            int i = a.size(), j = b.size(), cur = 0;\\n            while(i || j || cur) {\\n                cur += (i ? a[(i--)-1] -'0' : 0) + (j ? b[(j--)-1] -'0' : 0);\\n                res = char(cur%2 + '0') + res;\\n                cur /= 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24838,
                "title": "a-straightforward-c-solution",
                "content": "  \\n\\n      string addBinary(string a, string b) {\\n            string result = \"\";\\n            int ia = a.size() - 1;\\n            int ib = b.size() - 1;\\n            int sum = 0;\\n            while (ia >= 0 || ib >= 0) {\\n                int va = 0, vb = 0;\\n                if (ia >= 0) {\\n                    va = a[ia] - '0'; ia --;\\n                }\\n                if (ib >= 0) {\\n                    vb = b[ib] - '0'; ib --;\\n                }\\n                sum = sum + va + vb;\\n                // possible values of sum: 0 ~ 3\\n                result = (sum % 2 == 0 ? \"0\" : \"1\") + result;\\n                sum = sum / 2;\\n            }\\n            if (sum == 1) result = \"1\" + result;\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "  \\n\\n      string addBinary(string a, string b) {\\n            string result = \"\";\\n            int ia = a.size() - 1;\\n            int ib = b.size() - 1;\\n            int sum = 0;\\n            while (ia >= 0 || ib >= 0) {\\n                int va = 0, vb = 0;\\n                if (ia >= 0) {\\n                    va = a[ia] - '0'; ia --;\\n                }\\n                if (ib >= 0) {\\n                    vb = b[ib] - '0'; ib --;\\n                }\\n                sum = sum + va + vb;\\n                // possible values of sum: 0 ~ 3\\n                result = (sum % 2 == 0 ? \"0\" : \"1\") + result;\\n                sum = sum / 2;\\n            }\\n            if (sum == 1) result = \"1\" + result;\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 24808,
                "title": "python-one-liner-solution",
                "content": "    class Solution:\\n        # @param {string} a\\n        # @param {string} b\\n        # @return {string}\\n        def addBinary(self, a, b):\\n            return bin(int(a,2) + int(b,2))[2:]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 24797,
                "title": "213ms-java-solution-use-two-pointer-to-calculate-o-n-times",
                "content": "    public class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder str = new StringBuilder();\\n            int aPtr = a.length() - 1;\\n            int bPtr = b.length() - 1;\\n            int carry = 0;\\n            int count = 0;\\n            while(aPtr >= 0 || bPtr >= 0) {\\n                if(aPtr >= 0) {\\n                    if(a.charAt(aPtr) == '1') {\\n                        count ++;\\n                    }\\n                }\\n                if(bPtr >= 0) {\\n                    if(b.charAt(bPtr) == '1') {\\n                        count ++;\\n                    }\\n                }\\n                if(carry == 1) {\\n                    count++;\\n                }\\n                carry = (count > 1 ? 1 : 0);\\n                str.insert(0, ((count == 0 || count == 2)? '0' : '1'));\\n                count = 0;\\n                aPtr--;\\n                bPtr--;\\n            }\\n            if(carry == 1) {\\n                str.insert(0, '1');\\n            }\\n            return str.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            StringBuilder str = new StringBuilder();\\n            int aPtr = a.length() - 1;\\n            int bPtr = b.length() - 1;\\n            int carry = 0;\\n            int count = 0;\\n            while(aPtr >= 0 || bPtr >= 0) {\\n                if(aPtr >= 0) {\\n                    if(a.charAt(aPtr) == '1') {\\n                        count ++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3967679,
                "title": "two-simple-java-solutions-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n   public static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length());\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n        output.append(sum % 2); // Append the remainder of the sum\\n        carry = sum / 2; // Update the carry\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n\\n\\n}\\n```\\n\\n# code 2 \\n\\n```\\nclass Solution {\\npublic static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length()); // Use Math.max to get the maximum length\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n\\n        if (sum > 1) {\\n            carry = 1;\\n            output.append(sum % 2); // Append the remainder of the sum\\n        } else {\\n            carry = 0;\\n            output.append(sum);\\n        }\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n}\\n```\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/50f0b47b-f4a3-435a-a546-d93f75633914_1693145096.446008.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length());\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n        output.append(sum % 2); // Append the remainder of the sum\\n        carry = sum / 2; // Update the carry\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n\\n\\n}\\n```\n```\\nclass Solution {\\npublic static String addBinary(String a, String b) {\\n    int carry = 0;\\n    StringBuilder output = new StringBuilder();\\n    int length = Math.max(a.length(), b.length()); // Use Math.max to get the maximum length\\n\\n    for (int i = a.length() - 1, z = b.length() - 1; length > 0; i--, z--, length--) {\\n        int x = (i >= 0) ? Character.getNumericValue(a.charAt(i)) : 0;\\n        int y = (z >= 0) ? Character.getNumericValue(b.charAt(z)) : 0;\\n\\n        int sum = x + y + carry;\\n\\n        if (sum > 1) {\\n            carry = 1;\\n            output.append(sum % 2); // Append the remainder of the sum\\n        } else {\\n            carry = 0;\\n            output.append(sum);\\n        }\\n    }\\n\\n    if (carry > 0) {\\n        output.append(carry); // If there\\'s a final carry, append it\\n    }\\n\\n    return output.reverse().toString();\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183184,
                "title": "clean-and-easy-c-code",
                "content": "\\n# Code \\uD83D\\uDE80\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n\\n        string ans;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n\\n            if(i>=0) sum += a[i--]-\\'0\\';\\n            if(j>=0) sum += b[j--]-\\'0\\';\\n            \\n            //update carry for next round\\n            carry = sum>1 ? 1 : 0;\\n            ans += to_string(sum%2);\\n        }\\n\\n        if(carry) ans += to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n# Please, Do Upvote if you find the solution helpful!\\nHappy coding :)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n\\n        string ans;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n\\n            if(i>=0) sum += a[i--]-\\'0\\';\\n            if(j>=0) sum += b[j--]-\\'0\\';\\n            \\n            //update carry for next round\\n            carry = sum>1 ? 1 : 0;\\n            ans += to_string(sum%2);\\n        }\\n\\n        if(carry) ans += to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945235,
                "title": "java-oneline-solutioin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger m=new BigInteger(a,2);\\n        BigInteger n=m.add(new BigInteger(b,2));\\n        \\n        \\n        return n.toString(2);\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger m=new BigInteger(a,2);\\n        BigInteger n=m.add(new BigInteger(b,2));\\n        \\n        \\n        return n.toString(2);\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765135,
                "title": "it-s-one-liner-baby",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104551,
                "title": "c-simple-solution-0ms-96-beat-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry=0;\\n        \\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string ans;\\n        while(i>=0 && j>=0){\\n            \\n            if(carry==0){\\n                if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                        carry=1;\\n                    }\\n                }\\n            }\\n            else{\\n                 if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                        carry=0;\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n            }\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i>=0){\\n            if(carry==0){\\n                ans+=a[i];\\n            }\\n            else{\\n                if(a[i]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            i--;\\n        }\\n        while(j>=0){\\n            if(carry==0){\\n                ans+=b[j];\\n            }\\n            else{\\n                if(b[j]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            j--;\\n        }\\n        if(carry==1)\\n            ans+=\\'1\\';\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry=0;\\n        \\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string ans;\\n        while(i>=0 && j>=0){\\n            \\n            if(carry==0){\\n                if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                        carry=1;\\n                    }\\n                }\\n            }\\n            else{\\n                 if(a[i]==\\'0\\'){\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'1\\';\\n                        carry=0;\\n                    }\\n                    else{\\n                        ans+=\\'0\\';\\n                    }\\n                }\\n                else{\\n                    if(b[j]==\\'0\\'){\\n                        ans+=\\'0\\';\\n                    }\\n                    else{\\n                        ans+=\\'1\\';\\n                    }\\n                }\\n            }\\n            i--;\\n            j--;\\n        }\\n        \\n        while(i>=0){\\n            if(carry==0){\\n                ans+=a[i];\\n            }\\n            else{\\n                if(a[i]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            i--;\\n        }\\n        while(j>=0){\\n            if(carry==0){\\n                ans+=b[j];\\n            }\\n            else{\\n                if(b[j]==\\'0\\'){\\n                    ans+=\\'1\\';\\n                    carry=0;\\n                }\\n                else{\\n                    ans+=\\'0\\';\\n                }\\n            }\\n            j--;\\n        }\\n        if(carry==1)\\n            ans+=\\'1\\';\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794830,
                "title": "python3-using-bin-and-int-simple",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        summ = bin(int(a, 2) + int(b, 2))\\n        return summ[2:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        summ = bin(int(a, 2) + int(b, 2))\\n        return summ[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845910,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string str=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            str=to_string(sum%2)+str;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               str=to_string(1)+str;\\n        return str;\\n        \\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string str=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            str=to_string(sum%2)+str;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               str=to_string(1)+str;\\n        return str;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441283,
                "title": "simple-and-elegant-golang-solution-0-ms-faster-than-100-00",
                "content": "```go\\nfunc addBinary(a string, b string) string {\\n    if len(a) < len(b) {\\n        a, b = b, a\\n    }\\n    ans := make([]byte, len(a) + 1)\\n\\tvar carry byte\\n\\tfor i, j := len(a), len(b); i >= 1 || j >= 1; {\\n\\t\\ti, j = i - 1, j - 1\\n\\t\\tvar a2Digit, b2Digit byte\\n\\t\\tif (i >= 0) {\\n\\t\\t\\ta2Digit = a[i] - \\'0\\'\\n\\t\\t}\\n\\t\\tif (j >= 0) {\\n\\t\\t\\tb2Digit = b[j] - \\'0\\'\\n\\t\\t}\\n        // sum and carry of full adder\\n\\t\\tsum := a2Digit ^ b2Digit ^ carry\\n\\t\\tcarry = a2Digit & b2Digit | carry & (a2Digit ^ b2Digit)\\n        ans[i+1] = sum + \\'0\\'\\n\\t}\\n\\tif carry == 1 {\\n\\t\\tans[0] = \\'1\\'\\n        return string(ans)\\n\\t}\\n    return string(ans[1:])\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc addBinary(a string, b string) string {\\n    if len(a) < len(b) {\\n        a, b = b, a\\n    }\\n    ans := make([]byte, len(a) + 1)\\n\\tvar carry byte\\n\\tfor i, j := len(a), len(b); i >= 1 || j >= 1; {\\n\\t\\ti, j = i - 1, j - 1\\n\\t\\tvar a2Digit, b2Digit byte\\n\\t\\tif (i >= 0) {\\n\\t\\t\\ta2Digit = a[i] - \\'0\\'\\n\\t\\t}\\n\\t\\tif (j >= 0) {\\n\\t\\t\\tb2Digit = b[j] - \\'0\\'\\n\\t\\t}\\n        // sum and carry of full adder\\n\\t\\tsum := a2Digit ^ b2Digit ^ carry\\n\\t\\tcarry = a2Digit & b2Digit | carry & (a2Digit ^ b2Digit)\\n        ans[i+1] = sum + \\'0\\'\\n\\t}\\n\\tif carry == 1 {\\n\\t\\tans[0] = \\'1\\'\\n        return string(ans)\\n\\t}\\n    return string(ans[1:])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24593,
                "title": "javascript-solution-beats-96",
                "content": "```\\nvar addBinary = function(a, b) {\\n    var result = \"\";\\n    var i = a.length - 1;\\n    var j = b.length - 1;\\n    var carry = 0;\\n    while (i >= 0 || j >= 0 || carry > 0) {\\n        carry += i >= 0 ? parseInt(a[i--]) : 0;\\n        carry += j >= 0 ? parseInt(b[j--]) : 0;\\n        result = carry % 2 + result;\\n        carry = parseInt(carry / 2);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar addBinary = function(a, b) {\\n    var result = \"\";\\n    var i = a.length - 1;\\n    var j = b.length - 1;\\n    var carry = 0;\\n    while (i >= 0 || j >= 0 || carry > 0) {\\n        carry += i >= 0 ? parseInt(a[i--]) : 0;\\n        carry += j >= 0 ? parseInt(b[j--]) : 0;\\n        result = carry % 2 + result;\\n        carry = parseInt(carry / 2);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24776,
                "title": "a-8-line-c-solution-to-have-all-languages-here",
                "content": "    public string AddBinary(string a, string b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0; i--, j--){\\n            int total= ((i >= 0 ? a[i] - '0' : 0) + (j >= 0 ? b[j] - '0' : 0)) + carry;\\n            sb.Insert(0, total == 2 || total == 0 ? '0' : '1');\\n            carry = total > 1 ? 1 : 0;\\n        }\\n        return carry == 1 ? sb.Insert(0, 1).ToString() : sb.ToString();\\n    }",
                "solutionTags": [],
                "code": "    public string AddBinary(string a, string b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for (int i = a.Length - 1, j = b.Length - 1; i >= 0 || j >= 0; i--, j--){\\n            int total= ((i >= 0 ? a[i] - '0' : 0) + (j >= 0 ? b[j] - '0' : 0)) + carry;\\n            sb.Insert(0, total == 2 || total == 0 ? '0' : '1');\\n            carry = total > 1 ? 1 : 0;\\n        }\\n        return carry == 1 ? sb.Insert(0, 1).ToString() : sb.ToString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3129097,
                "title": "js-fully-loop-through-strings-perform-binary-addition",
                "content": "# Intuition\\nUse `parseInt(x,2)` to get the values of the strings as integers, add them, then convert back to a bianry string. This doesn\\'t work due to a binary number with length 10^4 not fitting into an integer. Second approach was to loop through the strings and impelment binary addition.\\n\\n# Approach\\nLoop through both strings, continuing through the longest. We could trim off the front of the longest to save a few loops, but we\\'d need to account for any carry over from the last addition. To keep it simple, we\\'ll just loop through and let the addition do its job.\\n\\nWhile our loop index will increase, we\\'ll add from the end of the strings. Indexing from 0 for the loop allows us to keep processing the strings consistently, even if they are different lengths.\\n\\nSince we are processing through the longest string, we need to check that the other string still has values with a length check. If not, we treat that as a 0.\\n\\nFor the actual addition, we\\'ll parse a single character into an integer. An improvement here could be to take multiple characters, but we\\'d still have to deal with the complexity putting the slices back together without hitting out integer limits.\\n\\nSince we are performing one character at a time, we simply add the two values, plus any carryover from previous calcualtions. If the result is 0 or 1, that\\'s our result. Greater that 1 we\\'ll need to remove our carryover and our result is the remained. In this case,carry over is always 1, and out result in sum mod 2, since binary representations of 2 and 3 are 10 and 11 respectively. We can never have a value higher than 3. Once we have our result we add it to the front of our string. \\n\\nWhen we complete the loop, we may still have a carryover. This problem does not allow for a leading zero. We can\\'t just loop an extra iteration. If carry is zero, that would add a leading zero to our string. After the loop, we add a 1 if we have a carryover.\\n\\n# Test Cases\\n - Either or both numbers are 0\\n - Cases to verify all our possible outcomes of addition (0,1,2,3)\\n   - 0 + 1\\n   - 1 + 1\\n   - 1 + 11\\n   - 10 + 11\\n   - 11 + 11\\n - Leading 0 vs Leading 1\\n   - 1 + 1000\\n   - 1000 + 1000\\n- Numbers greater than or whos sum is greater than Number.MAX_SAFE_INTEGER\\n\\n# Code\\n```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n\\n    let result = \"\";\\n    let carry = 0;\\n    let index = 0;\\n\\n    while (index < Math.max(a.length,b.length)) {\\n        let x = 0;\\n        let y = 0;\\n\\n        if(a.length-1-index >= 0) {\\n            x = parseInt(a[a.length-1-index],2);\\n        }\\n\\n        if(b.length-1-index >= 0) {\\n            y = parseInt(b[b.length-1-index],2);\\n        }\\n        \\n        let sum = carry + x + y;\\n\\n        if(sum <= 1) {\\n            result = `${sum}${result}`;\\n            carry = 0;\\n        } else {\\n            result = `${sum%2}${result}`;\\n            carry = 1;\\n        }\\n\\n        index++;\\n    }\\n\\n    if (carry === 1) {\\n        result = `${carry}${result}`;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n\\n    let result = \"\";\\n    let carry = 0;\\n    let index = 0;\\n\\n    while (index < Math.max(a.length,b.length)) {\\n        let x = 0;\\n        let y = 0;\\n\\n        if(a.length-1-index >= 0) {\\n            x = parseInt(a[a.length-1-index],2);\\n        }\\n\\n        if(b.length-1-index >= 0) {\\n            y = parseInt(b[b.length-1-index],2);\\n        }\\n        \\n        let sum = carry + x + y;\\n\\n        if(sum <= 1) {\\n            result = `${sum}${result}`;\\n            carry = 0;\\n        } else {\\n            result = `${sum%2}${result}`;\\n            carry = 1;\\n        }\\n\\n        index++;\\n    }\\n\\n    if (carry === 1) {\\n        result = `${carry}${result}`;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3086336,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //110101001\\n    //1101\\n    string addBinary(string a, string b) { \\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int i=0,j=0;\\n        string c=\"0\";\\n        string ans=\"\";\\n        while(i<a.length() && j<b.length())\\n        {\\n            if(a[i]==\\'0\\' && b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else if(a[i]==\\'1\\' && b[j]==\\'1\\')\\n            {\\n                ans+=c;\\n                c=\"1\";\\n            }\\n            else\\n            {\\n                if(c==\"1\")\\n                {\\n                    ans+=\"0\";\\n                    c=\"1\";\\n                }\\n                else\\n                {\\n                    ans+=\"1\";\\n                    c=\"0\";\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        while(i<a.length())\\n        {\\n            if(a[i]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=a[i];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            i++;\\n        }\\n        while(j<b.length())\\n        {\\n            if(b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=b[j];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            j++;\\n        }\\n        if(c==\"1\")\\n        ans+=c;\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //110101001\\n    //1101\\n    string addBinary(string a, string b) { \\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        int i=0,j=0;\\n        string c=\"0\";\\n        string ans=\"\";\\n        while(i<a.length() && j<b.length())\\n        {\\n            if(a[i]==\\'0\\' && b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else if(a[i]==\\'1\\' && b[j]==\\'1\\')\\n            {\\n                ans+=c;\\n                c=\"1\";\\n            }\\n            else\\n            {\\n                if(c==\"1\")\\n                {\\n                    ans+=\"0\";\\n                    c=\"1\";\\n                }\\n                else\\n                {\\n                    ans+=\"1\";\\n                    c=\"0\";\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        while(i<a.length())\\n        {\\n            if(a[i]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=a[i];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            i++;\\n        }\\n        while(j<b.length())\\n        {\\n            if(b[j]==\\'0\\')\\n            {\\n                ans+=c;\\n                c=\"0\";\\n            }\\n            else\\n            {\\n                if(c==\"0\")\\n                {\\n                    ans+=b[j];\\n                }\\n                else\\n                {\\n                    ans+=\\'0\\';\\n                    c=\"1\";\\n                }\\n                \\n            }\\n            j++;\\n        }\\n        if(c==\"1\")\\n        ans+=c;\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121434,
                "title": "python-concise-solution-with-divmod",
                "content": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        \\n        la, lb = len(a), len(b)\\n        \\n        if la < lb:\\n            a = \\'0\\' * (lb - la) + a\\n        else:\\n            b = \\'0\\' * (la - lb) + b\\n        \\n        a = [int(c) for c in a]\\n        b = [int(c) for c in b]\\n        \\n        carry = 0\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            \\n            carry, a[i] = divmod(a[i]+b[i]+carry,2)\\n        \\n        if carry:\\n             a = [carry] + a\\n        \\n        return \\'\\'.join([str(d) for d in a])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        \\n        la, lb = len(a), len(b)\\n        \\n        if la < lb:\\n            a = \\'0\\' * (lb - la) + a\\n        else:\\n            b = \\'0\\' * (la - lb) + b\\n        \\n        a = [int(c) for c in a]\\n        b = [int(c) for c in b]\\n        \\n        carry = 0\\n        \\n        for i in range(len(a)-1,-1,-1):\\n            \\n            carry, a[i] = divmod(a[i]+b[i]+carry,2)\\n        \\n        if carry:\\n             a = [carry] + a\\n        \\n        return \\'\\'.join([str(d) for d in a])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1174486,
                "title": "python-single-line-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2) + int(b,2))[2:]\\n```\\n\\nHere, first we convert the given strings(a and b) into their binary equivalents.\\nThis is done by ```int(a,2)``` and ```int(b,2)```. If we simply give ```int(a)```, the string will be converted to its decimal equivalent. So we need to specify to which base we need to convert the string into, which is 2 in our case.\\n\\nNow we need to carry out binary addition. To tell the system that we intend to carry out a binary operation and require the result in binary format, we enclose ```int(a,2) + int(b,2)``` with the ```bin()``` function. If we simply write ```int(a,2) + int(b,2)```, we will get the answer in decimal form.\\n\\nNow we will get the binary result with ```bin(int(a,2) + int(b,2))```. But by convention, the value of ```bin()``` is stored as a string starting with \\'0b\\', and then the result. For example if the actual answer for the binary addition is \\'100\\', the string returned by ```bin()``` will be \\'0b100\\'. This is to denote that the string represents a binary number.\\n\\nBut we do not need the extra \\'0b\\' in front of our answer. So we slice the string to ignore the first two characters, i.e. by [2:]. So the final answer is reached.\\n\\n```bin(int(a,2) + int(b,2))[2:]```\\n\\nNow just return it.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2) + int(b,2))[2:]\\n```\n```int(a,2)```\n```int(b,2)```\n```int(a)```\n```int(a,2) + int(b,2)```\n```bin()```\n```int(a,2) + int(b,2)```\n```bin(int(a,2) + int(b,2))```\n```bin()```\n```bin()```\n```bin(int(a,2) + int(b,2))[2:]```",
                "codeTag": "Java"
            },
            {
                "id": 1012869,
                "title": "0ms-golang-solution-use-math-big-package-very-simple",
                "content": "```\\nfunc addBinary(a string, b string) string {\\n\\taInt,bInt,sum:=new(big.Int),new(big.Int),new(big.Int)\\n\\taInt.SetString(a,2)\\n\\tbInt.SetString(b,2)\\n\\tsum.Add(aInt,bInt)\\n\\treturn sum.Text(2)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc addBinary(a string, b string) string {\\n\\taInt,bInt,sum:=new(big.Int),new(big.Int),new(big.Int)\\n\\taInt.SetString(a,2)\\n\\tbInt.SetString(b,2)\\n\\tsum.Add(aInt,bInt)\\n\\treturn sum.Text(2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865910,
                "title": "javascript-bit-manipulation",
                "content": "```\\nvar addBinary = function(a, b) {\\n  let binaryA = BigInt(\"0b\" + a);\\n  let binaryB = BigInt(\"0b\" + b);\\n  let sum;\\n  let carry;\\n  while (binaryB || carry === undefined) {\\n    sum = binaryA ^ binaryB;\\n    carry = (binaryA & binaryB) << BigInt(\"0b1\");\\n    binaryA = sum\\n    binaryB = carry\\n  }\\n  return sum.toString(2);\\n};\\n```\\nDoes it make sense ?",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n  let binaryA = BigInt(\"0b\" + a);\\n  let binaryB = BigInt(\"0b\" + b);\\n  let sum;\\n  let carry;\\n  while (binaryB || carry === undefined) {\\n    sum = binaryA ^ binaryB;\\n    carry = (binaryA & binaryB) << BigInt(\"0b1\");\\n    binaryA = sum\\n    binaryB = carry\\n  }\\n  return sum.toString(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 847720,
                "title": "super-simple-python-solution-1-line",
                "content": "The idea behind the code is pretty simple.\\n\\nFirst, convert the given binary strings into base 10 integers. Then add them.\\nFinally, return the binary value of the answer.\\n\\n```\\ndef addBinary(self, a: str, b: str) -> str:\\n# Convert the given strings to int and add them. Then return bin value of result.\\n        return bin(int(a,2)+int(b,2))[2:]\\n\\t\\t\\n\\t\\t\\n\\t\\t# [2:] is taken because python returns the bin value starting with \"0b\" which we do not need.\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n# Convert the given strings to int and add them. Then return bin value of result.\\n        return bin(int(a,2)+int(b,2))[2:]\\n\\t\\t\\n\\t\\t\\n\\t\\t# [2:] is taken because python returns the bin value starting with \"0b\" which we do not need.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 613270,
                "title": "javascript",
                "content": "```\\nvar addBinary = function(a, b) {\\n    let index1 = a.length;\\n    let index2 = b.length;\\n    let result = \\'\\';\\n    let carry = 0;\\n    while (index1 || index2) {\\n        let sum = (index1 > 0 ? +a[--index1] : 0) + (index2 > 0 ? +b[--index2] : 0) + carry;\\n        result = (sum % 2) + result;\\n        carry = sum > 1 ? 1 : 0;\\n    };\\n    return carry ? carry + result : result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar addBinary = function(a, b) {\\n    let index1 = a.length;\\n    let index2 = b.length;\\n    let result = \\'\\';\\n    let carry = 0;\\n    while (index1 || index2) {\\n        let sum = (index1 > 0 ? +a[--index1] : 0) + (index2 > 0 ? +b[--index2] : 0) + carry;\\n        result = (sum % 2) + result;\\n        carry = sum > 1 ? 1 : 0;\\n    };\\n    return carry ? carry + result : result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24699,
                "title": "3ms-java-simple-solution-using-stringbuilder",
                "content": "    class Solution {\\n        public String addBinary(String a, String b) {\\n            int c = 0;\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0;){\\n                if(i >= 0) c += a.charAt(i--) - '0';\\n                if(j >= 0) c += b.charAt(j--) - '0';\\n                sb.insert(0, (char)((c % 2) + '0'));\\n                c /= 2;\\n            }\\n            if(c == 1) sb.insert(0, \"1\");\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n        public String addBinary(String a, String b) {\\n            int c = 0;\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = a.length() - 1, j = b.length() - 1; i >= 0 || j >= 0;){\\n                if(i >= 0) c += a.charAt(i--) - '0';\\n                if(j >= 0) c += b.charAt(j--) - '0';\\n                sb.insert(0, (char)((c % 2) + '0'));\\n                c /= 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24748,
                "title": "short-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            bool carry = false;\\n            int i = a.length() - 1, j = b.length()-1;\\n            string res(max(i,j)+1, '0');\\n            while(i >= 0 || j >= 0) {\\n                int cur = (i >= 0? a[i--]-'0' : 0) + (j >= 0 ? b[j--]-'0' : 0 ) + carry;\\n                res[max(i,j)+1] = (cur % 2) + '0';\\n                carry = (cur > 1);\\n            }\\n            if (carry) \\n                res = \"1\" + res;\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            bool carry = false;\\n            int i = a.length() - 1, j = b.length()-1;\\n            string res(max(i,j)+1, '0');\\n            while(i >= 0 || j >= 0) {\\n                int cur = (i >= 0? a[i--]-'0' : 0) + (j >= 0 ? b[j--]-'0' : 0 ) + carry;\\n                res[max(i,j)+1] = (cur % 2) + '0';\\n                carry = (cur > 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24768,
                "title": "ac-clean-java-solution",
                "content": "    public String addBinary(String s1, String s2) {\\n        int i = s1.length() - 1, j = s2.length() - 1, c = 0;\\n        String s = \"\";\\n        \\n        while (i >= 0 || j >= 0 || c == 1) {\\n            int a = (i < 0) ? 0 : s1.charAt(i--) - '0';\\n            int b = (j < 0) ? 0 : s2.charAt(j--) - '0';\\n            \\n            s = (char)('0' + a ^ b ^ c) + s;\\n            c = (a + b + c) >> 1;\\n        }\\n        \\n        return s;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public String addBinary(String s1, String s2) {\\n        int i = s1.length() - 1, j = s2.length() - 1, c = 0;\\n        String s = \"\";\\n        \\n        while (i >= 0 || j >= 0 || c == 1) {\\n            int a = (i < 0) ? 0 : s1.charAt(i--) - '0';\\n            int b = (j < 0) ? 0 : s2.charAt(j--) - '0';\\n            \\n            s = (char)('0' + a ^ b ^ c) + s;\\n            c = (a + b + c) >> 1;\\n        }\\n        \\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24773,
                "title": "c-vanilla",
                "content": "The idea is to use two pointers initialied at the end of the two binary numbers and add from back to forth.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int m = a.size(), n = b.size(), carry = 0;\\n        for (int i = m - 1, j = n - 1; i >= 0 || j >= 0 || carry; i--, j--) {\\n            int x = i >= 0 ? a[i] - \\'0\\' : 0;\\n            int y = j >= 0 ? b[j] - \\'0\\' : 0;\\n            int sum = x ^ y ^ carry;\\n            carry = (x & y) | (x & carry) | (y & carry);\\n            ans = to_string(sum) + ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int m = a.size(), n = b.size(), carry = 0;\\n        for (int i = m - 1, j = n - 1; i >= 0 || j >= 0 || carry; i--, j--) {\\n            int x = i >= 0 ? a[i] - \\'0\\' : 0;\\n            int y = j >= 0 ? b[j] - \\'0\\' : 0;\\n            int sum = x ^ y ^ carry;\\n            carry = (x & y) | (x & carry) | (y & carry);\\n            ans = to_string(sum) + ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859464,
                "title": "simple-and-clean-code-c-optimized",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n\\n//facebook\\'s top 4 question:::\\n\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            //changing again to string for storing\\n            res += to_string(sum % 2);\\n        }\\n        //bilkull end me agar still koi carry aata hai to\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\n   \\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n\\n//facebook\\'s top 4 question:::\\n\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0) sum += a[i--] - \\'0\\';\\n            if(j >= 0) sum += b[j--] - \\'0\\';\\n            carry = sum > 1 ? 1 : 0;\\n            //changing again to string for storing\\n            res += to_string(sum % 2);\\n        }\\n        //bilkull end me agar still koi carry aata hai to\\n        if(carry) res += to_string(carry);\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073488,
                "title": "python-one-liner-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just convert a binary number into a decimal and do a summation and return it as a binary number using \"bin\" and \"int\" functions of python. Here, by default we got 0b in answer as a prifix because of the \"bin\" function. That\\'s why we slice that final answer by doing [2:]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2)+int(b,2))[2:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a,2)+int(b,2))[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571449,
                "title": "javascript-solution-in-one-line",
                "content": "```\\nvar addBinary = function (a, b) {\\n  return (BigInt(\\'0b\\' + a) + BigInt(\\'0b\\' + b)).toString(2);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function (a, b) {\\n  return (BigInt(\\'0b\\' + a) + BigInt(\\'0b\\' + b)).toString(2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355068,
                "title": "c-solution-faster-than-100-easy-to-understand",
                "content": "Be clear with concepts of string and integer and their conversion.\\n\\nHere\\'s the code:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string result;\\n        int carry=0;\\n        while(i>=0||j>=0)\\n        {    \\n            int sum = carry;\\n            if(i>=0)\\n            sum+=a[i--] - \\'0\\';\\n            if(j>=0)\\n            sum+=b[j--] - \\'0\\';\\n            carry=sum > 1 ? 1:0;\\n            result+=to_string(sum%2);\\n        }\\n        if(carry)\\n            result+=to_string(carry);\\n            reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```\\n\\nFor eg:\\nAdd 101 and 11\\nfrom last adding 1 and 1 ,initial carry is 0 , adding all we get 2\\n2>1 , so carry is 1 for next string.\\nresult is\\' 0\\'+\\'(2%2)\\'=\\'0\\';\\nnow add 0+1+1(carry)=2;\\nsum>1 =>carry =1 for next;\\nresult=\\'0\\'+\\'(2%2)\\'=\\'00\\'\\nnow add 1+1(carry)\\nsum>1 =carry =1;\\nresult=\\'00\\'+\\'(2%2)=\\'000\\'\\nboth strings end, append leftover carry by converting to string \\nresult = \\'000\\'+\\'1\\'=\\'0001\\';\\nreverse for final result=\\'1000\\'\\n101 (5) + 11 (3) = 1000  (8).\\n\\nHope you understood.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        string result;\\n        int carry=0;\\n        while(i>=0||j>=0)\\n        {    \\n            int sum = carry;\\n            if(i>=0)\\n            sum+=a[i--] - \\'0\\';\\n            if(j>=0)\\n            sum+=b[j--] - \\'0\\';\\n            carry=sum > 1 ? 1:0;\\n            result+=to_string(sum%2);\\n        }\\n        if(carry)\\n            result+=to_string(carry);\\n            reverse(result.begin(),result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324370,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        use std::iter;\\n        let mut carry = 0;\\n        let mut cur_sum = 0;\\n        let mut char_vec = a\\n            .as_bytes()\\n            .iter()\\n            .rev()\\n            .chain(iter::repeat(&b\\'0\\'))\\n            .zip(b.as_bytes().iter().rev().chain(iter::repeat(&b\\'0\\')))\\n            .take(a.len().max(b.len()))\\n            .map(|(ac, bc)| {\\n                cur_sum = (*ac - b\\'0\\') + (*bc - b\\'0\\') + carry;\\n                carry = cur_sum / 2;\\n                match cur_sum % 2 {\\n                    1 => \\'1\\',\\n                    _ => \\'0\\',\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n\\n        if carry == 1 {\\n            char_vec.push(\\'1\\');\\n        }\\n\\n        char_vec.iter().rev().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn add_binary(a: String, b: String) -> String {\\n        use std::iter;\\n        let mut carry = 0;\\n        let mut cur_sum = 0;\\n        let mut char_vec = a\\n            .as_bytes()\\n            .iter()\\n            .rev()\\n            .chain(iter::repeat(&b\\'0\\'))\\n            .zip(b.as_bytes().iter().rev().chain(iter::repeat(&b\\'0\\')))\\n            .take(a.len().max(b.len()))\\n            .map(|(ac, bc)| {\\n                cur_sum = (*ac - b\\'0\\') + (*bc - b\\'0\\') + carry;\\n                carry = cur_sum / 2;\\n                match cur_sum % 2 {\\n                    1 => \\'1\\',\\n                    _ => \\'0\\',\\n                }\\n            })\\n            .collect::<Vec<_>>();\\n\\n        if carry == 1 {\\n            char_vec.push(\\'1\\');\\n        }\\n\\n        char_vec.iter().rev().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840448,
                "title": "js-98",
                "content": "```js\\nvar addBinary = function(a, b) {\\n  let i = a.length - 1, \\n      j = b.length - 1,\\n      carry = 0, \\n      result = [];\\n  while(i >= 0 || j >= 0) {\\n    let n1 = +a[i] || 0;\\n    let n2 = +b[j] || 0;\\n    let sum = n1 + n2 + carry;\\n    if(sum === 0) {\\n      result.unshift(0);\\n      carry = 0;\\n    } else if(sum === 1) {\\n      result.unshift(1);\\n       carry = 0;\\n    } else if(sum === 2) {\\n      result.unshift(0);\\n      carry = 1;\\n    } else if(sum === 3) {\\n      result.unshift(1);\\n      carry = 1;\\n    }\\n    i--;\\n    j--; \\n  }\\n  if(carry) {\\n    result.unshift(1);\\n  }\\n  return result.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar addBinary = function(a, b) {\\n  let i = a.length - 1, \\n      j = b.length - 1,\\n      carry = 0, \\n      result = [];\\n  while(i >= 0 || j >= 0) {\\n    let n1 = +a[i] || 0;\\n    let n2 = +b[j] || 0;\\n    let sum = n1 + n2 + carry;\\n    if(sum === 0) {\\n      result.unshift(0);\\n      carry = 0;\\n    } else if(sum === 1) {\\n      result.unshift(1);\\n       carry = 0;\\n    } else if(sum === 2) {\\n      result.unshift(0);\\n      carry = 1;\\n    } else if(sum === 3) {\\n      result.unshift(1);\\n      carry = 1;\\n    }\\n    i--;\\n    j--; \\n  }\\n  if(carry) {\\n    result.unshift(1);\\n  }\\n  return result.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726796,
                "title": "python-one-liner",
                "content": "Approach:\\n1. The problem can be solved by first **converting both binary values to decimals.** \\n2. **Compute sum** by adding the two decimal values.\\n3. Return the **binary value of the sum** in string format. \\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a, 2) + int (b, 2)))[2:]\\n```\\nIn python, a binary number ```n``` can be converted to its decimal form by using the ```int(n,2)```.\\nThus the operation ``` int(a, 2) + int(b, 2) ```will add the decimals after conversion. This sum is then converted back to binary using ```bin()```. The binary is converted to type string and returned.\\n\\n**NOTE:** The string is returned from [2:] because, in python, the first two characters in the binary form are \"0b\" followed by the actual binary value. \\n\\nFor example,\\nLet ```a = \"11\", b = \"1\"```\\nAfter running ```str(bin(int(a,2) + int(b,2)))``` the result would be ```\"0b100\"```. Thus when returning the string, the first two characters are omitted and hence the term **[2:]**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return str(bin(int(a, 2) + int (b, 2)))[2:]\\n```\n```n```\n```int(n,2)```\n``` int(a, 2) + int(b, 2) ```\n```bin()```\n```a = \"11\", b = \"1\"```\n```str(bin(int(a,2) + int(b,2)))```\n```\"0b100\"```",
                "codeTag": "Java"
            },
            {
                "id": 167114,
                "title": "javascript-solution-with-2-pointers",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  let i = a.length-1;\\n  let j = b.length-1;\\n  let carry = 0;\\n  let result = \\'\\';\\n  while (i >= 0 || j >= 0) {\\n      let aDigit = a[i] || \\'0\\';\\n      let bDigit = b[j] || \\'0\\';\\n      let temp = parseInt(aDigit) + parseInt(bDigit) + carry;\\n      let digit = temp % 2;\\n      carry = Math.floor(temp / 2);\\n      result = digit + result;\\n      i--;\\n      j--;\\n   }\\n  if (carry !== 0) result = carry + result;\\n  return result;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n  let i = a.length-1;\\n  let j = b.length-1;\\n  let carry = 0;\\n  let result = \\'\\';\\n  while (i >= 0 || j >= 0) {\\n      let aDigit = a[i] || \\'0\\';\\n      let bDigit = b[j] || \\'0\\';\\n      let temp = parseInt(aDigit) + parseInt(bDigit) + carry;\\n      let digit = temp % 2;\\n      carry = Math.floor(temp / 2);\\n      result = digit + result;\\n      i--;\\n      j--;\\n   }\\n  if (carry !== 0) result = carry + result;\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24684,
                "title": "java-simple-solution",
                "content": "        \\n    public String addBinary(String a, String b) {\\n        if (a == null || a == \"\")\\n            return b;\\n        if (b == null || b == \"\")\\n            return a;\\n        int carry = 0;\\n        String ret = \"\";\\n        int l1 = a.length()-1;\\n        int l2 = b.length()-1;\\n        while (l1 >= 0 || l2 >= 0 || carry == 1) {\\n            if (l1 >= 0) {\\n                carry += Integer.parseInt(a.charAt(l1)+\"\");\\n                l1--;\\n            }\\n            if (l2 >= 0) {\\n                carry += Integer.parseInt(b.charAt(l2)+\"\");\\n                l2--;\\n            }\\n            ret = String.valueOf(carry%2) + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        \\n    public String addBinary(String a, String b) {\\n        if (a == null || a == \"\")\\n            return b;\\n        if (b == null || b == \"\")\\n            return a;\\n        int carry = 0;\\n        String ret = \"\";\\n        int l1 = a.length()-1;\\n        int l2 = b.length()-1;\\n        while (l1 >= 0 || l2 >= 0 || carry == 1) {\\n            if (l1 >= 0) {\\n                carry += Integer.parseInt(a.charAt(l1)+\"\");\\n                l1--;\\n            }\\n            if (l2 >= 0) {\\n                carry += Integer.parseInt(b.charAt(l2)+\"\");\\n                l2--;\\n            }\\n            ret = String.valueOf(carry%2) + ret;\\n            carry /= 2;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3738124,
                "title": "sol-using-python-just-2-line",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = str(bin(int(a, 2) + int(b, 2)))\\n        return res[2:]\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        res = str(bin(int(a, 2) + int(b, 2)))\\n        return res[2:]\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415431,
                "title": "easy-c-solution-with-if-else-which-beats-60-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdding each bit of the string individually.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterating through both the string simultaneously and adding the result in the resultant string according to the iterators current values.\\n\\n# Complexity\\n- Time complexity: O(max(a,b))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(a,b))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string s;\\n        std::string::iterator itr1=a.end()-1,itr2=b.end()-1;\\n        bool carry=0;\\n        while(itr1>=a.begin()&&itr2>=b.begin())\\n        {\\n            if(*itr1==\\'1\\'&&*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                    carry=1;\\n                }\\n            }\\n            else if((*itr1==\\'1\\'&&*itr2==\\'0\\')||(*itr1==\\'0\\'&&*itr2==\\'1\\'))\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n            itr1--;itr2--;\\n        }\\n        for(;itr1>=a.begin();itr1--)\\n        {\\n            if(*itr1==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }}\\n            for(;itr2>=b.begin();itr2--)\\n        {\\n            if(*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n        }\\n        if(carry==1)\\n        {\\n            s=\\'1\\'+s;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string s;\\n        std::string::iterator itr1=a.end()-1,itr2=b.end()-1;\\n        bool carry=0;\\n        while(itr1>=a.begin()&&itr2>=b.begin())\\n        {\\n            if(*itr1==\\'1\\'&&*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                    carry=1;\\n                }\\n            }\\n            else if((*itr1==\\'1\\'&&*itr2==\\'0\\')||(*itr1==\\'0\\'&&*itr2==\\'1\\'))\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n            itr1--;itr2--;\\n        }\\n        for(;itr1>=a.begin();itr1--)\\n        {\\n            if(*itr1==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }}\\n            for(;itr2>=b.begin();itr2--)\\n        {\\n            if(*itr2==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n                else\\n                {\\n                    s=\\'1\\'+s;\\n                }\\n            }\\n            else\\n            {\\n                if(carry==1)\\n                {\\n                    s=\\'1\\'+s;\\n                    carry=0;\\n                }\\n                else\\n                {\\n                    s=\\'0\\'+s;\\n                }\\n            }\\n        }\\n        if(carry==1)\\n        {\\n            s=\\'1\\'+s;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184413,
                "title": "c-beginner-friendly-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA little bit lengthy but easy to understand. \\nWe just have to handle all the cases like for carry and sum of a[i] and b[i].  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) --> not considering ans string \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i=0;\\n        int carry=0;\\n        reverse(begin(a),end(a));\\n        reverse(begin(b),end(b));\\n        while(i<a.size() and i<b.size()){\\n            ans+=((a[i]!=b[i] and !carry) or (a[i]==b[i] and carry))?\\'1\\':\\'0\\';\\n            carry= ((a[i]==\\'1\\' and b[i]==\\'1\\') or (a[i]!=b[i] and carry));\\n            i++;\\n        }\\n        while(i<a.size()){\\n            ans+=((a[i]==\\'1\\' and carry) or (a[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(a[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n         while(i<b.size()){\\n            ans+=((b[i]==\\'1\\' and carry) or (b[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(b[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n        if(carry)ans+=\\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i=0;\\n        int carry=0;\\n        reverse(begin(a),end(a));\\n        reverse(begin(b),end(b));\\n        while(i<a.size() and i<b.size()){\\n            ans+=((a[i]!=b[i] and !carry) or (a[i]==b[i] and carry))?\\'1\\':\\'0\\';\\n            carry= ((a[i]==\\'1\\' and b[i]==\\'1\\') or (a[i]!=b[i] and carry));\\n            i++;\\n        }\\n        while(i<a.size()){\\n            ans+=((a[i]==\\'1\\' and carry) or (a[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(a[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n         while(i<b.size()){\\n            ans+=((b[i]==\\'1\\' and carry) or (b[i]==\\'0\\' and !carry))?\\'0\\':\\'1\\';\\n            carry=(b[i]==\\'1\\' and carry);\\n            i++;\\n        }\\n        if(carry)ans+=\\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183290,
                "title": "beginner-friendly-solution-easy-simple-iteration",
                "content": "# Intuition\\nSimplpy iterating strings\\n\\n# Approach\\n- take carry, value as 0 and an empty string\\n- take a while loop in which iterate both the string and a condition in which carry is not equal to zero\\n- take index A-i-1(A size of string a) of a and B-i-1(B size of string b) of b and add these values at these indexes with carry and mod the value\\n- convert the values to string and add to ans string\\n- increment i\\n- after the loop return string ans\\n\\n# Complexity\\n- Time complexity:\\nO(size  of string a) or O(size of string b)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code in C++\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n       int i=0,carry=0;\\n        string ans=\"\";\\n        int A=a.size();\\n        int B=b.size();\\n       while(i<A||i<B||carry!=0){\\n           int x=0;\\n           if(i<A &&a[A-i-1]==\\'1\\'){\\n               x=1;\\n           }\\n           int y=0;\\n           if(i<B &&b[B-i-1]==\\'1\\'){\\n               y=1;\\n           }\\n           ans=to_string((x+y+carry)%2)+ans;\\n           carry=(x+y+carry)/2;\\n           i+=1;\\n       }\\n        return ans;\\n    }\\n};\\n```\\n# Code in python\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        i=0\\n        ans=\"\"\\n        carry=0\\n        while(i<len(a) or i<len(b) or carry!=0):\\n            x=0\\n            if(i<len(a) and a[len(a)-i-1]==\\'1\\'):\\n                x=1\\n            y=0\\n            if(i<len(b) and b[len(b)-i-1]==\\'1\\'):\\n                y=1\\n            ans=str((x+y+carry)%2)+ans\\n            carry=(x+y+carry)//2\\n            i+=1\\n        return ans\\n        \\n    pyt\\n```\\n\\n# DON\\'T FORGET TO UPVOTE !",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n       int i=0,carry=0;\\n        string ans=\"\";\\n        int A=a.size();\\n        int B=b.size();\\n       while(i<A||i<B||carry!=0){\\n           int x=0;\\n           if(i<A &&a[A-i-1]==\\'1\\'){\\n               x=1;\\n           }\\n           int y=0;\\n           if(i<B &&b[B-i-1]==\\'1\\'){\\n               y=1;\\n           }\\n           ans=to_string((x+y+carry)%2)+ans;\\n           carry=(x+y+carry)/2;\\n           i+=1;\\n       }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        i=0\\n        ans=\"\"\\n        carry=0\\n        while(i<len(a) or i<len(b) or carry!=0):\\n            x=0\\n            if(i<len(a) and a[len(a)-i-1]==\\'1\\'):\\n                x=1\\n            y=0\\n            if(i<len(b) and b[len(b)-i-1]==\\'1\\'):\\n                y=1\\n            ans=str((x+y+carry)%2)+ans\\n            carry=(x+y+carry)//2\\n            i+=1\\n        return ans\\n        \\n    pyt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182731,
                "title": "daily-leetcoding-challenge-february-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3172276,
                "title": "easy-to-understand-python-o-n-tc-solution",
                "content": "# Intuition\\nUse basic rules of binary addition but remember to consider carry Rules could be mapped with this approach:\\n1. if we have 3 \\'1\\' w.r.t a[i] , b[j] and carry then \\ncarry = 1 and  ( addtion of a[i] , b[j] and carry = 1 )\\n\\n2. if we have 2 \\'1\\' w.r.t a[i], b[j] and carry then\\ncarry = 1 and ( addtion of a[i] , b[j] and carry = 0 )\\n\\n3. if we have 1 \\'1\\' w.r.t a[i] , b[j] and carry then \\ncarry = 0 and ( addtion of a[i] , b[j] and carry = 1 )\\n\\n4. if we have 0 \\'1\\' w.r.t a[i] , b[j] and carry then\\ncarry = 0 and ( addtion of a[i] , b[j] and carry = 0 )\\n\\n# Approach\\n\\nsimple iterate the string a and string b and carry is not empty\\nwith carry not empty I mean not zero\\n\\nIterate in reverse order for addition\\n\\nEvery time we initialize ones with 0 and if we see a \\'1\\' we increment the count of ones\\n\\nand rest is mapping based on the intuition \\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1) -- if we don\\'t consider ans string else O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        ans = \"\"\\n        i = len(a) - 1\\n        j = len(b) - 1\\n        carry = 0\\n\\n        while i >= 0 or j >= 0 or carry:\\n            ones = 0\\n            if i >= 0 and a[i] == \\'1\\':\\n                ones += 1 \\n            if j >= 0 and b[j] == \\'1\\':\\n                ones += 1 \\n            if carry == 1:\\n                ones += 1 \\n            \\n            if ones == 0:\\n                ans = ans + \"0\"\\n            elif ones == 1:\\n                ans = ans + \\'1\\'\\n                carry = 0\\n            elif ones == 2:\\n                ans = ans + \\'0\\'\\n                carry = 1\\n            else:\\n                ans = ans + \\'1\\'\\n                carry = 1\\n\\n            i -= 1 \\n            j -= 1 \\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        ans = \"\"\\n        i = len(a) - 1\\n        j = len(b) - 1\\n        carry = 0\\n\\n        while i >= 0 or j >= 0 or carry:\\n            ones = 0\\n            if i >= 0 and a[i] == \\'1\\':\\n                ones += 1 \\n            if j >= 0 and b[j] == \\'1\\':\\n                ones += 1 \\n            if carry == 1:\\n                ones += 1 \\n            \\n            if ones == 0:\\n                ans = ans + \"0\"\\n            elif ones == 1:\\n                ans = ans + \\'1\\'\\n                carry = 0\\n            elif ones == 2:\\n                ans = ans + \\'0\\'\\n                carry = 1\\n            else:\\n                ans = ans + \\'1\\'\\n                carry = 1\\n\\n            i -= 1 \\n            j -= 1 \\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792541,
                "title": "1-line-kotlin-solution-with-80-space-complexity",
                "content": "# Complexity\\n- Time complexity: Runtime 76.33%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 80%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun addBinary(a: String, b: String): String {\\n        return (a.toBigInteger(2) + b.toBigInteger(2)).toString(2)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun addBinary(a: String, b: String): String {\\n        return (a.toBigInteger(2) + b.toBigInteger(2)).toString(2)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707115,
                "title": "python-two-line-solution-very-easy-to-understand-o-n-100",
                "content": "Firstly we convert string into int using python function.\\nThen add both the numbers.\\nAt last Converting back int to string and returning them.\\n\\n```\\n    def addBinary(self, a, b):\\n        x,y = int(a,2) , int (b,2)\\n        return str(bin(x+y).replace(\"0b\",\"\"))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def addBinary(self, a, b):\\n        x,y = int(a,2) , int (b,2)\\n        return str(bin(x+y).replace(\"0b\",\"\"))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2378436,
                "title": "beginner-friendly-java-javascript-python-solutions",
                "content": "```java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int i= a.length() -1;\\n        int j= b.length() -1;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0)\\n                sum+=a.charAt(i--)-\\'0\\'; // -\\'0\\' is just to convert char in integer\\n            if(j>=0)\\n                sum+=b.charAt(j--)-\\'0\\';\\n            sb.append(sum%2);   // If we have sum = 1  1  then = 2 % 2 = 0 and 0  1 = 1 % 2 = 1\\n            carry = sum /2;\\n        }\\n        if(carry>0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n```javascript []\\nvar addBinary = function(a, b) {\\n    let i = a.length-1, j = b.length-1, carry = 0\\n    let s =[]\\n    while(i >= 0 || j >= 0){\\n        let sum = carry\\n        if(i >= 0)  sum += a[i--].charCodeAt() - 48\\n        if(j >= 0)  sum += b[j--].charCodeAt() - 48\\n        s.unshift(sum % 2)\\n        carry = ~~(sum/2)\\n    }\\n    return carry > 0 ? \"1\" + s.join(\"\") : s.join(\"\")\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        i, j, carry = len(a)-1, len(b)-1, 0\\n        s = []\\n        while i >= 0 or j >= 0:\\n            sm = carry\\n            if i >= 0:\\n                sm += ord(a[i]) - 48\\n                i -= 1\\n            if j >= 0:\\n                sm += ord(b[j]) - 48\\n                j -= 1\\n            s.insert(0, (sm % 2))\\n            carry = sm/2\\n        return \\'1\\' + \\'\\'.join(map(str, s)) if carry > 0 else \\'\\'.join(map(str, s))\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```java []\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        int i= a.length() -1;\\n        int j= b.length() -1;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0)\\n                sum+=a.charAt(i--)-\\'0\\'; // -\\'0\\' is just to convert char in integer\\n            if(j>=0)\\n                sum+=b.charAt(j--)-\\'0\\';\\n            sb.append(sum%2);   // If we have sum = 1  1  then = 2 % 2 = 0 and 0  1 = 1 % 2 = 1\\n            carry = sum /2;\\n        }\\n        if(carry>0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```javascript []\\nvar addBinary = function(a, b) {\\n    let i = a.length-1, j = b.length-1, carry = 0\\n    let s =[]\\n    while(i >= 0 || j >= 0){\\n        let sum = carry\\n        if(i >= 0)  sum += a[i--].charCodeAt() - 48\\n        if(j >= 0)  sum += b[j--].charCodeAt() - 48\\n        s.unshift(sum % 2)\\n        carry = ~~(sum/2)\\n    }\\n    return carry > 0 ? \"1\" + s.join(\"\") : s.join(\"\")\\n};\\n```\n```python []\\nclass Solution(object):\\n    def addBinary(self, a, b):\\n        i, j, carry = len(a)-1, len(b)-1, 0\\n        s = []\\n        while i >= 0 or j >= 0:\\n            sm = carry\\n            if i >= 0:\\n                sm += ord(a[i]) - 48\\n                i -= 1\\n            if j >= 0:\\n                sm += ord(b[j]) - 48\\n                j -= 1\\n            s.insert(0, (sm % 2))\\n            carry = sm/2\\n        return \\'1\\' + \\'\\'.join(map(str, s)) if carry > 0 else \\'\\'.join(map(str, s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368240,
                "title": "runtime-0ms-faster-than-100-00-of-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string str=\"\";\\n        int carry=0;      \\n        while(a.size()!=0 || b.size()!=0)\\n        {     \\n            char al;        \\n            char bl;\\n            (a.size()!=0)? al=a.back():al=\\'0\\';         \\n            (b.size()!=0)? bl=b.back():bl=\\'0\\';\\n           \\n            if((al==\\'1\\' && bl==\\'0\\')||(al==\\'0\\' && bl==\\'1\\'))\\n            {\\n                if(carry==0)\\n                {\\n                    str+=\\'1\\';\\n                }\\n                else\\n                { \\n                    str+=\\'0\\';\\n                    carry=1;\\n                }\\n            }\\n            else if(al==\\'1\\' && bl==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    str+=\\'1\\';carry=1;\\n                }\\n                else\\n                {\\n                    str+=\\'0\\';carry=1;\\n                }\\n            }\\n            else if(al==\\'0\\'&& bl==\\'0\\')\\n            {\\n                if(carry==0)str+=\\'0\\';\\n                else\\n                { \\n                    str+=\\'1\\';\\n                    carry=0;\\n                }\\n            }\\n            if(a.size()!=0)a.pop_back();\\n            if(b.size()!=0)b.pop_back();\\n        }\\n        if(carry==1)str+=\\'1\\';\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string str=\"\";\\n        int carry=0;      \\n        while(a.size()!=0 || b.size()!=0)\\n        {     \\n            char al;        \\n            char bl;\\n            (a.size()!=0)? al=a.back():al=\\'0\\';         \\n            (b.size()!=0)? bl=b.back():bl=\\'0\\';\\n           \\n            if((al==\\'1\\' && bl==\\'0\\')||(al==\\'0\\' && bl==\\'1\\'))\\n            {\\n                if(carry==0)\\n                {\\n                    str+=\\'1\\';\\n                }\\n                else\\n                { \\n                    str+=\\'0\\';\\n                    carry=1;\\n                }\\n            }\\n            else if(al==\\'1\\' && bl==\\'1\\')\\n            {\\n                if(carry==1)\\n                {\\n                    str+=\\'1\\';carry=1;\\n                }\\n                else\\n                {\\n                    str+=\\'0\\';carry=1;\\n                }\\n            }\\n            else if(al==\\'0\\'&& bl==\\'0\\')\\n            {\\n                if(carry==0)str+=\\'0\\';\\n                else\\n                { \\n                    str+=\\'1\\';\\n                    carry=0;\\n                }\\n            }\\n            if(a.size()!=0)a.pop_back();\\n            if(b.size()!=0)b.pop_back();\\n        }\\n        if(carry==1)str+=\\'1\\';\\n        reverse(str.begin(),str.end());\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890638,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction addBinary(a: string, b: string): string {\\n  let result = \"\"\\n  let carry = 0\\n  let length = Math.max(a.length, b.length)\\n  let i = 1\\n  const its = []\\n\\n  while (i <= length) {\\n    let x = Number(a[a.length - i] || 0)\\n    let y = Number(b[b.length - i] || 0)\\n    let sum = x + y + carry\\n\\n    carry = sum > 1 ? 1 : 0\\n    result = (sum % 2) + result\\n\\n    its.push({ i, x, y, carry, sum, result })\\n    i++\\n  }\\n\\n  if (carry) { result = carry.toString(2) + result }\\n  return result\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction addBinary(a: string, b: string): string {\\n  let result = \"\"\\n  let carry = 0\\n  let length = Math.max(a.length, b.length)\\n  let i = 1\\n  const its = []\\n\\n  while (i <= length) {\\n    let x = Number(a[a.length - i] || 0)\\n    let y = Number(b[b.length - i] || 0)\\n    let sum = x + y + carry\\n\\n    carry = sum > 1 ? 1 : 0\\n    result = (sum % 2) + result\\n\\n    its.push({ i, x, y, carry, sum, result })\\n    i++\\n  }\\n\\n  if (carry) { result = carry.toString(2) + result }\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679490,
                "title": "c-binary-addition-with-three-different-approach-s",
                "content": "> Given two binary strings a and b, return their sum as a binary string.\\n***\\n**Intuition:-**\\nThere will be many different intuitions in this question \\n* **Easy but long way** is to convert `a` and `b` to decimal then add them and convert the result back to binary and return the result .\\n* **A optimized approach** can be to simply do the `binary addition` in a `result` variable and return the result .\\n* **A well optimized approach** can be that we just write the sum into the longer one of the inputs and return that as result. In this case space complexity will become O(1) .\\n***\\n**Algorithm :-**\\n* Intialize i & j index for a and b from last character index of a & b .\\n* Now loop till the both index reaches 0 and add last bit of both the string along wtih their carry.\\n* Reminder from 2 is the new bit we are dicussing and divide by 2 gives us our carry\\n***\\n**Optimized Code:-**\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string result=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            result=to_string(sum%2)+result;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               result=to_string(1)+result;\\n        return result;\\n        \\n    }\\n};\\n```\\n**Time Complexity :** *`O(n)`*\\n**Space Complexity :** *`O(n)`*\\n***\\n**Well Space Optimized Code:-**\\n```\\nclass Solution {\\npublic:\\n     string addBinary(string a, string b) {\\n        //making \\'a\\' as larger by swaping\\n        if(a.size() < b.size()) swap(a, b); \\n        int i = a.size(), j = b.size();\\n        //Traversing the whole \"a\"\\n        while (i--) {\\n            if(j) a[i] += b[--j] & 1;\\n            if(a[i] > \\'1\\') {\\n                a[i] -= 2;\\n                if(i) \\n                    a[i-1]++; else a = \\'1\\' + a;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(n^2) `*\\n**Space Complexity:** *`O(1)`*\\n***\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i=a.size()-1,j=b.size()-1;\\n        int carry=0;\\n        string result=\"\";\\n        while(i>=0|| j>=0){\\n            int x = (i>=0)?a[i--]-\\'0\\':0; \\n            int y = (j>=0)?b[j--]-\\'0\\':0;\\n            int sum = x+y+carry;\\n            result=to_string(sum%2)+result;\\n            carry=sum/2;\\n        }\\n        if(carry>0)\\n               result=to_string(1)+result;\\n        return result;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     string addBinary(string a, string b) {\\n        //making \\'a\\' as larger by swaping\\n        if(a.size() < b.size()) swap(a, b); \\n        int i = a.size(), j = b.size();\\n        //Traversing the whole \"a\"\\n        while (i--) {\\n            if(j) a[i] += b[--j] & 1;\\n            if(a[i] > \\'1\\') {\\n                a[i] -= 2;\\n                if(i) \\n                    a[i-1]++; else a = \\'1\\' + a;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506359,
                "title": "c-simple-clean-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.size()-1, bi = b.size()-1, carry = 0, curr;\\n        string res = \"\";\\n        \\n        for (; ai >= 0 || bi >= 0; ai--, bi--) {\\n            curr = (ai >= 0) ? a[ai]-\\'0\\' : 0;\\n            curr += (bi >= 0) ? b[bi]-\\'0\\' : 0;\\n            curr += carry;\\n            \\n            carry = curr >= 2;\\n            curr %= 2;\\n            \\n            res = to_string(curr) + res;\\n        }\\n        \\n        return carry ? \"1\" + res : res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.size()-1, bi = b.size()-1, carry = 0, curr;\\n        string res = \"\";\\n        \\n        for (; ai >= 0 || bi >= 0; ai--, bi--) {\\n            curr = (ai >= 0) ? a[ai]-\\'0\\' : 0;\\n            curr += (bi >= 0) ? b[bi]-\\'0\\' : 0;\\n            curr += carry;\\n            \\n            carry = curr >= 2;\\n            curr %= 2;\\n            \\n            res = to_string(curr) + res;\\n        }\\n        \\n        return carry ? \"1\" + res : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485094,
                "title": "c-0-ms-faster-than-100-00",
                "content": "```\\nstring addBinary(string a, string b) {\\n    int sum=0;\\n    string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        while(i>=0 && j>=0){\\n            sum=(a[i--]-\\'0\\')+(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        while(i>=0){\\n             sum=(a[i--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n         while(j>=0){\\n             sum=(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        if(carry==1){\\n            std::string s1 = std::to_string(carry);\\n            s+=s1;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring addBinary(string a, string b) {\\n    int sum=0;\\n    string s;\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        while(i>=0 && j>=0){\\n            sum=(a[i--]-\\'0\\')+(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        while(i>=0){\\n             sum=(a[i--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n         while(j>=0){\\n             sum=(b[j--]-\\'0\\')+carry;\\n            if(sum>1){\\n                carry=1;\\n            }else carry=0;\\n            std::string s1 = std::to_string(sum%2);\\n            s+=s1;\\n        }\\n        if(carry==1){\\n            std::string s1 = std::to_string(carry);\\n            s+=s1;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1337965,
                "title": "simple-code-of-c-100-faster-and-0ms",
                "content": "```\\n string addBinary(string a, string b) {\\n        int p = a.length() - 1;\\n        int q = b.length() - 1;\\n        int carry = 0;\\n        string r = \"\";\\n        while (p >= 0 || q >= 0 || carry )\\n        {\\n            carry += (p >= 0) ? a[p--] - \\'0\\' : 0;\\n            carry += (q >= 0) ? b[q--] - \\'0\\': 0;\\n            r = char(carry % 2+ \\'0\\') + r;\\n            carry /= 2;\\n        }\\n        return r;\\n       \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n string addBinary(string a, string b) {\\n        int p = a.length() - 1;\\n        int q = b.length() - 1;\\n        int carry = 0;\\n        string r = \"\";\\n        while (p >= 0 || q >= 0 || carry )\\n        {\\n            carry += (p >= 0) ? a[p--] - \\'0\\' : 0;\\n            carry += (q >= 0) ? b[q--] - \\'0\\': 0;\\n            r = char(carry % 2+ \\'0\\') + r;\\n            carry /= 2;\\n        }\\n        return r;\\n       \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1039251,
                "title": "my-long-way-javascript-97-93",
                "content": "```\\nvar addBinary = function(a, b) {\\n    if (a === \"0\" && b === \"0\") return \"0\";\\n    \\n    let output = \"\";\\n    let carry = 0;\\n    let i = a.length - 1;\\n    let j = b.length - 1;\\n    while (i >= 0 || j >= 0) {\\n        const num1 = a[i] === undefined ? 0 : +a[i];\\n        const num2 = b[j] === undefined ? 0 : +b[j];\\n        if (num1 + num2 + carry < 2) {\\n            output = (num1 + num2 + carry).toString() + output;\\n            carry = 0;\\n        } else if (num1 + num2 + carry >= 2) {\\n            output = (num1 + num2 + carry - 2).toString() + output;\\n            carry = 0;\\n            carry++;\\n        }\\n        i--, j--;\\n    }\\n    return `${carry || \"\"}${output}`;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addBinary = function(a, b) {\\n    if (a === \"0\" && b === \"0\") return \"0\";\\n    \\n    let output = \"\";\\n    let carry = 0;\\n    let i = a.length - 1;\\n    let j = b.length - 1;\\n    while (i >= 0 || j >= 0) {\\n        const num1 = a[i] === undefined ? 0 : +a[i];\\n        const num2 = b[j] === undefined ? 0 : +b[j];\\n        if (num1 + num2 + carry < 2) {\\n            output = (num1 + num2 + carry).toString() + output;\\n            carry = 0;\\n        } else if (num1 + num2 + carry >= 2) {\\n            output = (num1 + num2 + carry - 2).toString() + output;\\n            carry = 0;\\n            carry++;\\n        }\\n        i--, j--;\\n    }\\n    return `${carry || \"\"}${output}`;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 977474,
                "title": "100-faster-simple-code-with-proper-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans=\"\";\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        \\n        while(i>=0 || j>=0)\\n        {\\n            int temp=carry;\\n            if(i>=0) temp+=(a[i]-\\'0\\'); // converting string into integer\\n            if(j>=0) temp+=(b[j]-\\'0\\');\\n            ans+=to_string(temp%2); // if both digit is 1 then append 0\\n            carry=temp/2; // if sum is 2 then carry 1\\n            i--,j--;\\n        }\\n        if(carry!=0) ans+=to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans=\"\";\\n        int i=a.length()-1;\\n        int j=b.length()-1;\\n        int carry=0;\\n        \\n        while(i>=0 || j>=0)\\n        {\\n            int temp=carry;\\n            if(i>=0) temp+=(a[i]-\\'0\\'); // converting string into integer\\n            if(j>=0) temp+=(b[j]-\\'0\\');\\n            ans+=to_string(temp%2); // if both digit is 1 then append 0\\n            carry=temp/2; // if sum is 2 then carry 1\\n            i--,j--;\\n        }\\n        if(carry!=0) ans+=to_string(carry);\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745334,
                "title": "easy-clear-java-solution",
                "content": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        StringBuffer sb = new StringBuffer();\\n        while(i>=0 || j>=0){\\n            int sum = 0;\\n            if(i >= 0){\\n                sum += a.charAt(i) - \\'0\\';// -\\'0\\' to convert a char to int\\n                i--;    \\n            }\\n            if(j>=0){\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;    \\n            }\\n                sum += carry;\\n                sb.append(sum%2);\\n                carry = sum/2;\\n        }\\n        if(carry > 0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        StringBuffer sb = new StringBuffer();\\n        while(i>=0 || j>=0){\\n            int sum = 0;\\n            if(i >= 0){\\n                sum += a.charAt(i) - \\'0\\';// -\\'0\\' to convert a char to int\\n                i--;    \\n            }\\n            if(j>=0){\\n                sum += b.charAt(j) - \\'0\\';\\n                j--;    \\n            }\\n                sum += carry;\\n                sb.append(sum%2);\\n                carry = sum/2;\\n        }\\n        if(carry > 0)\\n            sb.append(carry);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500315,
                "title": "simple-go-solution",
                "content": "```\\nfunc addBinary(a string, b string) string {\\n    s := 0\\n    carry := 0\\n    res := \"\"\\n    la := len(a) - 1\\n    lb := len(b) - 1\\n    for la >= 0 || lb >= 0 || carry != 0{\\n        s = carry\\n        if la >= 0 {\\n            s += int(a[la] - \\'0\\')\\n            la -- \\n        }\\n        if lb >= 0 {\\n            s += int(b[lb] - \\'0\\')\\n            lb --\\n        }\\n        carry = s / 2\\n        res = string(s % 2 + \\'0\\') + res\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc addBinary(a string, b string) string {\\n    s := 0\\n    carry := 0\\n    res := \"\"\\n    la := len(a) - 1\\n    lb := len(b) - 1\\n    for la >= 0 || lb >= 0 || carry != 0{\\n        s = carry\\n        if la >= 0 {\\n            s += int(a[la] - \\'0\\')\\n            la -- \\n        }\\n        if lb >= 0 {\\n            s += int(b[lb] - \\'0\\')\\n            lb --\\n        }\\n        carry = s / 2\\n        res = string(s % 2 + \\'0\\') + res\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358445,
                "title": "easy-to-understand-python-solution-32ms-beats-97",
                "content": "The idea is similar to https://leetcode.com/problems/add-two-numbers/ -- iterate backwards and build the result from the back by adding two last digits while keeping carry in mind. In the end, if carry is non-zero we append it to the front.\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \"\"\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0:\\n            a_digit = int(a[i]) if i >= 0 else 0\\n            b_digit = int(b[j]) if j >= 0 else 0\\n            _sum = a_digit + b_digit + carry\\n            digit = _sum % 2\\n            carry = _sum // 2\\n            result = str(digit) + result\\n            i -= 1\\n            j -= 1\\n        if carry:\\n            result = str(carry) + result\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        carry = 0\\n        result = \"\"\\n        i, j = len(a) - 1, len(b) - 1\\n        while i >= 0 or j >= 0:\\n            a_digit = int(a[i]) if i >= 0 else 0\\n            b_digit = int(b[j]) if j >= 0 else 0\\n            _sum = a_digit + b_digit + carry\\n            digit = _sum % 2\\n            carry = _sum // 2\\n            result = str(digit) + result\\n            i -= 1\\n            j -= 1\\n        if carry:\\n            result = str(carry) + result\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186022,
                "title": "java-use-xor-and-displacement",
                "content": "```\\nclass Solution {\\n   public String addBinary(String astr, String bstr) {\\n        StringBuilder res = new StringBuilder();\\n        int inc=0;\\n        char[] as = astr.toCharArray();\\n        char[] bs = bstr.toCharArray();\\n        int i=astr.length()-1,j=bstr.length()-1;\\n        while(i>=0||j>=0||inc>0){\\n            int a = i>=0?as[i]-\\'0\\':0;\\n            int b = j>=0?bs[j]-\\'0\\':0;\\n            res.append(a^b^inc);\\n            inc = (a&b)|(a&inc)|(b&inc);\\n            i--;j--;\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public String addBinary(String astr, String bstr) {\\n        StringBuilder res = new StringBuilder();\\n        int inc=0;\\n        char[] as = astr.toCharArray();\\n        char[] bs = bstr.toCharArray();\\n        int i=astr.length()-1,j=bstr.length()-1;\\n        while(i>=0||j>=0||inc>0){\\n            int a = i>=0?as[i]-\\'0\\':0;\\n            int b = j>=0?bs[j]-\\'0\\':0;\\n            res.append(a^b^inc);\\n            inc = (a&b)|(a&inc)|(b&inc);\\n            i--;j--;\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24645,
                "title": "my-java-neat-and-clean-solution-using-bit-manipulation",
                "content": "Hello everyone,\\n\\nI am sharing my Java solution using bit manipulation with a very neat and clean code, easy to understand:\\n\\n```\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int sum = 0, carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        \\n        // start from the end\\n        while(i >= 0 || j >= 0){\\n            // take the bits\\n            int bit1 = (i >= 0) ? Integer.parseInt(String.valueOf(a.charAt(i))) : 0;\\n            int bit2 = (j >= 0) ? Integer.parseInt(String.valueOf(b.charAt(j))) : 0;\\n            \\n            // calculate the sum and the carry\\n            sum = carry ^ bit1 ^ bit2;\\n            carry = (carry & bit1) | (carry & bit2) | (bit1 & bit2);\\n            \\n            result.append(String.valueOf(sum));\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry > 0)\\n            result.append(String.valueOf(carry));\\n            \\n        return result.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int sum = 0, carry = 0;\\n        int i = a.length() - 1, j = b.length() - 1;\\n        \\n        // start from the end\\n        while(i >= 0 || j >= 0){\\n            // take the bits\\n            int bit1 = (i >= 0) ? Integer.parseInt(String.valueOf(a.charAt(i))) : 0;\\n            int bit2 = (j >= 0) ? Integer.parseInt(String.valueOf(b.charAt(j))) : 0;\\n            \\n            // calculate the sum and the carry\\n            sum = carry ^ bit1 ^ bit2;\\n            carry = (carry & bit1) | (carry & bit2) | (bit1 & bit2);\\n            \\n            result.append(String.valueOf(sum));\\n            i--;\\n            j--;\\n        }\\n        \\n        if(carry > 0)\\n            result.append(String.valueOf(carry));\\n            \\n        return result.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24762,
                "title": "consise-java-solution-11-lines",
                "content": "    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for(int i=a.length()-1,j=b.length()-1;i>=0 || j>=0;i--,j--){\\n            int v1 = (i<0)?0:a.charAt(i)-'0';\\n            int v2 = (j<0)?0:b.charAt(j)-'0';\\n            int val = (v1+v2+carry)%2;\\n            carry = (v1+v2+carry)/2;\\n            sb.insert(0,(char)(val+'0'));\\n        }\\n        if(carry == 1) sb.insert(0,'1');\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int carry = 0;\\n        for(int i=a.length()-1,j=b.length()-1;i>=0 || j>=0;i--,j--){\\n            int v1 = (i<0)?0:a.charAt(i)-'0';\\n            int v2 = (j<0)?0:b.charAt(j)-'0';\\n            int val = (v1+v2+carry)%2;\\n            carry = (v1+v2+carry)/2;\\n            sb.insert(0,(char)(val+'0'));\\n        }\\n        if(carry == 1) sb.insert(0,'1');\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3836500,
                "title": "easy-readable-and-concise-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint sum_funct(int a,int b){\\n    if (a==1 && b==1)return 10;\\n    return a+b;\\n}\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        string ans;\\n        int n= a.size(); int m= b.size();\\n        int i=0; int j=0;\\n        int carry=0;\\n        while (i<n && j<m){\\n            int sum= sum_funct(a[i]-\\'0\\',b[j]-\\'0\\');\\n            sum= sum_funct(sum,carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++; j++;\\n        }\\n        while (i<n){\\n            int sum= sum_funct(a[i]-\\'0\\',carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++;\\n        }\\n        while (j<m){\\n            int sum= sum_funct(carry,b[j]-\\'0\\');\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            j++;\\n        }\\n        if (carry==1)ans+= \\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint sum_funct(int a,int b){\\n    if (a==1 && b==1)return 10;\\n    return a+b;\\n}\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        string ans;\\n        int n= a.size(); int m= b.size();\\n        int i=0; int j=0;\\n        int carry=0;\\n        while (i<n && j<m){\\n            int sum= sum_funct(a[i]-\\'0\\',b[j]-\\'0\\');\\n            sum= sum_funct(sum,carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++; j++;\\n        }\\n        while (i<n){\\n            int sum= sum_funct(a[i]-\\'0\\',carry);\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            i++;\\n        }\\n        while (j<m){\\n            int sum= sum_funct(carry,b[j]-\\'0\\');\\n            carry= sum/10;\\n            ans+= (sum%10)+\\'0\\';\\n            j++;\\n        }\\n        if (carry==1)ans+= \\'1\\';\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718779,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to add two binary numbers (made up of 0\\'s and 1\\'s) and returns the result in binary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n->We start at the right end of each binary number, adding the digits and any carry-over value, and storing the result in a new string.\\n->Now we move to the next digit on the left and repeats the process until it has gone through all the digits in both binary numbers.\\n->If there is any carry-over value after adding all the digits, append it to the end of the new string.\\n->Finally, the new string is reversed and returned as the sum of the two binary numbers.\\n\\n# Code\\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int carry = 0;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\n        while(i>=0 || j>=0 || carry==1){\\n            if(i>=0){\\n                carry += a.charAt(i--) -\\'0\\';\\n            }\\n            if(j>=0){\\n                carry += b.charAt(j--) - \\'0\\';\\n            }\\n            result.append(carry%2);\\n            carry /= 2;\\n        }\\n\\n        return result.reverse().toString();\\n\\n    }\\n}\\n```\\n![oie_CksRiTNvbciG.jpg](https://assets.leetcode.com/users/images/9bf324f7-cdd3-46f7-b072-451013fd616b_1688494785.9285524.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int carry = 0;\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n\\n        while(i>=0 || j>=0 || carry==1){\\n            if(i>=0){\\n                carry += a.charAt(i--) -\\'0\\';\\n            }\\n            if(j>=0){\\n                carry += b.charAt(j--) - \\'0\\';\\n            }\\n            result.append(carry%2);\\n            carry /= 2;\\n        }\\n\\n        return result.reverse().toString();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183131,
                "title": "c-0ms-solution-optimal-solution-easy-to-understand-clean-and-concise",
                "content": "# Code\\n# **PLEASE DO UPVOTE !**\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        if(a.size()>b.size()){\\n            while(b.size()<a.size()){\\n                b+=\"0\";\\n            }\\n        }\\n        else if(b.size()>a.size()){\\n            while(a.size()<b.size()){\\n                a+=\"0\";\\n            }\\n        }\\n        string ans=\"\";\\n        int c=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==0){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==1){\\n                ans+=\"1\";\\n                c=1;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==0){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==1){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'0\\' and b[i]==\\'0\\' and c==0){\\n                ans+=\"0\";\\n                c=0;\\n            }\\n            else if(a[i]==\\'0\\' and a[i]==\\'0\\' and c==1){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n        }\\n        if(c==1){\\n            ans+=\"1\";\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(),a.end());\\n        reverse(b.begin(),b.end());\\n        if(a.size()>b.size()){\\n            while(b.size()<a.size()){\\n                b+=\"0\";\\n            }\\n        }\\n        else if(b.size()>a.size()){\\n            while(a.size()<b.size()){\\n                a+=\"0\";\\n            }\\n        }\\n        string ans=\"\";\\n        int c=0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==0){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'1\\' and b[i]==\\'1\\' and c==1){\\n                ans+=\"1\";\\n                c=1;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==0){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n            else if(((a[i]==\\'1\\' and b[i]==\\'0\\') or (a[i]==\\'0\\' and b[i]==\\'1\\')) and c==1){\\n                ans+=\"0\";\\n                c=1;\\n            }\\n            else if(a[i]==\\'0\\' and b[i]==\\'0\\' and c==0){\\n                ans+=\"0\";\\n                c=0;\\n            }\\n            else if(a[i]==\\'0\\' and a[i]==\\'0\\' and c==1){\\n                ans+=\"1\";\\n                c=0;\\n            }\\n        }\\n        if(c==1){\\n            ans+=\"1\";\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742895,
                "title": "python-one-line-solution-easy",
                "content": "````\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        #int(a,2) a represents str, 2 represents base\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        #int(a,2) a represents str, 2 represents base\\n        return str(bin(int(a,2)+int(b,2)))[2:]  # first two elements of the binary is always 0b",
                "codeTag": "Java"
            },
            {
                "id": 2635764,
                "title": "explaination-solution-java-90",
                "content": "Explaination : add two binary (given in the form of string ) and return the sum as a return\\n1+1 = 0  , 1 + 0 = 1 (binary sum)\\nApproach : \\n1. Used String Builder to use method like reverse , append \\n2. add last digits of binary and add the last digit of sum into new stringBuilder\\n3. also add the carry to next sum\\n4. atlast reverse the string \\n```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length()-1 , j = b.length()-1, carry = 0;\\n        while (i>=0||j>=0){\\n            int sum = carry;\\n            if(i>=0)sum += a.charAt(i--) - \\'0\\'; ////we subtract \\'0\\' to get the int value of the char from the ascii\\n            if(j>=0)sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum%2);\\n            carry = sum/2;\\n        }\\n        if(carry!=0) sb.append(carry); //adding remaining carry to sum\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuilder sb = new StringBuilder();\\n        int i = a.length()-1 , j = b.length()-1, carry = 0;\\n        while (i>=0||j>=0){\\n            int sum = carry;\\n            if(i>=0)sum += a.charAt(i--) - \\'0\\'; ////we subtract \\'0\\' to get the int value of the char from the ascii\\n            if(j>=0)sum += b.charAt(j--) - \\'0\\';\\n            sb.append(sum%2);\\n            carry = sum/2;\\n        }\\n        if(carry!=0) sb.append(carry); //adding remaining carry to sum\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529905,
                "title": "c-solution-add-binary",
                "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        \\n        string result;\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0){\\n                sum += a[i--] -\\'0\\'; \\n            }\\n            if(j >= 0){\\n                sum += b[j--] - \\'0\\';\\n            }\\n            carry = sum > 1 ? 1 : 0;\\n            result += to_string(sum%2);\\n        }\\n        if(carry) result += to_string(carry);\\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        \\n        string result;\\n        int i = a.size()-1, j = b.size()-1;\\n        int carry = 0;\\n        while(i >= 0 || j >= 0){\\n            int sum = carry;\\n            if(i >= 0){\\n                sum += a[i--] -\\'0\\'; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2524346,
                "title": "easy-approach-100-fast",
                "content": "```\\npublic String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int i = a.length() -1 ;\\n        int j = b.length() -1 ;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0) sum+= a.charAt(i--) - \\'0\\';\\n            if(j>=0) sum+= b.charAt(j--) - \\'0\\';\\n            carry = sum >1 ? 1:0;\\n            result.append(sum%2);\\n        }\\n        if(carry!=0) result.append(carry);\\n        return result.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String addBinary(String a, String b) {\\n        StringBuilder result = new StringBuilder();\\n        int i = a.length() -1 ;\\n        int j = b.length() -1 ;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0) sum+= a.charAt(i--) - \\'0\\';\\n            if(j>=0) sum+= b.charAt(j--) - \\'0\\';\\n            carry = sum >1 ? 1:0;\\n            result.append(sum%2);\\n        }\\n        if(carry!=0) result.append(carry);\\n        return result.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506833,
                "title": "0ms-easily-understandable-c-solution-single-for-loop",
                "content": "![image](https://assets.leetcode.com/users/images/8697268a-6131-4691-a90c-b6eebe3655a2_1661892025.0757692.png)\\n\\n**Question** (*read it after going through the code*): You will wonder, if we reversed the strings just to push back and then also reversed the final string at the end, then can\\'t we insert everything at the beginning so to save 3 reverse operations? \\n**Answer**: Try it yourself and drop in comments if you get the way! I would be impressed.\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(), a.end());                        //Reversing both strings (if you get this, then you got the code very well)\\n        reverse(b.begin(), b.end());\\n        \\n        if(a.size()>b.size()){                              //These two conditions are for making both strings equal sized by adding \\'0\\' to smaller string\\n            for(int i=b.size(); i<a.size(); i++){           //We need to add \\'0\\' to front so not to affect the sum, that\\'s why we first reversed the string and then pushed back ;)\\n                b.push_back(\\'0\\');\\n            }\\n        }\\n        else if(a.size()<b.size()){\\n            for(int i=a.size(); i<b.size(); i++){\\n                a.push_back(\\'0\\');\\n            }\\n        }\\n        \\n        string res;                                         //Result string\\n        char carry=\\'0\\';                                     //Carry\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==\\'1\\'&&b[i]==\\'1\\'){\\n                res.push_back(carry);\\n                carry=\\'1\\';\\n            }\\n            else if((a[i]==\\'1\\' || b[i]==\\'1\\')){\\n                if(carry==\\'1\\') res.push_back(\\'0\\');\\n                else res.push_back(\\'1\\');\\n            }\\n            else{\\n                res.push_back(carry);\\n                if(carry==\\'1\\') carry=\\'0\\';\\n            }\\n        }\\n        if(carry==\\'1\\') res.push_back(\\'1\\');                  //if carry is present after looping, add it at the end (remember, we first reversed strings. So everything we need to add to the front, we will push back)\\n            \\n        reverse(res.begin(), res.end());                    //Reverse again to get the final string\\n        return res;   \\n    }\\n};\\n```\\n**Plz Upvote if you find the solution helpful :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        reverse(a.begin(), a.end());                        //Reversing both strings (if you get this, then you got the code very well)\\n        reverse(b.begin(), b.end());\\n        \\n        if(a.size()>b.size()){                              //These two conditions are for making both strings equal sized by adding \\'0\\' to smaller string\\n            for(int i=b.size(); i<a.size(); i++){           //We need to add \\'0\\' to front so not to affect the sum, that\\'s why we first reversed the string and then pushed back ;)\\n                b.push_back(\\'0\\');\\n            }\\n        }\\n        else if(a.size()<b.size()){\\n            for(int i=a.size(); i<b.size(); i++){\\n                a.push_back(\\'0\\');\\n            }\\n        }\\n        \\n        string res;                                         //Result string\\n        char carry=\\'0\\';                                     //Carry\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==\\'1\\'&&b[i]==\\'1\\'){\\n                res.push_back(carry);\\n                carry=\\'1\\';\\n            }\\n            else if((a[i]==\\'1\\' || b[i]==\\'1\\')){\\n                if(carry==\\'1\\') res.push_back(\\'0\\');\\n                else res.push_back(\\'1\\');\\n            }\\n            else{\\n                res.push_back(carry);\\n                if(carry==\\'1\\') carry=\\'0\\';\\n            }\\n        }\\n        if(carry==\\'1\\') res.push_back(\\'1\\');                  //if carry is present after looping, add it at the end (remember, we first reversed strings. So everything we need to add to the front, we will push back)\\n            \\n        reverse(res.begin(), res.end());                    //Reverse again to get the final string\\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2379284,
                "title": "c-solution-3ms-fast-than-89",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i = a.length()-1, j = b.length()-1;\\n        int carry = 0;\\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry/=2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans;\\n        int i = a.length()-1, j = b.length()-1;\\n        int carry = 0;\\n        while(i>=0 || j>=0 || carry){\\n            if(i>=0){\\n                carry += a[i] - \\'0\\';\\n                i--;\\n            }\\n            if(j>=0){\\n                carry += b[j] - \\'0\\';\\n                j--;\\n            }\\n            \\n            ans += (carry%2 + \\'0\\');\\n            carry/=2;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883447,
                "title": "add-binary",
                "content": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder s = new StringBuilder();\\n        int sum = 0;\\n        while(i >= 0 || j >= 0){\\n            sum = sum/2;\\n            if(i >= 0) \\n                sum = sum + a.charAt(i) - \\'0\\';\\n            if(j >= 0) \\n                sum = sum + b.charAt(j) - \\'0\\';\\n            s.append(sum % 2);\\n            i--;\\n            j--;\\n        }\\n        if(sum / 2 != 0) \\n            s.append(1);\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        StringBuilder s = new StringBuilder();\\n        int sum = 0;\\n        while(i >= 0 || j >= 0){\\n            sum = sum/2;\\n            if(i >= 0) \\n                sum = sum + a.charAt(i) - \\'0\\';\\n            if(j >= 0) \\n                sum = sum + b.charAt(j) - \\'0\\';\\n            s.append(sum % 2);\\n            i--;\\n            j--;\\n        }\\n        if(sum / 2 != 0) \\n            s.append(1);\\n        return s.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714533,
                "title": "easy-python-1-liner",
                "content": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        return (bin(int(a,2) + int(b,2)))[2:]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        return (bin(int(a,2) + int(b,2)))[2:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1686352,
                "title": "javascript-o-max-n-m-time-complexity-o-1-space-complexity",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    let aLen = a.length - 1;\\n    let bLen = b.length - 1;\\n\\n    let binaryCount = \"\";\\n    let hasCarry = false;\\n\\n    while(aLen >= 0 || bLen >= 0) {\\n        let num1 = (aLen >= 0 ? Number.parseInt(a[aLen]) : 0);\\n        let num2 = (bLen >= 0 ? Number.parseInt(b[bLen]) : 0);\\n\\n        let value = hasCarry ? 1 ^ (num1 ^ num2) : (num1 ^ num2);\\n\\n        binaryCount = value.toString().concat(binaryCount);\\n\\n        hasCarry = num1 === num2 && num1 === 1 || hasCarry && (num1 === 1 || num2 === 1);\\n\\n        aLen--;\\n        bLen--;\\n    }\\n\\n    return hasCarry ? \"1\".concat(binaryCount) : binaryCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nvar addBinary = function(a, b) {\\n    let aLen = a.length - 1;\\n    let bLen = b.length - 1;\\n\\n    let binaryCount = \"\";\\n    let hasCarry = false;\\n\\n    while(aLen >= 0 || bLen >= 0) {\\n        let num1 = (aLen >= 0 ? Number.parseInt(a[aLen]) : 0);\\n        let num2 = (bLen >= 0 ? Number.parseInt(b[bLen]) : 0);\\n\\n        let value = hasCarry ? 1 ^ (num1 ^ num2) : (num1 ^ num2);\\n\\n        binaryCount = value.toString().concat(binaryCount);\\n\\n        hasCarry = num1 === num2 && num1 === 1 || hasCarry && (num1 === 1 || num2 === 1);\\n\\n        aLen--;\\n        bLen--;\\n    }\\n\\n    return hasCarry ? \"1\".concat(binaryCount) : binaryCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680413,
                "title": "short-and-easy-python-solution",
                "content": "Modify string values so you can convert them into integers with the int() function, then add them and return the result in binary format as a string without the \\'0b\\' at the start.\\n```\\ndef addBinary(self, a: str, b: str) -> str:\\n        a = \"0b\" + a\\n        b = \"0b\" + b\\n        \\n        result = int(a, 2) + int(b, 2)\\n        \\n        return str(bin(result))[2:]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef addBinary(self, a: str, b: str) -> str:\\n        a = \"0b\" + a\\n        b = \"0b\" + b\\n        \\n        result = int(a, 2) + int(b, 2)\\n        \\n        return str(bin(result))[2:]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1679607,
                "title": "cpp-solution-can-we-optimize-it-further",
                "content": "Can i do better than this solution ?\\n\\n\\n    string addBinary(string a, string b) {\\n        int i = a.length()-1;\\n    int j = b.length() -1 ;\\n\\n    int carry  = 0;\\n    string ans = \"\";\\n    while(carry || j>=0 || i>=0){\\n        int sum = 0;\\n        if(i>=0){\\n            sum += a[i] - \\'0\\';\\n            i--;\\n        }if(j>=0){\\n            sum += b[j] - \\'0\\';\\n            j--;\\n        }\\n        sum += carry;\\n        ans = ans + to_string(sum % 2) ;\\n        carry = sum /2 ;\\n        \\n    }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "Can i do better than this solution ?\\n\\n\\n    string addBinary(string a, string b) {\\n        int i = a.length()-1;\\n    int j = b.length() -1 ;\\n\\n    int carry  = 0;\\n    string ans = \"\";\\n    while(carry || j>=0 || i>=0){\\n        int sum = 0;\\n        if(i>=0){\\n            sum += a[i] - \\'0\\';\\n            i--;\\n        }if(j>=0){\\n            sum += b[j] - \\'0\\';\\n            j--;\\n        }\\n        sum += carry;\\n        ans = ans + to_string(sum % 2) ;\\n        carry = sum /2 ;\\n        \\n    }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1617150,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nconst addBinary = (a, b) => {\\n  const arrA = a.split(\"\").reverse();\\n  const arrB = b.split(\"\").reverse();\\n  let carry = 0;\\n  let answer = [];\\n  let idx = 0;\\n  const len = a.length > b.length ? a.length : b.length;\\n\\n  while (idx < len) {\\n    const x = arrA[idx] ? +arrA[idx] : 0;\\n    const y = arrB[idx] ? +arrB[idx] : 0;\\n    const sum = carry + x + y;\\n    carry = Math.floor(sum / 2);\\n    answer.unshift(sum % 2);\\n    idx++;\\n  }\\n\\n  if (carry > 0) answer.unshift(carry);\\n\\n  return answer.join(\"\");\\n};\\n```\\nRuntime: 72 ms, faster than 94.73% of JavaScript online submissions for Add Binary.\\nMemory Usage: 40.8 MB, less than 55.11% of JavaScript online submissions for Add Binary.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} a\\n * @param {string} b\\n * @return {string}\\n */\\nconst addBinary = (a, b) => {\\n  const arrA = a.split(\"\").reverse();\\n  const arrB = b.split(\"\").reverse();\\n  let carry = 0;\\n  let answer = [];\\n  let idx = 0;\\n  const len = a.length > b.length ? a.length : b.length;\\n\\n  while (idx < len) {\\n    const x = arrA[idx] ? +arrA[idx] : 0;\\n    const y = arrB[idx] ? +arrB[idx] : 0;\\n    const sum = carry + x + y;\\n    carry = Math.floor(sum / 2);\\n    answer.unshift(sum % 2);\\n    idx++;\\n  }\\n\\n  if (carry > 0) answer.unshift(carry);\\n\\n  return answer.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395977,
                "title": "python-simple-solution-one-liner-faster-than-97",
                "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a, 2)+int(b, 2))[2:]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return bin(int(a, 2)+int(b, 2))[2:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132526,
                "title": "c-0-ms-solution-bit-by-bit-calculation",
                "content": "Gist : \\n* Get last index of both string.\\n* calculate each position sum & carry bit by bit (Similar to adding two numbers in link list)\\n* Since it\\'s base 2 number, at each position value should be saved after modulo 2.\\n* Carry is 1 if sum at that position is greater than two else 0.\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.length() - 1;\\n        int bi = b.length() - 1;\\n        string ans{};\\n        int carry = 0;\\n        while(ai >= 0 || bi >= 0){\\n            if(ai >= 0){\\n                carry += a[ai] - \\'0\\';\\n                --ai;\\n            }\\n            if(bi >= 0){\\n                carry += b[bi]- \\'0\\';\\n                --bi;\\n            }\\n            ans.push_back((carry % 2) + \\'0\\');\\n            if(carry > 1)\\n                carry = 1;\\n            else\\n                carry = 0;\\n        }\\n        if(carry)\\n            ans.push_back((carry % 2) + \\'0\\');\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int ai = a.length() - 1;\\n        int bi = b.length() - 1;\\n        string ans{};\\n        int carry = 0;\\n        while(ai >= 0 || bi >= 0){\\n            if(ai >= 0){\\n                carry += a[ai] - \\'0\\';\\n                --ai;\\n            }\\n            if(bi >= 0){\\n                carry += b[bi]- \\'0\\';\\n                --bi;\\n            }\\n            ans.push_back((carry % 2) + \\'0\\');\\n            if(carry > 1)\\n                carry = 1;\\n            else\\n                carry = 0;\\n        }\\n        if(carry)\\n            ans.push_back((carry % 2) + \\'0\\');\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089002,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuffer sb = new StringBuffer();\\n        int aIndex = a.length()-1;\\n        int bIndex = b.length()-1;\\n        \\n        int add = 0;\\n        while(aIndex >= 0 || bIndex >= 0) {\\n            int val1 = aIndex < 0 ? 0 : a.charAt(aIndex)-\\'0\\';\\n            int val2 = bIndex < 0 ? 0 : b.charAt(bIndex)-\\'0\\';\\n            int sum = val1 + val2 + add;\\n            if(sum >= 2) {\\n                add = 1;\\n                sum = sum - 2;\\n            } else {\\n                add = 0;\\n            }\\n            sb.append(sum);\\n            aIndex--;\\n            bIndex--;\\n        }\\n        if(add == 1) sb.append(add);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        StringBuffer sb = new StringBuffer();\\n        int aIndex = a.length()-1;\\n        int bIndex = b.length()-1;\\n        \\n        int add = 0;\\n        while(aIndex >= 0 || bIndex >= 0) {\\n            int val1 = aIndex < 0 ? 0 : a.charAt(aIndex)-\\'0\\';\\n            int val2 = bIndex < 0 ? 0 : b.charAt(bIndex)-\\'0\\';\\n            int sum = val1 + val2 + add;\\n            if(sum >= 2) {\\n                add = 1;\\n                sum = sum - 2;\\n            } else {\\n                add = 0;\\n            }\\n            sb.append(sum);\\n            aIndex--;\\n            bIndex--;\\n        }\\n        if(add == 1) sb.append(add);\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977822,
                "title": "python-one-liner",
                "content": "``` \\nreturn format(int(a, 2) + int(b,2), \"b\")",
                "solutionTags": [],
                "code": "``` \\nreturn format(int(a, 2) + int(b,2), \"b\")",
                "codeTag": "Unknown"
            },
            {
                "id": 921110,
                "title": "python-3-intuitive-24-ms",
                "content": "~~~\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        llen = max(len(a), len(b))\\n        diff = abs(len(a) - len(b))\\n        carry = 0\\n        result = \"\"\\n        if len(a) > len(b):\\n            b = \\'\\'.join((\\'0\\'*(diff), b)) # Insert \\'0\\' at the beginning of the string\\n        elif len(a) < len(b):\\n            a = \\'\\'.join((\\'0\\'*(diff), a))\\n        for i in range((llen-1), -1, -1):\\n            if (int(a[i]) + int(b[i]) + carry) == 2:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 3:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 1:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 0\\n            elif (int(a[i]) + int(b[i]) + carry) == 0:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 0\\n        if carry == 1:\\n            result = \\'\\'.join((\\'1\\', result))\\n        return result if len(result) else \"0\"\\n~~~",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "~~~\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        llen = max(len(a), len(b))\\n        diff = abs(len(a) - len(b))\\n        carry = 0\\n        result = \"\"\\n        if len(a) > len(b):\\n            b = \\'\\'.join((\\'0\\'*(diff), b)) # Insert \\'0\\' at the beginning of the string\\n        elif len(a) < len(b):\\n            a = \\'\\'.join((\\'0\\'*(diff), a))\\n        for i in range((llen-1), -1, -1):\\n            if (int(a[i]) + int(b[i]) + carry) == 2:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 3:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 1\\n            elif (int(a[i]) + int(b[i]) + carry) == 1:\\n                result = \\'\\'.join((\\'1\\', result))\\n                carry = 0\\n            elif (int(a[i]) + int(b[i]) + carry) == 0:\\n                result = \\'\\'.join((\\'0\\', result))\\n                carry = 0\\n        if carry == 1:\\n            result = \\'\\'.join((\\'1\\', result))\\n        return result if len(result) else \"0\"\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 744625,
                "title": "swift-minimalistic-solution-with-complexity",
                "content": "Time: O(n + c), Space: O(n + c) where n is the length of the longer string, and c is the carry (0 or 1)\\n```\\nfunc addBinary(_ a: String, _ b: String) -> String {\\n\\tlet arrayA = Array(a)\\n\\tlet arrayB = Array(b)\\n\\tvar i = arrayA.count - 1\\n\\tvar j = arrayB.count - 1\\n\\n\\tvar result = \"\"\\n\\tvar carry = 0\\n\\n\\twhile i >= 0 || j >= 0 || carry > 0 {\\n\\t\\tvar sum = carry\\n\\n\\t\\tif i >= 0 {\\n\\t\\t\\tsum += Int(String(arrayA[i]))!\\n\\t\\t\\ti -= 1\\n\\t\\t}\\n\\n\\t\\tif j >= 0 {\\n\\t\\t\\tsum += Int(String(arrayB[j]))!\\n\\t\\t\\tj -= 1\\n\\t\\t}\\n\\n\\t\\tresult = \"\\\\(sum % 2)\" + result\\n\\t\\tcarry = sum / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc addBinary(_ a: String, _ b: String) -> String {\\n\\tlet arrayA = Array(a)\\n\\tlet arrayB = Array(b)\\n\\tvar i = arrayA.count - 1\\n\\tvar j = arrayB.count - 1\\n\\n\\tvar result = \"\"\\n\\tvar carry = 0\\n\\n\\twhile i >= 0 || j >= 0 || carry > 0 {\\n\\t\\tvar sum = carry\\n\\n\\t\\tif i >= 0 {\\n\\t\\t\\tsum += Int(String(arrayA[i]))!\\n\\t\\t\\ti -= 1\\n\\t\\t}\\n\\n\\t\\tif j >= 0 {\\n\\t\\t\\tsum += Int(String(arrayB[j]))!\\n\\t\\t\\tj -= 1\\n\\t\\t}\\n\\n\\t\\tresult = \"\\\\(sum % 2)\" + result\\n\\t\\tcarry = sum / 2\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615989,
                "title": "c-o-n-solution",
                "content": "```\\n/*\\n    Time: O(n) where n = max(a.Length, b.Length)\\n    Space: O(n) where n = max(a.Length, b.Length), since StringBuilder tracks the result.\\n*/\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = a.Length - 1, j = b.Length - 1, carry = 0;\\n        \\n        while(i >= 0 || j >= 0 || carry > 0)\\n        {\\n            int valA = i < 0? 0 : a[i] - \\'0\\';\\n            int valB = j < 0? 0 : b[j] - \\'0\\';\\n            \\n            int sum = valA + valB + carry;\\n            sb.Insert(0, sum % 2);\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Time: O(n) where n = max(a.Length, b.Length)\\n    Space: O(n) where n = max(a.Length, b.Length), since StringBuilder tracks the result.\\n*/\\npublic class Solution {\\n    public string AddBinary(string a, string b) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n        int i = a.Length - 1, j = b.Length - 1, carry = 0;\\n        \\n        while(i >= 0 || j >= 0 || carry > 0)\\n        {\\n            int valA = i < 0? 0 : a[i] - \\'0\\';\\n            int valB = j < 0? 0 : b[j] - \\'0\\';\\n            \\n            int sum = valA + valB + carry;\\n            sb.Insert(0, sum % 2);\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        \\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611983,
                "title": "easy-to-understand-java-solution",
                "content": "```\\npublic String addBinary(String a, String b) {\\n       StringBuffer sb = new StringBuffer();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0){\\n                sum += a.charAt(i--)-\\'0\\';\\n            }\\n            if(j>=0){\\n                sum += b.charAt(j--)-\\'0\\';\\n            }\\n            sb.insert(0,sum%2);\\n            carry = sum/2;\\n         }\\n        if(carry!=0){\\n            sb.insert(0,carry);\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic String addBinary(String a, String b) {\\n       StringBuffer sb = new StringBuffer();\\n        int i = a.length() - 1;\\n        int j = b.length() - 1;\\n        int carry = 0;\\n        while(i>=0 || j>=0){\\n            int sum = carry;\\n            if(i>=0){\\n                sum += a.charAt(i--)-\\'0\\';\\n            }\\n            if(j>=0){\\n                sum += b.charAt(j--)-\\'0\\';\\n            }\\n            sb.insert(0,sum%2);\\n            carry = sum/2;\\n         }\\n        if(carry!=0){\\n            sb.insert(0,carry);\\n        }\\n        return sb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158430,
                "title": "java-beat-100",
                "content": "```\\n public String addBinary(String a, String b) {\\n        char[] result = new char[Math.max(a.length(), b.length())];\\n        int carryBit = 0;\\n        for (int a1 = a.length() - 1, a2 = b.length() - 1; a1 >= 0 || a2 >= 0; --a1, --a2) {\\n            int c1 = a1 < 0 ? 0 : (a.charAt(a1) - \\'0\\');\\n            int c2 = a2 < 0 ? 0 : (b.charAt(a2) - \\'0\\');\\n            result[Math.max(a1, a2)] = (char) ((c1 + c2 + carryBit) % 2 + (int) \\'0\\');\\n\\n            if ((c1 + c2 + carryBit) / 2 > 0) carryBit = 1;\\n            else carryBit = 0;\\n        }\\n        return (carryBit > 0 ? \"1\" : \"\") + new String(result);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public String addBinary(String a, String b) {\\n        char[] result = new char[Math.max(a.length(), b.length())];\\n        int carryBit = 0;\\n        for (int a1 = a.length() - 1, a2 = b.length() - 1; a1 >= 0 || a2 >= 0; --a1, --a2) {\\n            int c1 = a1 < 0 ? 0 : (a.charAt(a1) - \\'0\\');\\n            int c2 = a2 < 0 ? 0 : (b.charAt(a2) - \\'0\\');\\n            result[Math.max(a1, a2)] = (char) ((c1 + c2 + carryBit) % 2 + (int) \\'0\\');\\n\\n            if ((c1 + c2 + carryBit) / 2 > 0) carryBit = 1;\\n            else carryBit = 0;\\n        }\\n        return (carryBit > 0 ? \"1\" : \"\") + new String(result);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 24551,
                "title": "clean-c-3ms-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s = \"\";\\n        int i = a.size() - 1;\\n        int j = b.size() - 1;\\n        while(i >= 0 || j >= 0 || carry){\\n            int num1 = i < 0 ? 0 : a[i] - '0';\\n            int num2 = j < 0 ? 0 : b[j] - '0';\\n            int sum = num1 + num2 + carry;\\n            s.push_back(sum % 2 + '0');\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n***\\nShorter version.\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        string s = \"\";\\n        while(i >= 0 || j >= 0 || carry){\\n            int sum = (i < 0 ? 0 : a[i--] - '0') + (j < 0 ? 0 : b[j--] - '0') + carry;\\n            s = to_string(sum % 2) + s;\\n            carry = sum / 2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int carry = 0;\\n        string s = \"\";\\n        int i = a.size() - 1;\\n        int j = b.size() - 1;\\n        while(i >= 0 || j >= 0 || carry){\\n            int num1 = i < 0 ? 0 : a[i] - '0';\\n            int num2 = j < 0 ? 0 : b[j] - '0';\\n            int sum = num1 + num2 + carry;\\n            s.push_back(sum % 2 + '0');\\n            carry = sum / 2;\\n            i--;\\n            j--;\\n        }\\n        reverse(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int i = a.size() - 1, j = b.size() - 1, carry = 0;\\n        string s = \"\";\\n        while(i >= 0 || j >= 0 || carry){\\n            int sum = (i < 0 ? 0 : a[i--] - '0') + (j < 0 ? 0 : b[j--] - '0') + carry;\\n            s = to_string(sum % 2) + s;\\n            carry = sum / 2;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 24608,
                "title": "share-my-2ms-java-solution-beats-96",
                "content": "    public String addBinary(String a, String b) {\\n    \\tchar[] aArray = a.toCharArray();\\n    \\tchar[] bArray = b.toCharArray();\\n        char[] sumArray = new char[Math.max(a.length(), b.length()) + 1];\\n        int index = sumArray.length - 1, carry = 0;\\n        for(int aIndex = a.length()-1, bIndex = b.length()-1; aIndex >=0 || bIndex >= 0; aIndex--, bIndex--){\\n            int aNum = aIndex < 0 ? 0 : aArray[aIndex] - '0';\\n            int bNum = bIndex < 0 ? 0 : bArray[bIndex] - '0';\\n            int sum = aNum + bNum + carry;\\n            sumArray[index--] = (char)('0' + (sum % 2));\\n            carry = sum / 2;\\n        }\\n        sumArray[0] = (char)('0' + carry);\\n        return carry == 0 ? new String(sumArray, 1, sumArray.length - 1): new String(sumArray);\\n    }",
                "solutionTags": [],
                "code": "    public String addBinary(String a, String b) {\\n    \\tchar[] aArray = a.toCharArray();\\n    \\tchar[] bArray = b.toCharArray();\\n        char[] sumArray = new char[Math.max(a.length(), b.length()) + 1];\\n        int index = sumArray.length - 1, carry = 0;\\n        for(int aIndex = a.length()-1, bIndex = b.length()-1; aIndex >=0 || bIndex >= 0; aIndex--, bIndex--){\\n            int aNum = aIndex < 0 ? 0 : aArray[aIndex] - '0';\\n            int bNum = bIndex < 0 ? 0 : bArray[bIndex] - '0';\\n            int sum = aNum + bNum + carry;\\n            sumArray[index--] = (char)('0' + (sum % 2));\\n            carry = sum / 2;\\n        }\\n        sumArray[0] = (char)('0' + carry);\\n        return carry == 0 ? new String(sumArray, 1, sumArray.length - 1): new String(sumArray);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 24690,
                "title": "short-and-concise-c-solution",
                "content": "    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            if(b.size() > a.size())\\n                return addBinary(b, a);\\n            \\n            int x = 0, y = 0, carry = 0;\\n            for(int i = a.size() - 1; i >= 0; i--){\\n                int ib = b.size() - a.size() + i;\\n                y = ib >= 0 ? b[ib] - '0' : 0;\\n                x = a[i] - '0';\\n                a[i] = (x + y + carry) % 2 + '0';\\n                carry = x + y + carry >= 2 ? 1 : 0;\\n            }\\n            \\n            if(carry) a = \"1\" + a;\\n            return a;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            if(b.size() > a.size())\\n                return addBinary(b, a);\\n            \\n            int x = 0, y = 0, carry = 0;\\n            for(int i = a.size() - 1; i >= 0; i--){\\n                int ib = b.size() - a.size() + i;\\n                y = ib >= 0 ? b[ib] - '0' : 0;\\n                x = a[i] - '0';\\n                a[i] = (x + y + carry) % 2 + '0';\\n                carry = x + y + carry >= 2 ? 1 : 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 24715,
                "title": "c-4ms-very-simple-logic",
                "content": "    class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            /* make strings the same length, by padding one in front with 0s */\\n            if(a.size() > b.size()) while(a.size() > b.size()) b = \"0\" + b;\\n            else if(b.size() > a.size()) while(b.size() > a.size()) a = \"0\" + a;\\n\\n            int i = a.size()-1;\\n            string sum = \"\";\\n            int carry = 0;\\n            \\n            while(i >= 0) {\\n                if(carry == 1) {\\n                    if(a[i] == '0' && b[i] == '0') {\\n                        sum = \"1\" + sum;\\n                        carry = 0;\\n                    }\\n                    else if((a[i] == '0' && b[i] == '1') || (a[i] == '1' && b[i] == '0')) {\\n                        sum = \"0\" + sum;\\n                    }\\n                    else { /* we're adding three 1s here */\\n                        sum = \"1\" + sum;\\n                    }\\n                }\\n                else {\\n                    if(a[i] == '0' && b[i] == '0') {\\n                        sum = \"0\" + sum;\\n                    }\\n                    else if((a[i] == '0' && b[i] == '1') || (a[i] == '1' && b[i] == '0')) {\\n                        sum = \"1\" + sum;\\n                    }\\n                    else { /* we're adding two 1s here */\\n                        sum = \"0\" + sum;\\n                        carry = 1;\\n                    }\\n                }\\n                \\n                i--;\\n            }\\n            \\n            if(carry == 1) sum = \"1\" + sum;\\n            \\n            return sum;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string addBinary(string a, string b) {\\n            /* make strings the same length, by padding one in front with 0s */\\n            if(a.size() > b.size()) while(a.size() > b.size()) b = \"0\" + b;\\n            else if(b.size() > a.size()) while(b.size() > a.size()) a = \"0\" + a;\\n\\n            int i = a.size()-1;\\n            string sum = \"\";\\n            int carry = 0;\\n            \\n            while(i >= 0) {\\n                if(carry == 1) {\\n                    if(a[i] == '0' && b[i] == '0') {\\n                        sum = \"1\" + sum;\\n                        carry = 0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 24779,
                "title": "c-4ms-solution-inspired-by-hardware-full-adder-circuit",
                "content": "This solution computes the stage value (sum) and carry-out using Boolean expressions of the [full adder circuit][1] <br> The circuit for the full adder is below.\\n![Full Adder circuit][2]\\n<br>\\nThe expressions are.\\n\\n                 S     = A xor B xor C_in\\n                 C_out = A.B + C_in. (A xor B)\\n\\nThe inputs are padded to the same size to emulate a hardware-adder with inputs of the same size.\\n\\n    string addBinary(string a, string b) {\\n        // Pad to same length\\n        if (a.size()> b.size())\\n                 b.insert(b.begin(), a.size()-b.size(), '0');\\n        else\\n                 a.insert(a.begin(), b.size()-a.size(), '0');\\n        int len = a.size();\\n        bool carry_out= false, sum= false;\\n        string res(len, '0'); // all zero\\n        for (int i=len-1; i>=0 ; --i) {\\n                bool ai = a[i]-'0'== 1; \\n                bool bi = b[i]-'0'== 1;\\n                // Full adder sum = (A xor B xor C_in)\\n                sum = ai != bi != carry_out ;\\n                // Full adder C_out =  (A.B + C_in. (A xor B))\\n                carry_out =  ai && bi || (carry_out && (ai != bi)) ; \\n                if (sum) res[i] = '1';\\n        }\\n        if (carry_out)  // carry over at end\\n                res= \"1\" + res;\\n        return res;\\n    }\\n\\nNote I have used boolean xor operator (i.e. != operator) instead of bit-wise xor ( ^ operator)\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Adder_%28electronics%29#Full_adder\\n  [2]: http://www.cs.iit.edu/~cs561/cs350/ADDER/full_adder.jpg",
                "solutionTags": [
                    "C++"
                ],
                "code": "This solution computes the stage value (sum) and carry-out using Boolean expressions of the [full adder circuit][1] <br> The circuit for the full adder is below.\\n![Full Adder circuit][2]\\n<br>\\nThe expressions are.\\n\\n                 S     = A xor B xor C_in\\n                 C_out = A.B + C_in. (A xor B)\\n\\nThe inputs are padded to the same size to emulate a hardware-adder with inputs of the same size.\\n\\n    string addBinary(string a, string b) {\\n        // Pad to same length\\n        if (a.size()> b.size())\\n                 b.insert(b.begin(), a.size()-b.size(), '0');\\n        else\\n                 a.insert(a.begin(), b.size()-a.size(), '0');\\n        int len = a.size();\\n        bool carry_out= false, sum= false;\\n        string res(len, '0'); // all zero\\n        for (int i=len-1; i>=0 ; --i) {\\n                bool ai = a[i]-'0'== 1; \\n                bool bi = b[i]-'0'== 1;\\n                // Full adder sum = (A xor B xor C_in)\\n                sum = ai != bi != carry_out ;\\n                // Full adder C_out =  (A.B + C_in. (A xor B))\\n                carry_out =  ai && bi || (carry_out && (ai != bi)) ; \\n                if (sum) res[i] = '1';\\n        }\\n        if (carry_out)  // carry over at end\\n                res= \"1\" + res;\\n        return res;\\n    }\\n\\nNote I have used boolean xor operator (i.e. != operator) instead of bit-wise xor ( ^ operator)\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Adder_%28electronics%29#Full_adder\\n  [2]: http://www.cs.iit.edu/~cs561/cs350/ADDER/full_adder.jpg",
                "codeTag": "Unknown"
            },
            {
                "id": 3979776,
                "title": "using-big-integer-in-java",
                "content": "# * Using Big Integer\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a1, String b1) {\\n        BigInteger c=new BigInteger(a1,2);\\n        BigInteger d=new BigInteger(b1,2);\\n        BigInteger p=c.add(d);        \\n         String o = p.toString(2);\\n        return o;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a1, String b1) {\\n        BigInteger c=new BigInteger(a1,2);\\n        BigInteger d=new BigInteger(b1,2);\\n        BigInteger p=c.add(d);        \\n         String o = p.toString(2);\\n        return o;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332248,
                "title": "java-biginteger",
                "content": "\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        return (new BigInteger(a, 2)).add(new BigInteger(b, 2)).toString(2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186288,
                "title": "python-explained-solutions-good-to-know-one-liner-solution",
                "content": "# Solution 1 - O(N), O(N)\\n\\n# Intuition\\nUnderstand carry.\\n\\nAdding all possible 2 binary bits :\\n0 + 0 = 0, carry = 0\\n1 + 0 = 1, carry = 0\\n0 + 1 = 1 carry = 0\\n1 + 1 = 2, carry = 1\\n**-> Carry is simply the sum // 2**\\n\\n\\nTherefore only when the Addition of 1 and 1 happens we get a carry 1.\\n\\n\\n# Approach\\n1. Define carry = 0 and empty answer string \"\"\\n2. Find the one with the largest count of bits. This will help us to make the other of same length by appending zeros in the front.\\n2. Reverse both the string so we can start adding from the right most bit.\\n3. Find sum and add any previous carry\\n4. Find carry and append the summation\\n5. Repeat 4 and 5 until loop ends\\n6. If we get any carry form them addition on left most bits, add \"1\"\\n7. Revese the answer and return\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(N)$$ -> answer string\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        answer = \"\"\\n        carry = 0\\n        len_diff = abs(len(a)-len(b))\\n        if len(a) >= len(b):\\n            b = \"0\" * len_diff + b\\n        else:\\n            a = \"0\" * len_diff + a\\n\\n        for i,j in zip(reversed(a), reversed(b)):\\n            summation = int(i) + int(j) + carry\\n            \\n            carry = summation // 2\\n            answer += str(summation % 2)\\n\\n        if carry == 1:\\n            answer += \"1\"\\n        return answer[::-1]\\n            \\n        \\n```\\n\\n\\n# Solution 2 - O(N), O(1) - Python One-liner\\n(Not recommended in a technical interview; but good to know :p)\\n\\n# Intuition\\nConvert string to integer and add as usual. Return the binary converted string of the answer.\\n\\n# Approach:\\n1. `int(a,2)`: this function converts the a into the needed base `2`\\n2. `format(sum, \"b\")`: converts the integer back into binary without \"0b\"\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$ -> int() and format() -> involves arithmetics and are optimized to O(N)\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return format(int(a,2) + int(b,2), \"b\")\\n        \\n```\\n\\n[]()\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        answer = \"\"\\n        carry = 0\\n        len_diff = abs(len(a)-len(b))\\n        if len(a) >= len(b):\\n            b = \"0\" * len_diff + b\\n        else:\\n            a = \"0\" * len_diff + a\\n\\n        for i,j in zip(reversed(a), reversed(b)):\\n            summation = int(i) + int(j) + carry\\n            \\n            carry = summation // 2\\n            answer += str(summation % 2)\\n\\n        if carry == 1:\\n            answer += \"1\"\\n        return answer[::-1]\\n            \\n        \\n```\n```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        return format(int(a,2) + int(b,2), \"b\")\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1693882,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574456,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800157,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800274,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800317,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1782417,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574409,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1570139,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1565221,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1571988,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1693882,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574456,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800157,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800274,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800317,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1782417,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1574409,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1570139,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1565221,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1571988,
                "content": [
                    {
                        "username": "MeetaHaldar",
                        "content": "I am a beginner and i do not think it s an easy question."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "bolleoa",
                        "content": "[@zenfred](/zenfred) Python has no limits on the size of integers."
                    },
                    {
                        "username": "shafaitahir8",
                        "content": "agreed"
                    },
                    {
                        "username": "zenfred",
                        "content": "[@qazFatNerd](/qazFatNerd) Converting to decimal does not make the situation easier, because the largest input is 10,000 bits long, which doesn\\'t fit into any primitive integer types."
                    },
                    {
                        "username": "dhlg1995",
                        "content": "[@abhinav-23](/abhinav-23) i use this way. and i think its a stupid way. can you suggest another way to solve?. I dont know what is BigInt(javascript) (i saw it in the very first solution after I submit my code)"
                    },
                    {
                        "username": "Tulsyan_25",
                        "content": "You are absolutely right, am also not able to solve it in very first time but let me give you a hint. Simply, convert both binary number in decimal then add them after that convert that decimal number in binary again."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "As a novice, I personally think the most intuitive and easiest way is  converting to decimal first."
                    },
                    {
                        "username": "santanusen",
                        "content": "The problem has around 51% acceptance rate; so you have a point."
                    },
                    {
                        "username": "Riaad_Morshed",
                        "content": "Once you solve it, it will be easy. First make both string same length by adding leading zero to smaller string and loop over strings at the same time and check [@Abhinav Gupta](/abhinav-23) mentioned conditions. It will be easy if you solve some cases on paper."
                    },
                    {
                        "username": "abhinav-23",
                        "content": "try solving the question in the way you actually add two binary numbers in maths (that is right to left) using loop and if-else condition.\\n\\nfew conditions are:\\nwhen carry=0\\na) 1+1+carry=0 and carry=1;\\nb)1+0+carry=1 and carry=0;\\nc)0+0+carry=0 and carry=0;"
                    },
                    {
                        "username": "YaduVuuDuu",
                        "content": "The word \\'easy\\' in itself is really subjective(someday this might be easy for you but difficult to someone else). Just enjoy the process of trying to solve it!! If you do solve it, celebrate it no matter the difficulty. Good luck!!"
                    },
                    {
                        "username": "Subhashish_Panda-123",
                        "content": "**Concept of Binary Addition.**\\n\\n**Rememeber,\\n1+1=0 with carry 1\\n1+0=1 with carry 0\\n0+1=1 with carry 0\\n0+0=0 with carry 0\\nImp:1+1=1 with carry 1 if previous carry was 1.\\nThe carry gets added in next step(scanning from right to left).\\n**\\n\\n*Know the algorithm first,then write your own code~Problem solving*"
                    },
                    {
                        "username": "harshabandi09",
                        "content": "how to add carry  1 in the text step?  in for loop!\\n\\n "
                    },
                    {
                        "username": "nat1902",
                        "content": "are you in GH ?"
                    },
                    {
                        "username": "liudger",
                        "content": "0 + 0 = 0 with carry 0? shouldn\\'t that be 1 then? cuz 0 + 0 = 0 + 1 = 1?"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "1+1+1=1 with carry 1\\n**(Imp: 1+1 gives 0 with carry 1 and again we add 1 in 0 gives you 1\\nThis is case when both number are 1 and have carry 1 on it.)**\\nSo Remember,\\n1+1+1=1 with carry 1"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@Sinan6942069](/Sinan6942069)  Fact"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "I mean everyone who learned a bit of binary knows how it works, my main problem is getting that algorithm to code"
                    },
                    {
                        "username": "rinkub",
                        "content": "awesome"
                    },
                    {
                        "username": "sugarteddy",
                        "content": "easy for two days, leetcode think we need to get a life for valentines ig"
                    },
                    {
                        "username": "abhinav_singh987",
                        "content": "[@kanishk--](/kanishk--)   can relate to you buddy\\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "Sadly, people like me don\\'t have one."
                    },
                    {
                        "username": "sepac",
                        "content": "If you are trying to convert the input strings into decimals, add them, and convert the number into a string, you're going to exceed a 64-bit integer. Therefore, think of a different approach."
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "i also did same thing vro"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "Did this in python and got top 99.5% in time."
                    },
                    {
                        "username": "JordiBustos",
                        "content": "In JavaScript works with big int :p"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I was almost done with that approach but thanks :("
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "does anyone else get a runtime error at the 194th test case?\\n  `java.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 668, java.base/java.lang.Integer.parseInt\\n  at line 3, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main`"
                    },
                    {
                        "username": "cmhandan",
                        "content": "yep i did get that error\\n"
                    },
                    {
                        "username": "prathyushadagumati",
                        "content": "you can resolve this error by importing BigInteger"
                    },
                    {
                        "username": "mayank_1515",
                        "content": "195th bro... \\nbut if you count from 0 then alright..."
                    },
                    {
                        "username": "Upsite",
                        "content": "Same brothern same mann!! I also learned about using the shifting xor and method too to solve this,"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yep Bro."
                    },
                    {
                        "username": "Pathak9696",
                        "content": "yup\\n"
                    },
                    {
                        "username": "RuslanZinovyev",
                        "content": "Apparently Leetcode wants you to provide your own algorithm to calculate the binaries without reusing embedded Integer or Long methods. "
                    },
                    {
                        "username": "yabdelaziz123",
                        "content": "How there is a test case with input \"10100000100100110110010000010101111011011001101110111111111101000000101111001110\" and there is a constraint with a max length of 10^4?!!!!!"
                    },
                    {
                        "username": "spannm",
                        "content": "String length!"
                    },
                    {
                        "username": "cthulhuden",
                        "content": "[@rushabhvg](/rushabhvg) between 0 and 2^(10^4)-1, actually"
                    },
                    {
                        "username": "rushabhvg",
                        "content": "10^4 constraint means there will 10^4 binary numbers (0 or 1), not that binary number will be 10^4. It can be anything between 0 and 2^(10^5)-1"
                    },
                    {
                        "username": "varshvilas",
                        "content": "return str(bin(int(a,2)+int(b,2)))[2:]\\n"
                    },
                    {
                        "username": "_sarthakmisal",
                        "content": "Tell me if it would work "
                    },
                    {
                        "username": "paulLyu",
                        "content": "The queation really says length of a and b is kinda short. So I used integers sum up but got overflow when a and b length is pretty long. So I think question should revise a little bit. And I have to acknowledge it is not good practice to use interger sum in string problem"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/add-binary/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bit-by-Bit Computation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zenfred",
                        "content": "This problem is made Daily Coding Challenge again on Valentine\\'s Day 2023. Good omen? (1+1=10)"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "https://leetcode.com/problems/add-binary/solutions/3063782/c-easily-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "jlyric2015",
                        "content": "What's with the malloc requirement being missing form this question?"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "machinelearning.lsc",
                        "content": "return bin(int(a,2)+int(b,2))[2:]"
                    }
                ]
            },
            {
                "id": 1800587,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1910197,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1800376,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1800528,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1800683,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1574044,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1575034,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 2016873,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1950604,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1924374,
                "content": [
                    {
                        "username": "JiayingGao",
                        "content": "Bless every leetcoder to become romantic and wisdom!"
                    },
                    {
                        "username": "imran26_96",
                        "content": "In starting I thought in just few minute I solve it but few to far minute \\nstill I m struggling now :("
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Enjoy EASY marked questions, as long they last"
                    },
                    {
                        "username": "theRadFad",
                        "content": "The string lengths can be up to 10^4. That number of bits cannot be contained in a variable in any computer alive today, so you\\'ll have to work with the numbers in their string format. Without the handy \\'+\\' operator, you might have to go back to elementary school"
                    },
                    {
                        "username": "ramonivandy21",
                        "content": "me rn struggle in this case "
                    },
                    {
                        "username": "va14___",
                        "content": "How do leetcode consider the difficulty of the question ?\\nIs it done manually or some automatic method ? "
                    },
                    {
                        "username": "masterpratikyadav",
                        "content": "return(bin(int(str(a),2)+int(str(b),2))[2:])"
                    },
                    {
                        "username": "Menaka17",
                        "content": "bin_sum=int(a,2)+int(b,2)\\nbin_sum=bin(bin_sum)\\nreturn (bin_sum [2:])\\n"
                    },
                    {
                        "username": "SahilShukla26031998",
                        "content": "you don\\'t have to do it using the internal functions of Python. Leetcode checks your logical capability to think of a logic on your own and change that logic into code with basic functions/options available in all programming languages"
                    },
                    {
                        "username": "ishika_jaiswal",
                        "content": "dont think this is particularly easy"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "I lost kind of 30 minutes on this \"easy\" problem, yes I'm a programmer of four months, and I don't know any patterns and techniques for solving LeetCode problems, so I solve the problems on my own. \nHowever, I truely hope that there are programmers that will solve this problem \"easily\" like in <5 minutes for the first time."
                    },
                    {
                        "username": "natitati",
                        "content": "Quite fun to do in C"
                    }
                ]
            },
            {
                "id": 1847074,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1801289,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1801215,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1800935,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1800086,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1800019,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1573637,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1572055,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 1576277,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 2075604,
                "content": [
                    {
                        "username": "gupta_arpita",
                        "content": "Can someone figure out what is wrong here...debug logs are attached : \\n`#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main() {\\n    string a = \"1010\";\\n    string b = \"1011\";\\n         int sizeOfA = a.size();\\n        int sizeOfB = b.size();\\n        string sum = \"\";\\n        int carry = 0;\\n        int smaller = sizeOfA <= sizeOfB ? sizeOfA : sizeOfB;\\n        for (int i = smaller-1; i>=0; i--)\\n        {\\n            cout << \"\\\\na[i] : \" << a[i] << \"\\\\n b[i] : \" << b[i] ;\\n            if(a[i] ==0 && b[i] ==0)\\n            {\\n                if (carry ==1 )\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 0;\\n                    cout <<\"\\\\n 1.  sum : \" << sum;    \\n                    \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    cout <<\"\\\\n 2.  sum : \" << sum; \\n                }\\n            }\\n            else if ((a[i] ==0 && b[i] ==1) || (a[i] ==1 && b[i] ==0))\\n            {\\n                if (carry ==1)\\n                {\\n                    sum = \"0\"+sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 3.  sum : \" << sum; \\n                }\\n                else{\\n                    sum = \"1\" + sum;\\n                    cout <<\"\\\\n 4.  sum : \" << sum; \\n                }\\n            }\\n            else \\n            {\\n                if (carry == 1)\\n                {\\n                    sum = \"1\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 5.  sum : \" << sum; \\n                }\\n                else\\n                {\\n                    sum = \"0\" + sum;\\n                    carry = 1;\\n                    cout <<\"\\\\n 6.  sum : \" << sum; \\n                }\\n                  \\n            }              \\n\\n        }\\n        if (smaller == sizeOfA)\\n        {\\n            for (int i=sizeOfB-smaller-1;i>=0;i--)\\n            {\\n                if(b[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 7.  sum : \" << sum; \\n                    }\\n                    else \\n                    {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 8.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 9.  sum : \" << sum; \\n                    }\\n                    else{ \\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 10.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n        else \\n        {\\n            for (int i=sizeOfA-smaller-1;i>=0;i--)\\n            {\\n                if(a[i] ==0)\\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"1\"+sum;\\n                        carry = 0;\\n                        cout <<\"\\\\n 11.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"0\"+sum;\\n                        cout <<\"\\\\n 12.  sum : \" << sum; \\n                    }\\n                }\\n                else \\n                {\\n                    if(carry ==1)\\n                    {\\n                        sum = \"0\"+sum;\\n                        carry = 1;\\n                        cout <<\"\\\\n 13.  sum : \" << sum; \\n                    }\\n                    else {\\n                        sum = \"1\"+sum;\\n                        cout <<\"\\\\n 14.  sum : \" << sum; \\n                    }\\n                }\\n                    \\n            }\\n        }\\n\\n\\n        if (carry ==1)\\n        {\\n            sum = \"1\" + sum;\\n            cout <<\"\\\\n 15.  sum : \" << sum; \\n        }\\n\\n        cout <<\"\\\\nfinal sum : \" << sum;    \\n\\treturn 0;\\n}\\n\\n\\n\\n\\nOP : \\n\\n\\na[i] : 0\\n b[i] : 1\\n 6.  sum : 0\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 10\\na[i] : 0\\n b[i] : 0\\n 5.  sum : 110\\na[i] : 1\\n b[i] : 1\\n 5.  sum : 1110\\n 15.  sum : 11110\\nfinal sum : 11110"
                    },
                    {
                        "username": "shuvo_922",
                        "content": "Can we solve this question by using following approach???\n\n \n\n`public class Solution {\n\n    public String addBinary(String a, String b) {\n\n        int decimal_a=Integer.parseInt(a,2);\n\n        int decimal_b=Integer.parseInt(b,2);\n\n        int add=decimal_a + decimal_b;\n\n        return Integer.toBinaryString(add);\n\n    }\n\n}`\n\n"
                    },
                    {
                        "username": "Upsite",
                        "content": "That\\'s one way to do it I did it using a shifting method but, it seems to be too big\\n"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Not possible for Big string greater than integer data type"
                    },
                    {
                        "username": "wesamnabeel99",
                        "content": "hint: try to use Boolean algebra to manipulate the bits, it\\'ll be easy."
                    },
                    {
                        "username": "theaksaa",
                        "content": "perfect gift for valentine\\'s day, thank you leetcode <3"
                    },
                    {
                        "username": "luanct",
                        "content": "2 easy problems consecutive. Not surprised at all if they set 3 hard problems consecutive in the next 3 days lol"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Two easies in a row? Something is not right here..."
                    },
                    {
                        "username": "EmreSF",
                        "content": "![image](https://assets.leetcode.com/users/emresf/image_1587246948.png)\\n\\n"
                    },
                    {
                        "username": "ghayrat_samiev",
                        "content": "people come here to check the discussion, why would you share your solution here"
                    },
                    {
                        "username": "johnopj",
                        "content": "I get runtime error in your first line. "
                    },
                    {
                        "username": "jchatterjee",
                        "content": "That is incredible!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/add-binary/solutions/2218807/eat-sleep-code-repeat-0-n-optimized/"
                    },
                    {
                        "username": "Liu_Guangyang",
                        "content": "return bin(int(a,2)+int(b,2))[2:]    "
                    },
                    {
                        "username": "diegohernandez6661",
                        "content": "\"\"\"\\nreturn str(bin(int(a,2)+int(b,2))[2:])\\n\"\"\""
                    },
                    {
                        "username": "BhavaniMedchal",
                        "content": "explain this problem"
                    }
                ]
            },
            {
                "id": 2074249,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2068623,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2067698,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2065679,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2063022,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2030029,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 2026211,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1998802,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1994963,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1988403,
                "content": [
                    {
                        "username": "kelvin2602",
                        "content": "anyone here get Time limit Exceeded\nI try not to use Integer. toBinaryString()\nSo I declare the algorithm by my own way but finnaly I receive Time limit exceeded ?\nor is it because the time complexity is too hight ?\n"
                    },
                    {
                        "username": "Joseph_TL",
                        "content": "Is it just me or are the numbers reversed?"
                    },
                    {
                        "username": "Engg_Ayush",
                        "content": "While solving this question it took some time ,\\nbut one thing i want to suggest that don\\'t convert it to int and just try to solve by making logics ,like if (1+1 is there than carry will be one and in o/p string you have to insert 0),\\n\\nhappy coding."
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "This should not be an easy question because of tricky implementation .\\nAtleast should be marked as medium.\\n"
                    },
                    {
                        "username": "Rollinghappy",
                        "content": "i got the answer in C. but the result is in \"char finalArray[ ]\" and just simply \"return finalArray\" is telling me the output is null. when i print the array the answer is correct. what should i do in the return statement?"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "make sure youre finalArray is mallocated\n```\n\n    int lenA = strlen(a);\n    int lenB = strlen(b);\n    int maxLength = lenA > lenB ? lenA : lenB;\n    char* finalArray = (char*)malloc((maxLength + 2) * sizeof(char));\n    //make sure you add +2 for potential carry and null terminator\n\n\n```\n\nafter your preferred logic make sure that finalChar is null terminated\nresult[whateveryourlastindexis] = '\\0';"
                    },
                    {
                        "username": "shaw-code",
                        "content": "Whoever categorized this question to \\'Easy\\' must be a genius that he/she found this question a walk in the park. This question should be placed at \\'Medium\\'. Idk if we can somehow change the category of a question on this platform."
                    },
                    {
                        "username": "500kbaby",
                        "content": "seems to work on the any other c++ ide but fails in leetcode. it fails with values when a=1 and b=111. may not be the best solution out there but it works. i think there is a problem with leetcode backend \\n `      \\n        reverse(a.begin(), a.end());\\n        reverse(b.begin(), b.end());\\n\\n        while (a[at] != \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            if(a[at]==b[at]){\\n                if (carry==0){\\n                    ans += \\'0\\';\\n                    if(a[at]==\\'1\\') carry++;  \\n                }else{\\n                    if (a[at]==\\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else{\\n                        ans += \\'1\\';\\n                    }\\n                }\\n            }else {\\n                if (carry==0)\\n                    ans += \\'1\\';\\n                else{\\n                    ans += \\'0\\'; \\n                }\\n            }\\n            at++;\\n        }\\n        if (a[at] == \\'\\\\0\\' && b[at] != \\'\\\\0\\'){\\n            while (b[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += b[at];\\n                else {\\n                    if (b[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (b[at] == \\'\\\\0\\' && a[at] != \\'\\\\0\\'){\\n            while (a[at] != \\'\\\\0\\'){\\n                if (carry == 0)\\n                    ans += a[at];\\n                else {\\n                    if (a[at] == \\'0\\'){\\n                        ans += \\'1\\';\\n                        carry--;\\n                    }else\\n                        ans += \\'0\\';\\n                }\\n                at++;\\n            }\\n        }\\n        if (carry != 0){\\n            ans += \\'1\\';\\n        }\\n        reverse(ans.begin(), ans.end());`"
                    },
                    {
                        "username": "namjoshisp",
                        "content": "Just implement Full adder circuit"
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "The challenge offers an opportunity to understand and implement binary addition, which is a fundamental concept in computer science. I love binary addition."
                    },
                    {
                        "username": "mafishere",
                        "content": "Why is this approach not working?\nIn this approach, I first calculate the decimal sum from the two given strings.\nThen I convert the decimal sum to binary.\n\nIt is failing on this test case:\n```\na =\n\"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\"\nb =\n\"110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011\"\n\nOutput\n\"11101000101011001000011011000001100011110011010010011000000000\"\nExpected\n\"110111101100010011000101110110100000011101000101011001000011011000001100011110011010010011000000000\"\n```\n\n```cpp\nstring addBinary(string a, string b)\n    {\nstring addBinary(string a, string b)\n{\n    unsigned long long int sum = 0, weight = 1;\n\n    for (int i = a.length() - 1; i >= 0; i--)\n    {\n        if (a[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    weight = 1;\n    for (int i = b.length() - 1; i >= 0; i--)\n    {\n        if (b[i] == '1')\n            sum += weight;\n        weight *= 2;\n    }\n\n    if (sum == 0)\n        return \"0\";\n\n    string c = \"\";\n    while (sum > 0)\n    {\n        int x = sum % 2;\n        sum = sum / 2;\n\n        if (x == 1)\n            c += '1';\n        else\n            c += '0';\n    }\n\n    // reversing\n    for (int i = 0; i < c.length() / 2; i++)\n    {\n        char temp = c[i];\n        c[i] = c[c.length() - 1 - i];\n        c[c.length() - 1 - i] = temp;\n    }\n\n    return c;\n}\n```"
                    },
                    {
                        "username": "ahamedibrahim2002",
                        "content": "same here! , did you find why it\\'s failing? "
                    }
                ]
            },
            {
                "id": 1968682,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1950846,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1913583,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1912528,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1900010,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1897924,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1870908,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1847430,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1840271,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1827585,
                "content": [
                    {
                        "username": "wilderfield",
                        "content": "Is it possible to do divide and conquer? Or no, because the nature of carry propagation means you have to start from the LSB and go serially?"
                    },
                    {
                        "username": "eduard92",
                        "content": "I hate this problem "
                    },
                    {
                        "username": "nathan-riggs",
                        "content": "I\\'m not sure someone who is mostly comfortable doing \"easy\" problems will have an easy time figuring out binary addition. It\\'s easy in itself, but I would dread something like this if I were just learning. "
                    },
                    {
                        "username": "erShivuu",
                        "content": "ava.lang.NumberFormatException: For input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\" under radix 2\\n  at line 67, java.base/java.lang.NumberFormatException.forInputString\\n  at line 711, java.base/java.lang.Long.parseLong\\n  at line 4, Solution.addBinary\\n  at line 54, __DriverSolution__.__helper__\\n  at line 87, __Driver__.main\\nI am getting this error"
                    },
                    {
                        "username": "ankush920",
                        "content": "Must Watch || Power of Ternary operator || small || simple || 0(N) || easy code :)\\nankush920\\n0\\nin a few seconds\\nC++\\nIntuition\\nbits carry digit carry\\n0 + 0 + 0 = 0 0\\n0 + 0 + 1 = 1 0\\n1 + 0 + 0 = 1 0\\n0 + 1 + 0 = 1 0\\n1 + 0 + 1 = 0 1\\n0 + 1 + 1 = 0 1\\n1 + 1 + 0 = 0 0\\n1 + 1 + 1 = 1 1\\n\\nApproach\\njust implemented the upper table and store result in result string :)\\n\\nComplexity\\nTime complexity:\\n0(N) --> ( max (length of(a,b)))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\n //upvote it vro :)\\n class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n    string res = \"\";\\n    \\n    int i = a.size()-1 , j = b.size()-1 ,carry = 0 ;\\n    \\n\\n   while( i>=0 && j>= 0 )\\n   {\\n      int val1 = a[i] -\\'0\\';\\n      int val2 = b[j] -\\'0\\';\\n      int ans = val1 + val2 + carry;     \\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;     \\n      i--; j--;\\n   }\\n\\n    while( i>=0)\\n    {\\n          int val1 = a[i] -\\'0\\';\\n           int ans = val1 +  carry;\\n              ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;  \\n     \\n           i--; \\n            }\\n   \\n   while( j>=0)\\n   {\\n              int val2 = b[j] - \\'0\\';\\n             int ans = val2 +  carry;\\n       ans%2==0  ? res =\"0\"+ res : res = \"1\"+ res;\\n        carry = ans>1  ? 1 : 0;   \\n              j--;\\n   }\\n\\n   if(carry) { res = \"1\" + res ; }\\n\\nreturn res ;\\n    }\\n};"
                    },
                    {
                        "username": "gabbar0101",
                        "content": " //I really think that this is correct code but idk somehow due to \\n runtime error or\\n        other reason it is not working\\nPLEASE HELP \\n `your inline code...\\nint l1 = a.length() - 1;\\n        int l2 = b.length() - 1;\\n        int sum = 0, carry = 0;\\n        string str;\\n\\n        while(l1 >= 0 || l2 >= 0)\\n        {\\n            sum = (a[l1] - \\'0\\') + (b[l2] - \\'0\\') + carry;\\n\\n            str += to_string(sum % 2);\\n            carry = (sum / 2);\\n\\n            l1--;\\n            l2--;\\n        }\\n\\n        while(l1 >= 0)\\n        {\\n            str += to_string(a[l1]);\\n            l1--;\\n        }\\n\\n        while(l2 >= 0)\\n        {\\n            str += to_string(b[l2]);\\n            l2--;\\n        }\\n\\n        if(carry) str += to_string(carry);\\n\\n        reverse(str.begin(), str.end());\\n        \\n        return str;\\nyour inline code...`"
                    },
                    {
                        "username": "Lokeshram12",
                        "content": "\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n    long  number0 = Long.parseLong(a, 2);\\n    long  number1 = Long.parseLong(b, 2);\\n\\n    long  sum = number0 + number1;\\n    int value=(int)sum;\\n\\n    return Integer.toBinaryString(value); //returns the answer as a binary value;\\n//sum of the two binary numbers will be small enough to fit within an integer (i.e., a 32-bit signed integer). If the sum is too large, it will overflow and the result will be incorrect.\\n    }\\n}\\n\\n\\n\\n//Alternative solution is\\n\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger num1 = new BigInteger(a, 2);\\n        BigInteger num2 = new BigInteger(b, 2);\\n\\n        BigInteger sum = num1.add(num2);\\n\\n        return sum.toString(2);// works for all cases\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "Hi guys how to handle this : input string: \"10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101\""
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Wow, I busted my brain implement it bitwise with XOR and AND and most of the solutions convert the digits to decimal and then use modulus or division by 2"
                    },
                    {
                        "username": "MenaiAla",
                        "content": "## How to parse large number in javascript?\\n\\n### Code\\n\\n```javascript\\nvar addBinary = function (a, b) {\\n\\treturn (parseInt(a, 2) + parseInt(b, 2)).toString(2);\\n};\\n```\\nMy solution works only small integers howvever it does not work with big integers? Any recommendation?"
                    }
                ]
            },
            {
                "id": 1814336,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1808400,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1802479,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1802298,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1801941,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1801149,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800911,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800889,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800873,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800598,
                "content": [
                    {
                        "username": "ShivanshuSamdhiya",
                        "content": "how to sum two binary number in a string"
                    },
                    {
                        "username": "aishwaryamoghekar",
                        "content": "what is missing??\\n\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string res;\\n        int i=a.size()-1, j= b.size()-1;\\n        int sum, carry = 0;\\n        while(i >= 0 || j >= 0){\\n            sum=carry;\\n            if(i>0) sum+=a[i]-\\'0\\';\\n            if(j>0) sum+=b[j]-\\'0\\';\\n            res += to_string(sum % 2);\\n            carry = sum/2 ;\\n            i--,j--;\\n        }\\n        if(carry != 0) res += \\'1\\';\\n        reverse(res.begin(),res.end());\\n        return res;\\n\\n    }\\n};"
                    },
                    {
                        "username": "raulgarcia",
                        "content": "What are the possible uses of this in real life coding problems? I mean... It's good to know more but, is this somehow going to be useful someday?"
                    },
                    {
                        "username": "space_invader",
                        "content": "The same as 989"
                    },
                    {
                        "username": "optionngoma",
                        "content": "Is using the wrapper class advisable?"
                    },
                    {
                        "username": "ygdev",
                        "content": "this one broke me"
                    },
                    {
                        "username": "jotarooraora94",
                        "content": "i am trying to use a for loop that checks the string backwards with if( a[i] == \\'1\\' && b[i] == \\'1\\' && carry == \\'0\\') and puts  sum[i] = \\'1\\' and carry = 1 etc. depending on binary addition concept.\\n\\ni realloc a to b or b to a depending on whats longer, put a 0 on the end of the shorter string, malloc sum with +1 space for extra carry and put at the start of sum a 0.\\n\\nat the and i used if() again for checking if carry is still 1 at the end so it can put a 1 on the start of sum or leave the 0 and return sum. \\n\\nbut all i get at the end is (null) as output.\\ni would post my code but i guess solutions or even false solutions shouldnt be posted in discussion tab."
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int aLen=a.size();\\n        int bLen=b.size();\\n        int i=0;\\n        int carry=0;\\n        string ans=\"\";\\n        while(i<aLen||i<bLen||carry!=0){\\n            int x=0;\\n            if(i<aLen && a[aLen-i-1]==\\'1\\'){\\n                x=1;\\n            }\\n            int y=0;\\n            if(i<bLen && b[bLen-i-1]==\\'1\\'){\\n                y=1;\\n            }\\n            ans=to_string((x+y+carry)%2)+ans;\\n            carry=(x+y+carry)/2;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sakega",
                        "content": "Valentines Day gift for the coding lovers :) "
                    },
                    {
                        "username": "VladQweqw",
                        "content": "can i be your 1 and you be my 0 ?"
                    }
                ]
            },
            {
                "id": 1800576,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800562,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800529,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800515,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800372,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800347,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800324,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800321,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800298,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800280,
                "content": [
                    {
                        "username": "rrdlpl",
                        "content": "As follow up: don't convert the strings to numbers."
                    },
                    {
                        "username": "Lokii1811",
                        "content": "my code is 99 lines :),and the question is marked easy\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        string ans = \"\";\\n        int p = a.length()-1;\\n        int q = b.length()-1;\\n        int rem = 0;\\n        while(p>=0 and q>=0){\\n            if(a[p] == \\'0\\' and b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else if(a[p] == \\'1\\' and b[q] == \\'1\\'){\\n                if(rem == 0){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                    rem = 1;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 0){\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                    q--;\\n                }\\n            }\\n        }\\n        while(p>=0){\\n            if(a[p] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    p--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    p--;\\n                }\\n            }\\n        }\\n        while(q>=0){\\n            if(b[q] == \\'0\\'){\\n                if(rem == 1){\\n                    ans = \\'1\\'+ans;\\n                    rem = 0;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n            }\\n            else{\\n                if(rem == 1){\\n                    ans = \\'0\\'+ans;\\n                    q--;\\n                }\\n                else{\\n                    ans = \\'1\\'+ans;\\n                    q--;\\n                }\\n            }\\n        }\\n        if(rem == 1){\\n            ans = \\'1\\'+ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "it\\'s a little bit similar to merge sort, same idea."
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "```\\nclass Solution:\\n    def addBinary(self, a: str, b: str) -> str:\\n        def BinToNum(s):\\n            res = 0\\n            t = s[::-1]\\n            for i in range(len(s)):\\n                res += (2**i) * int(t[i])\\n            return res\\n\\n        def NumToBin(val): \\n            return bin(val)\\n\\n        a1 , b1 = BinToNum(a) , BinToNum(b)\\n        return NumToBin(a1+b1)[2:]\\n\\n\\n   ```"
                    },
                    {
                        "username": "sh171",
                        "content": "class Solution {\\n    public String addBinary(String a, String b) {\\n        return Integer.toBinaryString(Integer.parseInt(a,2)+Integer.parseInt(b,2));\\n    }\\n}\\nWhy is this not working??"
                    },
                    {
                        "username": "utkarsh_30",
                        "content": "how do you convert a string to a int?"
                    },
                    {
                        "username": "jasmeet_2001",
                        "content": "use stoi function if you want to"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "You don\\'t need to convert to int. Just implement summation digit-by-digit"
                    },
                    {
                        "username": "yomaChoma",
                        "content": "This question made me feel extremely stupid"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "**greedy method**\nI was able to find approaches to this problem through simple binary addition\njust wanted to ask someone if this problem can be solved using greedy method by thinking of the different positions in the number as denominations regardless of the fact that it seems to be a round about approach compared to simple binary addition.  "
                    },
                    {
                        "username": "rohitramteke",
                        "content": "This is an interesting problem.....\\n"
                    },
                    {
                        "username": "anuragtk2002",
                        "content": "please find error in my code JAVA\\n\\n\\n      int decimal=Integer.parseInt(a,2); \\n         int decimal2=Integer.parseInt(b,2);\\n        int sum=decimal+decimal2;\\n        return Integer.toBinaryString(sum); "
                    },
                    {
                        "username": "yash_raileet",
                        "content": "import java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger dec1 = new BigInteger(a,2);\\n        BigInteger dec2 = new BigInteger(b,2);\\n        BigInteger add = dec1.add(dec2);\\n        return add.toString(2);\\n    }\\n}\\n\\nuse BigInteger class. :)"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "it exceeds 64 bit integer \\n"
                    },
                    {
                        "username": "aryamangodara",
                        "content": "leetcode going easy on us"
                    }
                ]
            },
            {
                "id": 1800102,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800055,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800027,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800022,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800021,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1800018,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1785662,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1775331,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1740096,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            },
            {
                "id": 1739448,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "I really don\\'t enjoy such a easy question, it this week for easy one??\\n"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/xor4.png)\n![](https://leetcode.com/problems/add-binary/solutions/414426/Figures/67/carry2.png)"
                    },
                    {
                        "username": "MasamuneDate",
                        "content": "Yes another easy morning. you can use basic math - binary and carry for approach method in this problem"
                    },
                    {
                        "username": "chees-e",
                        "content": "Leetcode do be giving us a nice little break after series of hard and hard in diguise dailies..."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "if you don't know how to manipulate strings to add the two numbers , try to convert each one to integer by the power of 2(10010 =1*2^4 +0*2^3 +0*2^2 +1*2^1 + 0*2^0) then add them then convert to binary by dividing over 2 (35/2=17 r=1, 17/2=8 r=1, 8/2=4 r=0,4/2=2 r=0, 2/2=1 r=0,1/2=0 r=1   .... 100011)"
                    },
                    {
                        "username": "Dhruv_Khanna123",
                        "content": "this will go out of range of integer or long(runtime error)"
                    },
                    {
                        "username": "scor32k",
                        "content": "again nice one lc"
                    },
                    {
                        "username": "brightkut",
                        "content": " ````\\nimport (\\n    \"math\"\\n    \"strconv\"\\n)\\n\\nfunc addBinary(a string, b string) string {\\n    if a == \"0\" && b == \"0\"{\\n        return \"0\"\\n    }\\n\\n    total:= convertBinaryToInt(a)+ convertBinaryToInt(b)\\n\\n    \\n    return convertIntToBinary(total)\\n}\\n\\nfunc convertBinaryToInt(a string) int {\\n\\tvar c int = 0\\n\\tvar res int\\n\\n\\tfor i := len(a) - 1; 0 <= i; i-- {\\n\\t\\taIntValue, _ := strconv.Atoi(string(a[i]))\\n\\t\\tres += int(aIntValue) * int(math.Pow(float64(2), float64(c)))\\n\\t\\tc++\\n\\t}\\n\\treturn res\\n}\\n\\nfunc convertIntToBinary(n int) string {\\n\\tvar res string\\n\\tdivide := n\\n\\n\\tfor divide != 1 {\\n\\t\\tres = strconv.Itoa(divide%2) + res\\n\\t\\tdivide = divide / 2\\n\\t}\\n\\n\\treturn \"1\" + res\\n}\\n\\n````\\n\\n\\nThis is my code and I suspected why this code has time limit exceed. "
                    },
                    {
                        "username": "krishnadev7",
                        "content": "`class Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int alen = a.length();\\n        int blen = b.length();\\n        int i = 0, carry = 0;\\n        string ans = \"\";\\n        while( i<alen || i<blen || carry!=\\'0\\'){\\n            int x = 0;\\n            if(i<alen && a[alen-i-1] == \\'1\\'){\\n                x = 1;\\n            }\\n            int y = 0;\\n            if(i<blen && b[blen-i-1] == \\'1\\'){\\n                y = 1;\\n            }\\n            ans = to_string((x+y+carry)%2) + ans;\\n            carry = (x+y+carry)/2;\\n            i+=1;\\n        }\\n        return ans;\\n    }\\n};`\\nwhy  i getting memory limit exceeded"
                    },
                    {
                        "username": "ec1912",
                        "content": " class Solution {\npublic:\n    string addBinary(string a, string b) {\n        string ans = \"\"; \n        int len1 = a.size() , len2 = b.size() , i,j, ds=0;\n        i = len1 - 1;\n        j = len2 - 1;\n        while(i>=0 || j>=0 || ds==1)\n        {\n            ds = ds + ((i >= 0) ? a[i] - '0' : 0);\n            ds = ds + ((j >= 0) ? b[j] - '0' : 0);\n            ans = char(ds % 2 + '0') + ans;\n            ds = ds/2;\n            i--;\n            j--;\n        }\n        return ans;\n    }\n};\n\n\nHere is the solution of such code , please let me update if there is any other compact code with heigh beat rate. "
                    },
                    {
                        "username": "13zidane",
                        "content": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\n\nchar * addBinary(char * a, char * b)\n{\n    int binarybits[]={128,64,32,16,8,4,2,1};\n    int sum = 0;\n    int acount = 0;\n    for (int i=strlen(a)-1;i>=0;i--)\n    {\n        if (a[i] == '1')\n        {\n            sum += pow(2,acount);\n            acount++;\n        }\n        else\n        {\n            acount++;\n        }\n        \n    }\n    int bcount = 0;\n    for (int j=strlen(b)-1;j>=0;j--)\n    {\n        if (b[j] == '1')\n        {\n            sum += pow(2,bcount);\n            bcount++;\n        }\n        else\n        {\n            bcount++;\n        }\n        \n    }\n    int start = 0;\n    for (int k=0;k<8;k++)\n    {\n        if (binarybits[k]<=sum)\n        {\n            start = k;\n            break;\n        }\n    }\n    char *ans = malloc(sizeof(char)*(3));\n    int count = 0;\n    if (sum == 0)\n    {\n        ans[0] = '0';\n        return ans;\n    }\n    for (int L=start;L<8;L++)\n    {\n        if (binarybits[L] <= sum)\n        {\n            sum -= binarybits[L];\n            ans[count++] = '1';\n\n        }\n        else\n        {\n            ans[count++] = '0';\n        }\n    }\n    return ans;\n}\n\nWhy does this result in heap buffer overflow even though it works on the compiler?\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Two Sum II - Input Array Is Sorted",
        "question_content": "<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong><em>sorted in non-decreasing order</em></strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 &lt;= index<sub>1</sub> &lt; index<sub>2</sub> &lt;&nbsp;numbers.length</code>.</p>\n\n<p>Return<em> the indices of the two numbers, </em><code>index<sub>1</sub></code><em> and </em><code>index<sub>2</sub></code><em>, <strong>added by one</strong> as an integer array </em><code>[index<sub>1</sub>, index<sub>2</sub>]</code><em> of length 2.</em></p>\n\n<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>\n\n<p>Your solution must use only constant extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,<u>7</u>,11,15], target = 9\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>2</u>,3,<u>4</u>], target = 6\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> The sum of 2 and 4 is 6. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> numbers = [<u>-1</u>,<u>0</u>], target = -1\n<strong>Output:</strong> [1,2]\n<strong>Explanation:</strong> The sum of -1 and 0 is -1. Therefore index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= numbers.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n\t<li><code>numbers</code> is sorted in <strong>non-decreasing order</strong>.</li>\n\t<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n\t<li>The tests are generated such that there is <strong>exactly one solution</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 51249,
                "title": "python-different-solutions-two-pointer-dictionary-binary-search",
                "content": "        \\n    # two-pointer\\n    def twoSum1(self, numbers, target):\\n        l, r = 0, len(numbers)-1\\n        while l < r:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n     \\n    # dictionary           \\n    def twoSum2(self, numbers, target):\\n        dic = {}\\n        for i, num in enumerate(numbers):\\n            if target-num in dic:\\n                return [dic[target-num]+1, i+1]\\n            dic[num] = i\\n     \\n    # binary search        \\n    def twoSum(self, numbers, target):\\n        for i in xrange(len(numbers)):\\n            l, r = i+1, len(numbers)-1\\n            tmp = target - numbers[i]\\n            while l <= r:\\n                mid = l + (r-l)//2\\n                if numbers[mid] == tmp:\\n                    return [i+1, mid+1]\\n                elif numbers[mid] < tmp:\\n                    l = mid+1\\n                else:\\n                    r = mid-1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "        \\n    # two-pointer\\n    def twoSum1(self, numbers, target):\\n        l, r = 0, len(numbers)-1\\n        while l < r:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n     \\n    # dictionary           \\n    def twoSum2(self, numbers, target):\\n        dic = {}\\n        for i, num in enumerate(numbers):\\n            if target-num in dic:\\n                return [dic[target-num]+1, i+1]\\n            dic[num] = i\\n     \\n    # binary search        \\n    def twoSum(self, numbers, target):\\n        for i in xrange(len(numbers)):\\n            l, r = i+1, len(numbers)-1\\n            tmp = target - numbers[i]\\n            while l <= r:\\n                mid = l + (r-l)//2\\n                if numbers[mid] == tmp:\\n                    return [i+1, mid+1]\\n                elif numbers[mid] < tmp:\\n                    l = mid+1\\n                else:\\n                    r = mid-1",
                "codeTag": "Python3"
            },
            {
                "id": 51239,
                "title": "share-my-java-ac-solution",
                "content": "Without HashMap, just have two pointers, A points to index 0, B points to index len - 1, shrink the scope based on the value and target comparison.\\n\\n    public int[] twoSum(int[] num, int target) {\\n        int[] indice = new int[2];\\n        if (num == null || num.length < 2) return indice;\\n        int left = 0, right = num.length - 1;\\n        while (left < right) {\\n            int v = num[left] + num[right];\\n            if (v == target) {\\n                indice[0] = left + 1;\\n                indice[1] = right + 1;\\n                break;\\n            } else if (v > target) {\\n                right --;\\n            } else {\\n                left ++;\\n            }\\n        }\\n        return indice;\\n    }",
                "solutionTags": [],
                "code": "Without HashMap, just have two pointers, A points to index 0, B points to index len - 1, shrink the scope based on the value and target comparison.\\n\\n    public int[] twoSum(int[] num, int target) {\\n        int[] indice = new int[2];\\n        if (num == null || num.length < 2) return indice;\\n        int left = 0, right = num.length - 1;\\n        while (left < right) {\\n            int v = num[left] + num[right];\\n            if (v == target) {\\n                indice[0] = left + 1;\\n                indice[1] = right + 1;\\n                break;\\n            } else if (v > target) {\\n                right --;\\n            } else {\\n                left ++;\\n            }\\n        }\\n        return indice;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2128501,
                "title": "two-pointers-visual-explanation-java",
                "content": "### Logic:\\nThe approach to this question differs to that of the classic Two Sum problem in that we have some direction with how we want to search for our target.\\n\\nSince the array is sorted, we can make some general observations:\\n* Smaller sums would come from the left half of the array\\n* Larger sums would come from the right half of the array\\n\\nTherefore, using two pointers starting at the end points of the array, we can choose to increase or decrease our current sum however we like. Pay attention to the example below:\\n\\n![image](https://assets.leetcode.com/users/images/d0fa6c55-4e51-4c81-9fca-9a98df8fe949_1654734113.3015687.jpeg)\\n\\nThe basic idea is that:\\n> If our current sum is too small, move closer to the right.\\n> If our current sum is too large, move closer to the left.\\n\\nThat\\'s really all there is to it! Since the array is sorted and we\\'re guarranteed that there exists an answer, we have everything we need to start coding :)\\n___\\n### How would I come up with this during an interview?\\nIn an interview, whenever you\\'re given a question where the input array is sorted, here are some super useful things to consider:\\n* Binary Search\\n* Two (or three) pointers\\n* A sliding window \\n* Traversing from the right\\n\\nMake sure to write down a couple examples and try experimenting with these approaches. Even understanding that these approaches may aid in finding an answer with a sorted array, you\\'re showing your interviewer that you have a good understanding of the array datastructure. Be mindful of negative values and duplicates as you\\'re experimenting! \\n\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n\\tint l = 0, r = nums.length - 1;\\n\\t\\n\\twhile (nums[l] + nums[r] != target) {\\n\\t\\tif (nums[l] + nums[r] < target) l++;\\n\\t\\telse r--;\\n\\t}\\n\\n\\treturn new int[] {l+1, r+1};\\n}\\n```\\n**Time Complexity:** `O(n)` \\n**Space Complexity:** `O(1)`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[] twoSum(int[] nums, int target) {\\n\\tint l = 0, r = nums.length - 1;\\n\\t\\n\\twhile (nums[l] + nums[r] != target) {\\n\\t\\tif (nums[l] + nums[r] < target) l++;\\n\\t\\telse r--;\\n\\t}\\n\\n\\treturn new int[] {l+1, r+1};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51253,
                "title": "a-simple-o-n-solution",
                "content": "We only have to shrink the range to find the pair:\\n\\nclass Solution {\\n\\npublic:\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int lo=0, hi=numbers.size()-1;\\n        while (numbers[lo]+numbers[hi]!=target){\\n            if (numbers[lo]+numbers[hi]<target){\\n                lo++;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        return vector<int>({lo+1,hi+1});\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int lo=0, hi=numbers.size()-1;\\n        while (numbers[lo]+numbers[hi]!=target){\\n            if (numbers[lo]+numbers[hi]<target){\\n                lo++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 51303,
                "title": "c-solution-simple-and-sweet",
                "content": "\\n\\t vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int l = 0;\\n        int r = numbers.size() -1;\\n       \\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target){\\n               \\n                return {l+1,r+1};;\\n            }\\n            else if(numbers[l] + numbers[r] > target){\\n                r--;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n\\t\\treturn {};\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\t vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int l = 0;\\n        int r = numbers.size() -1;\\n       \\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target){\\n               \\n                return {l+1,r+1};;\\n            }\\n            else if(numbers[l] + numbers[r] > target){\\n                r--;\\n            }\\n            else{\\n                l++;\\n            }\\n        }\\n\\t\\treturn {};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51282,
                "title": "simple-8-line-java-solution-with-explanation-o-n",
                "content": "    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length - 1;\\n        while (numbers[l] + numbers[r] != target) {\\n            if (numbers[l] + numbers[r] > target) r--;\\n            else l++;\\n        }\\n        return new int[]{l + 1, r + 1};\\n    }\\n\\nwe use `l` and `r` to denote the first index and second index respectively. \\n\\nWhen the sum is:<br>\\n1. smaller than the target:<br>\\n    we move `l` to the right by 1. we can't make `r` smaller because that's gonna make the sum even smaller.<br>\\n2. bigger than target:<br>\\n    move `r` to the left by 1. we can't make `l` bigger because that's gonna make the sum even bigger.<br>\\n3. equal to the target:<br>\\n    we found the answer and return.\\n\\nSince the question said there is EXACTLY one solution and didn't provide any info about when there is no valid answer, so we can always assume there is one and only one answer, which means `l` and `r` never across each other.\\n\\nAnother thing to notice is that this array is sorted.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length - 1;\\n        while (numbers[l] + numbers[r] != target) {\\n            if (numbers[l] + numbers[r] > target) r--;\\n            else l++;\\n        }\\n        return new int[]{l + 1, r + 1};\\n    }\\n\\nwe use `l` and `r` to denote the first index and second index respectively. \\n\\nWhen the sum is:<br>\\n1. smaller than the target:<br>\\n    we move `l` to the right by 1. we can't make `r` smaller because that's gonna make the sum even smaller.<br>\\n2. bigger than target:<br>\\n    move `r` to the left by 1. we can't make `l` bigger because that's gonna make the sum even bigger.<br>\\n3. equal to the target:<br>\\n    we found the answer and return.\\n\\nSince the question said there is EXACTLY one solution and didn't provide any info about when there is no valid answer, so we can always assume there is one and only one answer, which means `l` and `r` never across each other.\\n\\nAnother thing to notice is that this array is sorted.",
                "codeTag": "Unknown"
            },
            {
                "id": 261140,
                "title": "c-with-explanation-clear-simple",
                "content": "There are two good approaches to solve this problem.\\n**Hint:** As given array is **sorted**, we might use two pointer technique / binary search.\\n\\n**Two pointer technique**.\\nWe can exploit the sorted property of an array.\\nLet\\'s say for indices ``i`` & ``j`` such that ``i<j``, \\nif sum of elements ``A[i]+A[j] == target``, then we are done\\nelse check whether ``A[i]+A[j] > target``, then last element has to be removed to reduce the value of sum (``j--``).\\nsimilarly if ``A[i]+A[j] < target``, we have to add little to increase the sum (``i++``).\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // not found\\n    }\\n};\\n```\\ntime complexity: O(N)\\nspace complexity: O(1)\\n\\n___________________________________________________________________________________________________________________________\\n**Using Binary Search.** Consider each element and find is ``(target-nums[i])`` exist in array range ``[i+1,N-1]``? (If yes, we are done), else increment one step, then again search the element exist in array.\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1};\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // not found\\n    }\\n};\\n```\\n\\ntime complexity: O(NlogN) in worst (if elements are together in right extreme)\\nspace complexity: O(1)\\nNote: This is Template II Binary search, for further info go to [Explore](https://leetcode.com/explore/).\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // not found\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1};\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580496,
                "title": "python-short-two-pointer-solution-with-explanation",
                "content": "#### Explanation: \\n* The array is sorted in increasing order.\\n* So, incresing left index gives bigger number and decresing right index gives smaller number.\\n* We start with left index as the 1st index and right index as the last index of the array.\\n* Calculate the sum of the two elements at the two indices.\\n* If it is greater than the target, that means we have to decrese the sum. So, we decrement the right index.\\n* If it is lesser than the target, that means we have to increse the sum. So, we inrement the left index.\\n* Continue this process untill the sum is equal to the target.\\n\\n\\n```\\nclass Solution:\\n    def two_sum(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target: return (l + 1,  r + 1)\\n            if nums[l] + nums[r] > target: r -= 1\\n            else: l += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def two_sum(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target: return (l + 1,  r + 1)\\n            if nums[l] + nums[r] > target: r -= 1\\n            else: l += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128459,
                "title": "python-easy-o-1-space",
                "content": "This problem is an extension to [Two Sum](https://leetcode.com/problems/two-sum/) problem. In the two-sum problem, the input array is unsorted and hence we have to use a hashmap to solve the problem in **O(n)** time. But that completely changes, once the input is sorted. \\nThe algorithm is:\\n1. Initialize two pointers `i` and `j` which points first and last element respectively.\\n2. Add elements pointed by `i` and `j` and then compare with `target`. \\n3. If `target` is smaller, it means you have added a larger element and it needs to be cut off. So we decrement `j`.\\n4. If `target` is larger, it means you have added a smaller value and we need to pick next big value. So we increment \\'i`.\\n5. We repeat `2.` and `3.` until `i>=j` or a match is found.\\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while i<j:\\n            s = numbers[i] + numbers[j]\\n            if s == target:\\n                return [i + 1 , j + 1]\\n            \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return []\\n```\\n[Al_Dan](https://leetcode.com/Al_Dan/) pointed out that the solution can be made a bit more concise as the problem description states the following constraint:\\n>The tests are generated such that there is exactly one solution.\\n\\n\\nSo instead of  `i<j` check, we can do `numbers[i] + numbers[j]!=target`.\\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while numbers[i] + numbers[j]!=target:\\n            s = numbers[i] + numbers[j]        \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return [i + 1 , j + 1]\\n```\\n\\n\\n**Time - O(n)**\\n**Space - O(1)**\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while i<j:\\n            s = numbers[i] + numbers[j]\\n            if s == target:\\n                return [i + 1 , j + 1]\\n            \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return []\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        i = 0\\n        j = len(numbers) -1\\n        \\n        while numbers[i] + numbers[j]!=target:\\n            s = numbers[i] + numbers[j]        \\n            if s > target:\\n                j-=1\\n            else:\\n               i+=1 \\n        \\n        return [i + 1 , j + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128516,
                "title": "4-approaches-brute-force-hashmap-binary-search-two-pointers",
                "content": "[Leetcode](https://leetcode.com/) [167. Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/).\\n\\nHere shows **4** Approaches to slove this problem: Brute Force, HashMap, Binary Search, Two Pointers.\\n\\n# Brute Force\\n\\nIt\\'s easy to use **Brute Force** to find the answer, however, the time complexity is $O(n^2)$, so the BF solution will **Time Limit Exceeded**!\\n\\n```java\\n    public static int[] twoSum_bf(int[] numbers, int target) {\\n        int len = numbers.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (numbers[i] + numbers[j] == target) {\\n                    return new int[]{i + 1, j + 1};\\n                }\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$.\\n- **Space Complexity**: $O(1)$.\\n\\n# HashMap\\n\\nWe can use a extra $\\\\texttt{HashMap}$ to record the element we traversalled.\\n\\n```java\\n    public static int[] twoSum_hash(int[] numbers, int target) {\\n        int len = numbers.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(target - numbers[i])) {\\n                return new int[]{map.get(target - numbers[i]), i + 1};\\n            }\\n\\n            map.putIfAbsent(numbers[i], i + 1);\\n        }\\n\\n        return new int[0];\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n# Binary Search \\n\\nSince the array is already **sorted**, so we can use the **binary search**. In case of duplicated answer, we search only on the right of the left element.\\n\\n```java\\n    public int[] twoSum_bs(int[] numbers, int target) {\\n        for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n            int high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] == target - numbers[i]) {\\n                    return new int[]{i + 1, mid + 1};\\n                } else if (numbers[mid] > target - numbers[i]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$.\\n- **Space Complexity**: $O(1)$.\\n\\n# Two Pointers\\n\\n1. Let the two pointers point to the position of the first element and the position of the last element;\\n2. Each time the sum of the two elements pointed to by the two pointers is calculated and compared with the target value.\\n3. A unique solution is found if the sum of the two elements equals the target value. \\n4. If the sum of the two elements is less than the target, move the left pointer to the right one place; If the sum of the two elements is greater than the target, move the right pointer to the left by one. \\n5. Repeat until you find the answer.\\n\\n```java\\n    public static int[] twoSum_tp(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                return new int[]{left + 1, right + 1};\\n            }\\n        }\\n\\n        return new int[]{-1, -1};\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(1)$.\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```java\\n    public static int[] twoSum_bf(int[] numbers, int target) {\\n        int len = numbers.length;\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i + 1; j < len; j++) {\\n                if (numbers[i] + numbers[j] == target) {\\n                    return new int[]{i + 1, j + 1};\\n                }\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n```\n```java\\n    public static int[] twoSum_hash(int[] numbers, int target) {\\n        int len = numbers.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(target - numbers[i])) {\\n                return new int[]{map.get(target - numbers[i]), i + 1};\\n            }\\n\\n            map.putIfAbsent(numbers[i], i + 1);\\n        }\\n\\n        return new int[0];\\n    }\\n```\n```java\\n    public int[] twoSum_bs(int[] numbers, int target) {\\n        for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n            int high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] == target - numbers[i]) {\\n                    return new int[]{i + 1, mid + 1};\\n                } else if (numbers[mid] > target - numbers[i]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n```\n```java\\n    public static int[] twoSum_tp(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                return new int[]{left + 1, right + 1};\\n            }\\n        }\\n\\n        return new int[]{-1, -1};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376245,
                "title": "cleanest-js",
                "content": "```\\nconst twoSum = (numbers, target) => {\\n    let p1 = 0\\n    let p2 = numbers.length - 1\\n    \\n    while (numbers[p1] + numbers[p2] !== target) {\\n        if (numbers[p1] + numbers[p2] > target) {\\n            p2--\\n        } else {\\n            p1++\\n        }\\n    }\\n    \\n    return [p1 + 1, p2 + 1]\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst twoSum = (numbers, target) => {\\n    let p1 = 0\\n    let p2 = numbers.length - 1\\n    \\n    while (numbers[p1] + numbers[p2] !== target) {\\n        if (numbers[p1] + numbers[p2] > target) {\\n            p2--\\n        } else {\\n            p1++\\n        }\\n    }\\n    \\n    return [p1 + 1, p2 + 1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51268,
                "title": "a-less-efficient-way-binary-search",
                "content": "I know that the best solution is using two pointers like what is done in the previous solution sharing. However, I see the tag contains \"binary search\". I do not know if I misunderstand but is binary search a less efficient way for this problem.\\n\\nSay, fix the first element A[0] and do binary search on the remaining n-1 elements. If cannot find any element which equals target-A[0], Try A[1]. That is, fix A[1] and do binary search on A[2]~A[n-1]. Continue this process until we have the last two elements A[n-2] and A[n-1]. \\n\\nDoes this gives a time complexity lg(n-1) + lg(n-2) + ... + lg(1) ~ O(lg(n!)) ~ O(nlgn). So it is less efficient than the O(n) solution. Am I missing something here?\\n\\nThe code also passes OJ.\\n\\n    vector<int> twoSum(vector<int> &numbers, int target) {\\n        if(numbers.empty()) return {};\\n        for(int i=0; i<numbers.size()-1; i++) {\\n            int start=i+1, end=numbers.size()-1, gap=target-numbers[i];\\n            while(start <= end) {\\n                int m = start+(end-start)/2;\\n                if(numbers[m] == gap) return {i+1,m+1};\\n                else if(numbers[m] > gap) end=m-1;\\n                else start=m+1;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "I know that the best solution is using two pointers like what is done in the previous solution sharing. However, I see the tag contains \"binary search\". I do not know if I misunderstand but is binary search a less efficient way for this problem.\\n\\nSay, fix the first element A[0] and do binary search on the remaining n-1 elements. If cannot find any element which equals target-A[0], Try A[1]. That is, fix A[1] and do binary search on A[2]~A[n-1]. Continue this process until we have the last two elements A[n-2] and A[n-1]. \\n\\nDoes this gives a time complexity lg(n-1) + lg(n-2) + ... + lg(1) ~ O(lg(n!)) ~ O(nlgn). So it is less efficient than the O(n) solution. Am I missing something here?\\n\\nThe code also passes OJ.\\n\\n    vector<int> twoSum(vector<int> &numbers, int target) {\\n        if(numbers.empty()) return {};\\n        for(int i=0; i<numbers.size()-1; i++) {\\n            int start=i+1, end=numbers.size()-1, gap=target-numbers[i];\\n            while(start <= end) {\\n                int m = start+(end-start)/2;\\n                if(numbers[m] == gap) return {i+1,m+1};\\n                else if(numbers[m] > gap) end=m-1;\\n                else start=m+1;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 51251,
                "title": "a-o-logn-binary-search-java-solution-0ms-beat-98",
                "content": "```\\n    public int[] twoSum(int[] numbers, int target) {\\n        if (numbers == null || numbers.length == 0) {\\n            return new int[2];\\n        }\\n        int start = 0;\\n        int end = numbers.length - 1;\\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[]{start + 1, end + 1};\\n            } else if (numbers[start] + numbers[end] > target) {\\n                // move end forward to the last value that numbers[end] <= target - numbers[start]\\n                end = largestSmallerOrLastEqual(numbers, start, end, target - numbers[start]);\\n            } else {\\n                // move start backword to the first value that numbers[start] >= target - numbers[end]\\n                start = smallestLargerOrFirstEqual(numbers, start, end, target - numbers[end]);\\n            }\\n        }\\n        return new int[2];\\n    }\\n    private int largestSmallerOrLastEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    private int smallestLargerOrFirstEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] twoSum(int[] numbers, int target) {\\n        if (numbers == null || numbers.length == 0) {\\n            return new int[2];\\n        }\\n        int start = 0;\\n        int end = numbers.length - 1;\\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[]{start + 1, end + 1};\\n            } else if (numbers[start] + numbers[end] > target) {\\n                // move end forward to the last value that numbers[end] <= target - numbers[start]\\n                end = largestSmallerOrLastEqual(numbers, start, end, target - numbers[start]);\\n            } else {\\n                // move start backword to the first value that numbers[start] >= target - numbers[end]\\n                start = smallestLargerOrFirstEqual(numbers, start, end, target - numbers[end]);\\n            }\\n        }\\n        return new int[2];\\n    }\\n    private int largestSmallerOrLastEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return right;\\n    }\\n    private int smallestLargerOrFirstEqual(int[] numbers, int start, int end, int target) {\\n        int left = start;\\n        int right = end;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (numbers[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51386,
                "title": "java-7-line-simple-solution",
                "content": "    public int[] twoSum(int[] numbers, int target) {\\n            int start = 0, end = numbers.length - 1;\\n            while(start < end){\\n                if(numbers[start] + numbers[end] == target) break;\\n                if(numbers[start] + numbers[end] < target) start++;\\n                else end--;\\n            }\\n            return new int[]{start + 1, end + 1};\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int[] twoSum(int[] numbers, int target) {\\n            int start = 0, end = numbers.length - 1;\\n            while(start < end){\\n                if(numbers[start] + numbers[end] == target) break;\\n                if(numbers[start] + numbers[end] < target) start++;\\n                else end--;\\n            }\\n            return new int[]{start + 1, end + 1};\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3276269,
                "title": "easy-to-understand-beats-99",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nconstant\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int p1 = 0;\\n        int p2 = nums.length-1;\\n        int[] ans = new int[2];\\n        \\n        while(p1 < p2){\\n            int sum = nums[p1]+nums[p2];     \\n            if(sum == target){\\n                ans[0] = p1+1;\\n                ans[1] = p2+1;\\n                break;\\n            }\\n            else if(sum > target){\\n                p2--;\\n            }\\n            else{\\n                p1++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nPlease upvote if find helpful, and feel free to ask if you have any doubt regarding approach and code in the comment section.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg\" alt = \"\">\\n</p>",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int p1 = 0;\\n        int p2 = nums.length-1;\\n        int[] ans = new int[2];\\n        \\n        while(p1 < p2){\\n            int sum = nums[p1]+nums[p2];     \\n            if(sum == target){\\n                ans[0] = p1+1;\\n                ans[1] = p2+1;\\n                break;\\n            }\\n            else if(sum > target){\\n                p2--;\\n            }\\n            else{\\n                p1++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131167,
                "title": "java-4-approaches-explained-in-detail-easy-to-understand-code",
                "content": "**Two pointer Approach(Fastest)  -->**\\n**Logic**\\nWe take two pointers one pointing at the start and other at the end of the array\\nWe iterate till the two pointers meet in a logic that no sum is found out\\nWe check that wether array[pt1]+array[pt2]>target then pt2--\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tarray[pt1]+array[pt2]<target then pt++\\nIf dosent satisfy then sum is found out then we return the array index\\'s\\n\\n**Complexity**\\nTC - O(n)\\nSC - O(1)\\n\\n**Code  -->**\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int i=0;\\n        int j=len-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                return new int[]{i+1,j+1};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```\\n**Binary Search Approach**\\n**Logic**\\nWe iterate through the entire array and initialise the high and low value\\nWe initialise the mid value if low index is lesser than the higher one or vice-versa\\nThen we check whether array[i]+arr[mid] == target or not\\n\\n**Complexity**\\nTC - O(nlogn)\\nSC - O(1)\\n\\n**Code  -->**\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n         for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n\\t\\t\\tint high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] +numbers[i] == target)\\n                    return new int[]{i + 1, mid + 1};\\n                else if (numbers[mid] + numbers[i] > target) \\n                    high = mid - 1;\\n                else \\n                    low = mid + 1;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```\\n**HashMap Approach**\\n**Logic**\\nWe define a HashMap and then check whether the sum is available in the array or not by travesing through the sorted array\\n\\n**Complexity**\\nTC - O(n)\\nSC - O(n)\\n\\n**Code  -->**\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int len = numbers.length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (map.containsKey(target - numbers[i])) \\n                return new int[]{map.get(target - numbers[i]), i + 1};\\n            map.putIfAbsent(numbers[i], i + 1);\\n        }\\n        return new int[0];\\n    }\\n}\\n\\n**BruteForce Approach**\\n**Logic**\\nWe iterate through two loops and check whether the summation of ith element and jth element is equal to the target or not\\n\\n**Complexity**\\nTC - O(n^2)\\nSC - O(1)\\n\\n**Upvote if this helped**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int i=0;\\n        int j=len-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                return new int[]{i+1,j+1};\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n         for (int i = 0; i < numbers.length; ++i) {\\n            int low = i + 1;\\n\\t\\t\\tint high = numbers.length - 1;\\n            while (low <= high) {\\n                int mid = (high - low) / 2 + low;\\n                if (numbers[mid] +numbers[i] == target)\\n                    return new int[]{i + 1, mid + 1};\\n                else if (numbers[mid] + numbers[i] > target) \\n                    high = mid - 1;\\n                else \\n                    low = mid + 1;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51287,
                "title": "javascript-simple-solution",
                "content": "The idea is to have a pointer from the beginning and one from the end.\\n\\nOn each iteration, move the lower pointer to the right if the sum is too small, or the upper pointer down if it is too big.\\n\\nBe careful to return the indexes with an additional 1 because we are manipulating 0-based indexes.\\n\\n```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  while (numbers[i]+numbers[j] !== target) {\\n    numbers[i]+numbers[j] < target ? i++ : j--;\\n  }\\n  return [i+1, j+1];\\n};\\n```\\n\\nA minor optimization is to compute the sum only once on every iteration by putting it in a variable:\\n\\n```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  var sum = numbers[i]+numbers[j];\\n  while (sum !== target) {\\n    sum < target ? i++ : j--;\\n    sum = numbers[i]+numbers[j];\\n  }\\n  return [i+1, j+1];\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  while (numbers[i]+numbers[j] !== target) {\\n    numbers[i]+numbers[j] < target ? i++ : j--;\\n  }\\n  return [i+1, j+1];\\n};\\n```\n```js\\nvar twoSum = function(numbers, target) {\\n  var l=numbers.length, i=0, j=l-1;\\n  var sum = numbers[i]+numbers[j];\\n  while (sum !== target) {\\n    sum < target ? i++ : j--;\\n    sum = numbers[i]+numbers[j];\\n  }\\n  return [i+1, j+1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159553,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l = 0\\n        r = len(numbers) - 1\\n        while l < r:\\n            if numbers[l] + numbers[r] == target:\\n                return [l+1, r+1]\\n            elif numbers[l] + numbers[r] < target:\\n                l += 1\\n            else:\\n                r -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l = 0\\n        r = len(numbers) - 1\\n        while l < r:\\n            if numbers[l] + numbers[r] == target:\\n                return [l+1, r+1]\\n            elif numbers[l] + numbers[r] < target:\\n                l += 1\\n            else:\\n                r -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942235,
                "title": "c-two-pointers-o-n-and-binary-search-o-n-log-n",
                "content": "Two Pointer | O(n)\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0, high = numbers.size()-1;\\n        vector<int> sum;\\n        while(low < high)\\n        {\\n            if(numbers[low] + numbers[high] == target)\\n            {\\n                sum.push_back(low+1);\\n                sum.push_back(high+1);   // alternative: sum = {low+1, high+1};\\n                return sum;\\n            }\\n            else if(numbers[low] + numbers[high] > target)\\n                high--;\\n            else\\n                low++; \\n        }\\n        return sum;\\n    }\\n};\\n```\\nBinary Search | O(n log n)\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> sum;\\n        for(int x = 0; x < numbers.size(); x++)\\n        {\\n            int low = 0, high = numbers.size()-1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(numbers[mid] == target - numbers[x])\\n                {\\n                    if(mid == x)\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;  // moves low to next value in case the original value is the difference to be added\\n                    else\\n                    {\\n                        sum = {x+1, mid+1};\\n                        return sum;\\n                    }\\n                }\\n                else if(numbers[mid] < target - numbers[x])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;      \\n            }\\n        }\\n       return sum;\\n    }\\n};\\n```\\nUpvote if it helped out any at all. Drop any questions and suggestions if it didn\\'t. :)",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0, high = numbers.size()-1;\\n        vector<int> sum;\\n        while(low < high)\\n        {\\n            if(numbers[low] + numbers[high] == target)\\n            {\\n                sum.push_back(low+1);\\n                sum.push_back(high+1);   // alternative: sum = {low+1, high+1};\\n                return sum;\\n            }\\n            else if(numbers[low] + numbers[high] > target)\\n                high--;\\n            else\\n                low++; \\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> sum;\\n        for(int x = 0; x < numbers.size(); x++)\\n        {\\n            int low = 0, high = numbers.size()-1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low)/2;\\n                if(numbers[mid] == target - numbers[x])\\n                {\\n                    if(mid == x)\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;  // moves low to next value in case the original value is the difference to be added\\n                    else\\n                    {\\n                        sum = {x+1, mid+1};\\n                        return sum;\\n                    }\\n                }\\n                else if(numbers[mid] < target - numbers[x])\\n                    low = mid + 1;\\n                else\\n                    high = mid - 1;      \\n            }\\n        }\\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520736,
                "title": "concise-javascript-o-1-space-solution",
                "content": "```\\nfunction twoSum(numbers, target) {\\n    for(let start = 0, end = numbers.length-1; start < end;){\\n        let sum = numbers[start] + numbers[end]\\n        if(sum === target)return [++start, ++end]\\n        else sum > target ? end-- : start++\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction twoSum(numbers, target) {\\n    for(let start = 0, end = numbers.length-1; start < end;){\\n        let sum = numbers[start] + numbers[end]\\n        if(sum === target)return [++start, ++end]\\n        else sum > target ? end-- : start++\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507300,
                "title": "c-solution-4-ms-faster-than-87-56-python-simple-solution",
                "content": "**C++ :**\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint i = 0;\\n\\tint j = numbers.size() - 1;\\n\\tvector<int> res;\\n\\twhile(i < j)\\n\\t{\\n\\t\\tif(numbers[i] + numbers[j] < target)\\n\\t\\t\\t++i;\\n\\n\\t\\telse if(numbers[i] + numbers[j] > target)\\n\\t\\t\\t--j;\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres.push_back(i + 1);\\n\\t\\t\\tres.push_back(j + 1);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\\n\\tleft = 0\\n\\tright = len(nums) - 1\\n\\n\\twhile left < right:\\n\\t\\tif nums[left] + nums[right] < target:\\n\\t\\t\\tleft += 1\\n\\n\\t\\telif nums[left] + nums[right] > target:\\n\\t\\t\\tright -= 1\\n\\n\\t\\telse:\\n\\t\\t\\treturn [left + 1, right + 1]\\n```\\n\\n**Like it ? please upvote!**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint i = 0;\\n\\tint j = numbers.size() - 1;\\n\\tvector<int> res;\\n\\twhile(i < j)\\n\\t{\\n\\t\\tif(numbers[i] + numbers[j] < target)\\n\\t\\t\\t++i;\\n\\n\\t\\telse if(numbers[i] + numbers[j] > target)\\n\\t\\t\\t--j;\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres.push_back(i + 1);\\n\\t\\t\\tres.push_back(j + 1);\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\\n\\tleft = 0\\n\\tright = len(nums) - 1\\n\\n\\twhile left < right:\\n\\t\\tif nums[left] + nums[right] < target:\\n\\t\\t\\tleft += 1\\n\\n\\t\\telif nums[left] + nums[right] > target:\\n\\t\\t\\tright -= 1\\n\\n\\t\\telse:\\n\\t\\t\\treturn [left + 1, right + 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2128769,
                "title": "c-two-pointers-binary-search",
                "content": "**Please upvote the post if you like it :)**\\n\\n**Intuition:** The given array is `sorted`, which means we can use two techniques: `Two Pointers/Binary-Search`\\n\\n**Two Pointers:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```\\n**Time Complexity : O(N)**\\n**Space Complexity : O(1)**\\n****\\n**Binary Search:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1}; // returning the indices\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```\\n**Time Complexity : O(NlogN)**\\n**Space Complexity : O(1)**",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            int sum = nums[i] + nums[j];\\n            if(sum==target) return {i+1,j+1};\\n            else if(sum>target) j--;\\n            else i++;\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int N = nums.size();\\n        for(int i=0;i<N-1;i++){\\n            int lo = i+1;\\n            int hi = N;\\n            while(lo<hi){\\n                int mid = lo + (hi-lo)/2;\\n                if(nums[mid]==target-nums[i]) return {i+1,mid+1}; // returning the indices\\n                else if(nums[mid]>=target-nums[i]) hi=mid;\\n                else lo = mid+1;\\n            }\\n            if(lo!=nums.size() && nums[lo]==target-nums[i]) return {i+1,lo+1};\\n        }\\n        return {}; // Target not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610905,
                "title": "two-pointers-fast-simple-c",
                "content": "##### **Approach:**\\n1. Intinilize The **i from 0** and **j from n-1**\\n2. we are going to check each time that what number at i and number at j makes up\\n3. if it is less than target we **increment i**\\n4. if it is greater than target we **decrement j**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        vector <int> ans; // Answer Array\\n        int i = 0, j = nums.size() - 1; // Initilize Two Pointers\\n        while (i < j) {\\n            if (nums[i] + nums[j] < target) ++i;\\n            else if (nums[i] + nums[j] > target) --j;\\n            else {\\n                ans.push_back(i+1);\\n                ans.push_back(j+1);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nif you got the solution, please consider up voting\\nif you didn\\'t feel free to comment",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        vector <int> ans; // Answer Array\\n        int i = 0, j = nums.size() - 1; // Initilize Two Pointers\\n        while (i < j) {\\n            if (nums[i] + nums[j] < target) ++i;\\n            else if (nums[i] + nums[j] > target) --j;\\n            else {\\n                ans.push_back(i+1);\\n                ans.push_back(j+1);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737095,
                "title": "sum-megapost-python3-solution-with-a-detailed-explanation",
                "content": "If you\\'re a newbie and sometimes have a hard time understanding the logic. Don\\'t worry, you\\'ll catch up after a month of doing Leetcode on a daily basis. Try to do it, even one example per day. It\\'d help. I\\'ve compiled a bunch on `sum` problems here, go ahead and check it out. Also, I think focusing on a subject and do 3-4 problems would help to get the idea behind solution since they mostly follow the same logic. Of course there are other ways to solve each problems but I try to be as uniform as possible. Good luck. \\n\\nIn general, `sum` problems can be categorized into two categories: 1) there is any array and you add some numbers to get to (or close to) a `target`, or 2) you need to return indices of numbers that sum up to a (or close to) a `target` value.  Note that when the problem is looking for a indices, `sort`ing the array is probably NOT a good idea. \\n\\n\\n **[Two Sum:](https://leetcode.com/problems/two-sum/)**  \\n \\n This is the second type of the problems where we\\'re looking for indices, so sorting is not necessary. What you\\'d want to do is to go over the array, and try to find two integers that sum up to  a `target` value. Most of the times, in such a problem, using dictionary (hastable) helps. You try to keep track of you\\'ve observations in a dictionary and use it once you get to the results. \\n\\nNote: try to be comfortable to use `enumerate` as it\\'s sometime out of comfort zone for newbies. `enumerate` comes handy in a lot of problems (I mean if you want to have a cleaner code of course). If I had to choose three built in functions/methods that I wasn\\'t comfortable with at the start and have found them super helpful, I\\'d probably say `enumerate`, `zip` and `set`. \\n \\nSolution: In this problem, you initialize a dictionary (`seen`). This dictionary will keep track of numbers (as `key`) and indices (as `value`). So, you go over your array (line `#1`) using `enumerate` that gives you both index and value of elements in array. As an example, let\\'s do `nums = [2,3,1]` and `target = 3`. Let\\'s say you\\'re at index `i = 0` and `value = 2`, ok? you need to find `value = 1` to finish the problem, meaning, `target - 2 = 1`. 1 here is the `remaining`. Since `remaining + value = target`, you\\'re done once you found it, right? So when going through the array, you calculate the `remaining` and check to see whether `remaining` is in the `seen` dictionary (line `#3`). If it is, you\\'re done! you\\'re current number and the remaining from `seen` would give you the output (line `#4`). Otherwise, you add your current number to the dictionary (line `#5`) since it\\'s going to be a `remaining` for (probably) a number you\\'ll see in the future assuming that there is at least one instance of answer.  \\n \\n \\n ```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\\n \\n \\n\\n **[Two Sum II:](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)**  \\n\\nFor this, you can do exactly as the previous. The only change I made below was to change the order of line `#4`. In the previous example, the order didn\\'t matter. But, here the problem asks for asending order and since the values/indicess in `seen` has always lower indices than your current number, it should come first.  Also, note that the problem says it\\'s not zero based, meaning that indices don\\'t start from zero, that\\'s why I added 1 to both of them. \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\\n\\nAnother approach to solve this problem (probably what Leetcode is looking for) is to treat it as first category of problems. Since the array is already sorted, this works. You see the following approach in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you\\'d need three pointers as you\\'ll see in the future examples). One pointer move from `left` and one from `right`. Let\\'s say you `numbers = [1,3,6,9]` and your `target = 10`. Now, `left` points to 1 at first, and  `right` points to 9. There are three possibilities. If you sum numbers that `left` and `right` are pointing at, you get `temp_sum` (line `#1`). If `temp_sum` is your target, you\\'r done! You\\'re return it (line `#9`). If it\\'s more than your `target`, it means that `right` is poiting to a very large value (line `#5`) and you need to bring it a little bit to the left to a smaller (r maybe equal) value (line `#6`)  by adding one to the index . If the `temp_sum` is less than `target` (line `#7`), then you need to move your `left` to a little bit larger value by adding one to the index (line `#9`). This way, you try to narrow down the range in which you\\'re looking at and will eventually find a couple of number that sum to `target`, then, you\\'ll return this in line `#9`. In this problem, since it says there is only one solution, nothing extra is necessary. However, when a problem asks to return all combinations that sum to `target`, you can\\'t simply return the first instace and you need to collect all the possibilities and return the list altogether (you\\'ll see something like this in the next example). \\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\\n\\n\\n\\n\\n[**3Sum**](https://leetcode.com/problems/3sum/)\\n\\nThis is similar to the previous example except that it\\'s looking for three numbers. There are some minor differences in the problem statement. It\\'s looking for all combinations (not just one) of solutions returned as a list. And second, it\\'s looking for unique combination, repeatation is not allowed. \\n\\nHere, instead of looping (line `#1`) to `len(nums) -1`, we loop to `len(nums) -2` since we\\'re looking for three numbers. Since we\\'re returning values, `sort` would be a good idea. Otherwise, if the `nums` is not sorted, you cannot reducing `right` pointer or increasing `left` pointer easily, makes sense? \\n\\nSo, first you `sort` the array and define `res = []` to collect your outputs. In line `#2`, we check wether two consecutive elements are equal or not because if they are, we don\\'t want them (solutions need to be unique) and will skip to the next set of numbers. Also, there is an additional constrain in this line that `i > 0`. This is added to take care of cases like `nums = [1,1,1]` and `target = 3`. If we didn\\'t have `i > 0`, then we\\'d skip the only correct solution and would return `[]` as our answer which is wrong (correct answer is `[[1,1,1]]`.  \\n\\nWe define two additional pointers this time, `left = i + 1` and `right = len(nums) - 1`. For example, if `nums = [-2,-1,0,1,2]`, all the points in the case of `i=1` are looking at: `i` at `-1`, `left` at `0` and `right` at `2`. We then check `temp` variable similar to the previous example. There is only one change with respect to the previous example here between lines `#5` and `#10`.  If we have the `temp = target`, we obviously add this set to the `res` in line `#5`, right? However, we\\'re not done yet. For a fixed `i`, we still need to check and see whether there are other combinations by just changing `left` and `right` pointers. That\\'s what we are doing in lines `#6, 7, 8`. If we still have the condition of `left < right` and `nums[left]` and the number to the right of it are not the same, we move `left` one index to right (line `#6`). Similarly, if `nums[right]` and the value to left of it is not the same, we move `right` one index to left. This way for a fixed `i`, we get rid of repeative cases. For example, if `nums = [-3, 1,1, 3,5]` and `target = 3`, one we get the first `[-3,1,5]`, `left = 1`, but, `nums[2]` is also 1 which we don\\'t want the `left` variable to look at it simply because it\\'d again return `[-3,1,5]`, right? So, we move `left` one index. Finally, if the repeating elements don\\'t exists, lines `#6` to `#8` won\\'t get activated. In this case we still need to move forward by adding 1 to `left` and extracting 1 from `right` (lines `#9, 10`). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\\n\\nAnother way to solve this problem is to change it into a two sum problem. Instead of finding `a+b+c = 0`, you can find `a+b = -c` where we want to find two numbers `a` and `b` that are equal to `-c`, right? This is similar to the first problem. Remember if you wanted to use the exact same as the first code, it\\'d return indices and not numbers. Also, we need to re-arrage this problem in a way that we have `nums` and `target`. This code is not a good code and can be optimipized but you got the idea. For a better version of this, check [this](https://leetcode.com/problems/3sum/discuss/7384/My-Python-solution-based-on-2-sum-200-ms-beat-93.37). \\n\\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\\n\\n[**4Sum**](https://leetcode.com/problems/4sum/)\\n\\nYou should have gotten the idea, and what you\\'ve seen so far can be generalized to `nSum`. Here, I write the generic code using the same ideas as before. What I\\'ll do is to break down each case to a `2Sum II` problem, and solve them recursively using the approach in `2Sum II` example above. \\n\\nFirst sort `nums`, then I\\'m using two extra functions, `helper` and `twoSum`. The `twoSum` is similar to the `2sum II` example with some modifications. It doesn\\'t return the first instance of results, it check every possible combinations and return all of them now. Basically, now it\\'s more similar to the `3Sum` solution. Understanding this function shouldn\\'t be difficult as it\\'s very similar to `3Sum`. As for `helper` function, it first tries to check for cases that don\\'t work (line `#1`). And later, if the `N` we need to sum to get to a `target` is 2 (line `#2`), then runs the `twoSum` function. For the more than two numbers, it recursively breaks them down to two sum (line `#3`). There are some cases like line `#4` that we don\\'t need to proceed with the algorithm anymore and we can `break`. These cases include if multiplying the lowest number in the list by `N` is more than `target`. Since its sorted array, if this happens, we can\\'t find any result. Also, if the largest array (`nums[-1]`) multiplied by `N` would be less than `target`, we can\\'t find any solution. So, `break`. \\n\\n\\nFor other cases, we run the `helper` function again with new inputs, and we keep doing it until we get to `N=2` in which we use `twoSum` function, and add the results to get the final output. \\n\\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\\n[**Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\nI don\\'t post combination sum here since it\\'s basically this problem a little bit easier. \\nCombination questions can be solved with `dfs` most of the time. if you want to fully understand this concept and [backtracking](https://www.***.org/backtracking-introduction/), try to finish [this](https://leetcode.com/problems/combination-sum/discuss/429538/General-Backtracking-questions-solutions-in-Python-for-reference-%3A) post and do all the examples. \\n\\nRead my older post first [here](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation). This should give you a better idea of what\\'s going on. The solution here also follow the exact same format except for some minor changes. I first made a minor change in the `dfs` function where it doesn\\'t need the `index` parameter anymore. This is taken care of by `candidates[i+1:]` in line `#3`. Note that we had `candidates` here in the previous post. \\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```\\n\\n\\nThe only differences are lines `#1, 2, 3`. The difference in problem statement in this one and `combinations` problem of my previous post is >>>candidates must be used once<<< and lines `#1` and `2` are here to take care of this.  Line `#1` has two components where first `i > 0` and second `candidates[i] == candidates[i-1]`. The second component `candidates[i] == candidates[i-1]` is to take care of duplicates in the `candidates` variable as was instructed in the problem statement. Basically, if the next number in `candidates` is the same as the previous one, it means that it has already been taken care of, so `continue`. The first component takes care of cases like an input  `candidates = [1]` with `target = 1` (try to remove this component and submit your solution. You\\'ll see what I mean). The rest is similar to the previous [post](https://leetcode.com/problems/combinations/discuss/729397/python3-solution-with-detailed-explanation)\\n\\n================================================================\\nFinal note: Please let me know if you found any typo/error/ect. I\\'ll try to fix them.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n class Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        seen = {}\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n            \\n            if remaining in seen: #3\\n                return [i, seen[remaining]]  #4\\n            else:\\n                seen[value] = i  #5\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        seen = {}\\n        for i, value in enumerate(numbers): \\n            remaining = target - numbers[i] \\n           \\n            if remaining in seen: \\n                return [seen[remaining]+1, i+1]  #4\\n            else:\\n                seen[value] = i  \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        \\n        for left in range(len(numbers) -1): #1\\n            right = len(numbers) - 1 #2\\n            while left < right: #3\\n                temp_sum = numbers[left] + numbers[right] #4\\n                if temp_sum > target:  #5\\n                    right -= 1 #6\\n                elif temp_sum < target: #7\\n                    left +=1 #8\\n                else:\\n                    return [left+1, right+1] #9\\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        \\n        nums.sort()\\n        res = []\\n\\n        for i in range(len(nums) -2): #1\\n            if i > 0 and nums[i] == nums[i-1]: #2\\n                continue\\n            left = i + 1 #3\\n            right = len(nums) - 1 #4\\n            \\n            while left < right:  \\n                temp = nums[i] + nums[left] + nums[right]\\n                                    \\n                if temp > 0:\\n                    right -= 1\\n                    \\n                elif temp < 0:\\n                    left += 1\\n                \\n                else:\\n                    res.append([nums[i], nums[left], nums[right]]) #5\\n                    while left < right and nums[left] == nums[left + 1]: #6\\n                        left += 1\\n                    while left < right and nums[right] == nums[right-1]:#7\\n                        right -= 1    #8\\n                \\n                    right -= 1 #9 \\n                    left += 1 #10\\n                       \\n```\n```\\nclass Solution:\\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            output_2sum = self.twoSum(nums[i+1:], -nums[i])\\n            if output_2sum ==[]:\\n                continue\\n            else:\\n                for idx in output_2sum:\\n                    instance = idx+[nums[i]]\\n                    res.append(instance)\\n        \\n        output = []\\n        for idx in res:\\n            if idx not in output:\\n                output.append(idx)\\n                \\n        \\n        return output\\n    \\n    \\n    def twoSum(self, nums, target):\\n        seen = {}\\n        res = []\\n        for i, value in enumerate(nums): #1\\n            remaining = target - nums[i] #2\\n           \\n            if remaining in seen: #3\\n                res.append([value, remaining])  #4\\n            else:\\n                seen[value] = i  #5\\n            \\n        return res\\n```\n```\\nclass Solution:\\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\\n        nums.sort()\\n        results = []\\n        self.helper(nums, target, 4, [], results)\\n        return results\\n    \\n    def helper(self, nums, target, N, res, results):\\n        \\n        if len(nums) < N or N < 2: #1\\n            return\\n        if N == 2: #2\\n            output_2sum = self.twoSum(nums, target)\\n            if output_2sum != []:\\n                for idx in output_2sum:\\n                    results.append(res + idx)\\n        \\n        else: \\n            for i in range(len(nums) -N +1): #3\\n                if nums[i]*N > target or nums[-1]*N < target: #4\\n                    break\\n                if i == 0 or i > 0 and nums[i-1] != nums[i]: #5\\n                    self.helper(nums[i+1:], target-nums[i], N-1, res + [nums[i]], results)\\n    \\n    \\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        res = []\\n        left = 0\\n        right = len(nums) - 1 \\n        while left < right: \\n            temp_sum = nums[left] + nums[right] \\n\\n            if temp_sum == target:\\n                res.append([nums[left], nums[right]])\\n                right -= 1\\n                left += 1\\n                while left < right and nums[left] == nums[left - 1]:\\n                    left += 1\\n                while right > left and nums[right] == nums[right + 1]:\\n                    right -= 1\\n                                \\n            elif temp_sum < target: \\n                left +=1 \\n            else: \\n                right -= 1\\n                                        \\n        return res\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        candidates.sort()\\n        self.dfs(candidates, target, [], res)\\n        return res\\n    \\n    \\n    def dfs(self, candidates, target, path, res):\\n        if target < 0:\\n            return\\n        \\n        if target == 0:\\n            res.append(path)\\n            return res\\n        \\n        for i in range(len(candidates)):\\n            if i > 0 and candidates[i] == candidates[i-1]: #1\\n                continue #2\\n            self.dfs(candidates[i+1:], target - candidates[i], path+[candidates[i]], res) #3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128629,
                "title": "c-o-1-space-o-n-time-good-explanation",
                "content": "\\n#                                                                    TWO POINTER APPROACH\\nUsing the two-pointer approach, first create two pointers one to start off at the 0th index and the other to start from the end of the array.We create a while loop that will keep running provided the first pointer, pointer1, is less than the second pointer,pointer2. Inside this while loop, we find the sum of the elements at the respective pointer positions. If the sum is equal to the target, return those two indices, otherwise, if the sum is less than the target, increase the first pointer position by one and if the sum is greater than the target, reduce the second pointer by 1.\\n\\n**Time Complexity : O(n)   (for traversing array using two pointers)\\nSpace Complexity : O(1)  (the vector to be returned is always having 2 values)**\\n\\n![image](https://assets.leetcode.com/users/images/7347585f-87d3-43bd-ba07-4b0c2c9b8256_1654750949.8383505.png)\\n\\n```\\n     int i =0,j = numbers.size()-1;\\n        \\n        while(i<j){\\n            int k = numbers[i]+numbers[j];\\n            \\n            if(k==target){\\n               vector<int> ans{i+1,j+1}; \\n              return ans;\\n            }\\n            \\n            if(k<target){\\n                \\n                i++;\\n                continue;\\n            }\\n            \\n            if(k>target){\\n                j--;\\n                continue;\\n            }\\n        }\\n        \\n        return numbers;    // won\\'t be reached due to constraints\\n```",
                "solutionTags": [],
                "code": "```\\n     int i =0,j = numbers.size()-1;\\n        \\n        while(i<j){\\n            int k = numbers[i]+numbers[j];\\n            \\n            if(k==target){\\n               vector<int> ans{i+1,j+1}; \\n              return ans;\\n            }\\n            \\n            if(k<target){\\n                \\n                i++;\\n                continue;\\n            }\\n            \\n            if(k>target){\\n                j--;\\n                continue;\\n            }\\n        }\\n        \\n        return numbers;    // won\\'t be reached due to constraints\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748931,
                "title": "java-binary-search-map-two-pointer-solutions",
                "content": "Solution 1 : BinarySearch\\nTime : O(nlogn)\\nspace : O(1)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        for(int i=0;i<n-1;i++){\\n           int pos = Arrays.binarySearch(numbers,i+1,n,target-numbers[i]);\\n           if(pos>0) return new int[]{i+1,pos+1};\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\n\\n\\nSolution 2: HashMap\\nTime : O(n)\\nspace : O(n)\\n\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        Map<Integer,Integer> seen = new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<n;i++) seen.put(numbers[i],i);\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n           if(seen.containsKey(target-numbers[i]))\\n               return new int[]{i+1,seen.get(target-numbers[i])+1};\\n        \\n        return null;\\n    }\\n}\\n```\\n\\nSolution 3 : Two pointers\\nTime : O(n)\\nspace : O(1)\\n\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length,i=0,j=n-1;\\n        while(i<j){\\n            int sum = numbers[i] + numbers[j];\\n            if(sum == target) return new int[]{i+1,j+1};\\n            if(sum > target) j--;\\n            else i++;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        for(int i=0;i<n-1;i++){\\n           int pos = Arrays.binarySearch(numbers,i+1,n,target-numbers[i]);\\n           if(pos>0) return new int[]{i+1,pos+1};\\n        }\\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        Map<Integer,Integer> seen = new HashMap<>();\\n\\t\\t\\n        for(int i=0;i<n;i++) seen.put(numbers[i],i);\\n\\t\\t\\n        for(int i=0;i<n-1;i++)\\n           if(seen.containsKey(target-numbers[i]))\\n               return new int[]{i+1,seen.get(target-numbers[i])+1};\\n        \\n        return null;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length,i=0,j=n-1;\\n        while(i<j){\\n            int sum = numbers[i] + numbers[j];\\n            if(sum == target) return new int[]{i+1,j+1};\\n            if(sum > target) j--;\\n            else i++;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328900,
                "title": "binary-search-and-hash-table-concept",
                "content": "# 1. Binary Search With Cute Approach : O(NLogN)\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        list1=[]\\n        for i,n in enumerate(numbers):\\n            left,right=i+1,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if (numbers[mid]+n)==target:\\n                    return i+1,mid+1\\n                if (numbers[mid]+n)<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            \\n```\\n# 2. Binary Search----->O(NLogN)\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        for i in range(len(numbers)):\\n            left,right=0,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                n=numbers[i]+numbers[mid]\\n                if n==target:\\n                    if i+1==mid+1:\\n                        return i+1,mid+2\\n                    return i+1,mid+1\\n                if n<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n        \\n```\\n# 2. Hash Table Concept---->O(N)\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        dic={}\\n        for key,val in enumerate(nums):\\n            if val in dic:\\n                return dic[val],key\\n            else:\\n                dic[target-val]=key\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        list1=[]\\n        for i,n in enumerate(numbers):\\n            left,right=i+1,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if (numbers[mid]+n)==target:\\n                    return i+1,mid+1\\n                if (numbers[mid]+n)<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n            \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        for i in range(len(numbers)):\\n            left,right=0,len(numbers)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                n=numbers[i]+numbers[mid]\\n                if n==target:\\n                    if i+1==mid+1:\\n                        return i+1,mid+2\\n                    return i+1,mid+1\\n                if n<target:\\n                    left=mid+1\\n                else:\\n                    right=mid-1\\n        \\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        dic={}\\n        for key,val in enumerate(nums):\\n            if val in dic:\\n                return dic[val],key\\n            else:\\n                dic[target-val]=key\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063164,
                "title": "c-simple-solution-explained-properly",
                "content": "\\n# Approach\\nPick any two indices in the array and check the sum of their values.\\n **There may arise three possibilities regarding the sum of those two values:**\\n\\n 1. **The sum is equal to target**: In this case, we are lucky enough and will return the two selected indices.\\n1. **The sum is less than target:** In this case, we would want to increase the sum. Since the array is sorted, we can increase the sum by moving one of the indices towards right,so increasing low by one index.\\n1. **The sum is greater than target**: In this case, we would want to decrease the sum. This can be done by moving one of the indices towards the left,so decreasing high by one index.\\n\\nSo, the idea is to initially have pointers on the leftmost and the rightmost indices of the array. We will be using the left pointer to increase the sum and the right pointer to decrease the sum whenever needed. Therefore, the left pointer will move towards the right and the right pointer will move towards the left till one of the following conditions get satisfied:\\n\\nThe sum of the values pointed by the left and the right pointers is equal to target.\\nThe two pointers cross each other. In this case, no valid pair exists in the array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n),where n is size of array or vector.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector<int>ans;\\n        int n=numbers.size(),low=0,high=n-1;\\n        while(low<high)\\n        {\\n           int sum=numbers[low]+numbers[high];\\n           if(sum==target)\\n           {\\n               ans.push_back(low+1);\\n               ans.push_back(high+1);\\n               break;\\n           }\\n           else if(sum>target)\\n           high--;\\n           else\\n           low++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if this solution is helpful for you and for any doubt feel free to discuss and comment below.\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector<int>ans;\\n        int n=numbers.size(),low=0,high=n-1;\\n        while(low<high)\\n        {\\n           int sum=numbers[low]+numbers[high];\\n           if(sum==target)\\n           {\\n               ans.push_back(low+1);\\n               ans.push_back(high+1);\\n               break;\\n           }\\n           else if(sum>target)\\n           high--;\\n           else\\n           low++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799628,
                "title": "easy-clear-and-classic-javascript-solution-two-sum-ii-input-array-is-sorted",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar twoSum = function(numbers, target) {\\n  \\n    let left = 0, right = numbers.length -1;\\n\\n    while(left < right) {\\n       let sum = numbers[left] + numbers[right];\\n       if(sum === target) {\\n           return [left+1, right +1]\\n       }else if( sum > target) {\\n           right--\\n       }else {\\n           left++\\n       }\\n    }\\n    return [-1,-1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar twoSum = function(numbers, target) {\\n  \\n    let left = 0, right = numbers.length -1;\\n\\n    while(left < right) {\\n       let sum = numbers[left] + numbers[right];\\n       if(sum === target) {\\n           return [left+1, right +1]\\n       }else if( sum > target) {\\n           right--\\n       }else {\\n           left++\\n       }\\n    }\\n    return [-1,-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 368501,
                "title": "python-solution-o-1-memory",
                "content": "```python\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        low, high = 0, len(numbers) - 1\\n        while low < high:\\n            sum = numbers[low] + numbers[high]\\n            if sum > target:\\n                high -= 1\\n            elif sum == target:\\n                return [low + 1, high + 1]\\n            else:\\n                low += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        low, high = 0, len(numbers) - 1\\n        while low < high:\\n            sum = numbers[low] + numbers[high]\\n            if sum > target:\\n                high -= 1\\n            elif sum == target:\\n                return [low + 1, high + 1]\\n            else:\\n                low += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267705,
                "title": "c-o-n-2-pointers-beats-90",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int start = 0 ; \\n        int end = numbers.size() - 1 ; \\n\\n        while ((start <= end) && (numbers[start] + numbers[end] != target))\\n        {\\n            if (numbers[start] + numbers[end] < target)\\n            {\\n                start ++ ;  \\n            }\\n            else \\n            {\\n                end -- ; \\n            }\\n        }\\n        return {start + 1 ,end + 1} ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/e7392589-94ab-4736-9fca-a113abfb4d2e_1678175028.7162287.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int start = 0 ; \\n        int end = numbers.size() - 1 ; \\n\\n        while ((start <= end) && (numbers[start] + numbers[end] != target))\\n        {\\n            if (numbers[start] + numbers[end] < target)\\n            {\\n                start ++ ;  \\n            }\\n            else \\n            {\\n                end -- ; \\n            }\\n        }\\n        return {start + 1 ,end + 1} ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741413,
                "title": "java-easy-solution-two-pointers",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0;\\n        int high = numbers.length - 1;\\n        \\n        while(low < high){\\n            int sum = numbers[low] + numbers[high];\\n            if(sum == target)\\n                return new int[]{low+1, high+1};\\n            \\n            else if(sum < target)\\n                low++;\\n            \\n            else\\n                high--;\\n        }\\n        \\n        return new int[]{-1};\\n    }\\n}\\n```\\n\\n***UP-VOTE IF HELPFUL***",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0;\\n        int high = numbers.length - 1;\\n        \\n        while(low < high){\\n            int sum = numbers[low] + numbers[high];\\n            if(sum == target)\\n                return new int[]{low+1, high+1};\\n            \\n            else if(sum < target)\\n                low++;\\n            \\n            else\\n                high--;\\n        }\\n        \\n        return new int[]{-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642733,
                "title": "python-two-simple-approaches-binary-search-two-pointers",
                "content": "\\t# Two Pointers Solution\\n\\t# Time O(n)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tstrt = 0\\n\\t\\t\\tend = len(arr)-1\\n\\t\\t\\twhile strt <= end:\\n\\t\\t\\t\\tsum = arr[strt]+arr[end]\\n\\t\\t\\t\\tif sum == target:\\n\\t\\t\\t\\t\\treturn [strt+1, end+1]\\n\\t\\t\\t\\telif sum < target:\\n\\t\\t\\t\\t\\tstrt += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend -= 1\\n\\n\\n\\t# Binary Search Solution\\n\\t# Time: O(nlogn)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tfor idx in range(len(arr)):  # O(n)\\n\\t\\t\\t\\tnew_target = target-arr[idx]\\n\\t\\t\\t\\tlft, rght = idx+1, len(arr)-1\\n\\t\\t\\t\\twhile lft <= rght:  # O(logn)\\n\\t\\t\\t\\t\\tmid = lft+(rght-lft)//2\\n\\t\\t\\t\\t\\tif arr[mid] == new_target:\\n\\t\\t\\t\\t\\t\\treturn [idx+1, mid+1]\\n\\t\\t\\t\\t\\telif arr[mid] > new_target:\\n\\t\\t\\t\\t\\t\\trght = mid-1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tlft = mid+1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "\\t# Two Pointers Solution\\n\\t# Time O(n)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tstrt = 0\\n\\t\\t\\tend = len(arr)-1\\n\\t\\t\\twhile strt <= end:\\n\\t\\t\\t\\tsum = arr[strt]+arr[end]\\n\\t\\t\\t\\tif sum == target:\\n\\t\\t\\t\\t\\treturn [strt+1, end+1]\\n\\t\\t\\t\\telif sum < target:\\n\\t\\t\\t\\t\\tstrt += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend -= 1\\n\\n\\n\\t# Binary Search Solution\\n\\t# Time: O(nlogn)\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, arr: List[int], target: int) -> List[int]:\\n\\t\\t\\tfor idx in range(len(arr)):  # O(n)\\n\\t\\t\\t\\tnew_target = target-arr[idx]\\n\\t\\t\\t\\tlft, rght = idx+1, len(arr)-1\\n\\t\\t\\t\\twhile lft <= rght:  # O(logn)\\n\\t\\t\\t\\t\\tmid = lft+(rght-lft)//2\\n\\t\\t\\t\\t\\tif arr[mid] == new_target:\\n\\t\\t\\t\\t\\t\\treturn [idx+1, mid+1]\\n\\t\\t\\t\\t\\telif arr[mid] > new_target:\\n\\t\\t\\t\\t\\t\\trght = mid-1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tlft = mid+1",
                "codeTag": "Java"
            },
            {
                "id": 51324,
                "title": "0ms-java-solution-binary-search-with-detailed-comment-share-you-opinion",
                "content": "```\\npublic class Solution {\\n    /*\\n     Idea: keep updating boundaries using binary search.\\n     \\n     Method: \\n     1) fix lower number and find the target upper number\\n        e.g. intilize lower = numbers[0], then our goal is to find the \"right\" index of upper bound which value \\n        is <= (target - lower)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign the \"upper\" number to numbers[right], go to step 2;\\n     2) fix the upper number and find the target lower number \\n        e.g. lower = target - upper, our goal is to find the \"left\" index of lower bound which value is >= (target - upper)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign lower to the number[left], repeat step 1 and 2, because we are guranteed to have an answer\\n    \\n    remark:\\n        Every time we update the upper value, it will be smaller than its previous value\\n        Every time we update the lower value, it will be bigger than its previous value\\n        Since this array is sorted in ascending order, the range of binary search is getting smaller each time.\\n        \\n    performance: O(logn)\\n                 real time: 0 ms\\n     */\\n    public int[] twoSum(int[] numbers, int target) {\\n        boolean isSmall = false;\\n        long small = numbers[0];\\n        long big = target - small;\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (true) {\\n            if (isSmall) {\\n                isSmall = false;\\n                left = binarySearch(numbers, left, right - 1, small);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    small = numbers[++left];\\n                    big = target - small;\\n                }\\n            } else {\\n                isSmall = true;\\n                right = binarySearch(numbers, left + 1, right, big);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    big = numbers[right];\\n                    small = target - big;\\n                }\\n            }\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n    \\n    public int binarySearch(int[] nums, int l, int r, long target) {\\n        int left = l;\\n        int right = r;\\n        while (left < right) {\\n            int mid = right + (left - right) / 2;\\n            if (nums[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /*\\n     Idea: keep updating boundaries using binary search.\\n     \\n     Method: \\n     1) fix lower number and find the target upper number\\n        e.g. intilize lower = numbers[0], then our goal is to find the \"right\" index of upper bound which value \\n        is <= (target - lower)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign the \"upper\" number to numbers[right], go to step 2;\\n     2) fix the upper number and find the target lower number \\n        e.g. lower = target - upper, our goal is to find the \"left\" index of lower bound which value is >= (target - upper)\\n        i) if lower + upper = target, we got the answer\\n        ii) if not, assign lower to the number[left], repeat step 1 and 2, because we are guranteed to have an answer\\n    \\n    remark:\\n        Every time we update the upper value, it will be smaller than its previous value\\n        Every time we update the lower value, it will be bigger than its previous value\\n        Since this array is sorted in ascending order, the range of binary search is getting smaller each time.\\n        \\n    performance: O(logn)\\n                 real time: 0 ms\\n     */\\n    public int[] twoSum(int[] numbers, int target) {\\n        boolean isSmall = false;\\n        long small = numbers[0];\\n        long big = target - small;\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (true) {\\n            if (isSmall) {\\n                isSmall = false;\\n                left = binarySearch(numbers, left, right - 1, small);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    small = numbers[++left];\\n                    big = target - small;\\n                }\\n            } else {\\n                isSmall = true;\\n                right = binarySearch(numbers, left + 1, right, big);\\n                if (numbers[left] + numbers[right] == target) {\\n                    break;\\n                } else {\\n                    big = numbers[right];\\n                    small = target - big;\\n                }\\n            }\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n    \\n    public int binarySearch(int[] nums, int l, int r, long target) {\\n        int left = l;\\n        int right = r;\\n        while (left < right) {\\n            int mid = right + (left - right) / 2;\\n            if (nums[mid] > target) {\\n                right = mid - 1;\\n            } else {\\n                left = mid;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51383,
                "title": "java-hashmap-and-two-pointer-solution",
                "content": "        \\n    public int[] twoSum1(int[] numbers, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] ret = new int[2];\\n        for (int i = 0; i < numbers.length; i++) {\\n            if (map.containsKey(target-numbers[i])) {\\n                ret[0] = map.get(target-numbers[i]) + 1;\\n                ret[1] = i+1;\\n                break;\\n            }\\n            map.put(numbers[i], i);\\n        }\\n        return ret;\\n    }\\n    \\n    // two-pointer method\\n    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length-1;\\n        int[] ret = new int[2];\\n        while (l < r) {\\n            int sum = numbers[l] + numbers[r];\\n            if (sum > target) \\n                r--;\\n            else if (sum < target) \\n                l++;\\n            else {\\n                ret[0] = l+1;\\n                ret[1] = r+1;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        \\n    public int[] twoSum1(int[] numbers, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] ret = new int[2];\\n        for (int i = 0; i < numbers.length; i++) {\\n            if (map.containsKey(target-numbers[i])) {\\n                ret[0] = map.get(target-numbers[i]) + 1;\\n                ret[1] = i+1;\\n                break;\\n            }\\n            map.put(numbers[i], i);\\n        }\\n        return ret;\\n    }\\n    \\n    // two-pointer method\\n    public int[] twoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.length-1;\\n        int[] ret = new int[2];\\n        while (l < r) {\\n            int sum = numbers[l] + numbers[r];\\n            if (sum > target) \\n                r--;\\n            else if (sum < target) \\n                l++;\\n            else {\\n                ret[0] = l+1;\\n                ret[1] = r+1;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3338300,
                "title": "three-unique-approaches-using-binary-search-two-pointers-hashmap",
                "content": "# Using HashMap\\n```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(N)\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        unordered_map<int,pair<int,bool>>check;//pair.first=index,pair.second=existence\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(check[nums[i]].second)\\n            {\\n                return {check[nums[i]].first+1,i+1};\\n            }\\n            else\\n            {\\n                check[target-nums[i]].second=true;\\n                check[target-nums[i]].first=i;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\\n# Using Binary Search\\n```\\nclass Solution {\\npublic:\\n    //TC:-O(NLOGN),SC:-O(1)\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n            {\\n                return {i+1,j+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\\n# Using Two-Pointers\\n```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(1)\\n    vector<int>twoSum(vector<int>&numbers,int target) \\n    {\\n        int left=0,right=numbers.size()-1;\\n        while(left<=right)   \\n        {\\n            if((numbers[left]+numbers[right])>target)\\n            {\\n                right--;\\n            }\\n            else if((numbers[left]+numbers[right])<target)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                return {left+1,right+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(N)\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        unordered_map<int,pair<int,bool>>check;//pair.first=index,pair.second=existence\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(check[nums[i]].second)\\n            {\\n                return {check[nums[i]].first+1,i+1};\\n            }\\n            else\\n            {\\n                check[target-nums[i]].second=true;\\n                check[target-nums[i]].first=i;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //TC:-O(NLOGN),SC:-O(1)\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n            {\\n                right=mid-1;\\n            }\\n            else if(nums[mid]<target)\\n            {\\n                left=mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n            {\\n                return {i+1,j+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //TC:-O(N),SC:-O(1)\\n    vector<int>twoSum(vector<int>&numbers,int target) \\n    {\\n        int left=0,right=numbers.size()-1;\\n        while(left<=right)   \\n        {\\n            if((numbers[left]+numbers[right])>target)\\n            {\\n                right--;\\n            }\\n            else if((numbers[left]+numbers[right])<target)\\n            {\\n                left++;\\n            }\\n            else\\n            {\\n                return {left+1,right+1};\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131110,
                "title": "c-easy-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target)\\n    {\\n        int n = numbers.size();\\n        int i=0;\\n\\t\\tint j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)   \\n                return vector<int>{i+1,j+1};\\n            else if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return vector<int>{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target)\\n    {\\n        int n = numbers.size();\\n        int i=0;\\n\\t\\tint j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)   \\n                return vector<int>{i+1,j+1};\\n            else if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return vector<int>{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674602,
                "title": "java-simple-code-to-find-two-sum-ii-input-array-is-sorted-beats-99",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i = 0, j = numbers.length - 1;\\n        while(i <  j){\\n            if(numbers[i] + numbers[j] == target){\\n                return new int[]{i + 1, j + 1};\\n            }else if(numbers[i] + numbers[j] > target){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return new int [] {-1,-1};\\n    }\\n}\\n```\\n\\n## **If you find this helpful, please upvote \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i = 0, j = numbers.length - 1;\\n        while(i <  j){\\n            if(numbers[i] + numbers[j] == target){\\n                return new int[]{i + 1, j + 1};\\n            }else if(numbers[i] + numbers[j] > target){\\n                j--;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return new int [] {-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437444,
                "title": "simple-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe solution provided uses a two-pointer approach where a `low` pointer and a `high` pointer are initialized at the start and end of the array respectively. \\n\\nThen, a while loop is used to iterate through the array, and in each iteration, the `sum` of the values at the `low` and `high` pointers is computed. If the `sum` is equal to the `target`, the indices of the numbers are returned as an integer array. If the `sum` is less than the `target`, the `low` pointer is incremented to move towards larger values, and if the `sum` is greater than the `target`, the `high` pointer is decremented to move towards smaller values.\\n\\nThis approach works because the array is sorted, and by moving the `low` and `high` pointers based on the `sum` of their values, we can find the two numbers that add up to the `target`. Since the problem statement guarantees that there is exactly one solution, the while loop will always terminate with the correct indices being returned.\\n\\n# Complexity\\nThis solution has a *time complexity* of $$O(n)$$ since we only make a single pass through the array, and a *space complexity* of $$O(1)$$ since we are only using a constant amount of extra space to store the `low` and `high` pointers.\\n\\n# Code\\n```swift\\nclass Solution {\\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        var low = 0\\n        var high = numbers.count - 1\\n\\n        while low <= high {\\n            var sum = numbers[low] + numbers[high]\\n            if sum == target {\\n                return [low + 1, high + 1]\\n            } else if sum < target {\\n                low += 1\\n            } else {\\n                high -= 1\\n            }\\n        }\\n\\n        return []\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/f546f2e6-a477-40fa-9e19-41d654a3259f_1681980418.1320105.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        var low = 0\\n        var high = numbers.count - 1\\n\\n        while low <= high {\\n            var sum = numbers[low] + numbers[high]\\n            if sum == target {\\n                return [low + 1, high + 1]\\n            } else if sum < target {\\n                low += 1\\n            } else {\\n                high -= 1\\n            }\\n        }\\n\\n        return []\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712770,
                "title": "java-easy-99-o-n-solution-w-o-1-space-with-example",
                "content": "//Time complexity: O(n). The input array is traversed at most once.\\n//Space complexity: O(1). We use constant space to store two indices and the sum.\\n//Brute force would be O(n^2) but taking adavantage of the sorting, we know that lowest value will be leftmost and highest will be rightmost.\\n\\n\\nclass Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int left=0,right=numbers.length-1;\\n        \\n        while(left<right)\\n        {\\n            int sum=numbers[left]+numbers[right];\\n            if(sum==target)\\n                return new int[]{left+1,right+1};\\n            else if(sum>target)\\n                right--;\\n            else if(sum<target)\\n                left++;\\n        }\\n        return new int[]{};\\n    }\\n}\\n\\n\\n\\n//Example here:\\n\\n    1   3   4   5   7   11\\n    L                   R           sum = 1+11=12  > 9, so R--.\\n    If we increase L, we will get 3+11 which is much greater than target(9) so that would be wrong.\\n    Hence, we have to go backwards, i.e. R--, to decrease sum.\\n\\n    1   3   4   5   7   11\\n    L               R               sum=1+7=8  < 9, so L++. (Because we need to increase sum)\\n\\n    1   3   4   5   7   11\\n        L           R               sum=3+7=10  > 9, R--.  \\n\\n    1   3   4   5   7   11\\n        L       R                   sum=3+5=8  < 9, L++.\\n\\n    1   3   4   5   7   11\\n            L   R                   sum=4+5=9  == 9, Return.\\n\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int left=0,right=numbers.length-1;\\n        \\n        while(left<right)\\n        {\\n            int sum=numbers[left]+numbers[right];\\n            if(sum==target)\\n                return new int[]{left+1,right+1}",
                "codeTag": "Java"
            },
            {
                "id": 2130001,
                "title": "c-two-pointers-approach-o-n-time-constant-space",
                "content": "Just take 2 pointers , one at starting index of the array , another at the end index of the array.\\nNow check - \\n\\t\\t~~ if the two numbers at both index sums up target or not. If yes then return (both indexes+1)[as array is 1-indexed]\\n\\t\\t~~ If it is more than the target then decrease the last pointer. \\n\\t\\t~~ If it is less than the target then increase the first pointer.\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0;\\n        int j=numbers.size()-1;\\n        vector<int>satwik;\\n        \\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target) j--;\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else\\n            {\\n                satwik.push_back(i+1);\\n                satwik.push_back(j+1);\\n                break;\\n            }\\n        }\\n        \\n        return satwik;\\n    }\\n};\\n\\n```\\n\\nDO UPVOTE IF YOU LIKE IT :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0;\\n        int j=numbers.size()-1;\\n        vector<int>satwik;\\n        \\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target) j--;\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else\\n            {\\n                satwik.push_back(i+1);\\n                satwik.push_back(j+1);\\n                break;\\n            }\\n        }\\n        \\n        return satwik;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709242,
                "title": "java-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] result = new int[2];\\n        int start = 0, end = numbers.length - 1;\\n        while(start < end) {\\n            if(numbers[start] + numbers[end] == target) {\\n                result[0] = start + 1;\\n                result[1] = end + 1;\\n                break;\\n            } else if(numbers[start] + numbers[end] > target)\\n                end--;\\n            else\\n                start++;\\n        }\\n        return result;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] result = new int[2];\\n        int start = 0, end = numbers.length - 1;\\n        while(start < end) {\\n            if(numbers[start] + numbers[end] == target) {\\n                result[0] = start + 1;\\n                result[1] = end + 1;\\n                break;\\n            } else if(numbers[start] + numbers[end] > target)\\n                end--;\\n            else\\n                start++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464747,
                "title": "javascript-two-pointers-approach",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n\\n    let left = 0;\\n    let right = numbers.length - 1;\\n\\n    while (left < right) {\\n        let sum = numbers[left] + numbers[right];\\n        if (sum === target) {\\n            return [left + 1, right + 1];\\n        } else if (sum > target) {\\n            right--;\\n        } else {\\n            left++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n\\n    let left = 0;\\n    let right = numbers.length - 1;\\n\\n    while (left < right) {\\n        let sum = numbers[left] + numbers[right];\\n        if (sum === target) {\\n            return [left + 1, right + 1];\\n        } else if (sum > target) {\\n            right--;\\n        } else {\\n            left++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082998,
                "title": "python-multiple-solutions-for-beginners-with-explanation-brute-dictionary-2-pointers",
                "content": "This question is quite similar to question 1 of leet code . The noticiable differences are that this array is sorted whereas the array in question 1 was not. \\n\\n```\\n\\n# Brute force - This solution did not work for me due to max time met. This will work on a simple/smaller array but not on a 1000 number array. And hence the timeout during code submission.  \\n\\nclass Solution(object):\\n    def twoSum(self, nums, target):        \\n        for i in range(len(nums)): # First traversal loop\\n            for j in range(i+1, len(nums)): # Starting 2nd loop with i+1 since numbers in the array are unique per the conditions \\n                if (nums[i]+nums[j]) == target: \\n                    return[i+1,j+1] # Adding 1 to each variable since the return type is 1 indexed instead of 0 indexed. \\n\\n# Using Dictionary / map - What I am doing is trying to create a dictionary such that at one point one of the numbers in nums will add upto target when added to dictionary element. If nums is [1,2,3,4,5] and target is 6, then d will become d {1:0} on first iteration and d {1:0, 2:1} on second and so on. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        d = {} # Defining a null dictionary which we will build with each iteration\\n        for i in range(len(nums)): # I found it easier and more understandable to use range instead of enumerate since this is an easy question. \\n            m = target - nums[i] \\n            if m in d:\\n                return [d[m]+1, i+1] # Adding 1 since its 1 indexed instead of default 0 indexed\\n            else:\\n                d[nums[i]] = i # Building up the dictionary\\n\\n\\n# Using 2 pointers - In this approach, I am basically taking 1st and last number of the array and adding them to see if it equals the target. If the sum is bigger than target, then I need to reduce the sum. This is only possible by reducing the last number as the array is sorted. If the sum is smaller then target, then i need to increase the sum. THis is only possible by increasing the first number as the array is sorted. I keep doing so until my lower number is less than upper number. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        l = 0\\n        r = len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target:\\n                return [l+1, r+1]\\n            if nums[l] + nums[r] > target:\\n                r = r - 1\\n            if nums[l] + nums[r] < target:\\n                l = l + 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\n\\n# Brute force - This solution did not work for me due to max time met. This will work on a simple/smaller array but not on a 1000 number array. And hence the timeout during code submission.  \\n\\nclass Solution(object):\\n    def twoSum(self, nums, target):        \\n        for i in range(len(nums)): # First traversal loop\\n            for j in range(i+1, len(nums)): # Starting 2nd loop with i+1 since numbers in the array are unique per the conditions \\n                if (nums[i]+nums[j]) == target: \\n                    return[i+1,j+1] # Adding 1 to each variable since the return type is 1 indexed instead of 0 indexed. \\n\\n# Using Dictionary / map - What I am doing is trying to create a dictionary such that at one point one of the numbers in nums will add upto target when added to dictionary element. If nums is [1,2,3,4,5] and target is 6, then d will become d {1:0} on first iteration and d {1:0, 2:1} on second and so on. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        d = {} # Defining a null dictionary which we will build with each iteration\\n        for i in range(len(nums)): # I found it easier and more understandable to use range instead of enumerate since this is an easy question. \\n            m = target - nums[i] \\n            if m in d:\\n                return [d[m]+1, i+1] # Adding 1 since its 1 indexed instead of default 0 indexed\\n            else:\\n                d[nums[i]] = i # Building up the dictionary\\n\\n\\n# Using 2 pointers - In this approach, I am basically taking 1st and last number of the array and adding them to see if it equals the target. If the sum is bigger than target, then I need to reduce the sum. This is only possible by reducing the last number as the array is sorted. If the sum is smaller then target, then i need to increase the sum. THis is only possible by increasing the first number as the array is sorted. I keep doing so until my lower number is less than upper number. \\n\\nclass Solution:\\n    def twoSum(self, nums, target):\\n        l = 0\\n        r = len(nums) - 1\\n        while l < r:\\n            if nums[l] + nums[r] == target:\\n                return [l+1, r+1]\\n            if nums[l] + nums[r] > target:\\n                r = r - 1\\n            if nums[l] + nums[r] < target:\\n                l = l + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249291,
                "title": "two-pointer-beat-100",
                "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        p1 = 0\\n        p2 = len(numbers) - 1\\n        while p2 > p1:\\n            if numbers[p1] + numbers[p2] < target:\\n                p1 += 1\\n            elif numbers[p1] + numbers[p2] > target:\\n                p2 -= 1\\n            elif numbers[p1] + numbers[p2] == target:\\n                return [p1 + 1, p2 + 1]\\n        else:\\n            return None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        p1 = 0\\n        p2 = len(numbers) - 1\\n        while p2 > p1:\\n            if numbers[p1] + numbers[p2] < target:\\n                p1 += 1\\n            elif numbers[p1] + numbers[p2] > target:\\n                p2 -= 1\\n            elif numbers[p1] + numbers[p2] == target:\\n                return [p1 + 1, p2 + 1]\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244738,
                "title": "go-faster-than-100-memory-less-than-100",
                "content": "```go\\nfunc twoSum(numbers []int, target int) []int {\\n    i, j := 0, len(numbers) - 1\\n    sum := numbers[i] + numbers[j]\\n    \\n    for sum != target {\\n        if sum < target {\\n            i++\\n        } else {\\n            j--\\n        }\\n        \\n        sum = numbers[i] + numbers[j]\\n    }\\n    \\n    return []int{i + 1, j + 1}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc twoSum(numbers []int, target int) []int {\\n    i, j := 0, len(numbers) - 1\\n    sum := numbers[i] + numbers[j]\\n    \\n    for sum != target {\\n        if sum < target {\\n            i++\\n        } else {\\n            j--\\n        }\\n        \\n        sum = numbers[i] + numbers[j]\\n    }\\n    \\n    return []int{i + 1, j + 1}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51250,
                "title": "real-binary-search-approach-with-one-loop",
                "content": "Some existing posts only used binary search for one value, and their algorithm could be described as following: \\n```\\nfor(i = 0; i < nums; i++)\\n   num1 = nums[i]; \\n   num2 = target - num1;\\n   binary search num2 in nums[i:], if found, return the index of num1, num2\\n```\\nTheir approach actually takes O(nlogn) time. The worst case is num1 and num2 is the center. It takes log(n-1)+log(n-2)+..log(n/2) ~ nlogn\\n\\nMy idea only used one loop. The worst case is: \\n- the input arry contains same values, or\\n- num1 and num2 is in the center\\nso every time we move the cursor by 1, which takes O(n).In other cases my approach is faster than linear scan.\\n\\nWe could start with left = 0, right = nums.size()-1, and mid = (left+right)/2. \\nSince the input vector is sorted, we know nums[left] < nums[mid] < nums[right], so that\\uff1a  **nums[left] + nums[mid] < nums[left] + nums[right] < nums[mid] + nums[right].** \\n\\nIf nums[left] + nums[mid] > target, the 2 number we are looking for must be within nums[left:mid-1]. Similarly, if nums[right] + nums[mid] < target, the 2 number we are looking for must be within nums[mid+1:right]. \\n\\nFollowing is an accepted C++ implemetaion. \\n\\n ```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int left = 0, right = numbers.size()-1; \\n        vector<int> ret; \\n        while (left < right){\\n            int mid = left + (right-left)/2; \\n            int sum = numbers[left] + numbers[right]; \\n            if (sum == target){\\n                ret.push_back(left+1); \\n                ret.push_back(right+1); \\n                break; \\n            }\\n            else if (sum < target){\\n                left = (numbers[mid] + numbers[right] < target)?mid:left+1;\\n            }else{\\n                right = (numbers[mid] + numbers[left] > target)?mid:right-1;\\n            }\\n           \\n        }\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nfor(i = 0; i < nums; i++)\\n   num1 = nums[i]; \\n   num2 = target - num1;\\n   binary search num2 in nums[i:], if found, return the index of num1, num2\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int left = 0, right = numbers.size()-1; \\n        vector<int> ret; \\n        while (left < right){\\n            int mid = left + (right-left)/2; \\n            int sum = numbers[left] + numbers[right]; \\n            if (sum == target){\\n                ret.push_back(left+1); \\n                ret.push_back(right+1); \\n                break; \\n            }\\n            else if (sum < target){\\n                left = (numbers[mid] + numbers[right] < target)?mid:left+1;\\n            }else{\\n                right = (numbers[mid] + numbers[left] > target)?mid:right-1;\\n            }\\n           \\n        }\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162858,
                "title": "c-easy-beginner-friendly-solution",
                "content": "# Intuition\\nFirstly, we will deduce that the number of searching steps should not be too large, as it will give TLE.\\n\\n# Approach\\n- We will use two pointers, to travere the array.\\n- First pointer will be placed at first element and the second pointer will be placed at the last element.\\n- If sum of two numbers is greater than the target value then decrease the second pointer and if value is smaller then increase the first pointer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i = 0;\\n        int j = numbers.size()-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            if(numbers[i]+numbers[j]==target)\\n                return {i+1,j+1};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i = 0;\\n        int j = numbers.size()-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]>target)\\n                j--;\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            if(numbers[i]+numbers[j]==target)\\n                return {i+1,j+1};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030492,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> I used two pointers right and left to solve this problem.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int right = numbers.size() - 1;\\n        int left = 0;\\n        while (left < right){\\n            if(numbers[right] + numbers[left] == target){\\n                return {left + 1,right + 1};\\n            }\\n            else if(numbers[right] + numbers[left] < target){\\n                left++;\\n            }\\n            else{\\n                right--;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int right = numbers.size() - 1;\\n        int left = 0;\\n        while (left < right){\\n            if(numbers[right] + numbers[left] == target){\\n                return {left + 1,right + 1};\\n            }\\n            else if(numbers[right] + numbers[left] < target){\\n                left++;\\n            }\\n            else{\\n                right--;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834204,
                "title": "c-different-solutions-brute-force-hash-map-binary-search-2pointer-approach",
                "content": "```\\n//Sorry for interrupting.....please please upvote if you feel its worth giving \\uD83D\\uDC3C\\n//\\uD83D\\uDE42\\n//Always know the Brute-Force Approach............rest will get a lot easier\\uD83D\\uDE0A\\u270C\\uFE0F...\\n//brute-force approach......................................\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) \\n    {\\n```\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]+nums[j]==target)\\n                {\\n                    return {i,j};\\n                }\\n            }\\n        }\\n    return {};\\n        \\n    }\\n`};`\\n\\n```\\n//Map solution simple.......................................\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& arr, int t) {\\n        unordered_map<int,int> mp;\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(t-arr[i]))\\n            {\\n                ans.push_back(mp[t-arr[i]]+1);\\n                ans.push_back(i+1);\\n            }\\n            else\\n                mp[arr[i]]=i;\\n        }\\n    return ans;      \\n    }\\n};\\n```\\n\\n```\\n// 2 pointer approach for sorted array.......................\\n vector<int> twoSum(vector<int>& arr, int target) {\\n```\\n    \\n    int l = 0;\\n    int r = arr.size() -1;\\n   \\n    while(l < r){\\n        if(arr[l] + arr[r] == target){\\n           \\n            return {l+1,r+1};;\\n        }\\n        else if(arr[l] + arr[r] > target){\\n            r--;\\n        }\\n        else{\\n            l++;\\n        }\\n    }\\n\\treturn {};\\n}\\n\\n```\\n// binary-search approach.............................\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int i, int key) \\n    {\\n        int l=i+1,mid,h=arr.size()-1;\\n```\\n        \\n        while(l<=h)\\n        {\\n            mid=(l+h)/2;//[l+(h-l)]/2\\n            if(key==arr[mid])\\n                return mid;\\n            else if(key<arr[mid])\\n                h=mid-1;\\n            else\\n                l=mid+1;\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>& arr, int t) \\n    {\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(search(arr,i, t-arr[i])!=-1)\\n            {\\n                ans.push_back(i+1);\\n                ans.push_back(search(arr,i, t-arr[i])+1);\\n                break;\\n            }\\n            \\n        }\\n        if(ans.size()==1)\\n            return {-1};\\n    return ans;      \\n    }\\n`};`\\n```\\n//2 sum is a good level question. It covers a lot of concepts. \\n//Hope you got a good vibe\\uD83C\\uDF41\\uD83C\\uDF42\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n//Sorry for interrupting.....please please upvote if you feel its worth giving \\uD83D\\uDC3C\\n//\\uD83D\\uDE42\\n//Always know the Brute-Force Approach............rest will get a lot easier\\uD83D\\uDE0A\\u270C\\uFE0F...\\n//brute-force approach......................................\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) \\n    {\\n```\n```\\n//Map solution simple.......................................\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& arr, int t) {\\n        unordered_map<int,int> mp;\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(mp.count(t-arr[i]))\\n            {\\n                ans.push_back(mp[t-arr[i]]+1);\\n                ans.push_back(i+1);\\n            }\\n            else\\n                mp[arr[i]]=i;\\n        }\\n    return ans;      \\n    }\\n};\\n```\n```\\n// 2 pointer approach for sorted array.......................\\n vector<int> twoSum(vector<int>& arr, int target) {\\n```\n```\\n// binary-search approach.............................\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int i, int key) \\n    {\\n        int l=i+1,mid,h=arr.size()-1;\\n```\n```\\n//2 sum is a good level question. It covers a lot of concepts. \\n//Hope you got a good vibe\\uD83C\\uDF41\\uD83C\\uDF42\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627937,
                "title": "simple-java-solution-100-faster",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0,j=numbers.length-1;\\n        while(i<j){\\n            int sum = numbers[i]+numbers[j];\\n            if(sum==target)\\n               return new int[]{i+1,j+1};\\n            else if(sum<target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return new int[2];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0,j=numbers.length-1;\\n        while(i<j){\\n            int sum = numbers[i]+numbers[j];\\n            if(sum==target)\\n               return new int[]{i+1,j+1}",
                "codeTag": "Java"
            },
            {
                "id": 1456219,
                "title": "java-binary-search-with-explanation-o-logn",
                "content": "I followed what @samuelkanezhao2 said [here](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51268/A-less-efficient-way-(binary-search)/255594)\\n\\nFirst, set the two pointers `i` to index `0` and `j` to index `length - 1` respectively.\\nIf the sum of `i + j` is greater than the target, find the biggest number that is smaller than ```target - numbers[left]```\\n1. \\tFirst, check if the number on the left of the right pointer is smaller than ```target - numbers[left]```. If it is, then move the right pointer one to the left.\\n2. \\tHowever, if it is not, then use binary search to find the biggest number smaller than ```target - numbers[left]```.\\n\\nOn the other hand, if the sum is smaller than the target, then find the smallest number that is larger than ```target - nums[right]```\\n1. Check if the number on the right of the left pointer is greater than ```target - nums[right]```. If it is, move the left pointer one to the right.\\n2.  However, if it is not, then use binary search to find the smallest number that is larger than ```target - nums[right]```.\\n\\nIn this way, the average case would be O(logn), since we divide by half every time. However, the worst case scenario would be O(n), if the pointers have to move by 1 every single time. \\n\\n**Note** that it is not doing binary search for *every* move, but only for moves where the number to the left of the right pointer OR the number to the right of the left pointer do not fulfill the condition.\\n \\nIf you didn\\'t understand, maybe checking [@samuelkanezhao2\\'s explanation](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/discuss/51268/A-less-efficient-way-(binary-search)/255594) might help\\n\\n```\\npublic int[] twoSum(int[] numbers, int target) {\\n    int l = 0, r = numbers.length - 1;\\n    while (numbers[l] + numbers[r] != target) {\\n        if (numbers[l] + numbers[r] > target) {\\n            if (numbers[r - 1] > target - numbers[l])\\n                r = binarySearch(numbers, l + 1, r - 1, target - numbers[l]);\\n            else\\n                r--;\\n        } \\n\\t\\telse {\\n            if (numbers[l + 1] < target - numbers[r])\\n                l = binarySearch(numbers, l + 1, r - 1, target - numbers[r]);\\n            else\\n                l++;\\n        }\\n    }\\n    return new int[] { l + 1, r + 1 };\\n}\\n\\nprivate int binarySearch(int[] nums, int lo, int hi, int target) {\\n    int mid = (lo + hi) / 2;\\n    if (hi <= lo)\\n        return mid;\\n    if (nums[mid] == target)\\n        return mid;\\n    else if (nums[mid] > target)\\n        return binarySearch(nums, lo, (mid - 1), target);\\n    else if (nums[mid] < target)\\n        return binarySearch(nums, (mid + 1), hi, target);\\n    return mid;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```target - numbers[left]```\n```target - numbers[left]```\n```target - numbers[left]```\n```target - nums[right]```\n```target - nums[right]```\n```target - nums[right]```\n```\\npublic int[] twoSum(int[] numbers, int target) {\\n    int l = 0, r = numbers.length - 1;\\n    while (numbers[l] + numbers[r] != target) {\\n        if (numbers[l] + numbers[r] > target) {\\n            if (numbers[r - 1] > target - numbers[l])\\n                r = binarySearch(numbers, l + 1, r - 1, target - numbers[l]);\\n            else\\n                r--;\\n        } \\n\\t\\telse {\\n            if (numbers[l + 1] < target - numbers[r])\\n                l = binarySearch(numbers, l + 1, r - 1, target - numbers[r]);\\n            else\\n                l++;\\n        }\\n    }\\n    return new int[] { l + 1, r + 1 };\\n}\\n\\nprivate int binarySearch(int[] nums, int lo, int hi, int target) {\\n    int mid = (lo + hi) / 2;\\n    if (hi <= lo)\\n        return mid;\\n    if (nums[mid] == target)\\n        return mid;\\n    else if (nums[mid] > target)\\n        return binarySearch(nums, lo, (mid - 1), target);\\n    else if (nums[mid] < target)\\n        return binarySearch(nums, (mid + 1), hi, target);\\n    return mid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 147238,
                "title": "python-two-pointer-beats-99-56",
                "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        i = 0\\n        j = len(numbers)-1\\n        while i<j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i+1,j+1]\\n            elif numbers[i] + numbers[j] > target:\\n                j-= 1\\n            else:\\n                i += 1\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        i = 0\\n        j = len(numbers)-1\\n        while i<j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i+1,j+1]\\n            elif numbers[i] + numbers[j] > target:\\n                j-= 1\\n            else:\\n                i += 1\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576789,
                "title": "simple-java-solution-runtime-1ms-beats-99",
                "content": "# Approach\\nHere\\'s a step-by-step explanation of the code:\\n\\n1. The code defines a class called `Solution` with a single method `twoSum`, which takes an array of integers `numbers` and a target integer `target` as input, and returns an array of two integers.\\n\\n2. Two integer variables `x` and `y` are declared and initialized. `x` is set to 0 (representing the start of the array), and `y` is set to the last index of the `numbers` array (representing the end of the array).\\n\\n3. The code enters a `while` loop that continues until `x` becomes greater than or equal to `y`. This loop is used to search for a pair of numbers in the array that add up to the target value.\\n\\n4. Inside the loop, it retrieves the integers at the `x`th and `y`th positions of the `numbers` array, and stores them in the variables `head` and `tail`, respectively.\\n\\n5. It checks if the sum of `head` and `tail` is equal to the target value. If it is, it means the current pair of numbers satisfies the condition, and the loop is exited using the `break` statement.\\n\\n6. If the sum of `head` and `tail` is greater than the target value, it means the current pair of numbers is too large. In this case, the variable `y` is decremented (moving to a smaller number), and the loop continues to the next iteration using the `continue` statement.\\n\\n7. If the sum of `head` and `tail` is less than the target value, it means the current pair of numbers is too small. In this case, the variable `x` is incremented (moving to a larger number).\\n\\n8. Once the loop ends, it means a pair of numbers that add up to the target value has been found, or the pointers `x` and `y` have crossed each other without finding a suitable pair.\\n\\n9. The code creates a new array with the two indices (`x` and `y`) increased by 1, and returns this array as the result. The indices are incremented by 1 because the problem statement assumes the indices are 1-based, while the code uses 0-based indices.\\n\\nIn simpler terms, the code searches for a pair of numbers in an array that add up to a given target value. It uses two pointers, one at the beginning and one at the end of the array, and adjusts the pointers based on the sum of the current pair of numbers compared to the target. If a suitable pair is found, it returns their indices incremented by 1.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int x = 0, y = numbers.length-1;\\n\\n        while (x<y){\\n            int head = numbers[x];\\n            int tail = numbers[y];\\n            if (head+tail == target){\\n                break;\\n            } else if (head+tail > target) {\\n                y--;\\n                continue;\\n            }\\n            else {\\n                x++;\\n            }\\n        }\\n        return new int[] {x+1, y+1};\\n    }\\n}\\n```\\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int x = 0, y = numbers.length-1;\\n\\n        while (x<y){\\n            int head = numbers[x];\\n            int tail = numbers[y];\\n            if (head+tail == target){\\n                break;\\n            } else if (head+tail > target) {\\n                y--;\\n                continue;\\n            }\\n            else {\\n                x++;\\n            }\\n        }\\n        return new int[] {x+1, y+1};\\n    }\\n}\\n```\n```\\nPlease upvote if you like the solution.\\nHappy Coding! \\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208849,
                "title": "167-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach here is to use two pointers to keep track of the two numbers in the array that add up to the target. We start with the left pointer at the beginning of the array and the right pointer at the end of the array. We then calculate the sum of the two numbers at the left and right pointers, and check if it is equal to the target. If it is, we return the indices of the two numbers (adding 1 to each index since the array is 1-indexed). If the sum is less than the target, we move the left pointer to the right to try a larger number. If the sum is greater than the target, we move the right pointer to the left to try a smaller number. We continue this process until we find the two numbers that add up to the target, or until the left pointer passes the right pointer, in which case there is no solution and we return [-1, -1]. Since we are only using constant extra space (just two pointers), this solution satisfies the space requirements of the problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n    left, right = 0, len(numbers) - 1\\n    while left < right:\\n        current_sum = numbers[left] + numbers[right]\\n        if current_sum == target:\\n            return [left+1, right+1]\\n        elif current_sum < target:\\n            left += 1\\n        else:\\n            right -= 1\\n    return [-1, -1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n  def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n    left, right = 0, len(numbers) - 1\\n    while left < right:\\n        current_sum = numbers[left] + numbers[right]\\n        if current_sum == target:\\n            return [left+1, right+1]\\n        elif current_sum < target:\\n            left += 1\\n        else:\\n            right -= 1\\n    return [-1, -1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190625,
                "title": "python-clean-simple-two-pointer-o-n-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Two Pointer Approach :\\n```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        left, right = 0, len(arr) - 1\\n\\n        while left < right:\\n            curr_sum = arr[left] + arr[right] \\n            if curr_sum == target:\\n                return [left + 1, right + 1]\\n            elif curr_sum < target:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n```\\n## Using dictionary :\\n```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        dic = {}\\n        for i in range(len(arr)):\\n            if target - arr[i] in dic:\\n                return [dic[target - arr[i]] + 1, i + 1]\\n            dic[arr[i]] = i\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        left, right = 0, len(arr) - 1\\n\\n        while left < right:\\n            curr_sum = arr[left] + arr[right] \\n            if curr_sum == target:\\n                return [left + 1, right + 1]\\n            elif curr_sum < target:\\n                left += 1\\n            else:\\n                right -= 1\\n\\n```\n```\\nclass Solution:\\n    def twoSum(self, arr: List[int], target: int) -> List[int]:\\n        dic = {}\\n        for i in range(len(arr)):\\n            if target - arr[i] in dic:\\n                return [dic[target - arr[i]] + 1, i + 1]\\n            dic[arr[i]] = i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720660,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    \\n    int left=0,right=numbers.length-1;\\n    \\n    while(left<right)\\n    {\\n        int sum=numbers[left]+numbers[right];\\n        if(sum==target)\\n            return new int[]{left+1,right+1};\\n        else if(sum>target)\\n            right--;\\n        else if(sum<target)\\n            left++;\\n    }\\n    return new int[]{};\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    \\n    int left=0,right=numbers.length-1;\\n    \\n    while(left<right)\\n    {\\n        int sum=numbers[left]+numbers[right];\\n        if(sum==target)\\n            return new int[]{left+1,right+1};\\n        else if(sum>target)\\n            right--;\\n        else if(sum<target)\\n            left++;\\n    }\\n    return new int[]{};\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645664,
                "title": "c-5-lines-of-code-easy-one-faster-than-98",
                "content": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int min = 0, max = numbers.Length - 1, temp = 0;\\n        while((numbers[min] + numbers[max]) != target)\\n            if((numbers[min] + numbers[max]) > target) max--;\\n            else min++;            \\n        return new int[]{min +1, max+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int min = 0, max = numbers.Length - 1, temp = 0;\\n        while((numbers[min] + numbers[max]) != target)\\n            if((numbers[min] + numbers[max]) > target) max--;\\n            else min++;            \\n        return new int[]{min +1, max+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865262,
                "title": "python-easy-solution-99-faster-solution",
                "content": "**Runtime**: 40 ms, faster than 99.20% of Python online submissions for Two Sum II - Input array is sorted.\\n**Memory Usage**: 13.5 MB, less than 5.23% of Python online submissions for Two Sum II - Input array is sorted.\\n\\n\\n```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dict = {}\\n        for i, e in enumerate(numbers):\\n            if e in dict: return (dict[e], i+1)\\n            dict[(target - e)] = i+1\\n        return list(dict)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dict = {}\\n        for i, e in enumerate(numbers):\\n            if e in dict: return (dict[e], i+1)\\n            dict[(target - e)] = i+1\\n        return list(dict)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625985,
                "title": "python-binary-search",
                "content": "Going from left to right, binary search to get the complement number. For example:\\n[2,7,11,15], target = 9. \\nWhen num =2, left index = 0. We binary seach the interval [7,11,15] with target = 7 (9 -2). Resulting index: right = 1.\\nIncrement both index for the answer.\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        def binarySearch(l, r, target):\\n            while l <= r:\\n                m = (l + r)//2\\n                if numbers[m] == target:\\n                    return m\\n                elif numbers[m] < target:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n            return -1\\n        \\n        for left, num in enumerate(numbers):\\n            right = binarySearch(left + 1, len(numbers)-1, target - num)\\n            if right != -1:\\n                return [left + 1, right + 1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        def binarySearch(l, r, target):\\n            while l <= r:\\n                m = (l + r)//2\\n                if numbers[m] == target:\\n                    return m\\n                elif numbers[m] < target:\\n                    l = m + 1\\n                else:\\n                    r = m - 1\\n            return -1\\n        \\n        for left, num in enumerate(numbers):\\n            right = binarySearch(left + 1, len(numbers)-1, target - num)\\n            if right != -1:\\n                return [left + 1, right + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278978,
                "title": "java-solution-0ms-beats-100-of-java-solutions-two-pointer",
                "content": "```\\npublic int[] twoSum(int[] numbers, int target) {\\n\\t\\tint left = 0, right = numbers.length - 1;\\n\\t\\twhile(left < right) {\\n\\t\\t\\tif(numbers[left] + numbers[right] == target)\\n\\t\\t\\t\\treturn new int[] {left + 1, right + 1};\\n\\t\\t\\telse if(numbers[left] + numbers[right] > target) right--;\\n\\t\\t\\telse left++;\\n\\t\\t}\\n\\t\\treturn new int[] {};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] twoSum(int[] numbers, int target) {\\n\\t\\tint left = 0, right = numbers.length - 1;\\n\\t\\twhile(left < right) {\\n\\t\\t\\tif(numbers[left] + numbers[right] == target)\\n\\t\\t\\t\\treturn new int[] {left + 1, right + 1};\\n\\t\\t\\telse if(numbers[left] + numbers[right] > target) right--;\\n\\t\\t\\telse left++;\\n\\t\\t}\\n\\t\\treturn new int[] {};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3417849,
                "title": "deep-and-easy-cheers",
                "content": "# Intuition\\nWe want to find two numbers in the input array that add up to the target value. We can use a two-pointer approach to iteratively narrow down the search range until we find a pair that adds up to the target.\\n\\n# Approach\\n1. Initialize two pointers \\'p1\\' and \\'p2\\' to point to the start and end of the input array, respectively.\\n2. While \\'p1\\' is less than \\'p2\\', calculate the sum of the two numbers at \\'p1\\' and \\'p2\\'.\\n3. If the sum is equal to the target, return the indices of the two numbers as an array.\\n4. If the sum is greater than the target, decrement \\'p2\\' to consider a smaller number at the end of the array.\\n5. If the sum is less than the target, increment \\'p1\\' to consider a larger number at the start of the array.\\n6. If no two numbers are found that add up to the target, return an empty array.\\n\\n# Complexity\\n- Time complexity: O(N), where N is the length of the input array \\'numbers\\'. The algorithm iterates at most N times through the while loop.\\n- Space complexity: O(1), since the algorithm uses only a constant amount of extra space for the two pointers \\'p1\\' and \\'p2\\'.\\n</br>\\n</br>\\n\\n> Please upvote\\u2B06\\uFE0F if find helpful, and feel free to ask if you have any doubt regarding approach and code in the comment section.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\n\\nvar twoSum = function (numbers, target) {\\n    let p1 = 0;\\n    let p2 = numbers.length - 1;\\n\\n    while (p1 < p2) {\\n        let sum = numbers[p1] + numbers[p2];\\n        if (sum === target) {\\n            return [p1 + 1, p2 + 1];\\n        } else if (sum > target) {\\n            p2--;\\n        } else {\\n            p1++;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\n\\nvar twoSum = function (numbers, target) {\\n    let p1 = 0;\\n    let p2 = numbers.length - 1;\\n\\n    while (p1 < p2) {\\n        let sum = numbers[p1] + numbers[p2];\\n        if (sum === target) {\\n            return [p1 + 1, p2 + 1];\\n        } else if (sum > target) {\\n            p2--;\\n        } else {\\n            p1++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3194241,
                "title": "very-simple-solution-detailed-explanation-time-o-n-c",
                "content": "# Intuition\\nAs array is already sorted, we can solve this using 2 pointer approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We know this array is already sorted so we can use 2 pointer approach.\\n1. Using 2 pointer approach. keep left pointer at start of the array and right pointer at the end of the array.\\n2. When we get 2 numbers which sum up to target, return them as an array by incrementing both left and right by 1.\\n3. If we don\\'t get the target then\\n    - If sum is less than target, then move the left pointer towards right. As array is already sorted, by moving the left pointer towards right we are increasing the sum value.\\n    - If sum is more than target, then move the right pointer towards left. So it will decrease the sum.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nSupport by upvoting the answer ! Thank you.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.Length-1;\\n        while(left < right){\\n            int sum = numbers[left] + numbers[right];\\n            if(sum == target) break;\\n            if(sum < target) left++;\\n            if(sum > target) right--;\\n        }\\n        return new int[] {left+1, right+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.Length-1;\\n        while(left < right){\\n            int sum = numbers[left] + numbers[right];\\n            if(sum == target) break;\\n            if(sum < target) left++;\\n            if(sum > target) right--;\\n        }\\n        return new int[] {left+1, right+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036152,
                "title": "java-1ms-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0;\\n        int j=numbers.length-1;\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n                return new int[]{i+1,j+1};\\n            }\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return new int[]{i+1,j+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int i=0;\\n        int j=numbers.length-1;\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n                return new int[]{i+1,j+1};\\n            }\\n            else if(numbers[i]+numbers[j]<target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return new int[]{i+1,j+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953790,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        int i=0, j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)\\n            return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n            else\\n            j--;\\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```\\nPlease UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        int i=0, j=n-1;\\n        while(i<j)\\n        {\\n            if(numbers[i]+numbers[j]==target)\\n            return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n            else\\n            j--;\\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205469,
                "title": "java-1ms-beats-99-in-time-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int start = 0, n = nums.length, end = n - 1;\\n        while (start <= end) {\\n            if (nums[start] + nums[end] == target) {\\n                return new int[] { start + 1, end + 1 };\\n            } else if (nums[start] + nums[end] < target) {\\n                start++;\\n            } else\\n                end--;\\n        }\\n        return new int[] {};\\n    }\\n}\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        int start = 0, n = nums.length, end = n - 1;\\n        while (start <= end) {\\n            if (nums[start] + nums[end] == target) {\\n                return new int[] { start + 1, end + 1 };\\n            } else if (nums[start] + nums[end] < target) {\\n                start++;\\n            } else\\n                end--;\\n        }\\n        return new int[] {};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190953,
                "title": "keep-it-simple-and-go",
                "content": "```\\nfunc twoSum(nums []int, t int) []int {\\n    for l, r := 0, len(nums) - 1 ;; {\\n        switch {\\n            case nums[l] + nums[r] > t: r--\\n            case nums[l] + nums[r] < t: l++\\n            default: return []int{l+1, r+1}\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc twoSum(nums []int, t int) []int {\\n    for l, r := 0, len(nums) - 1 ;; {\\n        switch {\\n            case nums[l] + nums[r] > t: r--\\n            case nums[l] + nums[r] < t: l++\\n            default: return []int{l+1, r+1}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032483,
                "title": "two-pointer-approach",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        l , r = 0, len(numbers)-1\\n        while r>l:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        l , r = 0, len(numbers)-1\\n        while r>l:\\n            s = numbers[l] + numbers[r]\\n            if s == target:\\n                return [l+1, r+1]\\n            elif s < target:\\n                l += 1\\n            else:\\n                r -= 1\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977708,
                "title": "rust-two-pointers",
                "content": "I just started learning Rust, any improvement advices are welcome!\\n\\n```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut j = numbers.len()-1;\\n        \\n        while i < j {\\n            match (numbers[i]+numbers[j]).cmp(&target) {\\n                Ordering::Less => i += 1,\\n                Ordering::Greater => j -= 1,\\n                Ordering::Equal => return vec![(i+1) as i32, (j+1) as i32],\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut i = 0;\\n        let mut j = numbers.len()-1;\\n        \\n        while i < j {\\n            match (numbers[i]+numbers[j]).cmp(&target) {\\n                Ordering::Less => i += 1,\\n                Ordering::Greater => j -= 1,\\n                Ordering::Equal => return vec![(i+1) as i32, (j+1) as i32],\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084293,
                "title": "python-binary-search-with-comments",
                "content": "Python\\nWe can change the question into multiple binary search problems:\\n1. For each element, find a value (value == target - element) in its right side of the number array\\n\\nThen we can just use a linear search + multiple binary search to find the answer\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        # Binary Search nLogn\\n        # Only one valid answer exist, no special case handler and no need to store combinations\\n        for index in range(len(numbers)):\\n            new_target = target - numbers[index]\\n            # Binary Search\\n            left, right = index + 1, len(numbers) - 1\\n            while left <= right:\\n                middle = (left + right) // 2\\n                if numbers[middle] < new_target:\\n                    left = middle + 1\\n                elif numbers[middle] > new_target:\\n                    right = middle - 1\\n                else:\\n                    return [index + 1, middle + 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        # Binary Search nLogn\\n        # Only one valid answer exist, no special case handler and no need to store combinations\\n        for index in range(len(numbers)):\\n            new_target = target - numbers[index]\\n            # Binary Search\\n            left, right = index + 1, len(numbers) - 1\\n            while left <= right:\\n                middle = (left + right) // 2\\n                if numbers[middle] < new_target:\\n                    left = middle + 1\\n                elif numbers[middle] > new_target:\\n                    right = middle - 1\\n                else:\\n                    return [index + 1, middle + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372761,
                "title": "java-beats-100-runtime-and-memory",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while(left != right){\\n            if(numbers[left] + numbers[right] > target){\\n                right--;\\n            } else if(numbers[left] + numbers[right] < target){\\n                left++;\\n            } else{\\n                return new int[] {left + 1, right + 1};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while(left != right){\\n            if(numbers[left] + numbers[right] > target){\\n                right--;\\n            } else if(numbers[left] + numbers[right] < target){\\n                left++;\\n            } else{\\n                return new int[] {left + 1, right + 1};\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357435,
                "title": "java-solutions-brute-force-hash-table-binary-search-two-pointers",
                "content": "\\n### Brute-Force\\n\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      if (nums[i] + nums[j] == target) {\\n        return new int[] { i + 1, j + 1 };\\n      }\\n    }\\n  }\\n\\t\\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n**Time:** $O(N^2)$\\n**Space:** $O(1)$\\n\\n\\n\\n### Hash Table\\n\\n**Two-Pass:**\\n\\n```java\\n// Two-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  // map<target - num, index>\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    map.put(target - nums[i], i);\\n  }\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      if (i == j) continue;\\n      return new int[] { i + 1, j + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n**One-Pass:**\\n\\n```java\\n// One-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      return new int[] { j + 1, i + 1 }; // notice the order\\n    }\\n    map.put(target - val, i);\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n\\n**Time:** $O(N)$\\n**Space:** $O(N)$\\n\\n\\n### Binary Search\\n\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    // binary search\\n    int val = target - nums[i];\\n    int lo = i + 1, hi = n - 1;    // i + 1 instead of i\\n    int result = search(nums, val, lo, hi);\\n    if (result != -1) { // found\\n      return new int[] { i + 1, result + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n\\nprivate int search(int[] nums, int val, int lo, int hi) {\\n  while (lo <= hi) {\\n    int mid = lo + (hi - lo) / 2;\\n    if (nums[mid] == val) return mid;\\n    if (nums[mid] > val) {\\n      hi = mid - 1;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  return -1;\\n}\\n```\\n\\n**Time:** $O(N\\\\log{N})$\\n**Space:** $O(1)$\\n\\n\\n### Two Pointers\\n\\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  int i = 0, j = n - 1;\\n  \\n  while (i < j) {\\n    int val = nums[i] + nums[j];\\n    if (val == target) {\\n      return new int[] { i + 1, j + 1 };\\n    } else if (val < target) {\\n      i += 1;\\n    } else { // val > target\\n      j -= 1;\\n    }\\n  }\\n  \\n  throw new IllegalArgumentException();\\n}\\n```\\n\\n**Time:** $O(N)$\\n**Space:** $O(1)$",
                "solutionTags": [],
                "code": "```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i + 1; j < n; ++j) {\\n      if (nums[i] + nums[j] == target) {\\n        return new int[] { i + 1, j + 1 };\\n      }\\n    }\\n  }\\n\\t\\n  throw new IllegalArgumentException();\\n}\\n```\n```java\\n// Two-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  // map<target - num, index>\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    map.put(target - nums[i], i);\\n  }\\n  \\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      if (i == j) continue;\\n      return new int[] { i + 1, j + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\n```java\\n// One-Pass\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  // set map\\n  Map<Integer, Integer> map = new HashMap<>();\\n  for (int i = 0; i < n; ++i) {\\n    int val = nums[i];\\n    if (map.containsKey(val)) {\\n      int j = map.get(val);\\n      return new int[] { j + 1, i + 1 }; // notice the order\\n    }\\n    map.put(target - val, i);\\n  }\\n  throw new IllegalArgumentException();\\n}\\n```\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  for (int i = 0; i < n; ++i) {\\n    // binary search\\n    int val = target - nums[i];\\n    int lo = i + 1, hi = n - 1;    // i + 1 instead of i\\n    int result = search(nums, val, lo, hi);\\n    if (result != -1) { // found\\n      return new int[] { i + 1, result + 1 };\\n    }\\n  }\\n  throw new IllegalArgumentException();\\n}\\n\\nprivate int search(int[] nums, int val, int lo, int hi) {\\n  while (lo <= hi) {\\n    int mid = lo + (hi - lo) / 2;\\n    if (nums[mid] == val) return mid;\\n    if (nums[mid] > val) {\\n      hi = mid - 1;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  return -1;\\n}\\n```\n```java\\npublic int[] twoSum(int[] nums, int target) {\\n  int n = nums.length;\\n  int i = 0, j = n - 1;\\n  \\n  while (i < j) {\\n    int val = nums[i] + nums[j];\\n    if (val == target) {\\n      return new int[] { i + 1, j + 1 };\\n    } else if (val < target) {\\n      i += 1;\\n    } else { // val > target\\n      j -= 1;\\n    }\\n  }\\n  \\n  throw new IllegalArgumentException();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299549,
                "title": "c-concise-straightforward",
                "content": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.Length - 1, sum;\\n        while (true) {\\n            sum = numbers[l] + numbers[r];\\n            if (sum == target)\\n                break;\\n            else if (sum < target) \\n                l += 1;\\n            else\\n                r -= 1;\\n        }\\n        return new int[2] {l + 1, r + 1};\\n    } \\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int l = 0, r = numbers.Length - 1, sum;\\n        while (true) {\\n            sum = numbers[l] + numbers[r];\\n            if (sum == target)\\n                break;\\n            else if (sum < target) \\n                l += 1;\\n            else\\n                r -= 1;\\n        }\\n        return new int[2] {l + 1, r + 1};\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51252,
                "title": "o-n-time-o-1-space-two-pointer-solution-with-detailed-and-clear-explanation",
                "content": "To find the two numbers that sum to a target value, let's say the left number is numbers[i], and the right number is numbers[j].\\n\\nLet's iterate 0 to numbers.length - 1 one by one to find the left index i. \\n\\nFirstly look at when i = 0. Let's say the right j is j* satisfying numbers[i] + numbers[j*] == target. How to find j*? Let's just take a random j satisfying 0 < j < numbers.length. There are 3 situations:\\n1. numbers[i] + numbers[j] == target\\n2. numbers[i] + numbers[j] < target\\n3. numbers[i] + numbers[j] > target\\n\\nAnswer is found in situation 1.\\n\\nIn situation 2, if numbers[i] + numbers[j] < target, because the array is sorted, we know that numbers[j*] > numbers[j], and j* > j. So we should check the index bigger than j.\\n\\nIn situation 3, if numbers[i] + numbers[j] > target, because the array is sorted, we know that numbers[j*] < numbers[j], and j* < j. So we should check the index smaller than j.\\n\\nIf the left index is not when i == 0, then where is j now? \\n\\nIt should satisfy:\\nnumbers[i] + numbers[j] > target\\nand\\nnumbers[i] + numbers[j - 1] < target\\n\\nBecause answer is not found for i == 0, now let's check when i == 1. \\n\\nThe trick is, now we only have to check the j that is smaller than the j we have when i == 0. If numbers[0] + numbers[j] > target, then also numbers[1] +  numbers[j] > target. So j is decreasing.\\n\\nThat's how 2 pointer solution come from. Start with i == 0, and j == numbers.length - 1, so that we can always decrease j as we increase i to find the solution.\\n\\n```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[2];\\n        int l = 0, r = numbers.length - 1, cur = numbers[l] + numbers[r];\\n        while (l < r) {\\n            if (cur == target) {\\n                res[0] = l + 1;\\n                res[1] = r + 1;\\n                break;\\n            } else if (cur < target) {\\n                cur += numbers[l + 1] - numbers[l]; // increase the left index\\n                l++;\\n            } else {\\n                cur -= numbers[r] - numbers[r - 1]; // decrease the right index\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[2];\\n        int l = 0, r = numbers.length - 1, cur = numbers[l] + numbers[r];\\n        while (l < r) {\\n            if (cur == target) {\\n                res[0] = l + 1;\\n                res[1] = r + 1;\\n                break;\\n            } else if (cur < target) {\\n                cur += numbers[l + 1] - numbers[l]; // increase the left index\\n                l++;\\n            } else {\\n                cur -= numbers[r] - numbers[r - 1]; // decrease the right index\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082169,
                "title": "three-simple-java-solutions-runtime-2ms",
                "content": "\\n# Code1\\n**By BinarySearch**\\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0 , high = numbers.length-1;\\n\\n            while (low < high)\\n            {\\n                int complement = numbers[low] + numbers[high];\\n                if (complement == target)\\n                {\\n                    return new int[]{low+1 , high+1};\\n                }else if (complement > target){\\n                    high--;\\n                }else {\\n                    low++;\\n                }\\n            }\\n            \\n        return new int[] {-1 , -1};\\n    }\\n}\\n```\\n\\n# Code2\\n\\n**By hashMap**\\n\\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        HashMap<Integer , Integer> hashMap = new HashMap<>();\\n\\n        for (int i = 0; i < numbers.length ; i++)\\n        {\\n            int complement = target - numbers[i];\\n            if (hashMap.containsKey(complement))\\n            {\\n                return new int[]{ hashMap.get(complement)+1 , i+1};\\n            }\\n\\n            hashMap.put(numbers[i] , i);\\n        }\\n        \\n        return new int[]{-1 , -1};\\n    }\\n}\\n```\\n\\n\\n# Code3\\n\\n**By hashSet**\\n\\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int [] res = {-1 , -1};\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int n : numbers) {\\n            set.add(n);\\n        }\\n\\n           StringBuilder str = new StringBuilder();\\n           int i = 1 ;\\n        for (int num : numbers)\\n        {\\n            if ( res[0] == -1 && set.contains(target - num))\\n            {\\n                res[0] = i;\\n                str.append(target - num);\\n            }else if (res[0] != -1 && Integer.parseInt(str.toString()) == num ){\\n                res[1] = i;\\n                return res;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/7f2cbe8d-f066-466d-bfc3-6eda2c5f3730_1695501256.7571125.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Hash Function"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int low = 0 , high = numbers.length-1;\\n\\n            while (low < high)\\n            {\\n                int complement = numbers[low] + numbers[high];\\n                if (complement == target)\\n                {\\n                    return new int[]{low+1 , high+1};\\n                }else if (complement > target){\\n                    high--;\\n                }else {\\n                    low++;\\n                }\\n            }\\n            \\n        return new int[] {-1 , -1};\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        HashMap<Integer , Integer> hashMap = new HashMap<>();\\n\\n        for (int i = 0; i < numbers.length ; i++)\\n        {\\n            int complement = target - numbers[i];\\n            if (hashMap.containsKey(complement))\\n            {\\n                return new int[]{ hashMap.get(complement)+1 , i+1};\\n            }\\n\\n            hashMap.put(numbers[i] , i);\\n        }\\n        \\n        return new int[]{-1 , -1};\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int [] res = {-1 , -1};\\n\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int n : numbers) {\\n            set.add(n);\\n        }\\n\\n           StringBuilder str = new StringBuilder();\\n           int i = 1 ;\\n        for (int num : numbers)\\n        {\\n            if ( res[0] == -1 && set.contains(target - num))\\n            {\\n                res[0] = i;\\n                str.append(target - num);\\n            }else if (res[0] != -1 && Integer.parseInt(str.toString()) == num ){\\n                res[1] = i;\\n                return res;\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916016,
                "title": "unique-two-pointer-solution-visual-explanation",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate two pointers where one points at the first index in the array and the other points at the second index. \\n![image.png](https://assets.leetcode.com/users/images/d1bf7a1b-14d2-4c20-95fb-f0e28e8ef04c_1692158325.868738.png)\\n\\nIf the sum of the values at the pointers is less than the target, shift both pointers over one. \\n![image.png](https://assets.leetcode.com/users/images/ab1f29a8-b028-4831-9cb4-d465f80cf8b3_1692158387.3140357.png)\\n\\nIf the values summed are greater, shift the first pointer left one. \\n![image.png](https://assets.leetcode.com/users/images/0729c0f4-9453-4fec-bb8b-cce8c3274bfe_1692158455.6069474.png)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        p1, p2 = 0, 1;\\n        while not (numbers[p1] + numbers[p2] == target):\\n            if numbers[p1] + numbers[p2] < target:\\n                p2+=1;\\n                p1+=1;\\n            else:\\n                p1-=1; \\n        return [p1+1, p2+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        p1, p2 = 0, 1;\\n        while not (numbers[p1] + numbers[p2] == target):\\n            if numbers[p1] + numbers[p2] < target:\\n                p2+=1;\\n                p1+=1;\\n            else:\\n                p1-=1; \\n        return [p1+1, p2+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753419,
                "title": "2-methods-using-stl-implementation",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Method 1: \\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n       for(int i=0; i<nums.size();i++){\\n           if(binary_search(nums.begin()+i+1,nums.end(),target-nums[i])){\\n           int lb = lower_bound(nums.begin()+i+1, nums.end(), target-nums[i])-nums.begin();\\n               return {i+1,lb+1};\\n           }\\n       }\\n       return {-1,-1};\\n    }\\n};\\n```\\n\\n# Method 2: \\n```\\nclass Solution {\\npublic:\\n     int search(int target, vector<int> &nums, int left, int right){\\n         while(left<=right){\\n             int mid = left + (right-left)/2;\\n             if(nums[mid]>target)\\n                 right = mid-1;\\n             else if(nums[mid]<target)\\n                 left = mid+1;\\n             else \\n                 return mid;\\n         }\\n         return -1;\\n     }\\n\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n      \\n\\n        for(int i=0; i<nums.size();i++){\\n            int j=search(target-nums[i], nums, i+1, nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n         return {-1,-1};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n       for(int i=0; i<nums.size();i++){\\n           if(binary_search(nums.begin()+i+1,nums.end(),target-nums[i])){\\n           int lb = lower_bound(nums.begin()+i+1, nums.end(), target-nums[i])-nums.begin();\\n               return {i+1,lb+1};\\n           }\\n       }\\n       return {-1,-1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     int search(int target, vector<int> &nums, int left, int right){\\n         while(left<=right){\\n             int mid = left + (right-left)/2;\\n             if(nums[mid]>target)\\n                 right = mid-1;\\n             else if(nums[mid]<target)\\n                 left = mid+1;\\n             else \\n                 return mid;\\n         }\\n         return -1;\\n     }\\n\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n      \\n\\n        for(int i=0; i<nums.size();i++){\\n            int j=search(target-nums[i], nums, i+1, nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n         return {-1,-1};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744405,
                "title": "2-c-solutions-binary-search-two-pointers-approach",
                "content": "\\n\\n# Code\\n```\\n// Solution 1 (Two-pointers)\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int l = 0, r = numbers.size() -1;\\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target)\\n                return {l+1,r+1};\\n            else if(numbers[l] + numbers[r] > target)\\n                r--;\\n            else\\n                l++;\\n        }\\n\\t    return {};\\n    }\\n};\\n\\n// Solution 2 (Binary Search)\\nclass Solution {\\npublic:\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n                right=mid-1;\\n            else if(nums[mid]<target)\\n                left=mid+1;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\n// Solution 1 (Two-pointers)\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int l = 0, r = numbers.size() -1;\\n        while(l < r){\\n            if(numbers[l] + numbers[r] == target)\\n                return {l+1,r+1};\\n            else if(numbers[l] + numbers[r] > target)\\n                r--;\\n            else\\n                l++;\\n        }\\n\\t    return {};\\n    }\\n};\\n\\n// Solution 2 (Binary Search)\\nclass Solution {\\npublic:\\n    int search(int target,vector<int>&nums,int left,int right)\\n    {\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(nums[mid]>target)\\n                right=mid-1;\\n            else if(nums[mid]<target)\\n                left=mid+1;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n    vector<int> twoSum(vector<int>&nums,int target) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=search(target-nums[i],nums,i+1,nums.size()-1);\\n            if(j!=(-1))\\n                return {i+1,j+1};\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361903,
                "title": "easiest-solution-beats-99-8-code-optimization-o-n-2-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is similar to a leetcode problem number 1, where array is not sorted. Here, we are given sorted array which make easy for finding optimal solution. \\n\\n# Approach Number 2 (Iterative) \\n<!-- Describe your approach to solving the problem. -->\\n**similar to Two sum problem - leetcode problem 1**\\n1. Run loop from i = 0 to size-1 and another loop(nested one) j = i+1 to size-1.\\n2. check if(nums[i] + nums[j] == target), return {i+1,j+1};\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        for(int i = 0; i < nums.size(); i++)\\n        for(int j = i+1; j < nums.size(); j++)\\n        if(nums[i]+nums[j]==target)\\n        return {i+1,j+1};\\n        return {};\\n    }\\n};\\n```\\n# OPTIMIZATION:-O(n^2)-> O(N).\\n# Approach Number 2\\n1. set two pointer i = 0 and j =  size-1.\\n2. Iterative till (i < j)\\n3. At each step do the following,\\n- if(nums[i] + nums[j] == target), return {i+1,j+1};\\n- else if(nums[i] + nums[j] > target), means our sum is greater than target, (2+15=17>9), we need a smaller number to reduce the sum, so decrease j by 1 as array is sorted.\\n- else increase i by 1. means our sum is smaller thsn target, (2+5=7 9), we need a greater number to increase the sum, so increase i by 1 as array is sorted.\\n\\n# Complexity.\\n**Time**-O(N)\\n**Space**-O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i = 0, j = nums.size()-1;\\n        while(i < j){\\n            if(nums[i] + nums[j] == target) return {i+1,j+1};\\n            else if(nums[i] + nums[j] > target)  j--;\\n            else  i++;     // nums[i] + nums[j] < target\\n        }\\n        return{};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        for(int i = 0; i < nums.size(); i++)\\n        for(int j = i+1; j < nums.size(); j++)\\n        if(nums[i]+nums[j]==target)\\n        return {i+1,j+1};\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int i = 0, j = nums.size()-1;\\n        while(i < j){\\n            if(nums[i] + nums[j] == target) return {i+1,j+1};\\n            else if(nums[i] + nums[j] > target)  j--;\\n            else  i++;     // nums[i] + nums[j] < target\\n        }\\n        return{};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191053,
                "title": "python3-simplest-solution-o-log-n-and-o-1-space",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131059,
                "title": "c-use-2-pointers-simple-approach-dlc-june-day-9",
                "content": "**Approach:** Use 2 pointers approach\\n\\n**TC: O(N), SC:O(1)**\\n \\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int tar) \\n    {\\n        //define start and end pointer\\n        int s=0, e=nums.size()-1;\\n        \\n        //iterate until both pointers reach at the same index\\n        while(s<e)\\n        {\\n            if(nums[s]+nums[e]==tar) break;\\n            \\n            else if(nums[s]+nums[e]>tar) e--;\\n            \\n            else s++;\\n        }\\n        //return the index of s and e added by one\\n        return {s+1, e+1};           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int tar) \\n    {\\n        //define start and end pointer\\n        int s=0, e=nums.size()-1;\\n        \\n        //iterate until both pointers reach at the same index\\n        while(s<e)\\n        {\\n            if(nums[s]+nums[e]==tar) break;\\n            \\n            else if(nums[s]+nums[e]>tar) e--;\\n            \\n            else s++;\\n        }\\n        //return the index of s and e added by one\\n        return {s+1, e+1};           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128791,
                "title": "o-n-solution-in-c-using-two-pointers",
                "content": "We use a very important property here that the array is sorted...\\nNow we initialize two pointers, i and j, one being at start of the array and other being at the end...\\nIf the sum of these two elements is smaller than the target, we know that no element on left of i can sum with j to give us target, hence we move i forward...\\nSimilarly if sum of these two elements is greater than the target, we know that no element on right of j can sum with i to give us target, hence we j backward...\\nIf we reach target, we simply return these index added by 1...\\n\\n**If you found the solution helpful, pls upvote this thread.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0, j=numbers.size()-1;\\n        while(i<j) {\\n            if(numbers[i]+numbers[j]==target) return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else j--;\\n        }\\n        \\n        return {-1,-1};\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0, j=numbers.size()-1;\\n        while(i<j) {\\n            if(numbers[i]+numbers[j]==target) return {i+1, j+1};\\n            else if(numbers[i]+numbers[j]<target) i++;\\n            else j--;\\n        }\\n        \\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128757,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        val1=0\\n        val2=len(numbers)-1\\n        while val1<val2:\\n            if numbers[val1]+numbers[val2]==target:\\n                return [val1+1,val2+1]\\n            if numbers[val1]+numbers[val2]<target:\\n                val1+=1\\n            else:\\n                val2-=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        val1=0\\n        val2=len(numbers)-1\\n        while val1<val2:\\n            if numbers[val1]+numbers[val2]==target:\\n                return [val1+1,val2+1]\\n            if numbers[val1]+numbers[val2]<target:\\n                val1+=1\\n            else:\\n                val2-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016230,
                "title": "c-two-approaches-discussed-easy-to-understand",
                "content": "**Approach 1: (Using Binary Search)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size()-1;i++){\\n            int low=i+1,high=numbers.size()-1;\\n            int k=target-numbers[i];\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(numbers[mid]==k)     return{i+1,mid+1};\\n                else if(numbers[mid]<k)    low=mid+1;\\n                else    high=mid-1;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\n**Approach 2: (Using Two Pointers)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low=0,high=numbers.size()-1;\\n        while(low<high){\\n            if(numbers[low]+numbers[high]==target)  return {low+1,high+1};\\n            else if(numbers[low]+numbers[high]<target)  low++;\\n            else high--;\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nIf you liked the solution, then please upvote \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size()-1;i++){\\n            int low=i+1,high=numbers.size()-1;\\n            int k=target-numbers[i];\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(numbers[mid]==k)     return{i+1,mid+1};\\n                else if(numbers[mid]<k)    low=mid+1;\\n                else    high=mid-1;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low=0,high=numbers.size()-1;\\n        while(low<high){\\n            if(numbers[low]+numbers[high]==target)  return {low+1,high+1};\\n            else if(numbers[low]+numbers[high]<target)  low++;\\n            else high--;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945409,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the numbers.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        guard !numbers.isEmpty else { return [] }\\n        var i = 0\\n        var j = numbers.count - 1\\n\\n        while i < j {\\n            guard numbers[i] + numbers[j] != target else { break }\\n\\n            if numbers[i] + numbers[j] > target {\\n                j -= 1\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\n        return [i + 1, j + 1]\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the numbers.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func twoSum(_ numbers: [Int], _ target: Int) -> [Int] {\\n        guard !numbers.isEmpty else { return [] }\\n        var i = 0\\n        var j = numbers.count - 1\\n\\n        while i < j {\\n            guard numbers[i] + numbers[j] != target else { break }\\n\\n            if numbers[i] + numbers[j] > target {\\n                j -= 1\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\n        return [i + 1, j + 1]\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749544,
                "title": "python-simple-and-clean-python-solution-using-two-pointer-approach",
                "content": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n# Runtime: 184 ms, faster than 45.91% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n# Memory Usage: 14.8 MB, less than 89.05% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, numbers: List[int], target: int) -> List[int]:\\n\\n\\t\\t\\tlow = 0\\n\\t\\t\\thigh = len(numbers)-1\\n\\n\\t\\t\\twhile low < high:\\n\\n\\t\\t\\t\\tif numbers[low]+numbers[high] < target:\\n\\t\\t\\t\\t\\tlow = low + 1\\n\\t\\t\\t\\telif numbers[low]+numbers[high] > target:\\n\\t\\t\\t\\t\\thigh = high - 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn [low+1, high+1]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "# If It is Useful To Understand Please UpVote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n# Runtime: 184 ms, faster than 45.91% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n# Memory Usage: 14.8 MB, less than 89.05% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n\\tclass Solution:\\n\\t\\tdef twoSum(self, numbers: List[int], target: int) -> List[int]:\\n\\n\\t\\t\\tlow = 0\\n\\t\\t\\thigh = len(numbers)-1\\n\\n\\t\\t\\twhile low < high:\\n\\n\\t\\t\\t\\tif numbers[low]+numbers[high] < target:\\n\\t\\t\\t\\t\\tlow = low + 1\\n\\t\\t\\t\\telif numbers[low]+numbers[high] > target:\\n\\t\\t\\t\\t\\thigh = high - 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn [low+1, high+1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1625354,
                "title": "c-binary-search-two-pointers-o-nlogn-o-n",
                "content": "**Binary Search [ O(nlogn) ]**\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size();i++)\\n        {\\n            int lb=0,ub=numbers.size()-1,mid=0;\\n            while(lb<=ub)\\n            {\\n                mid=lb+(ub-lb)/2;\\n                if(numbers[i]+numbers[mid]==target)\\n                {\\n                    if(mid==i)\\n                    {\\n                        if(numbers[i]+numbers[mid+1]==target)\\n                            mid++;\\n                        else if(numbers[i]+numbers[mid-1]==target)\\n                            mid--;\\n                    }\\n                    return vector<int>{i+1,mid+1};\\n                }\\n                    \\n                else if(numbers[i]+numbers[mid]<target)\\n                    lb=mid+1;\\n                else\\n                    ub=mid-1;\\n            }\\n            \\n        }\\n        return vector<int>{0,0};\\n    }\\n```\\nHere, for every number in the array, I am doing a binary search to get the second number. \\n\\nNow while searching for the second number, it might catch the same index as of the first number which is an incorrect answer as both index in the answer could not be the same.\\nBut if it catches the same index and finds the result, it simply means that the first number has repeated atleast twice because all test case could have one exact solution. Now, we know the array is sorted then definitely the same number has repeated either before or after the same index where the first number lies.\\nHence the check:\\n```\\nif(mid==i)\\n{\\n\\tif(numbers[i]+numbers[mid+1]==target)\\n\\t\\tmid++;\\n\\telse if(numbers[i]+numbers[mid-1]==target)\\n        mid--; \\n}\\n```\\n*A testcase justifying the above snippet;*\\n[1,2,3,4,4,9,56,90]\\n8\\n\\n\\n**Method 2: Two pointer [ O(n) ]**\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int lb=0,ub=numbers.size()-1;\\n        while(numbers[lb]+numbers[ub]!=target)\\n        {\\n                if(numbers[lb]+numbers[ub]<target)\\n                    lb++;\\n            else\\n                ub--;\\n        }\\n        return vector<int>{lb+1,ub+1};\\n```\\n\\nIf my solution helped you, please hit an upvote\\nIf you have any query, drop a comment and lets discuss!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        for(int i=0;i<numbers.size();i++)\\n        {\\n            int lb=0,ub=numbers.size()-1,mid=0;\\n            while(lb<=ub)\\n            {\\n                mid=lb+(ub-lb)/2;\\n                if(numbers[i]+numbers[mid]==target)\\n                {\\n                    if(mid==i)\\n                    {\\n                        if(numbers[i]+numbers[mid+1]==target)\\n                            mid++;\\n                        else if(numbers[i]+numbers[mid-1]==target)\\n                            mid--;\\n                    }\\n                    return vector<int>{i+1,mid+1};\\n                }\\n                    \\n                else if(numbers[i]+numbers[mid]<target)\\n                    lb=mid+1;\\n                else\\n                    ub=mid-1;\\n            }\\n            \\n        }\\n        return vector<int>{0,0};\\n    }\\n```\n```\\nif(mid==i)\\n{\\n\\tif(numbers[i]+numbers[mid+1]==target)\\n\\t\\tmid++;\\n\\telse if(numbers[i]+numbers[mid-1]==target)\\n        mid--; \\n}\\n```\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        int lb=0,ub=numbers.size()-1;\\n        while(numbers[lb]+numbers[ub]!=target)\\n        {\\n                if(numbers[lb]+numbers[ub]<target)\\n                    lb++;\\n            else\\n                ub--;\\n        }\\n        return vector<int>{lb+1,ub+1};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534037,
                "title": "c-simple-solution-without-additional-memory",
                "content": "Pleas upvote if you like :-)\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n       int nStart=0, nEnd =numbers.size()-1;\\n        \\n        while(nStart<nEnd)\\n        {\\n            if(numbers[nStart]+numbers[nEnd] == target)\\n                return {nStart+1, nEnd+1};\\n            else if(numbers[nStart]+numbers[nEnd] > target)\\n                nEnd--;\\n            else\\n                nStart++;\\n        }\\n       \\n        return {};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n       int nStart=0, nEnd =numbers.size()-1;\\n        \\n        while(nStart<nEnd)\\n        {\\n            if(numbers[nStart]+numbers[nEnd] == target)\\n                return {nStart+1, nEnd+1};\\n            else if(numbers[nStart]+numbers[nEnd] > target)\\n                nEnd--;\\n            else\\n                nStart++;\\n        }\\n       \\n        return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981444,
                "title": "java-binary-search",
                "content": "```\\nclass Solution { // binary search \\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0, end = numbers.length-1;\\n        while(start + 1 < end){\\n            int mid = start + (end-start)/2;\\n            if(numbers[start] == (target - numbers[end]))\\n                return new int[]{start + 1, end + 1};\\n            else if (numbers[start] < (target-numbers[end])) {\\n                start = (numbers[mid] < (target-numbers[end])) ? mid : start + 1;\\n            }else{\\n                end = (numbers[mid] > (target-numbers[start])) ? mid : end - 1;\\n            }\\n        }\\n        if(numbers[start] == (target - numbers[end]))\\n            return new int[]{start + 1, end + 1};\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { // binary search \\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0, end = numbers.length-1;\\n        while(start + 1 < end){\\n            int mid = start + (end-start)/2;\\n            if(numbers[start] == (target - numbers[end]))\\n                return new int[]{start + 1, end + 1};\\n            else if (numbers[start] < (target-numbers[end])) {\\n                start = (numbers[mid] < (target-numbers[end])) ? mid : start + 1;\\n            }else{\\n                end = (numbers[mid] > (target-numbers[start])) ? mid : end - 1;\\n            }\\n        }\\n        if(numbers[start] == (target - numbers[end]))\\n            return new int[]{start + 1, end + 1};\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692019,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        ## RC ##\\n        ## APPRAOCH : 2 POINTER ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while(left < right):\\n            if(nums[left] + nums[right] < target):\\n                left += 1\\n            if(nums[left] + nums[right] > target):\\n                right -= 1\\n            if((nums[left] + nums[right]) == target):\\n                return [left+1,right+1]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        ## RC ##\\n        ## APPRAOCH : 2 POINTER ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while(left < right):\\n            if(nums[left] + nums[right] < target):\\n                left += 1\\n            if(nums[left] + nums[right] > target):\\n                right -= 1\\n            if((nums[left] + nums[right]) == target):\\n                return [left+1,right+1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 281058,
                "title": "javascript-98-runtime",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n    let p1=0, p2=numbers.length;\\n    while(p1<p2){\\n        if(numbers[p1]+numbers[p2]==target) return [p1+1,p2+1];\\n        else if(numbers[p1]+numbers[p2]<target) p1++;\\n        else p2--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    let p1=0, p2=numbers.length;\\n    while(p1<p2){\\n        if(numbers[p1]+numbers[p2]==target) return [p1+1,p2+1];\\n        else if(numbers[p1]+numbers[p2]<target) p1++;\\n        else p2--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 51258,
                "title": "clean-easy-to-understand-solution-in-java",
                "content": "```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        \\n        int i = 0;\\n        int j = len - 1;\\n        \\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            \\n            if (sum > target) j--;\\n            else if (sum < target) i++;\\n            else return new int[] {i+1, j+1};\\n        }\\n        return new int[] {-1, -1}; // never comes here if sum exists\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        \\n        int i = 0;\\n        int j = len - 1;\\n        \\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            \\n            if (sum > target) j--;\\n            else if (sum < target) i++;\\n            else return new int[] {i+1, j+1};\\n        }\\n        return new int[] {-1, -1}; // never comes here if sum exists\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 51338,
                "title": "c-6ms-two-pointers-6ms-binary-search-clean-code",
                "content": "**6ms: Two Pointers**\\nTime: O(n)\\nSpace: O(1)\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    int low = 0;\\n    int high = numbers.size() - 1;\\n\\n    while(low < high){\\n        int sum = numbers[low] + numbers[high];\\n\\n        if(target == sum) return vector<int>({low+1, high+1});\\n        if(target > sum) ++low;\\n        else --high;\\n    }\\n    return vector<int>();\\n}\\n```\\n\\n**6ms: Binary Search**\\nTime: O(nlogn)\\nSpace: O(1)\\n\\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    for(int i = 0; i < numbers.size(); ++i){\\n        int index = bs(numbers, i+1, numbers.size(), target - numbers[i]);\\n        \\n        if(index < 0) continue;\\n        else return vector<int>({i+1, index+1});\\n    }\\n    return vector<int>();\\n}\\n\\nint bs(vector<int>& numbers, int low, int high, int target){\\n    while(low < high){\\n        int mid = low + (high - low) / 2;\\n        if(numbers[mid] == target) return mid;\\n        if(target > numbers[mid]) low = mid + 1;\\n        else high = mid - 1;\\n    }\\n    return numbers[low] == target ? low : -1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    int low = 0;\\n    int high = numbers.size() - 1;\\n\\n    while(low < high){\\n        int sum = numbers[low] + numbers[high];\\n\\n        if(target == sum) return vector<int>({low+1, high+1});\\n        if(target > sum) ++low;\\n        else --high;\\n    }\\n    return vector<int>();\\n}\\n```\n```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n    for(int i = 0; i < numbers.size(); ++i){\\n        int index = bs(numbers, i+1, numbers.size(), target - numbers[i]);\\n        \\n        if(index < 0) continue;\\n        else return vector<int>({i+1, index+1});\\n    }\\n    return vector<int>();\\n}\\n\\nint bs(vector<int>& numbers, int low, int high, int target){\\n    while(low < high){\\n        int mid = low + (high - low) / 2;\\n        if(numbers[mid] == target) return mid;\\n        if(target > numbers[mid]) low = mid + 1;\\n        else high = mid - 1;\\n    }\\n    return numbers[low] == target ? low : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992419,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector <int> ans;\\n        int i = 0, j = numbers.size() - 1;\\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            if (sum == target) {\\n                ans.push_back(i + 1);\\n                ans.push_back(j + 1);\\n                break;\\n            } else if (sum < target) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector <int> ans;\\n        int i = 0, j = numbers.size() - 1;\\n        while (i < j) {\\n            int sum = numbers[i] + numbers[j];\\n            if (sum == target) {\\n                ans.push_back(i + 1);\\n                ans.push_back(j + 1);\\n                break;\\n            } else if (sum < target) {\\n                i++;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822273,
                "title": "c-2-pointers-solution",
                "content": "# Intuition\\nUse one single for-loop to give a solution.\\n\\n# Approach\\nWithin the loop it needs only to consider three cases, i.e. \\'==\\', \\'<\\' and \\'>\\'. \\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/uswoJ2X4mfU](https://youtu.be/uswoJ2X4mfU)\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        for(int i=0, j=n-1; i<j; ){\\n            int sum=numbers[i]+numbers[j];\\n            if (sum == target) return {i+1, j+1};\\n            else if ( sum< target) i++;\\n            else j--;\\n        }\\n        return {};        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n=numbers.size();\\n        for(int i=0, j=n-1; i<j; ){\\n            int sum=numbers[i]+numbers[j];\\n            if (sum == target) return {i+1, j+1};\\n            else if ( sum< target) i++;\\n            else j--;\\n        }\\n        return {};        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364667,
                "title": "easy-two-pointers-solution",
                "content": "![47d7b3d2-77fe-40ef-bd04-ce5a5e314972_1675901748.9217496.jpeg](https://assets.leetcode.com/users/images/3bb26290-c943-45df-88f8-17c3e5e2dd5c_1680330260.6041856.jpeg)\\n# Code\\n```javascript []\\n\\nvar twoSum = function(arr, target) {\\n      let n=arr.length;\\n        let s=0;\\n        let e=n-1;\\n        while(s<e){\\n            let sum=arr[s]+arr[e];\\n            if(sum==target){\\n                s++;\\n                e++;\\n              return [s,e];\\n            }\\n            else if(sum>target){\\n                e--;\\n            }else{\\n                s++;\\n            }\\n        }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] twoSum(int[] arr, int target) {\\n        int n = arr.length;\\n        int s = 0;\\n        int e = n - 1;\\n        int[] ans = new int[2]; // declare and initialize ans\\n        while (s < e) {\\n            int sum = arr[s] + arr[e];\\n            if (sum == target) {\\n                ans[0] = s+1;\\n                ans[1] = e+1;\\n                break; // break out of the loop once a solution is found\\n            } else if (sum > target) {\\n                e--;\\n            } else {\\n                s++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![6233d50d-1433-4516-8d8e-90fb8e13d32f_1677303191.974716.jpeg](https://assets.leetcode.com/users/images/5ea3c40e-f0ce-4300-9bec-70607884e164_1680330293.8649492.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```javascript []\\n\\nvar twoSum = function(arr, target) {\\n      let n=arr.length;\\n        let s=0;\\n        let e=n-1;\\n        while(s<e){\\n            let sum=arr[s]+arr[e];\\n            if(sum==target){\\n                s++;\\n                e++;\\n              return [s,e];\\n            }\\n            else if(sum>target){\\n                e--;\\n            }else{\\n                s++;\\n            }\\n        }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] twoSum(int[] arr, int target) {\\n        int n = arr.length;\\n        int s = 0;\\n        int e = n - 1;\\n        int[] ans = new int[2]; // declare and initialize ans\\n        while (s < e) {\\n            int sum = arr[s] + arr[e];\\n            if (sum == target) {\\n                ans[0] = s+1;\\n                ans[1] = e+1;\\n                break; // break out of the loop once a solution is found\\n            } else if (sum > target) {\\n                e--;\\n            } else {\\n                s++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975227,
                "title": "simple-java-solution-100-faster",
                "content": "\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0 , end = numbers.length-1;\\n        while(start < end){\\n            if(numbers[start] + numbers[end] > target){\\n                end--;\\n            }else if(numbers[start] + numbers[end] < target){\\n                start++;\\n            }else{\\n                return new int[]{start+1, end+1};\\n            }\\n        }\\n        return new int[]{};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0 , end = numbers.length-1;\\n        while(start < end){\\n            if(numbers[start] + numbers[end] > target){\\n                end--;\\n            }else if(numbers[start] + numbers[end] < target){\\n                start++;\\n            }else{\\n                return new int[]{start+1, end+1};\\n            }\\n        }\\n        return new int[]{};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382513,
                "title": "c-solution-two-pointers-approach-comments-o-n",
                "content": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint n = numbers.size();\\n\\tint i =0, j = n-1;\\n\\t\\n\\t// traversing the array until the left pointer goes further than right pointer\\n\\twhile(i<=j){\\n\\t\\tint sum = numbers[i]+ numbers[j];\\n\\t\\t\\n\\t\\t// if the sum of left and right pointer gives the target,\\n\\t\\t// we return the index positions\\n\\t\\tif(sum==target)  return {i+1, j+1};\\n\\t\\t// else since it\\'s sorted decreasing the right pointer would decrease the sum\\n\\t\\t\\n\\t\\telse if(sum>target) j--;\\n\\t\\t\\n\\t\\t// else increase the left pointer to increase the sum\\n\\t\\telse    i++;\\n\\t}\\n\\treturn {0,0};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> twoSum(vector<int>& numbers, int target) {\\n\\tint n = numbers.size();\\n\\tint i =0, j = n-1;\\n\\t\\n\\t// traversing the array until the left pointer goes further than right pointer\\n\\twhile(i<=j){\\n\\t\\tint sum = numbers[i]+ numbers[j];\\n\\t\\t\\n\\t\\t// if the sum of left and right pointer gives the target,\\n\\t\\t// we return the index positions\\n\\t\\tif(sum==target)  return {i+1, j+1};\\n\\t\\t// else since it\\'s sorted decreasing the right pointer would decrease the sum\\n\\t\\t\\n\\t\\telse if(sum>target) j--;\\n\\t\\t\\n\\t\\t// else increase the left pointer to increase the sum\\n\\t\\telse    i++;\\n\\t}\\n\\treturn {0,0};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130788,
                "title": "simple-and-easy-approach",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int low=0,high =numbers.size()-1;\\n        int total;\\n        while(low<high){\\n            total=(numbers[low]+numbers[high]);\\n            if(total==target) {\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                return ans;\\n            }\\n            else if(total >target)  high --;\\n            else low++;\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int low=0,high =numbers.size()-1;\\n        int total;\\n        while(low<high){\\n            total=(numbers[low]+numbers[high]);\\n            if(total==target) {\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                return ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2130676,
                "title": "two-sum-ii-input-array-is-sorted-two-pointer-simple",
                "content": "Solution:\\nThe precondition of sorted array indicates the use of two pointers,since this is the only point of difference from the normal Two Sum Problem( which btw can be solved using this approach as well but with a greater T.C. ).\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int l=0,h=numbers.size()-1;\\n        while(l<h){\\n            if((numbers[l]+numbers[h])==target){\\n                ans.push_back(l+1);\\n                ans.push_back(h+1);\\n                break;\\n            }\\n            else if((numbers[l]+numbers[h])<target)\\n                l++;\\n            else\\n                h--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int l=0,h=numbers.size()-1;\\n        while(l<h){\\n            if((numbers[l]+numbers[h])==target){\\n                ans.push_back(l+1);\\n                ans.push_back(h+1);\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2129916,
                "title": "c-2-pointer-approach-daily-leetcoding-challenge-june-day-9",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        int left = 0;                    // left pointer\\n        int right = numbers.size()-1;    // right pointer\\n        \\n        // till both the pointers will not collide\\n        while(left<right)\\n        {\\n            // after getting our target value break it\\n            if(numbers[left]+numbers[right]==target)\\n            {\\n                break;\\n            }\\n            \\n            // if current sum is lower than target , so we need to maximize it , so move left pointer towards the right\\n            else if(numbers[left]+numbers[right]<target)\\n            {\\n                left++;\\n            }\\n            \\n            // if current sum is bigger than target so we need to minimize it , so move right pointer towards the left\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        \\n        return {left+1,right+1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        int left = 0;                    // left pointer\\n        int right = numbers.size()-1;    // right pointer\\n        \\n        // till both the pointers will not collide\\n        while(left<right)\\n        {\\n            // after getting our target value break it\\n            if(numbers[left]+numbers[right]==target)\\n            {\\n                break;\\n            }\\n            \\n            // if current sum is lower than target , so we need to maximize it , so move left pointer towards the right\\n            else if(numbers[left]+numbers[right]<target)\\n            {\\n                left++;\\n            }\\n            \\n            // if current sum is bigger than target so we need to minimize it , so move right pointer towards the left\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        \\n        return {left+1,right+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128749,
                "title": "binary-search-approach-not-2-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // USING BINARY SEARCH - nLogn\\n    \\n    int bs(vector<int> &nums, int i ,int j,int target){\\n        int l = i, h = j;\\n        int mid;\\n        \\n        while(l<=h)\\n        {\\n            mid = l + (h-l)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid]>target){\\n                h = mid-1;\\n            }else\\n                l = mid+1;\\n        }\\n        \\n        return INT_MAX;            \\n    }\\n    \\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i<n-1; i++)  //IMP \\n        {   \\n            if(nums[i]>0 and nums[i]>target)        //condition for positive numbers only\\n                break;\\n            \\n            int index = bs(nums,i+1,n-1,target - nums[i]);\\n            \\n            if(index!= INT_MAX){\\n                ans.push_back(i+1);\\n                ans.push_back(index+1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // USING BINARY SEARCH - nLogn\\n    \\n    int bs(vector<int> &nums, int i ,int j,int target){\\n        int l = i, h = j;\\n        int mid;\\n        \\n        while(l<=h)\\n        {\\n            mid = l + (h-l)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid]>target){\\n                h = mid-1;\\n            }else\\n                l = mid+1;\\n        }\\n        \\n        return INT_MAX;            \\n    }\\n    \\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        \\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(int i = 0; i<n-1; i++)  //IMP \\n        {   \\n            if(nums[i]>0 and nums[i]>target)        //condition for positive numbers only\\n                break;\\n            \\n            int index = bs(nums,i+1,n-1,target - nums[i]);\\n            \\n            if(index!= INT_MAX){\\n                ans.push_back(i+1);\\n                ans.push_back(index+1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014406,
                "title": "two-pointer-using-binary-search-time-o-n-o-1-space-java",
                "content": "* This question straightforward uses **two-pointer** algo , but we can also use **binary search**  within it,  just to remove unwanted part of array (using unwanted part eliminate technique) \\nwhenever eliminated condition hit ,else normally executing by two pointer algo ,  that is help to reduce the overall time complexity .\\n\\n* Basically binary search helps to removes that part of array which have element greater than target.\\n    and only left with element that are lesser than target, on which we apply two-pointer algo.\\n\\n\\n**Time - O(Logn) + O(N) = O(N)\\nSpace - O(1)**\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n     \\n        int i=0;\\n        int j=numbers.length-1;\\n        int[] arr={1,1};\\n        while(i<=j){ \\n            int mid=(i+j)/2;\\n            if(target>0 && numbers[mid]>target){\\n                j=mid-1;\\n            }\\n            else{\\n                if(numbers[i]+numbers[mid]>target){\\n                    j=mid-1;\\n                }\\n            if(numbers[i]+numbers[j]==target){ \\n                arr[0]=i+1;\\n                arr[1]=j+1;\\n                break;\\n            } \\n            if(numbers[i]+numbers[j]<target){\\n                i++; \\n            }\\n            if(numbers[i]+numbers[j]>target){\\n                j--; \\n            }\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n     \\n        int i=0;\\n        int j=numbers.length-1;\\n        int[] arr={1,1};\\n        while(i<=j){ \\n            int mid=(i+j)/2;\\n            if(target>0 && numbers[mid]>target){\\n                j=mid-1;\\n            }\\n            else{\\n                if(numbers[i]+numbers[mid]>target){\\n                    j=mid-1;\\n                }\\n            if(numbers[i]+numbers[j]==target){ \\n                arr[0]=i+1;\\n                arr[1]=j+1;\\n                break;\\n            } \\n            if(numbers[i]+numbers[j]<target){\\n                i++; \\n            }\\n            if(numbers[i]+numbers[j]>target){\\n                j--; \\n            }\\n        }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991249,
                "title": "python-simple-beats-84",
                "content": "```\\nclass Solution:\\n    def twoSum(self, n: List[int], target: int) -> List[int]:\\n        \\n        i=0\\n        j=len(n)-1\\n        while i<j:\\n            x=n[i]+n[j]\\n            if(x==target):\\n                return i+1,j+1\\n            elif(x<target):\\n                i+=1\\n            else:\\n                j-=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoSum(self, n: List[int], target: int) -> List[int]:\\n        \\n        i=0\\n        j=len(n)-1\\n        while i<j:\\n            x=n[i]+n[j]\\n            if(x==target):\\n                return i+1,j+1\\n            elif(x<target):\\n                i+=1\\n            else:\\n                j-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846741,
                "title": "java-two-pointer-easy-solution",
                "content": "```\\nclass Solution {\\n      public int[] twoSum(int[] numbers, int target) {\\n        // we assume that s=start,e=end has two pointer\\n           int s=0, e=numbers.length-1;\\n          while(s<e){\\n                if(numbers[s]+numbers[e]>target){\\n                         e--;\\n                }else if(numbers[s]+numbers[e]<target){\\n                         s++;\\n                }else\\n                 {\\n                //In the question says that index start from 1 not 0\\n                              return new int[]{s+1,e+1}; // create new      array for put s & e\\n                  }\\n              }\\n                     return new int[]{};\\n          }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int[] twoSum(int[] numbers, int target) {\\n        // we assume that s=start,e=end has two pointer\\n           int s=0, e=numbers.length-1;\\n          while(s<e){\\n                if(numbers[s]+numbers[e]>target){\\n                         e--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1776647,
                "title": "c-2-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n     \\n        int i1=0,i2=nums.size()-1;\\n        \\n        while(i1 <=i2 ){\\n            \\n            if(nums[i1]+nums[i2] == target) return {i1+1,i2+1};\\n            else if(nums[i1]+nums[i2] > target) i2--;\\n            else i1++;\\n            \\n        }\\n        return {};\\n    }\\n};\\n```\\n\\nPlease **Upvote** if you liked my solution.\\nDon\\'t forget to visit my repository: https://github.com/tarunsahnan/LeetCode-Solutions",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n     \\n        int i1=0,i2=nums.size()-1;\\n        \\n        while(i1 <=i2 ){\\n            \\n            if(nums[i1]+nums[i2] == target) return {i1+1,i2+1};\\n            else if(nums[i1]+nums[i2] > target) i2--;\\n            else i1++;\\n            \\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1762376,
                "title": "c-efficient-two-pointers-tc-o-n-sc-1-with-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n##### Two pointer technique:-\\n* We can exploit the sorted property of an array.\\n* Let\\'s say for indices` i` & `j` such that` i<j,`\\n* if sum of elements `nums[i]+nums[j] == target, `then we are done\\n* else check whether `nums[i]+nums[j] > target,` then last element has to be removed to reduce the value of sum` (j--).`\\n* similarly if `nums[i]+nums[j] < target`, we have to add little to increase the sum `(i++).`\\n\\n*Time Complexity: O (n)\\nSpace Complexity: O (1)*\\n\\n##### C++ code:-\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0,j=numbers.size()-1;\\n        while(i<=j){\\n            if(numbers[i]+numbers[j]==target) return {i+1,j+1};\\n            else if((numbers[i]+numbers[j]) > target) j--;\\n            else if((numbers[i]+numbers[j]) < target) i++;   \\n        }\\n\\t\\treturn {};//to avoid leetcode error;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int i=0,j=numbers.size()-1;\\n        while(i<=j){\\n            if(numbers[i]+numbers[j]==target) return {i+1,j+1};\\n            else if((numbers[i]+numbers[j]) > target) j--;\\n            else if((numbers[i]+numbers[j]) < target) i++;   \\n        }\\n\\t\\treturn {};//to avoid leetcode error;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708101,
                "title": "javascript-map-o-n-time-o-n-space",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n    const map = new Map(numbers.map((n, i) => [n, i]));\\n    \\n    for(let i = 0; i < numbers.length; i++) {\\n        const complement = Math.abs(numbers[i] - target);\\n        \\n        if (map.has(complement)) {\\n            return [i + 1, map.get(complement) + 1];\\n        }\\n    }\\n    \\n    return [];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    const map = new Map(numbers.map((n, i) => [n, i]));\\n    \\n    for(let i = 0; i < numbers.length; i++) {\\n        const complement = Math.abs(numbers[i] - target);\\n        \\n        if (map.has(complement)) {\\n            return [i + 1, map.get(complement) + 1];\\n        }\\n    }\\n    \\n    return [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706003,
                "title": "faster-than-99-javascript-solution",
                "content": "```\\nvar twoSum = function(numbers, target) {\\n    const seen = {};\\n    for (let i = 0; i < numbers.length; i++) {\\n        const needed = seen[target - numbers[i]];\\n        if (needed !== undefined) {\\n            return [needed + 1, i + 1];\\n        }\\n        seen[numbers[i]] = i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    const seen = {};\\n    for (let i = 0; i < numbers.length; i++) {\\n        const needed = seen[target - numbers[i]];\\n        if (needed !== undefined) {\\n            return [needed + 1, i + 1];\\n        }\\n        seen[numbers[i]] = i;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578339,
                "title": "java-0ms-faster-than-100-optimized-solution-two-pointer-binary-search",
                "content": "```\\n/*\\nC: sorted in non-decreasing order  - > asc dup 1 <= index1 < index2 <= numbers.length\\nA:exactly one solution. \\nR:if length == 2, + -> return 2 indexes 1-indexed return 0-index + 1\\n    mid < target / 2 -> bs -> reduce by left + mid and mid + right -> worst case two pointer O(n),  binary search O(logn), total O(n)\\nT:[0, 1] [1,1, 1, 1, 2, 7,] \\n\\n*/\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[]{-1, -1};\\n        // corner case \\n        if (numbers.length < 2) {\\n            return res;\\n        }\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            // case 1\\n            if (numbers[left] + numbers[right] == target) {\\n                return new int[]{left + 1, right + 1};\\n            } else if (numbers[left] + numbers[right] < target) {\\n                // case 2\\n                if (numbers[mid] + numbers[right] == target) {\\n                    return new int[]{mid + 1, right + 1};\\n                } else if (numbers[mid] + numbers[right] < target) {\\n                    left = mid + 1;\\n                } else {\\n                    left++;\\n                }\\n            } else { // numbers[left] + numbers[right] > target\\n                 // case 3    \\n                if (numbers[left] + numbers[mid] == target) {\\n                    return new int[]{left + 1, mid + 1};\\n                } else if (numbers[left] + numbers[mid] > target) {\\n                    right = mid - 1;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\nC: sorted in non-decreasing order  - > asc dup 1 <= index1 < index2 <= numbers.length\\nA:exactly one solution. \\nR:if length == 2, + -> return 2 indexes 1-indexed return 0-index + 1\\n    mid < target / 2 -> bs -> reduce by left + mid and mid + right -> worst case two pointer O(n),  binary search O(logn), total O(n)\\nT:[0, 1] [1,1, 1, 1, 2, 7,] \\n\\n*/\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int[] res = new int[]{-1, -1};\\n        // corner case \\n        if (numbers.length < 2) {\\n            return res;\\n        }\\n        int left = 0;\\n        int right = numbers.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            // case 1\\n            if (numbers[left] + numbers[right] == target) {\\n                return new int[]{left + 1, right + 1};\\n            } else if (numbers[left] + numbers[right] < target) {\\n                // case 2\\n                if (numbers[mid] + numbers[right] == target) {\\n                    return new int[]{mid + 1, right + 1};\\n                } else if (numbers[mid] + numbers[right] < target) {\\n                    left = mid + 1;\\n                } else {\\n                    left++;\\n                }\\n            } else { // numbers[left] + numbers[right] > target\\n                 // case 3    \\n                if (numbers[left] + numbers[mid] == target) {\\n                    return new int[]{left + 1, mid + 1};\\n                } else if (numbers[left] + numbers[mid] > target) {\\n                    right = mid - 1;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1537424,
                "title": "2-easy-js-solutions-with-complexity",
                "content": "Solution 1:  **Two pointers**  \\nTC: O(N) SC: O(1)\\n\\n```\\nvar twoSum = function(numbers, target) {\\n    let start = 0;\\n    let end = numbers.length - 1;\\n    while(start < end) {\\n        let sum = numbers[start] + numbers[end];\\n        if(sum > target) {\\n            end--;\\n        } else if(sum < target) {\\n            start++;\\n        } else {\\n            return [start + 1, end + 1];\\n        }\\n    }\\n}\\n```\\n\\nSolution 2: **Binary Search**\\nTC: O(NlogN)\\nSC: O(1)\\n\\n```\\nvar twoSum = function(numbers, target) {\\n\\tfor(let i = 0;i< numbers.length;i++) {\\n        let number = numbers[i];\\n        let complement = target - number; \\n         \\n        let low = i + 1; //Search for complement from next index\\n        let high = numbers.length - 1;\\n         \\n        while(low <= high) {\\n            let mid = low + Math.floor((high - low) / 2);\\n            \\n            if(numbers[mid] === complement) {\\n                return [i + 1, mid + 1];\\n            } else if(numbers[mid] < complement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nvar twoSum = function(numbers, target) {\\n    let start = 0;\\n    let end = numbers.length - 1;\\n    while(start < end) {\\n        let sum = numbers[start] + numbers[end];\\n        if(sum > target) {\\n            end--;\\n        } else if(sum < target) {\\n            start++;\\n        } else {\\n            return [start + 1, end + 1];\\n        }\\n    }\\n}\\n```\n```\\nvar twoSum = function(numbers, target) {\\n\\tfor(let i = 0;i< numbers.length;i++) {\\n        let number = numbers[i];\\n        let complement = target - number; \\n         \\n        let low = i + 1; //Search for complement from next index\\n        let high = numbers.length - 1;\\n         \\n        while(low <= high) {\\n            let mid = low + Math.floor((high - low) / 2);\\n            \\n            if(numbers[mid] === complement) {\\n                return [i + 1, mid + 1];\\n            } else if(numbers[mid] < complement) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503779,
                "title": "rust-loop",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Two Sum II - Input array is sorted.\\nMemory Usage: 2.1 MB, less than 60.15% of Rust online submissions for Two Sum II - Input array is sorted.\\n```\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut first: usize = 0;\\n        let mut second: usize = numbers.len()-1;\\n        \\n        while first < second {\\n            if numbers[first]+numbers[second] == target {\\n                break;\\n            } else if numbers[first]+numbers[second] < target {\\n                first+=1;\\n            } else {\\n                second-=1;\\n            }\\n        }\\n        return Vec::from([first as i32 + 1, second as i32 + 1]);\\n    }\\n}",
                "solutionTags": [
                    "Rust"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Two Sum II - Input array is sorted.\\nMemory Usage: 2.1 MB, less than 60.15% of Rust online submissions for Two Sum II - Input array is sorted.\\n```\\nimpl Solution {\\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\\n        let mut first: usize = 0;\\n        let mut second: usize = numbers.len()-1;\\n        \\n        while first < second {\\n            if numbers[first]+numbers[second] == target {\\n                break;\\n            } else if numbers[first]+numbers[second] < target {\\n                first+=1;\\n            } else {\\n                second-=1;\\n            }\\n        }\\n        return Vec::from([first as i32 + 1, second as i32 + 1]);\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1448922,
                "title": "java-clean-concise-optimal-code-two-pointer-technique-o-n-time-solution",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int start = 0, end = numbers.length - 1;\\n        \\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[] {start + 1, end + 1};\\n            }\\n            else if (numbers[start] + numbers[end] < target) {\\n                ++start;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n        \\n        return new int[] {-1, -1};\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        \\n        int start = 0, end = numbers.length - 1;\\n        \\n        while (start < end) {\\n            if (numbers[start] + numbers[end] == target) {\\n                return new int[] {start + 1, end + 1};\\n            }\\n            else if (numbers[start] + numbers[end] < target) {\\n                ++start;\\n            }\\n            else {\\n                --end;\\n            }\\n        }\\n        \\n        return new int[] {-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411559,
                "title": "runtime-4-ms-faster-than-88-54",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int i = 0 , j = numbers.size()-1;\\n        while(i < j)\\n        {\\n            if(numbers[i] + numbers[j] > target)\\n                j--;\\n            else\\n            if(numbers[i] + numbers[j] < target)\\n                i++;\\n            else\\n                break;\\n            \\n                \\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        int i = 0 , j = numbers.size()-1;\\n        while(i < j)\\n        {\\n            if(numbers[i] + numbers[j] > target)\\n                j--;\\n            else\\n            if(numbers[i] + numbers[j] < target)\\n                i++;\\n            else\\n                break;\\n            \\n                \\n        }\\n        return {i+1,j+1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273272,
                "title": "kotlin-100-faster-100-memory-effecient-2-pointer-solution-o-n-time-clean-kotlin-syntax",
                "content": "\\tfun twoSum(numbers: IntArray, target: Int): IntArray {\\n\\t\\tvar i = 1\\n\\t\\tvar j = numbers.size\\n\\n\\t\\twhile (true) { //Use of `while` is ok since an answer is guaranteed \\n\\t\\t\\tval sumIJ = numbers[i-1] + numbers[j-1]\\n\\t\\t\\twhen { //Use of `when` to promote kotlin clean coding convention\\n\\t\\t\\t\\tsumIJ == target -> return intArrayOf(i, j)\\n\\t\\t\\t\\tsumIJ < target -> i++ //shift pointer to the right\\n\\t\\t\\t\\tsumIJ > target -> j-- //shift pointer to the left\\n\\t\\t\\t\\ti == j -> throw IllegalArgumentException(\"No sum\")\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\t\\nPlease Upvote if you like my answer.",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "\\tfun twoSum(numbers: IntArray, target: Int): IntArray {\\n\\t\\tvar i = 1\\n\\t\\tvar j = numbers.size\\n\\n\\t\\twhile (true) { //Use of `while` is ok since an answer is guaranteed \\n\\t\\t\\tval sumIJ = numbers[i-1] + numbers[j-1]\\n\\t\\t\\twhen { //Use of `when` to promote kotlin clean coding convention\\n\\t\\t\\t\\tsumIJ == target -> return intArrayOf(i, j)\\n\\t\\t\\t\\tsumIJ < target -> i++ //shift pointer to the right\\n\\t\\t\\t\\tsumIJ > target -> j-- //shift pointer to the left\\n\\t\\t\\t\\ti == j -> throw IllegalArgumentException(\"No sum\")\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n\\t\\nPlease Upvote if you like my answer.",
                "codeTag": "Unknown"
            },
            {
                "id": 1136521,
                "title": "python-two-pointers",
                "content": "```\\ndef twoSum(self, numbers: List[int], target: int) -> List[int]: \\n        left = 0\\n        right = len(numbers) - 1\\n        \\n        sumLR = 0\\n        \\n        while left <= right:\\n            sumLR = numbers[left] + numbers[right]\\n            \\n            if sumLR > target:\\n                right -= 1\\n            elif sumLR < target:\\n                left += 1\\n            else:\\n                return [left+1, right+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef twoSum(self, numbers: List[int], target: int) -> List[int]: \\n        left = 0\\n        right = len(numbers) - 1\\n        \\n        sumLR = 0\\n        \\n        while left <= right:\\n            sumLR = numbers[left] + numbers[right]\\n            \\n            if sumLR > target:\\n                right -= 1\\n            elif sumLR < target:\\n                left += 1\\n            else:\\n                return [left+1, right+1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 767436,
                "title": "o-n-c-solution-fast-and-easy-to-understand",
                "content": "```\\nint* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\\n    int* ans = malloc(sizeof(int)*2);\\n    *returnSize = 2;\\n    int l = 0, r = numbersSize-1;\\n    while (l < r)\\n    {\\n        if (numbers[l] + numbers[r] == target)\\n        {\\n            ans[0] = l+1; ans[1] = r+1;\\n            return ans;\\n        }\\n        else\\n        {\\n            if (numbers[l] + numbers[r] < target)\\n                l++;\\n            else\\n                r--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* twoSum(int* numbers, int numbersSize, int target, int* returnSize){\\n    int* ans = malloc(sizeof(int)*2);\\n    *returnSize = 2;\\n    int l = 0, r = numbersSize-1;\\n    while (l < r)\\n    {\\n        if (numbers[l] + numbers[r] == target)\\n        {\\n            ans[0] = l+1; ans[1] = r+1;\\n            return ans;\\n        }\\n        else\\n        {\\n            if (numbers[l] + numbers[r] < target)\\n                l++;\\n            else\\n                r--;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748113,
                "title": "ruby-hash-approach",
                "content": "```\\ndef two_sum(numbers, target)\\n    hash = {}\\n    \\n    numbers.each_with_index do |num, i|\\n        return hash[target - num] + 1, i + 1 if hash[target - num]\\n        hash[num] = i\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef two_sum(numbers, target)\\n    hash = {}\\n    \\n    numbers.each_with_index do |num, i|\\n        return hash[target - num] + 1, i + 1 if hash[target - num]\\n        hash[num] = i\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 646794,
                "title": "java-two-pointer-solution",
                "content": "![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_167.png)  \\n\\n\\n``` java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int lo = 0, len = numbers.length, hi = len - 1;\\n        while (lo < hi){\\n            int sum = numbers[lo] + numbers[hi];\\n            if (sum == target){\\n                return new int[]{lo + 1, hi + 1};\\n            } else if (sum < target){\\n                lo++;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int lo = 0, len = numbers.length, hi = len - 1;\\n        while (lo < hi){\\n            int sum = numbers[lo] + numbers[hi];\\n            if (sum == target){\\n                return new int[]{lo + 1, hi + 1};\\n            } else if (sum < target){\\n                lo++;\\n            } else {\\n                hi--;\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487895,
                "title": "java-0-ms-use-two-pointer-approach-while-avoiding-overflow",
                "content": "The accepted solution does not work for inputs with a valid solution where there is a possibility of overflow. The following should be added as a test case and the reference implementation should be updated:\\n![image](https://assets.leetcode.com/users/ed-karabinus/image_1579731057.png)\\n\\n\\n![image](https://assets.leetcode.com/users/ed-karabinus/image_1579730847.png)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int numbersLength = numbers.length;\\n        int low = 0;\\n        int high = numbersLength - 1;\\n        while (low < high) {\\n            int complement = target - numbers[low];\\n            if (complement == numbers[high]) {\\n                return new int[] { low + 1, high + 1 };\\n            } else if (complement > numbers[high]) {\\n                low++;\\n            } else {\\n                high--;\\n            }\\n        }\\n        // We are guaranteed an input with a valid solution,\\n        // so this line will never be reached.\\n        return new int[] { 0, 0 };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int numbersLength = numbers.length;\\n        int low = 0;\\n        int high = numbersLength - 1;\\n        while (low < high) {\\n            int complement = target - numbers[low];\\n            if (complement == numbers[high]) {\\n                return new int[] { low + 1, high + 1 };\\n            } else if (complement > numbers[high]) {\\n                low++;\\n            } else {\\n                high--;\\n            }\\n        }\\n        // We are guaranteed an input with a valid solution,\\n        // so this line will never be reached.\\n        return new int[] { 0, 0 };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362277,
                "title": "ruby-solution",
                "content": "```\\ndef two_sum(numbers, target)\\n    i = 0\\n    j = numbers.length-1\\n    while(i < j)\\n        curr_sum = numbers[i]+numbers[j]\\n        if(target > curr_sum)\\n            i += 1\\n        elsif(target < curr_sum)\\n            j -= 1\\n        else\\n            return [i+1,j+1]\\n        end\\n    end\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef two_sum(numbers, target)\\n    i = 0\\n    j = numbers.length-1\\n    while(i < j)\\n        curr_sum = numbers[i]+numbers[j]\\n        if(target > curr_sum)\\n            i += 1\\n        elsif(target < curr_sum)\\n            j -= 1\\n        else\\n            return [i+1,j+1]\\n        end\\n    end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4083125,
                "title": "two-sum-ii-sorted-array-solution-beats-99-23",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing two pointers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the fact the the list is sorted and there exists only one solution, we traverse the list using two pointers both from both ends of the list until they point to the values that add up to target. If the sum at the right and left pointers is greater than target, move the right ponter to the left. If it is less, move the left pointer to the right.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) extra space\\n\\n# Code\\n```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l=0\\n        r=len(numbers)-1\\n        while True:\\n            if numbers[l]+numbers[r] > target:\\n                r-=1\\n            elif numbers[l]+numbers[r] < target:\\n                l+=1\\n            else:\\n                return [l+1,r+1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        \"\"\"\\n        :type numbers: List[int]\\n        :type target: int\\n        :rtype: List[int]\\n        \"\"\"\\n        l=0\\n        r=len(numbers)-1\\n        while True:\\n            if numbers[l]+numbers[r] > target:\\n                r-=1\\n            elif numbers[l]+numbers[r] < target:\\n                l+=1\\n            else:\\n                return [l+1,r+1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768425,
                "title": "javascript-best-solution-with-explanation-two-pointers",
                "content": "# Approach\\n- Declare two pointers at the start and end of the array.\\n- Loop through the array until the sum of the two pointers is equal to the target.\\n- If the sum is greater than the target, move the right pointer to the left\\n- If the sum is less than the target, move the left pointer to the right\\n- Return the indices of the two pointers + 1\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function (numbers, target) {\\n  // declare two pointers at the start and end of the array\\n  let left = 0\\n  let right = numbers.length - 1\\n\\n  // loop through the array until the sum of the two pointers is equal to the target\\n  while (numbers[left] + numbers[right] !== target) {\\n    // if the sum is greater than the target, move the right pointer to the left\\n    if (numbers[left] + numbers[right] > target) {\\n      right--\\n    } else {\\n      // if the sum is less than the target, move the left pointer to the right\\n      left++\\n    }\\n  }\\n\\n  // return the indices of the two pointers + 1\\n  return [left + 1, right + 1]\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function (numbers, target) {\\n  // declare two pointers at the start and end of the array\\n  let left = 0\\n  let right = numbers.length - 1\\n\\n  // loop through the array until the sum of the two pointers is equal to the target\\n  while (numbers[left] + numbers[right] !== target) {\\n    // if the sum is greater than the target, move the right pointer to the left\\n    if (numbers[left] + numbers[right] > target) {\\n      right--\\n    } else {\\n      // if the sum is less than the target, move the left pointer to the right\\n      left++\\n    }\\n  }\\n\\n  // return the indices of the two pointers + 1\\n  return [left + 1, right + 1]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3630007,
                "title": "python3",
                "content": "\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        left, right = 0, len(numbers) - 1  # Initialize two pointers, left and right, pointing to the start and end of the list respectively.\\n\\n        while left < right:  # Continue the loop until the pointers meet or cross each other.\\n            if numbers[left] + numbers[right] == target:  # If the sum of the numbers at the left and right pointers is equal to the target:\\n                return [left + 1, right + 1]  # Return the indices (1-based) of the two numbers that add up to the target.\\n            \\n            if numbers[left] + numbers[right] < target:  # If the sum is less than the target:\\n                left += 1  # Move the left pointer to the right, increasing its index.\\n            else:  # If the sum is greater than the target:\\n                right -= 1  # Move the right pointer to the left, decreasing its index.\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        left, right = 0, len(numbers) - 1  # Initialize two pointers, left and right, pointing to the start and end of the list respectively.\\n\\n        while left < right:  # Continue the loop until the pointers meet or cross each other.\\n            if numbers[left] + numbers[right] == target:  # If the sum of the numbers at the left and right pointers is equal to the target:\\n                return [left + 1, right + 1]  # Return the indices (1-based) of the two numbers that add up to the target.\\n            \\n            if numbers[left] + numbers[right] < target:  # If the sum is less than the target:\\n                left += 1  # Move the left pointer to the right, increasing its index.\\n            else:  # If the sum is greater than the target:\\n                right -= 1  # Move the right pointer to the left, decreasing its index.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384290,
                "title": "java-two-pointers-get-two-indexes",
                "content": "\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n                int left = 0;\\n        int right = numbers.length - 1;\\n        int tmp;\\n        while (left < right)\\n        {\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[right];\\n            while (numbers[left] < tmp) left++;\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[left];\\n            while (numbers[right] > tmp) right--;\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n                int left = 0;\\n        int right = numbers.length - 1;\\n        int tmp;\\n        while (left < right)\\n        {\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[right];\\n            while (numbers[left] < tmp) left++;\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[left];\\n            while (numbers[right] > tmp) right--;\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341849,
                "title": "easy-java-solution-two-pointer-approach",
                "content": "\\n\\n# Approach\\nTwo Pointer\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int ans[]=new int[2];\\n        int i=0;\\n        int j=numbers.length-1;\\n\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n            ans[0]=i+1;\\n            ans[1]=j+1;\\n            break;\\n            }\\n            else if(numbers[i]+numbers[j]>target)\\n            j--;\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int ans[]=new int[2];\\n        int i=0;\\n        int j=numbers.length-1;\\n\\n        while(i<j){\\n            if(numbers[i]+numbers[j]==target){\\n            ans[0]=i+1;\\n            ans[1]=j+1;\\n            break;\\n            }\\n            else if(numbers[i]+numbers[j]>target)\\n            j--;\\n            else if(numbers[i]+numbers[j]<target)\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159765,
                "title": "java-best-solution-two-pointers-clean-code-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0;\\n        int end = numbers.length-1;\\n        int sum = 0;\\n        while(start < end){\\n            sum = numbers[start] + numbers[end];\\n            if(sum == target) return new int[] {start + 1, end + 1};\\n            if(sum < target) start++;\\n            else end--;\\n        }\\n        return new int[] {0, 0};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start = 0;\\n        int end = numbers.length-1;\\n        int sum = 0;\\n        while(start < end){\\n            sum = numbers[start] + numbers[end];\\n            if(sum == target) return new int[] {start + 1, end + 1};\\n            if(sum < target) start++;\\n            else end--;\\n        }\\n        return new int[] {0, 0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118646,
                "title": "1ms-using-two-pointers-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo Pointers\\n1. Using two pointers to track the start and end of array\\n2. Adjust the start and end pointers accordingly by comparing their sum and the target\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n          O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n          O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int end = numbers.length-1;\\n        int start = 0;\\n        while(start != end){\\n            int sum = numbers[start] + numbers[end];\\n            if(sum < target){\\n                start++;\\n            }else if( sum > target){\\n                end--;\\n            }else{\\n                int[] ans = {start+1 , end+1};\\n                return ans;\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int end = numbers.length-1;\\n        int start = 0;\\n        while(start != end){\\n            int sum = numbers[start] + numbers[end];\\n            if(sum < target){\\n                start++;\\n            }else if( sum > target){\\n                end--;\\n            }else{\\n                int[] ans = {start+1 , end+1};\\n                return ans;\\n            }\\n        }\\n        return new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118576,
                "title": "1ms-2-pointer-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                int[] arr = {left + 1, right + 1};\\n                return arr;\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int len = numbers.length;\\n        int left = 0;\\n        int right = len - 1;\\n        while (left < right) {\\n            if (numbers[left] + numbers[right] > target) {\\n                right--;\\n            } else if (numbers[left] + numbers[right] < target) {\\n                left++;\\n            } else {\\n                int[] arr = {left + 1, right + 1};\\n                return arr;\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106481,
                "title": "java-easy-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] twoSum(int[] n, int t) {\\n        int arr[]=new int[2];\\n      // if(n.length==2){\\n        //   return new int[]{1,2};\\n      // }\\n        for(int i=0;i<=n.length;++i){\\n            for(int j=i+1;j<n.length;++j){\\n                if(n[i]+n[j]==t){\\n                 //   System.out.print(n[i]+\" \"+n[j]+\" \");\\n                   arr[0]=i+1;\\n                   arr[1]=j+1;\\n                   //break;\\n                   return arr;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] n, int t) {\\n        int arr[]=new int[2];\\n      // if(n.length==2){\\n        //   return new int[]{1,2};\\n      // }\\n        for(int i=0;i<=n.length;++i){\\n            for(int j=i+1;j<n.length;++j){\\n                if(n[i]+n[j]==t){\\n                 //   System.out.print(n[i]+\" \"+n[j]+\" \");\\n                   arr[0]=i+1;\\n                   arr[1]=j+1;\\n                   //break;\\n                   return arr;\\n                }\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105605,
                "title": "easy-to-understand-for-beginners-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& num, int target) {\\n        int id=0;\\n        for(int i=0;i<num.size();++i){\\n            int x=num[i];\\n            id=i;\\n            int s=i+1,e=num.size()-1;\\n            int mid=s+(e-s)/2;\\n            while(s<=e){\\n                if(x+num[mid]==target)\\n                    return {id+1,mid+1};\\n                else if(x+num[mid]>target){\\n                    e=mid-1;\\n                }\\n                else\\n                    s=mid+1;\\n                mid=s+(e-s)/2;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& num, int target) {\\n        int id=0;\\n        for(int i=0;i<num.size();++i){\\n            int x=num[i];\\n            id=i;\\n            int s=i+1,e=num.size()-1;\\n            int mid=s+(e-s)/2;\\n            while(s<=e){\\n                if(x+num[mid]==target)\\n                    return {id+1,mid+1};\\n                else if(x+num[mid]>target){\\n                    e=mid-1;\\n                }\\n                else\\n                    s=mid+1;\\n                mid=s+(e-s)/2;\\n            }\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635156,
                "title": "python-faster-than-80-with-explanation",
                "content": "```\\n\"\"\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\"\"\"\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        d={}\\n        for i in range(len(numbers)):\\n            diff=target-numbers[i]\\n            if diff in d:\\n                return [d[diff],i+1]\\n            else:\\n                d[numbers[i]]=i+1\\n        return \\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 156 ms, faster than 80.41% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    # Memory Usage: 15 MB, less than 40.90% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    \\n# EXPLANATION:-\\n    # We will solve this using a hashmap\\n    # We will iterate through the numbers array using the range function\\n    # We will store the difference between the target and current element in diff variable\\n    # We will check if diff is in d(our hasmap), if it is, we will return its index and the index of current element +1 (because indexing starts from zero)\\n    # If it is not present, we will add the current element to the dictionary and its index as +1 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/\"\"\"\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        d={}\\n        for i in range(len(numbers)):\\n            diff=target-numbers[i]\\n            if diff in d:\\n                return [d[diff],i+1]\\n            else:\\n                d[numbers[i]]=i+1\\n        return \\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 156 ms, faster than 80.41% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    # Memory Usage: 15 MB, less than 40.90% of Python3 online submissions for Two Sum II - Input Array Is Sorted.\\n    \\n# EXPLANATION:-\\n    # We will solve this using a hashmap\\n    # We will iterate through the numbers array using the range function\\n    # We will store the difference between the target and current element in diff variable\\n    # We will check if diff is in d(our hasmap), if it is, we will return its index and the index of current element +1 (because indexing starts from zero)\\n    # If it is not present, we will add the current element to the dictionary and its index as +1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492070,
                "title": "true-binary-search-javascript-solution-o-n-log-n",
                "content": "**Logic behind the solution**\\nWe\\'ll start solving this by using the following classic TwoSum thinking:\\n*Whenever we have a number selected, (be it array[0] or any position in the array) the number that we need to sum it with to get our target will always be equal to `target - said number`*.\\nWe don\\'t know if that number exists, but we\\'ll find it by making comparing each position in the array *(via our for loop)* with the other ones using binary search. \\n\\n**Time Complexity**\\n`O(n * log n)`\\n`Reasoning: log(n-1) + log(n-2) .... log(2)`\\n\\n\\n```\\nvar twoSum = function (numbers, target) {\\n    let end = numbers.length - 1\\n\\n    for (let i = 0; i < numbers.length; i++) \\n    {\\n        let start = i + 1\\n        while (start <= end) \\n        {\\n            let middle = Math.floor(start + (end - start) / 2)\\n            if (numbers[middle] < target - numbers[i]) \\n            {\\n                start = middle + 1\\n            }\\n            else if (numbers[middle] > target - numbers[i]) \\n            {\\n                end = middle - 1\\n            }\\n            else if (numbers[middle] + numbers[i] === target) \\n            {\\n                return [i + 1, middle + 1]\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar twoSum = function (numbers, target) {\\n    let end = numbers.length - 1\\n\\n    for (let i = 0; i < numbers.length; i++) \\n    {\\n        let start = i + 1\\n        while (start <= end) \\n        {\\n            let middle = Math.floor(start + (end - start) / 2)\\n            if (numbers[middle] < target - numbers[i]) \\n            {\\n                start = middle + 1\\n            }\\n            else if (numbers[middle] > target - numbers[i]) \\n            {\\n                end = middle - 1\\n            }\\n            else if (numbers[middle] + numbers[i] === target) \\n            {\\n                return [i + 1, middle + 1]\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447778,
                "title": "c-4-approaches-two-pointers-hash-map-binary-search-brute-force-easy",
                "content": "**Kindly Upvote if you find this useful**\\n\\nThe **4 Approaches** are:\\n1. Brute Force\\n1. Binary Search\\n1. Hash Map\\n1. Two Pointers\\n\\n1) **Brute Force**\\n**Time Complexity:** O(N^2)\\n**Space Complexity:**  O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(numbers[i] + numbers[j] == target) return {i+1,j+1};\\n            }\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\\n2) **Binary Search**\\n**Time Complexity:** O(N logN)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target-numbers[i];\\n            \\n            int l = i+1;\\n            int r = n-1;\\n            \\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                \\n                if(numbers[mid] == need) return {i+1,mid+1};\\n                \\n                if(need < numbers[mid]) r = mid-1;\\n                else l = mid+1;\\n            }\\n            \\n        }\\n        return {0,1};\\n    }\\n};\\n```\\n3) **Hash Map**\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[numbers[i]] = i;\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target - numbers[i];\\n            if(mp.find(need) != mp.end() && mp[need] != i)\\n\\t\\t\\t\\treturn {i+1,mp[need]+1};\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\\n4) **Two Pointer**\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        int l = 0;\\n        int r = n-1;\\n        \\n        while(l < r){\\n            int sum = numbers[l] + numbers[r];\\n            \\n            if(sum == target) return {l+1,r+1};\\n            \\n            if(sum < target) l++;\\n            else r--;\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\\n**Kindly Upvote if you find this useful**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(numbers[i] + numbers[j] == target) return {i+1,j+1};\\n            }\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target-numbers[i];\\n            \\n            int l = i+1;\\n            int r = n-1;\\n            \\n            while(l<=r){\\n                int mid = (l+r)/2;\\n                \\n                if(numbers[mid] == need) return {i+1,mid+1};\\n                \\n                if(need < numbers[mid]) r = mid-1;\\n                else l = mid+1;\\n            }\\n            \\n        }\\n        return {0,1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++) mp[numbers[i]] = i;\\n        \\n        for(int i=0;i<n;i++){\\n            int need = target - numbers[i];\\n            if(mp.find(need) != mp.end() && mp[need] != i)\\n\\t\\t\\t\\treturn {i+1,mp[need]+1};\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        \\n        int l = 0;\\n        int r = n-1;\\n        \\n        while(l < r){\\n            int sum = numbers[l] + numbers[r];\\n            \\n            if(sum == target) return {l+1,r+1};\\n            \\n            if(sum < target) l++;\\n            else r--;\\n        }\\n        \\n        return {0,1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298970,
                "title": "simple-python-solutions-for-beginners",
                "content": "1.Brute force it give tle.\\n  TIme complexity: 0(n*n)\\n```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if (nums[i] + nums[j]) == target:\\n                   return[i, j]\\n```  \\n\\n2. Two pointers\\n   Time complexity: 0(n)\\nExplanation: We can make use of the fact that the numbers are sorted. Because the numbers are ascending, we can put two pointers at each end of the array. Then if the sum of the numbers the two pointers are at arent equal to the target sum, then we can move the first pointer forward by one index if the sum of the numbers is too smaller or move the last pointer backwards by one index if the sum of the numbers is too big. \\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        pointer1 = 0\\n        pointer2 = len(numbers) - 1\\n        while numbers[pointer1] + numbers[pointer2] != target:\\n              if numbers[pointer1] + numbers[pointer2] > target:\\n                 pointer2 -= 1\\n              else:\\n                 pointer1 += 1\\n        return [pointer1 + 1, pointer2 + 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                if (nums[i] + nums[j]) == target:\\n                   return[i, j]\\n```\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        pointer1 = 0\\n        pointer2 = len(numbers) - 1\\n        while numbers[pointer1] + numbers[pointer2] != target:\\n              if numbers[pointer1] + numbers[pointer2] > target:\\n                 pointer2 -= 1\\n              else:\\n                 pointer1 += 1\\n        return [pointer1 + 1, pointer2 + 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154515,
                "title": "simple-binary-search-two-pointers-two-methods",
                "content": "Two Pointers: Time Complexity O(N)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        //Q167\\n        //We know that there is only one solution in the entire array and the array is sorted\\n        // So, we can simply check the first element and the last element for the sum\\n        //If the sum is larger than the target, we can instead check for the 2nd last element\\n        //If the sum is smaller than the target, we can instead check for the 2nd element\\n        //This will keep on iterating until we reach the target and the required ans\\n        int firstIndex = 0, lastIndex = numbers.length-1;\\n        while (firstIndex<lastIndex){\\n            int sum = numbers[firstIndex] + numbers[lastIndex];\\n            if (sum==target){\\n                //We have found the answer\\n                return new int[]{firstIndex+1 , lastIndex+1};//As the array is 1-indexed array\\n            }else if (sum>target){\\n                //Sum is greater than the target so, decrease the lastIndex to get a smaller number\\n                lastIndex--;\\n            }else{\\n                //Sum is smaller than the target so, increase the firstIndex to get a larger number\\n                firstIndex++;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```\\nBinary Search O(n*logn)\\n```\\nclass Solution {\\n    public int[] twoSum(int[] nums, int target) {\\n        for (int i = 0; i < nums.length; ++i) {\\n            int low = i + 1;\\n            int high = nums.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                if (nums[mid] == target - nums[i]) {\\n                    return new int[]{i + 1, mid + 1};\\n                } else if (nums[mid] > target - nums[i]) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n        return new int[]{-1, -1};\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        //Q167\\n        //We know that there is only one solution in the entire array and the array is sorted\\n        // So, we can simply check the first element and the last element for the sum\\n        //If the sum is larger than the target, we can instead check for the 2nd last element\\n        //If the sum is smaller than the target, we can instead check for the 2nd element\\n        //This will keep on iterating until we reach the target and the required ans\\n        int firstIndex = 0, lastIndex = numbers.length-1;\\n        while (firstIndex<lastIndex){\\n            int sum = numbers[firstIndex] + numbers[lastIndex];\\n            if (sum==target){\\n                //We have found the answer\\n                return new int[]{firstIndex+1 , lastIndex+1};//As the array is 1-indexed array\\n            }else if (sum>target){\\n                //Sum is greater than the target so, decrease the lastIndex to get a smaller number\\n                lastIndex--;\\n            }else{\\n                //Sum is smaller than the target so, increase the firstIndex to get a larger number\\n                firstIndex++;\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133127,
                "title": "c-solution",
                "content": "Runtime: 169 ms, faster than 73.31% of C# online submissions for Two Sum II - Input Array Is Sorted.\\nMemory Usage: 44.5 MB, less than 94.14% of C# online submissions for Two Sum II - Input Array Is Sorted.\\n```\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int[] RetValue = default;\\n        int left = 0;\\n        int right = numbers.Length - 1;\\n\\n        while (left < right)\\n        { \\n            if (numbers[left] + numbers[right] == target) return new int[] { left+1, right+1 };\\n            if (numbers[left] + numbers[right] < target) left++;\\n            if (numbers[left] + numbers[right] > target) right--;\\n        }\\n\\n        return RetValue;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] TwoSum(int[] numbers, int target) {\\n        int[] RetValue = default;\\n        int left = 0;\\n        int right = numbers.Length - 1;\\n\\n        while (left < right)\\n        { \\n            if (numbers[left] + numbers[right] == target) return new int[] { left+1, right+1 };\\n            if (numbers[left] + numbers[right] < target) left++;\\n            if (numbers[left] + numbers[right] > target) right--;\\n        }\\n\\n        return RetValue;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2131458,
                "title": "c-2-pointers-easy-solution",
                "content": "Easy code. We take one pointer at beginning of **`numbers`** array named **`i`**, and the other pointer at the end of the array named **`j`**.\\n\\nThen we add the two, i.e., **`numbers[i] + numbers[j]`** and compare it to the **`target`** value.\\n\\nIf the addition is equal to our target value, we push both the indices, **`i`** and **`j`** to **`result`** array.\\nHowever, if **`numbers[i] + numbers[j] < target`**, we increment the beginning pointer, i.e., **`i`**.\\nFinally, if **`numbers[i] + numbers[j] > target`**, we decrement the end pointer, i.e., **`j`**.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        vector<int> result;\\n        \\n        int i = 0;\\n        int j = numbers.size() - 1;\\n        \\n        while(i < j){\\n            \\n            if(numbers[i] + numbers[j] == target){\\n                result.push_back(i + 1);\\n                result.push_back(j + 1);\\n                break;\\n            }\\n            \\n            else if(numbers[i] + numbers[j] < target)\\n                i++;\\n            \\n            else\\n                j--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        \\n        vector<int> result;\\n        \\n        int i = 0;\\n        int j = numbers.size() - 1;\\n        \\n        while(i < j){\\n            \\n            if(numbers[i] + numbers[j] == target){\\n                result.push_back(i + 1);\\n                result.push_back(j + 1);\\n                break;\\n            }\\n            \\n            else if(numbers[i] + numbers[j] < target)\\n                i++;\\n            \\n            else\\n                j--;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130590,
                "title": "o-1-time-o-1-space-and-no-branching-javascript",
                "content": "A solution that runs in constant time, uses constant memory, and has no branches:\\n```\\nconst twoSum = (numbers, target) => {\\n    const indices = [0, 0, numbers.length - 1];\\n    const f = () => {\\n        const diff = numbers[indices[0]] + numbers[indices[2]] - target;\\n        const differenceSign = (diff > 0) - (diff < 0);\\n        indices[differenceSign + 1] -= differenceSign;\\n    };\\n    const g = () => f(f(f(f(f()))));\\n    const h = () => g(g(g(g(g()))));\\n    const j = () => h(h(h(h(h()))));\\n    const k = () => j(j(j(j(j()))));\\n    const l = () => k(k(k(k())));\\n    const m = () => l(l(l(l())));\\n    m(m(m()));\\n    return [indices[0] + 1, indices[2] + 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst twoSum = (numbers, target) => {\\n    const indices = [0, 0, numbers.length - 1];\\n    const f = () => {\\n        const diff = numbers[indices[0]] + numbers[indices[2]] - target;\\n        const differenceSign = (diff > 0) - (diff < 0);\\n        indices[differenceSign + 1] -= differenceSign;\\n    };\\n    const g = () => f(f(f(f(f()))));\\n    const h = () => g(g(g(g(g()))));\\n    const j = () => h(h(h(h(h()))));\\n    const k = () => j(j(j(j(j()))));\\n    const l = () => k(k(k(k())));\\n    const m = () => l(l(l(l())));\\n    m(m(m()));\\n    return [indices[0] + 1, indices[2] + 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2130588,
                "title": "c-2-pointer-approach-explained-with-code",
                "content": "**2 Pointer approch explained with code:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        //2 pointer approach\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        //find 2 indexes\\n        vector<int> ans;\\n        while(start < end){\\n            if(nums[start]+ nums[end] == target){   //found the numbers, store them (1- index vector)\\n                ans.push_back(start+1);\\n                ans.push_back(end+1);\\n                break;\\n            }\\n            \\n            else if(nums[start]+ nums[end] < target)    //since array is sorted, moving start pointer ahead will increase sum\\n                start++;\\n            else    //if total sum is more than target, call end pointer backward so that value obtain can be decreased\\n                end--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TC: O(N)\\nSC: O(1)**\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        //2 pointer approach\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        //find 2 indexes\\n        vector<int> ans;\\n        while(start < end){\\n            if(nums[start]+ nums[end] == target){   //found the numbers, store them (1- index vector)\\n                ans.push_back(start+1);\\n                ans.push_back(end+1);\\n                break;\\n            }\\n            \\n            else if(nums[start]+ nums[end] < target)    //since array is sorted, moving start pointer ahead will increase sum\\n                start++;\\n            else    //if total sum is more than target, call end pointer backward so that value obtain can be decreased\\n                end--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128751,
                "title": "faster-than-100-c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& a, int target) {\\n        int n = a.size();\\n        int i=0, j=n-1;\\n        while(i<j){\\n            int tm = a[i] + a[j];\\n            if(tm==target){\\n                vector<int> v = {i+1, j+1};\\n                return v;\\n            }\\n            else if(tm>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return a;\\n    }\\n\\t//* If You find helpful upvote*\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& a, int target) {\\n        int n = a.size();\\n        int i=0, j=n-1;\\n        while(i<j){\\n            int tm = a[i] + a[j];\\n            if(tm==target){\\n                vector<int> v = {i+1, j+1};\\n                return v;\\n            }\\n            else if(tm>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n        return a;\\n    }\\n\\t//* If You find helpful upvote*\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096815,
                "title": "java-3-approaches-binary-two-pointer-hashmap",
                "content": "**Binary Search (1ms): O(log(n))**\\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                if(nums[i] + nums[m] > target)\\n                    j = m - 1;\\n                else\\n                    j--;\\n            else\\n                if(nums[m] + nums[j] < target)\\n                    i = m + 1;\\n                else\\n                    i++;\\n        }\\n        \\n        return null;\\n    }\\n```\\n**Two-Pointer (2ms): O(n)**\\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return null;\\n    }\\n```\\n**Brute Force, HashMap (8ms): O(n)**\\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int n = target - nums[i];\\n            \\n            if(map.containsKey(n)) \\n                return new int[] {map.get(n) + 1, i + 1};\\n            \\n            map.put(nums[i], i);\\n        }\\n        \\n        return null;\\n    }\\n```\\n***Upvote ^, If you like it!***",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                if(nums[i] + nums[m] > target)\\n                    j = m - 1;\\n                else\\n                    j--;\\n            else\\n                if(nums[m] + nums[j] < target)\\n                    i = m + 1;\\n                else\\n                    i++;\\n        }\\n        \\n        return null;\\n    }\\n```\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        int i = 0, j = nums.length - 1;\\n        \\n        while(i < j) {\\n            int m = i + (j - i) /  2;\\n            int sum = nums[i] + nums[j];\\n            \\n            if(sum == target) \\n                return new int[] {i+1, j+1};\\n            \\n            if(sum >= target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return null;\\n    }\\n```\n```\\n    public int[] twoSum(int[] nums, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            int n = target - nums[i];\\n            \\n            if(map.containsKey(n)) \\n                return new int[] {map.get(n) + 1, i + 1};\\n            \\n            map.put(nums[i], i);\\n        }\\n        \\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039142,
                "title": "fastest-100-0ms-shortestcode",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int a = 0;\\n        int b = numbers.length -1;\\n        while (numbers[a] + numbers[b] != target) {\\n            if (numbers[a] + numbers[b] > target) {\\n                b--;\\n            } else {\\n                a++;\\n            }\\n        }\\n        return new int[]{a+1,b+1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int a = 0;\\n        int b = numbers.length -1;\\n        while (numbers[a] + numbers[b] != target) {\\n            if (numbers[a] + numbers[b] > target) {\\n                b--;\\n            } else {\\n                a++;\\n            }\\n        }\\n        return new int[]{a+1,b+1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027751,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start =0, end = numbers.length-1;\\n        \\n        while(start < end){\\n            \\n            int sum = numbers[start]+ numbers[end];\\n            \\n            if(sum == target)break;\\n            else if(sum<target) start++;\\n            else end--;\\n        }\\n        \\n        int[] res = new int[2];\\n        res[0] = start+1;\\n        res[1] = end+1;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int start =0, end = numbers.length-1;\\n        \\n        while(start < end){\\n            \\n            int sum = numbers[start]+ numbers[end];\\n            \\n            if(sum == target)break;\\n            else if(sum<target) start++;\\n            else end--;\\n        }\\n        \\n        int[] res = new int[2];\\n        res[0] = start+1;\\n        res[1] = end+1;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978000,
                "title": "python-complexity-analysis-o-n",
                "content": "There are four ways to solve this problem.\\n\\n* Dictionary: O(n) time and O(n) space\\nThis does not fulfill the constant space condition\\n\\n* Brute Force: O(n^2) and O(1) space\\nQuadratic runtime\\n\\n* Binary search: O(nlogn) time and O(1) space\\nEfficient but we can do it in linear time\\n\\n* Two pointers: O(n) time and O(1) space\\nBest of both worlds\\n\\n```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start = 0\\n        end = len(numbers)-1\\n        while start<end:\\n            sum = numbers[start] + numbers[end]\\n            \\n            if sum == target:\\n                return [start+1, end+1]\\n            elif sum>target:\\n                end-=1\\n            else:\\n                start+=1\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start = 0\\n        end = len(numbers)-1\\n        while start<end:\\n            sum = numbers[start] + numbers[end]\\n            \\n            if sum == target:\\n                return [start+1, end+1]\\n            elif sum>target:\\n                end-=1\\n            else:\\n                start+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955828,
                "title": "python-5-lines-faster-than-96-127-ms",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        beg, end = 0, len(numbers) - 1\\n        while beg <= end:\\n            if numbers[beg] + numbers[end] == target: return [beg + 1, end + 1]\\n            elif numbers[beg] + numbers[end] < target: beg += 1\\n            else: end -= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        beg, end = 0, len(numbers) - 1\\n        while beg <= end:\\n            if numbers[beg] + numbers[end] == target: return [beg + 1, end + 1]\\n            elif numbers[beg] + numbers[end] < target: beg += 1\\n            else: end -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882469,
                "title": "python3-solution-using-two-pointers",
                "content": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        start,end = 0, len(numbers)-1\\n        while start<=end:\\n            sums = numbers[start]+numbers[end]\\n            if(sums == target):\\n                return [start+1, end+1]\\n            if(sums < target):\\n                start+=1\\n            else:\\n                end-=1\\n        return [start+1,end+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824651,
                "title": "o-n-javascript-solution",
                "content": "```\\nvar twoSum = function (numbers, target) {\\n  let left = 0,\\n    right = numbers.length - 1;\\n\\n  while (left < right) {\\n    const currentSum = numbers[left] + numbers[right];\\n    if (currentSum === target) {\\n      return [left+1, right+1];\\n    }\\n    if (target < currentSum) {\\n      right--;\\n    } else if (target > currentSum) {\\n      left++;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar twoSum = function (numbers, target) {\\n  let left = 0,\\n    right = numbers.length - 1;\\n\\n  while (left < right) {\\n    const currentSum = numbers[left] + numbers[right];\\n    if (currentSum === target) {\\n      return [left+1, right+1];\\n    }\\n    if (target < currentSum) {\\n      right--;\\n    } else if (target > currentSum) {\\n      left++;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752206,
                "title": "two-sum-ii-input-array-is-sorted-solution-java",
                "content": "class Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    int l = 0;\\n    int r = numbers.length - 1;\\n\\n    while (numbers[l] + numbers[r] != target)\\n      if (numbers[l] + numbers[r] < target)\\n        ++l;\\n      else\\n        --r;\\n\\n    return new int[] {l + 1, r + 1};\\n  }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n  public int[] twoSum(int[] numbers, int target) {\\n    int l = 0;\\n    int r = numbers.length - 1;\\n\\n    while (numbers[l] + numbers[r] != target)\\n      if (numbers[l] + numbers[r] < target)\\n        ++l;\\n      else\\n        --r;\\n\\n    return new int[] {l + 1, r + 1}",
                "codeTag": "Java"
            },
            {
                "id": 1742099,
                "title": "two-approach-using-c",
                "content": "Approach 1: Using unordered map\\n\\tTime complexity : O(N)\\n     Space Complexity : O(N)\\n\\t \\n\\t\\tvector<int> twoSum(vector<int>& nums, int target) \\n\\t\\t{\\n\\t\\t\\tunordered_map <int,int> un_mp;\\n\\t\\t\\tvector <int> v;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint findTarget=target-nums[i];\\n\\t\\t\\t\\tif(un_mp.find(findTarget)!=un_mp.end())\\n\\t\\t\\t\\t{\\n                    v.push_back(un_mp[findTarget]+1);\\n                    v.push_back(i+1);\\n                    return v;\\n                } \\n\\t\\t\\t    else\\n                    un_mp[nums[i]]=i;\\n            \\n         }\\n         return v;\\n\\t }\\n\\n\\nApproach 2: Using Two pointer method\\nTime Complexity :O(N)\\nSpace Complexity: O(1)\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector <int> v;\\n        int left=0,right=numbers.size()-1;\\n        while(left<right)\\n        {\\n            int curr_sum=numbers[left]+numbers[right];\\n            if(curr_sum==target)\\n            {\\n                v.push_back(left+1);\\n                v.push_back(right+1);\\n                return v;\\n            }\\n            else if(curr_sum>target)\\n                right--;\\n            else\\n                left++;\\n            \\n        }\\n        return v;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "Approach 1: Using unordered map\\n\\tTime complexity : O(N)\\n     Space Complexity : O(N)\\n\\t \\n\\t\\tvector<int> twoSum(vector<int>& nums, int target) \\n\\t\\t{\\n\\t\\t\\tunordered_map <int,int> un_mp;\\n\\t\\t\\tvector <int> v;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint findTarget=target-nums[i];\\n\\t\\t\\t\\tif(un_mp.find(findTarget)!=un_mp.end())\\n\\t\\t\\t\\t{\\n                    v.push_back(un_mp[findTarget]+1);\\n                    v.push_back(i+1);\\n                    return v;\\n                } \\n\\t\\t\\t    else\\n                    un_mp[nums[i]]=i;\\n            \\n         }\\n         return v;\\n\\t }\\n\\n\\nApproach 2: Using Two pointer method\\nTime Complexity :O(N)\\nSpace Complexity: O(1)\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) \\n    {\\n        vector <int> v;\\n        int left=0,right=numbers.size()-1;\\n        while(left<right)\\n        {\\n            int curr_sum=numbers[left]+numbers[right];\\n            if(curr_sum==target)\\n            {\\n                v.push_back(left+1);\\n                v.push_back(right+1);\\n                return v;\\n            }\\n            else if(curr_sum>target)\\n                right--;\\n            else\\n                left++;\\n            \\n        }\\n        return v;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566991,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568755,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565835,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566483,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1741505,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1631771,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566272,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570545,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567219,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567769,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566991,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568755,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565835,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566483,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1741505,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1631771,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566272,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570545,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567219,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567769,
                "content": [
                    {
                        "username": "codestarminion",
                        "content": "Took me sometime to realize why my answer was wrong until I saw the expected output was based on array index starting from 1 :-D"
                    },
                    {
                        "username": "honourableahamedsha001",
                        "content": "same lol !"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@volkoff5566](/volkoff5566) I guess maybe its to simulate the real world where humans would look at it as 1-indexed and not zero. Either its not stressful. just plus 1\\n"
                    },
                    {
                        "username": "JosephHuntley",
                        "content": "[@volkoff5566](/volkoff5566) My thoughts exactly. I couldn\\'t figure out why my submission wouldn\\'t work until I reread the problem. I hate these kind of trick questions."
                    },
                    {
                        "username": "volkoff5566",
                        "content": "I still don\\'t understand what\\'s the point of using 1-indexed array, why not 0-indexed... "
                    },
                    {
                        "username": "crazyA",
                        "content": "The two pointer method seems pretty straight forward. Increase L if sum is smaller, decrease R if sum is larger.\\n\\nBut I was having the same question as many others: **How to prove that the algorithm is actually correct? Why can\\'t I decrease R if the sum is smaller?** Here is my idea:\\n\\nForget about the 1-indexed array thing, say it\\'s 0-indexed. Assume that we are using two pointers L and R with starting position of 0 and n-1. And we know that it\\'s guaranteed to have a solution [X, Y] where nums[X] + nums[Y] = Traget. Then\\n\\n*Theorem 1: With our proposed two pointer algorithm, at least one of L or R will reach its solution position first. That is, either L reaches X first, or R reaches Y first.*\\n\\nThis is obvious. L and R will never cross. If L keeps increasing and R keeps decreasing, and there is a solution, at one of L and R must reaches the right position first (they can arrive at the same time, doesn\\'t matter.)\\n\\n*Theorem 2: With our proposed algorithm, if L or R is at its solution position, they will not keep going and then miss the position.*\\n\\nSay the solution is [X, Y].\\n* If L find its position first. L = X, R = Y + K. K is some random non-negative number. Because the array is sorted, nums[L] + nums[R] > Target. Our algorithm will then decrease R.\\n* Vice versa if R find its position first.\\n\\nI think now it\\'s proven that the algo will work.\\n"
                    },
                    {
                        "username": "user9860e",
                        "content": "You are not supposed to put solutions in this section."
                    },
                    {
                        "username": "AshrafHabromman",
                        "content": "Thanks "
                    },
                    {
                        "username": "KittenLS",
                        "content": "Thx when I read L = X, R = Y + K I realized the idea)"
                    },
                    {
                        "username": "pstrait",
                        "content": "\"Why can\\'t I decrease R if the sum is smaller?\" Decreasing R will always make your sum even smaller because it is non-decreasing. So if the sum was already too small, it seems pretty obvious why you can\\'t decrease R."
                    },
                    {
                        "username": "zaphdev254",
                        "content": "Awesome explanation"
                    },
                    {
                        "username": "guillaume8",
                        "content": "Hello,\\n\\n I am not an english native speaker and I wonder what is an AC solution. I have seen that on several problem already and Google was not useful.\\n\\nthanks"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@AbdalMahfuj](/AbdalMahfuj) We should start calling it ACC solution, that would make more sense and meaning."
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "All Correct Solution"
                    },
                    {
                        "username": "AbdalMahfuj",
                        "content": "Accepted solution"
                    },
                    {
                        "username": "fyh8238865",
                        "content": "I have seen some discussions in the discussion session about the binary search idea. Even though, they all look better ideas than two pointers, they still need O(N) in the worse case.\\n\\nI am asking is there any idea to solve this question in completely O(logN)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search\\n"
                    },
                    {
                        "username": "Boggers0",
                        "content": "All my testcases passed, 21/21, why does is return \"time limit exceeded\""
                    },
                    {
                        "username": "Vaibhav_1314",
                        "content": "[@Bogdan Boyko](/BoggersPoggers) My solution also passed all the test cases, but it is showing TLE.\\nI have used the binary search approach in my code with time complexity O(NlogN). If you know the answer, can you please help me."
                    },
                    {
                        "username": "antoniojsp",
                        "content": "[@nihil_johnson](/nihil_johnson) Space complexity need to be constant, which a lot of the answers in here don\\'t follow. My code is 0(n^2) but by using the fact that the arrays are in decreasing order, I can save some time by preventing the secundary loop enters in function if the current value is the same than the previous one and the previous one has already been checked for pairs. "
                    },
                    {
                        "username": "nihil_johnson",
                        "content": "Try to write code in O(logN)"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "# How does the submission work\\nEvery time I hit the submit button, I get a different performance"
                    },
                    {
                        "username": "karlapalem",
                        "content": "The question clearly states that the \"returned answers\" should not have a 0 in it. \n\"Please note that your returned answers (both index1 and index2) are not zero-based.\"\nI assumed that any array with a 0 in it supposed to be incremented by 1.\n\nPlease advise?\n"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "If sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 and return it. (+1 is added due to condition in ques).\\n"
                    },
                    {
                        "username": "sr_ch",
                        "content": "Yes. Correct. We should treat 0-index as 1 and 1-index as 2 so on and so forth for this problem."
                    },
                    {
                        "username": "Fabio_Trucco",
                        "content": "This is the problem used during the mock interview carried out by two software engineers from Google. They go explaining it from te brute force solution until this case where te array is already sorted.\\nA nice example of an easy problem explored all the way until it gets tricky"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "[@bbht](/bbht) how will you get to a O(log(n)) solution? "
                    },
                    {
                        "username": "bbht",
                        "content": "It can be further expanded to a possible log(N) solution, or some data structures constraints to test the candidate"
                    },
                    {
                        "username": "for_the_glory",
                        "content": " My algorithm is O(n), but runs 8ms, I am just wondering whether there is more efficient algorithm?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution. Therefore, there exist no O(log(n)) solutions"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "[@zaphdev254](/zaphdev254) yeah!! i use first and last index"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply Binary search!!"
                    },
                    {
                        "username": "zaphdev254",
                        "content": "did you use 2 pointer algorithm pattern"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570907,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1576683,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1571367,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1977405,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1858582,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1813001,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1753235,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 2034647,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 2033911,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1576117,
                "content": [
                    {
                        "username": "himanshuhere",
                        "content": "Shouldn\\'t it be an EASY tagged problem?"
                    },
                    {
                        "username": "user7117xu",
                        "content": "It is harder than Easy if you try to solve it with the optimal log(N), at least Medium."
                    },
                    {
                        "username": "bbht",
                        "content": "It can, but the use of the non-decreasing order does require some exploitation. Plus, there is the meticulous overhead of looping and array/list traversal with the precision of the \\'from 1\\' indices"
                    },
                    {
                        "username": "EugeneKruglov",
                        "content": "Is there some simple proof that it\\'s impossible to get less than O(n)?"
                    },
                    {
                        "username": "puneetripathi",
                        "content": "No, O(n) is the most optimized approach, as we need to find a comparison-based solution here, and me have to at least make n comparisons to get to such a solution."
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "two pointer approach"
                    },
                    {
                        "username": "vishanthan8055",
                        "content": "Apply binary search\\n"
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "I saw some binary search solutions but in fact they are worst case linear or even nlogn. Is there a 100% logN (i.e. worst case logN) solution?"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) A basic two pointer approach is used in this question. Here, two pointers, namely start and end are placed at the 0th and the last index of the given sorted array. Declare a vector ans to store values.\\n\\nStep 2) Create a while loop which will execute with the condition (start<=end).\\n\\nStep 3) Inside the loop, if sum of numbers at current indexes(start + end) == target, store values of index start+1 and end+1 in ans and return it. (+1 is added due to condition in ques).\\n\\nStep 4) If sum of (start+end) indexes is less than target, increase the value of start. Since we are given a sorted array, this will automatically increase the value of sum.\\n\\nStep 5) If sum of (start+end) indexes is greater than target decrease the value of end to reduce value of sum.\\n\\nStep 6) The loop will do the rest!"
                    },
                    {
                        "username": "Jeevan_Kali",
                        "content": "Hey we have name for this! Binary Search \\uD83D\\uDE00\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "How is this a medium Level Question?"
                    },
                    {
                        "username": "SoumyadipGhosh23",
                        "content": "I was trying to solve it with find method in vector in cpp, then I came to know, it\\'s time complexity is O(n), finally I used two pointer approach but I think if there was a feature in leetcode where we can see the exact time complexity to solve the problem then It\\'ll be helpful "
                    },
                    {
                        "username": "ayushchaytur",
                        "content": "my solution fails for only one case when i submit, however when i use the same case in the custom testcase it works \\n\\nadding the test case here \\n\\n`\\n\\n[-1,-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n`"
                    },
                    {
                        "username": "olsonpm",
                        "content": "This question is worded incorrectly\n\n> Given a 1-indexed array of integers numbers\n...\n> Return the indices of the two numbers, index1 and index2, added by one\n\nIf we're given a 1-indexed array, then why would we add one to the index of said array ?\n\nIt's crazy how many questions on this site are so poorly written.  Would be great for the questions to be community-based so the community can update them to make sense"
                    },
                    {
                        "username": "user9365Mn",
                        "content": "theres something wrong with the problem, it shows 23/23 testcases passed but still shows time limit exceeded and doesnt even show any input in the Last Executed Input section"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "On the problem description there is no such thing that input array elements are distinct or unique. So when I tried with duplicated values, it\\'s showing \"\\xEFnvalid test case\", WTH!"
                    },
                    {
                        "username": "Chandran2001",
                        "content": "[@saikiran816](/saikiran816) wow!"
                    },
                    {
                        "username": "saikiran816",
                        "content": "If you use duplicate there might be a possibility of getting more than 1 solution.\nExample:\nvalid input:\nnums = [2,7,9,11], target = 9\noutput: [1,2]\n\ninvalid input:\nnums = [2,7,7,11], target = 9\noutput: [1,2] or [1,3]\n\nIt is not mentioned about duplicates values. But it is mentioned with bold font saying, 'Exactly one solution exist'."
                    }
                ]
            },
            {
                "id": 1575678,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1572942,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1572730,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1574587,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1568201,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 1571366,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2075234,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2073738,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2057599,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2057525,
                "content": [
                    {
                        "username": "Matheos7",
                        "content": "It doesn\\'t make sense why would anyone want that...\\nFirst item in a list is always 0 in Python, so it just seems odd that we\\'re asked to return the results 1 indexed."
                    },
                    {
                        "username": "gl95",
                        "content": "Why is the example solution, which the answer is the first and second index, [1,2]. Shouldn\\'t it be [0,1]?"
                    },
                    {
                        "username": "Nithin_0144",
                        "content": "In the question, it is given as 1-based indexing."
                    },
                    {
                        "username": "sonic07",
                        "content": "The description says \"The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\"\\n\\nBut in this test, it is giving two indices of values that DO NOT ADD TO THE TARGET\\narr[1] + arr[2] = 7 + 11 != 9\\nMy output, [0, 1] -> arr[0] + arr[1] = 2 + 7 = 9\\nHow is this test correct?\\n\\nFinished\\nRuntime: 0 ms\\nYour input\\n[2,7,11,15]\\n9\\nOutput\\n[0,1]\\nExpected\\n[1,2]"
                    },
                    {
                        "username": "anwernazir674",
                        "content": "as per the 1 based indexing it is correct"
                    },
                    {
                        "username": "pantigalt",
                        "content": "In the description of the task the following is written:\\n\"Your returned answers (both index1 and index2) are not zero-based.\"\\n\\nWhy the solution cannot be zero-based? \\nIt does not make sense to me.\\n\\nIn solution you will find low index and high index of the solution and it does not matter of course are they zero based or not zero-based.\\nSo why not to confuse people and just make the statement that the solution must be zero-based?"
                    },
                    {
                        "username": "ren1010",
                        "content": "Anyone with a Python solution working 60% faster or more compared to other Python3 solutions? I\\'ve tried the two pointer method as well as the dictionary method, but the results were faster than 24% and 59% respectively. \\nPlease help."
                    },
                    {
                        "username": "cameron7",
                        "content": "I doesn't include what the output should be formatted as. It doesn't indicate what to return if there doesn't exist a pair. Lastly, the return indices should not start at 1! They should start at 0!"
                    },
                    {
                        "username": "anksum2022",
                        "content": "Is the limit incorrect??\\n\\n`1 <= index1 < index2 < numbers.length`\\n\\nShouldn\\'t it be \\n`0 <= index1 < index2 < numbers.length` -> If index starting from 0\\nOR `1 <= index1 < index2 < numbers.length + 1` -> If 1 added"
                    },
                    {
                        "username": "hwang1607",
                        "content": "I feel like this is easier than the original twosum"
                    },
                    {
                        "username": "LMS5400",
                        "content": "JFC, you need a Phd just to comprehend this confusing af problem."
                    },
                    {
                        "username": "Rightlyso",
                        "content": "This is similar to normal two sum problem tbf."
                    },
                    {
                        "username": "ZackOfAllTrades",
                        "content": "whats with the 1-indexed nonsense and the word \"non-decreasing\", you mean ascending?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "1 indexed is only a distraction, add one to the indexes of your soplution. non-decreasing is not ascending, as there are duplicates."
                    }
                ]
            },
            {
                "id": 2051723,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2046490,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2044688,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2027712,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2018599,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2018517,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2015615,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2015288,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2009775,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2009257,
                "content": [
                    {
                        "username": "gsahu07",
                        "content": "What is the point of having a 1-indexed array here? Please enlighten me.\\nAnd why isn\\'t a solution accepted if the order of indexes reversed?"
                    },
                    {
                        "username": "ims0s",
                        "content": "[@Tom_Dev](/Tom_Dev)  the firat index of any array is 0 \\nbut in the solution it\\'s 1 \\nwhy there is no reason \\uD83D\\uDE02\\uD83D\\uDE02\\uD83E\\uDD37\\u200D\\u2642\\uFE0F\\nif you see the first example 2 and 7 should be [0,1] but the solution is [1,2] \\nso just add 1 to every index. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is only a distraction. Simply add one to your solution."
                    },
                    {
                        "username": "O420",
                        "content": "Try a hash map :D"
                    },
                    {
                        "username": "O420",
                        "content": "[@ims0s](/ims0s) fine ... boring pointers then"
                    },
                    {
                        "username": "ims0s",
                        "content": "hash map have O(n) space \\nyou can make it O(1) space "
                    },
                    {
                        "username": "z_acc",
                        "content": "It\\'d be nice if they could tell us the time complexity they want."
                    },
                    {
                        "username": "ims0s",
                        "content": "it\\'s should be O(n) for time \\nbut for space should be O(1) \\nso don\\'t use hash map with it \\nif you can make less than that it\\'s better \\nif you want to explain how to make it  reply "
                    },
                    {
                        "username": "ims0s",
                        "content": "guys always remember to increase every index by one in the final answer because that leetcode want the index in based 1  .\\nlike in the first example its [1,2] and in the array it\\'s [0,1] . "
                    },
                    {
                        "username": "Kunal_697",
                        "content": "Tell Me problem in my code \\n\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        vector<int> ans;\\n        int start = 0;\\n        int end = numbers.size() - 1;\\n        \\n        while (start <= end) {\\n            int mid = (start + end) / 2;\\n\\n            if (numbers[start] + numbers[mid] == target) {\\n                ans.push_back(start + 1);\\n                ans.push_back(mid + 1);\\n                break;\\n            } else if (numbers[start] + numbers[mid] < target) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "egithinji",
                        "content": "The description says:\\n `where 1 <= index1 < index2 < numbers.length`\\n\\nWhy isn\\'t it `index2 <= numbers.length`?\\n\\nFor example in example 2, numbers is [2,3,4] and the answer is [1,3]. Doesn\\'t this mean that index2 == numbers.length?"
                    },
                    {
                        "username": "bajorek",
                        "content": "This problem should be easy "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Ataf10",
                        "content": "I don\\'t actually know why this question is marked as medium. I was able to submit it in one submission only, I didn\\'t even run my code. one must take care of that 1- indexing thing and that\\'s it."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero."
                    },
                    {
                        "username": "joshishashank2003",
                        "content": "input array sorted - question level medium\\nnot sorted- question level easy"
                    },
                    {
                        "username": "aaronsiapuatco",
                        "content": "damn why was this easier than the original two sum lol"
                    }
                ]
            },
            {
                "id": 2006525,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 2006424,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 2004796,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1988539,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1980076,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1976989,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1975572,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1966928,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1957101,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1956571,
                "content": [
                    {
                        "username": "axmrnv",
                        "content": "A hint or requirement for solution to have O(N) time complexity would be nice. It would make one think beyond brute force from the start."
                    },
                    {
                        "username": "anin9",
                        "content": "Can someone explain this?\\nLet these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length. \\n\\nWon\\'t index2 be <= numbers.length, given its a 1-indexed array and 1 <= index1?"
                    },
                    {
                        "username": "atvanek",
                        "content": "What\\'s the point of using a 1-indexed array? Actually curious."
                    },
                    {
                        "username": "rakeshSharma19",
                        "content": "Hello, \\nI have solved the problem using 2 pointer, can anyone give the solution using Binary Search.\\nThanks"
                    },
                    {
                        "username": "webmisfit",
                        "content": "what is non-descending order?????????\\nyou can use \"ascending\" word and dont confuse people?\\nwhats wrong?"
                    },
                    {
                        "username": "powenyao",
                        "content": "https://stackoverflow.com/questions/42444024/why-do-we-use-the-term-non-descending-instead-of-ascending-in-sorting-algori\\n\\u201CNon-ascending (and non-descending) include the possibility of adjacent terms being equal. [1, 2, 2] is non-descending, but isn\\'t ascending.\\u201D"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 < numbers.length` .\n\nShouldn't that be : `1 <= index1 < index2 <= numbers.length` ? ( As the array is 1-indexed )"
                    },
                    {
                        "username": "chrisangelov7",
                        "content": "Why does it need an answer when it exceeds the the Constrains"
                    },
                    {
                        "username": "yatharth_lashkari",
                        "content": "total 23/23 case passed but still getting time limit excide "
                    },
                    {
                        "username": "rainywuSC30",
                        "content": "How to implement binary search along with two pointers for the problem?"
                    },
                    {
                        "username": "slowNDsteady",
                        "content": "if i do int end_Index  = numbers.size() why i will get heap overflow problem? why cant we access that  \\n why end_index = numbers.size()-1?"
                    }
                ]
            },
            {
                "id": 1936928,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1934145,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1927523,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1923485,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1922434,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1922273,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1919206,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1919163,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1918223,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1912350,
                "content": [
                    {
                        "username": "anupk11",
                        "content": "May I know why is this Java solution giving Index out of bounds exception,\n\n\n` public int[] twoSum(int[] numbers, int target)\n {\n\n        int arr[] = new int[2];\n\n        int left = 1,  right = numbers.length;\n\n        while(left < right)\n\n        {\n\n            if(numbers[left]+numbers[right] == target && numbers[left] != numbers[right])\n\n            {\n\n                arr[0] = left;\n                arr[1] = right;\n            }\n\n            else if(numbers[left]+numbers[right] < target) left++;\n\n            else right--;\n        }\n\n        return arr;\n\n    }`\n"
                    },
                    {
                        "username": "manojbvs01",
                        "content": "Isn\\'t this supposed to be an easy question?\\n"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Code won\\'t pass because testcase #23 out of 23 doesn\\'t have any input. Literally \"numbers = \"\\nI tried adding \"If (numbers.Length == 0){ return null; }\" but that still doesn\\'t help. Anyone else having this issue?"
                    },
                    {
                        "username": "tanishq29",
                        "content": "can anyone tell me whats wrong in this code as it gives error on testcase 11 for numbers =[5,25,75] and target is 100?\\n\\n\\n (int i = 0; i<numbers.length-1; i++){\\n            for(int j = numbers.length-1 ; j>i ; j--){\\n               \\n               if(numbers[i]+numbers[j] == target){\\n                   return new int[]{i+1,j+1};\\n               } \\n               if(numbers[i]+numbers[j]<target){\\n                   i ++;\\n               }\\n               else{\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n        return new int[] {};\\n    }"
                    },
                    {
                        "username": "basicProgrammer",
                        "content": "On the first iteration, (i=0, j=2), it will satisfy your 2nd if (80 < 100) so i will increment (1). but j will also decrement and you have defined j-- as the part of your nested for loop. So in 2nd iteration you would have (i=1, j=1) and that\\'s where it starts to fail."
                    },
                    {
                        "username": "swapnil019",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int low = 0;\\n        int high = numbers.size() - 1;\\n\\n        bool flag = true;\\n        vector<int> ans;\\n\\n        while(flag){\\n            if(low > high){\\n                break;\\n            }\\n            int ck = numbers[low] + numbers[high];\\n            if(ck == target){\\n                ans.push_back(low+1);\\n                ans.push_back(high+1);\\n                break;\\n            }\\n\\n            if(ck > target){\\n                high--;\\n            }else{\\n                low++;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utsav1123",
                        "content": "Who the hell starts indexing from 1 :(\\n\\nTook me 5 mins to figure out."
                    },
                    {
                        "username": "Aman_08",
                        "content": "Using Two-Pointer Approach O(N)\\n1. if sum<target increase i\\n2. if sum>target decrease j\\n3.if found break\\n"
                    },
                    {
                        "username": "Iskan9",
                        "content": "Am I the only one who spent a lot of time solving faster than O(N) and then realizing that there is no solution?"
                    },
                    {
                        "username": "moonshine_monster",
                        "content": "What is the point of the 1-indexing?"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Description clearly states that array is 1-indexed, and then asks to return indices incremented by one, which is unrelated to indices (at least it\\'s not stated this way). Please fix -- remove explicit index increment by one, or make array 0-indexed and ask to increment indices for correct answer"
                    }
                ]
            },
            {
                "id": 1911998,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1910259,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1902827,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1901420,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1891982,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1883481,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1858304,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1856376,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1841032,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1837256,
                "content": [
                    {
                        "username": "AndrewEastwood",
                        "content": "seems like the last testcase is broken and does not allow to submit the solution. [@LeetCode](/LeetCode) pls check this. thanks!"
                    },
                    {
                        "username": "Msey",
                        "content": "should be easy"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Why do I get TLE when I use cout in C++? I can\\'t figure out why, that\\'s really dumb reason for TLE."
                    },
                    {
                        "username": "the_loyalty",
                        "content": "Any other method which is better then nlogn?"
                    },
                    {
                        "username": "unknowndevil",
                        "content": "Question regarding the memory\\n\\nSo I use hashmap to solve which is o(n), it says Memory is 17.2MB and beats 24.38% \\n\\nbut when I use two pointers, it says Memory is 17.3MB and beats 12.79%\\n\\nIs this Memory calculation even correct? the two pointers I really only assign i and j as 0 and len(numbers)-1 and increase/decrease as it goes, while using dictionary it takes the each key"
                    },
                    {
                        "username": "TusharJain128",
                        "content": "1. Initialize two pointers left and right to the first and last indices of the array.\\n2. While left < right, check if the sum of the values at the two pointers is equal to the target value.\\na. If yes, return the indices of the two pointers as the answer.\\nb. If the sum is less than the target value, move the left pointer to the right.\\nc. If the sum is greater than the target value, move the right pointer to the left.\\n3. If we have exhausted all possibilities, return [-1,-1] as the answer."
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def twoSum(self, numbers, target):\\n        i = 0\\n        j = len(numbers) - 1\\n        while i < j:\\n            if numbers[i] + numbers[j] == target:\\n                return [i + 1, j +1]\\n            elif numbers[i] + numbers[j] < target:\\n                i += 1\\n            else:\\n                j -= 1"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "MIKIBURGOS",
                        "content": "23/23 testcases passed but TLE??? Wtf"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "I got the same responce! It takes under 235us on my xeon, but leetcode does not want to approve my soluction. 4 rows of code."
                    },
                    {
                        "username": "mishanin",
                        "content": "There is ONLY ONE SOLUTION and this is simplifying the loop. Take two pointers from start and end and just find their sum decreasing or increasing ONE of them at a time "
                    },
                    {
                        "username": "karanvirsagar98",
                        "content": "can some one explain me why we can not solved it using the same technique used in Two Sum solution\\nunordered_map <int, int> seen;\\n        for(int i=0; i<nums.size(); i++){\\n            if(seen.find(target-nums[i]) == seen.end()){\\n                seen[nums[i]] = i; \\n            }else{\\n                return {seen[target-nums[i]] +1,i+1};\\n            }\\n        }\\n        return {};\\nhasmaps\\nI just incremented my result by 1 and the Runtime was 11ms"
                    }
                ]
            },
            {
                "id": 1812407,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1802855,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1794157,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1782091,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1776230,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1756382,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1750314,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1735835,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1733552,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1725868,
                "content": [
                    {
                        "username": "mikasa_pals",
                        "content": "Why tf are indexes in the problem are 1 based? "
                    },
                    {
                        "username": "nonethewiser",
                        "content": "What is the point of specifying the array is 1-indexed? It\\'s trivial to account for and doesn\\'t really change anything."
                    },
                    {
                        "username": "sadji",
                        "content": "solving three sum before two sum two helped me a lot on figuring out the solution!\\n"
                    },
                    {
                        "username": "rimanshu007",
                        "content": "i don\\'t understand the error......\\nhelp me ........\\n\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int s = 1,e=n;\\n        while(s<e){\\n            if(numbers[s] + numbers[e] == target){\\n                return s;\\n                return e;\\n            }\\n            if(numbers[s] + numbers[e] < target){\\n                s++;\\n            }\\n            else{\\n                e--;\\n            }\\n        }\\n\\nLine 8: Char 24: error: no viable conversion from returned value of type \\'int\\' to function return type \\'vector<int>\\'\\n                return s;\\n                       ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:550:7: note: candidate constructor not viable: no known conversion from \\'int\\' to \\'const std::vector<int, std::allocator<int>> &\\' for 1st argument\\n      vector(const vector& __x)\\n      ^"
                    },
                    {
                        "username": "dschey82",
                        "content": "You\\'re trying to return two integers one after another, which is not a vector (the return type of the function). To make a vector from what you\\'re trying to return would be something like `vector<int>{s,e}`"
                    },
                    {
                        "username": "munchster",
                        "content": "Unfortunately, the official solution does not need the requirement \"You may not use the same element twice.\" If the outermost pair is not a match, one or the other element will be used (read) again."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "jakej256",
                        "content": "> sorted in non-decreasing order\\n\\nSo... ascending? Why the awkward language?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "precision. \"ascending\" means that each number is greater than the previous. \"Non decreasing\" means following numbers can be the same as previous, but not less than. Same difference as between \"x > y\"  and \"x >= y\"."
                    },
                    {
                        "username": "_Tanmay",
                        "content": "lol, was about to say this."
                    },
                    {
                        "username": "grilam14",
                        "content": "This seems... really easy for a medium right? I\\'m usually pretty bad at LC so I was surprised. "
                    },
                    {
                        "username": "_Tanmay",
                        "content": "Agreed."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "alexelaus",
                        "content": "Well if don\\'t know this specific algo to find a cycle in the graph, you won\\'t solve it."
                    }
                ]
            },
            {
                "id": 1725662,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1723181,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1721280,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1717127,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1715586,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1714642,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1714028,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1707189,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1639551,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            },
            {
                "id": 1574331,
                "content": [
                    {
                        "username": "Godfather20",
                        "content": "can I write a code of lon(n^2) time complexity with for loop?"
                    },
                    {
                        "username": "Srijan_dutta",
                        "content": "why two pointer approach is getting tle?"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "I feel like this question should get dropped down into the easy bracket. If not I\\'d love to hear the justification for what makes it qualify as a medium. It\\'s a pretty straight forward two pointer solution. I\\'d argue once we hit 3sum and higher that\\'s when you transition to mediums(low end of the medium spectrum)"
                    },
                    {
                        "username": "jutikapatil16",
                        "content": "In binary search method, when I keep low = i , then it\\'s correct for first three cases but I\\'m not able to submit..\\n\\nand if i keep low = i+1 , then the answer is correct and I could submit\\n\\nwhy so ?"
                    },
                    {
                        "username": "TreeLibrarian",
                        "content": "Re:. proof of the validity of the two pointer method, crazyA\\'s description is good but another way to imagine it is like this:\\n\\nAt any point one pointer is static and the other moving. If the moving pointer moves and the sum passes over the target without hitting it, there is no pair to the static value in the rest of the sorted list which sums to the target: all other possible values are either higher or lower than the last two tested, and that static value can be discounted as part of the solution and we can move on from testing it further.\\n\\nThe same applies to the moving pointer in reverse. If the last movement of the currently static pointer moved the sum far enough past the target that it takes more than one step to pass it again in the other direction, the same logic above applies: all other values of the currently static pointer would yield sums that are further away from the target than we currently are, and the value from the moving pointer can be discounted as a possible part of the solution.\\n\\nAt each step you are moving on from a value that definitely isn\\'t part of the solution, and keeping one that might still possibly be a part of the solution. \\n\\nSo, you always have to be moving inward the pointer that will move the sum towards or past the target, otherwise you might miss the actual pair.\\n\\nWhat I don\\'t get is why this problem is listed as being harder (medium difficulty) than the basic unsorted twoSum (easy difficulty)...\\n"
                    },
                    {
                        "username": "mmkd",
                        "content": "I\\'m confused as to why this is a medium question? Seems incredibly straightforward two-pointer problem."
                    },
                    {
                        "username": "DynamicPlayer",
                        "content": "Guys the question has an error. Should be 0 indexed instead of 1. Then your code will run."
                    },
                    {
                        "username": "XOFJO",
                        "content": "This is not a binary search problem. Why does it have the binary search tag?"
                    },
                    {
                        "username": "Nileshchavan",
                        "content": "simple and easy solution \\nhttps://github.com/Nilesh2925/-LEETCODE-TWO-SUM-II-SOLUTION/blob/main/TWO%20SUM%20II%20LEETCODE"
                    },
                    {
                        "username": "Opimenov",
                        "content": "[2,7,11] target 9\\n\\n2 has an index of 0\\n7                          1\\n\\noutput should be [0,1] NOT [1,2]"
                    }
                ]
            }
        ]
    }
]