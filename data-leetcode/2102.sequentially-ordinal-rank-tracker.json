[
    {
        "title": "Sequentially Ordinal Rank Tracker",
        "question_content": "A scenic location is represented by its name and attractiveness score, where name is a unique string among all locations and score is an integer. Locations can be ranked from the best to the worst. The higher the score, the better the location. If the scores of two locations are equal, then the location with the lexicographically smaller name is better.\nYou are building a system that tracks the ranking of locations with the system initially starting with no locations. It supports:\n\n\tAdding scenic locations, one at a time.\n\tQuerying the ith best location of all locations already added, where i is the number of times the system has been queried (including the current query).\n\t\n\t\tFor example, when the system is queried for the 4th time, it returns the 4th best location of all locations already added.\n\t\n\t\n\nNote that the test data are generated so that at any time, the number of queries does not exceed the number of locations added to the system.\nImplement the SORTracker class:\n\n\tSORTracker() Initializes the tracker system.\n\tvoid add(string name, int score) Adds a scenic location with name and score to the system.\n\tstring get() Queries and returns the ith best location, where i is the number of times this method has been invoked (including this invocation).\n\n&nbsp;\nExample 1:\n\nInput\n[\"SORTracker\", \"add\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"add\", \"get\", \"get\"]\n[[], [\"bradford\", 2], [\"branford\", 3], [], [\"alps\", 2], [], [\"orland\", 2], [], [\"orlando\", 3], [], [\"alpine\", 2], [], []]\nOutput\n[null, null, null, \"branford\", null, \"alps\", null, \"bradford\", null, \"bradford\", null, \"bradford\", \"orland\"]\nExplanation\nSORTracker tracker = new SORTracker(); // Initialize the tracker system.\ntracker.add(\"bradford\", 2); // Add location with name=\"bradford\" and score=2 to the system.\ntracker.add(\"branford\", 3); // Add location with name=\"branford\" and score=3 to the system.\ntracker.get();              // The sorted locations, from best to worst, are: branford, bradford.\n                            // Note that branford precedes bradford due to its higher score (3 > 2).\n                            // This is the 1st time get() is called, so return the best location: \"branford\".\ntracker.add(\"alps\", 2);     // Add location with name=\"alps\" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, alps, bradford.\n                            // Note that alps precedes bradford even though they have the same score (2).\n                            // This is because \"alps\" is lexicographically smaller than \"bradford\".\n                            // Return the 2nd best location \"alps\", as it is the 2nd time get() is called.\ntracker.add(\"orland\", 2);   // Add location with name=\"orland\" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, alps, bradford, orland.\n                            // Return \"bradford\", as it is the 3rd time get() is called.\ntracker.add(\"orlando\", 3);  // Add location with name=\"orlando\" and score=3 to the system.\ntracker.get();              // Sorted locations: branford, orlando, alps, bradford, orland.\n                            // Return \"bradford\".\ntracker.add(\"alpine\", 2);   // Add location with name=\"alpine\" and score=2 to the system.\ntracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                            // Return \"bradford\".\ntracker.get();              // Sorted locations: branford, orlando, alpine, alps, bradford, orland.\n                            // Return \"orland\".\n\n&nbsp;\nConstraints:\n\n\tname consists of lowercase English letters, and is unique among all locations.\n\t1 <= name.length <= 10\n\t1 <= score <= 105\n\tAt any time, the number of calls to get does not exceed the number of calls to add.\n\tAt most 4 * 104 calls in total will be made to add and get.",
        "solutions": [
            {
                "id": 1623288,
                "title": "decrement-iterator-4-lines",
                "content": "We use set to track locations. The iterator points to the ith-best one.\\n\\nIf we insert a location that is better than ith-best one, we decrement the iterator.\\n\\n**C++**\\n```cpp\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> s;\\n    set<pair<int, string>>::iterator it = end(s);    \\n    void add(string name, int score) {\\n        auto it1 = s.insert({-score, name}).first;\\n        if (it == end(s) || *it1 < *it)\\n            --it;\\n    }\\n    string get() {\\n        return (it++)->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> s;\\n    set<pair<int, string>>::iterator it = end(s);    \\n    void add(string name, int score) {\\n        auto it1 = s.insert({-score, name}).first;\\n        if (it == end(s) || *it1 < *it)\\n            --it;\\n    }\\n    string get() {\\n        return (it++)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623292,
                "title": "python-sortedlist-no-need-to-think-explain-behind-the-scene-o-logn",
                "content": "**Idea**\\n- This problem becomes so easy if we use **[SortedList()](http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html)**.\\n- In this problem, we use 2 opertors:\\n\\t- `add`, which add an element into the SortedList.\\n\\t- `[]`, which get an element at arbitrary index of the SortedList.\\n\\n**Explain SortedList behind the scene!**\\n- **[SortedList()](http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html)** in Python is implemented based on **Divide and Conquer** & **Binary Search** idea.\\n- **SortedList Implementation** here: https://github.com/grantjenks/python-sortedcontainers/blob/master/sortedcontainers/sortedlist.py.\\n- Basically, it divides a large list into smaller sub-lists and store sorted elements into sublists, each sublist stores up to `loadFactor=1000` elements by default. There are 2 main internal variables:\\n\\t- `_lists`: store list of sublists, each sublist stores elements in sorted order. When the size of the sublist grows greater than `2*loadFactor`, it will split into 2 smaller sublists.\\n\\t- `_maxes`: store maximum element of each sublists. \\n- When we do `bisect_left`, `bisect_right` or `add` in SortedList. It does binary search in `_maxes` to find the index of corresponding sublist. Then call `bisect_left`, `bisect_right` or `insort` in that sublist.\\n- When we do `insort` into a sub-list, actually cost `O(|sublist|)`, `|sublist| <= loadFactor`, but in practically it\\'s very fast. [Stackoverflow Discussion](https://stackoverflow.com/questions/53023380/bisect-insort-complexity-not-as-expected).\\n\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.sortedList = SortedList()\\n        self.i = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.sortedList.add([-score, name])\\n\\n    def get(self) -> str:\\n        ans = self.sortedList[self.i][1]\\n        self.i += 1\\n        return ans\\n```\\n**Complexity**\\n- Time: \\n\\t- add(name, score): `O(logN)`, where `N` is total number of times to call `add`\\n\\t- get(): `O(logN)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.sortedList = SortedList()\\n        self.i = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.sortedList.add([-score, name])\\n\\n    def get(self) -> str:\\n        ans = self.sortedList[self.i][1]\\n        self.i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623437,
                "title": "java-treeset-pointer-simple",
                "content": "Idea: \\n- Use a TreeSet to maintain sorted locations\\n- Use a pointer to keep track of the last returned index\\n- When adding a location, shift the pointer if needed (using `TreeMap.lower` to get the previous element)\\n\\n![image](https://assets.leetcode.com/users/images/841bc4bc-eeb7-4b6f-9b77-a8c3c995f76b_1640766211.5639458.png)\\n\\n\\n```\\nclass SORTracker {\\n    private TreeSet<Location> locations = new TreeSet<>(); \\n    private Location lastReturned = new Location(\"\", Integer.MAX_VALUE); // Last returned (or equivalent)\\n    \\n    public void add(String name, int score) {\\n        Location location = new Location(name, score);\\n        locations.add(location);\\n        \\n\\t\\t// If the new location is before the last returned, we need to update the pointer\\n        if (location.compareTo(lastReturned) < 0) {\\n            lastReturned = locations.lower(lastReturned);\\n        }\\n    }\\n    \\n    public String get() {\\n        // Update the pointer\\n        lastReturned = locations.higher(lastReturned);\\n        \\n        return lastReturned.name;\\n    }\\n    \\n    private static class Location implements Comparable<Location> {\\n        private final String name;\\n        private final int score;\\n        \\n        public Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        public int compareTo(Location l) {\\n            // Sort by score (desc), then name (asc)\\n            return score != l.score ? -Integer.compare(score, l.score) : name.compareTo(l.name);\\n        }\\n    }\\n}\\n```\\n\\nComments and questions welcome :)",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass SORTracker {\\n    private TreeSet<Location> locations = new TreeSet<>(); \\n    private Location lastReturned = new Location(\"\", Integer.MAX_VALUE); // Last returned (or equivalent)\\n    \\n    public void add(String name, int score) {\\n        Location location = new Location(name, score);\\n        locations.add(location);\\n        \\n\\t\\t// If the new location is before the last returned, we need to update the pointer\\n        if (location.compareTo(lastReturned) < 0) {\\n            lastReturned = locations.lower(lastReturned);\\n        }\\n    }\\n    \\n    public String get() {\\n        // Update the pointer\\n        lastReturned = locations.higher(lastReturned);\\n        \\n        return lastReturned.name;\\n    }\\n    \\n    private static class Location implements Comparable<Location> {\\n        private final String name;\\n        private final int score;\\n        \\n        public Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        public int compareTo(Location l) {\\n            // Sort by score (desc), then name (asc)\\n            return score != l.score ? -Integer.compare(score, l.score) : name.compareTo(l.name);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632156,
                "title": "two-heaps",
                "content": "Let `i` be the number of calls we make to `get()`\\nWe want to save \"largest\" `i` items to `minPq`.\\n\\nWhen we add the number of total items change, but `i` does not. We only need to compare the smallest ofthe largest `i` items, and add the smaller of the two to `maxPq`.\\nWhen we get the number of total items stay, but `i` changes. We want to poll the largest of items we saved in `maxPq` and move it to `minPq`\\n\\nRun time. Both add() and get() done in O(log(N)).\\nMemory. O(N) (minPq.size() + maxPq.size() == # of add\\'s)\\n\\n```\\npublic class SORTracker {\\n\\n    private PriorityQueue<Pair> minPq;\\n    private PriorityQueue<Pair> maxPq;\\n\\n    public SORTracker() {\\n        this.minPq = new PriorityQueue<>();\\n        this.maxPq = new PriorityQueue<>(Comparator.reverseOrder());\\n    }\\n\\n    public void add(String name, int score) {\\n        Pair pair = new Pair(score, name);\\n        minPq.add(pair);\\n        maxPq.add(minPq.poll());\\n    }\\n\\n    public String get() {\\n        Pair pair = maxPq.poll();\\n        minPq.add(pair);\\n        return pair.name;\\n    }\\n\\n    private static class Pair implements Comparable<Pair> {\\n        int score;\\n        String name;\\n\\n        Pair(int score, String name) {\\n            this.score = score;\\n            this.name = name;\\n        }\\n\\n        @Override\\n        public int compareTo(Pair o) {\\n            if (this.score == o.score)\\n                return o.name.compareTo(this.name);\\n            return this.score - o.score;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class SORTracker {\\n\\n    private PriorityQueue<Pair> minPq;\\n    private PriorityQueue<Pair> maxPq;\\n\\n    public SORTracker() {\\n        this.minPq = new PriorityQueue<>();\\n        this.maxPq = new PriorityQueue<>(Comparator.reverseOrder());\\n    }\\n\\n    public void add(String name, int score) {\\n        Pair pair = new Pair(score, name);\\n        minPq.add(pair);\\n        maxPq.add(minPq.poll());\\n    }\\n\\n    public String get() {\\n        Pair pair = maxPq.poll();\\n        minPq.add(pair);\\n        return pair.name;\\n    }\\n\\n    private static class Pair implements Comparable<Pair> {\\n        int score;\\n        String name;\\n\\n        Pair(int score, String name) {\\n            this.score = score;\\n            this.name = name;\\n        }\\n\\n        @Override\\n        public int compareTo(Pair o) {\\n            if (this.score == o.score)\\n                return o.name.compareTo(this.name);\\n            return this.score - o.score;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623337,
                "title": "c-simple-solution-just-store-in-a-set",
                "content": "- store scores and names as pairs in a set (ordered tree)\\n\\t- I store `{-score, name}` to make it easier, so the \\'smaller\\' pair the better\\n- store an iterator, which at the beginning points to the first item\\n- if a newly added place is < the current pointed place, move the iterator one position before\\n- after `get`, move the iterator one position after\\n\\n```cpp\\nclass SORTracker {\\npublic:\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        auto [newit, b] = memo.insert({-score, name});\\n        if (it == memo.end() || *newit < *it) advance(it, -1);\\n    }\\n    \\n    string get() {\\n        auto &name = it->second;\\n        advance(it, 1);\\n        return name;\\n    }\\n    \\n    using T = set<pair<int, string>>;\\n    T memo;\\n    T::iterator it = memo.end();\\n};\\n```\\n\\nComplexity:\\n- time\\n\\t- add: O(log N)\\n\\t- get: O(1)\\n- space: O(N)\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass SORTracker {\\npublic:\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        auto [newit, b] = memo.insert({-score, name});\\n        if (it == memo.end() || *newit < *it) advance(it, -1);\\n    }\\n    \\n    string get() {\\n        auto &name = it->second;\\n        advance(it, 1);\\n        return name;\\n    }\\n    \\n    using T = set<pair<int, string>>;\\n    T memo;\\n    T::iterator it = memo.end();\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623295,
                "title": "python-sortedlist-should-be-easy",
                "content": "In python we have quite powerful data structure SortedList, which allows us to get all order statistics in logarithmic time. It was so far the easiest 4-th problem from contest I have ever seen.\\n\\n#### Complexity\\nIt is `O(log n)` both for `add` and `get`.\\n\\n#### Code\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.SList = SortedList()\\n        self.T = 0\\n        \\n    def add(self, name, score):\\n        self.SList.add((-score, name))\\n        \\n    def get(self):\\n        self.T += 1\\n        return self.SList[self.T - 1][1]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.SList = SortedList()\\n        self.T = 0\\n        \\n    def add(self, name, score):\\n        self.SList.add((-score, name))\\n        \\n    def get(self):\\n        self.T += 1\\n        return self.SList[self.T - 1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623474,
                "title": "c-min-heap-max-heap",
                "content": "The idea is similar to [problem#295](https://leetcode.com/problems/find-median-from-data-stream/). The only difference is that we are interested in getting the *number_of_get* th element instead of the median.\\n```\\nclass SORTracker {\\npublic:\\n    SORTracker() : number_of_get(0) {}\\n    \\n    void add(string name, int score) {\\n        min_heap.push(make_pair(score, name));\\n        while (min_heap.size() > number_of_get) {\\n            max_heap.push(min_heap.top());\\n            min_heap.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        auto p = max_heap.top();\\n        min_heap.push(p);\\n        max_heap.pop();\\n        ++number_of_get;\\n        return p.second;\\n    }\\n    \\nprivate:\\n    struct Compare1 { // comparator for min_heap\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b)\\n        {\\n            if (a.first != b.first) {\\n                return a.first > b.first;\\n            } else {\\n                return a.second < b.second;\\n            }\\n        }\\n    };\\n\\n    struct Compare2 { // comparator for max_heap\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b)\\n        {\\n            if (a.first != b.first) {\\n                return a.first < b.first;\\n            } else {\\n                return a.second > b.second;\\n            }\\n        }\\n    };\\n    \\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Compare1> min_heap; // store number_of_get lowest-ranked locations\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Compare2> max_heap; // store the rest of the locations\\n    int number_of_get; // number of get() requests so far\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\n    SORTracker() : number_of_get(0) {}\\n    \\n    void add(string name, int score) {\\n        min_heap.push(make_pair(score, name));\\n        while (min_heap.size() > number_of_get) {\\n            max_heap.push(min_heap.top());\\n            min_heap.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        auto p = max_heap.top();\\n        min_heap.push(p);\\n        max_heap.pop();\\n        ++number_of_get;\\n        return p.second;\\n    }\\n    \\nprivate:\\n    struct Compare1 { // comparator for min_heap\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b)\\n        {\\n            if (a.first != b.first) {\\n                return a.first > b.first;\\n            } else {\\n                return a.second < b.second;\\n            }\\n        }\\n    };\\n\\n    struct Compare2 { // comparator for max_heap\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b)\\n        {\\n            if (a.first != b.first) {\\n                return a.first < b.first;\\n            } else {\\n                return a.second > b.second;\\n            }\\n        }\\n    };\\n    \\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Compare1> min_heap; // store number_of_get lowest-ranked locations\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Compare2> max_heap; // store the rest of the locations\\n    int number_of_get; // number of get() requests so far\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202661,
                "title": "python-two-heaps-solution-clear-o-logn",
                "content": "```\\nfrom heapq import *\\n\\nclass MinHeapItem:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        return self.score < other.score or \\\\\\n               (self.score == other.score and self.name > other.name)\\n\\nclass MaxHeapItem:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        return self.score > other.score or \\\\\\n               (self.score == other.score and self.name < other.name)\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.min_heap = []\\n        self.max_heap = []\\n        self.i = 1\\n\\n    def add(self, name: str, score: int) -> None:\\n        current = MinHeapItem(name, score)\\n        if len(self.min_heap) < self.i:\\n            heappush(self.min_heap, current)\\n        elif current > self.min_heap[0]:\\n            temp = heapreplace(self.min_heap, current)\\n            heappush(self.max_heap, MaxHeapItem(temp.name, temp.score))\\n        else:\\n            heappush(self.max_heap, MaxHeapItem(name, score))\\n        \\n\\n    def get(self) -> str:\\n        ans = self.min_heap[0].name\\n        self.i += 1        \\n        if self.max_heap:\\n            temp = heappop(self.max_heap)\\n            heappush(self.min_heap, MinHeapItem(temp.name, temp.score))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\n\\nclass MinHeapItem:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        return self.score < other.score or \\\\\\n               (self.score == other.score and self.name > other.name)\\n\\nclass MaxHeapItem:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        return self.score > other.score or \\\\\\n               (self.score == other.score and self.name < other.name)\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.min_heap = []\\n        self.max_heap = []\\n        self.i = 1\\n\\n    def add(self, name: str, score: int) -> None:\\n        current = MinHeapItem(name, score)\\n        if len(self.min_heap) < self.i:\\n            heappush(self.min_heap, current)\\n        elif current > self.min_heap[0]:\\n            temp = heapreplace(self.min_heap, current)\\n            heappush(self.max_heap, MaxHeapItem(temp.name, temp.score))\\n        else:\\n            heappush(self.max_heap, MaxHeapItem(name, score))\\n        \\n\\n    def get(self) -> str:\\n        ans = self.min_heap[0].name\\n        self.i += 1        \\n        if self.max_heap:\\n            temp = heappop(self.max_heap)\\n            heappush(self.min_heap, MinHeapItem(temp.name, temp.score))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623408,
                "title": "java-two-heaps-solution-splay-tree-solution",
                "content": "Reference \\uFF1A https://leetcode.com/problems/find-median-from-data-stream/ \\n\\nIdea : \\n1. maintain two heap, maxheap -> minheap\\n2. always keep the minheap with size == ith\\n3. Since ith + 1 each time, the movement between 2 heaps is expected to be 1 time for each add operation\\n\\n\\n```\\nclass SORTracker {\\n    int i = 1;\\n    PriorityQueue < Pair > min = new PriorityQueue < > ((a, b) -> {\\n        if (a.val == b.val) {\\n            return b.name.compareTo(a.name);\\n        }\\n        return a.val - b.val;\\n    });\\n    PriorityQueue < Pair > max = new PriorityQueue < > ((a, b) -> {\\n        if (a.val == b.val) {\\n            return a.name.compareTo(b.name);\\n        }\\n        return b.val - a.val;\\n    });\\n\\n\\n    public SORTracker() {\\n\\n    }\\n\\n    public void add(String name, int score) {\\n        Pair p = new Pair(name, score);\\n        if (max.size() == 0 && min.size() == 0) {\\n            max.add(p);\\n        } else if (max.size() > 0 && min.size() == 0) {\\n            max.add(p);\\n        } else if (max.size() == 0 && min.size() >= 0) {\\n            min.add(p);\\n        } else {\\n            Pair p2 = min.peek();\\n            if (check(p2, p)) { // p > p2\\n                min.add(p);\\n            } else {\\n                max.add(p);\\n            }\\n        }\\n    }\\n\\n    public boolean check(Pair p1, Pair p2) { //p2 > p1\\n        if (p2.val > p1.val) return true;\\n        if (p2.val < p1.val) return false;\\n        if (p2.name.compareTo(p1.name) > 0) return false;\\n        return true;\\n    }\\n\\n    public String get() {\\n        while (min.size() > i) {\\n            max.add(min.poll());\\n        }\\n        while (min.size() < i && max.size() > 0) {\\n            min.add(max.poll());\\n        }\\n        Pair top = min.peek();\\n        i++;\\n        return top.name;\\n    }\\n\\n\\n}\\n\\nclass Pair {\\n    String name;\\n    int val;\\n    public Pair(String name, int val) {\\n        this.name = name;\\n        this.val = val;\\n    }\\n\\n    public String toString() {\\n        return name + \",\" + val + \"  \";\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```\\n\\n<br/><br/>\\nSplay Tree\\n```\\nclass SORTracker {\\n    Splay splay;\\n    int k = 0;\\n    int size = 2;\\n    public SORTracker() {\\n        splay = new Splay(100 + 10);\\n        splay.insert(100000000, \"\");\\n        splay.insert(-100000000, \"\");\\n    }\\n    \\n    public void add(String name, int score) {\\n        splay.insert(score, name);\\n        size++;\\n    }\\n    \\n    public String get() {\\n        int kthIdx = splay.kth(size - k - 1);\\n        k++;\\n        return splay.nodes[kthIdx].name;\\n    }\\n}\\n\\nclass Splay{\\n    int N;\\n    int n;\\n    Node nodes[];\\n    int root = 0, idx = 1;\\n    \\n    class Node {\\n        int childs[] = new int[2];\\n        int p = -1; int val = -1;\\n        int size = 1;\\n        int flag = 0;\\n        String name;\\n        public Node(int val, String name, int p) {\\n            this.val = val;\\n            this.name = name;\\n            this.p = p;\\n        }\\n    }\\n\\n    public Splay(int N) {\\n        this.N = N;\\n        nodes = new Node[N];\\n        nodes[0] = new Node(-1, \"\", -1);\\n        nodes[0].size = 0;\\n    }\\n\\n    public void rotate(int x){\\n        int y = nodes[x].p; int z = nodes[y].p;\\n        int k = (nodes[y].childs[1] == x) ? 1 : 0;  // k = 0 x is y\\'s leftchild, k = 1, x is y\\'s rightchild\\n\\n        nodes[z].childs[(nodes[z].childs[1] == y) ? 1 : 0] = x;\\n        nodes[x].p = z;\\n\\n        nodes[y].childs[k] = nodes[x].childs[k ^ 1];\\n        nodes[nodes[x].childs[k ^ 1]].p = y;\\n\\n        nodes[x].childs[k ^ 1] = y;\\n        nodes[y].p = x;\\n\\n        pushup(y);\\n        pushup(x);\\n    }\\n\\n    public void splay(int x, int k){\\n        while(nodes[x].p!=k){\\n            int y = nodes[x].p;\\n            int z = nodes[y].p;\\n            if(z!=k){\\n                int a = (nodes[y].childs[1] == x) ? 1 : 0;\\n                int b = (nodes[z].childs[1] == y) ? 1 : 0;\\n                if ((a^b) != 0) {\\n                    rotate(x);\\n                }\\n                else{\\n                    rotate(y);\\n                }\\n            }\\n            rotate(x);\\n        }\\n\\n        if(k==0){\\n            root = x;\\n        }\\n    }\\n\\n    public void insert(int val, String name){\\n        int u = root, p = 0;\\n        while (u != 0) {\\n            p = u;\\n            u = nodes[u].childs[com(nodes[u], val, name) ? 1 : 0];\\n        }\\n        u = idx++;\\n   \\n        if (p!=0){\\n            nodes[p].childs[com(nodes[p],val, name)? 1 : 0] = u;\\n        }\\n        \\n        if(u >= nodes.length){\\n            resize();\\n        }\\n        \\n        nodes[u] = new Node(val, name, p);\\n        splay(u, 0);\\n    }\\n    \\n    public boolean com(Node node, int otherScore, String otherName) {\\n        if(otherScore > node.val)return true;\\n        if(otherScore < node.val)return false;\\n        if (otherName.compareTo(node.name) > 0) return false;\\n        return true;\\n    }\\n\\n    public int kth(int k) {\\n        int u = root;\\n        while (true) {\\n            if (nodes[nodes[u].childs[0]].size >= k){\\n                u = nodes[u].childs[0];\\n            }\\n            else if (nodes[nodes[u].childs[0]].size + 1 == k){\\n                break;\\n            }\\n            else {\\n                k -= (nodes[nodes[u].childs[0]].size + 1);\\n                u = nodes[u].childs[1];\\n            }\\n        }\\n        return u;\\n    }\\n\\n    public void pushup(int x){\\n        nodes[x].size = 1 + nodes[nodes[x].childs[0]].size + nodes[nodes[x].childs[1]].size;\\n    }\\n\\n    public void pushdown(int x){\\n        //no push down\\n    }\\n    \\n    public void resize(){\\n        Node newnodes[] = new Node[N * 2];\\n        for(int i = 0; i < nodes.length; i++) {\\n            newnodes[i] = nodes[i];\\n        }\\n        N *= 2;\\n        nodes = newnodes;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\n    int i = 1;\\n    PriorityQueue < Pair > min = new PriorityQueue < > ((a, b) -> {\\n        if (a.val == b.val) {\\n            return b.name.compareTo(a.name);\\n        }\\n        return a.val - b.val;\\n    });\\n    PriorityQueue < Pair > max = new PriorityQueue < > ((a, b) -> {\\n        if (a.val == b.val) {\\n            return a.name.compareTo(b.name);\\n        }\\n        return b.val - a.val;\\n    });\\n\\n\\n    public SORTracker() {\\n\\n    }\\n\\n    public void add(String name, int score) {\\n        Pair p = new Pair(name, score);\\n        if (max.size() == 0 && min.size() == 0) {\\n            max.add(p);\\n        } else if (max.size() > 0 && min.size() == 0) {\\n            max.add(p);\\n        } else if (max.size() == 0 && min.size() >= 0) {\\n            min.add(p);\\n        } else {\\n            Pair p2 = min.peek();\\n            if (check(p2, p)) { // p > p2\\n                min.add(p);\\n            } else {\\n                max.add(p);\\n            }\\n        }\\n    }\\n\\n    public boolean check(Pair p1, Pair p2) { //p2 > p1\\n        if (p2.val > p1.val) return true;\\n        if (p2.val < p1.val) return false;\\n        if (p2.name.compareTo(p1.name) > 0) return false;\\n        return true;\\n    }\\n\\n    public String get() {\\n        while (min.size() > i) {\\n            max.add(min.poll());\\n        }\\n        while (min.size() < i && max.size() > 0) {\\n            min.add(max.poll());\\n        }\\n        Pair top = min.peek();\\n        i++;\\n        return top.name;\\n    }\\n\\n\\n}\\n\\nclass Pair {\\n    String name;\\n    int val;\\n    public Pair(String name, int val) {\\n        this.name = name;\\n        this.val = val;\\n    }\\n\\n    public String toString() {\\n        return name + \",\" + val + \"  \";\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```\n```\\nclass SORTracker {\\n    Splay splay;\\n    int k = 0;\\n    int size = 2;\\n    public SORTracker() {\\n        splay = new Splay(100 + 10);\\n        splay.insert(100000000, \"\");\\n        splay.insert(-100000000, \"\");\\n    }\\n    \\n    public void add(String name, int score) {\\n        splay.insert(score, name);\\n        size++;\\n    }\\n    \\n    public String get() {\\n        int kthIdx = splay.kth(size - k - 1);\\n        k++;\\n        return splay.nodes[kthIdx].name;\\n    }\\n}\\n\\nclass Splay{\\n    int N;\\n    int n;\\n    Node nodes[];\\n    int root = 0, idx = 1;\\n    \\n    class Node {\\n        int childs[] = new int[2];\\n        int p = -1; int val = -1;\\n        int size = 1;\\n        int flag = 0;\\n        String name;\\n        public Node(int val, String name, int p) {\\n            this.val = val;\\n            this.name = name;\\n            this.p = p;\\n        }\\n    }\\n\\n    public Splay(int N) {\\n        this.N = N;\\n        nodes = new Node[N];\\n        nodes[0] = new Node(-1, \"\", -1);\\n        nodes[0].size = 0;\\n    }\\n\\n    public void rotate(int x){\\n        int y = nodes[x].p; int z = nodes[y].p;\\n        int k = (nodes[y].childs[1] == x) ? 1 : 0;  // k = 0 x is y\\'s leftchild, k = 1, x is y\\'s rightchild\\n\\n        nodes[z].childs[(nodes[z].childs[1] == y) ? 1 : 0] = x;\\n        nodes[x].p = z;\\n\\n        nodes[y].childs[k] = nodes[x].childs[k ^ 1];\\n        nodes[nodes[x].childs[k ^ 1]].p = y;\\n\\n        nodes[x].childs[k ^ 1] = y;\\n        nodes[y].p = x;\\n\\n        pushup(y);\\n        pushup(x);\\n    }\\n\\n    public void splay(int x, int k){\\n        while(nodes[x].p!=k){\\n            int y = nodes[x].p;\\n            int z = nodes[y].p;\\n            if(z!=k){\\n                int a = (nodes[y].childs[1] == x) ? 1 : 0;\\n                int b = (nodes[z].childs[1] == y) ? 1 : 0;\\n                if ((a^b) != 0) {\\n                    rotate(x);\\n                }\\n                else{\\n                    rotate(y);\\n                }\\n            }\\n            rotate(x);\\n        }\\n\\n        if(k==0){\\n            root = x;\\n        }\\n    }\\n\\n    public void insert(int val, String name){\\n        int u = root, p = 0;\\n        while (u != 0) {\\n            p = u;\\n            u = nodes[u].childs[com(nodes[u], val, name) ? 1 : 0];\\n        }\\n        u = idx++;\\n   \\n        if (p!=0){\\n            nodes[p].childs[com(nodes[p],val, name)? 1 : 0] = u;\\n        }\\n        \\n        if(u >= nodes.length){\\n            resize();\\n        }\\n        \\n        nodes[u] = new Node(val, name, p);\\n        splay(u, 0);\\n    }\\n    \\n    public boolean com(Node node, int otherScore, String otherName) {\\n        if(otherScore > node.val)return true;\\n        if(otherScore < node.val)return false;\\n        if (otherName.compareTo(node.name) > 0) return false;\\n        return true;\\n    }\\n\\n    public int kth(int k) {\\n        int u = root;\\n        while (true) {\\n            if (nodes[nodes[u].childs[0]].size >= k){\\n                u = nodes[u].childs[0];\\n            }\\n            else if (nodes[nodes[u].childs[0]].size + 1 == k){\\n                break;\\n            }\\n            else {\\n                k -= (nodes[nodes[u].childs[0]].size + 1);\\n                u = nodes[u].childs[1];\\n            }\\n        }\\n        return u;\\n    }\\n\\n    public void pushup(int x){\\n        nodes[x].size = 1 + nodes[nodes[x].childs[0]].size + nodes[nodes[x].childs[1]].size;\\n    }\\n\\n    public void pushdown(int x){\\n        //no push down\\n    }\\n    \\n    public void resize(){\\n        Node newnodes[] = new Node[N * 2];\\n        for(int i = 0; i < nodes.length; i++) {\\n            newnodes[i] = nodes[i];\\n        }\\n        N *= 2;\\n        nodes = newnodes;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624327,
                "title": "minheap-maxheap-c",
                "content": "1. Create two heaps: minheap & maxheap.\\n2. get(): pop the top element of maxheap and push it in minheap.\\n3. add(name, score):  \\n\\t\\tif ```minheap is not empty then check if its top element is less than the new element:```\\n\\t\\tthen ```pop the top element and insert it in maxheap, insert new element in minheap.```\\n\\t\\t\\t\\telse ```insert new element in maxheap```\\n4. top element of maxheap is always the answer for get()\\n```\\nstruct compareMin\\n{\\n    bool operator() (pair<int,string> p1, pair<int,string> p2) {\\n        if(p1.first == p2.first) return p1.second < p2.second;\\n        return p1.first > p2.first;\\n    }\\n};\\n\\nstruct compareMax\\n{\\n    bool operator() (pair<int,string> p1, pair<int,string> p2) {\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        return p1.first < p2.first;\\n    }\\n};\\n\\n\\n\\nclass SORTracker {\\npublic:\\n    priority_queue <pair<int,string>, vector<pair<int,string>>, compareMin> min_heap;\\n    priority_queue <pair<int,string>, vector<pair<int,string>>, compareMax> max_heap; \\n    \\n    SORTracker() {}\\n    \\n    void add(string name, int score) {\\n        if(!min_heap.empty() && (min_heap.top().first < score || (min_heap.top().first == score && min_heap.top().second > name))) {\\n                pair<int,string> t = min_heap.top();\\n                min_heap.pop();\\n                min_heap.push({score,name});\\n                max_heap.push(t);\\n        } else {\\n            max_heap.push({score,name});\\n        }\\n    }\\n    \\n    string get() {\\n        pair<int,string> s = max_heap.top();\\n        max_heap.pop();\\n        min_heap.push(s);\\n        return s.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```minheap is not empty then check if its top element is less than the new element:```\n```pop the top element and insert it in maxheap, insert new element in minheap.```\n```insert new element in maxheap```\n```\\nstruct compareMin\\n{\\n    bool operator() (pair<int,string> p1, pair<int,string> p2) {\\n        if(p1.first == p2.first) return p1.second < p2.second;\\n        return p1.first > p2.first;\\n    }\\n};\\n\\nstruct compareMax\\n{\\n    bool operator() (pair<int,string> p1, pair<int,string> p2) {\\n        if(p1.first == p2.first) return p1.second > p2.second;\\n        return p1.first < p2.first;\\n    }\\n};\\n\\n\\n\\nclass SORTracker {\\npublic:\\n    priority_queue <pair<int,string>, vector<pair<int,string>>, compareMin> min_heap;\\n    priority_queue <pair<int,string>, vector<pair<int,string>>, compareMax> max_heap; \\n    \\n    SORTracker() {}\\n    \\n    void add(string name, int score) {\\n        if(!min_heap.empty() && (min_heap.top().first < score || (min_heap.top().first == score && min_heap.top().second > name))) {\\n                pair<int,string> t = min_heap.top();\\n                min_heap.pop();\\n                min_heap.push({score,name});\\n                max_heap.push(t);\\n        } else {\\n            max_heap.push({score,name});\\n        }\\n    }\\n    \\n    string get() {\\n        pair<int,string> s = max_heap.top();\\n        max_heap.pop();\\n        min_heap.push(s);\\n        return s.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623374,
                "title": "c-policy-based-ds-ordered-set",
                "content": "Ordered Set of pairs with **custom comparison**\\n\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> struct cmp {\\n    bool operator() (T a, T b) {\\n        return a.first > b.first || (a.first == b.first && a.second < b.second);\\n    }\\n};\\ntemplate <class T> using ordered_set = tree<T, null_type, cmp<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\nclass SORTracker {\\n    int i;\\n    ordered_set<pair<int,string>> s;    \\npublic:\\n    SORTracker() \\n\\t{ i = 0; }\\n    \\n    void add(string name, int score) \\n\\t{ s.insert({score,name}); }\\n    \\n    string get() \\n\\t{ return s.find_by_order(i++)->second; }\\n};\\n```\\n\\nEdit: \\n\\nWe won\\'t need custom comparison, if we use pairs with -score. less<> would suffice.\\nIn that case, the code is simpler.\\n\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\nclass SORTracker {\\n    int i;\\n    ordered_set<pair<int,string>> s;    \\npublic:\\n    SORTracker() \\n\\t{ i = 0; }\\n    \\n    void add(string name, int score) \\n\\t{ s.insert({-score,name}); }\\n    \\n    string get() \\n\\t{ return s.find_by_order(i++)->second; }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> struct cmp {\\n    bool operator() (T a, T b) {\\n        return a.first > b.first || (a.first == b.first && a.second < b.second);\\n    }\\n};\\ntemplate <class T> using ordered_set = tree<T, null_type, cmp<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\nclass SORTracker {\\n    int i;\\n    ordered_set<pair<int,string>> s;    \\npublic:\\n    SORTracker() \\n\\t{ i = 0; }\\n    \\n    void add(string name, int score) \\n\\t{ s.insert({score,name}); }\\n    \\n    string get() \\n\\t{ return s.find_by_order(i++)->second; }\\n};\\n```\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\nclass SORTracker {\\n    int i;\\n    ordered_set<pair<int,string>> s;    \\npublic:\\n    SORTracker() \\n\\t{ i = 0; }\\n    \\n    void add(string name, int score) \\n\\t{ s.insert({-score,name}); }\\n    \\n    string get() \\n\\t{ return s.find_by_order(i++)->second; }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1623314,
                "title": "javascript-avl-tree",
                "content": "In order to achieve O(logn) lookups and insertions, we use a Self Balancing Binary Search Tree with a custom comparator for our problem\\'s needs. \\nMore precisely, on our tree we store elements of the form [name,score]. Given It\\'s a BST, finding the k-th order statistic is simple. On each node we store the amount of nodes stored in the current subtree.\\nOnce we have that it\\'s simple to determine going left or right to find the k-th order statistic in O(logn), the height of the Tree.\\n\\n```\\nvar SORTracker = function() {\\n    this.S=new AVL(),this.i=1\\n};\\nSORTracker.prototype.add = function(name, score) {\\n    this.S.insert([name,score])\\n};\\nSORTracker.prototype.get = function() {\\n    return this.S.findKthNODE(this.i++)[0]\\n};\\n\\n// B O I  L E R P L A T E \\nclass AVL{\\n    constructor(){\\n        this.nodeCount=0\\n        this.root=null\\n\\n        // MODIFY THIS EVERY TIME.\\n        this.NODE=class{\\n            constructor(val,left=null,right=null,parent=null,bf=0,height=0){\\n                this.val=val\\n                this.left=left,this.right=right,this.parent=parent\\n                this.bf=bf,this.height=height\\n                this.SubTreeNodes=1\\n            }\\n        }\\n    }\\n    \\n//===M O D I F Y   FOR     COMPLEX     NODES==\\\\\\\\\\n    NODIFY(val){  //should return a new node based on the stats given\\n        return new this.NODE(val)\\n    }\\n    comparator=(node1,node2)=>{// basic comparator that returns <0,0,>0 if node1>node2,node1==node2,node1<node2\\n        if(node1.val[1]===node2.val[1]){\\n             if(node2.val[0]>node1.val[0])\\n                 return -1\\n            return 1\\n        }\\n        return Number(node2.val[1])-Number(node1.val[1])\\n    }\\n//-------------U S A B L E------------------\\\\\\\\\\n    //returns true if the value was inserted successfully\\n    //returns false if the value already exists\\n    insert(NODE){ //O(logn) \\n        if(NODE===null)\\n            return false\\n        NODE=this.NODIFY(NODE)\\n        if(!this.contains(this.root,NODE)){\\n            this.root=this.ins(this.root,NODE)\\n            this.nodeCount++\\n            return true\\n        }\\n        return false\\n    }\\n    remove(NODE){ \\n        if(NODE===null)\\n            return false\\n        NODE=this.NODIFY(NODE)\\n       // console.log(this.contains(this.root,new Node(7)))\\n        if(this.contains(this.root,NODE)){\\n            this.root=this.rem(this.root,NODE)\\n            this.nodeCount--\\n            return true\\n        }\\n        return false\\n        //rebalance the tree\\n    }\\n    has(NODE){\\n        NODE=this.NODIFY(NODE)\\n        return this.contains(this.root,NODE)\\n    }\\n    traversalASC(){ //O(n)\\n        let result=[]\\n        let dfs=(node)=>{\\n            if(!node)\\n                return\\n            dfs(node.left)\\n            result.push(node)\\n            dfs(node.right)\\n        }\\n        dfs(this.root)\\n        return result\\n    }\\n    findNextSmaller(NODE){\\n        NODE=this.NODIFY(NODE)\\n        let cur=this.root,result=null\\n        while(cur!==null){\\n            if(this.comparator(cur,NODE)<0)\\n                result=cur,\\n                cur=cur.right\\n            else\\n                cur=cur.left\\n        }\\n        if(result===null)\\n            return false // no such element\\n        return result\\n    }\\n    findNextBigger(NODE){\\n        NODE=this.NODIFY(NODE)\\n        let cur=this.root,result=null\\n        while(cur!==null){\\n            if(this.comparator(cur,NODE)<=0)\\n                cur=cur.right\\n            else\\n                result=cur,\\n                cur=cur.left\\n        }\\n        if(result===null)\\n            return false // no such element\\n        return result\\n    }\\n    findKthNODE(k){ //RETURNS THE NODE, NOT THE VALUE\\n        if(this.nodeCount<k)\\n            return null\\n        return this.findKth(this.root,k)\\n    }\\n    min=()=>this.findMin(this.root).val\\n    max=()=>this.findMax(this.root).val\\n//--------- I N T E R N A L S -----------------\\\\\\\\\\n    contains(node,val){\\n        if(node===null)\\n            return false\\n        let compare=this.comparator(node,val)\\n        if(compare<0) //node<val\\n            return this.contains(node.right,val)\\n        if(compare>0)\\n            return this.contains(node.left,val)\\n        return true\\n    }\\n    //inserts newNode to target node\\n    ins(tree,value){\\n        if(tree===null)\\n            return value\\n        //(target is bigger? insert it to the left): else to the right\\n        if(this.comparator(tree,value)>0)\\n            tree.left=this.ins(tree.left,value)\\n        else\\n            tree.right=this.ins(tree.right,value)\\n        //update balance factor of the target\\n        this.update(tree) \\n        return this.rebalance(tree) //balance the target if it needs rebalancing\\n    }\\n    rem(node,elem){\\n        if(node===null)\\n            return null\\n        //search an existing node with the given value\\n        let compare=this.comparator(elem,node)//-----\\n        if(compare<0)\\n            node.left=this.rem(node.left,elem)\\n        else if(compare>0)\\n            node.right=this.rem(node.right,elem)\\n        else{ //node found\\n             //remove the node and replace it with its sucessor\\n            if(node.left===null)\\n                return node.right\\n            else if(node.right===null)\\n                return node.left\\n            else{ //still has both subtrees? \\n                if(node.left.height>node.right.height){\\n                    let successor=this.findMax(node.left)/////\\n                    node.val=successor.val\\n                    node.left=this.rem(node.left,successor)\\n                }   \\n                else{\\n                    let successor=this.findMin(node.right)\\n                    node.val=successor.val\\n                    node.right=this.rem(node.right,successor)\\n                }\\n            }\\n        }\\n        this.update(node)\\n        return this.rebalance(node)\\n    }\\n    //find the min and max node of the subtree rooted at (node)\\n    findMin=(node)=>node.left?this.findMin(node.left):node\\n    findMax=(node)=>node.right?this.findMax(node.right):node\\n    //balances the subtree rooted at node if it is imbalanced (has balancefactor=+-2)\\n    //and returns the now balanced node\\n    rebalance(node){  //4 cases, 4 rotations\\n        if(node.bf==-2){\\n            if(node.left.bf<=0)\\n                return this.LL(node)\\n            else\\n                return this.LR(node)\\n        }\\n        else if(node.bf==2){\\n            if(node.right.bf>=0)\\n                return this.RR(node)\\n            else\\n                return this.RL(node)\\n        }\\n        return node\\n    }\\n    //update the balance factor and the height of the current node\\n    update(node){ \\n        let leftHeight=node.left!==null?node.left.height:-1,rightHeight=node.right!==null?node.right.height:-1\\n        node.height=Math.max(leftHeight,rightHeight)+1\\n        node.bf=rightHeight-leftHeight\\n        node.SubTreeNodes=1+(node.left===null?0:node.left.SubTreeNodes )+(node.right===null?0:node.right.SubTreeNodes)\\n    }\\n\\n    //4 cases of unbalanced trees\\n    LL=(node)=>this.rightRotation(node)\\n    RR=(node)=>this.leftRotation(node)\\n    LR(node){\\n        node.left=this.leftRotation(node.left)\\n        return this.LL(node)\\n    }\\n    RL(node){\\n        node.right=this.rightRotation(node.right)\\n        return this.RR(node)\\n    }\\n    //2 total rotations that work on RR and LL cases\\n    leftRotation(node){\\n        let newParent=node.right\\n        node.right=newParent.left\\n        newParent.left=node\\n        this.update(node)\\n        this.update(newParent)\\n        return newParent\\n    }\\n    rightRotation(node){\\n        let newParent=node.left\\n        node.left=newParent.right\\n        newParent.right=node\\n        this.update(node)\\n        this.update(newParent)\\n        return newParent\\n    }\\n    findKth(node,k){\\n        let leftCount=node.left?node.left.SubTreeNodes:0\\n        if(leftCount+1===k)\\n            return node.val\\n        if(leftCount+1<k)\\n            return this.findKth(node.right,k-leftCount-1)\\n        \\n        return this.findKth(node.left,k)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar SORTracker = function() {\\n    this.S=new AVL(),this.i=1\\n};\\nSORTracker.prototype.add = function(name, score) {\\n    this.S.insert([name,score])\\n};\\nSORTracker.prototype.get = function() {\\n    return this.S.findKthNODE(this.i++)[0]\\n};\\n\\n// B O I  L E R P L A T E \\nclass AVL{\\n    constructor(){\\n        this.nodeCount=0\\n        this.root=null\\n\\n        // MODIFY THIS EVERY TIME.\\n        this.NODE=class{\\n            constructor(val,left=null,right=null,parent=null,bf=0,height=0){\\n                this.val=val\\n                this.left=left,this.right=right,this.parent=parent\\n                this.bf=bf,this.height=height\\n                this.SubTreeNodes=1\\n            }\\n        }\\n    }\\n    \\n//===M O D I F Y   FOR     COMPLEX     NODES==\\\\\\\\\\n    NODIFY(val){  //should return a new node based on the stats given\\n        return new this.NODE(val)\\n    }\\n    comparator=(node1,node2)=>{// basic comparator that returns <0,0,>0 if node1>node2,node1==node2,node1<node2\\n        if(node1.val[1]===node2.val[1]){\\n             if(node2.val[0]>node1.val[0])\\n                 return -1\\n            return 1\\n        }\\n        return Number(node2.val[1])-Number(node1.val[1])\\n    }\\n//-------------U S A B L E------------------\\\\\\\\\\n    //returns true if the value was inserted successfully\\n    //returns false if the value already exists\\n    insert(NODE){ //O(logn) \\n        if(NODE===null)\\n            return false\\n        NODE=this.NODIFY(NODE)\\n        if(!this.contains(this.root,NODE)){\\n            this.root=this.ins(this.root,NODE)\\n            this.nodeCount++\\n            return true\\n        }\\n        return false\\n    }\\n    remove(NODE){ \\n        if(NODE===null)\\n            return false\\n        NODE=this.NODIFY(NODE)\\n       // console.log(this.contains(this.root,new Node(7)))\\n        if(this.contains(this.root,NODE)){\\n            this.root=this.rem(this.root,NODE)\\n            this.nodeCount--\\n            return true\\n        }\\n        return false\\n        //rebalance the tree\\n    }\\n    has(NODE){\\n        NODE=this.NODIFY(NODE)\\n        return this.contains(this.root,NODE)\\n    }\\n    traversalASC(){ //O(n)\\n        let result=[]\\n        let dfs=(node)=>{\\n            if(!node)\\n                return\\n            dfs(node.left)\\n            result.push(node)\\n            dfs(node.right)\\n        }\\n        dfs(this.root)\\n        return result\\n    }\\n    findNextSmaller(NODE){\\n        NODE=this.NODIFY(NODE)\\n        let cur=this.root,result=null\\n        while(cur!==null){\\n            if(this.comparator(cur,NODE)<0)\\n                result=cur,\\n                cur=cur.right\\n            else\\n                cur=cur.left\\n        }\\n        if(result===null)\\n            return false // no such element\\n        return result\\n    }\\n    findNextBigger(NODE){\\n        NODE=this.NODIFY(NODE)\\n        let cur=this.root,result=null\\n        while(cur!==null){\\n            if(this.comparator(cur,NODE)<=0)\\n                cur=cur.right\\n            else\\n                result=cur,\\n                cur=cur.left\\n        }\\n        if(result===null)\\n            return false // no such element\\n        return result\\n    }\\n    findKthNODE(k){ //RETURNS THE NODE, NOT THE VALUE\\n        if(this.nodeCount<k)\\n            return null\\n        return this.findKth(this.root,k)\\n    }\\n    min=()=>this.findMin(this.root).val\\n    max=()=>this.findMax(this.root).val\\n//--------- I N T E R N A L S -----------------\\\\\\\\\\n    contains(node,val){\\n        if(node===null)\\n            return false\\n        let compare=this.comparator(node,val)\\n        if(compare<0) //node<val\\n            return this.contains(node.right,val)\\n        if(compare>0)\\n            return this.contains(node.left,val)\\n        return true\\n    }\\n    //inserts newNode to target node\\n    ins(tree,value){\\n        if(tree===null)\\n            return value\\n        //(target is bigger? insert it to the left): else to the right\\n        if(this.comparator(tree,value)>0)\\n            tree.left=this.ins(tree.left,value)\\n        else\\n            tree.right=this.ins(tree.right,value)\\n        //update balance factor of the target\\n        this.update(tree) \\n        return this.rebalance(tree) //balance the target if it needs rebalancing\\n    }\\n    rem(node,elem){\\n        if(node===null)\\n            return null\\n        //search an existing node with the given value\\n        let compare=this.comparator(elem,node)//-----\\n        if(compare<0)\\n            node.left=this.rem(node.left,elem)\\n        else if(compare>0)\\n            node.right=this.rem(node.right,elem)\\n        else{ //node found\\n             //remove the node and replace it with its sucessor\\n            if(node.left===null)\\n                return node.right\\n            else if(node.right===null)\\n                return node.left\\n            else{ //still has both subtrees? \\n                if(node.left.height>node.right.height){\\n                    let successor=this.findMax(node.left)/////\\n                    node.val=successor.val\\n                    node.left=this.rem(node.left,successor)\\n                }   \\n                else{\\n                    let successor=this.findMin(node.right)\\n                    node.val=successor.val\\n                    node.right=this.rem(node.right,successor)\\n                }\\n            }\\n        }\\n        this.update(node)\\n        return this.rebalance(node)\\n    }\\n    //find the min and max node of the subtree rooted at (node)\\n    findMin=(node)=>node.left?this.findMin(node.left):node\\n    findMax=(node)=>node.right?this.findMax(node.right):node\\n    //balances the subtree rooted at node if it is imbalanced (has balancefactor=+-2)\\n    //and returns the now balanced node\\n    rebalance(node){  //4 cases, 4 rotations\\n        if(node.bf==-2){\\n            if(node.left.bf<=0)\\n                return this.LL(node)\\n            else\\n                return this.LR(node)\\n        }\\n        else if(node.bf==2){\\n            if(node.right.bf>=0)\\n                return this.RR(node)\\n            else\\n                return this.RL(node)\\n        }\\n        return node\\n    }\\n    //update the balance factor and the height of the current node\\n    update(node){ \\n        let leftHeight=node.left!==null?node.left.height:-1,rightHeight=node.right!==null?node.right.height:-1\\n        node.height=Math.max(leftHeight,rightHeight)+1\\n        node.bf=rightHeight-leftHeight\\n        node.SubTreeNodes=1+(node.left===null?0:node.left.SubTreeNodes )+(node.right===null?0:node.right.SubTreeNodes)\\n    }\\n\\n    //4 cases of unbalanced trees\\n    LL=(node)=>this.rightRotation(node)\\n    RR=(node)=>this.leftRotation(node)\\n    LR(node){\\n        node.left=this.leftRotation(node.left)\\n        return this.LL(node)\\n    }\\n    RL(node){\\n        node.right=this.rightRotation(node.right)\\n        return this.RR(node)\\n    }\\n    //2 total rotations that work on RR and LL cases\\n    leftRotation(node){\\n        let newParent=node.right\\n        node.right=newParent.left\\n        newParent.left=node\\n        this.update(node)\\n        this.update(newParent)\\n        return newParent\\n    }\\n    rightRotation(node){\\n        let newParent=node.left\\n        node.left=newParent.right\\n        newParent.right=node\\n        this.update(node)\\n        this.update(newParent)\\n        return newParent\\n    }\\n    findKth(node,k){\\n        let leftCount=node.left?node.left.SubTreeNodes:0\\n        if(leftCount+1===k)\\n            return node.val\\n        if(leftCount+1<k)\\n            return this.findKth(node.right,k-leftCount-1)\\n        \\n        return this.findKth(node.left,k)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595070,
                "title": "java-using-min-max-heap",
                "content": "```\\nclass SORTracker {\\n\\tint index = 0;\\n\\tPriorityQueue<pair> maxH = new PriorityQueue<pair>(\\n\\t\\t\\t(a, b) -> (a.score == b.score ? a.name.compareTo(b.name) : b.score - a.score));\\n\\tPriorityQueue<pair> minH = new PriorityQueue<pair>(\\n\\t\\t\\t(a, b) -> (a.score == b.score ? b.name.compareTo(a.name) : a.score - b.score));\\n\\n\\tpublic void add(String name, int score) {\\n\\t\\tpair p = new pair();\\n\\t\\tp.name = name;\\n\\t\\tp.score = score;\\n\\t\\tminH.add(p);\\n\\t\\tmaxH.add(minH.poll());\\n\\t}\\n\\n\\tpublic String get() {\\n\\t\\tpair p = maxH.poll();\\n\\t\\tminH.add(p);\\n\\t\\tindex++;\\n\\t\\treturn p.name;\\n\\t}\\n\\n\\tpublic class pair {\\n\\t\\tString name;\\n\\t\\tint score;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SORTracker {\\n\\tint index = 0;\\n\\tPriorityQueue<pair> maxH = new PriorityQueue<pair>(\\n\\t\\t\\t(a, b) -> (a.score == b.score ? a.name.compareTo(b.name) : b.score - a.score));\\n\\tPriorityQueue<pair> minH = new PriorityQueue<pair>(\\n\\t\\t\\t(a, b) -> (a.score == b.score ? b.name.compareTo(a.name) : a.score - b.score));\\n\\n\\tpublic void add(String name, int score) {\\n\\t\\tpair p = new pair();\\n\\t\\tp.name = name;\\n\\t\\tp.score = score;\\n\\t\\tminH.add(p);\\n\\t\\tmaxH.add(minH.poll());\\n\\t}\\n\\n\\tpublic String get() {\\n\\t\\tpair p = maxH.poll();\\n\\t\\tminH.add(p);\\n\\t\\tindex++;\\n\\t\\treturn p.name;\\n\\t}\\n\\n\\tpublic class pair {\\n\\t\\tString name;\\n\\t\\tint score;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542572,
                "title": "c-beats-90-in-time-ordered-set",
                "content": "```\\nclass SORTracker {\\n    struct location {\\n        int score;\\n        string name;\\n        \\n        location(int score, string name): score(score), name(name) {}\\n        \\n        bool operator<(const location &l) const {\\n            return score > l.score || (score == l.score && name < l.name);\\n        }\\n    };\\n    set<location> scenes;\\n    set<location>::iterator cur;\\npublic:\\n    SORTracker() {}\\n    \\n    void add(string name, int score) {\\n        auto scene = location(score, name);\\n        if (scenes.empty()) {\\n            scenes.insert(scene);\\n            cur = scenes.begin();\\n            return;\\n        }\\n        \\n        scenes.insert(scene);\\n        if (cur == scenes.end() || scene < *cur) \\n            cur--;\\n    }\\n    \\n    string get() {\\n        string ans = cur->name;\\n        cur++;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SORTracker {\\n    struct location {\\n        int score;\\n        string name;\\n        \\n        location(int score, string name): score(score), name(name) {}\\n        \\n        bool operator<(const location &l) const {\\n            return score > l.score || (score == l.score && name < l.name);\\n        }\\n    };\\n    set<location> scenes;\\n    set<location>::iterator cur;\\npublic:\\n    SORTracker() {}\\n    \\n    void add(string name, int score) {\\n        auto scene = location(score, name);\\n        if (scenes.empty()) {\\n            scenes.insert(scene);\\n            cur = scenes.begin();\\n            return;\\n        }\\n        \\n        scenes.insert(scene);\\n        if (cur == scenes.end() || scene < *cur) \\n            cur--;\\n    }\\n    \\n    string get() {\\n        string ans = cur->name;\\n        cur++;\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361807,
                "title": "c-c-two-heaps-clean-o-logn",
                "content": "Keep 2 heaps, one max and the other min. The idea is to have the index point in the middle of the heaps. So for example, if at the `4th` index out of 10 items, there will be 3 items in the min heap, the result will be the top of the max heap (after the index).\\n- for `add` `O(logN)`, we push to the min heap (before the index), then we take the top of the min heap and push it to the max heap. This will balance the 2 heaps.\\n- for `get` `O(logN)`, the answer is the top of the max heap and we move that item to the min heap to keep the balance.\\n\\n##### C++\\n```c++\\ntypedef pair<string, int> psi;\\n\\nclass MinCompare {\\n public:\\n  bool operator()(psi& a, psi& b) { return a.second == b.second ? a.first < b.first : a.second > b.second; }\\n};\\n\\nclass MaxCompare {\\n public:\\n  bool operator()(psi& a, psi& b) { return a.second == b.second ? a.first > b.first : a.second < b.second; }\\n};\\n\\nclass SORTracker {\\n public:\\n  priority_queue<psi, vector<psi>, MaxCompare> after;\\n  priority_queue<psi, vector<psi>, MinCompare> before;\\n\\n  SORTracker() {}\\n\\n  void add(string name, int score) {\\n    before.push({name, score});\\n    after.push(before.top());\\n    before.pop();\\n  }\\n\\n  string get() {\\n    auto res = after.top();\\n    after.pop();\\n    before.push(res);\\n    return res.first;\\n  }\\n};\\n```\\n\\n##### C#\\n```cs\\npublic class SORTracker {\\n  SortedSet<Tuple<string, int>> before, after;\\n\\n  public SORTracker() {\\n    before = new SortedSet<Tuple<string, int>>(Comparer<Tuple<string, int>>.Create((a, b) =>\\n      a.Item2 == b.Item2 ? b.Item1.CompareTo(a.Item1) : a.Item2 - b.Item2\\n    ));\\n    after = new SortedSet<Tuple<string, int>>(Comparer<Tuple<string, int>>.Create((a, b) =>\\n      a.Item2 == b.Item2 ? a.Item1.CompareTo(b.Item1) : b.Item2 - a.Item2\\n    ));\\n  }\\n\\n  public void Add(string name, int score) {\\n    before.Add(Tuple.Create(name, score));\\n    var first = before.First();\\n    before.Remove(first);\\n    after.Add(first);\\n  }\\n\\n  public string Get() {\\n    var res = after.First();\\n    after.Remove(res);\\n    before.Add(res);\\n    return res.Item1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\ntypedef pair<string, int> psi;\\n\\nclass MinCompare {\\n public:\\n  bool operator()(psi& a, psi& b) { return a.second == b.second ? a.first < b.first : a.second > b.second; }\\n};\\n\\nclass MaxCompare {\\n public:\\n  bool operator()(psi& a, psi& b) { return a.second == b.second ? a.first > b.first : a.second < b.second; }\\n};\\n\\nclass SORTracker {\\n public:\\n  priority_queue<psi, vector<psi>, MaxCompare> after;\\n  priority_queue<psi, vector<psi>, MinCompare> before;\\n\\n  SORTracker() {}\\n\\n  void add(string name, int score) {\\n    before.push({name, score});\\n    after.push(before.top());\\n    before.pop();\\n  }\\n\\n  string get() {\\n    auto res = after.top();\\n    after.pop();\\n    before.push(res);\\n    return res.first;\\n  }\\n};\\n```\n```cs\\npublic class SORTracker {\\n  SortedSet<Tuple<string, int>> before, after;\\n\\n  public SORTracker() {\\n    before = new SortedSet<Tuple<string, int>>(Comparer<Tuple<string, int>>.Create((a, b) =>\\n      a.Item2 == b.Item2 ? b.Item1.CompareTo(a.Item1) : a.Item2 - b.Item2\\n    ));\\n    after = new SortedSet<Tuple<string, int>>(Comparer<Tuple<string, int>>.Create((a, b) =>\\n      a.Item2 == b.Item2 ? a.Item1.CompareTo(b.Item1) : b.Item2 - a.Item2\\n    ));\\n  }\\n\\n  public void Add(string name, int score) {\\n    before.Add(Tuple.Create(name, score));\\n    var first = before.First();\\n    before.Remove(first);\\n    after.Add(first);\\n  }\\n\\n  public string Get() {\\n    var res = after.First();\\n    after.Remove(res);\\n    before.Add(res);\\n    return res.Item1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156362,
                "title": "python-min-max-heap",
                "content": "The idea is similar to problem [295](http://leetcode.com/problems/find-median-from-data-stream/). The only difference is that we are interested in getting the number_of_get(i) th element instead of the median.  For python, heapq is a min heap. We can easily convert it to max heap by putting the key as the ```-score```. However, the tie breaker for string comparison is tricky. Thus, we create Node struture for each heaps and overwrite ```__lt__```.     \\n```\\nclass Node1():\\n    def __init__(self, score, name):\\n        self.score = score\\n        self.name = name\\n    \\n    def __lt__(self, otherNode):\\n        if self.score == otherNode.score:\\n            return self.name>otherNode.name\\n        return self.score<otherNode.score        \\n    \\nclass Node2():\\n    def __init__(self, score, name):\\n        self.score = score\\n        self.name = name\\n    \\n    def __lt__(self, otherNode):\\n        if self.score == otherNode.score:\\n            return self.name<otherNode.name\\n        return otherNode.score<self.score\\n        \\nclass SORTracker:\\n    def __init__(self):\\n        # h1 is min heap, h2 is max heap \\n        self.h1, self.h2 = [], []\\n\\n    def add(self, name: str, score: int) -> None:\\n        if not self.h1 or (self.h2 and score<-self.h2[0].score): # push to h2\\n            heapq.heappush(self.h2, Node2(score, name))\\n        else: # push to h1 and maintain i th order for h2\\n            heapq.heappush(self.h1, Node1(score, name))\\n            node1 = heapq.heappop(self.h1)\\n            # maintain ith order for h2\\n            heapq.heappush(self.h2, Node2(node1.score, node1.name))\\n        \\n        \\n\\n    def get(self) -> str:\\n        node2 = heapq.heappop(self.h2)\\n        score, name = node2.score, node2.name\\n        heapq.heappush(self.h1, Node1(score, name))\\n        \\n        return name \\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```-score```\n```__lt__```\n```\\nclass Node1():\\n    def __init__(self, score, name):\\n        self.score = score\\n        self.name = name\\n    \\n    def __lt__(self, otherNode):\\n        if self.score == otherNode.score:\\n            return self.name>otherNode.name\\n        return self.score<otherNode.score        \\n    \\nclass Node2():\\n    def __init__(self, score, name):\\n        self.score = score\\n        self.name = name\\n    \\n    def __lt__(self, otherNode):\\n        if self.score == otherNode.score:\\n            return self.name<otherNode.name\\n        return otherNode.score<self.score\\n        \\nclass SORTracker:\\n    def __init__(self):\\n        # h1 is min heap, h2 is max heap \\n        self.h1, self.h2 = [], []\\n\\n    def add(self, name: str, score: int) -> None:\\n        if not self.h1 or (self.h2 and score<-self.h2[0].score): # push to h2\\n            heapq.heappush(self.h2, Node2(score, name))\\n        else: # push to h1 and maintain i th order for h2\\n            heapq.heappush(self.h1, Node1(score, name))\\n            node1 = heapq.heappop(self.h1)\\n            # maintain ith order for h2\\n            heapq.heappush(self.h2, Node2(node1.score, node1.name))\\n        \\n        \\n\\n    def get(self) -> str:\\n        node2 = heapq.heappop(self.h2)\\n        score, name = node2.score, node2.name\\n        heapq.heappush(self.h1, Node1(score, name))\\n        \\n        return name \\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958764,
                "title": "c-priority-queue-min-and-max-heap",
                "content": "Two heaps: Min heap and Max heap.\\nMin heap always stores only \"k\" number of elements = The number of times get() is called. (say k). Each time get() is called min_heap size increases by 1 and the kth smallest element is pushed into it.\\nMax heap maintains the list of elements smaller than the kth smallest element at all times. This is done by pushing the latest element from add into the min_heap and then popping the k+1th element and pushing it into the max_heap\\n\\n```\\nclass SORTracker {\\nprivate:\\n\\t// Custom Min_comp and Max_comp operator to maintain score and lexicographical order\\n    struct Min_comp {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) {\\n            if (a.first != b.first) return (a.first > b.first);\\n            else return (a.second < b.second);\\n        }\\n    };\\n    struct Max_comp {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) {\\n            if (a.first != b.first) return (a.first < b.first);\\n            else return (a.second > b.second);\\n        }\\n    };\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Min_comp> min_heap;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Max_comp> max_heap;\\n    \\npublic:\\n    SORTracker() {    \\n    }\\n    \\n    void add(string name, int score) {\\n\\t\\t// Add the new name to min_heap and let min_heap automatically weed out the kth sorted element.\\n\\t\\t// Size k is maintained because mn_heap size increases by 1 each time get() is called\\n        min_heap.push(make_pair(score, name));\\n        max_heap.push(min_heap.top());\\n        min_heap.pop();\\n    }\\n    \\n    string get() {\\n\\t\\t// No need to keep track of the number of times get is called, as min heap size increases automatically \\n        auto ans = max_heap.top();\\n        min_heap.push(ans);\\n        max_heap.pop();\\n        return ans.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker {\\nprivate:\\n\\t// Custom Min_comp and Max_comp operator to maintain score and lexicographical order\\n    struct Min_comp {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) {\\n            if (a.first != b.first) return (a.first > b.first);\\n            else return (a.second < b.second);\\n        }\\n    };\\n    struct Max_comp {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) {\\n            if (a.first != b.first) return (a.first < b.first);\\n            else return (a.second > b.second);\\n        }\\n    };\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Min_comp> min_heap;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Max_comp> max_heap;\\n    \\npublic:\\n    SORTracker() {    \\n    }\\n    \\n    void add(string name, int score) {\\n\\t\\t// Add the new name to min_heap and let min_heap automatically weed out the kth sorted element.\\n\\t\\t// Size k is maintained because mn_heap size increases by 1 each time get() is called\\n        min_heap.push(make_pair(score, name));\\n        max_heap.push(min_heap.top());\\n        min_heap.pop();\\n    }\\n    \\n    string get() {\\n\\t\\t// No need to keep track of the number of times get is called, as min heap size increases automatically \\n        auto ans = max_heap.top();\\n        min_heap.push(ans);\\n        max_heap.pop();\\n        return ans.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675900,
                "title": "c-using-min-heap-and-max-heap-custom-comparator",
                "content": "I maintained one min heap of size ```i+1```, where i represents the number of times get has been called till now. The min heap contains all the maximum entries seen till now. So whenever a get is called, we simple have to return the top most entry in the min heap and increment the ```i to i+1```. But, get can be called consecutive times, and hence we need to update the length of the min heap and add the appropriate entries with the help of max heap. Therefore every get is followed by an add of the top most entry in the min heap. Thats it! \\n\\n```\\nclass SORTracker {\\npublic:\\n    #define pis pair<int, string> \\n    struct cmp{\\n        bool operator()(pis &a, pis & b){\\n            if(a.first == b.first) return a.second > b.second; \\n            return a.first < b.first; \\n        }\\n    };\\n    \\n    struct cmpRev{\\n        bool operator()(pis &a, pis & b){\\n            if(a.first == b.first) return a.second < b.second; \\n            return a.first > b.first; \\n        }\\n    };\\n    \\n    int i = 0; \\n    priority_queue<pis, vector<pis>, cmp> maxHeap; \\n    priority_queue<pis, vector<pis>, cmpRev> minHeap; \\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        while(minHeap.size()<i+1 && maxHeap.size()){\\n            minHeap.push(maxHeap.top()); \\n            maxHeap.pop(); \\n        }\\n        \\n        minHeap.push({score, name}); \\n        if(minHeap.size() > i+1) {\\n            maxHeap.push(minHeap.top()); \\n            minHeap.pop(); \\n        }\\n    }\\n    \\n    string get() {\\n        i++; \\n        auto temp = minHeap.top();\\n        minHeap.pop(); \\n        add(temp.second, temp.first); \\n        return temp.second; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```i+1```\n```i to i+1```\n```\\nclass SORTracker {\\npublic:\\n    #define pis pair<int, string> \\n    struct cmp{\\n        bool operator()(pis &a, pis & b){\\n            if(a.first == b.first) return a.second > b.second; \\n            return a.first < b.first; \\n        }\\n    };\\n    \\n    struct cmpRev{\\n        bool operator()(pis &a, pis & b){\\n            if(a.first == b.first) return a.second < b.second; \\n            return a.first > b.first; \\n        }\\n    };\\n    \\n    int i = 0; \\n    priority_queue<pis, vector<pis>, cmp> maxHeap; \\n    priority_queue<pis, vector<pis>, cmpRev> minHeap; \\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        while(minHeap.size()<i+1 && maxHeap.size()){\\n            minHeap.push(maxHeap.top()); \\n            maxHeap.pop(); \\n        }\\n        \\n        minHeap.push({score, name}); \\n        if(minHeap.size() > i+1) {\\n            maxHeap.push(minHeap.top()); \\n            minHeap.pop(); \\n        }\\n    }\\n    \\n    string get() {\\n        i++; \\n        auto temp = minHeap.top();\\n        minHeap.pop(); \\n        add(temp.second, temp.first); \\n        return temp.second; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623497,
                "title": "c-sortedlist",
                "content": "```\\npublic class Record {\\n    public string Name; public int Score;\\n}\\nSortedList<Record, Record> list;\\nprivate int index = 0;\\npublic SORTracker() {\\n    list = new SortedList<Record, Record>(Comparer<Record>.Create((a, b) => a.Score == b.Score ? a.Name.CompareTo(b.Name) : a.Score < b.Score ? 1 : -1));\\n}\\n\\npublic void Add(string name, int score) {\\n    var newRecord = new Record(){Name = name, Score=score};\\n    list.Add(newRecord, newRecord);\\n}\\n\\npublic string Get() {\\n    return list.Values[index++].Name;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Record {\\n    public string Name; public int Score;\\n}\\nSortedList<Record, Record> list;\\nprivate int index = 0;\\npublic SORTracker() {\\n    list = new SortedList<Record, Record>(Comparer<Record>.Create((a, b) => a.Score == b.Score ? a.Name.CompareTo(b.Name) : a.Score < b.Score ? 1 : -1));\\n}\\n\\npublic void Add(string name, int score) {\\n    var newRecord = new Record(){Name = name, Score=score};\\n    list.Add(newRecord, newRecord);\\n}\\n\\npublic string Get() {\\n    return list.Values[index++].Name;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623301,
                "title": "python-dict-list",
                "content": "```python\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.d = collections.defaultdict(list)\\n        self.i = -1\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.d[score].append(name)\\n        self.d[score].sort()\\n\\n    def get(self) -> str:\\n        self.i += 1\\n        j = self.i\\n\\n        for k in sorted(self.d.keys(), reverse=True):\\n            if j >= len(self.d[k]):\\n                j -= len(self.d[k])\\n            else:\\n                return self.d[k][j]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.d = collections.defaultdict(list)\\n        self.i = -1\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.d[score].append(name)\\n        self.d[score].sort()\\n\\n    def get(self) -> str:\\n        self.i += 1\\n        j = self.i\\n\\n        for k in sorted(self.d.keys(), reverse=True):\\n            if j >= len(self.d[k]):\\n                j -= len(self.d[k])\\n            else:\\n                return self.d[k][j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623285,
                "title": "python",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n    def __init__(self):\\n        self.curr=0\\n        self.list=SortedList([])\\n    def add(self, name: str, score: int) -> None:\\n        self.list.add((-score,name))\\n    def get(self) -> str:\\n        ans= self.list[self.curr][1]\\n        self.curr+=1\\n        return ans",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n    def __init__(self):\\n        self.curr=0\\n        self.list=SortedList([])\\n    def add(self, name: str, score: int) -> None:\\n        self.list.add((-score,name))\\n    def get(self) -> str:\\n        ans= self.list[self.curr][1]\\n        self.curr+=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2229108,
                "title": "python-heaps-and-custom-string-class",
                "content": "##### **Intuition:**\\nSeems like a question where we need to to keep track of the places with higher and lower score then the ith place.\\nHeaps are perfect solution solution for this kinda problems. Imagine a maxheap on the right and min heap on the left, where the max heap on the right would always give us the ith best place to visit. \\nAnd on every get call we pop a place from the right and keep it the left min heap.\\nFor every add call we compare the top of left and put it either to left or right depending on the score and the string, if we put it to the left (minheap) we pop out the min element from left and append it to the right.\\n\\nAlso we need a custom string class while we push to the left minheap, beacuse we need a lecixographically sorted values but it reverse, creating a custom string class is a great way to acheive this, didn\\'t actually much about custom string classes, learnt while solving this problem \\n\\n\\n```\\nimport heapq\\nclass stringMod():\\n    def __init__(self, word):\\n        self.word = word\\n        \\n    def __lt__(self, other):\\n        return self.word>other.word\\n    \\nclass SORTracker:\\n    def __init__(self):\\n        #left is minheap\\n        self.left = []\\n        #right is maxheap\\n        self.right = []\\n        \\n    def add(self, name: str, score: int) -> None:\\n        if not self.left:\\n            #for first instances before a get is called the left will be empty\\n            heapq.heappush(self.right, [-score,name])\\n        elif self.left[0][0]<score or (self.left[0][0] == score and self.left[0][1].word>name):\\n            #when the current comes before ie higher score or lexiographically smaller name \\n            heapq.heappush(self.left, [score,stringMod(name)])\\n            scoreNew, obj = heapq.heappop(self.left)\\n            nameNew = obj.word\\n            heapq.heappush(self.right, [-scoreNew,nameNew])\\n        else:\\n            #for lower scores we append to the right\\n            heapq.heappush(self.right, [-score,name])\\n            \\n    def get(self) -> str:\\n        #we pop the top name from right and append it to left\\n        score, name = heapq.heappop(self.right)\\n        heapq.heappush(self.left, [-score,stringMod(name)])\\n        return name\\n```\\n\\nTrust in the grind\\uD83D\\uDE4C\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass stringMod():\\n    def __init__(self, word):\\n        self.word = word\\n        \\n    def __lt__(self, other):\\n        return self.word>other.word\\n    \\nclass SORTracker:\\n    def __init__(self):\\n        #left is minheap\\n        self.left = []\\n        #right is maxheap\\n        self.right = []\\n        \\n    def add(self, name: str, score: int) -> None:\\n        if not self.left:\\n            #for first instances before a get is called the left will be empty\\n            heapq.heappush(self.right, [-score,name])\\n        elif self.left[0][0]<score or (self.left[0][0] == score and self.left[0][1].word>name):\\n            #when the current comes before ie higher score or lexiographically smaller name \\n            heapq.heappush(self.left, [score,stringMod(name)])\\n            scoreNew, obj = heapq.heappop(self.left)\\n            nameNew = obj.word\\n            heapq.heappush(self.right, [-scoreNew,nameNew])\\n        else:\\n            #for lower scores we append to the right\\n            heapq.heappush(self.right, [-score,name])\\n            \\n    def get(self) -> str:\\n        #we pop the top name from right and append it to left\\n        score, name = heapq.heappop(self.right)\\n        heapq.heappush(self.left, [-score,stringMod(name)])\\n        return name\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842245,
                "title": "python-two-solutions-sortedcontainers-and-minheap-maxheap-with-explanation",
                "content": "First Solution (Using sortedcontainers):\\nHere we use SortedList which is implemented using divide & conquer and binary search, sortedlist always maintain the sorted order, so we can just query the ith index nd get the Ithe best location\\nMore at: https://github.com/grantjenks/python-sortedcontainers/blob/master/src/sortedcontainers/sortedlist.py\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass SORTracker1:\\n    def __init__(self):\\n        self.storage=SortedList()\\n        self.queryNum=0\\n    \\n    def add(self, name: str, score: int) -> None:\\n        self.storage.add((-score,name))    \\n\\n    def get(self) -> str:\\n        ans=self.storage[self.queryNum]\\n        self.queryNum+=1\\n        return ans[1]\\n```\\n\\nSecond Solution (using heaps):\\nIdea: \\n1. First lets suppose, there is no condition of returing the ith best location. So, in this scenario we just have to use a maxheap and return the top element of the maxheap every time the get function is called.\\nBut the catch in the question is that we have to return the ith best so, in this case we can not pop the top most element from the heap and just return it because in some cases we might need the popped location. Refer to provided example in the question description for more insight.\\n2. So, we also need the popped locations to be used further. To solve this scenario what we can do is use two heaps. \\n3. See the diagram below:\\n![image](https://assets.leetcode.com/users/images/ec1cee15-ca1b-4a84-87e2-2e0b7f2264a6_1682336231.7993224.jpeg)\\n\\n4. In the diagram we can see, if we think of the min heap in inverted fashion then combining it with the max heap will give us the tracker. Because when we pop the ith best location, before returning it we will also push that to the min heap namely upper part of the tracker, so that the order of the best locations is maintained, now when we add a new location we will check if the new location is better than the top of min heap or i-1th location, if it is better than we will add the new location in the min heap or the upper part of the tracker and remove the top of min heap or the i-1 th location and push it to max heap or lower part of the tracker, in simple terms we have two parts, upper part contains 1 to (i-1)th locations and lower part contains i to nth locations, so whenever we get a location that fits in the upper part we push the new location there, now it has 1 to i locations so we push the (i-1)th location in the upper part, so that top of maxheap remains the ith best location. As we are using heaps so the order is maintained.\\n\\nNote: In python, maxheap do not exist, so I have used a custom string class that will sort the location names in decreasing order in minheap if scores are equal. We do not need it in maxHeap, as the best location is decided by a big score and a lexicographically smaller name.\\n\\n```\\nclass CString:\\n    def __init__(self,word):\\n        self.word=word\\n    \\n    def __lt__(self,other):\\n        return self.word>other.word\\n    \\n    def __eq__(self,other):\\n        return self.word==other.word\\n        \\nclass SORTracker:\\n    def __init__(self):\\n        self.upperPart=[] #minHeap\\n        self.lowerPart=[] #maxHeap\\n        \\n    def add(self, name, score):\\n        name=CString(name)\\n\\t\\t#first check if there is any element in minHeap\\n        if self.upperPart:\\n            upperScore,upperName=self.upperPart[0]\\n\\t\\t\\t#check if we got a better location than the i-1th location\\n            if (upperScore<score) or (upperScore==score and upperName.word>name.word):\\n                heapq.heappop(self.upperPart)\\n                heapq.heappush(self.upperPart,(score,name))\\n\\t\\t\\t\\t#negative score used below because its a maxheap\\n                heapq.heappush(self.lowerPart,(-upperScore,upperName.word))\\n                \\n            else:\\n\\t\\t\\t#if not we just add the new location to lower part\\n                heapq.heappush(self.lowerPart,(-score,name.word))\\n        else:\\n\\t\\t#if not we just add the new location to lower part\\n            heapq.heappush(self.lowerPart,(-score,name.word))             \\n    \\n    def get(self):\\n\\t\\t#remove from the ith position\\n        score,name=heapq.heappop(self.lowerPart)\\n\\t\\t#add to the upper part of the tracker or minHeap\\n        heapq.heappush(self.upperPart,(-score,CString(name)))\\n        return name\\n        \\n```\\n\\nTime Complexity (same for both solution):\\nadd function: O(logn)\\nget function: O(logn)\\n\\nPlease upvote, if you like the explanation!\\n",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker1:\\n    def __init__(self):\\n        self.storage=SortedList()\\n        self.queryNum=0\\n    \\n    def add(self, name: str, score: int) -> None:\\n        self.storage.add((-score,name))    \\n\\n    def get(self) -> str:\\n        ans=self.storage[self.queryNum]\\n        self.queryNum+=1\\n        return ans[1]\\n```\n```\\nclass CString:\\n    def __init__(self,word):\\n        self.word=word\\n    \\n    def __lt__(self,other):\\n        return self.word>other.word\\n    \\n    def __eq__(self,other):\\n        return self.word==other.word\\n        \\nclass SORTracker:\\n    def __init__(self):\\n        self.upperPart=[] #minHeap\\n        self.lowerPart=[] #maxHeap\\n        \\n    def add(self, name, score):\\n        name=CString(name)\\n\\t\\t#first check if there is any element in minHeap\\n        if self.upperPart:\\n            upperScore,upperName=self.upperPart[0]\\n\\t\\t\\t#check if we got a better location than the i-1th location\\n            if (upperScore<score) or (upperScore==score and upperName.word>name.word):\\n                heapq.heappop(self.upperPart)\\n                heapq.heappush(self.upperPart,(score,name))\\n\\t\\t\\t\\t#negative score used below because its a maxheap\\n                heapq.heappush(self.lowerPart,(-upperScore,upperName.word))\\n                \\n            else:\\n\\t\\t\\t#if not we just add the new location to lower part\\n                heapq.heappush(self.lowerPart,(-score,name.word))\\n        else:\\n\\t\\t#if not we just add the new location to lower part\\n            heapq.heappush(self.lowerPart,(-score,name.word))             \\n    \\n    def get(self):\\n\\t\\t#remove from the ith position\\n        score,name=heapq.heappop(self.lowerPart)\\n\\t\\t#add to the upper part of the tracker or minHeap\\n        heapq.heappush(self.upperPart,(-score,CString(name)))\\n        return name\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571762,
                "title": "java-no-need-for-treeset-binary-search-with-arraylist",
                "content": "Maintained a sorted list using binary search to find the insert location.\\nTreeSet is good as well but doesn\\'t handle duplicate names very well and maintaining last read postion is not as intuitive.\\n```\\nclass SORTracker {\\n    ArrayList<Entry> list;\\n    int read;\\n    \\n    public SORTracker() {\\n        list = new ArrayList<Entry> ();\\n    }\\n    \\n    public void add(String name, int score) {\\n        var e = new Entry(name, score);\\n        list.add(find(e), e);\\n    }\\n    \\n    public String get() {\\n        read++;\\n        return list.get(read-1).name;\\n    }\\n    \\n    int find(Entry e){\\n        int left = 0;\\n        int right = list.size()-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right -left)/2;\\n            int cmp = e.compareTo(list.get(mid));\\n            if(cmp < 0) {\\n                right = mid -1;\\n            } else if(cmp > 0){\\n                left = mid +1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    static class Entry implements Comparable<Entry> {\\n        String name;\\n        int score;\\n        Entry(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        public int compareTo(Entry e){\\n            return score == e.score? name.compareTo(e.name) : e.score - score;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass SORTracker {\\n    ArrayList<Entry> list;\\n    int read;\\n    \\n    public SORTracker() {\\n        list = new ArrayList<Entry> ();\\n    }\\n    \\n    public void add(String name, int score) {\\n        var e = new Entry(name, score);\\n        list.add(find(e), e);\\n    }\\n    \\n    public String get() {\\n        read++;\\n        return list.get(read-1).name;\\n    }\\n    \\n    int find(Entry e){\\n        int left = 0;\\n        int right = list.size()-1;\\n        \\n        while(left <= right){\\n            int mid = left + (right -left)/2;\\n            int cmp = e.compareTo(list.get(mid));\\n            if(cmp < 0) {\\n                right = mid -1;\\n            } else if(cmp > 0){\\n                left = mid +1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return left;\\n    }\\n    \\n    static class Entry implements Comparable<Entry> {\\n        String name;\\n        int score;\\n        Entry(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        public int compareTo(Entry e){\\n            return score == e.score? name.compareTo(e.name) : e.score - score;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460832,
                "title": "python-sorted-list-solution-two-heaps-solution",
                "content": "Sorted list solution\\n```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.locations = []\\n        self.get_calls = -1\\n\\n    def add(self, name: str, score: int) -> None:\\n        # O(log(n)) to find + O(n) to insert = O(n)\\n        bisect.insort_left(self.locations, (-score, name))\\n\\n    def get(self) -> str:\\n        # O(1) to get\\n        self.get_calls += 1\\n        return self.locations[self.get_calls][1]\\n```\\n---------------------------------\\nTwo heaps solution\\n```\\ndef str_to_list(s):\\n    return [-ord(char) for char in s] + [0] * (10 - len(s))\\n\\ndef list_to_str(lst):\\n    return \\'\\'.join(chr(-x) for x in lst if x != 0)\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.queue_heap = []\\n        self.seen_heap = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        list_name = str_to_list(name)\\n        if self.seen_heap and \\\\\\n                (score > self.seen_heap[0][0] or (score == self.seen_heap[0][0] and list_name > self.seen_heap[0][1])):\\n            s, n = heapq.heappop(self.seen_heap)\\n            n = list_to_str(n)\\n            heapq.heappush(self.queue_heap, (-s, n))\\n            heapq.heappush(self.seen_heap, (score, list_name))\\n        else:\\n            heapq.heappush(self.queue_heap, (-score, name))\\n\\n    def get(self) -> str:\\n        s, n = heapq.heappop(self.queue_heap)\\n        list_name = str_to_list(n)\\n        heapq.heappush(self.seen_heap, (-s, list_name))\\n        return n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.locations = []\\n        self.get_calls = -1\\n\\n    def add(self, name: str, score: int) -> None:\\n        # O(log(n)) to find + O(n) to insert = O(n)\\n        bisect.insort_left(self.locations, (-score, name))\\n\\n    def get(self) -> str:\\n        # O(1) to get\\n        self.get_calls += 1\\n        return self.locations[self.get_calls][1]\\n```\n```\\ndef str_to_list(s):\\n    return [-ord(char) for char in s] + [0] * (10 - len(s))\\n\\ndef list_to_str(lst):\\n    return \\'\\'.join(chr(-x) for x in lst if x != 0)\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.queue_heap = []\\n        self.seen_heap = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        list_name = str_to_list(name)\\n        if self.seen_heap and \\\\\\n                (score > self.seen_heap[0][0] or (score == self.seen_heap[0][0] and list_name > self.seen_heap[0][1])):\\n            s, n = heapq.heappop(self.seen_heap)\\n            n = list_to_str(n)\\n            heapq.heappush(self.queue_heap, (-s, n))\\n            heapq.heappush(self.seen_heap, (score, list_name))\\n        else:\\n            heapq.heappush(self.queue_heap, (-score, name))\\n\\n    def get(self) -> str:\\n        s, n = heapq.heappop(self.queue_heap)\\n        list_name = str_to_list(n)\\n        heapq.heappush(self.seen_heap, (-s, list_name))\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176110,
                "title": "java-simple-solution-using-minheap-and-maxheap",
                "content": "class SORTracker {\\n\\n    PriorityQueue<Node> pq;\\n    PriorityQueue<Node> pq1;\\n    \\n    public SORTracker() {\\n        pq = new PriorityQueue<>((a, b) -> a.score == b.score ? a.name.compareTo(b.name) : b.score - a.score);\\n        pq1 = new PriorityQueue<>((a, b) -> a.score == b.score ? b.name.compareTo(a.name) : a.score - b.score);\\n        \\n    }\\n    \\n    public void add(String name, int score) {\\n        pq1.add(new Node(name, score));\\n        pq.add(pq1.remove());\\n    }\\n    \\n    public String get() {\\n        String ans = pq.peek().name;\\n        pq1.add(pq.remove());\\n        return ans;\\n        \\n    }\\n}\\n\\nclass Node {\\n    String name;\\n    int score;\\n    \\n    public Node(String name, int score) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class SORTracker {\\n\\n    PriorityQueue<Node> pq;\\n    PriorityQueue<Node> pq1;\\n    \\n    public SORTracker() {\\n        pq = new PriorityQueue<>((a, b) -> a.score == b.score ? a.name.compareTo(b.name) : b.score - a.score);\\n        pq1 = new PriorityQueue<>((a, b) -> a.score == b.score ? b.name.compareTo(a.name) : a.score - b.score);\\n        \\n    }\\n    \\n    public void add(String name, int score) {\\n        pq1.add(new Node(name, score));\\n        pq.add(pq1.remove());\\n    }\\n    \\n    public String get() {\\n        String ans = pq.peek().name;\\n        pq1.add(pq.remove());\\n        return ans;\\n        \\n    }\\n}\\n\\nclass Node {\\n    String name;\\n    int score;\\n    \\n    public Node(String name, int score) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1966133,
                "title": "sequentially-ordinal-rank-tracker-java-treemap-binary-search",
                "content": "#### **Sequentially Ordinal Rank Tracker**\\n```\\nclass SORTracker {\\n\\n    private TreeMap<Integer, List<String>> map;\\n    private int queryNum;\\n    \\n    // Find suitable position for name in the list\\n    private int getIndex(String name, List<String> list) {\\n        int l = 0, r = list.size() - 1, m = 0;\\n        while (l < r) {\\n            m = l + (r - l) / 2;\\n            if(name.compareTo(list.get(m)) > 0) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return name.compareTo(list.get(l)) > 0 ? l+1 : l;\\n    }\\n    \\n    public SORTracker() {\\n        map = new TreeMap<>((a,b) -> (b-a));\\n        queryNum = 0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        List<String> list = map.getOrDefault(score, new ArrayList<>());\\n        int index = (list.size() == 0) ? 0 : getIndex(name, list);\\n        list.add(index, name);\\n        map.put(score, list);\\n    }\\n    \\n    public String get() {\\n        int index = queryNum;\\n        for (int score: map.keySet()) {\\n            if (index < map.get(score).size()) {\\n                queryNum++;\\n                return map.get(score).get(index);\\n            }\\n            index -= map.get(score).size();\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass SORTracker {\\n\\n    private TreeMap<Integer, List<String>> map;\\n    private int queryNum;\\n    \\n    // Find suitable position for name in the list\\n    private int getIndex(String name, List<String> list) {\\n        int l = 0, r = list.size() - 1, m = 0;\\n        while (l < r) {\\n            m = l + (r - l) / 2;\\n            if(name.compareTo(list.get(m)) > 0) {\\n                l = m + 1;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return name.compareTo(list.get(l)) > 0 ? l+1 : l;\\n    }\\n    \\n    public SORTracker() {\\n        map = new TreeMap<>((a,b) -> (b-a));\\n        queryNum = 0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        List<String> list = map.getOrDefault(score, new ArrayList<>());\\n        int index = (list.size() == 0) ? 0 : getIndex(name, list);\\n        list.add(index, name);\\n        map.put(score, list);\\n    }\\n    \\n    public String get() {\\n        int index = queryNum;\\n        for (int score: map.keySet()) {\\n            if (index < map.get(score).size()) {\\n                queryNum++;\\n                return map.get(score).get(index);\\n            }\\n            index -= map.get(score).size();\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667160,
                "title": "c-simple-2-heap-amortised-tc-o-lg-n-sc-o-n",
                "content": "We will be using one **Max Heap** and  one **Min Heap**(implemented using stl priority_queue)\\n\\nNow, we will push in such a way that top of maxHeap contains our answer. Which means, while get() maxHeap contains highest **curr** elements, where curr represent number of times get() function is called.\\n\\nAlso, minHeap contains rest elements such that top(if exists) of it is the elements just smaller than top of maxHeap.\\n\\nNow, this can also be achieved by creating custom comparators for priority_queue but it can be simplified in a manner that we will push pair **{-score, name}** into both the min and max priority queues. (Just observe this for a minute). We will get what we need. Just a reminder that an element with greater score (i.e. smaller -score) and if same, then smaller(lexicographically) name will be ranked higher.\\n\\n**Operation 1 : void add(string name, int score)** \\n```\\nminHeap.push({-score, name});\\n```\\nJust push the pair in minHeap.\\nTime Complexity : O(lg(n)) (Worst Case)\\n\\n**Operation 2 : string get()**\\n```\\ncurr++;\\nwhile(maxHeap.size() < curr) {\\n\\tmaxHeap.push(minHeap.top());\\n\\tminHeap.pop();\\n}\\nif(!minHeap.empty()) {\\n\\twhile((-maxHeap.top().first < -minHeap.top().first) || (maxHeap.top().first == minHeap.top().first && maxHeap.top().second > minHeap.top().second)) {\\n\\t\\tauto temp = maxHeap.top();\\n\\t\\tmaxHeap.pop();\\n\\t\\tmaxHeap.push(minHeap.top());\\n\\t\\tminHeap.pop();\\n\\t\\tminHeap.push(temp);\\n\\t}\\n}\\nreturn maxHeap.top().second;\\n```\\nStep - 1 -> Increment **curr** (Number of calls to get()).\\nStep - 2 -> Complete maxHeap s.t. it contains curr number of elements.\\nStep - 3 -> Now, there can be cases when new elements that are pushed in minHeap are greater than in maxHeap and hence check this by comparing topmost elements of both and exchange(not swap) their topmost values until \\ntopmost(maxHeap) > topmost(minHeap) hold true or minHeap is empty.\\nStep - 4 -> Return string part of topmost value of maxHeap.\\n\\nTime Complexity : O(lg(n)) (Amortised)\\n\\n```\\nclass SORTracker {\\npublic:\\n    int curr = 0;\\n    priority_queue<pair<int, string>> maxHeap;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> minHeap;\\n    SORTracker() {}\\n    \\n    void add(string name, int score) {\\n        minHeap.push({-score, name});\\n    }\\n    \\n    string get() {\\n        curr++;\\n        while(maxHeap.size() < curr) {\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n        if(!minHeap.empty()) {\\n            while((-maxHeap.top().first < -minHeap.top().first) || (maxHeap.top().first == minHeap.top().first && maxHeap.top().second > minHeap.top().second)) {\\n                auto temp = maxHeap.top();\\n                maxHeap.pop();\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n                minHeap.push(temp);\\n            }\\n        }\\n        return maxHeap.top().second;\\n    }\\n};\\n```\\n\\nIf you like the explaination, please **UPVOTE** the solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nminHeap.push({-score, name});\\n```\n```\\ncurr++;\\nwhile(maxHeap.size() < curr) {\\n\\tmaxHeap.push(minHeap.top());\\n\\tminHeap.pop();\\n}\\nif(!minHeap.empty()) {\\n\\twhile((-maxHeap.top().first < -minHeap.top().first) || (maxHeap.top().first == minHeap.top().first && maxHeap.top().second > minHeap.top().second)) {\\n\\t\\tauto temp = maxHeap.top();\\n\\t\\tmaxHeap.pop();\\n\\t\\tmaxHeap.push(minHeap.top());\\n\\t\\tminHeap.pop();\\n\\t\\tminHeap.push(temp);\\n\\t}\\n}\\nreturn maxHeap.top().second;\\n```\n```\\nclass SORTracker {\\npublic:\\n    int curr = 0;\\n    priority_queue<pair<int, string>> maxHeap;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> minHeap;\\n    SORTracker() {}\\n    \\n    void add(string name, int score) {\\n        minHeap.push({-score, name});\\n    }\\n    \\n    string get() {\\n        curr++;\\n        while(maxHeap.size() < curr) {\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n        if(!minHeap.empty()) {\\n            while((-maxHeap.top().first < -minHeap.top().first) || (maxHeap.top().first == minHeap.top().first && maxHeap.top().second > minHeap.top().second)) {\\n                auto temp = maxHeap.top();\\n                maxHeap.pop();\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n                minHeap.push(temp);\\n            }\\n        }\\n        return maxHeap.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631368,
                "title": "java-order-statistic-tree-based-on-left-leaning-red-black-tree",
                "content": "Binary search tree can be used for efficient (O(logN)) insertion.\\n\\nEfficient (O(logN)) rank query requires [Order Statistic Tree](https://en.wikipedia.org/wiki/Order_statistic_tree) - a BST where each node stores the size of its subtree.\\nThere is no standard implementation of Order Statistic Tree in Java, so I have implemented my own.\\nBalancing the tree was the main challenge - I based mine on [Left-Leaning Red-Black Tree by R. Sedgewick.](https://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf) (link points to Sedgewick\\'s whitepaper that describes tree implementation in details).\\n\\n```\\nclass SORTracker {\\n    \\n    private Tree tree;\\n    private int rank;\\n\\n    public SORTracker() {\\n        tree = new Tree();\\n        rank = 0;\\n    }\\n\\n    public void add(String name, int score) {\\n        tree.insert(name, score);\\n    }\\n\\n    public String get() {\\n        return tree.rank(++rank);\\n    }\\n    \\n    private static final class Node {\\n        private final String name;\\n        private final int score;\\n\\n        private int size;\\n        private boolean red;\\n\\n        private Node left;\\n        private Node right;\\n\\n        Node(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n            this.size = 1;\\n            this.red = true;\\n        }\\n    }\\n\\n    private static final class Tree {\\n        private Node root;\\n\\n        String rank(int rank) {\\n            Node n = root;\\n            while (n != null) {\\n                if (rank <= size(n.left)) {\\n                    n = n.left;\\n                } else {\\n                    rank -= size(n.left);\\n                    if (rank == 1) {\\n                        return n.name;\\n                    } else {\\n                        rank--;\\n                        n = n.right;\\n                    }\\n                }\\n            }\\n            throw new IllegalArgumentException();\\n        }\\n\\n        void insert(String name, int score) {\\n            root = insert(root, name, score);\\n            root.red = false;\\n        }\\n\\n        private static Node insert(Node n, String name, int score) {\\n            if (n == null) {\\n                return new Node(name, score);\\n            }\\n\\t\\t\\t\\n\\t\\t\\tif (isRed(n.left) && isRed(n.right)) {\\n                flipColors(n);\\n            }\\n\\n            if (score > n.score || score == n.score && name.compareTo(n.name) < 0) {\\n                n.left = insert(n.left, name, score);\\n            } else {\\n                n.right = insert(n.right, name, score);\\n            }\\n\\n            n.size++;\\n\\n            if (isRed(n.right) && !isRed(n.left)) {\\n                n = rotateLeft(n);\\n            }\\n            if (isRed(n.left) && isRed(n.left.left)) {\\n                n = rotateRight(n);\\n            }\\n\\n            return n;\\n        }\\n\\n        private static int size(Node n) {\\n            return n != null ? n.size : 0;\\n        }\\n\\n        private static boolean isRed(Node n) {\\n            return n != null && n.red;\\n        }\\n\\n        private static Node rotateLeft(Node n) {\\n            Node x = n.right;\\n\\n            n.right = x.left;\\n            x.left = n;\\n\\n            x.red = n.red;\\n            n.red = true;\\n\\n            n.size -= size(x.right) + 1;\\n            x.size += size(n.left) + 1;\\n\\n            return x;\\n        }\\n\\n        private static Node rotateRight(Node n) {\\n            Node x = n.left;\\n\\n            n.left = x.right;\\n            x.right = n;\\n\\n            x.red = n.red;\\n            n.red = true;\\n\\n            n.size -= size(x.left) + 1;\\n            x.size += size(n.right) + 1;\\n\\n            return x;\\n        }\\n\\n        private static void flipColors(Node n) {\\n            n.red = !n.red;\\n            n.left.red = !n.left.red;\\n            n.right.red = !n.right.red;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\n    \\n    private Tree tree;\\n    private int rank;\\n\\n    public SORTracker() {\\n        tree = new Tree();\\n        rank = 0;\\n    }\\n\\n    public void add(String name, int score) {\\n        tree.insert(name, score);\\n    }\\n\\n    public String get() {\\n        return tree.rank(++rank);\\n    }\\n    \\n    private static final class Node {\\n        private final String name;\\n        private final int score;\\n\\n        private int size;\\n        private boolean red;\\n\\n        private Node left;\\n        private Node right;\\n\\n        Node(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n            this.size = 1;\\n            this.red = true;\\n        }\\n    }\\n\\n    private static final class Tree {\\n        private Node root;\\n\\n        String rank(int rank) {\\n            Node n = root;\\n            while (n != null) {\\n                if (rank <= size(n.left)) {\\n                    n = n.left;\\n                } else {\\n                    rank -= size(n.left);\\n                    if (rank == 1) {\\n                        return n.name;\\n                    } else {\\n                        rank--;\\n                        n = n.right;\\n                    }\\n                }\\n            }\\n            throw new IllegalArgumentException();\\n        }\\n\\n        void insert(String name, int score) {\\n            root = insert(root, name, score);\\n            root.red = false;\\n        }\\n\\n        private static Node insert(Node n, String name, int score) {\\n            if (n == null) {\\n                return new Node(name, score);\\n            }\\n\\t\\t\\t\\n\\t\\t\\tif (isRed(n.left) && isRed(n.right)) {\\n                flipColors(n);\\n            }\\n\\n            if (score > n.score || score == n.score && name.compareTo(n.name) < 0) {\\n                n.left = insert(n.left, name, score);\\n            } else {\\n                n.right = insert(n.right, name, score);\\n            }\\n\\n            n.size++;\\n\\n            if (isRed(n.right) && !isRed(n.left)) {\\n                n = rotateLeft(n);\\n            }\\n            if (isRed(n.left) && isRed(n.left.left)) {\\n                n = rotateRight(n);\\n            }\\n\\n            return n;\\n        }\\n\\n        private static int size(Node n) {\\n            return n != null ? n.size : 0;\\n        }\\n\\n        private static boolean isRed(Node n) {\\n            return n != null && n.red;\\n        }\\n\\n        private static Node rotateLeft(Node n) {\\n            Node x = n.right;\\n\\n            n.right = x.left;\\n            x.left = n;\\n\\n            x.red = n.red;\\n            n.red = true;\\n\\n            n.size -= size(x.right) + 1;\\n            x.size += size(n.left) + 1;\\n\\n            return x;\\n        }\\n\\n        private static Node rotateRight(Node n) {\\n            Node x = n.left;\\n\\n            n.left = x.right;\\n            x.right = n;\\n\\n            x.red = n.red;\\n            n.red = true;\\n\\n            n.size -= size(x.left) + 1;\\n            x.size += size(n.right) + 1;\\n\\n            return x;\\n        }\\n\\n        private static void flipColors(Node n) {\\n            n.red = !n.red;\\n            n.left.red = !n.left.red;\\n            n.right.red = !n.right.red;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629479,
                "title": "c-set-python-sortedlist-o-nlogn",
                "content": "```\\n1. C++\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> tree;\\n\\tset<pair<int, string>>::iterator it;\\n\\tSORTracker(){\\n\\t\\n\\t}\\n\\n\\tvoid add(string name, int score){\\n        score *= -1;\\n\\t\\ttree.emplace(score, name);\\n\\t\\tif(tree.size() == 1){\\n\\t\\t\\tit = begin(tree);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(score < it->first || (score == it->first && name < it->second)) it--;\\n\\t}\\n\\n\\tstring get(){\\n\\t\\tstring res = it->second;\\n\\t\\tit++;\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\n```\\n2. python3\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.vec = SortedList()\\n        self.i = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        score *= -1\\n        self.vec.add((score, name))\\n\\n    def get(self) -> str:\\n        res = self.vec[self.i][1]\\n        self.i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n1. C++\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> tree;\\n\\tset<pair<int, string>>::iterator it;\\n\\tSORTracker(){\\n\\t\\n\\t}\\n\\n\\tvoid add(string name, int score){\\n        score *= -1;\\n\\t\\ttree.emplace(score, name);\\n\\t\\tif(tree.size() == 1){\\n\\t\\t\\tit = begin(tree);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(score < it->first || (score == it->first && name < it->second)) it--;\\n\\t}\\n\\n\\tstring get(){\\n\\t\\tstring res = it->second;\\n\\t\\tit++;\\n\\t\\treturn res;\\n\\t}\\n};\\n```\n```\\n2. python3\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.vec = SortedList()\\n        self.i = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        score *= -1\\n        self.vec.add((score, name))\\n\\n    def get(self) -> str:\\n        res = self.vec[self.i][1]\\n        self.i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624205,
                "title": "java-simple-and-clean-solution-binary-search",
                "content": "This solution was inspired by [iamss072\\'s solution](https://leetcode.com/problems/sequentially-ordinal-rank-tracker/discuss/1623655/Java-List-Binary-Search)\\n\\nThe idea is keep a sorted list. when we need add new location, just using binary search to find the \\nbest spot to insert it.\\n\\n```java\\nclass SORTracker {\\n  private List<Pair<String, Integer>> list;\\n  private int i = 0;\\n\\n  public SORTracker() {\\n    this.list = new ArrayList<>();\\n  }\\n\\n  public void add(String name, int score) {\\n    Pair<String, Integer> target = new Pair<>(name, score);\\n\\n    // find the index to insert\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n      int m = l + (r - l) / 2;\\n\\t  //\\n\\t  // think it as \\n\\t  // if (list.get(m) <= target) \\n\\t  //\\n      if (compare(list.get(m), target) <= 0) {\\n        l = m + 1;\\n      } else {\\n        r = m;\\n      }\\n    }\\n    // L: less (than target)\\n    // E: equal (...)\\n    // G: greater (...)\\n    // \\n    // after upper bound search, l will at\\n    // \\n    // [L L L L L L E E E E E E G G G G G G]\\n    //                          ^\\n    //                          l\\n    //\\n    // that\\'s the position we want to insert\\n    //\\n    // T: target\\n    // \\n    // [L L L L L L E E E E E E T G G G G G G]\\n    //                          ^\\n    //                          l\\n    //\\n\\n    list.add(l, target);\\n  }\\n\\n  private int compare(Pair<String, Integer> a, Pair<String, Integer> b) {\\n    if (a.getValue().equals(b.getValue())) {\\n      return a.getKey().compareTo(b.getKey());\\n    } else {\\n      return b.getValue() - a.getValue();\\n    }\\n  }\\n\\n  public String get() {\\n    return list.get(i++).getKey();\\n  }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```java\\nclass SORTracker {\\n  private List<Pair<String, Integer>> list;\\n  private int i = 0;\\n\\n  public SORTracker() {\\n    this.list = new ArrayList<>();\\n  }\\n\\n  public void add(String name, int score) {\\n    Pair<String, Integer> target = new Pair<>(name, score);\\n\\n    // find the index to insert\\n    int l = 0, r = list.size();\\n    while (l < r) {\\n      int m = l + (r - l) / 2;\\n\\t  //\\n\\t  // think it as \\n\\t  // if (list.get(m) <= target) \\n\\t  //\\n      if (compare(list.get(m), target) <= 0) {\\n        l = m + 1;\\n      } else {\\n        r = m;\\n      }\\n    }\\n    // L: less (than target)\\n    // E: equal (...)\\n    // G: greater (...)\\n    // \\n    // after upper bound search, l will at\\n    // \\n    // [L L L L L L E E E E E E G G G G G G]\\n    //                          ^\\n    //                          l\\n    //\\n    // that\\'s the position we want to insert\\n    //\\n    // T: target\\n    // \\n    // [L L L L L L E E E E E E T G G G G G G]\\n    //                          ^\\n    //                          l\\n    //\\n\\n    list.add(l, target);\\n  }\\n\\n  private int compare(Pair<String, Integer> a, Pair<String, Integer> b) {\\n    if (a.getValue().equals(b.getValue())) {\\n      return a.getKey().compareTo(b.getKey());\\n    } else {\\n      return b.getValue() - a.getValue();\\n    }\\n  }\\n\\n  public String get() {\\n    return list.get(i++).getKey();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623409,
                "title": "simple-solution-using-python-and-sortedlist",
                "content": "Leetcode\\'s Python installation includes the `sortedcontainers.SortedList` class (which I think is implemented as a balanced tree structure where all nodes keep track of the number of items in them). This class provides O(log(N)) insert and O(log(N)) lookup of the i:th smallest item. The problem becomes extreemly simple using this. I think one can consider this as an easy problem if one knows about `SortedList`.\\n\\nSee inline comments for time complexity:\\n\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.gets = 0\\n        self.locs = SortedList()\\n\\n    def add(self, name: str, score: int) -> None:\\n\\t    # O(log(N)) where N is the number of locations before\\n        self.locs.add((-score, name))\\n\\n    def get(self) -> str:\\n\\t    # O(log(N)) where N is the number of locations\\n        score, name = self.locs[self.gets]\\n        self.gets += 1\\n        return name\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.gets = 0\\n        self.locs = SortedList()\\n\\n    def add(self, name: str, score: int) -> None:\\n\\t    # O(log(N)) where N is the number of locations before\\n        self.locs.add((-score, name))\\n\\n    def get(self) -> str:\\n\\t    # O(log(N)) where N is the number of locations\\n        score, name = self.locs[self.gets]\\n        self.gets += 1\\n        return name\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623348,
                "title": "python3-brute-force",
                "content": "Kinda cheating for Python3 as `insort` is fast enough for such problems. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b553623546e2799477b8bca6b5c89f22c83a4d08) for solutions of weekly 67. \\n\\n```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.k = 0 \\n        self.data = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        insort(self.data, (-score, name))\\n\\n    def get(self) -> str:\\n        self.k += 1\\n        return self.data[self.k-1][1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.k = 0 \\n        self.data = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        insort(self.data, (-score, name))\\n\\n    def get(self) -> str:\\n        self.k += 1\\n        return self.data[self.k-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705685,
                "title": "c-5-lines-of-code-easy-to-understand-2102-sequentially-ordinal-rank-tracker",
                "content": "# C++ | 5 Lines of Code | Easy to Understand | 2102. Sequentially Ordinal Rank Tracker\\n```\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> s;\\n    set<pair<int, string>>::iterator it = end(s);    \\n    void add(string name, int score) {\\n        auto it1 = s.insert({-score, name}).first;\\n        if (it == end(s) || *it1 < *it)\\n            --it;\\n    }\\n    string get() {\\n        return (it++)->second;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> s;\\n    set<pair<int, string>>::iterator it = end(s);    \\n    void add(string name, int score) {\\n        auto it1 = s.insert({-score, name}).first;\\n        if (it == end(s) || *it1 < *it)\\n            --it;\\n    }\\n    string get() {\\n        return (it++)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578629,
                "title": "interviewer-pleaser-solution-log-n-add-log-n-get-well-commented-code",
                "content": "```\\nclass SORTracker {\\n    typedef pair<int , string> p;\\n    class minHeapComparator {\\n        public : \\n        bool operator() (p p1 , p p2) {\\n            \\n            if(p1.first == p2.first) {\\n                return p1.second < p2.second;\\n            }\\n            \\n            return p1.first > p2.first;\\n        }\\n    };\\n    \\n    class maxHeapComparator {\\n        public :\\n        bool operator() (p p1 , p p2) {\\n            \\n            if(p1.first == p2.first) {\\n                return p1.second > p2.second; \\n            }\\n            return p1.first < p2.first;\\n        }\\n    };\\n    \\n    priority_queue<p , vector<p> , maxHeapComparator> maxHeap;\\n    priority_queue<p , vector<p> , minHeapComparator> minHeap;\\n    \\npublic:\\n    \\n    \\n    /*\\n    \\n        I will create a minHeap and a maxHeap\\n        \\n        The min Heap will contain the i largest number of entries  - top will store the ith largest element till now\\n        and the maxheap will contain the remaining number of entries  - max will store the maximum element excluding these values\\n        \\n        \\n        \\n        when the first word comes \\n        my i will be 0 \\n        i stores the number of get calls that i have got till now \\n        \\n        that many amount of entries should be exactly there in the minHeap \\n        \\n        if we see that adding this element will exceed the number of get calls that we have got till now i will push it to maxHeap\\n        \\n    */\\n    \\n    \\n    int i = 0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    \\n    /*\\n    \\n        The main crux of the problem  is that we want the size of the minHeap to be number of get calls that we get . \\n        \\n        That means my minHeap is containing i largest elements and minHeap.top() is having the ith largest element of all the elements we have till now \\n        \\n        \\n    */\\n    \\n    \\n    \\n    \\n    void add(string name, int score) {\\n        \\n        \\n         p x = make_pair(score , name);\\n        if(minHeap.size() == 0) {\\n            \\n            /*\\n                No get has been called till now thus we will keep the minHeap size as zero and keep populating the maxHeap \\n            */\\n            maxHeap.push(x);\\n            return ;\\n        }\\n        \\n        \\n        // at this point i want to maintain my minHeap size = i and not change it \\n        \\n        /*\\n        \\n            So when a new element comes in i will have to check \\n            \\n            if this is a part of the minHeap or the maxHeap\\n            \\n            if the new element lets call it X \\n            \\n            is having higher priority than the minHeap.top() \\n            \\n            -> in that case i need to remove the minHeap.top() to the maxHeap and push this X to the minHeap \\n            \\n            if thats not the case i will simply push the new element to the maxHeap , because \\n            the X has lower priority than current ith largest element \\n        */\\n       \\n        if(isGreater(x , minHeap.top())) {\\n            \\n            \\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n            minHeap.push(x);\\n        }\\n        else\\n        {\\n            maxHeap.push(x);\\n        }\\n    }\\n    \\n    \\n    bool isGreater(p p1 , p p2) {\\n        // this function checks if p1 is higher priority than p2\\n        \\n        if(p1.first == p2.first) {\\n            return p1.second < p2.second; // smaller lexicographical name has higher priority\\n        }\\n        \\n        return p1.first > p2.first ;\\n    }\\n    \\n   \\n    \\n    \\n    /*\\n        Whenever am getting a get call  now my number of calls becomes i++;\\n        my current minHeap\\'s size is now i - 1 , thus i pull the maximum element from the maxHeap and push it to the minHeap \\n        \\n        Now my minHeap\\'s size = i \\n        \\n        Now minHeap.top() is my answer \\n        \\n    */\\n    string get() {\\n       \\n        minHeap.push(maxHeap.top());\\n        maxHeap.pop();\\n       return minHeap.top().second;\\n        \\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker {\\n    typedef pair<int , string> p;\\n    class minHeapComparator {\\n        public : \\n        bool operator() (p p1 , p p2) {\\n            \\n            if(p1.first == p2.first) {\\n                return p1.second < p2.second;\\n            }\\n            \\n            return p1.first > p2.first;\\n        }\\n    };\\n    \\n    class maxHeapComparator {\\n        public :\\n        bool operator() (p p1 , p p2) {\\n            \\n            if(p1.first == p2.first) {\\n                return p1.second > p2.second; \\n            }\\n            return p1.first < p2.first;\\n        }\\n    };\\n    \\n    priority_queue<p , vector<p> , maxHeapComparator> maxHeap;\\n    priority_queue<p , vector<p> , minHeapComparator> minHeap;\\n    \\npublic:\\n    \\n    \\n    /*\\n    \\n        I will create a minHeap and a maxHeap\\n        \\n        The min Heap will contain the i largest number of entries  - top will store the ith largest element till now\\n        and the maxheap will contain the remaining number of entries  - max will store the maximum element excluding these values\\n        \\n        \\n        \\n        when the first word comes \\n        my i will be 0 \\n        i stores the number of get calls that i have got till now \\n        \\n        that many amount of entries should be exactly there in the minHeap \\n        \\n        if we see that adding this element will exceed the number of get calls that we have got till now i will push it to maxHeap\\n        \\n    */\\n    \\n    \\n    int i = 0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    \\n    /*\\n    \\n        The main crux of the problem  is that we want the size of the minHeap to be number of get calls that we get . \\n        \\n        That means my minHeap is containing i largest elements and minHeap.top() is having the ith largest element of all the elements we have till now \\n        \\n        \\n    */\\n    \\n    \\n    \\n    \\n    void add(string name, int score) {\\n        \\n        \\n         p x = make_pair(score , name);\\n        if(minHeap.size() == 0) {\\n            \\n            /*\\n                No get has been called till now thus we will keep the minHeap size as zero and keep populating the maxHeap \\n            */\\n            maxHeap.push(x);\\n            return ;\\n        }\\n        \\n        \\n        // at this point i want to maintain my minHeap size = i and not change it \\n        \\n        /*\\n        \\n            So when a new element comes in i will have to check \\n            \\n            if this is a part of the minHeap or the maxHeap\\n            \\n            if the new element lets call it X \\n            \\n            is having higher priority than the minHeap.top() \\n            \\n            -> in that case i need to remove the minHeap.top() to the maxHeap and push this X to the minHeap \\n            \\n            if thats not the case i will simply push the new element to the maxHeap , because \\n            the X has lower priority than current ith largest element \\n        */\\n       \\n        if(isGreater(x , minHeap.top())) {\\n            \\n            \\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n            minHeap.push(x);\\n        }\\n        else\\n        {\\n            maxHeap.push(x);\\n        }\\n    }\\n    \\n    \\n    bool isGreater(p p1 , p p2) {\\n        // this function checks if p1 is higher priority than p2\\n        \\n        if(p1.first == p2.first) {\\n            return p1.second < p2.second; // smaller lexicographical name has higher priority\\n        }\\n        \\n        return p1.first > p2.first ;\\n    }\\n    \\n   \\n    \\n    \\n    /*\\n        Whenever am getting a get call  now my number of calls becomes i++;\\n        my current minHeap\\'s size is now i - 1 , thus i pull the maximum element from the maxHeap and push it to the minHeap \\n        \\n        Now my minHeap\\'s size = i \\n        \\n        Now minHeap.top() is my answer \\n        \\n    */\\n    string get() {\\n       \\n        minHeap.push(maxHeap.top());\\n        maxHeap.pop();\\n       return minHeap.top().second;\\n        \\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2428932,
                "title": "python3-sortedlist-o-log-n-simple",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.l=SortedList()\\n        self.idx=0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.l.add((-score,name))\\n        \\n    def get(self) -> str:\\n        res=self.l[self.idx][1]\\n        self.idx+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.l=SortedList()\\n        self.idx=0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.l.add((-score,name))\\n        \\n    def get(self) -> str:\\n        res=self.l[self.idx][1]\\n        self.idx+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260794,
                "title": "error-in-hint-n3",
                "content": "According to the multiple posted solutions, when it says \"*The left heap is a max-heap, and the right heap is a min-heap. The size of the left heap is k + 1 (best locations), where k is the number of times the get method was invoked. The other locations are maintained in the right heap.*\". I think it should say \"The left heap is a **min-heap**, and the right heap is a **max-heap** \".\\n\\nThen it makes sense the hint N6: \"we maintain the left heap to have the best k + 2 items by moving the best location from the right heap to the left heap\".",
                "solutionTags": [],
                "code": "According to the multiple posted solutions, when it says \"*The left heap is a max-heap, and the right heap is a min-heap. The size of the left heap is k + 1 (best locations), where k is the number of times the get method was invoked. The other locations are maintained in the right heap.*\". I think it should say \"The left heap is a **min-heap**, and the right heap is a **max-heap** \".\\n\\nThen it makes sense the hint N6: \"we maintain the left heap to have the best k + 2 items by moving the best location from the right heap to the left heap\".",
                "codeTag": "Unknown"
            },
            {
                "id": 2123859,
                "title": "java-using-min-heap-and-max-heap",
                "content": "class SORTracker {\\n\\n    PriorityQueue<Scenic> maxHeap;\\n    PriorityQueue<Scenic> minHeap;\\n    int index;\\n    public SORTracker() {\\n        index = 0;\\n        maxHeap = new PriorityQueue<Scenic>((a,b)->(a.score == b.score? a.name.compareTo(b.name) : b.score - a.score));\\n        minHeap = new PriorityQueue<Scenic>((a,b)->(a.score == b.score? b.name.compareTo(a.name) : a.score - b.score));\\n    }\\n    \\n    public void add(String name, int score) {\\n        Scenic s = new Scenic();\\n        s.name = name;\\n        s.score = score;\\n        minHeap.add(s);\\n        maxHeap.add(minHeap.poll());\\n    }\\n    \\n    public String get() {\\n        Scenic s = maxHeap.poll();\\n        minHeap.add(s);\\n        index++;\\n        return s.name;\\n    }\\n    \\n    public class Scenic{\\n        String name;\\n        int score;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class SORTracker {\\n\\n    PriorityQueue<Scenic> maxHeap;\\n    PriorityQueue<Scenic> minHeap;\\n    int index;\\n    public SORTracker() {\\n        index = 0;\\n        maxHeap = new PriorityQueue<Scenic>((a,b)->(a.score == b.score? a.name.compareTo(b.name) : b.score - a.score));\\n        minHeap = new PriorityQueue<Scenic>((a,b)->(a.score == b.score? b.name.compareTo(a.name) : a.score - b.score));\\n    }\\n    \\n    public void add(String name, int score) {\\n        Scenic s = new Scenic();\\n        s.name = name;\\n        s.score = score;\\n        minHeap.add(s);\\n        maxHeap.add(minHeap.poll());\\n    }\\n    \\n    public String get() {\\n        Scenic s = maxHeap.poll();\\n        minHeap.add(s);\\n        index++;\\n        return s.name;\\n    }\\n    \\n    public class Scenic{\\n        String name;\\n        int score;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1992058,
                "title": "python-two-heaps",
                "content": "Not the fastest solution, but the logic is simple.\\nWe\\'re maintaining two heaps, `heap1` and `heap2`, where \\n- `heap1` keeps the `nth to least` greatest location. Note that it is a max heap ordering by score. If two locations having the same score, the lexicographically smaller one will come first\\n- `heap2` keeps the previous `first to n-1 th` greatest location. Note that `heap2` is a min heap order by score.  If two locations having the same score, the lexicographically greater one will come first\\n\\nWhen adding a new location, test where it is greater than the least greatest location in `heap2`, if so, put this new location in `heap2`, and pop the least greatest location in `heap2` to `heap1`. Otherwise, just put this new location to `heap1`\\n\\nWhen getting the `nth` greatest location, it will simply be the greatest location from `heap1`. To keep the `heap1` and `heap2` logic consistent, we\\'ll need to pop the greatest node from `heap1` and push this node to `heap2`\\n\\nIn terms of implementation, I don\\'t think Python\\'s `heapq` supports customized sorting order easily, so I\\'m defining my own class and put the sorting logic in `__lt__` dunder function. `h1Node` is a basic element in `heap1` and `h2Node` is a basic element in `heap2`\\n\\nTime complexity:\\nO(logn) for `add`\\nO(logn) for `get`\\n\\nSpace complexity:\\nO(n) for keeping two heaps\\n\\n```python\\nclass h1Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n\\n    def __lt__(self, other):\\n        # higher score first\\n        # if same score, lexico smaller first\\n       return self.score > other.score or (self.score == other.score and self.name < other.name)\\n\\n    def to_h2Node(self):\\n        return h2Node(self.name, self.score)\\n\\nclass h2Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        # lower score first\\n        # if same score, lexico greater first\\n        return self.score < other.score or (self.score == other.score and self.name > other.name)\\n\\n    def to_h1Node(self):\\n        return h1Node(self.name, self.score)\\n```\\n\\nHere is my full solution\\n\\n```python\\nclass h1Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n\\n    def __lt__(self, other):\\n        # higher score first\\n        # if same score, lexico smaller first\\n       return self.score > other.score or (self.score == other.score and self.name < other.name)\\n\\n    def to_h2Node(self):\\n        return h2Node(self.name, self.score)\\n\\nclass h2Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        # lower score first\\n        # if same score, lexico greater first\\n        return self.score < other.score or (self.score == other.score and self.name > other.name)\\n\\n    def to_h1Node(self):\\n        return h1Node(self.name, self.score)\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        from heapq import heappush, heappop\\n        self.heap1 = []\\n        self.heap2 = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        h1node = h1Node(name, score)\\n        h2node = h2Node(name, score)\\n        if not self.heap2 or self.heap2[0] > h2node:\\n            heappush(self.heap1, h1node)\\n        else:\\n            heappush(self.heap2, h2node)\\n            node = heappop(self.heap2)\\n            heappush(self.heap1, node.to_h1Node())\\n\\n    def get(self) -> str:\\n        node = heappop(self.heap1)\\n        heappush(self.heap2, node.to_h2Node())\\n        return node.name\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass h1Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n\\n    def __lt__(self, other):\\n        # higher score first\\n        # if same score, lexico smaller first\\n       return self.score > other.score or (self.score == other.score and self.name < other.name)\\n\\n    def to_h2Node(self):\\n        return h2Node(self.name, self.score)\\n\\nclass h2Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        # lower score first\\n        # if same score, lexico greater first\\n        return self.score < other.score or (self.score == other.score and self.name > other.name)\\n\\n    def to_h1Node(self):\\n        return h1Node(self.name, self.score)\\n```\n```python\\nclass h1Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n\\n    def __lt__(self, other):\\n        # higher score first\\n        # if same score, lexico smaller first\\n       return self.score > other.score or (self.score == other.score and self.name < other.name)\\n\\n    def to_h2Node(self):\\n        return h2Node(self.name, self.score)\\n\\nclass h2Node:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    def __lt__(self, other):\\n        # lower score first\\n        # if same score, lexico greater first\\n        return self.score < other.score or (self.score == other.score and self.name > other.name)\\n\\n    def to_h1Node(self):\\n        return h1Node(self.name, self.score)\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        from heapq import heappush, heappop\\n        self.heap1 = []\\n        self.heap2 = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        h1node = h1Node(name, score)\\n        h2node = h2Node(name, score)\\n        if not self.heap2 or self.heap2[0] > h2node:\\n            heappush(self.heap1, h1node)\\n        else:\\n            heappush(self.heap2, h2node)\\n            node = heappop(self.heap2)\\n            heappush(self.heap1, node.to_h1Node())\\n\\n    def get(self) -> str:\\n        node = heappop(self.heap1)\\n        heappush(self.heap2, node.to_h2Node())\\n        return node.name\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984628,
                "title": "c-solution-priorityqueue",
                "content": "```\\npublic class SORTracker {\\n    \\n    private PriorityQueue<string,(int,string)> minHeap; // store locations with large scores\\n    private PriorityQueue<string,(int,string)> maxHeap; // store locations with small scores\\n    public int queryNumber = 1;\\n    \\n    public SORTracker() {\\n        \\n        // For the minHeap, the lexicrographically larger one has less priority if two locations have the same score.\\n        // e.g., if location 1\\'s score = 1, location 2\\'s score = 2, then location 1 should be the min element\\n        // e.g., if location 1a\\'s and 1b\\'s score are the same, then location 1b should be the min element\\n        minHeap = new PriorityQueue<string,(int,string)>(Comparer<(int,string)>.Create((a,b) => a.Item1 == b.Item1? b.Item2.CompareTo(a.Item2) : a.Item1 - b.Item1));\\n        \\n        // top element of maxHeap will be the result of each query\\n        maxHeap = new PriorityQueue<string,(int,string)>(Comparer<(int,string)>.Create((a,b) => a.Item1 == b.Item1? a.Item2.CompareTo(b.Item2) : b.Item1 - a.Item1));\\n    }\\n    \\n    public void Add(string name, int score) {\\n        \\n        minHeap.Enqueue(name,(score,name));\\n        \\n        // secure a spot in minHeap for the result, which is the max element of the maxHeap\\n        while(minHeap.Count >= queryNumber)\\n        {\\n            minHeap.TryDequeue(out string location, out (int,string) priority);\\n            maxHeap.Enqueue(location, (priority.Item1, priority.Item2));\\n        }\\n    }\\n    \\n    public string Get() {\\n        \\n        maxHeap.TryDequeue(out string location, out (int,string) priority);\\n        minHeap.Enqueue(location, (priority.Item1, priority.Item2));\\n        queryNumber++;\\n        return location;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class SORTracker {\\n    \\n    private PriorityQueue<string,(int,string)> minHeap; // store locations with large scores\\n    private PriorityQueue<string,(int,string)> maxHeap; // store locations with small scores\\n    public int queryNumber = 1;\\n    \\n    public SORTracker() {\\n        \\n        // For the minHeap, the lexicrographically larger one has less priority if two locations have the same score.\\n        // e.g., if location 1\\'s score = 1, location 2\\'s score = 2, then location 1 should be the min element\\n        // e.g., if location 1a\\'s and 1b\\'s score are the same, then location 1b should be the min element\\n        minHeap = new PriorityQueue<string,(int,string)>(Comparer<(int,string)>.Create((a,b) => a.Item1 == b.Item1? b.Item2.CompareTo(a.Item2) : a.Item1 - b.Item1));\\n        \\n        // top element of maxHeap will be the result of each query\\n        maxHeap = new PriorityQueue<string,(int,string)>(Comparer<(int,string)>.Create((a,b) => a.Item1 == b.Item1? a.Item2.CompareTo(b.Item2) : b.Item1 - a.Item1));\\n    }\\n    \\n    public void Add(string name, int score) {\\n        \\n        minHeap.Enqueue(name,(score,name));\\n        \\n        // secure a spot in minHeap for the result, which is the max element of the maxHeap\\n        while(minHeap.Count >= queryNumber)\\n        {\\n            minHeap.TryDequeue(out string location, out (int,string) priority);\\n            maxHeap.Enqueue(location, (priority.Item1, priority.Item2));\\n        }\\n    }\\n    \\n    public string Get() {\\n        \\n        maxHeap.TryDequeue(out string location, out (int,string) priority);\\n        minHeap.Enqueue(location, (priority.Item1, priority.Item2));\\n        queryNumber++;\\n        return location;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942474,
                "title": "java-min-max-heap-solution-easy",
                "content": "```\\nclass ScenicLocation {\\n    String name;\\n    int score;\\n    ScenicLocation(String name, int score) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n}\\n\\nclass ScenicLocationMaxComparator implements Comparator<ScenicLocation> {\\n    @Override\\n    public int compare(ScenicLocation s1, ScenicLocation s2) {\\n        if(s1.score == s2.score) {\\n            return s1.name.compareTo(s2.name);\\n        } else {\\n            return Integer.compare(s2.score, s1.score);\\n        }\\n    }\\n}\\n\\n\\nclass ScenicLocationMinComparator implements Comparator<ScenicLocation> {\\n    @Override\\n    public int compare(ScenicLocation s1, ScenicLocation s2) {\\n        if(s1.score == s2.score) {\\n            return s2.name.compareTo(s1.name);\\n        } else {\\n            return Integer.compare(s1.score, s2.score);\\n        }\\n    }\\n}\\n\\nclass SORTracker {\\n    PriorityQueue<ScenicLocation> minHeap, maxHeap;\\n    \\n    public SORTracker() {\\n        minHeap = new PriorityQueue<>(new ScenicLocationMinComparator());\\n        maxHeap = new PriorityQueue<>(new ScenicLocationMaxComparator());\\n    }\\n    \\n    public void add(String name, int score) {\\n        minHeap.offer(new ScenicLocation(name, score));\\n        maxHeap.offer(minHeap.poll());\\n    }\\n    \\n    public String get() {\\n        ScenicLocation sl = maxHeap.poll();\\n        minHeap.offer(sl);\\n        return sl.name;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass ScenicLocation {\\n    String name;\\n    int score;\\n    ScenicLocation(String name, int score) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n}\\n\\nclass ScenicLocationMaxComparator implements Comparator<ScenicLocation> {\\n    @Override\\n    public int compare(ScenicLocation s1, ScenicLocation s2) {\\n        if(s1.score == s2.score) {\\n            return s1.name.compareTo(s2.name);\\n        } else {\\n            return Integer.compare(s2.score, s1.score);\\n        }\\n    }\\n}\\n\\n\\nclass ScenicLocationMinComparator implements Comparator<ScenicLocation> {\\n    @Override\\n    public int compare(ScenicLocation s1, ScenicLocation s2) {\\n        if(s1.score == s2.score) {\\n            return s2.name.compareTo(s1.name);\\n        } else {\\n            return Integer.compare(s1.score, s2.score);\\n        }\\n    }\\n}\\n\\nclass SORTracker {\\n    PriorityQueue<ScenicLocation> minHeap, maxHeap;\\n    \\n    public SORTracker() {\\n        minHeap = new PriorityQueue<>(new ScenicLocationMinComparator());\\n        maxHeap = new PriorityQueue<>(new ScenicLocationMaxComparator());\\n    }\\n    \\n    public void add(String name, int score) {\\n        minHeap.offer(new ScenicLocation(name, score));\\n        maxHeap.offer(minHeap.poll());\\n    }\\n    \\n    public String get() {\\n        ScenicLocation sl = maxHeap.poll();\\n        minHeap.offer(sl);\\n        return sl.name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884240,
                "title": "javascript-simple-priority-queue-100",
                "content": "```\\nlet min\\nlet max\\nlet count\\n\\nvar SORTracker = function() {\\n    count = 0\\n    min = new MinPriorityQueue({compare: (a, b)=> a[0]-b[0] || b[1].localeCompare(a[1]) })    \\n    max = new MaxPriorityQueue({compare: (a, b)=> b[0]-a[0] || a[1].localeCompare(b[1]) })\\n};\\n\\n/** \\n * @param {string} name \\n * @param {number} score\\n * @return {void}\\n */\\nSORTracker.prototype.add = function(name, score) {\\n    min.enqueue([score, name])\\n    max.enqueue(min.dequeue())\\n};\\n\\n/**\\n * @return {string}\\n */\\nSORTracker.prototype.get = function() {\\n    let maxElement = max.dequeue()\\n    min.enqueue(maxElement)\\n    \\n    return maxElement[1]\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nlet min\\nlet max\\nlet count\\n\\nvar SORTracker = function() {\\n    count = 0\\n    min = new MinPriorityQueue({compare: (a, b)=> a[0]-b[0] || b[1].localeCompare(a[1]) })    \\n    max = new MaxPriorityQueue({compare: (a, b)=> b[0]-a[0] || a[1].localeCompare(b[1]) })\\n};\\n\\n/** \\n * @param {string} name \\n * @param {number} score\\n * @return {void}\\n */\\nSORTracker.prototype.add = function(name, score) {\\n    min.enqueue([score, name])\\n    max.enqueue(min.dequeue())\\n};\\n\\n/**\\n * @return {string}\\n */\\nSORTracker.prototype.get = function() {\\n    let maxElement = max.dequeue()\\n    min.enqueue(maxElement)\\n    \\n    return maxElement[1]\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1782967,
                "title": "c-easy-readable-solution",
                "content": "```\\nclass Node{\\npublic:\\n    string name;\\n    int score;\\n    Node(string name, int score){\\n        this->name = name;\\n        this->score = score;\\n    }\\n    bool operator < (const Node &n) const{\\n        if(this->score != n.score) return this->score > n.score;\\n        else return this->name < n.name;\\n    }\\n};\\nclass SORTracker {\\nprivate:\\n    set<Node> s;\\n    set<Node> ::iterator it;\\npublic:\\n    SORTracker() {\\n        ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\\n        it = s.begin();\\n    }\\n    \\n    void add(string name, int score) {\\n        Node node = Node(name, score);\\n        bool insertSuccess = s.insert(node).second;\\n        if(it == s.end() || (insertSuccess && node < *it)) --it;\\n    }\\n    \\n    string get() {\\n        return (*it++).name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Node{\\npublic:\\n    string name;\\n    int score;\\n    Node(string name, int score){\\n        this->name = name;\\n        this->score = score;\\n    }\\n    bool operator < (const Node &n) const{\\n        if(this->score != n.score) return this->score > n.score;\\n        else return this->name < n.name;\\n    }\\n};\\nclass SORTracker {\\nprivate:\\n    set<Node> s;\\n    set<Node> ::iterator it;\\npublic:\\n    SORTracker() {\\n        ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\\n        it = s.begin();\\n    }\\n    \\n    void add(string name, int score) {\\n        Node node = Node(name, score);\\n        bool insertSuccess = s.insert(node).second;\\n        if(it == s.end() || (insertSuccess && node < *it)) --it;\\n    }\\n    \\n    string get() {\\n        return (*it++).name;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1669031,
                "title": "clean-c-two-heaps",
                "content": "```\\nclass Max {\\npublic:\\n    bool operator() (pair<int, string> &p1, pair<int, string> &p2) {\\n        return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n    }\\n};\\nclass Min {\\npublic:\\n    bool operator() (pair<int, string> &p1, pair<int, string> &p2) {\\n        return p1.first == p2.first ? p1.second > p2.second : p1.first < p2.first;\\n    }\\n};\\nclass SORTracker {\\npublic:\\n    int cnt = 0;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Max> minHeap;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Min> maxHeap;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        minHeap.push({score, name});\\n        while (minHeap.size() > cnt) {\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        cnt++;\\n        while (minHeap.size() < cnt) {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        }\\n        return minHeap.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Max {\\npublic:\\n    bool operator() (pair<int, string> &p1, pair<int, string> &p2) {\\n        return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n    }\\n};\\nclass Min {\\npublic:\\n    bool operator() (pair<int, string> &p1, pair<int, string> &p2) {\\n        return p1.first == p2.first ? p1.second > p2.second : p1.first < p2.first;\\n    }\\n};\\nclass SORTracker {\\npublic:\\n    int cnt = 0;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Max> minHeap;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, Min> maxHeap;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        minHeap.push({score, name});\\n        while (minHeap.size() > cnt) {\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        cnt++;\\n        while (minHeap.size() < cnt) {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        }\\n        return minHeap.top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637357,
                "title": "java-splay-tree",
                "content": "```\\nclass SORTracker {\\n    Splay splay;\\n    int k = 0;\\n    int size = 2;\\n    public SORTracker() {\\n        splay = new Splay(100 + 10);\\n        splay.insert(100000000, \"\");\\n        splay.insert(-100000000, \"\");\\n    }\\n    \\n    public void add(String name, int score) {\\n        splay.insert(score, name);\\n        size++;\\n    }\\n    \\n    public String get() {\\n        int kthIdx = splay.kth(size - k - 1);\\n        k++;\\n        return splay.nodes[kthIdx].name;\\n    }\\n}\\n\\nclass Splay{\\n    int N;\\n    int n;\\n    Node nodes[];\\n    int root = 0, idx = 1;\\n    \\n    class Node {\\n        int childs[] = new int[2];\\n        int p = -1; int val = -1;\\n        int size = 1;\\n        int flag = 0;\\n        String name;\\n        public Node(int val, String name, int p) {\\n            this.val = val;\\n            this.name = name;\\n            this.p = p;\\n        }\\n    }\\n\\n    public Splay(int N) {\\n        this.N = N;\\n        nodes = new Node[N];\\n        nodes[0] = new Node(-1, \"\", -1);\\n        nodes[0].size = 0;\\n    }\\n\\n    public void rotate(int x){\\n        int y = nodes[x].p; int z = nodes[y].p;\\n        int k = (nodes[y].childs[1] == x) ? 1 : 0;  // k = 0 x is y\\'s leftchild, k = 1, x is y\\'s rightchild\\n\\n        nodes[z].childs[(nodes[z].childs[1] == y) ? 1 : 0] = x;\\n        nodes[x].p = z;\\n\\n        nodes[y].childs[k] = nodes[x].childs[k ^ 1];\\n        nodes[nodes[x].childs[k ^ 1]].p = y;\\n\\n        nodes[x].childs[k ^ 1] = y;\\n        nodes[y].p = x;\\n\\n        pushup(y);\\n        pushup(x);\\n    }\\n\\n    public void splay(int x, int k){\\n        while(nodes[x].p!=k){\\n            int y = nodes[x].p;\\n            int z = nodes[y].p;\\n            if(z!=k){\\n                int a = (nodes[y].childs[1] == x) ? 1 : 0;\\n                int b = (nodes[z].childs[1] == y) ? 1 : 0;\\n                if ((a^b) != 0) {\\n                    rotate(x);\\n                }\\n                else{\\n                    rotate(y);\\n                }\\n            }\\n            rotate(x);\\n        }\\n\\n        if(k==0){\\n            root = x;\\n        }\\n    }\\n\\n    public void insert(int val, String name){\\n        int u = root, p = 0;\\n        while (u != 0) {\\n            p = u;\\n            u = nodes[u].childs[com(nodes[u], val, name) ? 1 : 0];\\n        }\\n        u = idx++;\\n   \\n        if (p!=0){\\n            nodes[p].childs[com(nodes[p],val, name)? 1 : 0] = u;\\n        }\\n        \\n        if(u >= nodes.length){\\n            resize();\\n        }\\n        \\n        nodes[u] = new Node(val, name, p);\\n        splay(u, 0);\\n    }\\n    \\n    public boolean com(Node node, int otherScore, String otherName) {\\n        if(otherScore > node.val)return true;\\n        if(otherScore < node.val)return false;\\n        if (otherName.compareTo(node.name) > 0) return false;\\n        return true;\\n    }\\n\\n    public int kth(int k) {\\n        int u = root;\\n        while (true) {\\n            if (nodes[nodes[u].childs[0]].size >= k){\\n                u = nodes[u].childs[0];\\n            }\\n            else if (nodes[nodes[u].childs[0]].size + 1 == k){\\n                break;\\n            }\\n            else {\\n                k -= (nodes[nodes[u].childs[0]].size + 1);\\n                u = nodes[u].childs[1];\\n            }\\n        }\\n        return u;\\n    }\\n\\n    public void pushup(int x){\\n        nodes[x].size = 1 + nodes[nodes[x].childs[0]].size + nodes[nodes[x].childs[1]].size;\\n    }\\n\\n    public void pushdown(int x){\\n        //no push down\\n    }\\n    \\n    public void resize(){\\n        Node newnodes[] = new Node[N * 2];\\n        for(int i = 0; i < nodes.length; i++) {\\n            newnodes[i] = nodes[i];\\n        }\\n        N *= 2;\\n        nodes = newnodes;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\n    Splay splay;\\n    int k = 0;\\n    int size = 2;\\n    public SORTracker() {\\n        splay = new Splay(100 + 10);\\n        splay.insert(100000000, \"\");\\n        splay.insert(-100000000, \"\");\\n    }\\n    \\n    public void add(String name, int score) {\\n        splay.insert(score, name);\\n        size++;\\n    }\\n    \\n    public String get() {\\n        int kthIdx = splay.kth(size - k - 1);\\n        k++;\\n        return splay.nodes[kthIdx].name;\\n    }\\n}\\n\\nclass Splay{\\n    int N;\\n    int n;\\n    Node nodes[];\\n    int root = 0, idx = 1;\\n    \\n    class Node {\\n        int childs[] = new int[2];\\n        int p = -1; int val = -1;\\n        int size = 1;\\n        int flag = 0;\\n        String name;\\n        public Node(int val, String name, int p) {\\n            this.val = val;\\n            this.name = name;\\n            this.p = p;\\n        }\\n    }\\n\\n    public Splay(int N) {\\n        this.N = N;\\n        nodes = new Node[N];\\n        nodes[0] = new Node(-1, \"\", -1);\\n        nodes[0].size = 0;\\n    }\\n\\n    public void rotate(int x){\\n        int y = nodes[x].p; int z = nodes[y].p;\\n        int k = (nodes[y].childs[1] == x) ? 1 : 0;  // k = 0 x is y\\'s leftchild, k = 1, x is y\\'s rightchild\\n\\n        nodes[z].childs[(nodes[z].childs[1] == y) ? 1 : 0] = x;\\n        nodes[x].p = z;\\n\\n        nodes[y].childs[k] = nodes[x].childs[k ^ 1];\\n        nodes[nodes[x].childs[k ^ 1]].p = y;\\n\\n        nodes[x].childs[k ^ 1] = y;\\n        nodes[y].p = x;\\n\\n        pushup(y);\\n        pushup(x);\\n    }\\n\\n    public void splay(int x, int k){\\n        while(nodes[x].p!=k){\\n            int y = nodes[x].p;\\n            int z = nodes[y].p;\\n            if(z!=k){\\n                int a = (nodes[y].childs[1] == x) ? 1 : 0;\\n                int b = (nodes[z].childs[1] == y) ? 1 : 0;\\n                if ((a^b) != 0) {\\n                    rotate(x);\\n                }\\n                else{\\n                    rotate(y);\\n                }\\n            }\\n            rotate(x);\\n        }\\n\\n        if(k==0){\\n            root = x;\\n        }\\n    }\\n\\n    public void insert(int val, String name){\\n        int u = root, p = 0;\\n        while (u != 0) {\\n            p = u;\\n            u = nodes[u].childs[com(nodes[u], val, name) ? 1 : 0];\\n        }\\n        u = idx++;\\n   \\n        if (p!=0){\\n            nodes[p].childs[com(nodes[p],val, name)? 1 : 0] = u;\\n        }\\n        \\n        if(u >= nodes.length){\\n            resize();\\n        }\\n        \\n        nodes[u] = new Node(val, name, p);\\n        splay(u, 0);\\n    }\\n    \\n    public boolean com(Node node, int otherScore, String otherName) {\\n        if(otherScore > node.val)return true;\\n        if(otherScore < node.val)return false;\\n        if (otherName.compareTo(node.name) > 0) return false;\\n        return true;\\n    }\\n\\n    public int kth(int k) {\\n        int u = root;\\n        while (true) {\\n            if (nodes[nodes[u].childs[0]].size >= k){\\n                u = nodes[u].childs[0];\\n            }\\n            else if (nodes[nodes[u].childs[0]].size + 1 == k){\\n                break;\\n            }\\n            else {\\n                k -= (nodes[nodes[u].childs[0]].size + 1);\\n                u = nodes[u].childs[1];\\n            }\\n        }\\n        return u;\\n    }\\n\\n    public void pushup(int x){\\n        nodes[x].size = 1 + nodes[nodes[x].childs[0]].size + nodes[nodes[x].childs[1]].size;\\n    }\\n\\n    public void pushdown(int x){\\n        //no push down\\n    }\\n    \\n    public void resize(){\\n        Node newnodes[] = new Node[N * 2];\\n        for(int i = 0; i < nodes.length; i++) {\\n            newnodes[i] = nodes[i];\\n        }\\n        N *= 2;\\n        nodes = newnodes;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625183,
                "title": "c-very-easy-using-ordered-multisets",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<pair<int, string>, null_type, less_equal<pair<int, string>>, rb_tree_tag, tree_order_statistics_node_update> oms;\\n\\nclass SORTracker {\\npublic:\\n    oms s;\\n    int query = 0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        s.insert({score*-1, name});\\n    }\\n    \\n    string get() {\\n        auto it = s.find_by_order(query);\\n        query++;\\n        return (*it).second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<pair<int, string>, null_type, less_equal<pair<int, string>>, rb_tree_tag, tree_order_statistics_node_update> oms;\\n\\nclass SORTracker {\\npublic:\\n    oms s;\\n    int query = 0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        s.insert({score*-1, name});\\n    }\\n    \\n    string get() {\\n        auto it = s.find_by_order(query);\\n        query++;\\n        return (*it).second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1624011,
                "title": "easy-java-solution-with-treemap-binary-search",
                "content": "Easy steps to follow:\\nThis is a double-property sorting problem that needs to rank according to score and then name.\\n\\n1. Use TreeMap to rank the score from big to small.\\n2. Add the name into the propery position within the list of same score. To avoid TLE, use binary search to find the right position to insert (ref: LC35)\\n3. Track count and loop through TreeMap to get the right score and find the position for the result string inside its list.\\n\\n\\n```\\nclass SORTracker {\\n    TreeMap<Integer, List<String>> map;\\n    int count = 0;\\n    public SORTracker() {\\n        map = new TreeMap<>((o1, o2) -> o2 - o1);\\n    }\\n\\n    public void add(String name, int score) {\\n        map.putIfAbsent(score, new ArrayList<>());\\n        List<String> list = map.get(score);\\n        if (list.size() == 0) list.add(name);\\n        else {\\n            int idx = upperBound(list, name);\\n            list.add(idx, name);\\n        }\\n        map.put(score, list);\\n    }\\n\\n    public String get() {\\n        int temp = count;\\n        String res = \"\";\\n        for (int x : map.keySet()) {\\n            if (count < map.get(x).size()) {\\n                res = map.get(x).get(count);\\n                break;\\n            } else count -= map.get(x).size();\\n        }\\n        count = temp + 1;\\n        return res;\\n    }\\n\\n    private int upperBound(List<String> list, String t) {\\n        int left = 0, right = list.size() - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid).compareTo(t) < 0) left = mid + 1;\\n            else right = mid;\\n        }\\n        return list.get(left).compareTo(t) >= 0 ? left : left + 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "Easy steps to follow:\\nThis is a double-property sorting problem that needs to rank according to score and then name.\\n\\n1. Use TreeMap to rank the score from big to small.\\n2. Add the name into the propery position within the list of same score. To avoid TLE, use binary search to find the right position to insert (ref: LC35)\\n3. Track count and loop through TreeMap to get the right score and find the position for the result string inside its list.\\n\\n\\n```\\nclass SORTracker {\\n    TreeMap<Integer, List<String>> map;\\n    int count = 0;\\n    public SORTracker() {\\n        map = new TreeMap<>((o1, o2) -> o2 - o1);\\n    }\\n\\n    public void add(String name, int score) {\\n        map.putIfAbsent(score, new ArrayList<>());\\n        List<String> list = map.get(score);\\n        if (list.size() == 0) list.add(name);\\n        else {\\n            int idx = upperBound(list, name);\\n            list.add(idx, name);\\n        }\\n        map.put(score, list);\\n    }\\n\\n    public String get() {\\n        int temp = count;\\n        String res = \"\";\\n        for (int x : map.keySet()) {\\n            if (count < map.get(x).size()) {\\n                res = map.get(x).get(count);\\n                break;\\n            } else count -= map.get(x).size();\\n        }\\n        count = temp + 1;\\n        return res;\\n    }\\n\\n    private int upperBound(List<String> list, String t) {\\n        int left = 0, right = list.size() - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (list.get(mid).compareTo(t) < 0) left = mid + 1;\\n            else right = mid;\\n        }\\n        return list.get(left).compareTo(t) >= 0 ? left : left + 1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1623960,
                "title": "maxpriorityqueue-minpriorityqueue-javascript-solution-748-ms",
                "content": "```\\nvar SORTracker = function() {\\n    this.count = 0;\\n    this.maxPriorityQueue = new MaxPriorityQueue({\\n        compare: this.maxCompare\\n    });\\n    \\n    this.minPriorityQueue = new MinPriorityQueue({\\n        compare: (e1, e2) => e1.score - e2.score || e2.name.localeCompare(e1.name)\\n    });\\n};\\n\\nSORTracker.prototype.add = function(name, score) {\\n    this.maxPriorityQueue.enqueue({ name: name, score: score });\\n};\\n\\nSORTracker.prototype.get = function() {\\n    if (this.count !== 0) {\\n        this.minPriorityQueue.enqueue(this.maxPriorityQueue.dequeue());\\n        \\n        while (this.maxCompare(this.minPriorityQueue.front(), this.maxPriorityQueue.front()) > 0) {\\n            const tmp = this.minPriorityQueue.dequeue();\\n            this.minPriorityQueue.enqueue(this.maxPriorityQueue.dequeue());\\n            this.maxPriorityQueue.enqueue(tmp);\\n        }\\n    }\\n    \\n    ++this.count;\\n    return this.maxPriorityQueue.front().name;\\n};\\n\\nSORTracker.prototype.maxCompare = (e1, e2) => e2.score - e1.score || e1.name.localeCompare(e2.name);\\n```",
                "solutionTags": [],
                "code": "```\\nvar SORTracker = function() {\\n    this.count = 0;\\n    this.maxPriorityQueue = new MaxPriorityQueue({\\n        compare: this.maxCompare\\n    });\\n    \\n    this.minPriorityQueue = new MinPriorityQueue({\\n        compare: (e1, e2) => e1.score - e2.score || e2.name.localeCompare(e1.name)\\n    });\\n};\\n\\nSORTracker.prototype.add = function(name, score) {\\n    this.maxPriorityQueue.enqueue({ name: name, score: score });\\n};\\n\\nSORTracker.prototype.get = function() {\\n    if (this.count !== 0) {\\n        this.minPriorityQueue.enqueue(this.maxPriorityQueue.dequeue());\\n        \\n        while (this.maxCompare(this.minPriorityQueue.front(), this.maxPriorityQueue.front()) > 0) {\\n            const tmp = this.minPriorityQueue.dequeue();\\n            this.minPriorityQueue.enqueue(this.maxPriorityQueue.dequeue());\\n            this.maxPriorityQueue.enqueue(tmp);\\n        }\\n    }\\n    \\n    ++this.count;\\n    return this.maxPriorityQueue.front().name;\\n};\\n\\nSORTracker.prototype.maxCompare = (e1, e2) => e2.score - e1.score || e1.name.localeCompare(e2.name);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623655,
                "title": "java-list-binary-search",
                "content": "Our idea is to maintain a sorted list and find perfect position to insert while adding using binary search.\\nInserting into list might take O(n) time.\\n```\\nclass SORTracker {\\n    class Object{\\n        int score;\\n        String name;\\n        public Object(int score,String name){\\n            this.score=score;\\n            this.name=name;\\n        }\\n    }\\n    List<Object> arr;\\n    int idx;\\n    public SORTracker() {\\n        arr=new ArrayList<>();\\n        idx=0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        if(arr.size()==0 || arr.get(arr.size()-1).score<score){\\n            arr.add(new Object(score,name));\\n        }\\n        else if(arr.size()==1){\\n            if(arr.get(0).score<score){\\n                arr.add(new Object(score,name));\\n            }\\n            else if(arr.get(0).score==score && arr.get(0).name.compareTo(name)>0){\\n                arr.add(new Object(score,name));\\n            }\\n            else{\\n                arr.add(0,new Object(score,name));\\n            }\\n        }\\n        else{\\n            int lo=0,hi=arr.size()-1;\\n            \\n            while(lo<hi){\\n                int mid=lo+(hi-lo)/2;\\n                \\n                if(arr.get(mid).score<score){\\n                    lo=mid+1;\\n                }\\n                else if(arr.get(mid).score==score && arr.get(mid).name.compareTo(name)>0){\\n                    lo=mid+1;\\n                }\\n                else{\\n                    hi=mid;\\n                }\\n            }\\n            if(arr.get(lo).score==score && arr.get(lo).name.compareTo(name)>0){\\n                arr.add(new Object(score,name));\\n            }\\n            else arr.add(lo,new Object(score,name));\\n        }\\n    }\\n    \\n    public String get() {\\n        idx++;\\n        return arr.get(arr.size()-idx).name;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\n    class Object{\\n        int score;\\n        String name;\\n        public Object(int score,String name){\\n            this.score=score;\\n            this.name=name;\\n        }\\n    }\\n    List<Object> arr;\\n    int idx;\\n    public SORTracker() {\\n        arr=new ArrayList<>();\\n        idx=0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        if(arr.size()==0 || arr.get(arr.size()-1).score<score){\\n            arr.add(new Object(score,name));\\n        }\\n        else if(arr.size()==1){\\n            if(arr.get(0).score<score){\\n                arr.add(new Object(score,name));\\n            }\\n            else if(arr.get(0).score==score && arr.get(0).name.compareTo(name)>0){\\n                arr.add(new Object(score,name));\\n            }\\n            else{\\n                arr.add(0,new Object(score,name));\\n            }\\n        }\\n        else{\\n            int lo=0,hi=arr.size()-1;\\n            \\n            while(lo<hi){\\n                int mid=lo+(hi-lo)/2;\\n                \\n                if(arr.get(mid).score<score){\\n                    lo=mid+1;\\n                }\\n                else if(arr.get(mid).score==score && arr.get(mid).name.compareTo(name)>0){\\n                    lo=mid+1;\\n                }\\n                else{\\n                    hi=mid;\\n                }\\n            }\\n            if(arr.get(lo).score==score && arr.get(lo).name.compareTo(name)>0){\\n                arr.add(new Object(score,name));\\n            }\\n            else arr.add(lo,new Object(score,name));\\n        }\\n    }\\n    \\n    public String get() {\\n        idx++;\\n        return arr.get(arr.size()-idx).name;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1623394,
                "title": "ordered-set-and-gnu-c-pbds",
                "content": "```\\n#include <ext/pb_ds/tree_policy.hpp>\\n#include <ext/pb_ds/assoc_container.hpp> // Common file\\n\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> \\nstruct cmp {\\n    bool operator() (T a, T b) {\\n        return a.first > b.first || (a.first == b.first && a.second < b.second);\\n    }\\n};\\ntemplate <class T> using ordered_set = tree<T, null_type, cmp<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\nclass SORTracker {\\n    unordered_map<string , int> m;\\n    ordered_set <pair<int , string> > tree ;\\n    int index;\\n\\npublic:\\n    SORTracker() {\\n        m.clear();\\n        index = 0;\\n    }\\n\\n    void add(string name, int score) {\\n        tree.erase( tree.find({m[name] , name}) );\\n        tree.insert({score , name });\\n        m[name] = score;\\n    }\\n\\n    string get() {\\n        pair<int , string> ans =  *tree.find_by_order(index);\\n        index++;\\n        return ans.second ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/tree_policy.hpp>\\n#include <ext/pb_ds/assoc_container.hpp> // Common file\\n\\nusing namespace __gnu_pbds;\\n\\ntemplate <class T> \\nstruct cmp {\\n    bool operator() (T a, T b) {\\n        return a.first > b.first || (a.first == b.first && a.second < b.second);\\n    }\\n};\\ntemplate <class T> using ordered_set = tree<T, null_type, cmp<T>, rb_tree_tag, tree_order_statistics_node_update>;\\n\\nclass SORTracker {\\n    unordered_map<string , int> m;\\n    ordered_set <pair<int , string> > tree ;\\n    int index;\\n\\npublic:\\n    SORTracker() {\\n        m.clear();\\n        index = 0;\\n    }\\n\\n    void add(string name, int score) {\\n        tree.erase( tree.find({m[name] , name}) );\\n        tree.insert({score , name });\\n        m[name] = score;\\n    }\\n\\n    string get() {\\n        pair<int , string> ans =  *tree.find_by_order(index);\\n        index++;\\n        return ans.second ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1623284,
                "title": "python-clean-sortedlist",
                "content": "Textbook sorted list. Use a sorted list and keep track of how many times the function is called. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.list = SortedList()\\n        self.calls = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.list.add((-score, name))\\n\\n    def get(self) -> str:\\n        returnLocation = self.list[self.calls][1]\\n        self.calls += 1\\n        return returnLocation\\n```\\n\\nTime Complexity: O(LogN) for add/get\\nSpace Complexity: O(N) for SortedList\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.list = SortedList()\\n        self.calls = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.list.add((-score, name))\\n\\n    def get(self) -> str:\\n        returnLocation = self.list[self.calls][1]\\n        self.calls += 1\\n        return returnLocation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994225,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Location {\\n  string name;\\n  int score;\\n  Location(const string& name, int score) : name(move(name)), score(score) {}\\n};\\n\\nclass SORTracker {\\n public:\\n  void add(const string& name, int score) {\\n    l.emplace(name, score);\\n    if (l.size() > k + 1) {\\n      const Location location = l.top();\\n      l.pop();\\n      r.emplace(location.name, location.score);\\n    }\\n  }\\n\\n  string get() {\\n    const string name = l.top().name;\\n    if (!r.empty()) {\\n      const Location location = r.top();\\n      r.pop();\\n      l.emplace(location.name, location.score);\\n    }\\n    ++k;\\n    return name;\\n  }\\n\\n private:\\n  struct CompareLeftMinHeap {\\n    bool operator()(const Location& a, const Location& b) {\\n      return a.score == b.score ? a.name < b.name : a.score > b.score;\\n    }\\n  };\\n\\n  struct CompareRightMaxHeap {\\n    bool operator()(const Location& a, const Location& b) {\\n      return a.score == b.score ? a.name > b.name : a.score < b.score;\\n    }\\n  };\\n\\n  priority_queue<Location, vector<Location>, CompareLeftMinHeap> l;\\n  priority_queue<Location, vector<Location>, CompareRightMaxHeap> r;\\n  int k = 0;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Location {\\n  string name;\\n  int score;\\n  Location(const string& name, int score) : name(move(name)), score(score) {}\\n};\\n\\nclass SORTracker {\\n public:\\n  void add(const string& name, int score) {\\n    l.emplace(name, score);\\n    if (l.size() > k + 1) {\\n      const Location location = l.top();\\n      l.pop();\\n      r.emplace(location.name, location.score);\\n    }\\n  }\\n\\n  string get() {\\n    const string name = l.top().name;\\n    if (!r.empty()) {\\n      const Location location = r.top();\\n      r.pop();\\n      l.emplace(location.name, location.score);\\n    }\\n    ++k;\\n    return name;\\n  }\\n\\n private:\\n  struct CompareLeftMinHeap {\\n    bool operator()(const Location& a, const Location& b) {\\n      return a.score == b.score ? a.name < b.name : a.score > b.score;\\n    }\\n  };\\n\\n  struct CompareRightMaxHeap {\\n    bool operator()(const Location& a, const Location& b) {\\n      return a.score == b.score ? a.name > b.name : a.score < b.score;\\n    }\\n  };\\n\\n  priority_queue<Location, vector<Location>, CompareLeftMinHeap> l;\\n  priority_queue<Location, vector<Location>, CompareRightMaxHeap> r;\\n  int k = 0;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926930,
                "title": "java-solution-two-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//  TLE\\n\\n/*class SORTracker {\\n\\n    public static class Location{\\n        String name;\\n        int score;\\n\\n        Location(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n\\n    public static class LocationComparator implements Comparator<Location>{\\n        public int compare(Location l1, Location l2){\\n            if(l1.score<l2.score) return 1;\\n            else if(l1.score>l2.score) return -1;\\n            else{\\n                return l1.name.compareTo(l2.name);\\n            }\\n        }\\n    }\\n\\n    \\n    PriorityQueue<Location> pq;\\n    int k;\\n\\n    public SORTracker() {\\n        pq = new PriorityQueue<>(new LocationComparator());\\n        k=1;\\n    }\\n    \\n    public void add(String name, int score) {\\n        pq.add(new Location(name,score));\\n    }\\n    \\n    public String get() {\\n        if(k==1){\\n            k++;\\n            return pq.peek().name;\\n        }else{\\n            Location arr[] = new Location[k-1];\\n\\n            for(int i=0; i<k-1; i++){\\n                arr[i] = pq.remove();\\n            }\\n\\n            String ans = pq.peek().name;\\n\\n            for(int i=0; i<k-1; i++){\\n                pq.add(arr[i]);\\n            }\\n            k++;\\n            return ans;\\n        }\\n    }\\n}  */\\n\\nclass SORTracker {\\n\\n    public static class Node{\\n        String name;\\n        int score;\\n\\n        Node(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n\\n    PriorityQueue<Node> pq;\\n    PriorityQueue<Node> pq1;\\n\\n    public SORTracker() {\\n        pq = new PriorityQueue<>((a, b) -> a.score == b.score ? a.name.compareTo(b.name) : b.score - a.score);\\n        pq1 = new PriorityQueue<>((a, b) -> a.score == b.score ? b.name.compareTo(a.name) : a.score - b.score);\\n    \\n    }\\n\\n    public void add(String name, int score) {\\n        pq1.add(new Node(name, score));\\n        pq.add(pq1.remove());\\n    }\\n\\n    public String get() {\\n        String ans = pq.peek().name;\\n        pq1.add(pq.remove());\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//  TLE\\n\\n/*class SORTracker {\\n\\n    public static class Location{\\n        String name;\\n        int score;\\n\\n        Location(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n\\n    public static class LocationComparator implements Comparator<Location>{\\n        public int compare(Location l1, Location l2){\\n            if(l1.score<l2.score) return 1;\\n            else if(l1.score>l2.score) return -1;\\n            else{\\n                return l1.name.compareTo(l2.name);\\n            }\\n        }\\n    }\\n\\n    \\n    PriorityQueue<Location> pq;\\n    int k;\\n\\n    public SORTracker() {\\n        pq = new PriorityQueue<>(new LocationComparator());\\n        k=1;\\n    }\\n    \\n    public void add(String name, int score) {\\n        pq.add(new Location(name,score));\\n    }\\n    \\n    public String get() {\\n        if(k==1){\\n            k++;\\n            return pq.peek().name;\\n        }else{\\n            Location arr[] = new Location[k-1];\\n\\n            for(int i=0; i<k-1; i++){\\n                arr[i] = pq.remove();\\n            }\\n\\n            String ans = pq.peek().name;\\n\\n            for(int i=0; i<k-1; i++){\\n                pq.add(arr[i]);\\n            }\\n            k++;\\n            return ans;\\n        }\\n    }\\n}  */\\n\\nclass SORTracker {\\n\\n    public static class Node{\\n        String name;\\n        int score;\\n\\n        Node(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n\\n    PriorityQueue<Node> pq;\\n    PriorityQueue<Node> pq1;\\n\\n    public SORTracker() {\\n        pq = new PriorityQueue<>((a, b) -> a.score == b.score ? a.name.compareTo(b.name) : b.score - a.score);\\n        pq1 = new PriorityQueue<>((a, b) -> a.score == b.score ? b.name.compareTo(a.name) : a.score - b.score);\\n    \\n    }\\n\\n    public void add(String name, int score) {\\n        pq1.add(new Node(name, score));\\n        pq.add(pq1.remove());\\n    }\\n\\n    public String get() {\\n        String ans = pq.peek().name;\\n        pq1.add(pq.remove());\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860110,
                "title": "easy-peasy-solution-using-min-and-max-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: n(logn) for push and pop in priority_queue\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)  where n is the number of add() calls\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SORTracker {\\npublic:\\npriority_queue<pair<int,string>>maxHeap;\\npriority_queue<pair<int,string>,vector<pair<int,string>>,greater<pair<int,string>>>minHeap;\\nint current;\\n    SORTracker() {\\n        current=1;\\n    }\\n    \\n    void add(string name, int score) {\\n        if(maxHeap.empty() || maxHeap.top().first>-1*score || (maxHeap.top().first==-1*score && maxHeap.top().second>name)){\\n            maxHeap.push({-1*score,name});\\n        }\\n        else minHeap.push({-1*score,name});\\n        while(maxHeap.size()<current){\\n            auto it = minHeap.top();\\n            minHeap.pop();\\n            maxHeap.push(it);\\n        }\\n        while(maxHeap.size()>current){\\n            auto it = maxHeap.top();\\n            maxHeap.pop();\\n            minHeap.push(it);\\n        }\\n    }\\n    \\n    string get() {\\n        auto it = maxHeap.top();\\n        current++;\\n        while(maxHeap.size()<current && minHeap.size()>0){\\n            auto it = minHeap.top();\\n            minHeap.pop();\\n            maxHeap.push(it);\\n        }\\n        while(maxHeap.size()>current ){\\n            auto it = maxHeap.top();\\n            maxHeap.pop();\\n            minHeap.push(it);\\n        }\\n        return it.second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\npriority_queue<pair<int,string>>maxHeap;\\npriority_queue<pair<int,string>,vector<pair<int,string>>,greater<pair<int,string>>>minHeap;\\nint current;\\n    SORTracker() {\\n        current=1;\\n    }\\n    \\n    void add(string name, int score) {\\n        if(maxHeap.empty() || maxHeap.top().first>-1*score || (maxHeap.top().first==-1*score && maxHeap.top().second>name)){\\n            maxHeap.push({-1*score,name});\\n        }\\n        else minHeap.push({-1*score,name});\\n        while(maxHeap.size()<current){\\n            auto it = minHeap.top();\\n            minHeap.pop();\\n            maxHeap.push(it);\\n        }\\n        while(maxHeap.size()>current){\\n            auto it = maxHeap.top();\\n            maxHeap.pop();\\n            minHeap.push(it);\\n        }\\n    }\\n    \\n    string get() {\\n        auto it = maxHeap.top();\\n        current++;\\n        while(maxHeap.size()<current && minHeap.size()>0){\\n            auto it = minHeap.top();\\n            minHeap.pop();\\n            maxHeap.push(it);\\n        }\\n        while(maxHeap.size()>current ){\\n            auto it = maxHeap.top();\\n            maxHeap.pop();\\n            minHeap.push(it);\\n        }\\n        return it.second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834111,
                "title": "c-priority-queue-solution-maintaining-invariant",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we want to get the location with the best score, priority queue data structure comes to mind to pick the top element. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince each get query, we want to get the location with the kth best score, we can maintain a max heap and minHeap. Max heap will contain k-1 elements smallest elements and min heap will contain the rest of elements. \\n\\nMaintain this invariant: \\nAll elements in max heap must be less than min of minHeap. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAdd: $$O(logn)$$\\nGET: $$O(logn)$$ asymptotically. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass SORTracker {\\npublic:\\n/**\\n\\napproach:  \\n\\nkeep track of the median. while each insertion. keep take care of if it increasing or not . \\n\\nkeep two heaps. max heap and a min heap. \\nmax heap will contain cnt-1 elements. min heap will contain n-cnt elements. \\nall elements in max heap will be less than min of min heap. \\n\\nget will return the result from min heap. it will maintain the invariant, after each get operation. \\n\\n\\n*/\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> minHeap;\\n    priority_queue<pair<int, string>> maxHeap;\\n    int cnt = 0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        minHeap.push({-score, name});\\n        if(!maxHeap.empty() and (maxHeap.top() > minHeap.top())){\\n           minHeap.push(maxHeap.top()); \\n           maxHeap.pop();\\n           maxHeap.push(minHeap.top());\\n           minHeap.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        while(maxHeap.size() < cnt){\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n        string ret = minHeap.top().second;\\n        cnt++;\\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\n/**\\n\\napproach:  \\n\\nkeep track of the median. while each insertion. keep take care of if it increasing or not . \\n\\nkeep two heaps. max heap and a min heap. \\nmax heap will contain cnt-1 elements. min heap will contain n-cnt elements. \\nall elements in max heap will be less than min of min heap. \\n\\nget will return the result from min heap. it will maintain the invariant, after each get operation. \\n\\n\\n*/\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> minHeap;\\n    priority_queue<pair<int, string>> maxHeap;\\n    int cnt = 0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        minHeap.push({-score, name});\\n        if(!maxHeap.empty() and (maxHeap.top() > minHeap.top())){\\n           minHeap.push(maxHeap.top()); \\n           maxHeap.pop();\\n           maxHeap.push(minHeap.top());\\n           minHeap.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        while(maxHeap.size() < cnt){\\n            maxHeap.push(minHeap.top());\\n            minHeap.pop();\\n        }\\n        string ret = minHeap.top().second;\\n        cnt++;\\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791204,
                "title": "rust-two-heaps",
                "content": "# Intuition\\nAs with all problems that require tracking the `i-th` largest number (e.g. median) in a data stream, two heaps is the way to go.\\n\\n# Code\\n```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\nstruct SORTracker {\\n    heap_frnt: BinaryHeap<(Reverse<i32>, String)>,\\n    heap_back: BinaryHeap<(i32, Reverse<String>)>,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        let heap_frnt = BinaryHeap::new();\\n        let heap_back = BinaryHeap::new();\\n\\n        Self { heap_frnt, heap_back }\\n    }\\n    \\n    fn add(&mut self, name: String, score: i32) {\\n        // push to front while keeping its size!!\\n        self.heap_frnt.push((Reverse(score), name));\\n        let (Reverse(score_prev), name_prev) = self.heap_frnt.pop().unwrap();\\n        self.heap_back.push((score_prev, Reverse(name_prev)));\\n    }\\n    \\n    fn get(&mut self) -> String {\\n        let (score, Reverse(name)) = self.heap_back.pop().unwrap();\\n        self.heap_frnt.push((Reverse(score), name.clone()));\\n        name\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::cmp::Reverse;\\n\\nstruct SORTracker {\\n    heap_frnt: BinaryHeap<(Reverse<i32>, String)>,\\n    heap_back: BinaryHeap<(i32, Reverse<String>)>,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        let heap_frnt = BinaryHeap::new();\\n        let heap_back = BinaryHeap::new();\\n\\n        Self { heap_frnt, heap_back }\\n    }\\n    \\n    fn add(&mut self, name: String, score: i32) {\\n        // push to front while keeping its size!!\\n        self.heap_frnt.push((Reverse(score), name));\\n        let (Reverse(score_prev), name_prev) = self.heap_frnt.pop().unwrap();\\n        self.heap_back.push((score_prev, Reverse(name_prev)));\\n    }\\n    \\n    fn get(&mut self) -> String {\\n        let (score, Reverse(name)) = self.heap_back.pop().unwrap();\\n        self.heap_frnt.push((Reverse(score), name.clone()));\\n        name\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683840,
                "title": "highly-intuitive-using-concept-of-median-from-data-stream-two-heaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever we want process stream of data in some order and need to right element from the middle part think about using two heaps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMax heap of size i-1...and min heap contaning the rest of the elemenet...used special comparator function for use.\\n\\n\\n# Complexity\\n- Time complexity: O(Q.logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SORTracker {\\npublic:\\n    class cmp{\\n        public:\\n        bool operator()(pair<int,string> &a, pair<int,string> &b){\\n            if(a.first==b.first) return a.second>b.second;\\n            return a.first<b.first;\\n        }\\n    };\\n    class cmp2{\\n            public:\\n            bool operator()(pair<int,string> &a, pair<int,string> &b){\\n                if(a.first==b.first) return a.second<b.second;\\n                return a.first>b.first;\\n            }\\n    };\\n\\n    priority_queue<pair<int,string>, vector<pair<int, string>> , cmp> pq2;\\n    priority_queue<pair<int,string>, vector<pair<int, string>> , cmp2> pq1;\\n    int i=1;\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        if(!pq1.empty() && pq2.empty()){\\n            pq1.push({score,name});\\n        }else if(!pq2.empty() && ((score==pq2.top().first && name < pq2.top().second)|| (score>pq2.top().first) )){\\n            pq1.push({score,name});\\n        }else{\\n            pq2.push({score,name});\\n        }\\n\\n        if(pq1.size()==i){\\n            pq2.push(pq1.top());\\n            pq1.pop();\\n        }\\n\\n    }\\n    \\n    string get() {\\n        string ans= pq2.top().second;\\n        pq1.push(pq2.top());\\n        pq2.pop();\\n        i++;\\n        if(pq1.size()==i){\\n            pq2.push(pq1.top());\\n            pq1.pop();\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\n    class cmp{\\n        public:\\n        bool operator()(pair<int,string> &a, pair<int,string> &b){\\n            if(a.first==b.first) return a.second>b.second;\\n            return a.first<b.first;\\n        }\\n    };\\n    class cmp2{\\n            public:\\n            bool operator()(pair<int,string> &a, pair<int,string> &b){\\n                if(a.first==b.first) return a.second<b.second;\\n                return a.first>b.first;\\n            }\\n    };\\n\\n    priority_queue<pair<int,string>, vector<pair<int, string>> , cmp> pq2;\\n    priority_queue<pair<int,string>, vector<pair<int, string>> , cmp2> pq1;\\n    int i=1;\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        if(!pq1.empty() && pq2.empty()){\\n            pq1.push({score,name});\\n        }else if(!pq2.empty() && ((score==pq2.top().first && name < pq2.top().second)|| (score>pq2.top().first) )){\\n            pq1.push({score,name});\\n        }else{\\n            pq2.push({score,name});\\n        }\\n\\n        if(pq1.size()==i){\\n            pq2.push(pq1.top());\\n            pq1.pop();\\n        }\\n\\n    }\\n    \\n    string get() {\\n        string ans= pq2.top().second;\\n        pq1.push(pq2.top());\\n        pq2.pop();\\n        i++;\\n        if(pq1.size()==i){\\n            pq2.push(pq1.top());\\n            pq1.pop();\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673443,
                "title": "sortedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.arr=SortedList()\\n        self.index=-1\\n    def add(self, name: str, score: int) -> None:\\n        self.arr.add([-score,name])\\n        \\n    def get(self) -> str:\\n       \\n        self.index+=1\\n        return self.arr[self.index][1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.arr=SortedList()\\n        self.index=-1\\n    def add(self, name: str, score: int) -> None:\\n        self.arr.add([-score,name])\\n        \\n    def get(self) -> str:\\n       \\n        self.index+=1\\n        return self.arr[self.index][1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643626,
                "title": "ignore-the-hints-detailed-explanation-included-c-soln-beats-100-two-heaps",
                "content": "``` \\n#define MAX_HEAP (100000)   \\n\\n/*The intuition is to always add the new location to the left heap and \"dump\" it in the right heap every time get() is \\ncalled. This allows us to maintain that the right heap has the i best locations. Moreover, since the right heap is a min heap and the left heap is a max heap, the top of the right heap should represent i best location while the top of the left heap represents the i+1 best location.  \\n\\nObserve that this problem is akin to the find the median of a data stream of integers problem, the main difference being we would like to maintain the the right heap to have the i best locations and the earliest queries (or inputs) to the stream begin at the bottom of the right heap. This trait enables us to have O(1) access to the i and i+1 best locations, which are necessary for our queries.  \\n\\nThe get() function is trivial in that we simply increase the number of queries i, poll the left heap and return. \\n\\nThe add function would be trivial, but we must account for the fact that we can add a location that has a greater ranking than the top of the right heap (the i best location). To do this, we still add the new location to the left heap, but we also compare the left heap peak with the right heap peak. If left peak < right peak then we know the location added need not is assuredly less than the i best location (head of right peak) and we need not do any more processing. If we see left peak > right peak then we know the location we just added (note we are still in the add function) is a new best location in the 1-i range (meaning it belongs in the right heap). Thus, we poll both heap heads and interpolate those values (right to left, left to right), essentially making the former i best location be the i+1 best location and the newly added value is sorted into it\\'s proper place in the heap \\n\\nIn so many words, the algorithm is using a max heap to consistently get the next best location, using a right heap to contain the best locations up to the current one (i) and shifting the stream of locations to make the next best location the current one, if a higher ranked location is added \\n\\nAs an elementary programmer, I think an algorithm like this could be very useful for applications that rely on finding a best-fit of some object (places, people, food) \\nUpvote if the explanation helped! \\ncheers*/\\n\\nstruct heap;\\n\\ntypedef struct { \\n    int score; \\n    char *name;\\n} Location ;\\n\\ntypedef struct {\\n    struct heap *l; \\n    struct heap *r; \\n    int i;\\n} SORTracker; \\n\\ntypedef struct heap { \\n    Location **root; \\n    int size; \\n    short (*comparator)(Location* a, Location* b);\\n    int end; /*always points to first open spot*/\\n} Heap;  \\n\\nHeap *heap_create(int mode); \\nshort min_comparator(Location* val1, Location* val2); \\nshort max_comparator(Location* val1, Location* val2); \\nshort insert(Heap *h, Location* val, short (*comp)(Location* a, Location* b)); \\nLocation* deletion(Heap *, short (*comp)(Location* a, Location* b)); \\nshort push(Heap *, Location* val); \\nLocation* poll(Heap *);  \\nLocation *location_create(int score, char *name);\\n\\n\\nLocation *location_create(int score, char *name) { \\n    Location *node = malloc(sizeof(Location)); \\n    node->score = score; \\n    node->name = malloc(strlen(name)+1); \\n    strcpy(node->name,name); \\n    return node;\\n}\\n\\nHeap *heap_create(int mode) { \\n    Heap *heap = malloc(sizeof(Heap)); \\n    heap->root = calloc(sizeof(Location *), MAX_HEAP);  \\n    memset(heap->root,0,sizeof(heap->root));\\n    heap->size = 0; \\n    heap->end = 0;  \\n    heap->comparator = !mode ? min_comparator : max_comparator;\\n    return heap;\\n}  \\n\\nshort min_comparator(Location* val1, Location* val2) { /*ret -1 if val1 less than val2, 1 greater, 0 if equal*/  \\n    return val1->score == val2->score ?  -1*strcmp(val1->name,val2->name) : (val1->score > val2->score ? 1 : -1);\\n} \\n\\nshort max_comparator(Location* val1, Location* val2) { /*ret 1 if val1 less than val2, -1 greater, 0 if equal*/\\n    return -1*(val1->score == val2->score ?  -1*strcmp(val1->name,val2->name) : (val1->score > val2->score ? 1 : -1));\\n} \\n\\nshort insert(Heap *h, Location *val, short (*comp)(Location* a, Location* b)) { \\n    if(h->size >= MAX_HEAP)\\n        return 0; \\n    \\n    Location **heap = h->root;  \\n    int curr = (h->end)++; \\n    int par = (curr-1)/2;\\n    heap[curr] = val; \\n    \\n    while(par>=0 && comp(heap[curr],heap[par]) == -1) {  \\n        Location* tmp = heap[par]; \\n        heap[par] = heap[curr]; \\n        heap[curr] = tmp;  \\n        \\n        curr = par;\\n        par = (curr-1)/2;\\n    } \\n    \\n    (h->size)++;\\n    return 1;\\n} \\n\\nLocation* deletion(Heap *h, short (*comp)(Location* a, Location* b)) {  \\n    assert(h != NULL);\\n    Location **heap = h->root; \\n    int last = (h->end)-1; \\n    int curr = 0;   \\n    int left = 2*curr+1; \\n    int right = 2*curr+2; \\n    Location* head = heap[0]; \\n    \\n    heap[curr] = heap[last]; \\n    \\n    while(right <= last && (comp(heap[curr],heap[left]) == 1 ||  \\n           comp(heap[curr],heap[right]) == 1)) {  \\n        \\n        int swap = 0;  \\n        \\n        if(comp(heap[curr],heap[left]) == 1 && comp(heap[curr],heap[right]) == 1)   \\n            swap = comp(heap[left],heap[right]) == -1 ? left : right; \\n        \\n        else if(comp(heap[curr],heap[left]) == 1)  \\n            swap = left;  \\n        \\n        else  \\n            swap = right;   \\n        \\n        Location* tmp = heap[swap]; \\n        heap[swap] = heap[curr]; \\n        heap[curr] = tmp;\\n        \\n        curr = swap;\\n        left = 2*curr+1; \\n        right = 2*curr+2;\\n    } \\n    \\n    (h->end)--; \\n    (h->size)--;\\n    return head;\\n} \\n\\nshort push(Heap *heap, Location *val) { /*0 for min, 1 for max*/\\n    return !heap || !val ? 0 : insert(heap,val,heap->comparator);\\n}\\n\\nLocation* poll(Heap *heap) {  /*0 for min, 1 for max */ \\n    assert(heap != NULL);\\n    return deletion(heap,heap->comparator);  \\n} \\n\\nLocation* peek(Heap *heap) { \\n    return (heap->root)[0];\\n}\\n\\n\\nSORTracker* sORTrackerCreate() { \\n    SORTracker *sort = malloc(sizeof(SORTracker)); \\n    sort->l = heap_create(1); \\n    sort->r = heap_create(0);\\n    sort->i = 0; \\n    return sort;\\n}\\n\\nvoid sORTrackerAdd(SORTracker* obj, char *name, int score) { \\n    if(!obj) \\n        return; \\n    Heap *l = obj->l; \\n    Heap *r = obj->r; \\n    Location *location = location_create(score, name); \\n    \\n    push(l,location);  \\n    \\n    if(obj->i>0) {  \\n        if(min_comparator(peek(l),peek(r)) == 1) { \\n            Location *max_peak = poll(l); \\n            Location *min_peak = poll(r); \\n            push(r,max_peak); \\n            push(l,min_peak);\\n        }\\n    } \\n    return;\\n}\\n\\nchar *sORTrackerGet(SORTracker* obj) { \\n    if(!obj) \\n        return NULL;   \\n    \\n    (obj->i)++;\\n    Location *location = poll(obj->l);  \\n    push(obj->r, location); \\n    \\n    return location->name;\\n}\\n\\nvoid sORTrackerFree(SORTracker* obj) {\\n    \\n}\\n\\n/**\\n * Your SORTracker struct will be instantiated and called as such:\\n * SORTracker* obj = sORTrackerCreate();\\n * sORTrackerAdd(obj, name, score);\\n \\n \\n * char * param_2 = sORTrackerGet(obj);\\n \\n * sORTrackerFree(obj);\\n*/",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "``` \\n#define MAX_HEAP (100000)   \\n\\n/*The intuition is to always add the new location to the left heap and \"dump\" it in the right heap every time get() is \\ncalled. This allows us to maintain that the right heap has the i best locations. Moreover, since the right heap is a min heap and the left heap is a max heap, the top of the right heap should represent i best location while the top of the left heap represents the i+1 best location.  \\n\\nObserve that this problem is akin to the find the median of a data stream of integers problem, the main difference being we would like to maintain the the right heap to have the i best locations and the earliest queries (or inputs) to the stream begin at the bottom of the right heap. This trait enables us to have O(1) access to the i and i+1 best locations, which are necessary for our queries.  \\n\\nThe get() function is trivial in that we simply increase the number of queries i, poll the left heap and return. \\n\\nThe add function would be trivial, but we must account for the fact that we can add a location that has a greater ranking than the top of the right heap (the i best location). To do this, we still add the new location to the left heap, but we also compare the left heap peak with the right heap peak. If left peak < right peak then we know the location added need not is assuredly less than the i best location (head of right peak) and we need not do any more processing. If we see left peak > right peak then we know the location we just added (note we are still in the add function) is a new best location in the 1-i range (meaning it belongs in the right heap). Thus, we poll both heap heads and interpolate those values (right to left, left to right), essentially making the former i best location be the i+1 best location and the newly added value is sorted into it\\'s proper place in the heap \\n\\nIn so many words, the algorithm is using a max heap to consistently get the next best location, using a right heap to contain the best locations up to the current one (i) and shifting the stream of locations to make the next best location the current one, if a higher ranked location is added \\n\\nAs an elementary programmer, I think an algorithm like this could be very useful for applications that rely on finding a best-fit of some object (places, people, food) \\nUpvote if the explanation helped! \\ncheers*/\\n\\nstruct heap;\\n\\ntypedef struct { \\n    int score; \\n    char *name;\\n} Location ;\\n\\ntypedef struct {\\n    struct heap *l; \\n    struct heap *r; \\n    int i;\\n} SORTracker; \\n\\ntypedef struct heap { \\n    Location **root; \\n    int size; \\n    short (*comparator)(Location* a, Location* b);\\n    int end; /*always points to first open spot*/\\n} Heap;  \\n\\nHeap *heap_create(int mode); \\nshort min_comparator(Location* val1, Location* val2); \\nshort max_comparator(Location* val1, Location* val2); \\nshort insert(Heap *h, Location* val, short (*comp)(Location* a, Location* b)); \\nLocation* deletion(Heap *, short (*comp)(Location* a, Location* b)); \\nshort push(Heap *, Location* val); \\nLocation* poll(Heap *);  \\nLocation *location_create(int score, char *name);\\n\\n\\nLocation *location_create(int score, char *name) { \\n    Location *node = malloc(sizeof(Location)); \\n    node->score = score; \\n    node->name = malloc(strlen(name)+1); \\n    strcpy(node->name,name); \\n    return node;\\n}\\n\\nHeap *heap_create(int mode) { \\n    Heap *heap = malloc(sizeof(Heap)); \\n    heap->root = calloc(sizeof(Location *), MAX_HEAP);  \\n    memset(heap->root,0,sizeof(heap->root));\\n    heap->size = 0; \\n    heap->end = 0;  \\n    heap->comparator = !mode ? min_comparator : max_comparator;\\n    return heap;\\n}  \\n\\nshort min_comparator(Location* val1, Location* val2) { /*ret -1 if val1 less than val2, 1 greater, 0 if equal*/  \\n    return val1->score == val2->score ?  -1*strcmp(val1->name,val2->name) : (val1->score > val2->score ? 1 : -1);\\n} \\n\\nshort max_comparator(Location* val1, Location* val2) { /*ret 1 if val1 less than val2, -1 greater, 0 if equal*/\\n    return -1*(val1->score == val2->score ?  -1*strcmp(val1->name,val2->name) : (val1->score > val2->score ? 1 : -1));\\n} \\n\\nshort insert(Heap *h, Location *val, short (*comp)(Location* a, Location* b)) { \\n    if(h->size >= MAX_HEAP)\\n        return 0; \\n    \\n    Location **heap = h->root;  \\n    int curr = (h->end)++; \\n    int par = (curr-1)/2;\\n    heap[curr] = val; \\n    \\n    while(par>=0 && comp(heap[curr],heap[par]) == -1) {  \\n        Location* tmp = heap[par]; \\n        heap[par] = heap[curr]; \\n        heap[curr] = tmp;  \\n        \\n        curr = par;\\n        par = (curr-1)/2;\\n    } \\n    \\n    (h->size)++;\\n    return 1;\\n} \\n\\nLocation* deletion(Heap *h, short (*comp)(Location* a, Location* b)) {  \\n    assert(h != NULL);\\n    Location **heap = h->root; \\n    int last = (h->end)-1; \\n    int curr = 0;   \\n    int left = 2*curr+1; \\n    int right = 2*curr+2; \\n    Location* head = heap[0]; \\n    \\n    heap[curr] = heap[last]; \\n    \\n    while(right <= last && (comp(heap[curr],heap[left]) == 1 ||  \\n           comp(heap[curr],heap[right]) == 1)) {  \\n        \\n        int swap = 0;  \\n        \\n        if(comp(heap[curr],heap[left]) == 1 && comp(heap[curr],heap[right]) == 1)   \\n            swap = comp(heap[left],heap[right]) == -1 ? left : right; \\n        \\n        else if(comp(heap[curr],heap[left]) == 1)  \\n            swap = left;  \\n        \\n        else  \\n            swap = right;   \\n        \\n        Location* tmp = heap[swap]; \\n        heap[swap] = heap[curr]; \\n        heap[curr] = tmp;\\n        \\n        curr = swap;\\n        left = 2*curr+1; \\n        right = 2*curr+2;\\n    } \\n    \\n    (h->end)--; \\n    (h->size)--;\\n    return head;\\n} \\n\\nshort push(Heap *heap, Location *val) { /*0 for min, 1 for max*/\\n    return !heap || !val ? 0 : insert(heap,val,heap->comparator);\\n}\\n\\nLocation* poll(Heap *heap) {  /*0 for min, 1 for max */ \\n    assert(heap != NULL);\\n    return deletion(heap,heap->comparator);  \\n} \\n\\nLocation* peek(Heap *heap) { \\n    return (heap->root)[0];\\n}\\n\\n\\nSORTracker* sORTrackerCreate() { \\n    SORTracker *sort = malloc(sizeof(SORTracker)); \\n    sort->l = heap_create(1); \\n    sort->r = heap_create(0);\\n    sort->i = 0; \\n    return sort;\\n}\\n\\nvoid sORTrackerAdd(SORTracker* obj, char *name, int score) { \\n    if(!obj) \\n        return; \\n    Heap *l = obj->l; \\n    Heap *r = obj->r; \\n    Location *location = location_create(score, name); \\n    \\n    push(l,location);  \\n    \\n    if(obj->i>0) {  \\n        if(min_comparator(peek(l),peek(r)) == 1) { \\n            Location *max_peak = poll(l); \\n            Location *min_peak = poll(r); \\n            push(r,max_peak); \\n            push(l,min_peak);\\n        }\\n    } \\n    return;\\n}\\n\\nchar *sORTrackerGet(SORTracker* obj) { \\n    if(!obj) \\n        return NULL;   \\n    \\n    (obj->i)++;\\n    Location *location = poll(obj->l);  \\n    push(obj->r, location); \\n    \\n    return location->name;\\n}\\n\\nvoid sORTrackerFree(SORTracker* obj) {\\n    \\n}\\n\\n/**\\n * Your SORTracker struct will be instantiated and called as such:\\n * SORTracker* obj = sORTrackerCreate();\\n * sORTrackerAdd(obj, name, score);\\n \\n \\n * char * param_2 = sORTrackerGet(obj);\\n \\n * sORTrackerFree(obj);\\n*/",
                "codeTag": "Python3"
            },
            {
                "id": 3642054,
                "title": "swift-100-faster-sortedarray",
                "content": "```\\nstruct Location: Comparable {\\n    let name: String\\n    let score: Int\\n    static func < (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.score, lhs.name) < (rhs.score, rhs.name)\\n    }\\n} \\n\\nclass SORTracker {\\n    var i: Int\\n    var locations: [Location]\\n    init() {\\n        i = 0\\n        locations = []\\n    }\\n    \\n    func add(_ name: String, _ score: Int) {\\n        locations.insort(Location(name: name, score: -score))\\n    }\\n    \\n    func get() -> String {\\n        defer { i += 1 }\\n        return locations[i].name\\n    }\\n}\\n\\nextension Array where Element: Comparable {\\n    mutating func insort(_ item: Element) {\\n        let i = bisectLeft(item)\\n        self.insert(item, at: i)\\n    }\\n    func bisectLeft(_ target: Element) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if self[mid] < target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nstruct Location: Comparable {\\n    let name: String\\n    let score: Int\\n    static func < (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.score, lhs.name) < (rhs.score, rhs.name)\\n    }\\n} \\n\\nclass SORTracker {\\n    var i: Int\\n    var locations: [Location]\\n    init() {\\n        i = 0\\n        locations = []\\n    }\\n    \\n    func add(_ name: String, _ score: Int) {\\n        locations.insort(Location(name: name, score: -score))\\n    }\\n    \\n    func get() -> String {\\n        defer { i += 1 }\\n        return locations[i].name\\n    }\\n}\\n\\nextension Array where Element: Comparable {\\n    mutating func insort(_ item: Element) {\\n        let i = bisectLeft(item)\\n        self.insert(item, at: i)\\n    }\\n    func bisectLeft(_ target: Element) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if self[mid] < target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641992,
                "title": "short-python-faster-than-80-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.scores = SortedList()\\n        self.i = 0\\n\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.scores.add((-score, name))\\n\\n    def get(self) -> str:\\n        self.i += 1\\n        return self.scores[self.i - 1][1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.scores = SortedList()\\n        self.i = 0\\n\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.scores.add((-score, name))\\n\\n    def get(self) -> str:\\n        self.i += 1\\n        return self.scores[self.i - 1][1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555798,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::BinaryHeap;\\n\\nuse std::cmp::Reverse;\\n\\nstruct SORTracker {\\n    max: BinaryHeap<(i32, Reverse<String>)>,\\n    min: BinaryHeap<Reverse<(i32, Reverse<String>)>>,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        Self {\\n            max: BinaryHeap::new(),\\n            min: BinaryHeap::new(),\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        self.min.push(Reverse((score, Reverse(name))));\\n\\n        let (v, s) = self.min.pop().unwrap().0;\\n        self.max.push((v, s));\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let (v, s) = self.max.pop().unwrap();\\n        self.min.push(Reverse((v, s.clone())));\\n        s.0\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\n\\nuse std::cmp::Reverse;\\n\\nstruct SORTracker {\\n    max: BinaryHeap<(i32, Reverse<String>)>,\\n    min: BinaryHeap<Reverse<(i32, Reverse<String>)>>,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        Self {\\n            max: BinaryHeap::new(),\\n            min: BinaryHeap::new(),\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        self.min.push(Reverse((score, Reverse(name))));\\n\\n        let (v, s) = self.min.pop().unwrap().0;\\n        self.max.push((v, s));\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let (v, s) = self.max.pop().unwrap();\\n        self.min.push(Reverse((v, s.clone())));\\n        s.0\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524997,
                "title": "c-increase-decrease-iterator",
                "content": "- use `std::set` to keep ordered data\\n- keep/update current iterator to return for next `get()`\\n- use sentinel to avoid edge case\\n```\\nclass SORTracker {\\n    set<pair<int, string>> scorename { {INT_MAX, \"\"} };       // ordered pair(score, name)\\n    set<pair<int, string>>::iterator itr = scorename.begin(); // cur choice to return for next get()\\npublic:\\n    void add(string name, int score) {\\n        if(auto p = scorename.emplace(-score, name); *p.first < *itr) // inserted before\\n            --itr;\\n    }\\n    \\n    string get() {\\n        return itr++->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SORTracker {\\n    set<pair<int, string>> scorename { {INT_MAX, \"\"} };       // ordered pair(score, name)\\n    set<pair<int, string>>::iterator itr = scorename.begin(); // cur choice to return for next get()\\npublic:\\n    void add(string name, int score) {\\n        if(auto p = scorename.emplace(-score, name); *p.first < *itr) // inserted before\\n            --itr;\\n    }\\n    \\n    string get() {\\n        return itr++->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511419,
                "title": "c-two-set",
                "content": "```\\n\\nstruct Scene {\\n    int score;\\n    string name;\\n    bool operator<(const Scene &y) const\\n    {\\n        if (score == y.score) return name < y.name;\\n        return score > y.score;\\n    }\\n    \\n};\\n\\nbool cmp(const Scene &x, const Scene &y) \\n{\\n    if (x.score == y.score) return x.name < y.name;\\n    return x.score > y.score;\\n}\\n\\n\\nclass SORTracker {\\n\\npublic:\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        st2.insert({score, name});\\n        if (st1.size())\\n        {\\n            auto t1 = *st1.rbegin();\\n            auto t2 = *st2.begin();\\n            if (!cmp(t1, t2))\\n            {\\n                st1.insert(t2);\\n                st2.insert(t1);\\n                st1.erase(st1.find(t1));\\n                st2.erase(st2.find(t2));\\n            }\\n        }\\n    }\\n    \\n    string get() {\\n        qcnt ++ ;\\n        while (st1.size() < qcnt)\\n        {\\n            auto t2 = *st2.begin();\\n            st1.insert(t2);    \\n            st2.erase(st2.find(t2));\\n        }\\n        return st1.rbegin()->name;\\n    }\\n    \\n    set<Scene> st1, st2;\\n    int qcnt = 0;\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct Scene {\\n    int score;\\n    string name;\\n    bool operator<(const Scene &y) const\\n    {\\n        if (score == y.score) return name < y.name;\\n        return score > y.score;\\n    }\\n    \\n};\\n\\nbool cmp(const Scene &x, const Scene &y) \\n{\\n    if (x.score == y.score) return x.name < y.name;\\n    return x.score > y.score;\\n}\\n\\n\\nclass SORTracker {\\n\\npublic:\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        st2.insert({score, name});\\n        if (st1.size())\\n        {\\n            auto t1 = *st1.rbegin();\\n            auto t2 = *st2.begin();\\n            if (!cmp(t1, t2))\\n            {\\n                st1.insert(t2);\\n                st2.insert(t1);\\n                st1.erase(st1.find(t1));\\n                st2.erase(st2.find(t2));\\n            }\\n        }\\n    }\\n    \\n    string get() {\\n        qcnt ++ ;\\n        while (st1.size() < qcnt)\\n        {\\n            auto t2 = *st2.begin();\\n            st1.insert(t2);    \\n            st2.erase(st2.find(t2));\\n        }\\n        return st1.rbegin()->name;\\n    }\\n    \\n    set<Scene> st1, st2;\\n    int qcnt = 0;\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511236,
                "title": "python-solution-use-binary-search-and-directly-insertion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncustomise Scenic object let bisect lib can compare each items:\\n```\\nclass Scenic:\\n    def __init__(self,name,score):\\n        self._name,self._score=name,score\\n    def __lt__(self,s):\\n        return self._score<s._score if self._score!=s._score else self._name<s._name\\n```\\n\\nuse binary search find right-place for new item and insert at it\\nkeep track k:every time get() called,just return the kth ith and increment 1\\n\\ncomplexity: time O(n*logn) (as insertion may case mem allocation and copy,this time may be O(n))\\nspace O(n)\\n\\n\\n# Code\\n```\\nclass Scenic:\\n    def __init__(self,name,score):\\n        self._name,self._score=name,score\\n    def __lt__(self,s):\\n        return self._score<s._score if self._score!=s._score else self._name<s._name\\n\\nclass SORTracker(object):\\n    def __init__(self):\\n        self._scoreToScentics,self._k=[],0\\n\\n    def add(self, name, score):\\n        \"\"\"\\n        :type name: str\\n        :type score: int\\n        :rtype: None\\n        \"\"\"\\n        bisect.insort_right(self._scoreToScentics,Scenic(name,-score))\\n\\n    def get(self):\\n        \"\"\"\\n        :rtype: str\\n        \"\"\"\\n        self._k=self._k+1\\n        return self._scoreToScentics[self._k-1]._name\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Scenic:\\n    def __init__(self,name,score):\\n        self._name,self._score=name,score\\n    def __lt__(self,s):\\n        return self._score<s._score if self._score!=s._score else self._name<s._name\\n```\n```\\nclass Scenic:\\n    def __init__(self,name,score):\\n        self._name,self._score=name,score\\n    def __lt__(self,s):\\n        return self._score<s._score if self._score!=s._score else self._name<s._name\\n\\nclass SORTracker(object):\\n    def __init__(self):\\n        self._scoreToScentics,self._k=[],0\\n\\n    def add(self, name, score):\\n        \"\"\"\\n        :type name: str\\n        :type score: int\\n        :rtype: None\\n        \"\"\"\\n        bisect.insort_right(self._scoreToScentics,Scenic(name,-score))\\n\\n    def get(self):\\n        \"\"\"\\n        :rtype: str\\n        \"\"\"\\n        self._k=self._k+1\\n        return self._scoreToScentics[self._k-1]._name\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502632,
                "title": "c-easy-to-understand-two-heaps",
                "content": "```\\nstruct maxHeapComp{\\n    // return true if you want to switch their position and make new_element as the top element\\n    bool operator()(pair<string, int>& top_element, pair<string, int>& new_element) {\\n        if (new_element.second < top_element.second) return false;\\n        else if(new_element.second > top_element.second) return true;\\n        else return new_element.first < top_element.first;\\n    }\\n};\\n\\nstruct minHeapComp{\\n    // return true if you want to switch their position and make new_element as the top element\\n    bool operator()(pair<string, int>& top_element, pair<string, int>& new_element) {\\n        if (new_element.second < top_element.second) return true;\\n        else if(new_element.second > top_element.second) return false;\\n        else return new_element.first > top_element.first;\\n    }\\n};\\n\\nclass SORTracker {\\npublic:\\n    //maxHeap - contain all the element after k-1 element. \\n    priority_queue<pair<string, int>, vector<pair<string, int>>, maxHeapComp> maxHeap_left; \\n\\n    //minHeap - always contain k-1 biggest element\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, minHeapComp> minHeap_right;\\n\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        //Pushing will increase the size of minHeap by 1\\n        minHeap_right.push({name, score});\\n\\n        //Top of minHeapRight is the kth largest element\\n        //Push it to maxHeapLeft so minHeapRight only contain (k-1) largest element in it\\n        maxHeap_left.push(minHeap_right.top());\\n        minHeap_right.pop();\\n    }\\n    \\n    string get() {\\n        //MaxHeapLeft will be kth largest element \\n        string ans = maxHeap_left.top().first;\\n\\n        //Size of Right will increase by 1 due to get operation so \\n        //it can now store one more larger element in it.\\n        minHeap_right.push(maxHeap_left.top());\\n        maxHeap_left.pop();\\n\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct maxHeapComp{\\n    // return true if you want to switch their position and make new_element as the top element\\n    bool operator()(pair<string, int>& top_element, pair<string, int>& new_element) {\\n        if (new_element.second < top_element.second) return false;\\n        else if(new_element.second > top_element.second) return true;\\n        else return new_element.first < top_element.first;\\n    }\\n};\\n\\nstruct minHeapComp{\\n    // return true if you want to switch their position and make new_element as the top element\\n    bool operator()(pair<string, int>& top_element, pair<string, int>& new_element) {\\n        if (new_element.second < top_element.second) return true;\\n        else if(new_element.second > top_element.second) return false;\\n        else return new_element.first > top_element.first;\\n    }\\n};\\n\\nclass SORTracker {\\npublic:\\n    //maxHeap - contain all the element after k-1 element. \\n    priority_queue<pair<string, int>, vector<pair<string, int>>, maxHeapComp> maxHeap_left; \\n\\n    //minHeap - always contain k-1 biggest element\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, minHeapComp> minHeap_right;\\n\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        //Pushing will increase the size of minHeap by 1\\n        minHeap_right.push({name, score});\\n\\n        //Top of minHeapRight is the kth largest element\\n        //Push it to maxHeapLeft so minHeapRight only contain (k-1) largest element in it\\n        maxHeap_left.push(minHeap_right.top());\\n        minHeap_right.pop();\\n    }\\n    \\n    string get() {\\n        //MaxHeapLeft will be kth largest element \\n        string ans = maxHeap_left.top().first;\\n\\n        //Size of Right will increase by 1 due to get operation so \\n        //it can now store one more larger element in it.\\n        minHeap_right.push(maxHeap_left.top());\\n        maxHeap_left.pop();\\n\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455578,
                "title": "python-simple-sortedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        from sortedcontainers import SortedList\\n        self.ans = SortedList()\\n        self.idx = 0\\n\\n    def add(self, name, score):\\n        self.ans.add((-score,name))\\n\\n    def get(self):\\n        self.idx += 1\\n        return self.ans[self.idx-1][1]\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        from sortedcontainers import SortedList\\n        self.ans = SortedList()\\n        self.idx = 0\\n\\n    def add(self, name, score):\\n        self.ans.add((-score,name))\\n\\n    def get(self):\\n        self.idx += 1\\n        return self.ans[self.idx-1][1]\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431784,
                "title": "python-binary-search-and-inseration-sort",
                "content": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.ordered_list = []\\n        self.cur_qidx = -1\\n        \\n\\n    def add(self, name: str, score: int) -> None:\\n        iidx = 0\\n        if self.ordered_list:\\n            iidx = self.findPos(name, score)\\n        self.ordered_list.insert(iidx, (score, name))\\n\\n    def get(self) -> str:\\n        name = None\\n        if self.ordered_list:\\n            self.cur_qidx += 1\\n            _, name = self.ordered_list[len(self.ordered_list) - self.cur_qidx - 1]\\n        return name\\n    \\n    def findPos(self, name, score):\\n        len_l = len(self.ordered_list)\\n        s, e = 0, len_l - 1\\n        while s < e:\\n            mid = (s + e) // 2\\n            if self._compL(self.ordered_list[mid], (score, name)):\\n                e = mid - 1\\n            elif self._compL((score, name), self.ordered_list[mid]):\\n                s = mid + 1\\n            else:\\n                s = e = mid\\n        \\n        while s < len_l and self._compL((score, name), self.ordered_list[s]):\\n            s += 1\\n        return s\\n    \\n        \\n    def _compL(self, ns1, ns2):\\n        if ns1[0] > ns2[0]:\\n            return True\\n        elif ns1[0] == ns2[0]:\\n            return ns1[1] < ns2[1]\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.ordered_list = []\\n        self.cur_qidx = -1\\n        \\n\\n    def add(self, name: str, score: int) -> None:\\n        iidx = 0\\n        if self.ordered_list:\\n            iidx = self.findPos(name, score)\\n        self.ordered_list.insert(iidx, (score, name))\\n\\n    def get(self) -> str:\\n        name = None\\n        if self.ordered_list:\\n            self.cur_qidx += 1\\n            _, name = self.ordered_list[len(self.ordered_list) - self.cur_qidx - 1]\\n        return name\\n    \\n    def findPos(self, name, score):\\n        len_l = len(self.ordered_list)\\n        s, e = 0, len_l - 1\\n        while s < e:\\n            mid = (s + e) // 2\\n            if self._compL(self.ordered_list[mid], (score, name)):\\n                e = mid - 1\\n            elif self._compL((score, name), self.ordered_list[mid]):\\n                s = mid + 1\\n            else:\\n                s = e = mid\\n        \\n        while s < len_l and self._compL((score, name), self.ordered_list[s]):\\n            s += 1\\n        return s\\n    \\n        \\n    def _compL(self, ns1, ns2):\\n        if ns1[0] > ns2[0]:\\n            return True\\n        elif ns1[0] == ns2[0]:\\n            return ns1[1] < ns2[1]\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386112,
                "title": "with-two-binaryheaps-in-rust",
                "content": "# Intuition\\n\\nsince it\\'s hard to store the iterator and the BTreeSet together in a struct, two binary heaps are used\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::BinaryHeap,\\n};\\n\\n#[derive(PartialEq, Eq, Clone)]\\nstruct Data {\\n    name: String,\\n    score: i32,\\n}\\n\\nimpl PartialOrd for Data {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Ord for Data {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        match self.score.cmp(&other.score) {\\n            Ordering::Equal => other.name.cmp(&self.name),\\n            ord => ord,\\n        }\\n    }\\n}\\n\\nstruct SORTracker {\\n    x: BinaryHeap<Data>,\\n    y: BinaryHeap<Reverse<Data>>,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        SORTracker {\\n            x: BinaryHeap::new(),\\n            y: BinaryHeap::new(),\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        let data = Data { name, score };\\n        if let Some(vr) = self.y.pop() {\\n            if data > vr.0 {\\n                self.y.push(Reverse(data));\\n                self.x.push(vr.0);\\n            } else {\\n                self.y.push(vr);\\n                self.x.push(data);\\n            }\\n        } else {\\n            self.x.push(data);\\n        }\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let vr = self.x.pop().unwrap();\\n        self.y.push(Reverse(vr.clone()));\\n        vr.name\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::BinaryHeap,\\n};\\n\\n#[derive(PartialEq, Eq, Clone)]\\nstruct Data {\\n    name: String,\\n    score: i32,\\n}\\n\\nimpl PartialOrd for Data {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Ord for Data {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        match self.score.cmp(&other.score) {\\n            Ordering::Equal => other.name.cmp(&self.name),\\n            ord => ord,\\n        }\\n    }\\n}\\n\\nstruct SORTracker {\\n    x: BinaryHeap<Data>,\\n    y: BinaryHeap<Reverse<Data>>,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        SORTracker {\\n            x: BinaryHeap::new(),\\n            y: BinaryHeap::new(),\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        let data = Data { name, score };\\n        if let Some(vr) = self.y.pop() {\\n            if data > vr.0 {\\n                self.y.push(Reverse(data));\\n                self.x.push(vr.0);\\n            } else {\\n                self.y.push(vr);\\n                self.x.push(data);\\n            }\\n        } else {\\n            self.x.push(data);\\n        }\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let vr = self.x.pop().unwrap();\\n        self.y.push(Reverse(vr.clone()));\\n        vr.name\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370063,
                "title": "python-interview-acceptable-version-trying-to-avoid-abusing-fancy-language-features",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI wanted to avoid using libraries and fancy features as much as possible. sortedlist() is great, but I wanted to approach this from a mindset of \"Hey, you cant do that! This is an interview and we dont allow you to use sensible, common programming tools to accomplish this task! Plese reinvent the wheel for me here\". Unfortunately the Time Limit barely allows that, and this passes in the bottom 5%, and thats only after using the list.insert() function which I am iffy on. That at least should be fair, its so basic.\\n\\nIm also using the fact that Python can do direct lexigraphical comparisons using > and < operators.\\n\\nI negate the score so the $$most negative$$ score is best, and is on the left. Otherwise I have to flip the order or slice backwards somewhere else. This seemed easiest.\\n\\nI DID just use the bisect method as writing my own binary search blows the time limit. I could have used the bisect.insort() method with a tuple to insert the new place most directly, including doing the lexigraphical search. Again, avoiding due to it being \"too fancy\" of a trick. \\n\\nI am using a plain list to store the ordered list, using bisect left to find the first place with $$matching$$ score and then linearly scanning for the exact placement using < to check lexigraphical order. I have to the then use the list.insert() function as slicing and recopying the list also takes too much time.\\n\\n\\n# Other Methods:\\nAs I said, I think the sortedlist() solutions ARE the better solutions, but I think an interviewer would maybe not allow them, at least according to the lore. I think this is nonsense: If you can clearly explain exactly what is being done in that package, how, and why, it should be fair game. But I hear otherwise.\\n\\nYou could perhaps mimic your own sortedlist: keep a parallel dict of scores where their key is lists of places with that score. Sort these sublists when convenient (in either get or add). You could perhaps add them UNSORTED in the add() function, but update a list of \"sorted scores\" then, so when you call get() youd jump right to the correct semi-sorted bucket of place names, and then only have to sort this bucket. Splitting these two sorting operations accross the two main functions might be a good choice if there are roughly equal number of get() and add() calls. \\n\\nInstead, the penultimate test case is like 99.99% add() calls, which means if you are doing all the sorting in the add() funciton, you may be in trouble. \\n\\nAnother option is just to use a tuple with heapq. Heapq in python sorts tuples beautifully, by first element then second. First can be the negated score, second is just a string and it will know to sort lexigraphically. When calling get, just create a copy of the heap (so... twice as much memory...) and destructively pop from it query times.\\n \\n\\n\\n# Code\\n```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.num_queries = 0\\n        self.nth_best = []\\n        self.place_score = collections.defaultdict(int)\\n\\n    def add(self, name: str, score: int) -> None:\\n        see_nth_best = self.nth_best\\n        see_place_score = self.place_score\\n\\n        #negating score so the \"most negative\" is best, so order remains left to right or my head will pop.\\n        self.place_score[name] = -score\\n        insert_idx = bisect.bisect_left(self.nth_best, -score, key= lambda place: self.place_score[place])\\n        while insert_idx < len(self.nth_best) and self.place_score[self.nth_best[insert_idx]] == -score and self.nth_best[insert_idx] < name:\\n            insert_idx += 1\\n        # self.nth_best = self.nth_best[:insert_idx] + [name] + self.nth_best[insert_idx:]\\n        self.nth_best.insert(insert_idx, name)\\n         \\n    def get(self) -> str:\\n        see_nth_best = self.nth_best\\n        see_num_queries = self.num_queries\\n        \\n        self.num_queries += 1\\n        return self.nth_best[self.num_queries - 1]\\n        \\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.num_queries = 0\\n        self.nth_best = []\\n        self.place_score = collections.defaultdict(int)\\n\\n    def add(self, name: str, score: int) -> None:\\n        see_nth_best = self.nth_best\\n        see_place_score = self.place_score\\n\\n        #negating score so the \"most negative\" is best, so order remains left to right or my head will pop.\\n        self.place_score[name] = -score\\n        insert_idx = bisect.bisect_left(self.nth_best, -score, key= lambda place: self.place_score[place])\\n        while insert_idx < len(self.nth_best) and self.place_score[self.nth_best[insert_idx]] == -score and self.nth_best[insert_idx] < name:\\n            insert_idx += 1\\n        # self.nth_best = self.nth_best[:insert_idx] + [name] + self.nth_best[insert_idx:]\\n        self.nth_best.insert(insert_idx, name)\\n         \\n    def get(self) -> str:\\n        see_nth_best = self.nth_best\\n        see_num_queries = self.num_queries\\n        \\n        self.num_queries += 1\\n        return self.nth_best[self.num_queries - 1]\\n        \\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336323,
                "title": "c-using-2-heap-and-ordered-set",
                "content": "# Code\\n```\\n// Using 2 Heap\\nclass SORTracker {\\n    struct compMax {\\n        bool operator()(pair<int, string> &B, pair<int, string> &A) {\\n          return B.first < A.first || (B.first == A.first && B.second > A.second);\\n        }\\n    };\\n    struct compMin {\\n        bool operator()(pair<int, string> &B, pair<int, string> &A) {\\n          return B.first > A.first || (B.first == A.first && B.second < A.second);\\n        }\\n    };\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, compMax> left;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, compMin> right;\\npublic:\\n    SORTracker() {\\n\\n    }\\n    \\n    void add(string name, int score) {\\n        right.push({score, name});\\n        left.push(right.top());\\n        right.pop();\\n    }\\n    \\n    string get() {\\n        auto removed = left.top();\\n        right.push(removed);\\n        left.pop();\\n        return removed.second;  \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n \\n//----------------------------------------------------------------------------\\n\\n// Using 2 Heap\\nclass SORTracker {\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> left;\\n    priority_queue<pair<int, string>> right;\\npublic:\\n    SORTracker() {\\n\\n    }\\n    \\n    void add(string name, int score) {\\n        right.push({-score, name});\\n        left.push(right.top());\\n        right.pop();\\n    }\\n    \\n    string get() {\\n        auto removed = left.top();\\n        right.push(removed);\\n        left.pop();\\n        return removed.second;  \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n \\n//----------------------------------------------------------------------------\\n\\n// Using Ordered Set\\nclass SORTracker {\\n    set<pair<int, string>> PQ;\\n    set<pair<int, string>>::iterator currIter = PQ.end();\\npublic:\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        auto insertPosIter = PQ.insert({-score, name}).first;\\n        if(currIter == PQ.end() || *insertPosIter < *currIter)\\n            currIter--;\\n    }\\n    \\n    string get() {\\n        return (currIter++) -> second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Heap (Priority Queue)",
                    "Data Stream",
                    "Ordered Set"
                ],
                "code": "```\\n// Using 2 Heap\\nclass SORTracker {\\n    struct compMax {\\n        bool operator()(pair<int, string> &B, pair<int, string> &A) {\\n          return B.first < A.first || (B.first == A.first && B.second > A.second);\\n        }\\n    };\\n    struct compMin {\\n        bool operator()(pair<int, string> &B, pair<int, string> &A) {\\n          return B.first > A.first || (B.first == A.first && B.second < A.second);\\n        }\\n    };\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, compMax> left;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, compMin> right;\\npublic:\\n    SORTracker() {\\n\\n    }\\n    \\n    void add(string name, int score) {\\n        right.push({score, name});\\n        left.push(right.top());\\n        right.pop();\\n    }\\n    \\n    string get() {\\n        auto removed = left.top();\\n        right.push(removed);\\n        left.pop();\\n        return removed.second;  \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n \\n//----------------------------------------------------------------------------\\n\\n// Using 2 Heap\\nclass SORTracker {\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> left;\\n    priority_queue<pair<int, string>> right;\\npublic:\\n    SORTracker() {\\n\\n    }\\n    \\n    void add(string name, int score) {\\n        right.push({-score, name});\\n        left.push(right.top());\\n        right.pop();\\n    }\\n    \\n    string get() {\\n        auto removed = left.top();\\n        right.push(removed);\\n        left.pop();\\n        return removed.second;  \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n \\n//----------------------------------------------------------------------------\\n\\n// Using Ordered Set\\nclass SORTracker {\\n    set<pair<int, string>> PQ;\\n    set<pair<int, string>>::iterator currIter = PQ.end();\\npublic:\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        auto insertPosIter = PQ.insert({-score, name}).first;\\n        if(currIter == PQ.end() || *insertPosIter < *currIter)\\n            currIter--;\\n    }\\n    \\n    string get() {\\n        return (currIter++) -> second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270912,
                "title": "1270-ms",
                "content": "```ruby\\nclass SORTracker\\n\\n    def initialize\\n        @i, @t = *2.times.map { CRBTreeMap.new }\\n    end\\n\\n    def add n, s\\n        k = [-s, n]\\n        @i[k] = k\\n        k = @i.delete_max\\n        @t[k] = k\\n    end\\n\\n    def get\\n        k = @t.delete_min\\n        @i[k] = k\\n        k.last\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass SORTracker\\n\\n    def initialize\\n        @i, @t = *2.times.map { CRBTreeMap.new }\\n    end\\n\\n    def add n, s\\n        k = [-s, n]\\n        @i[k] = k\\n        k = @i.delete_max\\n        @t[k] = k\\n    end\\n\\n    def get\\n        k = @t.delete_min\\n        @i[k] = k\\n        k.last\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253852,
                "title": "golang-438-ms-18-6-mb",
                "content": "```\\ntype Location struct {\\n\\tname  string\\n\\tscore int32\\n}\\n\\nfunc (l Location) isLessThan(l2 Location) bool {\\n\\treturn l.score < l2.score || (l.score == l2.score && l.name > l2.name)\\n}\\n\\ntype LocationMinHeap []Location\\n\\nfunc (h LocationMinHeap) Len() int            { return len(h) }\\nfunc (h LocationMinHeap) Less(i, j int) bool  { return h[i].isLessThan(h[j]) }\\nfunc (h LocationMinHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *LocationMinHeap) Push(x interface{}) { *h = append(*h, x.(Location)) }\\nfunc (h *LocationMinHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype LocationMaxHeap []Location\\n\\nfunc (h LocationMaxHeap) Len() int            { return len(h) }\\nfunc (h LocationMaxHeap) Less(i, j int) bool  { return h[j].isLessThan(h[i]) }\\nfunc (h LocationMaxHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *LocationMaxHeap) Push(x interface{}) { *h = append(*h, x.(Location)) }\\nfunc (h *LocationMaxHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype SORTracker struct {\\n\\tminHeap LocationMinHeap\\n\\tmaxHeap LocationMaxHeap\\n}\\n\\nfunc Constructor() SORTracker {\\n\\treturn SORTracker{}\\n}\\n\\nfunc (s *SORTracker) Add(name string, score int) {\\n\\tl := Location{\\n\\t\\tname:  name,\\n\\t\\tscore: int32(score),\\n\\t}\\n\\tif len(s.minHeap) != 0 && s.minHeap[0].isLessThan(l) {\\n\\t\\tl, s.minHeap[0] = s.minHeap[0], l\\n\\t\\theap.Fix(&s.minHeap, 0)\\n\\t}\\n\\theap.Push(&s.maxHeap, l)\\n}\\n\\nfunc (s *SORTracker) Get() string {\\n\\theap.Push(&s.minHeap, heap.Pop(&s.maxHeap))\\n\\treturn s.minHeap[0].name\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Location struct {\\n\\tname  string\\n\\tscore int32\\n}\\n\\nfunc (l Location) isLessThan(l2 Location) bool {\\n\\treturn l.score < l2.score || (l.score == l2.score && l.name > l2.name)\\n}\\n\\ntype LocationMinHeap []Location\\n\\nfunc (h LocationMinHeap) Len() int            { return len(h) }\\nfunc (h LocationMinHeap) Less(i, j int) bool  { return h[i].isLessThan(h[j]) }\\nfunc (h LocationMinHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *LocationMinHeap) Push(x interface{}) { *h = append(*h, x.(Location)) }\\nfunc (h *LocationMinHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype LocationMaxHeap []Location\\n\\nfunc (h LocationMaxHeap) Len() int            { return len(h) }\\nfunc (h LocationMaxHeap) Less(i, j int) bool  { return h[j].isLessThan(h[i]) }\\nfunc (h LocationMaxHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *LocationMaxHeap) Push(x interface{}) { *h = append(*h, x.(Location)) }\\nfunc (h *LocationMaxHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype SORTracker struct {\\n\\tminHeap LocationMinHeap\\n\\tmaxHeap LocationMaxHeap\\n}\\n\\nfunc Constructor() SORTracker {\\n\\treturn SORTracker{}\\n}\\n\\nfunc (s *SORTracker) Add(name string, score int) {\\n\\tl := Location{\\n\\t\\tname:  name,\\n\\t\\tscore: int32(score),\\n\\t}\\n\\tif len(s.minHeap) != 0 && s.minHeap[0].isLessThan(l) {\\n\\t\\tl, s.minHeap[0] = s.minHeap[0], l\\n\\t\\theap.Fix(&s.minHeap, 0)\\n\\t}\\n\\theap.Push(&s.maxHeap, l)\\n}\\n\\nfunc (s *SORTracker) Get() string {\\n\\theap.Push(&s.minHeap, heap.Pop(&s.maxHeap))\\n\\treturn s.minHeap[0].name\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3252495,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nstruct SORTracker {\\n    sorted_list: Vec<(i32, String)>,\\n    idx: usize,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        Self {\\n            sorted_list: Vec::new(),\\n            idx: 0,\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        let v = (-score, name);\\n        let i = self.sorted_list.binary_search(&v).unwrap_or_else(|x| x);\\n        self.sorted_list.insert(i, v);\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let ans = self.sorted_list[self.idx].1.clone();\\n        self.idx += 1;\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct SORTracker {\\n    sorted_list: Vec<(i32, String)>,\\n    idx: usize,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        Self {\\n            sorted_list: Vec::new(),\\n            idx: 0,\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        let v = (-score, name);\\n        let i = self.sorted_list.binary_search(&v).unwrap_or_else(|x| x);\\n        self.sorted_list.insert(i, v);\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let ans = self.sorted_list[self.idx].1.clone();\\n        self.idx += 1;\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3249914,
                "title": "golang-two-heaps-min-and-max",
                "content": "This solution is very similar to the solution for https://leetcode.com/problems/find-median-from-data-stream/\\n\\n```go\\n// We\\'re going to maintain two heaps (similar to median in a stream)\\n// similar to folding a descending order sorted numbers at some point\\n// The lo heap is a Min Heap and the hi heap is a max heap. The lo heap\\n// initially contains nothing and we move the top of the hi heap to the\\n// lo heap every time Get() is called.\\n// When we add something, we check the top of both heaps to identify which\\n// heap the new location should be added.\\n\\ntype Location struct {\\n  name string\\n  score int\\n}\\n\\n// Checks whether self is greater than other location\\nfunc (l *Location) Greater(other *Location) bool {\\n  return l.score > other.score || (l.score == other.score && l.name < other.name)\\n}\\n\\ntype MinHeap []*Location\\n\\nfunc (min MinHeap) Len() int           { return len(min) }\\nfunc (min MinHeap) Less(i, j int) bool {\\n  if min[i].score == min[j].score {\\n    return min[i].name > min[j].name\\n  }\\n  return min[i].score < min[j].score\\n}\\nfunc (min MinHeap) Swap(i, j int)      { min[i], min[j] = min[j], min[i] }\\n\\nfunc (min *MinHeap) Push(x interface{}) {\\n  *min = append(*min, x.(*Location))\\n}\\n\\nfunc (min *MinHeap) Pop() interface{} {\\n  old := *min\\n  n := len(old)\\n  item := old[n-1]\\n  *min = old[:n-1]\\n  return item\\n}\\n\\nfunc (min MinHeap) Top() interface{} {\\n  // The top element or the minimum element is at index 0\\n  return min[0]\\n}\\n\\ntype MaxHeap []*Location\\n\\nfunc (max MaxHeap) Len() int           { return len(max) }\\nfunc (max MaxHeap) Less(i, j int) bool {\\n  if max[i].score == max[j].score {\\n    return max[i].name < max[j].name\\n  }\\n  return max[i].score > max[j].score\\n}\\nfunc (max MaxHeap) Swap(i, j int)      { max[i], max[j] = max[j], max[i] }\\n\\nfunc (max *MaxHeap) Push(x interface{}) {\\n  *max = append(*max, x.(*Location))\\n}\\n\\nfunc (max *MaxHeap) Pop() interface{} {\\n  old := *max\\n  n := len(old)\\n  item := old[n-1]\\n  *max = old[:n-1]\\n  return item\\n}\\n\\nfunc (max MaxHeap) Top() interface{} {\\n  // The top element or the minimum element is at index 0\\n  return max[0]\\n}\\n\\n\\ntype SORTracker struct {\\n  lo MinHeap\\n  hi MaxHeap\\n}\\n\\n\\nfunc Constructor() SORTracker {\\n  return SORTracker{\\n    lo: MinHeap{},\\n    hi: MaxHeap{},\\n  }\\n}\\n\\n\\nfunc (this *SORTracker) Add(name string, score int)  {\\n  l := &Location{name: name, score: score}\\n  if this.lo.Len() > 0 && l.Greater(this.lo.Top().(*Location)) {\\n    heap.Push(&this.lo, l)\\n    heap.Push(&this.hi, heap.Pop(&this.lo).(*Location))\\n  } else {\\n    heap.Push(&this.hi, l)\\n  }\\n}\\n\\n\\nfunc (this *SORTracker) Get() string {\\n  heap.Push(&this.lo, heap.Pop(&this.hi).(*Location))\\n  return this.lo.Top().(*Location).name\\n}\\n\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(name,score);\\n * param_2 := obj.Get();\\n */\\n ```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\n// We\\'re going to maintain two heaps (similar to median in a stream)\\n// similar to folding a descending order sorted numbers at some point\\n// The lo heap is a Min Heap and the hi heap is a max heap. The lo heap\\n// initially contains nothing and we move the top of the hi heap to the\\n// lo heap every time Get() is called.\\n// When we add something, we check the top of both heaps to identify which\\n// heap the new location should be added.\\n\\ntype Location struct {\\n  name string\\n  score int\\n}\\n\\n// Checks whether self is greater than other location\\nfunc (l *Location) Greater(other *Location) bool {\\n  return l.score > other.score || (l.score == other.score && l.name < other.name)\\n}\\n\\ntype MinHeap []*Location\\n\\nfunc (min MinHeap) Len() int           { return len(min) }\\nfunc (min MinHeap) Less(i, j int) bool {\\n  if min[i].score == min[j].score {\\n    return min[i].name > min[j].name\\n  }\\n  return min[i].score < min[j].score\\n}\\nfunc (min MinHeap) Swap(i, j int)      { min[i], min[j] = min[j], min[i] }\\n\\nfunc (min *MinHeap) Push(x interface{}) {\\n  *min = append(*min, x.(*Location))\\n}\\n\\nfunc (min *MinHeap) Pop() interface{} {\\n  old := *min\\n  n := len(old)\\n  item := old[n-1]\\n  *min = old[:n-1]\\n  return item\\n}\\n\\nfunc (min MinHeap) Top() interface{} {\\n  // The top element or the minimum element is at index 0\\n  return min[0]\\n}\\n\\ntype MaxHeap []*Location\\n\\nfunc (max MaxHeap) Len() int           { return len(max) }\\nfunc (max MaxHeap) Less(i, j int) bool {\\n  if max[i].score == max[j].score {\\n    return max[i].name < max[j].name\\n  }\\n  return max[i].score > max[j].score\\n}\\nfunc (max MaxHeap) Swap(i, j int)      { max[i], max[j] = max[j], max[i] }\\n\\nfunc (max *MaxHeap) Push(x interface{}) {\\n  *max = append(*max, x.(*Location))\\n}\\n\\nfunc (max *MaxHeap) Pop() interface{} {\\n  old := *max\\n  n := len(old)\\n  item := old[n-1]\\n  *max = old[:n-1]\\n  return item\\n}\\n\\nfunc (max MaxHeap) Top() interface{} {\\n  // The top element or the minimum element is at index 0\\n  return max[0]\\n}\\n\\n\\ntype SORTracker struct {\\n  lo MinHeap\\n  hi MaxHeap\\n}\\n\\n\\nfunc Constructor() SORTracker {\\n  return SORTracker{\\n    lo: MinHeap{},\\n    hi: MaxHeap{},\\n  }\\n}\\n\\n\\nfunc (this *SORTracker) Add(name string, score int)  {\\n  l := &Location{name: name, score: score}\\n  if this.lo.Len() > 0 && l.Greater(this.lo.Top().(*Location)) {\\n    heap.Push(&this.lo, l)\\n    heap.Push(&this.hi, heap.Pop(&this.lo).(*Location))\\n  } else {\\n    heap.Push(&this.hi, l)\\n  }\\n}\\n\\n\\nfunc (this *SORTracker) Get() string {\\n  heap.Push(&this.lo, heap.Pop(&this.hi).(*Location))\\n  return this.lo.Top().(*Location).name\\n}\\n\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(name,score);\\n * param_2 := obj.Get();\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169686,
                "title": "best-solution-explained",
                "content": "\\n```\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> s;\\n    set<pair<int, string>>::iterator it = end(s);    \\n    void add(string name, int score) {\\n        auto it1 = s.insert({-score, name}).first;\\n        if (it == end(s) || *it1 < *it)\\n            --it;\\n    }\\n    string get() {\\n        return (it++)->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> s;\\n    set<pair<int, string>>::iterator it = end(s);    \\n    void add(string name, int score) {\\n        auto it1 = s.insert({-score, name}).first;\\n        if (it == end(s) || *it1 < *it)\\n            --it;\\n    }\\n    string get() {\\n        return (it++)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108468,
                "title": "easy-to-understand-2-min-and-max-heap-commented-code-c",
                "content": "```\\nclass SORTracker {\\npublic:\\n    using pi = pair<int,string>;\\n    struct minCmp {\\n        bool operator()(pi &a, pi & b) {\\n            return (a.first > b.first) || ((a.first == b.first) && (a.second < b.second));\\n        }\\n    };\\n    \\n    struct maxCmp {\\n        bool operator()(pi &a, pi & b) {\\n            return (a.first < b.first) || ((a.first == b.first) && (a.second > b.second));\\n        }\\n    };\\n    \\n    \\n    priority_queue<pi,vector<pi>,minCmp> minHeap; // minHeap maintains already picked element\\n    priority_queue<pi,vector<pi>,maxCmp> maxHeap; // maxHeap maintains future first get element\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        auto maxCmp1 = [](auto &a, auto &b) {return (a.first < b.first) || ((a.first == b.first) && (a.second > b.second));};\\n        minHeap.push({score,name}); // put the incoming in min first, so we have 1 extra in minHeap \\n        maxHeap.push(minHeap.top()); // pop out from min and push it to maxHeap with updated next element\\n        minHeap.pop();\\n    }\\n    \\n    string get() {\\n        auto [score,name] = maxHeap.top(); // pop out updated next max element\\n        minHeap.push(maxHeap.top()); // push it to list of already visited elements\\n        maxHeap.pop();\\n        return name;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\npublic:\\n    using pi = pair<int,string>;\\n    struct minCmp {\\n        bool operator()(pi &a, pi & b) {\\n            return (a.first > b.first) || ((a.first == b.first) && (a.second < b.second));\\n        }\\n    };\\n    \\n    struct maxCmp {\\n        bool operator()(pi &a, pi & b) {\\n            return (a.first < b.first) || ((a.first == b.first) && (a.second > b.second));\\n        }\\n    };\\n    \\n    \\n    priority_queue<pi,vector<pi>,minCmp> minHeap; // minHeap maintains already picked element\\n    priority_queue<pi,vector<pi>,maxCmp> maxHeap; // maxHeap maintains future first get element\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        auto maxCmp1 = [](auto &a, auto &b) {return (a.first < b.first) || ((a.first == b.first) && (a.second > b.second));};\\n        minHeap.push({score,name}); // put the incoming in min first, so we have 1 extra in minHeap \\n        maxHeap.push(minHeap.top()); // pop out from min and push it to maxHeap with updated next element\\n        minHeap.pop();\\n    }\\n    \\n    string get() {\\n        auto [score,name] = maxHeap.top(); // pop out updated next max element\\n        minHeap.push(maxHeap.top()); // push it to list of already visited elements\\n        maxHeap.pop();\\n        return name;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107914,
                "title": "solution-using-two-priority-queue-without-set-decrement-operator",
                "content": "\\n# Code\\n```\\nusing pn = pair<int, string>;\\nclass SORTracker {\\npublic:\\n    priority_queue<pn> lhs;\\n    priority_queue<pn, vector<pn>, greater<pn>> rhs;\\n\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        pn nn = {-score, name};\\n        if (!lhs.size()) {\\n            rhs.push(nn);\\n        } else {\\n            pn t = lhs.top();\\n\\n            if (nn < t) {\\n                lhs.push(nn);\\n                rhs.push(lhs.top());\\n                lhs.pop();\\n            } else {\\n                rhs.push(nn);\\n            }\\n        }\\n    }\\n    \\n    string get() {\\n        lhs.push(rhs.top());\\n        auto [scr, name] = rhs.top();\\n        rhs.pop();\\n        return name;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing pn = pair<int, string>;\\nclass SORTracker {\\npublic:\\n    priority_queue<pn> lhs;\\n    priority_queue<pn, vector<pn>, greater<pn>> rhs;\\n\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        pn nn = {-score, name};\\n        if (!lhs.size()) {\\n            rhs.push(nn);\\n        } else {\\n            pn t = lhs.top();\\n\\n            if (nn < t) {\\n                lhs.push(nn);\\n                rhs.push(lhs.top());\\n                lhs.pop();\\n            } else {\\n                rhs.push(nn);\\n            }\\n        }\\n    }\\n    \\n    string get() {\\n        lhs.push(rhs.top());\\n        auto [scr, name] = rhs.top();\\n        rhs.pop();\\n        return name;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104937,
                "title": "golang-solution",
                "content": "# Code\\n```\\ntype Location struct {\\n    name string \\n    score int\\n}\\n\\n\\ntype SORTracker struct {\\n    locations []Location\\n    count int\\n}\\n\\n\\nfunc Constructor() SORTracker {\\n    return SORTracker{}\\n}\\n\\n\\nfunc (this *SORTracker) Add(name string, score int)  {\\n\\n    // fmt.Println(this.locations)\\n    i := sort.Search(len(this.locations), func(i int) bool {\\n            if this.locations[i].score < score  {\\n                return true\\n            } else if this.locations[i].score == score {\\n                if strings.Compare(this.locations[i].name, name) > 0 {\\n                        return true\\n                }\\n            }\\n            return false\\n            \\n        })\\n    this.locations = append(this.locations, Location{})\\n\\tcopy(this.locations[i+1:], this.locations[i:])\\n\\tthis.locations[i] = Location{name, score}\\n    // fmt.Println(this.locations)\\n}\\n\\nfunc (this *SORTracker) Get() string {\\n    this.count++ \\n    return this.locations[this.count - 1].name\\n}\\n\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(name,score);\\n * param_2 := obj.Get();\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Location struct {\\n    name string \\n    score int\\n}\\n\\n\\ntype SORTracker struct {\\n    locations []Location\\n    count int\\n}\\n\\n\\nfunc Constructor() SORTracker {\\n    return SORTracker{}\\n}\\n\\n\\nfunc (this *SORTracker) Add(name string, score int)  {\\n\\n    // fmt.Println(this.locations)\\n    i := sort.Search(len(this.locations), func(i int) bool {\\n            if this.locations[i].score < score  {\\n                return true\\n            } else if this.locations[i].score == score {\\n                if strings.Compare(this.locations[i].name, name) > 0 {\\n                        return true\\n                }\\n            }\\n            return false\\n            \\n        })\\n    this.locations = append(this.locations, Location{})\\n\\tcopy(this.locations[i+1:], this.locations[i:])\\n\\tthis.locations[i] = Location{name, score}\\n    // fmt.Println(this.locations)\\n}\\n\\nfunc (this *SORTracker) Get() string {\\n    this.count++ \\n    return this.locations[this.count - 1].name\\n}\\n\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(name,score);\\n * param_2 := obj.Get();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3061455,
                "title": "javascript-avl-tree-698ms-100",
                "content": "```\\n////////////////////// Template /////////////////////////\\nclass AVLNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.left = null;\\n        this.right = null;\\n        this.height = 1;\\n        this.cnt = 1;\\n        this.SubTreeNodes = 1;\\n    }\\n}\\n\\nconst lexical_smallest_comp = (x, y) => x < y ? -1 : x > y ? 1 : 0;\\n\\nclass AVLTree {\\n    constructor() {\\n        this.root = null;\\n        this.nodeCount = 0;\\n        this.tot = 0;\\n    }\\n    cmp(x, y) { // compare nodes: x is inserted item\\n        if (x == null || y == null) return 0;\\n        if (Array.isArray(x) || Number.isInteger(x)) x = new AVLNode(x);\\n        if (Array.isArray(y) || Number.isInteger(y)) y = new AVLNode(y);\\n        if (Array.isArray(x.val) || Array.isArray(y.val)) { // array compare (can change like PQ)\\n            // this problem comparator\\n            if (Array.isArray(x.val) && Array.isArray(y.val)) {\\n                if (x.val[1] != y.val[1]) return y.val[1] - x.val[1]; // first priority: larger score comes first\\n                return lexical_smallest_comp(x.val[0], y.val[0]); // second priority: lexical smaller comes first\\n            } else {\\n                return 0;\\n            }\\n        } else if (Number.isInteger(x.val) || Number.isInteger(y.val)) { // number compare\\n            if (Number.isInteger(x.val) && Number.isInteger(y.val)) {\\n                return x.val - y.val;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        return 0;\\n    }\\n    getHeight(node) {\\n        return node != null ? node.height : 0;\\n    }\\n    getBalance(node) {\\n        return node != null ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\\n    }\\n    update(node) {\\n        let leftHeight = this.getHeight(node.left), rightHeight = this.getHeight(node.right);\\n        node.height = 1 + Math.max(leftHeight, rightHeight);\\n        node.SubTreeNodes = 1 + (node.left != null ? node.left.SubTreeNodes : 0) + (node.right != null ? node.right.SubTreeNodes : 0);\\n    }\\n    LR(z) {\\n        let y = z.right;\\n        let T2 = y.left;\\n        y.left = z;\\n        z.right = T2;\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    RR(z) {\\n        let y = z.left;\\n        let T3 = y.right;\\n        y.right = z\\n        z.left = T3\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    insert(item) {\\n        this.root = this.insertUtil(this.root, item);\\n    }\\n    insertUtil(node, item) {\\n        if (node == null) { // find place to insert\\n            this.nodeCount++;\\n            this.tot++;\\n            return new AVLNode(item);\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.insertUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.insertUtil(node.right, item);\\n        } else {\\n            node.cnt++;\\n            this.tot++;\\n            return node;\\n        }\\n        this.update(node);\\n        return this.rebalanceAfterInsert(node, item);\\n    }\\n    remove(v) {\\n        this.root = this.removeUtil(this.root, v);\\n    }\\n    removeUtil(node, item) {\\n        if (node == null) {\\n            return node;\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.removeUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.removeUtil(node.right, item);\\n        } else { // find node\\n            if (node.cnt > 1) { // current node > 1, remove 1, tree size keep the same\\n                node.cnt--;\\n                this.tot--;\\n                return node;\\n            } else { // current node == 1, delete, tree size--\\n                this.nodeCount--;\\n                this.tot--;\\n            }\\n            // delete process\\n            if (node.left == null) {\\n                let tmp = node.right;\\n                node = null;\\n                return tmp;\\n            } else if (node.right == null) {\\n                let tmp = node.left;\\n                node = null;\\n                return tmp;\\n            }\\n            let tmp = this.findMin(node.right);\\n            node.val = tmp.val;\\n            node.right = this.removeUtil(node.right, tmp.val);\\n        }\\n        if (node == null) return node;\\n        this.update(node);\\n        return this.rebalanceAfterDeletion(node, item);\\n    }\\n    rebalanceAfterInsert(node, item) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.cmp(item, node.left) < 0) return this.RR(node);\\n        if (bal < -1 && this.cmp(item, node.right) > 0) return this.LR(node);\\n        if (bal > 1 && this.cmp(item, node.left) > 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.cmp(item, node.right) < 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    rebalanceAfterDeletion(node) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.getBalance(node.left) >= 0) return this.RR(node);\\n        if (bal < -1 && this.getBalance(node.right) <= 0) return this.LR(node);\\n        if (bal > 1 && this.getBalance(node.left) < 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.getBalance(node.right) > 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    find(item) {\\n        return this.findFirstOf(item);\\n    }\\n    findFirstOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    higher(item) {// > upper_bound\\n        let node = this.findSuccessorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findSuccessorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        return res;\\n    }\\n    lower(item) { // < \\n        let node = this.findPrecursorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findPrecursorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) > 0) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    findKth(k) { // (1-indexed)  unique\\n        let res = this.findKthNode(k);\\n        return res == null ? null : res.val;\\n    }\\n    findKthNode(k) {\\n        return this.size() < k ? null : this.KthUtil(this.root, k);\\n    }\\n    KthUtil(node, k) {\\n        let leftCount = node.left ? node.left.SubTreeNodes : 0;\\n        if (leftCount + 1 === k) return node;\\n        if (leftCount + 1 < k) return this.KthUtil(node.right, k - leftCount - 1);\\n        return this.KthUtil(node.left, k);\\n    }\\n    rankOf(item) { // unique value treeset    total elements in tree with val < item\\n        let x = this.findPrecursorOf(item);\\n        return x == null ? 0 : this.findRankOf(x, this.root) + 1;\\n    }\\n    findRankOf(item, node) {\\n        let rank = 0;\\n        while (node != null) {\\n            let leftSubtreeNodes = node.left != null ? node.left.SubTreeNodes : 0;\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                rank += leftSubtreeNodes + 1;\\n                node = node.right;\\n            } else {\\n                return rank + leftSubtreeNodes;\\n            }\\n        }\\n        return 0;\\n    }\\n    has(item) {\\n        return this.count(item) > 0;\\n    }\\n    count(item) {\\n        let node = this.find(item);\\n        return node == null ? 0 : node.cnt;\\n    }\\n    maxx() {\\n        let node = this.findMax(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    minx() {\\n        let node = this.findMin(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    findMin(node) {\\n        return node == null || node.left == null ? node : this.findMin(node.left);\\n    }\\n    findMax(node) {\\n        return node == null || node.right == null ? node : this.findMax(node.right);\\n    }\\n    size() {\\n        return this.nodeCount;\\n    }\\n    total() {\\n        return this.tot;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() { // inorder\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n    showAll() {\\n        let d = this.show(), res = [];\\n        for (const x of d) {\\n            for (let i = 0; i < this.count(x); i++) res.push(x);\\n        }\\n        return res;\\n    }\\n}\\n////////////////////////////////////////////////////////////\\n\\nfunction SORTracker() {\\n    let tree = new AVLTree(), i = 1;\\n    return { add, get }\\n    function add(name, score) {\\n       tree.insert([name,score])\\n    }\\n    function get() {\\n       let node = tree.findKthNode(i++);\\n       return node.val[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n////////////////////// Template /////////////////////////\\nclass AVLNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.left = null;\\n        this.right = null;\\n        this.height = 1;\\n        this.cnt = 1;\\n        this.SubTreeNodes = 1;\\n    }\\n}\\n\\nconst lexical_smallest_comp = (x, y) => x < y ? -1 : x > y ? 1 : 0;\\n\\nclass AVLTree {\\n    constructor() {\\n        this.root = null;\\n        this.nodeCount = 0;\\n        this.tot = 0;\\n    }\\n    cmp(x, y) { // compare nodes: x is inserted item\\n        if (x == null || y == null) return 0;\\n        if (Array.isArray(x) || Number.isInteger(x)) x = new AVLNode(x);\\n        if (Array.isArray(y) || Number.isInteger(y)) y = new AVLNode(y);\\n        if (Array.isArray(x.val) || Array.isArray(y.val)) { // array compare (can change like PQ)\\n            // this problem comparator\\n            if (Array.isArray(x.val) && Array.isArray(y.val)) {\\n                if (x.val[1] != y.val[1]) return y.val[1] - x.val[1]; // first priority: larger score comes first\\n                return lexical_smallest_comp(x.val[0], y.val[0]); // second priority: lexical smaller comes first\\n            } else {\\n                return 0;\\n            }\\n        } else if (Number.isInteger(x.val) || Number.isInteger(y.val)) { // number compare\\n            if (Number.isInteger(x.val) && Number.isInteger(y.val)) {\\n                return x.val - y.val;\\n            } else {\\n                return 0;\\n            }\\n        }\\n        return 0;\\n    }\\n    getHeight(node) {\\n        return node != null ? node.height : 0;\\n    }\\n    getBalance(node) {\\n        return node != null ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\\n    }\\n    update(node) {\\n        let leftHeight = this.getHeight(node.left), rightHeight = this.getHeight(node.right);\\n        node.height = 1 + Math.max(leftHeight, rightHeight);\\n        node.SubTreeNodes = 1 + (node.left != null ? node.left.SubTreeNodes : 0) + (node.right != null ? node.right.SubTreeNodes : 0);\\n    }\\n    LR(z) {\\n        let y = z.right;\\n        let T2 = y.left;\\n        y.left = z;\\n        z.right = T2;\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    RR(z) {\\n        let y = z.left;\\n        let T3 = y.right;\\n        y.right = z\\n        z.left = T3\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    insert(item) {\\n        this.root = this.insertUtil(this.root, item);\\n    }\\n    insertUtil(node, item) {\\n        if (node == null) { // find place to insert\\n            this.nodeCount++;\\n            this.tot++;\\n            return new AVLNode(item);\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.insertUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.insertUtil(node.right, item);\\n        } else {\\n            node.cnt++;\\n            this.tot++;\\n            return node;\\n        }\\n        this.update(node);\\n        return this.rebalanceAfterInsert(node, item);\\n    }\\n    remove(v) {\\n        this.root = this.removeUtil(this.root, v);\\n    }\\n    removeUtil(node, item) {\\n        if (node == null) {\\n            return node;\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.removeUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.removeUtil(node.right, item);\\n        } else { // find node\\n            if (node.cnt > 1) { // current node > 1, remove 1, tree size keep the same\\n                node.cnt--;\\n                this.tot--;\\n                return node;\\n            } else { // current node == 1, delete, tree size--\\n                this.nodeCount--;\\n                this.tot--;\\n            }\\n            // delete process\\n            if (node.left == null) {\\n                let tmp = node.right;\\n                node = null;\\n                return tmp;\\n            } else if (node.right == null) {\\n                let tmp = node.left;\\n                node = null;\\n                return tmp;\\n            }\\n            let tmp = this.findMin(node.right);\\n            node.val = tmp.val;\\n            node.right = this.removeUtil(node.right, tmp.val);\\n        }\\n        if (node == null) return node;\\n        this.update(node);\\n        return this.rebalanceAfterDeletion(node, item);\\n    }\\n    rebalanceAfterInsert(node, item) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.cmp(item, node.left) < 0) return this.RR(node);\\n        if (bal < -1 && this.cmp(item, node.right) > 0) return this.LR(node);\\n        if (bal > 1 && this.cmp(item, node.left) > 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.cmp(item, node.right) < 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    rebalanceAfterDeletion(node) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.getBalance(node.left) >= 0) return this.RR(node);\\n        if (bal < -1 && this.getBalance(node.right) <= 0) return this.LR(node);\\n        if (bal > 1 && this.getBalance(node.left) < 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.getBalance(node.right) > 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    find(item) {\\n        return this.findFirstOf(item);\\n    }\\n    findFirstOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    higher(item) {// > upper_bound\\n        let node = this.findSuccessorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findSuccessorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        return res;\\n    }\\n    lower(item) { // < \\n        let node = this.findPrecursorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findPrecursorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) > 0) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    findKth(k) { // (1-indexed)  unique\\n        let res = this.findKthNode(k);\\n        return res == null ? null : res.val;\\n    }\\n    findKthNode(k) {\\n        return this.size() < k ? null : this.KthUtil(this.root, k);\\n    }\\n    KthUtil(node, k) {\\n        let leftCount = node.left ? node.left.SubTreeNodes : 0;\\n        if (leftCount + 1 === k) return node;\\n        if (leftCount + 1 < k) return this.KthUtil(node.right, k - leftCount - 1);\\n        return this.KthUtil(node.left, k);\\n    }\\n    rankOf(item) { // unique value treeset    total elements in tree with val < item\\n        let x = this.findPrecursorOf(item);\\n        return x == null ? 0 : this.findRankOf(x, this.root) + 1;\\n    }\\n    findRankOf(item, node) {\\n        let rank = 0;\\n        while (node != null) {\\n            let leftSubtreeNodes = node.left != null ? node.left.SubTreeNodes : 0;\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                rank += leftSubtreeNodes + 1;\\n                node = node.right;\\n            } else {\\n                return rank + leftSubtreeNodes;\\n            }\\n        }\\n        return 0;\\n    }\\n    has(item) {\\n        return this.count(item) > 0;\\n    }\\n    count(item) {\\n        let node = this.find(item);\\n        return node == null ? 0 : node.cnt;\\n    }\\n    maxx() {\\n        let node = this.findMax(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    minx() {\\n        let node = this.findMin(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    findMin(node) {\\n        return node == null || node.left == null ? node : this.findMin(node.left);\\n    }\\n    findMax(node) {\\n        return node == null || node.right == null ? node : this.findMax(node.right);\\n    }\\n    size() {\\n        return this.nodeCount;\\n    }\\n    total() {\\n        return this.tot;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() { // inorder\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n    showAll() {\\n        let d = this.show(), res = [];\\n        for (const x of d) {\\n            for (let i = 0; i < this.count(x); i++) res.push(x);\\n        }\\n        return res;\\n    }\\n}\\n////////////////////////////////////////////////////////////\\n\\nfunction SORTracker() {\\n    let tree = new AVLTree(), i = 1;\\n    return { add, get }\\n    function add(name, score) {\\n       tree.insert([name,score])\\n    }\\n    function get() {\\n       let node = tree.findKthNode(i++);\\n       return node.val[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011388,
                "title": "java-binary-search",
                "content": "# Intuition\\nUse binary search to find the appropriate position when adding new loction.\\n\\n# Approach\\nBinary search\\n\\n# Complexity\\n- Time complexity:\\n$O(nlogn)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Location {\\n    String name;\\n    int score;\\n    public Location(String name, int score) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n}\\n\\nclass SORTracker {\\n\\n    int query = 0;\\n    List<Location> locations;\\n\\n    public SORTracker() {\\n        locations = new ArrayList<>();\\n    }\\n    \\n    public void add(String name, int score) {\\n        int left = 0;\\n        int right= locations.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            Location cur = locations.get(mid);\\n            // System.out.printf(\"%d %d\\\\n\", mid, cur.score);\\n            if (cur.score == score) {\\n                if (cur.name.compareTo(name) <= 0) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else if (cur.score > score) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        locations.add(left, new Location(name, score));\\n    }\\n    \\n    public String get() {\\n        String name = locations.get(query).name;\\n        query++;\\n        return name;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Location {\\n    String name;\\n    int score;\\n    public Location(String name, int score) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n}\\n\\nclass SORTracker {\\n\\n    int query = 0;\\n    List<Location> locations;\\n\\n    public SORTracker() {\\n        locations = new ArrayList<>();\\n    }\\n    \\n    public void add(String name, int score) {\\n        int left = 0;\\n        int right= locations.size() - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            Location cur = locations.get(mid);\\n            // System.out.printf(\"%d %d\\\\n\", mid, cur.score);\\n            if (cur.score == score) {\\n                if (cur.name.compareTo(name) <= 0) {\\n                    left = mid + 1;\\n                } else {\\n                    right = mid - 1;\\n                }\\n            } else if (cur.score > score) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        locations.add(left, new Location(name, score));\\n    }\\n    \\n    public String get() {\\n        String name = locations.get(query).name;\\n        query++;\\n        return name;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981152,
                "title": "java-sol-sequentially-ordinal-rank-tracker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBy using two priorityQueue i.e. min and max heap.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SORTracker {\\n    class Pair{\\n        String name;\\n        int score;\\n        Pair(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n    PriorityQueue<Pair> min;\\n    PriorityQueue<Pair> max;\\n    public SORTracker() {\\n        this.min = new PriorityQueue<>((Pair p1, Pair p2) -> {\\n            if(p1.score == p2.score)    return p1.name.compareTo(p2.name);\\n            return p2.score-p1.score;\\n        });\\n        this.max = new PriorityQueue<>((Pair p1, Pair p2) -> {\\n            if(p1.score == p2.score)    return p2.name.compareTo(p1.name);\\n            return p1.score-p2.score;\\n        });\\n    }\\n    \\n    public void add(String name, int score) {\\n        max.add(new Pair(name,score));\\n        min.add(max.poll());\\n    }\\n    \\n    public String get() {\\n        Pair p = min.peek();\\n        max.add(min.poll());\\n        return p.name;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SORTracker {\\n    class Pair{\\n        String name;\\n        int score;\\n        Pair(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n    PriorityQueue<Pair> min;\\n    PriorityQueue<Pair> max;\\n    public SORTracker() {\\n        this.min = new PriorityQueue<>((Pair p1, Pair p2) -> {\\n            if(p1.score == p2.score)    return p1.name.compareTo(p2.name);\\n            return p2.score-p1.score;\\n        });\\n        this.max = new PriorityQueue<>((Pair p1, Pair p2) -> {\\n            if(p1.score == p2.score)    return p2.name.compareTo(p1.name);\\n            return p1.score-p2.score;\\n        });\\n    }\\n    \\n    public void add(String name, int score) {\\n        max.add(new Pair(name,score));\\n        min.add(max.poll());\\n    }\\n    \\n    public String get() {\\n        Pair p = min.peek();\\n        max.add(min.poll());\\n        return p.name;\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932630,
                "title": "c-using-two-priority-queue-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SORTracker {\\n    priority_queue<pair<int , string> , vector<pair<int , string>> , greater<pair<int , string>>> pqmax;\\n    priority_queue<pair<int , string>> pqmin;\\npublic:\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int , string> temp = {-1*score , name};\\n        if(pqmin.size()){\\n            if(pqmin.top() > temp){\\n                pqmax.push(pqmin.top());\\n                pqmin.pop();\\n                pqmin.push(temp);\\n            }\\n            else{\\n                pqmax.push(temp);\\n            }\\n        }else{\\n            pqmax.push(temp);\\n        }\\n    }\\n    \\n    string get() {\\n        string result = pqmax.top().second;\\n        pqmin.push(pqmax.top());\\n        pqmax.pop();\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SORTracker {\\n    priority_queue<pair<int , string> , vector<pair<int , string>> , greater<pair<int , string>>> pqmax;\\n    priority_queue<pair<int , string>> pqmin;\\npublic:\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int , string> temp = {-1*score , name};\\n        if(pqmin.size()){\\n            if(pqmin.top() > temp){\\n                pqmax.push(pqmin.top());\\n                pqmin.pop();\\n                pqmin.push(temp);\\n            }\\n            else{\\n                pqmax.push(temp);\\n            }\\n        }else{\\n            pqmax.push(temp);\\n        }\\n    }\\n    \\n    string get() {\\n        string result = pqmax.top().second;\\n        pqmin.push(pqmax.top());\\n        pqmax.pop();\\n        return result;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921704,
                "title": "python-maxheap-minheap-beats-88-8",
                "content": "# Intuition\\n\\nFor maxHeap\\n- The worst location is at heap top\\n\\n- This heap keeps the `k-1` best locations\\n\\nFor minHeap\\n- The best location is at heap top\\n\\n- This heap keeps the remaining `N-k+1` locations\\n\\nAlways keep the `k-th` best location for `get()` at the top of minHeap.\\n\\n# Complexity\\n- Time complexity: add `O(logN)`, get `O(logN)`\\n\\n- Space complexity: `O(N)`\\n\\n# Code\\n```\\nimport heapq\\n\\n# worst location at heap top\\nclass MaxHeapNode:\\n    def __init__(self, score, name):\\n        self.score = score\\n        self.name = name\\n\\n    def __lt__(self, other):\\n        if self.score == other.score:\\n            return self.name > other.name\\n        return self.score < other.score\\n    \\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.max_h, self.min_h = [], []\\n\\n    def add(self, name: str, score: int) -> None:\\n        # if the new element is better than k-1\\'th\\n        if self.max_h and (-score, name) < (-self.max_h[0].score, self.max_h[0].name):\\n            x = heapq.heappop(self.max_h)\\n            heapq.heappush(self.min_h, (-x.score, x.name))\\n            heapq.heappush(self.max_h, MaxHeapNode(score, name))\\n        else:\\n            heapq.heappush(self.min_h, (-score, name))\\n\\n    def get(self) -> str:\\n        x = heapq.heappop(self.min_h)\\n        heapq.heappush(self.max_h, MaxHeapNode(-x[0], x[1]))\\n        return x[1]\\n```\\n\\n# Performance\\n\\n- Runtime 1144 ms, Beats 88.81%\\n\\n- Memory 37.5 MB, Beats 78.98%\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\n# worst location at heap top\\nclass MaxHeapNode:\\n    def __init__(self, score, name):\\n        self.score = score\\n        self.name = name\\n\\n    def __lt__(self, other):\\n        if self.score == other.score:\\n            return self.name > other.name\\n        return self.score < other.score\\n    \\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.max_h, self.min_h = [], []\\n\\n    def add(self, name: str, score: int) -> None:\\n        # if the new element is better than k-1\\'th\\n        if self.max_h and (-score, name) < (-self.max_h[0].score, self.max_h[0].name):\\n            x = heapq.heappop(self.max_h)\\n            heapq.heappush(self.min_h, (-x.score, x.name))\\n            heapq.heappush(self.max_h, MaxHeapNode(score, name))\\n        else:\\n            heapq.heappush(self.min_h, (-score, name))\\n\\n    def get(self) -> str:\\n        x = heapq.heappop(self.min_h)\\n        heapq.heappush(self.max_h, MaxHeapNode(-x[0], x[1]))\\n        return x[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907859,
                "title": "c-2-heaps-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCannot perform sorting every time get() is called and return the ith best location, \"time limit exceeded\".\\n\\nSo, maintain the order of two part of the sorted list. \\n```[from the best to ith best(1)] + [from ith - 1 best to last location(2)]```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOh, so use two heaps to simulate the two sorted parts. Update every time the min value at (1) is < max value at (2). Swap them.\\n\\nThe final outcome should be like:\\n```[(1): from best --> ith min] + [(2): follows (1)\\'s min --> global min value] = a sorted array...```\\n\\n```...and for the first element of (2) (follows (1)\\'s min) = MAX of (2)...```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(N)) for each heap search and insertion.\\nWorse case time complexity can be O(Nlog(N))...? \\n\\nBut that\\'s better that perform sorting every time a new value is added, such time complexity = O(N^2log(N)) --> somewhat between the time needed to perform 2 to 3 for-loops = time limit exceeded.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N), I suppose.\\n# Code\\n```\\ntypedef pair<int, string> p;\\nclass minc {\\n    public:\\n       bool operator()(p& a, p& b){\\n           if(a.first > b.first ||\\n                (a.first == b.first && \\n                    a.second < b.second)){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\nclass maxc {\\n    public:\\n       bool operator()(p& a, p& b){\\n           if(a.first < b.first ||\\n                (a.first == b.first && \\n                    a.second > b.second)){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass SORTracker {\\npublic:\\n    std::priority_queue<p, vector<p>, maxc> maxh;\\n    std::priority_queue<p, vector<p>, minc> minh;\\n    int getcnt;\\n    bool isLarger(p& a, p& b) {\\n        if (a.first > b.first ||\\n            (a.first == b.first && \\n                a.second < b.second))\\n                return true;\\n        return false;\\n    }\\n    SORTracker() {\\n        maxh = {};\\n        minh = {};\\n        getcnt = 1;        \\n    }\\n    \\n    void add(string name, int score) {\\n        if (minh.size() < getcnt) {\\n            minh.push({score, name});\\n        }\\n        else {\\n            maxh.push({score, name});\\n            p cmin = minh.top();\\n            p cmax = maxh.top();\\n            while (isLarger(cmax, cmin)) {\\n                minh.pop();\\n                maxh.pop();\\n                minh.push(cmax);\\n                maxh.push(cmin);\\n                cmin = minh.top();\\n                cmax = maxh.top();\\n            }\\n        }\\n    }\\n    \\n    string get() {\\n        p res = minh.top();\\n        p cmax, cmin;\\n        if (maxh.size() > 0) {\\n            cmax = maxh.top();\\n            maxh.pop();\\n            minh.push(cmax);\\n        }\\n        if (maxh.size() > 0) {\\n            cmin = minh.top();\\n            cmax = maxh.top();\\n            while (isLarger(cmax, cmin)) {\\n                minh.pop();\\n                maxh.pop();\\n                minh.push(cmax);\\n                maxh.push(cmin);\\n                cmin = minh.top();\\n                cmax = maxh.top();\\n            }\\n        }\\n        getcnt++;\\n        return res.second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```[from the best to ith best(1)] + [from ith - 1 best to last location(2)]```\n```[(1): from best --> ith min] + [(2): follows (1)\\'s min --> global min value] = a sorted array...```\n```...and for the first element of (2) (follows (1)\\'s min) = MAX of (2)...```\n```\\ntypedef pair<int, string> p;\\nclass minc {\\n    public:\\n       bool operator()(p& a, p& b){\\n           if(a.first > b.first ||\\n                (a.first == b.first && \\n                    a.second < b.second)){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\nclass maxc {\\n    public:\\n       bool operator()(p& a, p& b){\\n           if(a.first < b.first ||\\n                (a.first == b.first && \\n                    a.second > b.second)){\\n               return true;\\n           }\\n           return false;\\n      }\\n};\\n\\nclass SORTracker {\\npublic:\\n    std::priority_queue<p, vector<p>, maxc> maxh;\\n    std::priority_queue<p, vector<p>, minc> minh;\\n    int getcnt;\\n    bool isLarger(p& a, p& b) {\\n        if (a.first > b.first ||\\n            (a.first == b.first && \\n                a.second < b.second))\\n                return true;\\n        return false;\\n    }\\n    SORTracker() {\\n        maxh = {};\\n        minh = {};\\n        getcnt = 1;        \\n    }\\n    \\n    void add(string name, int score) {\\n        if (minh.size() < getcnt) {\\n            minh.push({score, name});\\n        }\\n        else {\\n            maxh.push({score, name});\\n            p cmin = minh.top();\\n            p cmax = maxh.top();\\n            while (isLarger(cmax, cmin)) {\\n                minh.pop();\\n                maxh.pop();\\n                minh.push(cmax);\\n                maxh.push(cmin);\\n                cmin = minh.top();\\n                cmax = maxh.top();\\n            }\\n        }\\n    }\\n    \\n    string get() {\\n        p res = minh.top();\\n        p cmax, cmin;\\n        if (maxh.size() > 0) {\\n            cmax = maxh.top();\\n            maxh.pop();\\n            minh.push(cmax);\\n        }\\n        if (maxh.size() > 0) {\\n            cmin = minh.top();\\n            cmax = maxh.top();\\n            while (isLarger(cmax, cmin)) {\\n                minh.pop();\\n                maxh.pop();\\n                minh.push(cmax);\\n                maxh.push(cmin);\\n                cmin = minh.top();\\n                cmax = maxh.top();\\n            }\\n        }\\n        getcnt++;\\n        return res.second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890743,
                "title": "python-100-faster-solution-with-proof",
                "content": "![image](https://assets.leetcode.com/users/images/762f9bfa-6ca6-4cad-83c5-df22485216e4_1670499854.9837372.png)\\n\\t\\n\\tfrom sortedcontainers import SortedList\\n\\tclass SORTracker:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.cnt = 0\\n\\t\\t\\tself.lst = SortedList()\\n\\n\\t\\tdef add(self, name: str, score: int) -> None:\\n\\t\\t\\tself.lst.add((-score,name))\\n\\n\\t\\tdef get(self) -> str:\\n\\t\\t\\tself.cnt+=1\\n\\t\\t\\treturn self.lst[self.cnt-1][1]\\n\\n\\n\\t# Your SORTracker object will be instantiated and called as such:\\n\\t# obj = SORTracker()\\n\\t# obj.add(name,score)\\n\\t# param_2 = obj.get()",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/762f9bfa-6ca6-4cad-83c5-df22485216e4_1670499854.9837372.png)\\n\\t\\n\\tfrom sortedcontainers import SortedList\\n\\tclass SORTracker:\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.cnt = 0\\n\\t\\t\\tself.lst = SortedList()\\n\\n\\t\\tdef add(self, name: str, score: int) -> None:\\n\\t\\t\\tself.lst.add((-score,name))\\n\\n\\t\\tdef get(self) -> str:\\n\\t\\t\\tself.cnt+=1\\n\\t\\t\\treturn self.lst[self.cnt-1][1]\\n\\n\\n\\t# Your SORTracker object will be instantiated and called as such:\\n\\t# obj = SORTracker()\\n\\t# obj.add(name,score)\\n\\t# param_2 = obj.get()",
                "codeTag": "Java"
            },
            {
                "id": 2889597,
                "title": "python-easiest-4-lines-code-solution",
                "content": "# Code\\n```\\nclass SORTracker(object):\\n    def __init__(self):\\n        self.data, self.i = [], -1\\n\\n    def add(self, name, score):\\n        bisect.insort(self.data, (-score, name))\\n\\n    def get(self):\\n        self.i += 1\\n        return self.data[self.i][1]\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Code\\n```\\nclass SORTracker(object):\\n    def __init__(self):\\n        self.data, self.i = [], -1\\n\\n    def add(self, name, score):\\n        bisect.insort(self.data, (-score, name))\\n\\n    def get(self):\\n        self.i += 1\\n        return self.data[self.i][1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2849834,
                "title": "javascript-solution-with-binary-search",
                "content": "```\\nvar SORTracker = function() {\\n    this.count = 0;\\n    // sort by score first and name second\\n    this.scoreArr = [];\\n};\\n\\n/** \\n * @param {string} name \\n * @param {number} score\\n * @return {void}\\n */\\nSORTracker.prototype.add = function(name, score) {\\n    let scoreArr = this.scoreArr;\\n    if(scoreArr.length === 0){\\n        scoreArr.push([score, name]);\\n    }else{\\n        let left = 0;\\n        let right = scoreArr.length-1;\\n        // binary search find the index to insert\\n        while(left < right){\\n            let mid = Math.floor((left+right)/2);\\n            let flag = check([score, name], scoreArr[mid]);\\n            if(flag){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        // compore the right\\n        if(left === right){\\n            if(score === scoreArr[right][0]){\\n                if(name > scoreArr[right][1]){\\n                    left = right+1;\\n                }\\n            }else{\\n                if(score < scoreArr[right][0]){\\n                    left = right+1;\\n                }\\n            }\\n        }\\n        // insert the new element\\n        scoreArr.splice(left, 0, [score, name]);\\n    }\\n\\n    this.scoreArr = scoreArr;\\n};\\n\\n/**\\n * @return {string}\\n */\\nSORTracker.prototype.get = function() {\\n    let res = \\'\\';\\n    let count = this.count;\\n    let scoreArr = this.scoreArr;\\n    count ++;\\n    let r = scoreArr[count-1];\\n    res = r[1];\\n\\n    this.count = count;\\n\\n    return res;\\n};\\n\\nfunction check(arr1, arr2){\\n    let res = true;\\n    if(arr1[0] === arr2[0]){\\n        if(arr1[1] > arr2[1]){\\n            res = false;\\n        }else{\\n            res = true;\\n        }\\n    }else{\\n        if(arr1[0] > arr2[0]){\\n            res = true;\\n        }else{\\n            res = false;\\n        }\\n    }\\n    return res;\\n}\\n\\n/** \\n * Your SORTracker object will be instantiated and called as such:\\n * var obj = new SORTracker()\\n * obj.add(name,score)\\n * var param_2 = obj.get()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nvar SORTracker = function() {\\n    this.count = 0;\\n    // sort by score first and name second\\n    this.scoreArr = [];\\n};\\n\\n/** \\n * @param {string} name \\n * @param {number} score\\n * @return {void}\\n */\\nSORTracker.prototype.add = function(name, score) {\\n    let scoreArr = this.scoreArr;\\n    if(scoreArr.length === 0){\\n        scoreArr.push([score, name]);\\n    }else{\\n        let left = 0;\\n        let right = scoreArr.length-1;\\n        // binary search find the index to insert\\n        while(left < right){\\n            let mid = Math.floor((left+right)/2);\\n            let flag = check([score, name], scoreArr[mid]);\\n            if(flag){\\n                right = mid;\\n            }else{\\n                left = mid+1;\\n            }\\n        }\\n        // compore the right\\n        if(left === right){\\n            if(score === scoreArr[right][0]){\\n                if(name > scoreArr[right][1]){\\n                    left = right+1;\\n                }\\n            }else{\\n                if(score < scoreArr[right][0]){\\n                    left = right+1;\\n                }\\n            }\\n        }\\n        // insert the new element\\n        scoreArr.splice(left, 0, [score, name]);\\n    }\\n\\n    this.scoreArr = scoreArr;\\n};\\n\\n/**\\n * @return {string}\\n */\\nSORTracker.prototype.get = function() {\\n    let res = \\'\\';\\n    let count = this.count;\\n    let scoreArr = this.scoreArr;\\n    count ++;\\n    let r = scoreArr[count-1];\\n    res = r[1];\\n\\n    this.count = count;\\n\\n    return res;\\n};\\n\\nfunction check(arr1, arr2){\\n    let res = true;\\n    if(arr1[0] === arr2[0]){\\n        if(arr1[1] > arr2[1]){\\n            res = false;\\n        }else{\\n            res = true;\\n        }\\n    }else{\\n        if(arr1[0] > arr2[0]){\\n            res = true;\\n        }else{\\n            res = false;\\n        }\\n    }\\n    return res;\\n}\\n\\n/** \\n * Your SORTracker object will be instantiated and called as such:\\n * var obj = new SORTracker()\\n * obj.add(name,score)\\n * var param_2 = obj.get()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839701,
                "title": "c-short-and-easy-beats-70-time-set-of-pairs",
                "content": "```\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> data;\\n    set<pair<int, string>>::iterator pos;\\n    \\n    SORTracker() {\\n        pos = data.end(); \\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int,string> upd = {-score, name};\\n        if (pos == data.end()) {\\n            data.insert(upd);\\n            --pos;\\n        }\\n        else if (upd < *pos) {\\n            data.insert(upd);\\n            --pos;\\n        }\\n        else data.insert(upd);\\n    }\\n    \\n    string get() {\\n        string ans = pos->second;\\n        ++pos;\\n        return ans;  \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\n    set<pair<int, string>> data;\\n    set<pair<int, string>>::iterator pos;\\n    \\n    SORTracker() {\\n        pos = data.end(); \\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int,string> upd = {-score, name};\\n        if (pos == data.end()) {\\n            data.insert(upd);\\n            --pos;\\n        }\\n        else if (upd < *pos) {\\n            data.insert(upd);\\n            --pos;\\n        }\\n        else data.insert(upd);\\n    }\\n    \\n    string get() {\\n        string ans = pos->second;\\n        ++pos;\\n        return ans;  \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2809904,
                "title": "2-priority-queue-easy-and-undertandable-code-with-comments",
                "content": "~~~\\nclass sorted{\\n    public:\\n    bool operator()(pair<string,int>a ,pair<string,int>b)\\n    {\\n        if(a.second==b.second)\\n            return a.first>b.first;\\n        return a.second<b.second;\\n    }\\n};\\n// It is used as comparator class to make max-heap.\\nclass revsorted{\\n    public:\\n    bool operator()(pair<string,int>a ,pair<string,int>b)\\n    {\\n        if(a.second==b.second)\\n            return a.first<b.first;\\n        return a.second>b.second;\\n    }\\n};\\n// It is used as comparator class to make min-heap.\\nclass SORTracker {\\n    int c=1; \\n\\t//counter . It is initialsed to 1 and we will increase it whenever we make a get() call.\\npublic:\\n    \\n    priority_queue<pair<string,int> , vector<pair<string,int>> , sorted>maxi;\\n    priority_queue<pair<string,int> , vector<pair<string,int>> , revsorted>mini;\\n\\t//Made max and min heaps. Minheap.top() will contain our answer.\\n    //Its size will be equal to counter.\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        mini.push({name,score});\\n\\t\\t// We will push the newly added string to min heap.\\n        if(mini.size()>c)\\n        {\\n            auto it=mini.top();\\n            mini.pop();\\n            maxi.push(it);\\n        }\\n\\t\\t//If the size of min heap exceeds the counter we will pop the element \\n\\t\\t//and add to the max heap. This way we ensure the highest cth\\n\\t\\t//element is at the top of min heap.\\n    }\\n    \\n    string get() {\\n        if(mini.size()==0)return \"\";\\n        auto it=mini.top();\\n        if(maxi.size()!=0){\\n            mini.push(maxi.top());\\n            maxi.pop();\\n        }\\n        c++;\\n        return it.first;\\n        // Now whenever we get a element the top of min heap contains our answer. \\n\\t\\t//We now need to increase the counter size as well because we need to find\\n\\t\\t//the cth highest scored element form now onwards. \\n\\t\\t//So we will push the max.top() element in min heap  and continue this process.\\n    }\\n};\\n\\n~~~\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "~~~\\nclass sorted{\\n    public:\\n    bool operator()(pair<string,int>a ,pair<string,int>b)\\n    {\\n        if(a.second==b.second)\\n            return a.first>b.first;\\n        return a.second<b.second;\\n    }\\n};\\n// It is used as comparator class to make max-heap.\\nclass revsorted{\\n    public:\\n    bool operator()(pair<string,int>a ,pair<string,int>b)\\n    {\\n        if(a.second==b.second)\\n            return a.first<b.first;\\n        return a.second>b.second;\\n    }\\n};\\n// It is used as comparator class to make min-heap.\\nclass SORTracker {\\n    int c=1; \\n\\t//counter . It is initialsed to 1 and we will increase it whenever we make a get() call.\\npublic:\\n    \\n    priority_queue<pair<string,int> , vector<pair<string,int>> , sorted>maxi;\\n    priority_queue<pair<string,int> , vector<pair<string,int>> , revsorted>mini;\\n\\t//Made max and min heaps. Minheap.top() will contain our answer.\\n    //Its size will be equal to counter.\\n    SORTracker() {\\n    }\\n    \\n    void add(string name, int score) {\\n        mini.push({name,score});\\n\\t\\t// We will push the newly added string to min heap.\\n        if(mini.size()>c)\\n        {\\n            auto it=mini.top();\\n            mini.pop();\\n            maxi.push(it);\\n        }\\n\\t\\t//If the size of min heap exceeds the counter we will pop the element \\n\\t\\t//and add to the max heap. This way we ensure the highest cth\\n\\t\\t//element is at the top of min heap.\\n    }\\n    \\n    string get() {\\n        if(mini.size()==0)return \"\";\\n        auto it=mini.top();\\n        if(maxi.size()!=0){\\n            mini.push(maxi.top());\\n            maxi.pop();\\n        }\\n        c++;\\n        return it.first;\\n        // Now whenever we get a element the top of min heap contains our answer. \\n\\t\\t//We now need to increase the counter size as well because we need to find\\n\\t\\t//the cth highest scored element form now onwards. \\n\\t\\t//So we will push the max.top() element in min heap  and continue this process.\\n    }\\n};\\n\\n~~~\\n",
                "codeTag": "Java"
            },
            {
                "id": 2806600,
                "title": "python-sorted-lists",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n    def __init__(self):\\n        self.q, self.c= SortedList(), 0\\n        \\n    def add(self, name: str, score: int) -> None:\\n        self.q.add((-score, name))\\n\\n    def get(self) -> str:\\n        v = self.q[self.c][1]\\n        self.c+=1\\n        return v\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n    def __init__(self):\\n        self.q, self.c= SortedList(), 0\\n        \\n    def add(self, name: str, score: int) -> None:\\n        self.q.add((-score, name))\\n\\n    def get(self) -> str:\\n        v = self.q[self.c][1]\\n        self.c+=1\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805496,
                "title": "simple-c-solution-using-ordered-set-pbds",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\nstruct comp_fx\\n{\\n    bool operator()(const pair<int,string> &a, const pair<int,string> &b)\\n    {\\n\\n        if(a.first==b.first){\\n            return a.second<b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n};\\n\\n #define ordered_set tree<pair<int,string>, null_type,comp_fx, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass SORTracker {\\npublic:\\n    int ct = 0;\\n    \\n    ordered_set st;\\n    \\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        st.insert({score ,name});\\n    }\\n    \\n    string get() {\\n        auto ans = *st.find_by_order(ct);\\n        ct++;\\n        return ans.second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\nstruct comp_fx\\n{\\n    bool operator()(const pair<int,string> &a, const pair<int,string> &b)\\n    {\\n\\n        if(a.first==b.first){\\n            return a.second<b.second;\\n        }\\n        return a.first > b.first;\\n    }\\n};\\n\\n #define ordered_set tree<pair<int,string>, null_type,comp_fx, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass SORTracker {\\npublic:\\n    int ct = 0;\\n    \\n    ordered_set st;\\n    \\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        st.insert({score ,name});\\n    }\\n    \\n    string get() {\\n        auto ans = *st.find_by_order(ct);\\n        ct++;\\n        return ans.second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2796392,
                "title": "ordered-set-pbds-c",
                "content": "If you have any doubts or suggestions please let me know in comment section.\\nDont forget to upvote the solution\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate<class T>\\nclass Comp{\\n    public:\\n    bool operator()(const T&a,const T&b){\\n        if(a.second==b.second){\\n            return a.first<b.first;\\n        }\\n        return a.second>b.second;\\n    }\\n};\\n\\nclass SORTracker {\\npublic:\\n    tree<pair<string,int>,null_type,Comp<pair<string,int>>,rb_tree_tag,tree_order_statistics_node_update>pbds;\\n    int i=0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        pbds.insert({name,score});\\n    }\\n    \\n    string get() {\\n        auto ans=*pbds.find_by_order(i++);\\n        return ans.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntemplate<class T>\\nclass Comp{\\n    public:\\n    bool operator()(const T&a,const T&b){\\n        if(a.second==b.second){\\n            return a.first<b.first;\\n        }\\n        return a.second>b.second;\\n    }\\n};\\n\\nclass SORTracker {\\npublic:\\n    tree<pair<string,int>,null_type,Comp<pair<string,int>>,rb_tree_tag,tree_order_statistics_node_update>pbds;\\n    int i=0;\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        pbds.insert({name,score});\\n    }\\n    \\n    string get() {\\n        auto ans=*pbds.find_by_order(i++);\\n        return ans.first;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2790854,
                "title": "javascript-minheap-maxheap",
                "content": "```\\nclass SORTracker {\\n  constructor() {\\n    this.maxHeap = new Heap(this.maxSort);\\n    this.minHeap = new Heap(this.minSort);\\n  }\\n\\n  add(max, score) {\\n    this.minHeap.insert([max, score]);\\n    const val = this.minHeap.remove();\\n    this.maxHeap.insert(val);\\n  }\\n\\n  get() {\\n    const val = this.maxHeap.remove();\\n    this.minHeap.insert(val);\\n    return val[0];\\n  }\\n\\n  maxSort(a, b) {\\n    if (a[1] === b[1]) {\\n      return a[0] < b[0];\\n    }\\n    return a[1] > b[1];\\n  }\\n\\n  minSort(a, b) {\\n    if (a[1] === b[1]) {\\n      return a[0] > b[0];\\n    }\\n    return a[1] < b[1];\\n  }\\n}\\n```\\n[Heap Link](https://github.com/faustaleonardo/data-structure-in-js/blob/main/Heap.js)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker {\\n  constructor() {\\n    this.maxHeap = new Heap(this.maxSort);\\n    this.minHeap = new Heap(this.minSort);\\n  }\\n\\n  add(max, score) {\\n    this.minHeap.insert([max, score]);\\n    const val = this.minHeap.remove();\\n    this.maxHeap.insert(val);\\n  }\\n\\n  get() {\\n    const val = this.maxHeap.remove();\\n    this.minHeap.insert(val);\\n    return val[0];\\n  }\\n\\n  maxSort(a, b) {\\n    if (a[1] === b[1]) {\\n      return a[0] < b[0];\\n    }\\n    return a[1] > b[1];\\n  }\\n\\n  minSort(a, b) {\\n    if (a[1] === b[1]) {\\n      return a[0] > b[0];\\n    }\\n    return a[1] < b[1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771779,
                "title": "java-17-o-log-n-add-get-clean-treeset",
                "content": "```\\n    class SORTracker {\\n        public record Location(String name, int score){}\\n\\n        private final TreeSet<Location> set;\\n        private final Comparator<Location> scoreAndNameComparator;\\n        private Location bestIthLocation;\\n\\n        // O(1)\\n        public SORTracker() {\\n            scoreAndNameComparator = Comparator.comparing(Location::score, Comparator.reverseOrder())\\n                    .thenComparing(Location::name);\\n            set = new TreeSet<>(scoreAndNameComparator);\\n            bestIthLocation = null;\\n        }\\n\\n        // O(log(n))\\n        public void add(String name, int score) {\\n            var newLocation = new Location(name, score);\\n            set.add(newLocation);\\n            if (bestIthLocation == null) {\\n                bestIthLocation = set.last();\\n            } else {\\n                int comparison = scoreAndNameComparator.compare(bestIthLocation, newLocation);\\n                if (comparison < 0 ) {\\n                    set.lower(bestIthLocation);\\n                }\\n            }\\n        }\\n\\n        // O(log(n))\\n        public String get() {\\n            var toReturn = bestIthLocation;\\n            bestIthLocation = set.higher(bestIthLocation);\\n            return toReturn.name;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\n    class SORTracker {\\n        public record Location(String name, int score){}\\n\\n        private final TreeSet<Location> set;\\n        private final Comparator<Location> scoreAndNameComparator;\\n        private Location bestIthLocation;\\n\\n        // O(1)\\n        public SORTracker() {\\n            scoreAndNameComparator = Comparator.comparing(Location::score, Comparator.reverseOrder())\\n                    .thenComparing(Location::name);\\n            set = new TreeSet<>(scoreAndNameComparator);\\n            bestIthLocation = null;\\n        }\\n\\n        // O(log(n))\\n        public void add(String name, int score) {\\n            var newLocation = new Location(name, score);\\n            set.add(newLocation);\\n            if (bestIthLocation == null) {\\n                bestIthLocation = set.last();\\n            } else {\\n                int comparison = scoreAndNameComparator.compare(bestIthLocation, newLocation);\\n                if (comparison < 0 ) {\\n                    set.lower(bestIthLocation);\\n                }\\n            }\\n        }\\n\\n        // O(log(n))\\n        public String get() {\\n            var toReturn = bestIthLocation;\\n            bestIthLocation = set.higher(bestIthLocation);\\n            return toReturn.name;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752795,
                "title": "tle-to-accepted-binary-search-to-find-insertion-index-two-different-approaches",
                "content": "**Accepted Approach : Clean Code at the end of this post**\\n\\n```\\nTime Limit Exceeded\\n```\\n\\n```\\nclass SORTracker {\\n\\n    // holds all locations name from best to worst\\n    // keys are soreted based on score, using score stores on \\'scores\\' map\\n    private TreeSet<String> locs;\\n    \\n    // location_name -> score\\n    private Map<String, Integer> scores;\\n    \\n\\t// To keep track of query count\\n    private int getCnt;\\n    \\n    public SORTracker() {\\n        locs = new TreeSet<>((a, b) -> {\\n            Integer score_a = scores.get(a), score_b = scores.get(b);\\n            if(score_a.equals(score_b)) return a.compareTo(b);\\n            return Integer.compare(score_b, score_a);\\n        });\\n        scores = new HashMap<>();\\n    }\\n    \\n    public void add(String name, int score) {\\n        scores.put(name, score);\\n        locs.add(name);\\n    }\\n    \\n    // when first time call : loop runs 1, then for second 2, 3, 4..... n\\n    // over-all (n * (n + 1)) / 2 , If locations count is (>=10^4) gets TLE guaranteed\\n    public String get() {\\n        getCnt += 1;\\n        int cnt = 0;\\n        // optimize this part, in order to get accepted\\n        for(String name : locs) {\\n            cnt += 1;\\n            if(cnt == getCnt) return name;\\n        }\\n        return \"-1\";\\n    }\\n}\\n```\\n\\n```\\nAccepted : Using TreeMap + Binary Search (to find insertion index of \\'location_name\\')\\n```\\n\\n```\\nclass SORTracker {\\n\\n    // score(key) --> [list_of_sorted_location_names_with_current_score(key)]\\n    private Map<Integer, List<String>> scores;\\n    \\n    // to keep track of query count\\n    private int getCnt;\\n    \\n    public SORTracker() {\\n        scores = new TreeMap<>((a, b) -> -Integer.compare(a, b));\\n    }\\n    \\n    public void add(String name, int score) {\\n        scores.putIfAbsent(score, new ArrayList<>());\\n        List<String> locNames = scores.get(score);\\n        int insertionIndex = getInsertionIndexUBinarySearch(locNames, name);\\n        locNames.add(insertionIndex, name);\\n    }\\n    \\n    public String get() {\\n\\t\\t // copy is 1 based indexing that\\'s why (copy - 1)\\n        getCnt += 1; int copy = getCnt;\\n        for(int score : scores.keySet()) {\\n            List<String> locs = scores.get(score);\\n            if(copy <= locs.size())\\n                return locs.get(copy - 1);\\n            else\\n                copy -= locs.size();\\n        }\\n        return \"-1\";\\n    }\\n    \\n    /*\\n        Leftmost Binary Search [Important Points]\\n        =========================================\\n        \\n        If the element exists, find its leftmost index\\n        If it doesn\\'t exists, locate the index of where it should be\\n        (i.e., find insertion index)\\n        \\n    */\\n    private int getInsertionIndexUBinarySearch_(List<String> locs, String name) {\\n        int left = 0, right = locs.size();\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            int compResult = locs.get(mid).compareTo(name);\\n            if(compResult < 0)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n    \\n    // Using Traditional Syntax of Binary Search (Serve Same Purpose As Above One)\\n    private int getInsertionIndexUBinarySearch(List<String> locs, String name) {\\n        int left = 0, right = locs.size() - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int compResult = locs.get(mid).compareTo(name);\\n            if(compResult < 0)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n```\\nClean Code : Last Approach\\n```\\n\\n```\\nclass SORTracker {\\n    private Map<Integer, List<String>> scores;\\n    private int getCnt;\\n    \\n    public SORTracker() {\\n        scores = new TreeMap<>((a, b) -> -Integer.compare(a, b));\\n    }\\n    \\n    public void add(String name, int score) {\\n        scores.putIfAbsent(score, new ArrayList<>());\\n        List<String> locNames = scores.get(score);\\n        int insertionIndex = getInsertionIndexUBinarySearch(locNames, name);\\n        locNames.add(insertionIndex, name);\\n    }\\n    \\n    public String get() {\\n        getCnt += 1; int copy = getCnt;\\n        for(int score : scores.keySet()) {\\n            List<String> locs = scores.get(score);\\n            if(copy <= locs.size())\\n                return locs.get(copy - 1);\\n            else\\n                copy -= locs.size();\\n        }\\n        return \"-1\";\\n    }\\n    \\n    private int getInsertionIndexUBinarySearch(List<String> locs, String name) {\\n        int left = 0, right = locs.size() - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int compResult = locs.get(mid).compareTo(name);\\n            if(compResult < 0)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\\n\\n*If you like the idea and found something new to learn from this post then do upvote my solution*",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nTime Limit Exceeded\\n```\n```\\nclass SORTracker {\\n\\n    // holds all locations name from best to worst\\n    // keys are soreted based on score, using score stores on \\'scores\\' map\\n    private TreeSet<String> locs;\\n    \\n    // location_name -> score\\n    private Map<String, Integer> scores;\\n    \\n\\t// To keep track of query count\\n    private int getCnt;\\n    \\n    public SORTracker() {\\n        locs = new TreeSet<>((a, b) -> {\\n            Integer score_a = scores.get(a), score_b = scores.get(b);\\n            if(score_a.equals(score_b)) return a.compareTo(b);\\n            return Integer.compare(score_b, score_a);\\n        });\\n        scores = new HashMap<>();\\n    }\\n    \\n    public void add(String name, int score) {\\n        scores.put(name, score);\\n        locs.add(name);\\n    }\\n    \\n    // when first time call : loop runs 1, then for second 2, 3, 4..... n\\n    // over-all (n * (n + 1)) / 2 , If locations count is (>=10^4) gets TLE guaranteed\\n    public String get() {\\n        getCnt += 1;\\n        int cnt = 0;\\n        // optimize this part, in order to get accepted\\n        for(String name : locs) {\\n            cnt += 1;\\n            if(cnt == getCnt) return name;\\n        }\\n        return \"-1\";\\n    }\\n}\\n```\n```\\nAccepted : Using TreeMap + Binary Search (to find insertion index of \\'location_name\\')\\n```\n```\\nclass SORTracker {\\n\\n    // score(key) --> [list_of_sorted_location_names_with_current_score(key)]\\n    private Map<Integer, List<String>> scores;\\n    \\n    // to keep track of query count\\n    private int getCnt;\\n    \\n    public SORTracker() {\\n        scores = new TreeMap<>((a, b) -> -Integer.compare(a, b));\\n    }\\n    \\n    public void add(String name, int score) {\\n        scores.putIfAbsent(score, new ArrayList<>());\\n        List<String> locNames = scores.get(score);\\n        int insertionIndex = getInsertionIndexUBinarySearch(locNames, name);\\n        locNames.add(insertionIndex, name);\\n    }\\n    \\n    public String get() {\\n\\t\\t // copy is 1 based indexing that\\'s why (copy - 1)\\n        getCnt += 1; int copy = getCnt;\\n        for(int score : scores.keySet()) {\\n            List<String> locs = scores.get(score);\\n            if(copy <= locs.size())\\n                return locs.get(copy - 1);\\n            else\\n                copy -= locs.size();\\n        }\\n        return \"-1\";\\n    }\\n    \\n    /*\\n        Leftmost Binary Search [Important Points]\\n        =========================================\\n        \\n        If the element exists, find its leftmost index\\n        If it doesn\\'t exists, locate the index of where it should be\\n        (i.e., find insertion index)\\n        \\n    */\\n    private int getInsertionIndexUBinarySearch_(List<String> locs, String name) {\\n        int left = 0, right = locs.size();\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            int compResult = locs.get(mid).compareTo(name);\\n            if(compResult < 0)\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return left;\\n    }\\n    \\n    // Using Traditional Syntax of Binary Search (Serve Same Purpose As Above One)\\n    private int getInsertionIndexUBinarySearch(List<String> locs, String name) {\\n        int left = 0, right = locs.size() - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int compResult = locs.get(mid).compareTo(name);\\n            if(compResult < 0)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```\n```\\nClean Code : Last Approach\\n```\n```\\nclass SORTracker {\\n    private Map<Integer, List<String>> scores;\\n    private int getCnt;\\n    \\n    public SORTracker() {\\n        scores = new TreeMap<>((a, b) -> -Integer.compare(a, b));\\n    }\\n    \\n    public void add(String name, int score) {\\n        scores.putIfAbsent(score, new ArrayList<>());\\n        List<String> locNames = scores.get(score);\\n        int insertionIndex = getInsertionIndexUBinarySearch(locNames, name);\\n        locNames.add(insertionIndex, name);\\n    }\\n    \\n    public String get() {\\n        getCnt += 1; int copy = getCnt;\\n        for(int score : scores.keySet()) {\\n            List<String> locs = scores.get(score);\\n            if(copy <= locs.size())\\n                return locs.get(copy - 1);\\n            else\\n                copy -= locs.size();\\n        }\\n        return \"-1\";\\n    }\\n    \\n    private int getInsertionIndexUBinarySearch(List<String> locs, String name) {\\n        int left = 0, right = locs.size() - 1;\\n        while(left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int compResult = locs.get(mid).compareTo(name);\\n            if(compResult < 0)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723886,
                "title": "heap-based-javascript-solution",
                "content": "```\\n//HEAP class in Javascript\\nclass Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                if(a[1]!==b[1]){\\n                    return b[1]-a[1];\\n                }\\n                for(let i=0;i<Math.min(a[0].length,b[0].length);i++){\\n                    if(a[0].charCodeAt(i)!=b[0].charCodeAt(i)){\\n                        return a[0].charCodeAt(i)-b[0].charCodeAt(i);\\n                    }\\n                }\\n                return a[0].length-b[0].length;\\n            }else{\\n                if(a[1]!==b[1]){\\n                    return a[1]-b[1];\\n                }\\n                for(let i=0;i<Math.min(a[0].length,b[0].length);i++){\\n                    if(a[0].charCodeAt(i)!=b[0].charCodeAt(i)){\\n                        return b[0].charCodeAt(i)-a[0].charCodeAt(i);\\n                    }\\n                }\\n                return b[0].length-a[0].length;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n\\nvar SORTracker = function() {\\n    this.index = 1;\\n    this.leftHeap = new Heap(\\'min\\');\\n    this.rightHeap = new Heap(\\'max\\');\\n};\\n\\nSORTracker.prototype.compare = function (a,b){\\n    if(a[1]!==b[1]){\\n        return a[1]-b[1];\\n    }\\n    for(let i=0;i<Math.min(a[0].length,b[0].length);i++){\\n        if(a[0].charCodeAt(i)!=b[0].charCodeAt(i)){\\n            return b[0].charCodeAt(i)-a[0].charCodeAt(i);\\n        }\\n    }\\n    return b[0].length-a[0].length;\\n}\\n\\n/** \\n * @param {string} name \\n * @param {number} score\\n * @return {void}\\n */\\nSORTracker.prototype.add = function(name, score) {\\n    if(this.leftHeap.getSize()===0){\\n        this.leftHeap.insert([name,score]);\\n    }else{\\n        let topLeft = this.leftHeap.getTop();\\n        if(this.compare([name,score],topLeft)<0){//new element is smaller than the smallest element on the left \\n            this.rightHeap.insert([name,score]);\\n        }else{\\n            this.leftHeap.insert([name,score]);\\n        }\\n        if(this.leftHeap.getSize()<this.index){\\n            let rightTop = this.rightHeap.removeTop();\\n            this.leftHeap.insert(rightTop);\\n        }else if(this.leftHeap.getSize()>this.index){\\n            let leftTop = this.leftHeap.removeTop();\\n            this.rightHeap.insert(leftTop);\\n        }\\n    }\\n};\\n\\n/**\\n * @return {string}\\n */\\nSORTracker.prototype.get = function() {\\n    let topLeft = this.leftHeap.getTop();\\n    this.index++;\\n    if(this.rightHeap.getSize()>0){\\n        let rightTop = this.rightHeap.removeTop();\\n        this.leftHeap.insert(rightTop);\\n    }\\n    return topLeft[0];\\n};\\n\\n/** \\n * Your SORTracker object will be instantiated and called as such:\\n * var obj = new SORTracker()\\n * obj.add(name,score)\\n * var param_2 = obj.get()\\n */\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//HEAP class in Javascript\\nclass Heap{\\n        constructor(type){\\n            this.type = type;\\n            this.data = [];\\n            this.data[0] = undefined;\\n        }\\n        print(){\\n            for(let i=1;i<this.data.length;i++){\\n                console.log(this.data[i])\\n            }\\n        }\\n        getSize(){\\n            return this.data.length-1;\\n        }\\n        insert(value){\\n            this.data.push(value);\\n            if(this.data.length==2){\\n                return ;\\n            }\\n            let lastIndex = this.data.length-1;\\n            while(this.data[Math.floor(lastIndex/2)]!==undefined && this.compare(this.data[lastIndex],this.data[Math.floor(lastIndex/2)])>0){\\n                let temp = this.data[Math.floor(lastIndex/2)];\\n                this.data[Math.floor(lastIndex/2)] = this.data[lastIndex];\\n                this.data[lastIndex] = temp;\\n                lastIndex = Math.floor(lastIndex/2);\\n            }\\n        }\\n        //This returns a positive number if a is greater than b. Here meaing of being greater depends on the type of heap. For max heap it will return positive number if a>b and for min heap it will return positive number if a<b . \\n        compare(a,b){\\n            if(this.type===\"min\"){\\n                if(a[1]!==b[1]){\\n                    return b[1]-a[1];\\n                }\\n                for(let i=0;i<Math.min(a[0].length,b[0].length);i++){\\n                    if(a[0].charCodeAt(i)!=b[0].charCodeAt(i)){\\n                        return a[0].charCodeAt(i)-b[0].charCodeAt(i);\\n                    }\\n                }\\n                return a[0].length-b[0].length;\\n            }else{\\n                if(a[1]!==b[1]){\\n                    return a[1]-b[1];\\n                }\\n                for(let i=0;i<Math.min(a[0].length,b[0].length);i++){\\n                    if(a[0].charCodeAt(i)!=b[0].charCodeAt(i)){\\n                        return b[0].charCodeAt(i)-a[0].charCodeAt(i);\\n                    }\\n                }\\n                return b[0].length-a[0].length;\\n            }\\n        }\\n        removeTop(){\\n            let max = this.data[1];\\n            if(this.getSize()>1){\\n                this.data[1] = this.data.pop();\\n                this.heapify(1);\\n            }else{//If the size is 0 then just remove the element, no shifting and hipify will be applicable\\n                this.data.pop();\\n            }\\n            return max;\\n        }\\n        getTop(){\\n            let max = null;\\n            if(this.getSize()>=1){\\n                max = this.data[1];\\n            }\\n            return max;\\n        }\\n        heapify(pos){\\n            if(pos*2>this.data.length-1){\\n                //That means element at index \\'pos\\' is not having any child\\n                return;\\n            }\\n            if(\\n                (this.data[pos*2]!==undefined && this.compare(this.data[pos*2],this.data[pos])>0)\\n              || (this.data[pos*2+1]!==undefined && this.compare(this.data[pos*2+1],this.data[pos])>0)\\n              ){\\n                if(this.data[pos*2+1]===undefined || this.compare(this.data[pos*2+1],this.data[pos*2])<=0){\\n                    let temp = this.data[pos*2];\\n                    this.data[pos*2] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2);\\n                }else{\\n                    let temp = this.data[pos*2+1];\\n                    this.data[pos*2+1] = this.data[pos];\\n                    this.data[pos] = temp;\\n                    this.heapify(pos*2+1);\\n                }\\n            }\\n        }\\n    }\\n\\nvar SORTracker = function() {\\n    this.index = 1;\\n    this.leftHeap = new Heap(\\'min\\');\\n    this.rightHeap = new Heap(\\'max\\');\\n};\\n\\nSORTracker.prototype.compare = function (a,b){\\n    if(a[1]!==b[1]){\\n        return a[1]-b[1];\\n    }\\n    for(let i=0;i<Math.min(a[0].length,b[0].length);i++){\\n        if(a[0].charCodeAt(i)!=b[0].charCodeAt(i)){\\n            return b[0].charCodeAt(i)-a[0].charCodeAt(i);\\n        }\\n    }\\n    return b[0].length-a[0].length;\\n}\\n\\n/** \\n * @param {string} name \\n * @param {number} score\\n * @return {void}\\n */\\nSORTracker.prototype.add = function(name, score) {\\n    if(this.leftHeap.getSize()===0){\\n        this.leftHeap.insert([name,score]);\\n    }else{\\n        let topLeft = this.leftHeap.getTop();\\n        if(this.compare([name,score],topLeft)<0){//new element is smaller than the smallest element on the left \\n            this.rightHeap.insert([name,score]);\\n        }else{\\n            this.leftHeap.insert([name,score]);\\n        }\\n        if(this.leftHeap.getSize()<this.index){\\n            let rightTop = this.rightHeap.removeTop();\\n            this.leftHeap.insert(rightTop);\\n        }else if(this.leftHeap.getSize()>this.index){\\n            let leftTop = this.leftHeap.removeTop();\\n            this.rightHeap.insert(leftTop);\\n        }\\n    }\\n};\\n\\n/**\\n * @return {string}\\n */\\nSORTracker.prototype.get = function() {\\n    let topLeft = this.leftHeap.getTop();\\n    this.index++;\\n    if(this.rightHeap.getSize()>0){\\n        let rightTop = this.rightHeap.removeTop();\\n        this.leftHeap.insert(rightTop);\\n    }\\n    return topLeft[0];\\n};\\n\\n/** \\n * Your SORTracker object will be instantiated and called as such:\\n * var obj = new SORTracker()\\n * obj.add(name,score)\\n * var param_2 = obj.get()\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2709247,
                "title": "c-using-std-set-and-custom-comparator",
                "content": "# Intuition\\niterator denoting current element. Just decrement iterator when inserting better element \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPOP!\\n\\n# Code\\n```\\nauto cmp = [](auto &p1, auto &p2)->bool{\\n    if(p1.first!=p2.first)return p1.first>p2.first;\\n    return p1.second<p2.second;\\n};\\n\\nset<pair<int, string>, decltype(cmp)>s(cmp);\\n\\nclass SORTracker {\\n    set<pair<int, string>>::iterator it;\\npublic:\\n    SORTracker() {\\n        s.clear();\\n        it=s.end();\\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int, string>p = {score, name};\\n        s.insert(p);\\n        if(it==s.end()){\\n            it--;\\n        }\\n        else{\\n            pair<int, string>p2 = *it;\\n            if(cmp(p, p2))\\n                it--;\\n        }\\n    }\\n    \\n    string get() {\\n        auto &[score, name] = *it;\\n        it++;\\n        return name;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nauto cmp = [](auto &p1, auto &p2)->bool{\\n    if(p1.first!=p2.first)return p1.first>p2.first;\\n    return p1.second<p2.second;\\n};\\n\\nset<pair<int, string>, decltype(cmp)>s(cmp);\\n\\nclass SORTracker {\\n    set<pair<int, string>>::iterator it;\\npublic:\\n    SORTracker() {\\n        s.clear();\\n        it=s.end();\\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int, string>p = {score, name};\\n        s.insert(p);\\n        if(it==s.end()){\\n            it--;\\n        }\\n        else{\\n            pair<int, string>p2 = *it;\\n            if(cmp(p, p2))\\n                it--;\\n        }\\n    }\\n    \\n    string get() {\\n        auto &[score, name] = *it;\\n        it++;\\n        return name;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704575,
                "title": "c-min-max-heap",
                "content": "```\\nstruct cmp1 {\\n  bool operator() (pair<int, string>& a, pair<int, string>& b){\\n      if (a.first == b.first) {\\n          return a.second > b.second;\\n      }\\n      return a.first < b.first;\\n  }  \\n};\\n\\nstruct cmp2 {\\n  bool operator() (pair<int, string>& a, pair<int, string>& b){\\n      if (a.first == b.first) {\\n          return a.second < b.second;\\n      }\\n      return a.first > b.first;\\n  }  \\n};\\n\\nclass SORTracker {\\npublic:\\n    SORTracker() {\\n\\n    }\\n    \\n    void add(string name, int score) {\\n        if (myHeap1.empty() && myHeap2.empty()) {\\n            myHeap1.push({score, name});\\n        } else if (!myHeap2.empty() && (score > myHeap2.top().first || (score == myHeap2.top().first && name < myHeap2.top().second))) {\\n            myHeap1.push(myHeap2.top());\\n            myHeap2.pop();\\n            myHeap2.push({score, name});\\n        } else {\\n            myHeap1.push({score, name});\\n        }\\n    }\\n    \\n    string get() {\\n        string ans = myHeap1.top().second;\\n        myHeap2.push(myHeap1.top());\\n        myHeap1.pop();\\n        return ans;\\n    }\\nprivate:\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, cmp1> myHeap1;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, cmp2> myHeap2;\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct cmp1 {\\n  bool operator() (pair<int, string>& a, pair<int, string>& b){\\n      if (a.first == b.first) {\\n          return a.second > b.second;\\n      }\\n      return a.first < b.first;\\n  }  \\n};\\n\\nstruct cmp2 {\\n  bool operator() (pair<int, string>& a, pair<int, string>& b){\\n      if (a.first == b.first) {\\n          return a.second < b.second;\\n      }\\n      return a.first > b.first;\\n  }  \\n};\\n\\nclass SORTracker {\\npublic:\\n    SORTracker() {\\n\\n    }\\n    \\n    void add(string name, int score) {\\n        if (myHeap1.empty() && myHeap2.empty()) {\\n            myHeap1.push({score, name});\\n        } else if (!myHeap2.empty() && (score > myHeap2.top().first || (score == myHeap2.top().first && name < myHeap2.top().second))) {\\n            myHeap1.push(myHeap2.top());\\n            myHeap2.pop();\\n            myHeap2.push({score, name});\\n        } else {\\n            myHeap1.push({score, name});\\n        }\\n    }\\n    \\n    string get() {\\n        string ans = myHeap1.top().second;\\n        myHeap2.push(myHeap1.top());\\n        myHeap1.pop();\\n        return ans;\\n    }\\nprivate:\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, cmp1> myHeap1;\\n    priority_queue<pair<int, string>, vector<pair<int, string>>, cmp2> myHeap2;\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2676649,
                "title": "js-min-max-priorityqueue",
                "content": "```\\n\\nclass SORTracker {\\n  constructor() {\\n    this.maxPq = new MaxPriorityQueue({ compare: (a, b) => this.compare(a, b) });\\n    this.minPq = new MinPriorityQueue({ compare: (a, b) => this.compare(b, a) });\\n  }\\n  \\n  compare(a = 0, b = 0) {\\n    if (a[1] === b[1]) {\\n      return a[0].localeCompare(b[0]);\\n    }\\n\\n    return b[1] - a[1];\\n  }\\n  \\n  add(name, score) {\\n    const cur = [name, score];\\n    this.minPq.enqueue(cur);\\n    this.maxPq.enqueue(this.minPq.dequeue());\\n  }\\n  \\n  get() {\\n    const maxPeek = this.maxPq.dequeue();\\n    this.minPq.enqueue(maxPeek);\\n    return maxPeek[0];\\n  }\\n};\\n\\n/** \\n * Your SORTracker object will be instantiated and called as such:\\n * var obj = new SORTracker()\\n * obj.add(name,score)\\n * var param_2 = obj.get()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass SORTracker {\\n  constructor() {\\n    this.maxPq = new MaxPriorityQueue({ compare: (a, b) => this.compare(a, b) });\\n    this.minPq = new MinPriorityQueue({ compare: (a, b) => this.compare(b, a) });\\n  }\\n  \\n  compare(a = 0, b = 0) {\\n    if (a[1] === b[1]) {\\n      return a[0].localeCompare(b[0]);\\n    }\\n\\n    return b[1] - a[1];\\n  }\\n  \\n  add(name, score) {\\n    const cur = [name, score];\\n    this.minPq.enqueue(cur);\\n    this.maxPq.enqueue(this.minPq.dequeue());\\n  }\\n  \\n  get() {\\n    const maxPeek = this.maxPq.dequeue();\\n    this.minPq.enqueue(maxPeek);\\n    return maxPeek[0];\\n  }\\n};\\n\\n/** \\n * Your SORTracker object will be instantiated and called as such:\\n * var obj = new SORTracker()\\n * obj.add(name,score)\\n * var param_2 = obj.get()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658657,
                "title": "c-priority-queue",
                "content": "```\\nstruct CompGreater {\\npublic:\\n    CompGreater() {}\\n        \\n    bool operator() (const pair<string, int> a, const pair<string, int> b) {\\n        if (a.second != b.second) {\\n            return a.second < b.second;\\n        } else {\\n            return a.first.compare(b.first) > 0;\\n        }\\n    }\\n};\\n\\nstruct CompLess {\\npublic:\\n    CompLess() {}\\n        \\n    bool operator() (const pair<string, int> a, const pair<string, int> b) {\\n        if (a.second != b.second) {\\n            return a.second > b.second;\\n        } else {\\n            return a.first.compare(b.first) < 0;\\n        }\\n    }\\n};\\n\\nclass SORTracker {\\npublic:\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        if (top_min_pq.size() < m_queries + 1) {\\n            top_min_pq.push({name, score});\\n        } else {\\n            top_min_pq.push({name, score});\\n            top_max_pq.push(top_min_pq.top());\\n            top_min_pq.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        string ans = top_min_pq.top().first;\\n        ++m_queries;\\n        if (!top_max_pq.empty()) {\\n            top_min_pq.push(top_max_pq.top());\\n            top_max_pq.pop();\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, CompGreater> top_max_pq;\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, CompLess> top_min_pq;\\n    int m_queries = 0;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct CompGreater {\\npublic:\\n    CompGreater() {}\\n        \\n    bool operator() (const pair<string, int> a, const pair<string, int> b) {\\n        if (a.second != b.second) {\\n            return a.second < b.second;\\n        } else {\\n            return a.first.compare(b.first) > 0;\\n        }\\n    }\\n};\\n\\nstruct CompLess {\\npublic:\\n    CompLess() {}\\n        \\n    bool operator() (const pair<string, int> a, const pair<string, int> b) {\\n        if (a.second != b.second) {\\n            return a.second > b.second;\\n        } else {\\n            return a.first.compare(b.first) < 0;\\n        }\\n    }\\n};\\n\\nclass SORTracker {\\npublic:\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        if (top_min_pq.size() < m_queries + 1) {\\n            top_min_pq.push({name, score});\\n        } else {\\n            top_min_pq.push({name, score});\\n            top_max_pq.push(top_min_pq.top());\\n            top_min_pq.pop();\\n        }\\n    }\\n    \\n    string get() {\\n        string ans = top_min_pq.top().first;\\n        ++m_queries;\\n        if (!top_max_pq.empty()) {\\n            top_min_pq.push(top_max_pq.top());\\n            top_max_pq.pop();\\n        }\\n        return ans;\\n    }\\n    \\nprivate:\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, CompGreater> top_max_pq;\\n    priority_queue<pair<string, int>, vector<pair<string, int>>, CompLess> top_min_pq;\\n    int m_queries = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627851,
                "title": "java-simple-treeset-solution",
                "content": "```\\nclass SORTracker {\\n    class Scenic implements Comparable{\\n        String name;\\n        int score;\\n        \\n        public Scenic(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        public int compareTo(Object o) {\\n            Scenic that = (Scenic) o;\\n            if(this.score != that.score) return this.score - that.score;\\n            else{\\n                return that.name.compareTo(this.name);\\n            }\\n        }\\n        \\n        public String toString(){\\n            return \"Scenic: (\" + this.name + \", \" + this.score + \")\";\\n        }\\n    }\\n    \\n    TreeSet<Scenic> set;\\n    Scenic ithBest;\\n    \\n    public SORTracker() {\\n        set = new TreeSet<>();\\n        ithBest = null;\\n    }\\n    \\n    public void add(String name, int score) {\\n        Scenic s = new Scenic(name, score);\\n        if(ithBest == null){\\n            if(set.isEmpty()){\\n                ithBest = s;\\n            }else{\\n                //expect something smaller than the prev ithBest but there is \\n                //null, prev ithBest is the smallest element\\n                Scenic prevBest = set.first();\\n                if(s.compareTo(prevBest) > 0){\\n                    ithBest = prevBest;\\n                }else{\\n                    ithBest = s;\\n                }\\n            }\\n            set.add(s);\\n        }else{\\n            set.add(s);\\n            //ithBest is worse than s\\n            if(ithBest.compareTo(s) < 0){\\n                ithBest = set.higher(ithBest);\\n            }\\n            \\n        }\\n    }\\n    \\n    public String get() {\\n        String res = ithBest.name;\\n        ithBest = set.lower(ithBest);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SORTracker {\\n    class Scenic implements Comparable{\\n        String name;\\n        int score;\\n        \\n        public Scenic(String name, int score){\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        public int compareTo(Object o) {\\n            Scenic that = (Scenic) o;\\n            if(this.score != that.score) return this.score - that.score;\\n            else{\\n                return that.name.compareTo(this.name);\\n            }\\n        }\\n        \\n        public String toString(){\\n            return \"Scenic: (\" + this.name + \", \" + this.score + \")\";\\n        }\\n    }\\n    \\n    TreeSet<Scenic> set;\\n    Scenic ithBest;\\n    \\n    public SORTracker() {\\n        set = new TreeSet<>();\\n        ithBest = null;\\n    }\\n    \\n    public void add(String name, int score) {\\n        Scenic s = new Scenic(name, score);\\n        if(ithBest == null){\\n            if(set.isEmpty()){\\n                ithBest = s;\\n            }else{\\n                //expect something smaller than the prev ithBest but there is \\n                //null, prev ithBest is the smallest element\\n                Scenic prevBest = set.first();\\n                if(s.compareTo(prevBest) > 0){\\n                    ithBest = prevBest;\\n                }else{\\n                    ithBest = s;\\n                }\\n            }\\n            set.add(s);\\n        }else{\\n            set.add(s);\\n            //ithBest is worse than s\\n            if(ithBest.compareTo(s) < 0){\\n                ithBest = set.higher(ithBest);\\n            }\\n            \\n        }\\n    }\\n    \\n    public String get() {\\n        String res = ithBest.name;\\n        ithBest = set.lower(ithBest);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626502,
                "title": "python-sortedlist-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n    def __init__(self):\\n        self.x=SortedList([])\\n        self.c=-1\\n    def add(self, name: str, score: int) -> None:\\n        self.x.add((-score,name))        \\n    def get(self) -> str:\\n        self.c+=1\\n        return self.x[self.c][1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n    def __init__(self):\\n        self.x=SortedList([])\\n        self.c=-1\\n    def add(self, name: str, score: int) -> None:\\n        self.x.add((-score,name))        \\n    def get(self) -> str:\\n        self.c+=1\\n        return self.x[self.c][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588424,
                "title": "java-a-clean-min-max-heap-solution",
                "content": "```\\nclass SORTracker {\\n\\n    private final PriorityQueue<Pair<String, Integer>> maxQueue;\\n    \\n    private final PriorityQueue<Pair<String, Integer>> minQueue;\\n    \\n    public SORTracker() {\\n        maxQueue = new PriorityQueue<>((o1, o2) -> o1.getValue().equals(o2.getValue()) ? o1.getKey().compareTo(o2.getKey()) : o2.getValue() - o1.getValue());\\n        \\n        minQueue = new PriorityQueue<>((o1, o2) -> o1.getValue().equals(o2.getValue()) ? o2.getKey().compareTo(o1.getKey()) : o1.getValue() - o2.getValue());\\n    }\\n    \\n    public void add(String name, int score) {\\n        \\n        minQueue.add(new Pair<>(name, score));\\n        maxQueue.add(minQueue.poll());\\n    }\\n    \\n    public String get() {\\n        final Pair<String, Integer> max = maxQueue.poll();\\n        minQueue.add(max);\\n        return max.getKey();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\n\\n    private final PriorityQueue<Pair<String, Integer>> maxQueue;\\n    \\n    private final PriorityQueue<Pair<String, Integer>> minQueue;\\n    \\n    public SORTracker() {\\n        maxQueue = new PriorityQueue<>((o1, o2) -> o1.getValue().equals(o2.getValue()) ? o1.getKey().compareTo(o2.getKey()) : o2.getValue() - o1.getValue());\\n        \\n        minQueue = new PriorityQueue<>((o1, o2) -> o1.getValue().equals(o2.getValue()) ? o2.getKey().compareTo(o1.getKey()) : o1.getValue() - o2.getValue());\\n    }\\n    \\n    public void add(String name, int score) {\\n        \\n        minQueue.add(new Pair<>(name, score));\\n        maxQueue.add(minQueue.poll());\\n    }\\n    \\n    public String get() {\\n        final Pair<String, Integer> max = maxQueue.poll();\\n        minQueue.add(max);\\n        return max.getKey();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581302,
                "title": "python-2-heap-easy-to-understand-best-solution",
                "content": "\\tclass MinHeapItem:\\n\\t\\tdef __init__(self, name, score):\\n\\t\\t\\tself.name = name\\n\\t\\t\\tself.score = score\\n\\t\\tdef __lt__(self, other):\\n\\t\\t\\treturn self.score < other.score or \\\\\\n\\t\\t\\t\\t   (self.score == other.score and self.name > other.name)\\n\\n\\tclass MaxHeapItem:\\n\\t\\tdef __init__(self, name, score):\\n\\t\\t\\tself.name = name\\n\\t\\t\\tself.score = score\\n\\t\\tdef __lt__(self, other):\\n\\t\\t\\treturn self.score > other.score or \\\\\\n\\t\\t\\t\\t   (self.score == other.score and self.name < other.name)\\n\\n\\tclass SORTracker:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.min_heap = []\\n\\t\\t\\tself.max_heap = []\\n\\t\\t\\tself.k = 0\\n\\n\\t\\tdef add(self, name: str, score: int) -> None:\\n\\t\\t\\theappush(self.min_heap, MinHeapItem(name, score))     \\n\\t\\t\\tif len(self.min_heap) > self.k + 1:\\n\\t\\t\\t\\ttemp = heappop(self.min_heap)\\n\\t\\t\\t\\theappush(self.max_heap, MaxHeapItem(temp.name, temp.score))\\n\\n\\t\\tdef get(self) -> str:\\n\\t\\t\\tans = self.min_heap[0].name\\n\\t\\t\\tself.k += 1        \\n\\t\\t\\tif self.max_heap:\\n\\t\\t\\t\\ttemp = heappop(self.max_heap)\\n\\t\\t\\t\\theappush(self.min_heap, MinHeapItem(temp.name, temp.score))\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass MinHeapItem:\\n\\t\\tdef __init__(self, name, score):\\n\\t\\t\\tself.name = name\\n\\t\\t\\tself.score = score\\n\\t\\tdef __lt__(self, other):\\n\\t\\t\\treturn self.score < other.score or \\\\\\n\\t\\t\\t\\t   (self.score == other.score and self.name > other.name)\\n\\n\\tclass MaxHeapItem:\\n\\t\\tdef __init__(self, name, score):\\n\\t\\t\\tself.name = name\\n\\t\\t\\tself.score = score\\n\\t\\tdef __lt__(self, other):\\n\\t\\t\\treturn self.score > other.score or \\\\\\n\\t\\t\\t\\t   (self.score == other.score and self.name < other.name)\\n\\n\\tclass SORTracker:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.min_heap = []\\n\\t\\t\\tself.max_heap = []\\n\\t\\t\\tself.k = 0\\n\\n\\t\\tdef add(self, name: str, score: int) -> None:\\n\\t\\t\\theappush(self.min_heap, MinHeapItem(name, score))     \\n\\t\\t\\tif len(self.min_heap) > self.k + 1:\\n\\t\\t\\t\\ttemp = heappop(self.min_heap)\\n\\t\\t\\t\\theappush(self.max_heap, MaxHeapItem(temp.name, temp.score))\\n\\n\\t\\tdef get(self) -> str:\\n\\t\\t\\tans = self.min_heap[0].name\\n\\t\\t\\tself.k += 1        \\n\\t\\t\\tif self.max_heap:\\n\\t\\t\\t\\ttemp = heappop(self.max_heap)\\n\\t\\t\\t\\theappush(self.min_heap, MinHeapItem(temp.name, temp.score))\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 2545274,
                "title": "python-binary-search-insert-solution-o-n",
                "content": "Add takes O(n)\\nGet takes O(1)\\nOverall space complexity O(n)\\n```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.query_time = -1\\n        self.lst = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        idx = bisect.bisect_left(self.lst, (-score, name)) # O(logn)\\n        self.lst.insert(idx, (-score, name)) # O(n)\\n    def get(self) -> str: \\n        self.query_time += 1\\n        return self.lst[self.query_time][1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.query_time = -1\\n        self.lst = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        idx = bisect.bisect_left(self.lst, (-score, name)) # O(logn)\\n        self.lst.insert(idx, (-score, name)) # O(n)\\n    def get(self) -> str: \\n        self.query_time += 1\\n        return self.lst[self.query_time][1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527733,
                "title": "java-2-priorityqueue-method",
                "content": "```\\npublic class Location {\\n        String name;\\n        int score;\\n        public Location (String str, int num) {\\n            name = str;\\n            score = num;\\n        }\\n        public Location () {}\\n    }\\n    int queryTimes;\\n    PriorityQueue<Location> maxheap;\\n    PriorityQueue<Location> minheap;\\n\\n    public SORTracker() {\\n        queryTimes = 0;\\n        maxheap = new PriorityQueue<>((o1, o2) -> {\\n            if (o1.score == o2.score) {\\n                return o1.name.compareTo(o2.name);\\n            }\\n            return o2.score - o1.score;\\n        });\\n        minheap = new PriorityQueue<>((o1, o2) -> {\\n            if (o1.score == o2.score) {\\n                return o2.name.compareTo(o1.name);\\n            }\\n            return o1.score - o2.score;\\n        });\\n    }\\n    \\n    public void add(String name, int score) {\\n        Location loc = new Location(name, score);\\n        if (minheap.size() == 0) {\\n            maxheap.offer(loc);\\n        } else if (score > minheap.peek().score || (score == minheap.peek().score && name.compareTo(minheap.peek().name) < 0)) {\\n            Location changed = minheap.poll();\\n            maxheap.offer(changed);\\n            minheap.offer(loc);\\n        } else {\\n            maxheap.offer(loc);\\n        } \\n    }\\n    \\n    public String get() {\\n        queryTimes++;\\n        minheap.offer(maxheap.poll());\\n        return minheap.peek().name;          \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Location {\\n        String name;\\n        int score;\\n        public Location (String str, int num) {\\n            name = str;\\n            score = num;\\n        }\\n        public Location () {}\\n    }\\n    int queryTimes;\\n    PriorityQueue<Location> maxheap;\\n    PriorityQueue<Location> minheap;\\n\\n    public SORTracker() {\\n        queryTimes = 0;\\n        maxheap = new PriorityQueue<>((o1, o2) -> {\\n            if (o1.score == o2.score) {\\n                return o1.name.compareTo(o2.name);\\n            }\\n            return o2.score - o1.score;\\n        });\\n        minheap = new PriorityQueue<>((o1, o2) -> {\\n            if (o1.score == o2.score) {\\n                return o2.name.compareTo(o1.name);\\n            }\\n            return o1.score - o2.score;\\n        });\\n    }\\n    \\n    public void add(String name, int score) {\\n        Location loc = new Location(name, score);\\n        if (minheap.size() == 0) {\\n            maxheap.offer(loc);\\n        } else if (score > minheap.peek().score || (score == minheap.peek().score && name.compareTo(minheap.peek().name) < 0)) {\\n            Location changed = minheap.poll();\\n            maxheap.offer(changed);\\n            minheap.offer(loc);\\n        } else {\\n            maxheap.offer(loc);\\n        } \\n    }\\n    \\n    public String get() {\\n        queryTimes++;\\n        minheap.offer(maxheap.poll());\\n        return minheap.peek().name;          \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519688,
                "title": "python-memory-usage-34-5-mb-less-than-91-94",
                "content": "```\\nclass Score:\\n    def __init__(self, startIndex=0, endIndex=0):\\n        self.startIndex=startIndex\\n        self.endIndex=endIndex\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        # Count the number of times get() has been called\\n        self.countGet=0\\n        # List of scenic locations, which is sorted according to its score\\n        self.tracker=[]\\n        # Different values of scores of scenic views. Each score consists of start and end index of its scenic locations in tracker list\\n        self.scores={}\\n        # Highest score recorded\\n        self.highestScore=0\\n\\n    def add(self, name: str, score: int) -> None:\\n        # If new score has surfaced, create a new Score()\\n        if score not in self.scores:\\n            self.scores[score]=Score()\\n            # If the new score is the highest score recorded so far, update the highestScore and insert the scenic location at the start of tracker\\n            if score>self.highestScore:\\n                self.tracker.insert(0, name)\\n                self.highestScore=score\\n            else:\\n                # Find maximum score smaller than the current score from scores\\n                maxSmallScore=0\\n                for i in self.scores:\\n                    if i<score and i>maxSmallScore:\\n                        maxSmallScore=i\\n                # Add the new scenic location before the start of maxSmallScore scenic locations\\n                if maxSmallScore!=0:\\n                    self.tracker.insert(self.scores[maxSmallScore].startIndex, name)\\n                    self.scores[score].startIndex=self.scores[score].endIndex= self.scores[maxSmallScore].startIndex\\n                # If no score smaller than current score is found, then append the new scenic location at the end of the tracker\\n                else:\\n                    self.tracker.append(name)\\n                    self.scores[score].startIndex=self.scores[score].endIndex= len(self.tracker)-1\\n                \\n        # If score is already present in scores, get start and end indices in tracker\\n        else:\\n            start, end=self.scores[score].startIndex, self.scores[score].endIndex \\n            # Insert the new scenic location at the correct index\\n            for i in range(start, end+1):\\n                if name<self.tracker[i]:\\n                    self.tracker.insert(i, name)\\n                    break\\n            else:\\n                self.tracker.insert(end+1, name)\\n            # Increment the end index for this score\\n            self.scores[score].endIndex+=1\\n            \\n        # print(self.tracker)\\n            \\n        \\n        # When a new scenic location is added, the start and end indices for scores less than this is pushed to the end by 1 index\\n        for i in self.scores:\\n            if i<score:\\n                self.scores[i].startIndex+=1\\n                self.scores[i].endIndex+=1\\n                \\n            \\n\\n    def get(self) -> str:\\n        # Update the number of times get() has been called\\n        self.countGet+=1\\n        # Return the scenic location from countGet-1 index from the tracker\\n        return self.tracker[self.countGet-1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Score:\\n    def __init__(self, startIndex=0, endIndex=0):\\n        self.startIndex=startIndex\\n        self.endIndex=endIndex\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        # Count the number of times get() has been called\\n        self.countGet=0\\n        # List of scenic locations, which is sorted according to its score\\n        self.tracker=[]\\n        # Different values of scores of scenic views. Each score consists of start and end index of its scenic locations in tracker list\\n        self.scores={}\\n        # Highest score recorded\\n        self.highestScore=0\\n\\n    def add(self, name: str, score: int) -> None:\\n        # If new score has surfaced, create a new Score()\\n        if score not in self.scores:\\n            self.scores[score]=Score()\\n            # If the new score is the highest score recorded so far, update the highestScore and insert the scenic location at the start of tracker\\n            if score>self.highestScore:\\n                self.tracker.insert(0, name)\\n                self.highestScore=score\\n            else:\\n                # Find maximum score smaller than the current score from scores\\n                maxSmallScore=0\\n                for i in self.scores:\\n                    if i<score and i>maxSmallScore:\\n                        maxSmallScore=i\\n                # Add the new scenic location before the start of maxSmallScore scenic locations\\n                if maxSmallScore!=0:\\n                    self.tracker.insert(self.scores[maxSmallScore].startIndex, name)\\n                    self.scores[score].startIndex=self.scores[score].endIndex= self.scores[maxSmallScore].startIndex\\n                # If no score smaller than current score is found, then append the new scenic location at the end of the tracker\\n                else:\\n                    self.tracker.append(name)\\n                    self.scores[score].startIndex=self.scores[score].endIndex= len(self.tracker)-1\\n                \\n        # If score is already present in scores, get start and end indices in tracker\\n        else:\\n            start, end=self.scores[score].startIndex, self.scores[score].endIndex \\n            # Insert the new scenic location at the correct index\\n            for i in range(start, end+1):\\n                if name<self.tracker[i]:\\n                    self.tracker.insert(i, name)\\n                    break\\n            else:\\n                self.tracker.insert(end+1, name)\\n            # Increment the end index for this score\\n            self.scores[score].endIndex+=1\\n            \\n        # print(self.tracker)\\n            \\n        \\n        # When a new scenic location is added, the start and end indices for scores less than this is pushed to the end by 1 index\\n        for i in self.scores:\\n            if i<score:\\n                self.scores[i].startIndex+=1\\n                self.scores[i].endIndex+=1\\n                \\n            \\n\\n    def get(self) -> str:\\n        # Update the number of times get() has been called\\n        self.countGet+=1\\n        # Return the scenic location from countGet-1 index from the tracker\\n        return self.tracker[self.countGet-1]\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518452,
                "title": "python-sortedlist-this-structure-is-sooooooooo-helpful",
                "content": "```\\n# from queue import PriorityQueue\\n# import functools\\n# class Node:\\n#     def __init__(self, name, score):\\n#         self.name = name\\n#         self.score = score\\n        \\n# @functools.total_ordering\\n# class ComparableNode(Node):\\n#     def __gt__(self, other):\\n#         if self.score > other.score:\\n#             return True\\n#         elif self.score == other.score:\\n#             if self.name < other.name:\\n#                 return True\\n#         else:\\n#             return False\\n#         return False\\n\\n#     def __eq__(self, other):\\n#         return self.score == other.score and self.name == other.name\\n    \\n#     def __lt__(self, other):\\n#         if self.score < other.score:\\n#             return True\\n#         if self.score == other.score:\\n#             if self.name < other.name:\\n#                 return True\\n#         return False\\n\\n# class SORTracker:\\n\\n#     def __init__(self):\\n#         self.pq = PriorityQueue()\\n\\n#     def add(self, name: str, score: int) -> None:\\n#         node = ComparableNode(name, score)\\n#         self.pq.put(node)\\n\\n#     def get(self) -> str:\\n#         node = self.pq.get()\\n#         return node.name\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.rank = SortedList()\\n        self.idx = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.rank.add([-score, name])\\n\\n    def get(self) -> str:\\n        top = self.rank[self.idx]\\n        self.idx += 1\\n        return top[1]\\n        \\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [],
                "code": "```\\n# from queue import PriorityQueue\\n# import functools\\n# class Node:\\n#     def __init__(self, name, score):\\n#         self.name = name\\n#         self.score = score\\n        \\n# @functools.total_ordering\\n# class ComparableNode(Node):\\n#     def __gt__(self, other):\\n#         if self.score > other.score:\\n#             return True\\n#         elif self.score == other.score:\\n#             if self.name < other.name:\\n#                 return True\\n#         else:\\n#             return False\\n#         return False\\n\\n#     def __eq__(self, other):\\n#         return self.score == other.score and self.name == other.name\\n    \\n#     def __lt__(self, other):\\n#         if self.score < other.score:\\n#             return True\\n#         if self.score == other.score:\\n#             if self.name < other.name:\\n#                 return True\\n#         return False\\n\\n# class SORTracker:\\n\\n#     def __init__(self):\\n#         self.pq = PriorityQueue()\\n\\n#     def add(self, name: str, score: int) -> None:\\n#         node = ComparableNode(name, score)\\n#         self.pq.put(node)\\n\\n#     def get(self) -> str:\\n#         node = self.pq.get()\\n#         return node.name\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.rank = SortedList()\\n        self.idx = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.rank.add([-score, name])\\n\\n    def get(self) -> str:\\n        top = self.rank[self.idx]\\n        self.idx += 1\\n        return top[1]\\n        \\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507019,
                "title": "python-two-heaps-with-custom-string-class-for-comparison",
                "content": "Each add step takes O(log i) + O(log(N-i) where N number of add calls so far, i - number of get calls.\\nEach get step takes the same as ^.\\n\\n```\\n# string with inverted comparison\\nclass MyString:\\n    def __init__(self, word):\\n        self.word = word\\n\\n    def __lt__(self, other):\\n        return self.word > other.word\\n    \\n    def __eq__(self, other):\\n        return self.word == other.word\\n    \\n    def __repr__(self):\\n        return self.word\\n\\nclass SORTracker:\\n    def __init__(self):\\n        # min heap, holds the ith max at the top\\n        self.left = []\\n        # max heap holds the next to th ith max at the rop\\n        self.right = []\\n        # counter for tet calls\\n        self.get_calls = 1\\n\\n    def add(self, name: str, score: int) -> None:\\n        if not self.left:\\n            self.left.append((score, MyString(name)))\\n            return\\n        \\n        heappush(self.left, (score, MyString(name)))\\n\\n        # balancing step\\n        if len(self.left) > self.get_calls:\\n            sc, w = heappop(self.left)\\n            heappush(self.right, (-sc, str(w)))\\n\\n    def get(self) -> str:     \\n        # get the ith max as it\\'s at the left\\'s top\\n        _, location = self.left[0]\\n\\n        # rebalance the heaps back cause we need one more max_i at the left\\'s top\\n        if self.right:\\n            sc, w = heappop(self.right)\\n            heappush(self.left, (-sc, MyString(w)))\\n            \\n        self.get_calls += 1\\n        \\n        return str(location)\\n```",
                "solutionTags": [],
                "code": "```\\n# string with inverted comparison\\nclass MyString:\\n    def __init__(self, word):\\n        self.word = word\\n\\n    def __lt__(self, other):\\n        return self.word > other.word\\n    \\n    def __eq__(self, other):\\n        return self.word == other.word\\n    \\n    def __repr__(self):\\n        return self.word\\n\\nclass SORTracker:\\n    def __init__(self):\\n        # min heap, holds the ith max at the top\\n        self.left = []\\n        # max heap holds the next to th ith max at the rop\\n        self.right = []\\n        # counter for tet calls\\n        self.get_calls = 1\\n\\n    def add(self, name: str, score: int) -> None:\\n        if not self.left:\\n            self.left.append((score, MyString(name)))\\n            return\\n        \\n        heappush(self.left, (score, MyString(name)))\\n\\n        # balancing step\\n        if len(self.left) > self.get_calls:\\n            sc, w = heappop(self.left)\\n            heappush(self.right, (-sc, str(w)))\\n\\n    def get(self) -> str:     \\n        # get the ith max as it\\'s at the left\\'s top\\n        _, location = self.left[0]\\n\\n        # rebalance the heaps back cause we need one more max_i at the left\\'s top\\n        if self.right:\\n            sc, w = heappop(self.right)\\n            heappush(self.left, (-sc, MyString(w)))\\n            \\n        self.get_calls += 1\\n        \\n        return str(location)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499649,
                "title": "c-solution-using-multiset",
                "content": "```\\nclass SORTracker {\\npublic:\\n    int query = 0;\\n    struct Comparator {\\n        bool operator () (const pair<int, string>& p, const pair<int, string>& q) const {\\n            if (p.first > q.first) return true;\\n            if (p.first < q.first) return false;\\n            return p.second < q.second;\\n        }\\n    };\\n    multiset<pair<int, string>, Comparator> st;\\n    multiset<pair<int, string>, Comparator>::iterator it;\\n    SORTracker() {\\n        it = st.end();\\n    }\\n    \\n    void add(string name, int score) {\\n        if ((int) st.size() == 0) {\\n            st.insert(make_pair(score, name));\\n            it = st.begin();\\n            return;\\n        }\\n        if (it == st.end()) {\\n            st.insert(make_pair(score, name));\\n            it = prev(st.end());\\n            return;\\n        }\\n        pair<int, string> p = *it;\\n        Comparator comparator;\\n        if (comparator(p, make_pair(score, name))) {\\n            st.insert(make_pair(score, name) );\\n        } else {\\n            st.insert(make_pair(score, name));\\n            it = prev(it);\\n        }\\n    }\\n    \\n    string get() {\\n        string sol = it->second;\\n        it = next(it);\\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\npublic:\\n    int query = 0;\\n    struct Comparator {\\n        bool operator () (const pair<int, string>& p, const pair<int, string>& q) const {\\n            if (p.first > q.first) return true;\\n            if (p.first < q.first) return false;\\n            return p.second < q.second;\\n        }\\n    };\\n    multiset<pair<int, string>, Comparator> st;\\n    multiset<pair<int, string>, Comparator>::iterator it;\\n    SORTracker() {\\n        it = st.end();\\n    }\\n    \\n    void add(string name, int score) {\\n        if ((int) st.size() == 0) {\\n            st.insert(make_pair(score, name));\\n            it = st.begin();\\n            return;\\n        }\\n        if (it == st.end()) {\\n            st.insert(make_pair(score, name));\\n            it = prev(st.end());\\n            return;\\n        }\\n        pair<int, string> p = *it;\\n        Comparator comparator;\\n        if (comparator(p, make_pair(score, name))) {\\n            st.insert(make_pair(score, name) );\\n        } else {\\n            st.insert(make_pair(score, name));\\n            it = prev(it);\\n        }\\n    }\\n    \\n    string get() {\\n        string sol = it->second;\\n        it = next(it);\\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2395232,
                "title": "c-max-heap-min-heap-easy-to-understand",
                "content": "\\tclass SORTracker {\\n\\t\\tstruct Location {        \\n\\t\\t\\tstring name;\\n\\t\\t\\tint score;\\n\\n\\t\\t\\tLocation(string name, int score): name(name), score(score) {}\\n\\t\\t};\\n\\n\\t\\tstruct minHeapComparator {\\n\\t\\t\\tbool operator() (Location const& l1, Location const& l2) {\\n\\t\\t\\t\\tif(l1.score == l2.score) {\\n\\t\\t\\t\\t\\treturn l1.name < l2.name;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn l1.score > l2.score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tstruct maxHeapComparator {\\n\\t\\t\\tbool operator() (Location const& l1, Location const& l2) {\\n\\t\\t\\t\\tif(l1.score == l2.score) {\\n\\t\\t\\t\\t\\treturn l1.name > l2.name;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn l1.score < l2.score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\tpublic:\\n\\t\\tint i;\\n\\t\\tpriority_queue<Location, vector<Location>, minHeapComparator> left;\\n\\t\\tpriority_queue<Location, vector<Location>, maxHeapComparator> right;\\n\\n\\t\\tSORTracker() {\\n\\t\\t\\ti = 1;    \\n\\t\\t}\\n\\n\\t\\tvoid add(string name, int score) {\\n\\t\\t\\tif(left.size() == 0) {\\n\\t\\t\\t\\tleft.push(Location(name, score));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif(score >= left.top().score) {\\n\\t\\t\\t\\t\\tleft.push(Location(name, score));\\n\\t\\t\\t\\t\\t// balance correction\\n\\t\\t\\t\\t\\tif(left.size() >= i) {\\n\\t\\t\\t\\t\\t\\tLocation loc = left.top();\\n\\t\\t\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t\\t\\t\\tright.push(loc);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tright.push(Location(name, score));\\n\\t\\t\\t\\t\\t// balance correction\\n\\t\\t\\t\\t\\tif(left.size() < i) {\\n\\t\\t\\t\\t\\t\\tLocation loc = right.top();\\n\\t\\t\\t\\t\\t\\tright.pop();\\n\\t\\t\\t\\t\\t\\tleft.push(loc);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring get() {\\n\\t\\t\\t// balance correction\\n\\t\\t\\tif(left.size() > i) {\\n\\t\\t\\t\\tLocation loc = left.top();\\n\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t\\tright.push(loc);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(left.size() < i) {\\n\\t\\t\\t\\tLocation loc = right.top();\\n\\t\\t\\t\\tright.pop();\\n\\t\\t\\t\\tleft.push(loc);\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\treturn left.top().name;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your SORTracker object will be instantiated and called as such:\\n\\t * SORTracker* obj = new SORTracker();\\n\\t * obj->add(name,score);\\n\\t * string param_2 = obj->get();\\n\\t */",
                "solutionTags": [],
                "code": "\\tclass SORTracker {\\n\\t\\tstruct Location {        \\n\\t\\t\\tstring name;\\n\\t\\t\\tint score;\\n\\n\\t\\t\\tLocation(string name, int score): name(name), score(score) {}\\n\\t\\t};\\n\\n\\t\\tstruct minHeapComparator {\\n\\t\\t\\tbool operator() (Location const& l1, Location const& l2) {\\n\\t\\t\\t\\tif(l1.score == l2.score) {\\n\\t\\t\\t\\t\\treturn l1.name < l2.name;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn l1.score > l2.score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tstruct maxHeapComparator {\\n\\t\\t\\tbool operator() (Location const& l1, Location const& l2) {\\n\\t\\t\\t\\tif(l1.score == l2.score) {\\n\\t\\t\\t\\t\\treturn l1.name > l2.name;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn l1.score < l2.score;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\tpublic:\\n\\t\\tint i;\\n\\t\\tpriority_queue<Location, vector<Location>, minHeapComparator> left;\\n\\t\\tpriority_queue<Location, vector<Location>, maxHeapComparator> right;\\n\\n\\t\\tSORTracker() {\\n\\t\\t\\ti = 1;    \\n\\t\\t}\\n\\n\\t\\tvoid add(string name, int score) {\\n\\t\\t\\tif(left.size() == 0) {\\n\\t\\t\\t\\tleft.push(Location(name, score));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif(score >= left.top().score) {\\n\\t\\t\\t\\t\\tleft.push(Location(name, score));\\n\\t\\t\\t\\t\\t// balance correction\\n\\t\\t\\t\\t\\tif(left.size() >= i) {\\n\\t\\t\\t\\t\\t\\tLocation loc = left.top();\\n\\t\\t\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t\\t\\t\\tright.push(loc);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tright.push(Location(name, score));\\n\\t\\t\\t\\t\\t// balance correction\\n\\t\\t\\t\\t\\tif(left.size() < i) {\\n\\t\\t\\t\\t\\t\\tLocation loc = right.top();\\n\\t\\t\\t\\t\\t\\tright.pop();\\n\\t\\t\\t\\t\\t\\tleft.push(loc);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring get() {\\n\\t\\t\\t// balance correction\\n\\t\\t\\tif(left.size() > i) {\\n\\t\\t\\t\\tLocation loc = left.top();\\n\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t\\tright.push(loc);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(left.size() < i) {\\n\\t\\t\\t\\tLocation loc = right.top();\\n\\t\\t\\t\\tright.pop();\\n\\t\\t\\t\\tleft.push(loc);\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\treturn left.top().name;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your SORTracker object will be instantiated and called as such:\\n\\t * SORTracker* obj = new SORTracker();\\n\\t * obj->add(name,score);\\n\\t * string param_2 = obj->get();\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 2352117,
                "title": "python-bisect-insort-solution",
                "content": "O(n) with bisect insort.\\n\\n```\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.scores = []\\n        self.count = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        bisect.insort(self.scores, (-score, name))\\n\\n    def get(self) -> str:\\n        self.count += 1\\n        return self.scores[self.count - 1][1]\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.scores = []\\n        self.count = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        bisect.insort(self.scores, (-score, name))\\n\\n    def get(self) -> str:\\n        self.count += 1\\n        return self.scores[self.count - 1][1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329847,
                "title": "java-using-arraylist-and-pointer-with-explanation",
                "content": "By using an ArrayList, we can have direct access to whichever index is to-be retrieved next. By mantaining our arraylist in a sorted order, we are able to mantain (O(logN)) insertion times by using binary search, and (O(1)) retrieval times.\\n\\n```\\nclass SORTracker {\\n    ArrayList<Tuple> list;\\n    int index;\\n    public SORTracker() {\\n        list = new ArrayList<Tuple>();\\n        index = 0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        insertSorted(new Tuple(name, score));\\n    }\\n    \\n    public String get() {\\n        Tuple val = list.get(index);\\n        index++;\\n        return val.name;\\n    }\\n    \\n    public void insertSorted(Tuple item) {\\n        int tempIndex = Collections.binarySearch(list, item, (x,y) -> {\\n            if(y.value - x.value == 0) {\\n                return x.name.compareTo(y.name);\\n            }\\n            return y.value - x.value;\\n        });\\n        if(tempIndex < 0) {\\n            tempIndex = (tempIndex * -1) - 1;\\n        }\\n        list.add(tempIndex, item);\\n    }\\n}\\n\\n\\nclass Tuple {\\n    String name;\\n    int value;\\n    \\n    public Tuple(String name, int value) {\\n        this.name = name;\\n        this.value = value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass SORTracker {\\n    ArrayList<Tuple> list;\\n    int index;\\n    public SORTracker() {\\n        list = new ArrayList<Tuple>();\\n        index = 0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        insertSorted(new Tuple(name, score));\\n    }\\n    \\n    public String get() {\\n        Tuple val = list.get(index);\\n        index++;\\n        return val.name;\\n    }\\n    \\n    public void insertSorted(Tuple item) {\\n        int tempIndex = Collections.binarySearch(list, item, (x,y) -> {\\n            if(y.value - x.value == 0) {\\n                return x.name.compareTo(y.name);\\n            }\\n            return y.value - x.value;\\n        });\\n        if(tempIndex < 0) {\\n            tempIndex = (tempIndex * -1) - 1;\\n        }\\n        list.add(tempIndex, item);\\n    }\\n}\\n\\n\\nclass Tuple {\\n    String name;\\n    int value;\\n    \\n    public Tuple(String name, int value) {\\n        this.name = name;\\n        this.value = value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328970,
                "title": "using-set-instead-of-maxheap-solution-with-comments",
                "content": "\\n\\n```\\nclass SORTracker {\\n    private:\\n         set<pair<int,string>>store;\\n        //Declaring an iterator to point to the end of the set variable\\n         set<pair<int,string>>:: iterator itr = end(store);\\npublic:\\n    SORTracker() {\\n        \\n    }\\n     bool cmp(set<pair<int,string>>:: iterator a,set<pair<int,string>>:: iterator b)\\n     {\\n         if(a->first < b->first)\\n             return true;\\n         else if(a->first == b->first && a->second < b->second)\\n             return true;\\n         \\n         return false;\\n    }\\n\\n    void add(string name, int score) {\\n        //Add the elements to the set variable\\n        //the score is added with negative number so that it is sorted in order \\n        // insert return type is <iter,bool> s.insert().first will return the iterator\\n        //use the comparision function to sort the iterator\\n        auto itr1 = store.insert({-score,name}).first;\\n        if(itr == end(store) || cmp(itr1,itr))\\n            itr--;// to keep track of ith best  location\\n    }\\n    \\n    string get() {\\n        return (*itr++).second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SORTracker {\\n    private:\\n         set<pair<int,string>>store;\\n        //Declaring an iterator to point to the end of the set variable\\n         set<pair<int,string>>:: iterator itr = end(store);\\npublic:\\n    SORTracker() {\\n        \\n    }\\n     bool cmp(set<pair<int,string>>:: iterator a,set<pair<int,string>>:: iterator b)\\n     {\\n         if(a->first < b->first)\\n             return true;\\n         else if(a->first == b->first && a->second < b->second)\\n             return true;\\n         \\n         return false;\\n    }\\n\\n    void add(string name, int score) {\\n        //Add the elements to the set variable\\n        //the score is added with negative number so that it is sorted in order \\n        // insert return type is <iter,bool> s.insert().first will return the iterator\\n        //use the comparision function to sort the iterator\\n        auto itr1 = store.insert({-score,name}).first;\\n        if(itr == end(store) || cmp(itr1,itr))\\n            itr--;// to keep track of ith best  location\\n    }\\n    \\n    string get() {\\n        return (*itr++).second;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287806,
                "title": "c-sortedlist",
                "content": "```csharp\\npublic class SORTracker {\\n    \\n    int counter;\\n    SortedList<string, (string, int)> pq = new();\\n\\n    public SORTracker() {\\n       counter = 0; \\n    }\\n    \\n    public void Add(string name, int score) {\\n        string key = (int.MaxValue-score).ToString();\\n        pq.Add($\"{key}_{name}\", (name, score));\\n    }\\n    \\n    public string Get() {\\n        counter++;\\n        return pq.Values[counter-1].Item1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class SORTracker {\\n    \\n    int counter;\\n    SortedList<string, (string, int)> pq = new();\\n\\n    public SORTracker() {\\n       counter = 0; \\n    }\\n    \\n    public void Add(string name, int score) {\\n        string key = (int.MaxValue-score).ToString();\\n        pq.Add($\"{key}_{name}\", (name, score));\\n    }\\n    \\n    public string Get() {\\n        counter++;\\n        return pq.Values[counter-1].Item1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243918,
                "title": "python-binary-search-function",
                "content": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.mapper = {}\\n        self.lst = []\\n        self.inv = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.mapper[name] = score\\n        def bin_search(name):\\n            start, end = 0, len(self.lst) - 1\\n            \\n            while start <= end:\\n                mid = (start + end) >> 1\\n                if self.mapper[self.lst[mid]] == self.mapper[name]:\\n                    if name > self.lst[mid]:\\n                        start = mid + 1\\n                    else:\\n                        end = mid - 1\\n                elif self.mapper[self.lst[mid]] < self.mapper[name]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            return start\\n     \\n        if not self.lst:\\n            self.lst.append(name)\\n        else:\\n            n = bin_search(name)\\n            self.lst.insert(n, name)\\n            \\n    def get(self) -> str:\\n        val = self.lst[self.inv]\\n        self.inv += 1\\n        return val\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.mapper = {}\\n        self.lst = []\\n        self.inv = 0\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.mapper[name] = score\\n        def bin_search(name):\\n            start, end = 0, len(self.lst) - 1\\n            \\n            while start <= end:\\n                mid = (start + end) >> 1\\n                if self.mapper[self.lst[mid]] == self.mapper[name]:\\n                    if name > self.lst[mid]:\\n                        start = mid + 1\\n                    else:\\n                        end = mid - 1\\n                elif self.mapper[self.lst[mid]] < self.mapper[name]:\\n                    end = mid - 1\\n                else:\\n                    start = mid + 1\\n            return start\\n     \\n        if not self.lst:\\n            self.lst.append(name)\\n        else:\\n            n = bin_search(name)\\n            self.lst.insert(n, name)\\n            \\n    def get(self) -> str:\\n        val = self.lst[self.inv]\\n        self.inv += 1\\n        return val\\n\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243576,
                "title": "python-3-binary-search-explanation-with-example",
                "content": "```\\n\"\"\"\\n                        self.counter    self.scorelist      self.score_name or return_value\\nadd     [bradford, 2]   0               [-2]                2:[bradford]\\n\\nadd     [branford, 3]   0               [-3,-2]             3:[branford], \\n                                                            2:[bradford]\\n                                                            \\nget                     0 -> 1          [-3,-2]             return score_name[3][0-0] = branford\\n                                                            scorelist[0] = -3 which starts at index 0\\n                                                            \\nadd     [alps, 2]       1               [-3,-2,-2]          3:[branford],\\n                                                            2:[alps, bradford]\\n                                                            \\nget                     1 -> 2          [-3,-2,-2]          return score_name[2][1-1] = alps\\n                                                            scorelist[1] = -2 which starts at index 1\\n\\nadd     [orland, 2]     2               [-3,-2,-2,-2]       3:[branford],\\n                                                            2:[alps, bradford, orland]\\n\\nget                     2 -> 3          [-3,-2,-2,-2]       return score_name[2][2-1] = bradford     \\n                                                            scorelist[2] = -2 which starts at index 1\\n\\nadd     [orlando, 3]    3               [-3,-3,-2,-2,-2]    3:[branford, orlando],\\n                                                            2:[alps, bradford, orland]\\n                                                            \\nget                     3 -> 4          [-3,-3,-2,-2,-2]    return score_name[2][3-2] = bradford\\n                                                            scorelist[3] = -2 which starts at index 2\\n\\nadd     [alpine, 2]     4               [-3,-3,-2,-2,-2,-2] 3:[branford, orlando],\\n                                                            2:[alpine, alps, bradford, orland]\\n\\nget                     4 -> 5          [-3,-3,-2,-2,-2,-2] return score_name[2][4-2] = bradford\\n                                                            scorelist[4] = -2 which starts at index 2\\n\\nget                     5 -> 6          [-3,-3,-2,-2,-2,-2] return score_name[2][5-2] = orland\\n                                                            scorelist[5] = -2 which starts at index 2\\n\"\"\"\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.counter = 0\\n        self.score_name = defaultdict(list)\\n        self.scorelist = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        index = bisect.bisect_left(self.score_name[score], name)\\n        self.score_name[score].insert(index, name)\\n        index = bisect.bisect_left(self.scorelist, -score)\\n        self.scorelist.insert(index, -score)\\n        \\n    def get(self) -> str:\\n        target = self.scorelist[self.counter]\\n        target_start = bisect.bisect_left(self.scorelist, target)\\n        ret = self.score_name[-target][self.counter - target_start]\\n        self.counter += 1\\n        return ret",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n                        self.counter    self.scorelist      self.score_name or return_value\\nadd     [bradford, 2]   0               [-2]                2:[bradford]\\n\\nadd     [branford, 3]   0               [-3,-2]             3:[branford], \\n                                                            2:[bradford]\\n                                                            \\nget                     0 -> 1          [-3,-2]             return score_name[3][0-0] = branford\\n                                                            scorelist[0] = -3 which starts at index 0\\n                                                            \\nadd     [alps, 2]       1               [-3,-2,-2]          3:[branford],\\n                                                            2:[alps, bradford]\\n                                                            \\nget                     1 -> 2          [-3,-2,-2]          return score_name[2][1-1] = alps\\n                                                            scorelist[1] = -2 which starts at index 1\\n\\nadd     [orland, 2]     2               [-3,-2,-2,-2]       3:[branford],\\n                                                            2:[alps, bradford, orland]\\n\\nget                     2 -> 3          [-3,-2,-2,-2]       return score_name[2][2-1] = bradford     \\n                                                            scorelist[2] = -2 which starts at index 1\\n\\nadd     [orlando, 3]    3               [-3,-3,-2,-2,-2]    3:[branford, orlando],\\n                                                            2:[alps, bradford, orland]\\n                                                            \\nget                     3 -> 4          [-3,-3,-2,-2,-2]    return score_name[2][3-2] = bradford\\n                                                            scorelist[3] = -2 which starts at index 2\\n\\nadd     [alpine, 2]     4               [-3,-3,-2,-2,-2,-2] 3:[branford, orlando],\\n                                                            2:[alpine, alps, bradford, orland]\\n\\nget                     4 -> 5          [-3,-3,-2,-2,-2,-2] return score_name[2][4-2] = bradford\\n                                                            scorelist[4] = -2 which starts at index 2\\n\\nget                     5 -> 6          [-3,-3,-2,-2,-2,-2] return score_name[2][5-2] = orland\\n                                                            scorelist[5] = -2 which starts at index 2\\n\"\"\"\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.counter = 0\\n        self.score_name = defaultdict(list)\\n        self.scorelist = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        index = bisect.bisect_left(self.score_name[score], name)\\n        self.score_name[score].insert(index, name)\\n        index = bisect.bisect_left(self.scorelist, -score)\\n        self.scorelist.insert(index, -score)\\n        \\n    def get(self) -> str:\\n        target = self.scorelist[self.counter]\\n        target_start = bisect.bisect_left(self.scorelist, target)\\n        ret = self.score_name[-target][self.counter - target_start]\\n        self.counter += 1\\n        return ret",
                "codeTag": "Java"
            },
            {
                "id": 2197623,
                "title": "c-using-std-set-of-tuple-score-place-and-maintain-an-long-lived-iterator",
                "content": "### [C++] using std::set of tuple<score, place>, and maintain an long-lived iterator\\n* use std::set of tuple<score, place>, and maintain a long-lived iterator.\\n* decrement the iterator when the new place is inserted before the position pointed to by the\\niterator\\n* increment the iterator after each query.\\n\\n```\\n// Idea / Approach:\\n// * use std::set of tuple<score, place>, and maintain a long-lived iterator.\\n// * decrement the iterator when the new place is inserted before the position pointed to by the\\n// iterator\\n// * increment the iterator after each query.\\nclass SORTracker {\\n    // tuple of (negated) score with the name of the place; ie tuple<-score, place>\\n    using Item = tuple<int, string>;\\n    set<Item> _places;\\n    int _seq = 0;\\n    set<Item>::iterator _iter;\\n\\npublic:\\n    SORTracker() {\\n        _iter = _places.end();\\n    }\\n\\n    void add(string name, int score) {\\n        Item newPlace{-score, name};\\n\\t\\t\\n        // if the new place is inserted before the iter, we will decrement the iter.\\n        bool isInsertedBefore = _iter == _places.end() || newPlace < *_iter;\\n        _places.emplace(std::move(newPlace));\\n        if (isInsertedBefore) {\\n            --_iter;\\n        }\\n    }\\n\\n    string get() {\\n        ++_seq;\\n        auto name = std::get<1>(*_iter);\\n        ++_iter; // iter may pass the end after increment.\\n        return name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Idea / Approach:\\n// * use std::set of tuple<score, place>, and maintain a long-lived iterator.\\n// * decrement the iterator when the new place is inserted before the position pointed to by the\\n// iterator\\n// * increment the iterator after each query.\\nclass SORTracker {\\n    // tuple of (negated) score with the name of the place; ie tuple<-score, place>\\n    using Item = tuple<int, string>;\\n    set<Item> _places;\\n    int _seq = 0;\\n    set<Item>::iterator _iter;\\n\\npublic:\\n    SORTracker() {\\n        _iter = _places.end();\\n    }\\n\\n    void add(string name, int score) {\\n        Item newPlace{-score, name};\\n\\t\\t\\n        // if the new place is inserted before the iter, we will decrement the iter.\\n        bool isInsertedBefore = _iter == _places.end() || newPlace < *_iter;\\n        _places.emplace(std::move(newPlace));\\n        if (isInsertedBefore) {\\n            --_iter;\\n        }\\n    }\\n\\n    string get() {\\n        ++_seq;\\n        auto name = std::get<1>(*_iter);\\n        ++_iter; // iter may pass the end after increment.\\n        return name;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197178,
                "title": "python-binary-search-solution",
                "content": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.lst = []\\n        self.k = 0\\n        \\n    def add(self, name: str, score: int) -> None:\\n        x = (-score, name)\\n        if not self.lst or self.lst[-1] < x:\\n            self.lst.append(x)\\n            return\\n        \\n        lo, hi = 0, len(self.lst)\\n        while(lo<hi):\\n            mid = (lo+hi)//2\\n            if self.lst[mid]<x:\\n                lo = mid+1\\n            else:\\n                hi = mid\\n        self.lst.insert(lo, x)  # O(N) here\\n        \\n    def get(self) -> str:\\n        res = self.lst[self.k][1]\\n        self.k += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.lst = []\\n        self.k = 0\\n        \\n    def add(self, name: str, score: int) -> None:\\n        x = (-score, name)\\n        if not self.lst or self.lst[-1] < x:\\n            self.lst.append(x)\\n            return\\n        \\n        lo, hi = 0, len(self.lst)\\n        while(lo<hi):\\n            mid = (lo+hi)//2\\n            if self.lst[mid]<x:\\n                lo = mid+1\\n            else:\\n                hi = mid\\n        self.lst.insert(lo, x)  # O(N) here\\n        \\n    def get(self) -> str:\\n        res = self.lst[self.k][1]\\n        self.k += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146436,
                "title": "using-std-set",
                "content": "```\\nusing pqt = pair<int, string>;\\nbool lessthan(const pqt& p1, const pqt& p2) {\\n    if (p1.first == p2.first)\\n        return p1.second > p2.second;\\n    return p1.first < p2.first;\\n}\\n\\nclass SORTracker {\\n    set<pqt, decltype(&lessthan)> s;\\n    set<pqt, decltype(&lessthan)>::const_iterator iter;\\npublic:\\n    SORTracker() : s(&lessthan) {\\n        iter = s.end();\\n    }\\n    \\n    void add(string name, int score) {\\n        auto p = make_pair(score, name);\\n        s.insert(p);\\n        if (iter != s.end() && !lessthan(p, *iter))\\n            iter++;\\n    }\\n    \\n    string get() {\\n        return (--iter)->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing pqt = pair<int, string>;\\nbool lessthan(const pqt& p1, const pqt& p2) {\\n    if (p1.first == p2.first)\\n        return p1.second > p2.second;\\n    return p1.first < p2.first;\\n}\\n\\nclass SORTracker {\\n    set<pqt, decltype(&lessthan)> s;\\n    set<pqt, decltype(&lessthan)>::const_iterator iter;\\npublic:\\n    SORTracker() : s(&lessthan) {\\n        iter = s.end();\\n    }\\n    \\n    void add(string name, int score) {\\n        auto p = make_pair(score, name);\\n        s.insert(p);\\n        if (iter != s.end() && !lessthan(p, *iter))\\n            iter++;\\n    }\\n    \\n    string get() {\\n        return (--iter)->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132898,
                "title": "scala-ac",
                "content": "```\\nimport scala.collection.mutable\\n\\nclass SORTracker {\\n\\n  case class Location(name: String, score: Int)\\n\\n  object orderedPQ1 extends Ordering[Location] {\\n    override def compare(a: Location, b: Location): Int = {\\n      if (a.score == b.score) {\\n        b.name compare a.name // (\"bc\"), (\"ab\")\\n      } else {\\n        a.score compare b.score // 1, 2, 3, 4, 5\\n      }\\n    }\\n  }\\n\\n  object orderedPQ2 extends Ordering[Location] {\\n    override def compare(a: Location, b: Location): Int = {\\n      if (a.score == b.score) {\\n        a.name compare b.name // (\"ab\"), (\"bc\")\\n      } else {\\n        b.score compare a.score // 5, 4, 3, 2, 1\\n      }\\n    }\\n  }\\n\\n  // min heap\\n  val pq1 = mutable.PriorityQueue[Location]()(orderedPQ1)\\n\\n  // max heap\\n  val pq2 = mutable.PriorityQueue[Location]()(orderedPQ2)\\n\\n  var i = 0\\n\\n  def add(name: String, score: Int): Unit = {\\n    pq2.addOne(Location(name, score))\\n    if (pq2.size > i) {\\n      pq1.addOne(pq2.dequeue())\\n    }\\n  }\\n\\n  def get(): String = {\\n    pq2.addOne(pq1.dequeue())\\n    i += 1\\n    pq2.head.name\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport scala.collection.mutable\\n\\nclass SORTracker {\\n\\n  case class Location(name: String, score: Int)\\n\\n  object orderedPQ1 extends Ordering[Location] {\\n    override def compare(a: Location, b: Location): Int = {\\n      if (a.score == b.score) {\\n        b.name compare a.name // (\"bc\"), (\"ab\")\\n      } else {\\n        a.score compare b.score // 1, 2, 3, 4, 5\\n      }\\n    }\\n  }\\n\\n  object orderedPQ2 extends Ordering[Location] {\\n    override def compare(a: Location, b: Location): Int = {\\n      if (a.score == b.score) {\\n        a.name compare b.name // (\"ab\"), (\"bc\")\\n      } else {\\n        b.score compare a.score // 5, 4, 3, 2, 1\\n      }\\n    }\\n  }\\n\\n  // min heap\\n  val pq1 = mutable.PriorityQueue[Location]()(orderedPQ1)\\n\\n  // max heap\\n  val pq2 = mutable.PriorityQueue[Location]()(orderedPQ2)\\n\\n  var i = 0\\n\\n  def add(name: String, score: Int): Unit = {\\n    pq2.addOne(Location(name, score))\\n    if (pq2.size > i) {\\n      pq1.addOne(pq2.dequeue())\\n    }\\n  }\\n\\n  def get(): String = {\\n    pq2.addOne(pq1.dequeue())\\n    i += 1\\n    pq2.head.name\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128876,
                "title": "python3-heap-bisect-o-nlogk",
                "content": "Key idea is to have a list (`self.lst`) to maintain the sorted top elements `(score, name)`, and a heap (`self.hq`) to track the others. \\n\\n```\\nimport bisect \\nimport heapq\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        \\n        self.hq = []\\n        self.lst = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        \\n        bisect.insort(self.lst, (-score, name))\\n        heapq.heappush(self.hq, self.lst.pop())\\n        \\n    def get(self) -> str:\\n        \\n        bisect.insort(self.lst, heapq.heappop(self.hq))\\n        return self.lst[-1][1]\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect \\nimport heapq\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        \\n        self.hq = []\\n        self.lst = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        \\n        bisect.insort(self.lst, (-score, name))\\n        heapq.heappush(self.hq, self.lst.pop())\\n        \\n    def get(self) -> str:\\n        \\n        bisect.insort(self.lst, heapq.heappop(self.hq))\\n        return self.lst[-1][1]\\n\\n# Your SORTracker object will be instantiated and called as such:\\n# obj = SORTracker()\\n# obj.add(name,score)\\n# param_2 = obj.get()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124388,
                "title": "rust-two-binaryheap-solution",
                "content": "```rust\\nuse std::{\\n    cmp::Ordering,\\n    collections::BinaryHeap,\\n};\\n\\n\\n#[derive(Eq, PartialEq, Debug)]\\nstruct MinNode {\\n    name: String,\\n    score: i32,\\n}\\n\\nimpl Ord for MinNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other\\n            .score\\n            .cmp(&self.score)\\n            .then(self.name.cmp(&other.name))\\n    }\\n}\\n\\nimpl PartialOrd for MinNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\n#[derive(Eq, PartialEq, Debug)]\\nstruct MaxNode {\\n    name: String,\\n    score: i32,\\n}\\n\\nimpl Ord for MaxNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self\\n            .score\\n            .cmp(&other.score)\\n            .then(other.name.cmp(&self.name))\\n    }\\n}\\n\\nimpl PartialOrd for MaxNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\n\\n#[derive(Debug)]\\nstruct SORTracker {\\n    top: BinaryHeap<MinNode>,\\n    bot: BinaryHeap<MaxNode>,\\n    idx: usize,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        SORTracker {\\n            top: BinaryHeap::new(),\\n            bot: BinaryHeap::new(),\\n            idx: 0,\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        self.top.push(MinNode { name, score });\\n        while self.top.len() > self.idx {\\n            let curr = self.top.pop().unwrap();\\n            self.bot.push(MaxNode {\\n                name: curr.name,\\n                score: curr.score,\\n            })\\n        }\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let curr = self.bot.pop().unwrap();\\n        self.idx += 1;\\n        self.top.push(MinNode {\\n            name: curr.name.clone(),\\n            score: curr.score,\\n        });\\n        curr.name\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    cmp::Ordering,\\n    collections::BinaryHeap,\\n};\\n\\n\\n#[derive(Eq, PartialEq, Debug)]\\nstruct MinNode {\\n    name: String,\\n    score: i32,\\n}\\n\\nimpl Ord for MinNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other\\n            .score\\n            .cmp(&self.score)\\n            .then(self.name.cmp(&other.name))\\n    }\\n}\\n\\nimpl PartialOrd for MinNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\n#[derive(Eq, PartialEq, Debug)]\\nstruct MaxNode {\\n    name: String,\\n    score: i32,\\n}\\n\\nimpl Ord for MaxNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        self\\n            .score\\n            .cmp(&other.score)\\n            .then(other.name.cmp(&self.name))\\n    }\\n}\\n\\nimpl PartialOrd for MaxNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\n\\n#[derive(Debug)]\\nstruct SORTracker {\\n    top: BinaryHeap<MinNode>,\\n    bot: BinaryHeap<MaxNode>,\\n    idx: usize,\\n}\\n\\nimpl SORTracker {\\n    fn new() -> Self {\\n        SORTracker {\\n            top: BinaryHeap::new(),\\n            bot: BinaryHeap::new(),\\n            idx: 0,\\n        }\\n    }\\n\\n    fn add(&mut self, name: String, score: i32) {\\n        self.top.push(MinNode { name, score });\\n        while self.top.len() > self.idx {\\n            let curr = self.top.pop().unwrap();\\n            self.bot.push(MaxNode {\\n                name: curr.name,\\n                score: curr.score,\\n            })\\n        }\\n    }\\n\\n    fn get(&mut self) -> String {\\n        let curr = self.bot.pop().unwrap();\\n        self.idx += 1;\\n        self.top.push(MinNode {\\n            name: curr.name.clone(),\\n            score: curr.score,\\n        });\\n        curr.name\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114068,
                "title": "java-using-min-and-max-heaps-with-explanation",
                "content": "Here\\'s a another take at the 2 heap solution with some more verbose explanation.\\n\\nThis solution is very similar to theheap solution for finding median from a data stream: https://leetcode.com/problems/find-median-from-data-stream/\\n\\n1. The location can be represented by a \\'City\\' class which has 2 immutable attributes, name and score.\\n\\n2. The location class is comparable and the criteria is that one with the higher score wins. If the score is the same, the one with the lexicographically smaller name wins.\\n\\n3. We define 2 heaps - one min heap and the other is max heap.\\n\\n4. The top of the min heap is larger than the top of the max heap. This ensures that all the items in the max heap are smaller than all the items in the min heap.\\n\\n5. The max heap is always of the size \\'rank\\'. The \\'rank\\' is the number of times \\'get\\' has been invoked. This ensures that the top of the max heap always has the location that must be returned in the next call to \\'get\\'.\\n\\n6. Whenever we add a location, it can either land in maxHeap or minHeap. If it lands in maxHeap, we need to ensure that if the size has exceeded the rank, we shif one location from max heap to min heap. If it lands in the min heap, we need to ensure that if the max heap\\'s size is less than the rank, we transfer one element from the min heap to the max heap.\\n\\n7. Whenever we \\'get\\' a location, we return the top item of the max heap. Also we increment the rank by 1 as we would now be returning the next ranked location in the next \\'get\\' call. We should also check that if the size of the max heap is less than rank + 1, and if yes, we transfer an element from min heap to max heap. This is necessary to be able to return the \\'rank + 1\\' item in the next invocation of the \\'get\\' method.\\n\\nTime complexity to add a single location = O(log n)\\nTime complexity to get a single location = O(log n)\\n```\\nclass SORTracker {\\n\\n    int rank = 1;\\n\\n    class City implements Comparable<City> {\\n        private final int score;\\n        private final String name;\\n\\n        public City(int score, String name) {\\n            this.score = score;\\n            this.name = name;\\n        }\\n\\n        public int compareTo(City other) {\\n            if (other.score != score) {\\n                return other.score - score;\\n            } else {\\n                return name.compareTo(other.name);\\n            }\\n        }\\n    }\\n\\n    PriorityQueue<City> minHeap = new PriorityQueue<>((a, b) -> {\\n        return a.compareTo(b);\\n    });\\n\\n    PriorityQueue<City> maxHeap = new PriorityQueue<>((a, b) -> {\\n        return a.compareTo(b) * -1;\\n    });\\n\\n    public void add(String name, int score) {\\n        City city = new City(score, name);\\n        if ((maxHeap.isEmpty() && minHeap.isEmpty()) || maxHeap.peek().compareTo(city) >= 0) {\\n            maxHeap.add(city);\\n            if (maxHeap.size() > rank) {\\n                minHeap.add(maxHeap.remove());\\n            }\\n        } else {\\n            minHeap.add(city);\\n            if (maxHeap.size() < rank) {\\n                maxHeap.add(minHeap.remove());\\n            }\\n        }\\n    }\\n\\n    public String get() {\\n        City city = maxHeap.peek();\\n        if (maxHeap.size() < rank + 1 && minHeap.size() > 0) {\\n            maxHeap.add(minHeap.remove());\\n        }\\n        rank++;\\n        return city.name;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker {\\n\\n    int rank = 1;\\n\\n    class City implements Comparable<City> {\\n        private final int score;\\n        private final String name;\\n\\n        public City(int score, String name) {\\n            this.score = score;\\n            this.name = name;\\n        }\\n\\n        public int compareTo(City other) {\\n            if (other.score != score) {\\n                return other.score - score;\\n            } else {\\n                return name.compareTo(other.name);\\n            }\\n        }\\n    }\\n\\n    PriorityQueue<City> minHeap = new PriorityQueue<>((a, b) -> {\\n        return a.compareTo(b);\\n    });\\n\\n    PriorityQueue<City> maxHeap = new PriorityQueue<>((a, b) -> {\\n        return a.compareTo(b) * -1;\\n    });\\n\\n    public void add(String name, int score) {\\n        City city = new City(score, name);\\n        if ((maxHeap.isEmpty() && minHeap.isEmpty()) || maxHeap.peek().compareTo(city) >= 0) {\\n            maxHeap.add(city);\\n            if (maxHeap.size() > rank) {\\n                minHeap.add(maxHeap.remove());\\n            }\\n        } else {\\n            minHeap.add(city);\\n            if (maxHeap.size() < rank) {\\n                maxHeap.add(minHeap.remove());\\n            }\\n        }\\n    }\\n\\n    public String get() {\\n        City city = maxHeap.peek();\\n        if (maxHeap.size() < rank + 1 && minHeap.size() > 0) {\\n            maxHeap.add(minHeap.remove());\\n        }\\n        rank++;\\n        return city.name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044358,
                "title": "two-heap-11-lines",
                "content": "```\\nclass SORTracker {\\n\\n    priority_queue< pair< int , string > > P , NP ;\\n    priority_queue< pair< int , string > , vector<pair< int , string >> , greater< pair< int , string > > > Q , NQ ;\\n    int cnt ; \\n    \\n    public:\\n    SORTracker() {\\n        P = NP ;\\n        Q = NQ ;\\n        cnt = 0 ;\\n    }\\n    \\n    void add(string name, int score) {\\n        pair< int , string > temp = { -score , name };\\n    \\n        P.push(temp);\\n        \\n        while( P.size() > cnt )\\n        {\\n            Q.push(P.top());\\n            P.pop();\\n        }\\n         \\n    }\\n    \\n    string get() {\\n        auto temp = Q.top(); Q.pop();\\n        P.push(temp);\\n        cnt++;\\n        return temp.second ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SORTracker {\\n\\n    priority_queue< pair< int , string > > P , NP ;\\n    priority_queue< pair< int , string > , vector<pair< int , string >> , greater< pair< int , string > > > Q , NQ ;\\n    int cnt ; \\n    \\n    public:\\n    SORTracker() {\\n        P = NP ;\\n        Q = NQ ;\\n        cnt = 0 ;\\n    }\\n    \\n    void add(string name, int score) {\\n        pair< int , string > temp = { -score , name };\\n    \\n        P.push(temp);\\n        \\n        while( P.size() > cnt )\\n        {\\n            Q.push(P.top());\\n            P.pop();\\n        }\\n         \\n    }\\n    \\n    string get() {\\n        auto temp = Q.top(); Q.pop();\\n        P.push(temp);\\n        cnt++;\\n        return temp.second ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030402,
                "title": "go-heaps",
                "content": "```\\n/*\\ninsertion sort will work as we add values into the stream, then to get the ith value\\nyou would return the value at idx. nlogn to do insertion sort but 1 for get\\n\\nyou could also use a heapq and insert values into it. then to get the ith largest value\\nwould be most reasonable. logn to insert values into the heap.\\n\\ncould this use the 2 heap solution of keeping min/max? Yes!\\nthe max heap keeps track of lower half values\\nthe min heap keeps track of top half values\\n\\nif len(minheap) > ith value that means the maxheap top\\ndoes not have the ith value. when the minheap < ith value\\nthat means the top of the max heap would have the ith value\\n\\nwhen you add values keep this invariant and when you get values\\ntake the top of the maxheap and add it to the minheap. \\n*/\\n\\ntype SORTracker struct {\\n    topHalf maxHeap\\n\\tbottomHalf minHeap\\n}\\n\\n\\nfunc Constructor() SORTracker {\\n\\ts := SORTracker{}\\n\\treturn s\\n}\\n\\n\\nfunc (s *SORTracker) Add(name string, score int)  {\\n    heap.Push(&s.topHalf, location{name, score})\\n    top := heap.Pop(&s.topHalf).(location)\\n    heap.Push(&s.bottomHalf, location{top.name, top.score})\\n}\\n\\nfunc (s *SORTracker) Get() string {\\n    i := heap.Pop(&s.bottomHalf).(location)\\n\\theap.Push(&s.topHalf, location{i.name, i.score})\\n\\treturn i.name\\n}\\n\\ntype location struct {\\n\\tname string\\n\\tscore int\\n}\\n\\ntype minHeap struct {\\n    locHeap\\n}\\ntype maxHeap struct {\\n    locHeap\\n}\\n\\nfunc (m minHeap) Less(i, j int) bool {\\n\\tif m.locHeap[i].score == m.locHeap[j].score {\\n\\t\\treturn m.locHeap[i].name < m.locHeap[j].name\\n\\t}\\n\\treturn m.locHeap[i].score > m.locHeap[j].score\\n}\\n\\nfunc (m maxHeap) Less(i, j int) bool {\\n\\tif m.locHeap[i].score == m.locHeap[j].score {\\n\\t\\treturn m.locHeap[i].name > m.locHeap[j].name\\n\\t}\\n\\treturn m.locHeap[i].score < m.locHeap[j].score\\n}\\ntype locHeap []location\\nfunc (m locHeap) Len() int { return len(m) }\\nfunc (m locHeap) Swap(i, j int) { m[i], m[j] = m[j], m[i] }\\nfunc (m *locHeap) Push(x interface{}) { *m = append(*m, x.(location)) }\\nfunc (m *locHeap) Pop() interface{} {\\n    x := (*m)[m.Len()-1]\\n    *m = (*m)[:m.Len()-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\ninsertion sort will work as we add values into the stream, then to get the ith value\\nyou would return the value at idx. nlogn to do insertion sort but 1 for get\\n\\nyou could also use a heapq and insert values into it. then to get the ith largest value\\nwould be most reasonable. logn to insert values into the heap.\\n\\ncould this use the 2 heap solution of keeping min/max? Yes!\\nthe max heap keeps track of lower half values\\nthe min heap keeps track of top half values\\n\\nif len(minheap) > ith value that means the maxheap top\\ndoes not have the ith value. when the minheap < ith value\\nthat means the top of the max heap would have the ith value\\n\\nwhen you add values keep this invariant and when you get values\\ntake the top of the maxheap and add it to the minheap. \\n*/\\n\\ntype SORTracker struct {\\n    topHalf maxHeap\\n\\tbottomHalf minHeap\\n}\\n\\n\\nfunc Constructor() SORTracker {\\n\\ts := SORTracker{}\\n\\treturn s\\n}\\n\\n\\nfunc (s *SORTracker) Add(name string, score int)  {\\n    heap.Push(&s.topHalf, location{name, score})\\n    top := heap.Pop(&s.topHalf).(location)\\n    heap.Push(&s.bottomHalf, location{top.name, top.score})\\n}\\n\\nfunc (s *SORTracker) Get() string {\\n    i := heap.Pop(&s.bottomHalf).(location)\\n\\theap.Push(&s.topHalf, location{i.name, i.score})\\n\\treturn i.name\\n}\\n\\ntype location struct {\\n\\tname string\\n\\tscore int\\n}\\n\\ntype minHeap struct {\\n    locHeap\\n}\\ntype maxHeap struct {\\n    locHeap\\n}\\n\\nfunc (m minHeap) Less(i, j int) bool {\\n\\tif m.locHeap[i].score == m.locHeap[j].score {\\n\\t\\treturn m.locHeap[i].name < m.locHeap[j].name\\n\\t}\\n\\treturn m.locHeap[i].score > m.locHeap[j].score\\n}\\n\\nfunc (m maxHeap) Less(i, j int) bool {\\n\\tif m.locHeap[i].score == m.locHeap[j].score {\\n\\t\\treturn m.locHeap[i].name > m.locHeap[j].name\\n\\t}\\n\\treturn m.locHeap[i].score < m.locHeap[j].score\\n}\\ntype locHeap []location\\nfunc (m locHeap) Len() int { return len(m) }\\nfunc (m locHeap) Swap(i, j int) { m[i], m[j] = m[j], m[i] }\\nfunc (m *locHeap) Push(x interface{}) { *m = append(*m, x.(location)) }\\nfunc (m *locHeap) Pop() interface{} {\\n    x := (*m)[m.Len()-1]\\n    *m = (*m)[:m.Len()-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024484,
                "title": "java-two-treeset-solution",
                "content": "```\\nclass SORTracker {\\n    class Location {\\n        String name;\\n        int score;\\n        public Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n        public String getName() {\\n            return name;\\n        }\\n        public int getScore() {\\n            return score;\\n        }\\n    }\\n    \\n    TreeSet<Location> tSet1;\\n    TreeSet<Location> tSet2;\\n\\n    public SORTracker() {\\n        tSet1 = new TreeSet<Location>((a,b)->{\\n            if (a.score != b.score) {\\n                return b.getScore() - a.getScore();\\n            } else {\\n                return a.getName().compareTo(b.getName());\\n            }\\n        });\\n        \\n        tSet2 = new TreeSet<Location>((a,b)->{\\n            if (a.score != b.score) {\\n                return b.getScore() - a.getScore();\\n            } else {\\n                return a.getName().compareTo(b.getName());\\n            }\\n        });\\n        \\n        \\n    }\\n    \\n    public void add(String name, int score) {\\n        tSet1.add(new Location(name, score));\\n        tSet2.add(tSet1.pollLast());\\n    }\\n    \\n    public String get() {\\n        Location res = tSet2.pollFirst();\\n        tSet1.add(res);\\n        return res.name;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\n    class Location {\\n        String name;\\n        int score;\\n        public Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n        public String getName() {\\n            return name;\\n        }\\n        public int getScore() {\\n            return score;\\n        }\\n    }\\n    \\n    TreeSet<Location> tSet1;\\n    TreeSet<Location> tSet2;\\n\\n    public SORTracker() {\\n        tSet1 = new TreeSet<Location>((a,b)->{\\n            if (a.score != b.score) {\\n                return b.getScore() - a.getScore();\\n            } else {\\n                return a.getName().compareTo(b.getName());\\n            }\\n        });\\n        \\n        tSet2 = new TreeSet<Location>((a,b)->{\\n            if (a.score != b.score) {\\n                return b.getScore() - a.getScore();\\n            } else {\\n                return a.getName().compareTo(b.getName());\\n            }\\n        });\\n        \\n        \\n    }\\n    \\n    public void add(String name, int score) {\\n        tSet1.add(new Location(name, score));\\n        tSet2.add(tSet1.pollLast());\\n    }\\n    \\n    public String get() {\\n        Location res = tSet2.pollFirst();\\n        tSet1.add(res);\\n        return res.name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985461,
                "title": "python-two-heaps",
                "content": "Two heap idea is similar to https://leetcode.com/problems/find-median-from-data-stream/. But top heap implementation is more complated because of a custom comparator.\\n```\\nclass Place:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    \\n    def __lt__(self,other):\\n        if self.score == other.score:\\n            return self.name > other.name\\n        return self.score < other.score\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.topHeap = []\\n        self.bottomHeap = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        heappush(self.topHeap, Place(name, score))\\n        place = heappop(self.topHeap)\\n        heappush(self.bottomHeap, (-place.score, place.name))\\n            \\n    def get(self) -> str:\\n        score, name = heappop(self.bottomHeap)\\n        heappush(self.topHeap, Place(name, -score))\\n        return name\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Place:\\n    def __init__(self, name, score):\\n        self.name = name\\n        self.score = score\\n    \\n    def __lt__(self,other):\\n        if self.score == other.score:\\n            return self.name > other.name\\n        return self.score < other.score\\n\\nclass SORTracker:\\n    def __init__(self):\\n        self.topHeap = []\\n        self.bottomHeap = []\\n\\n    def add(self, name: str, score: int) -> None:\\n        heappush(self.topHeap, Place(name, score))\\n        place = heappop(self.topHeap)\\n        heappush(self.bottomHeap, (-place.score, place.name))\\n            \\n    def get(self) -> str:\\n        score, name = heappop(self.bottomHeap)\\n        heappush(self.topHeap, Place(name, -score))\\n        return name\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980920,
                "title": "o-1-get-and-o-logn-add-ordered-set-based-sln",
                "content": "```\\nstruct Location {\\n    Location(string_view n, int s): name(n), score(s) {}\\n    string name;\\n    int score;\\n    bool operator<(const Location& other) const {\\n        return score == other.score ?\\n            name > other.name :\\n            score < other.score;\\n    }\\n};\\n\\nclass SORTracker {\\npublic:    \\n    void add(string name, int score) {\\n        const auto[it, _] = locations.emplace(name, score);\\n        if (size(locations) == 1) {\\n            itIth = begin(locations);\\n        }\\n        if (*itIth < *it) {\\n            itIth = next(itIth);\\n        }\\n        if (shouldAdvance) {\\n            shouldAdvance = false;\\n            itIth = prev(itIth);\\n        }\\n    }\\n    \\n    string get() {\\n        const auto res = itIth->name;\\n        if (itIth == begin(locations)) {\\n            shouldAdvance = true;\\n        }\\n        else {\\n            itIth = prev(itIth);\\n        }\\n        return res;\\n    }\\n    \\n    using Locations = set<Location>;\\n    Locations locations;\\n    Locations::iterator itIth;\\n    bool shouldAdvance = false;\\n};",
                "solutionTags": [],
                "code": "```\\nstruct Location {\\n    Location(string_view n, int s): name(n), score(s) {}\\n    string name;\\n    int score;\\n    bool operator<(const Location& other) const {\\n        return score == other.score ?\\n            name > other.name :\\n            score < other.score;\\n    }\\n};\\n\\nclass SORTracker {\\npublic:    \\n    void add(string name, int score) {\\n        const auto[it, _] = locations.emplace(name, score);\\n        if (size(locations) == 1) {\\n            itIth = begin(locations);\\n        }\\n        if (*itIth < *it) {\\n            itIth = next(itIth);\\n        }\\n        if (shouldAdvance) {\\n            shouldAdvance = false;\\n            itIth = prev(itIth);\\n        }\\n    }\\n    \\n    string get() {\\n        const auto res = itIth->name;\\n        if (itIth == begin(locations)) {\\n            shouldAdvance = true;\\n        }\\n        else {\\n            itIth = prev(itIth);\\n        }\\n        return res;\\n    }\\n    \\n    using Locations = set<Location>;\\n    Locations locations;\\n    Locations::iterator itIth;\\n    bool shouldAdvance = false;\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1954478,
                "title": "c-two-sets-heap-beat-73",
                "content": "```\\nstruct Location {\\n    string name;\\n    int score;\\n    Location() : name(\"\"), score(0) {}\\n    Location(string a, int b) : name(a), score(b) {}\\n};\\n// Score low to high\\nauto leftHeapComp = [](const Location& x, const Location& y) {\\n    if (x.score == y.score) return x.name > y.name;\\n    return x.score < y.score;\\n};\\n// Score high to low\\nauto rightHeapComp = [](const Location& x, const Location& y) {\\n    if (x.score == y.score) return x.name < y.name;\\n    return x.score > y.score;\\n};\\n\\nset<Location, decltype(leftHeapComp)> leftHeap(leftHeapComp);\\nset<Location, decltype(rightHeapComp)> rightHeap(rightHeapComp);\\n\\nclass SORTracker {\\npublic:\\n    int callCount;\\n\\n    SORTracker() {\\n        callCount = 0;\\n        leftHeap.clear();\\n        rightHeap.clear();\\n    }\\n\\n    void add(string name, int score) {\\n        leftHeap.insert(Location(name, score));\\n        while ((int)leftHeap.size() > callCount) {\\n            rightHeap.insert(*leftHeap.begin());\\n            leftHeap.erase(leftHeap.begin());\\n        }\\n    }\\n\\n    string get() {\\n        callCount++;\\n        while ((int)leftHeap.size() < callCount) {\\n            leftHeap.insert(*rightHeap.begin());\\n            rightHeap.erase(rightHeap.begin());\\n        }\\n        return leftHeap.begin()->name;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n\\n/**\\n\\nIdea: \\n=====\\n1. It seems ordered set/heap/priority queue is mandatory.\\n2. When get being called, if we traverse the heap/set to find desired item TLE will occur\\n3. If we maintain two heaps, where left heap will contain K (get call count) items and remaining items in right heap, then it will reduce time.\\n4. THIS PROBLEM IS LIKE ONLINE MEDIAN CALCULATION PROBLEM WHERE TWO HEAPS REQUIRED.\\n\\n**/\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nstruct Location {\\n    string name;\\n    int score;\\n    Location() : name(\"\"), score(0) {}\\n    Location(string a, int b) : name(a), score(b) {}\\n};\\n// Score low to high\\nauto leftHeapComp = [](const Location& x, const Location& y) {\\n    if (x.score == y.score) return x.name > y.name;\\n    return x.score < y.score;\\n};\\n// Score high to low\\nauto rightHeapComp = [](const Location& x, const Location& y) {\\n    if (x.score == y.score) return x.name < y.name;\\n    return x.score > y.score;\\n};\\n\\nset<Location, decltype(leftHeapComp)> leftHeap(leftHeapComp);\\nset<Location, decltype(rightHeapComp)> rightHeap(rightHeapComp);\\n\\nclass SORTracker {\\npublic:\\n    int callCount;\\n\\n    SORTracker() {\\n        callCount = 0;\\n        leftHeap.clear();\\n        rightHeap.clear();\\n    }\\n\\n    void add(string name, int score) {\\n        leftHeap.insert(Location(name, score));\\n        while ((int)leftHeap.size() > callCount) {\\n            rightHeap.insert(*leftHeap.begin());\\n            leftHeap.erase(leftHeap.begin());\\n        }\\n    }\\n\\n    string get() {\\n        callCount++;\\n        while ((int)leftHeap.size() < callCount) {\\n            leftHeap.insert(*rightHeap.begin());\\n            rightHeap.erase(rightHeap.begin());\\n        }\\n        return leftHeap.begin()->name;\\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n\\n/**\\n\\nIdea: \\n=====\\n1. It seems ordered set/heap/priority queue is mandatory.\\n2. When get being called, if we traverse the heap/set to find desired item TLE will occur\\n3. If we maintain two heaps, where left heap will contain K (get call count) items and remaining items in right heap, then it will reduce time.\\n4. THIS PROBLEM IS LIKE ONLINE MEDIAN CALCULATION PROBLEM WHERE TWO HEAPS REQUIRED.\\n\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947147,
                "title": "python-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.i=0\\n        self.sl=SortedList()\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.sl.add((-score,name))\\n\\n    def get(self) -> str:\\n        self.i+=1\\n        return self.sl[self.i-1][1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.i=0\\n        self.sl=SortedList()\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.sl.add((-score,name))\\n\\n    def get(self) -> str:\\n        self.i+=1\\n        return self.sl[self.i-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937815,
                "title": "java-explained-30-lines-of-o-log-n-on-add-using-binary-search-and-sorted-array",
                "content": "```java\\nimport java.util.AbstractMap.SimpleEntry;\\nclass SORTracker {\\n    private final List<SimpleEntry<String, Integer>> alwaysSortedList;\\n    private int currCounter;\\n    public SORTracker() {\\n        currCounter=0;\\n        alwaysSortedList = new ArrayList<SimpleEntry<String, Integer>> () {\\n            public boolean add(SimpleEntry<String, Integer> mt) {\\n                int index = Collections.binarySearch(\\n                    this, \\n                    mt,\\n                    (a,b)-> {\\n                        if (!a.getValue().equals(b.getValue())) {\\n                            return b.getValue()-a.getValue();\\n                        } else {\\n                            return a.getKey().compareTo(b.getKey());\\n                        }\\n                    }\\n                );\\n                if (index < 0) index = ~index;\\n                super.add(index, mt);\\n                return true;\\n            }\\n        };\\n    }\\n    \\n    public void add(String name, int score) {\\n        alwaysSortedList.add(new SimpleEntry(name, score));\\n    }\\n    \\n    public String get() {\\n        SimpleEntry<String, Integer> entry = alwaysSortedList.get(currCounter);\\n        currCounter++;\\n        return entry.getKey();\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n ```",
                "solutionTags": [
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```java\\nimport java.util.AbstractMap.SimpleEntry;\\nclass SORTracker {\\n    private final List<SimpleEntry<String, Integer>> alwaysSortedList;\\n    private int currCounter;\\n    public SORTracker() {\\n        currCounter=0;\\n        alwaysSortedList = new ArrayList<SimpleEntry<String, Integer>> () {\\n            public boolean add(SimpleEntry<String, Integer> mt) {\\n                int index = Collections.binarySearch(\\n                    this, \\n                    mt,\\n                    (a,b)-> {\\n                        if (!a.getValue().equals(b.getValue())) {\\n                            return b.getValue()-a.getValue();\\n                        } else {\\n                            return a.getKey().compareTo(b.getKey());\\n                        }\\n                    }\\n                );\\n                if (index < 0) index = ~index;\\n                super.add(index, mt);\\n                return true;\\n            }\\n        };\\n    }\\n    \\n    public void add(String name, int score) {\\n        alwaysSortedList.add(new SimpleEntry(name, score));\\n    }\\n    \\n    public String get() {\\n        SimpleEntry<String, Integer> entry = alwaysSortedList.get(currCounter);\\n        currCounter++;\\n        return entry.getKey();\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1924861,
                "title": "java-explained-array-binary-search-system-arraycopy-shift-faster-than-80",
                "content": "If we don\\'t mind throwing a 40,000-element array at the problem, we can fill an array right-to-left (best element to the left, worst to the right) so we can leverage System.arraycopy to shift elements to make room for insertion.  We track where the first element is, and move it left as we insert.  We track a query count as well, and increment it after querying.  This makes add O(n log n) for binary search and worst case n shifts, and makes for a constant-time get - O(1).  Our space cost is O(max_n) which is kind of gross, but it beats allocating new arrays each time we expand.  The reason we can use System.arraycopy by keeping our values in the right side of the array is that our source index is always 1 larger than our destination index, so we are reading values before we overwrite them.  Shifting right means our source index is always 1 smaller than our destination index, and we\\'d end up reading values that had already been overwritten by System.arraycopy, and we\\'d have to copy manually starting from the right, instead.  No, thanks.\\n\\nIf our max size was potentially larger where we were concerned about allocating an extremely large amount of space for smaller use cases, we could add an ensureCapacity option to reallocate a larger array whenever it grows to large - but at that point, it would probably be worth it to just use an ArrayList instead and let it manage capacity and the array for us (we could still use the [binary search method in java.util.Collections](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Collections.html#binarySearch(java.util.List,T))).  But something felt a little more fun about doing it this way.\\n\\nNote that we have to handle negative indices from the binarySearch method.  A non-negative index represents the insertion point at an equal value (see [the JavaDoc](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#binarySearch(java.lang.Object%5B%5D,int,int,java.lang.Object))).  A negative index represents -1-ip where ip is the insertion point.  So if we get a negative index, we convert it to a non-negative insertion index.  And we insert at idx - 1 because we are shifting elements left to make room (instead of right).\\n\\nProbably not the most optimal solution, but it beats 80% by skipping collections overhead, most of which ultimately end up paying a similar time cost in terms of complexity (typically with a larger coefficient) albeit for less space.\\n\\n```\\nclass SORTracker {\\n\\n    static final int MAX_COUNT = 40000;\\n\\n    final Location[] locations;\\n    int first;\\n    int count;\\n\\n    public SORTracker() {\\n        this.locations = new Location[MAX_COUNT];\\n        this.first = this.locations.length;\\n\\t\\tthis.count = 0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        final Location location = new Location(name, score);\\n        int idx = Arrays.binarySearch(this.locations, this.first, this.locations.length, location);\\n        if (idx < 0) {\\n            idx = -(idx + 1);\\n        }\\n        int length = (idx - first);\\n        if (length > 0) {\\n            System.arraycopy(this.locations, this.first, this.locations, this.first - 1, length);\\n        }\\n        this.locations[idx - 1] = location;\\n        this.first--;\\n    }\\n    \\n    public String get() {\\n        final String out = this.locations[this.first + this.count].name;\\n        this.count++;\\n        return out;\\n    }\\n\\n    static class Location implements Comparable<Location> {\\n\\n        final String name;\\n        final int score;\\n        \\n        Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n\\n        @Override\\n        public int compareTo(Location other) {\\n            int diff = Integer.compare(other.score, this.score);\\n            if (diff == 0) {\\n                diff = this.name.compareTo(other.name);\\n            }\\n            return diff;\\n        }\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass SORTracker {\\n\\n    static final int MAX_COUNT = 40000;\\n\\n    final Location[] locations;\\n    int first;\\n    int count;\\n\\n    public SORTracker() {\\n        this.locations = new Location[MAX_COUNT];\\n        this.first = this.locations.length;\\n\\t\\tthis.count = 0;\\n    }\\n    \\n    public void add(String name, int score) {\\n        final Location location = new Location(name, score);\\n        int idx = Arrays.binarySearch(this.locations, this.first, this.locations.length, location);\\n        if (idx < 0) {\\n            idx = -(idx + 1);\\n        }\\n        int length = (idx - first);\\n        if (length > 0) {\\n            System.arraycopy(this.locations, this.first, this.locations, this.first - 1, length);\\n        }\\n        this.locations[idx - 1] = location;\\n        this.first--;\\n    }\\n    \\n    public String get() {\\n        final String out = this.locations[this.first + this.count].name;\\n        this.count++;\\n        return out;\\n    }\\n\\n    static class Location implements Comparable<Location> {\\n\\n        final String name;\\n        final int score;\\n        \\n        Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n\\n        @Override\\n        public int compareTo(Location other) {\\n            int diff = Integer.compare(other.score, this.score);\\n            if (diff == 0) {\\n                diff = this.name.compareTo(other.name);\\n            }\\n            return diff;\\n        }\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918831,
                "title": "c-easy-to-understand-using-two-priorityqueue",
                "content": "Explaination\\uFF1A\\n1.minHeap\\uFF1Acount of minHeap equal to call times and store all location keys which rank less than call times. \\n2.maxHeap: store all locations keys which rank greater or equal to call times. So the top of maxHeap is the next key.\\n3.Everytime call Add() API, we enqueue it to maxHeap first, then check if the top of maxheap should swap with top of minheap. \\n\\n```\\n    public class SORTracker\\n    {\\n        private readonly PriorityQueue<string, string> maxHeap;\\n        private readonly PriorityQueue<string, string> minHeap;\\n        private readonly Dictionary<string, int> dict;\\n        public SORTracker()\\n        {\\n            dict = new Dictionary<string, int>();\\n\\t\\t\\t//beware of the diffierent compare instance of minheap and maxheap\\n            maxHeap = new PriorityQueue<string, string>(Comparer<string>.Create(\\n                new Comparison<string>((x, y) =>\\n                {\\n                    if (dict[x] != dict[y]) return dict[y] - dict[x];\\n                    else return x.CompareTo(y);\\n                })));\\n\\n            minHeap = new PriorityQueue<string, string>(Comparer<string>.Create(\\n                new Comparison<string>((x, y) =>\\n                {\\n                    if (dict[x] != dict[y]) return dict[x] - dict[y];\\n                    else return y.CompareTo(x);\\n                })));\\n        }\\n\\n        public void Add(string name, int score)\\n        {\\n            dict.Add(name, score);\\n            maxHeap.Enqueue(name, name);//enqueue to maxHeap first\\n            while (minHeap.Count>0)\\n            {\\n                var max = maxHeap.Peek();\\n                var min = minHeap.Peek();\\n\\t\\t\\t\\t//check if should swap the top of maxHeap and minHeap\\n                if (dict[max] > dict[min] ||\\n                    (dict[max] == dict[min] && max.CompareTo(min) == -1))\\n                {\\n                    max = maxHeap.Dequeue();\\n                    min = minHeap.Dequeue();\\n                    maxHeap.Enqueue(min, min);\\n                    minHeap.Enqueue(max, max);\\n                }\\n                else break;\\n            }\\n        }\\n\\n        public string Get()\\n        {\\n            var key=maxHeap.Dequeue();\\n            minHeap.Enqueue(key, key);//dequeue the top of maxheap then enqueue it to minheap\\n            return key;\\n        }\\n    }\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public class SORTracker\\n    {\\n        private readonly PriorityQueue<string, string> maxHeap;\\n        private readonly PriorityQueue<string, string> minHeap;\\n        private readonly Dictionary<string, int> dict;\\n        public SORTracker()\\n        {\\n            dict = new Dictionary<string, int>();\\n\\t\\t\\t//beware of the diffierent compare instance of minheap and maxheap\\n            maxHeap = new PriorityQueue<string, string>(Comparer<string>.Create(\\n                new Comparison<string>((x, y) =>\\n                {\\n                    if (dict[x] != dict[y]) return dict[y] - dict[x];\\n                    else return x.CompareTo(y);\\n                })));\\n\\n            minHeap = new PriorityQueue<string, string>(Comparer<string>.Create(\\n                new Comparison<string>((x, y) =>\\n                {\\n                    if (dict[x] != dict[y]) return dict[x] - dict[y];\\n                    else return y.CompareTo(x);\\n                })));\\n        }\\n\\n        public void Add(string name, int score)\\n        {\\n            dict.Add(name, score);\\n            maxHeap.Enqueue(name, name);//enqueue to maxHeap first\\n            while (minHeap.Count>0)\\n            {\\n                var max = maxHeap.Peek();\\n                var min = minHeap.Peek();\\n\\t\\t\\t\\t//check if should swap the top of maxHeap and minHeap\\n                if (dict[max] > dict[min] ||\\n                    (dict[max] == dict[min] && max.CompareTo(min) == -1))\\n                {\\n                    max = maxHeap.Dequeue();\\n                    min = minHeap.Dequeue();\\n                    maxHeap.Enqueue(min, min);\\n                    minHeap.Enqueue(max, max);\\n                }\\n                else break;\\n            }\\n        }\\n\\n        public string Get()\\n        {\\n            var key=maxHeap.Dequeue();\\n            minHeap.Enqueue(key, key);//dequeue the top of maxheap then enqueue it to minheap\\n            return key;\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865510,
                "title": "csharp-2-priorityqueues-minheap-maxheap",
                "content": "```\\npublic class SORTracker\\n{\\n    public class DescComparator : IComparer<(int, string)>\\n    {\\n        public int Compare((int, string) x, (int, string) y)\\n        {\\n            int val = y.Item1.CompareTo(x.Item1);\\n            if (val == 0) val = x.Item2.CompareTo(y.Item2);\\n            return val;\\n        }\\n    }\\n    public class AscComparator : IComparer<(int, string)>\\n    {\\n        public int Compare((int, string) x, (int, string) y)\\n        {\\n            int val = x.Item1.CompareTo(y.Item1);\\n            if (val == 0) val = y.Item2.CompareTo(x.Item2);\\n            return val;\\n        }\\n    }\\n\\n    readonly PriorityQueue<string, (int, string)> pqTop;\\n    readonly PriorityQueue<string, (int, string)> pqBot;\\n    int getCounter = 0;\\n    readonly DescComparator desc;\\n    readonly AscComparator asc;\\n    public SORTracker()\\n    {\\n        desc = new DescComparator();\\n        asc = new AscComparator();\\n        pqBot = new PriorityQueue<string, (int, string)>(desc);\\n        pqTop = new PriorityQueue<string, (int, string)>(asc);\\n    }\\n\\n    public void Add(string name, int score)\\n    {\\n        pqTop.Enqueue(name, (score, name));\\n        while (pqTop.Count > getCounter)\\n        {\\n            _ = pqTop.TryDequeue(out _, out (int score, string name) priority);\\n            pqBot.Enqueue(priority.name, (priority.score, priority.name)); \\n        }\\n    }\\n\\n    public string Get()\\n    {\\n        _ = pqBot.TryDequeue(out _, out (int score, string name) priority);\\n        pqTop.Enqueue(priority.name, (priority.score, priority.name));\\n        getCounter++;\\n        return priority.name;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class SORTracker\\n{\\n    public class DescComparator : IComparer<(int, string)>\\n    {\\n        public int Compare((int, string) x, (int, string) y)\\n        {\\n            int val = y.Item1.CompareTo(x.Item1);\\n            if (val == 0) val = x.Item2.CompareTo(y.Item2);\\n            return val;\\n        }\\n    }\\n    public class AscComparator : IComparer<(int, string)>\\n    {\\n        public int Compare((int, string) x, (int, string) y)\\n        {\\n            int val = x.Item1.CompareTo(y.Item1);\\n            if (val == 0) val = y.Item2.CompareTo(x.Item2);\\n            return val;\\n        }\\n    }\\n\\n    readonly PriorityQueue<string, (int, string)> pqTop;\\n    readonly PriorityQueue<string, (int, string)> pqBot;\\n    int getCounter = 0;\\n    readonly DescComparator desc;\\n    readonly AscComparator asc;\\n    public SORTracker()\\n    {\\n        desc = new DescComparator();\\n        asc = new AscComparator();\\n        pqBot = new PriorityQueue<string, (int, string)>(desc);\\n        pqTop = new PriorityQueue<string, (int, string)>(asc);\\n    }\\n\\n    public void Add(string name, int score)\\n    {\\n        pqTop.Enqueue(name, (score, name));\\n        while (pqTop.Count > getCounter)\\n        {\\n            _ = pqTop.TryDequeue(out _, out (int score, string name) priority);\\n            pqBot.Enqueue(priority.name, (priority.score, priority.name)); \\n        }\\n    }\\n\\n    public string Get()\\n    {\\n        _ = pqBot.TryDequeue(out _, out (int score, string name) priority);\\n        pqTop.Enqueue(priority.name, (priority.score, priority.name));\\n        getCounter++;\\n        return priority.name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820197,
                "title": "c-using-two-priority-queues-with-big-top-and-small-top",
                "content": "The size of big number queue(small top) should be equal to the count of calling \"get()\".\\nAfter calling \"get()\",we should move the biggest number from small queue to big queue.\\n```\\nclass SORTracker {\\n    int get_cnt_ = 1;\\n    std::priority_queue<std::pair<int,std::string>,std::vector<std::pair<int,std::string>>, my_cmp_bigtop> big_nums_;\\n    std::priority_queue<std::pair<int,std::string>,std::vector<std::pair<int,std::string>>, my_cmp_smalltop> small_nums_;\\npublic:\\n    SORTracker() {\\n    }\\n\\n    void add(string name, int score) {\\n        big_nums_.push(std::make_pair(score,name));\\n        if(big_nums_.size() > get_cnt_){\\n            small_nums_.push(big_nums_.top());\\n            big_nums_.pop();\\n        }\\n    }\\n\\n    string get() {\\n        auto ret = big_nums_.top();\\n        if(!small_nums_.empty()){\\n            big_nums_.push(small_nums_.top());\\n            small_nums_.pop();\\n        }\\n        get_cnt_++;\\n        return ret.second;\\n    }\\n};\\n\\n\\nstruct my_cmp_smalltop{\\n    bool operator()(const std::pair<int,std::string>& p1,const std::pair<int,std::string>& p2) {\\n        if(p1.first == p2.first){\\n            return p1.second > p2.second;\\n        }else{\\n            return p1.first < p2.first;\\n        }\\n    }\\n};\\n\\nstruct my_cmp_bigtop{\\n    bool operator()(const std::pair<int,std::string>& p1,const std::pair<int,std::string>& p2) {\\n        if(p1.first == p2.first){\\n            return p1.second < p2.second;\\n        }else{\\n            return p1.first > p2.first;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "The size of big number queue(small top) should be equal to the count of calling \"get()\".\\nAfter calling \"get()\",we should move the biggest number from small queue to big queue.\\n```\\nclass SORTracker {\\n    int get_cnt_ = 1;\\n    std::priority_queue<std::pair<int,std::string>,std::vector<std::pair<int,std::string>>, my_cmp_bigtop> big_nums_;\\n    std::priority_queue<std::pair<int,std::string>,std::vector<std::pair<int,std::string>>, my_cmp_smalltop> small_nums_;\\npublic:\\n    SORTracker() {\\n    }\\n\\n    void add(string name, int score) {\\n        big_nums_.push(std::make_pair(score,name));\\n        if(big_nums_.size() > get_cnt_){\\n            small_nums_.push(big_nums_.top());\\n            big_nums_.pop();\\n        }\\n    }\\n\\n    string get() {\\n        auto ret = big_nums_.top();\\n        if(!small_nums_.empty()){\\n            big_nums_.push(small_nums_.top());\\n            small_nums_.pop();\\n        }\\n        get_cnt_++;\\n        return ret.second;\\n    }\\n};\\n\\n\\nstruct my_cmp_smalltop{\\n    bool operator()(const std::pair<int,std::string>& p1,const std::pair<int,std::string>& p2) {\\n        if(p1.first == p2.first){\\n            return p1.second > p2.second;\\n        }else{\\n            return p1.first < p2.first;\\n        }\\n    }\\n};\\n\\nstruct my_cmp_bigtop{\\n    bool operator()(const std::pair<int,std::string>& p1,const std::pair<int,std::string>& p2) {\\n        if(p1.first == p2.first){\\n            return p1.second < p2.second;\\n        }else{\\n            return p1.first > p2.first;\\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1729092,
                "title": "cpp-set",
                "content": "```\\n\\nstruct cmp{\\n    bool operator() (pair<int,string> a,pair<int,string> b) const{\\n    if(a.first==b.first)return a.second>b.second;\\n    return a.first<b.first;\\n}\\n};\\n\\nset<pair<int,string>,cmp> st;\\n\\nclass SORTracker {\\npublic:\\n    set<pair<int,string>>::iterator it;\\n    int t=0;\\n    \\n    SORTracker() {\\n        st.clear();\\n        t=0;\\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int,string> p={score,name};\\n        st.insert(p);\\n        if(st.size()==1)it=st.begin();\\n        else {\\n            if(score>(*it).first)it++;\\n            else if(score==(*it).first and name<(*it).second)it++;\\n        }\\n    }\\n    \\n    string get() {\\n        if(t)it--;\\n        string ans=(*it).second;\\n        t=1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nstruct cmp{\\n    bool operator() (pair<int,string> a,pair<int,string> b) const{\\n    if(a.first==b.first)return a.second>b.second;\\n    return a.first<b.first;\\n}\\n};\\n\\nset<pair<int,string>,cmp> st;\\n\\nclass SORTracker {\\npublic:\\n    set<pair<int,string>>::iterator it;\\n    int t=0;\\n    \\n    SORTracker() {\\n        st.clear();\\n        t=0;\\n    }\\n    \\n    void add(string name, int score) {\\n        pair<int,string> p={score,name};\\n        st.insert(p);\\n        if(st.size()==1)it=st.begin();\\n        else {\\n            if(score>(*it).first)it++;\\n            else if(score==(*it).first and name<(*it).second)it++;\\n        }\\n    }\\n    \\n    string get() {\\n        if(t)it--;\\n        string ans=(*it).second;\\n        t=1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673874,
                "title": "c-min-heap-max-heap-solution",
                "content": "```\\n#define MAX_NODES 40000\\n\\ntypedef struct {\\n    const char* name;\\n    int score;\\n} Node;\\n\\ntypedef struct {\\n    bool min;\\n    int size;\\n    Node heap[MAX_NODES];\\n} Heap;\\n\\ntypedef struct {\\n    Heap min;\\n    Heap max;\\n} SORTracker;\\n\\nstatic inline int getFirstChildIndex(int idx)\\n{\\n    return idx * 2 + 1;\\n}\\n\\nstatic inline int getParentIndex(int idx)\\n{\\n    return (idx - 1) / 2;\\n}\\n\\nstatic inline bool nodeCompare(const Node* n1, const Node* n2)\\n{\\n    if (n1->score < n2->score) {\\n        return true;\\n    } else if (n1->score == n2->score) {\\n        return strcmp(n1->name, n2->name) > 0;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nstatic inline bool heapCompare(Heap *h, int idx1, int idx2)\\n{\\n    return nodeCompare(&h->heap[idx1], &h->heap[idx2]);\\n}\\n\\nstatic inline void heapSwap(Heap *h, int idx1, int idx2)\\n{\\n    const Node temp = h->heap[idx1];\\n    \\n    h->heap[idx1] = h->heap[idx2];\\n    h->heap[idx2] = temp;\\n}\\n\\nstatic void heapBalanceUp(Heap* h) \\n{\\n    int cIdx = h->size - 1;\\n    \\n    while (cIdx > 0) {\\n        const int pIdx = getParentIndex(cIdx);\\n        \\n        if (h->min) {\\n            if (heapCompare(h, cIdx, pIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        } else {\\n            if (heapCompare(h, pIdx, cIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        }\\n        cIdx = pIdx;\\n    }\\n}\\n\\nstatic void heapBalanceDown(Heap* h)\\n{\\n    int pIdx = 0;\\n    \\n    while (1) {\\n        const int cIdx1 = getFirstChildIndex(pIdx);\\n        const int cIdx2 = cIdx1 + 1;\\n        int cIdx = -1;\\n        \\n        if (cIdx2 < h->size) {\\n            if (h->min) {\\n                if (heapCompare(h, cIdx1, cIdx2)) {\\n                    cIdx = cIdx1;\\n                } else {\\n                    cIdx = cIdx2;\\n                }\\n            } else {\\n                if (heapCompare(h, cIdx1, cIdx2)) {\\n                    cIdx = cIdx2;\\n                } else {\\n                    cIdx = cIdx1;\\n                }\\n            }\\n        } else if (cIdx1 < h->size) {\\n            cIdx = cIdx1;\\n        } else {\\n            break;\\n        }\\n        \\n        if (h->min) {\\n            if (heapCompare(h, cIdx, pIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        } else {\\n            if (heapCompare(h, pIdx, cIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        }\\n        pIdx = cIdx;\\n    }\\n}\\n\\nstatic void heapPush(Heap *h, char* name, int score)\\n{\\n    h->heap[h->size++] = (Node){ name, score };\\n    if (h->size > 1) {\\n        heapBalanceUp(h);\\n    }\\n}\\n\\nstatic const Node* heapPeak(Heap *h) \\n{\\n    const Node* ret = NULL;\\n\\n    if (h->size > 0) {\\n        ret = &h->heap[0];\\n    }\\n    \\n    return ret;\\n}\\n\\nstatic const Node* heapPop(Heap *h)\\n{\\n    const Node* ret = NULL;\\n\\n    if (h->size > 0) {\\n        h->size--;\\n        heapSwap(h, 0, h->size);\\n\\n        if (h->size > 1) {\\n            heapBalanceDown(h);\\n        }\\n        \\n        ret = &h->heap[h->size];\\n    }\\n    \\n    return ret;\\n}\\n\\nSORTracker* sORTrackerCreate() {\\n    SORTracker* h = calloc(1, sizeof(SORTracker));\\n    \\n    h->min.min = true;\\n    h->max.min = false;\\n    \\n    return h;\\n}\\n\\nvoid sORTrackerAdd(SORTracker* obj, char * name, int score) {\\n    const Node *peak = heapPeak(&obj->min);\\n    const Node temp = { name, score };\\n\\n    if (peak == NULL || nodeCompare(&temp, peak)) {\\n        heapPush(&obj->max, name, score);\\n    } else {\\n        heapPush(&obj->min, name, score);\\n        peak = heapPop(&obj->min);\\n        heapPush(&obj->max, peak->name, peak->score);\\n    }\\n}\\n\\nchar *sORTrackerGet(SORTracker* obj) {\\n    const Node *popped = heapPop(&obj->max);\\n\\n    heapPush(&obj->min, popped->name, popped->score);\\n    popped = heapPeak(&obj->min);\\n\\n    return popped->name;\\n}\\n\\nvoid sORTrackerFree(SORTracker* obj) {\\n    free(obj);\\n}\\n\\n/**\\n * Your SORTracker struct will be instantiated and called as such:\\n * SORTracker* obj = sORTrackerCreate();\\n * sORTrackerAdd(obj, name, score);\\n \\n * char * param_2 = sORTrackerGet(obj);\\n \\n * sORTrackerFree(obj);\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define MAX_NODES 40000\\n\\ntypedef struct {\\n    const char* name;\\n    int score;\\n} Node;\\n\\ntypedef struct {\\n    bool min;\\n    int size;\\n    Node heap[MAX_NODES];\\n} Heap;\\n\\ntypedef struct {\\n    Heap min;\\n    Heap max;\\n} SORTracker;\\n\\nstatic inline int getFirstChildIndex(int idx)\\n{\\n    return idx * 2 + 1;\\n}\\n\\nstatic inline int getParentIndex(int idx)\\n{\\n    return (idx - 1) / 2;\\n}\\n\\nstatic inline bool nodeCompare(const Node* n1, const Node* n2)\\n{\\n    if (n1->score < n2->score) {\\n        return true;\\n    } else if (n1->score == n2->score) {\\n        return strcmp(n1->name, n2->name) > 0;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nstatic inline bool heapCompare(Heap *h, int idx1, int idx2)\\n{\\n    return nodeCompare(&h->heap[idx1], &h->heap[idx2]);\\n}\\n\\nstatic inline void heapSwap(Heap *h, int idx1, int idx2)\\n{\\n    const Node temp = h->heap[idx1];\\n    \\n    h->heap[idx1] = h->heap[idx2];\\n    h->heap[idx2] = temp;\\n}\\n\\nstatic void heapBalanceUp(Heap* h) \\n{\\n    int cIdx = h->size - 1;\\n    \\n    while (cIdx > 0) {\\n        const int pIdx = getParentIndex(cIdx);\\n        \\n        if (h->min) {\\n            if (heapCompare(h, cIdx, pIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        } else {\\n            if (heapCompare(h, pIdx, cIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        }\\n        cIdx = pIdx;\\n    }\\n}\\n\\nstatic void heapBalanceDown(Heap* h)\\n{\\n    int pIdx = 0;\\n    \\n    while (1) {\\n        const int cIdx1 = getFirstChildIndex(pIdx);\\n        const int cIdx2 = cIdx1 + 1;\\n        int cIdx = -1;\\n        \\n        if (cIdx2 < h->size) {\\n            if (h->min) {\\n                if (heapCompare(h, cIdx1, cIdx2)) {\\n                    cIdx = cIdx1;\\n                } else {\\n                    cIdx = cIdx2;\\n                }\\n            } else {\\n                if (heapCompare(h, cIdx1, cIdx2)) {\\n                    cIdx = cIdx2;\\n                } else {\\n                    cIdx = cIdx1;\\n                }\\n            }\\n        } else if (cIdx1 < h->size) {\\n            cIdx = cIdx1;\\n        } else {\\n            break;\\n        }\\n        \\n        if (h->min) {\\n            if (heapCompare(h, cIdx, pIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        } else {\\n            if (heapCompare(h, pIdx, cIdx)) {\\n                heapSwap(h, cIdx, pIdx);\\n            } else {\\n                break;\\n            }\\n        }\\n        pIdx = cIdx;\\n    }\\n}\\n\\nstatic void heapPush(Heap *h, char* name, int score)\\n{\\n    h->heap[h->size++] = (Node){ name, score };\\n    if (h->size > 1) {\\n        heapBalanceUp(h);\\n    }\\n}\\n\\nstatic const Node* heapPeak(Heap *h) \\n{\\n    const Node* ret = NULL;\\n\\n    if (h->size > 0) {\\n        ret = &h->heap[0];\\n    }\\n    \\n    return ret;\\n}\\n\\nstatic const Node* heapPop(Heap *h)\\n{\\n    const Node* ret = NULL;\\n\\n    if (h->size > 0) {\\n        h->size--;\\n        heapSwap(h, 0, h->size);\\n\\n        if (h->size > 1) {\\n            heapBalanceDown(h);\\n        }\\n        \\n        ret = &h->heap[h->size];\\n    }\\n    \\n    return ret;\\n}\\n\\nSORTracker* sORTrackerCreate() {\\n    SORTracker* h = calloc(1, sizeof(SORTracker));\\n    \\n    h->min.min = true;\\n    h->max.min = false;\\n    \\n    return h;\\n}\\n\\nvoid sORTrackerAdd(SORTracker* obj, char * name, int score) {\\n    const Node *peak = heapPeak(&obj->min);\\n    const Node temp = { name, score };\\n\\n    if (peak == NULL || nodeCompare(&temp, peak)) {\\n        heapPush(&obj->max, name, score);\\n    } else {\\n        heapPush(&obj->min, name, score);\\n        peak = heapPop(&obj->min);\\n        heapPush(&obj->max, peak->name, peak->score);\\n    }\\n}\\n\\nchar *sORTrackerGet(SORTracker* obj) {\\n    const Node *popped = heapPop(&obj->max);\\n\\n    heapPush(&obj->min, popped->name, popped->score);\\n    popped = heapPeak(&obj->min);\\n\\n    return popped->name;\\n}\\n\\nvoid sORTrackerFree(SORTracker* obj) {\\n    free(obj);\\n}\\n\\n/**\\n * Your SORTracker struct will be instantiated and called as such:\\n * SORTracker* obj = sORTrackerCreate();\\n * sORTrackerAdd(obj, name, score);\\n \\n * char * param_2 = sORTrackerGet(obj);\\n \\n * sORTrackerFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1669134,
                "title": "neat-java-treeset-based-solution",
                "content": "```\\nimport java.util.TreeSet;\\n\\npublic class SORTracker {\\n\\n    TreeNode nodeToGet = null;\\n    TreeSet<TreeNode> tree;\\n    TreeNode prev = null;\\n    \\n    public SORTracker() {\\n        tree = new TreeSet<>();\\n    }\\n\\n   public void add(String name, int score) {\\n        TreeNode node = new TreeNode(score, name);\\n        tree.add(node);\\n        if (nodeToGet == null) {\\n            nodeToGet = tree.last();\\n        } else {\\n            if (node.compareTo(nodeToGet) < 0) {\\n                nodeToGet = tree.lower(nodeToGet);\\n            }\\n        }\\n    }\\n\\n    public String get() {\\n        String retVal = nodeToGet.name;\\n        prev = nodeToGet;\\n        nodeToGet = tree.higher(nodeToGet);\\n        return retVal;\\n    }\\n}\\n\\nclass TreeNode implements Comparable<TreeNode>{\\n    String name;\\n    int score;\\n    public TreeNode(int score, String name) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n    @Override\\n    public int compareTo(TreeNode other) {\\n        return this.score != other.score ? -(this.score - other.score) : this.name.compareTo(other.name);\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nimport java.util.TreeSet;\\n\\npublic class SORTracker {\\n\\n    TreeNode nodeToGet = null;\\n    TreeSet<TreeNode> tree;\\n    TreeNode prev = null;\\n    \\n    public SORTracker() {\\n        tree = new TreeSet<>();\\n    }\\n\\n   public void add(String name, int score) {\\n        TreeNode node = new TreeNode(score, name);\\n        tree.add(node);\\n        if (nodeToGet == null) {\\n            nodeToGet = tree.last();\\n        } else {\\n            if (node.compareTo(nodeToGet) < 0) {\\n                nodeToGet = tree.lower(nodeToGet);\\n            }\\n        }\\n    }\\n\\n    public String get() {\\n        String retVal = nodeToGet.name;\\n        prev = nodeToGet;\\n        nodeToGet = tree.higher(nodeToGet);\\n        return retVal;\\n    }\\n}\\n\\nclass TreeNode implements Comparable<TreeNode>{\\n    String name;\\n    int score;\\n    public TreeNode(int score, String name) {\\n        this.name = name;\\n        this.score = score;\\n    }\\n    @Override\\n    public int compareTo(TreeNode other) {\\n        return this.score != other.score ? -(this.score - other.score) : this.name.compareTo(other.name);\\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666222,
                "title": "simple-2-heap-solution",
                "content": "```\\nclass SORTracker {\\n    //making a class to store location and name\\n    class location{\\n        String name;    \\n        int score;\\n        location(String name,int score){\\n            this.name=name;\\n            this.score=score;\\n        }\\n    } \\n    \\n    PriorityQueue<location> pqMax=new PriorityQueue<>((a,b)->{\\n        if(a.score==b.score){\\n        return  a.name.compareTo(b.name);  //if the score is same sort on the basis of name (**lexicographically smaller**)\\n        }\\n        return b.score-a.score; \\n    });\\n    \\n    PriorityQueue<location> pqMin=new PriorityQueue<>((a,b)->{\\n         if(a.score==b.score){\\n        return  b.name.compareTo(a.name);\\n        }\\n        return a.score-b.score;\\n    });\\n    \\n   \\n    public SORTracker() {\\n    \\n    }\\n    /*idea\\n\\t1.In the maxHeap keep top i locations\\n\\t2.After each get function call move the  best location in maxHeap to minHeap\\n\\t*/\\n\\t\\n    public void add(String name, int score) {\\n        pqMin.add(new location(name,score));  \\n        pqMax.add(pqMin.poll());\\n    }\\n    \\n    public String get() {\\n        \\n        String ans=pqMax.peek().name; \\n        pqMin.add(pqMax.poll());\\n        return ans;\\n        \\n        \\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SORTracker {\\n    //making a class to store location and name\\n    class location{\\n        String name;    \\n        int score;\\n        location(String name,int score){\\n            this.name=name;\\n            this.score=score;\\n        }\\n    } \\n    \\n    PriorityQueue<location> pqMax=new PriorityQueue<>((a,b)->{\\n        if(a.score==b.score){\\n        return  a.name.compareTo(b.name);  //if the score is same sort on the basis of name (**lexicographically smaller**)\\n        }\\n        return b.score-a.score; \\n    });\\n    \\n    PriorityQueue<location> pqMin=new PriorityQueue<>((a,b)->{\\n         if(a.score==b.score){\\n        return  b.name.compareTo(a.name);\\n        }\\n        return a.score-b.score;\\n    });\\n    \\n   \\n    public SORTracker() {\\n    \\n    }\\n    /*idea\\n\\t1.In the maxHeap keep top i locations\\n\\t2.After each get function call move the  best location in maxHeap to minHeap\\n\\t*/\\n\\t\\n    public void add(String name, int score) {\\n        pqMin.add(new location(name,score));  \\n        pqMax.add(pqMin.poll());\\n    }\\n    \\n    public String get() {\\n        \\n        String ans=pqMax.peek().name; \\n        pqMin.add(pqMax.poll());\\n        return ans;\\n        \\n        \\n    }\\n}\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker obj = new SORTracker();\\n * obj.add(name,score);\\n * String param_2 = obj.get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666147,
                "title": "c-set-solution",
                "content": "A tree structure is a great solution to this problem and with it we can answer any queries like answering to the given `i`-th item.\\nThis problem is easier than such a general problem because `i`  denotes the number of calls of the `get` method.\\nThis quary can be solved with a set in C++.\\n\\nMy main idea is to hold the `i`-th item and the get method means returning it. The held item is clearly changed via get method because the number of calls is incresed. Then, the item should be updated. In the `add` method, the item may be changed and such a change occurs if and only if the added item is \"smaller\" than the held item. Otherwise, the held item stays.\\n\\nThe code is shown below. The complexity is O(NlogM) where N denotes the number of calls of the `get` method and M denotes the number of items in the set.\\n\\n```c++\\nstruct Scene {\\n    string name;\\n    int score;\\n    Scene() : name(\"\"), score(0) {};\\n    Scene(string name, int score) : name(name) , score(score) {};\\n    bool operator>(const Scene& comp) const {\\n        if(score != comp.score)\\n            return score < comp.score;\\n        return name > comp.name;\\n    };\\n    bool operator<(const Scene& comp) const {\\n        if(score != comp.score)\\n            return score > comp.score;\\n        return name < comp.name;\\n    };\\n};\\n\\nclass SORTracker {\\npublic:\\n    set<Scene> s;\\n    Scene curr;\\n    SORTracker() {\\n        s.emplace(\"\", 0);\\n    }\\n    \\n    void add(string name, int score) {\\n        Scene item(name, score);\\n        s.insert(item);\\n        if(item < curr){\\n            auto iter = s.find(curr);\\n            iter--;\\n            curr = *(iter);\\n        }\\n    }\\n    \\n    string get() {\\n        auto iter = s.find(curr);\\n        iter++;\\n        string ans = move(curr.name);\\n        curr = *(iter);\\n        return move(ans);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```c++\\nstruct Scene {\\n    string name;\\n    int score;\\n    Scene() : name(\"\"), score(0) {};\\n    Scene(string name, int score) : name(name) , score(score) {};\\n    bool operator>(const Scene& comp) const {\\n        if(score != comp.score)\\n            return score < comp.score;\\n        return name > comp.name;\\n    };\\n    bool operator<(const Scene& comp) const {\\n        if(score != comp.score)\\n            return score > comp.score;\\n        return name < comp.name;\\n    };\\n};\\n\\nclass SORTracker {\\npublic:\\n    set<Scene> s;\\n    Scene curr;\\n    SORTracker() {\\n        s.emplace(\"\", 0);\\n    }\\n    \\n    void add(string name, int score) {\\n        Scene item(name, score);\\n        s.insert(item);\\n        if(item < curr){\\n            auto iter = s.find(curr);\\n            iter--;\\n            curr = *(iter);\\n        }\\n    }\\n    \\n    string get() {\\n        auto iter = s.find(curr);\\n        iter++;\\n        string ans = move(curr.name);\\n        curr = *(iter);\\n        return move(ans);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663968,
                "title": "c-336ms-91-treap-not-simple-not-easy-not-small",
                "content": "Runtime: 336 ms, faster than 90.66% of C++ online submissions for Sequentially Ordinal Rank Tracker.\\nMemory Usage: 145.9 MB, less than 98.74% of C++ online submissions for Sequentially Ordinal Rank Tracker.\\n**I have my old realisation of Descartes Tree and I use it**\\n```\\nclass Treap{\\n  private:\\n    int y, sz, val;\\n    string s; \\n    Treap *l, *r;\\n  \\n  public:\\n  Treap(string &s, int &val){\\n    y = rand();                                //prior\\n    sz = 1;    \\n    this->val = val;\\n    this->s = s;\\n    l = r = NULL;\\n  }\\n  \\n  static int get_size(Treap *t){\\n    return t == NULL ? 0 : t->sz;\\n  }\\n  \\n  static void upd_size(Treap *t){\\n    if(t) t->sz = 1 + get_size(t->l) + get_size(t->r);\\n  }\\n  \\n  static Treap* merge(Treap *t1, Treap *t2){\\n    if(!t1) return t2; \\n    if(!t2) return t1; \\n  \\n    if (t1->y > t2->y){\\n      t1->r = merge(t1->r, t2);\\n      upd_size(t1);\\n      return t1;\\n    }else{\\n      t2->l = merge(t1, t2->l);\\n      upd_size(t2);\\n      return t2;\\n    }\\n  }\\n  \\n  static void split(Treap *t, int x, Treap *&t1, Treap *&t2){\\n    if (!t){\\n      t1 = t2 = NULL;\\n      return;\\n    }\\n    \\n    if(get_size(t->l) < x){\\n      split(t->r, x - get_size(t->l) - 1, t->r, t2);\\n      t1 = t;\\n    }\\n    else{\\n      split(t->l, x, t1, t->l);\\n      t2 = t;\\n    }\\n    \\n    upd_size(t);\\n  }\\n  \\n  static Treap* add(Treap *t, int pos, string &s, int val){\\n    Treap *t1, *t2;\\n    split(t, pos, t1, t2);\\n    Treap *new_tree = new Treap(s, val);\\n    return merge(merge(t1, new_tree), t2);\\n  }\\n  \\n  static string get_value(Treap *t, int pos){\\n    int my_idx = get_size(t->l);\\n    if      (pos <  my_idx) return get_value(t->l, pos);\\n    else if (pos == my_idx) return t->s;\\n    else                    return get_value(t->r, pos - my_idx - 1);\\n  }\\n  \\n  static int find_pos(Treap *t, string &s, int val){\\n    int x = 0;                 // x = 0 for position\\n    if(!t) return 0;\\n  \\n    while(true){\\n      if     (val == t->val){\\n        if(s < t->s){\\n          if(t->l) t = t->l;\\n          else return x + (t->l ? t->l->sz : 0);  \\n        }\\n        else{\\n          if(t->r) x += 1 + (t->l ? t->l->sz : 0);\\n          else return x + (t->l ? t->l->sz : 0) + 1;\\n      \\n          t = t->r;  \\n        }\\n      }\\n    \\n      else if(val >  t->val){\\n        if(t->l) t = t->l;\\n        else return x + (t->l ? t->l->sz : 0);\\n      }\\n    \\n      else{\\n        if(t->r) x += (t->l ? t->l->sz : 0) + 1;\\n        else return x + (t->l ? t->l->sz : 0) + 1;\\n      \\n        t = t->r;\\n      }\\n    }\\n\\n    return x;\\n  }\\n};\\n\\nclass SORTracker {\\npublic:  \\n  int id;\\n  Treap *tree;\\n  \\n  SORTracker(){\\n    id = -1;\\n    tree = NULL;\\n  }\\n    \\n  void add(string name, int score){\\n    tree = tree->add(tree, tree->find_pos(tree, name, score), name, score);\\n  }\\n    \\n  string get() {\\n    return tree->get_value(tree, ++id);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Treap{\\n  private:\\n    int y, sz, val;\\n    string s; \\n    Treap *l, *r;\\n  \\n  public:\\n  Treap(string &s, int &val){\\n    y = rand();                                //prior\\n    sz = 1;    \\n    this->val = val;\\n    this->s = s;\\n    l = r = NULL;\\n  }\\n  \\n  static int get_size(Treap *t){\\n    return t == NULL ? 0 : t->sz;\\n  }\\n  \\n  static void upd_size(Treap *t){\\n    if(t) t->sz = 1 + get_size(t->l) + get_size(t->r);\\n  }\\n  \\n  static Treap* merge(Treap *t1, Treap *t2){\\n    if(!t1) return t2; \\n    if(!t2) return t1; \\n  \\n    if (t1->y > t2->y){\\n      t1->r = merge(t1->r, t2);\\n      upd_size(t1);\\n      return t1;\\n    }else{\\n      t2->l = merge(t1, t2->l);\\n      upd_size(t2);\\n      return t2;\\n    }\\n  }\\n  \\n  static void split(Treap *t, int x, Treap *&t1, Treap *&t2){\\n    if (!t){\\n      t1 = t2 = NULL;\\n      return;\\n    }\\n    \\n    if(get_size(t->l) < x){\\n      split(t->r, x - get_size(t->l) - 1, t->r, t2);\\n      t1 = t;\\n    }\\n    else{\\n      split(t->l, x, t1, t->l);\\n      t2 = t;\\n    }\\n    \\n    upd_size(t);\\n  }\\n  \\n  static Treap* add(Treap *t, int pos, string &s, int val){\\n    Treap *t1, *t2;\\n    split(t, pos, t1, t2);\\n    Treap *new_tree = new Treap(s, val);\\n    return merge(merge(t1, new_tree), t2);\\n  }\\n  \\n  static string get_value(Treap *t, int pos){\\n    int my_idx = get_size(t->l);\\n    if      (pos <  my_idx) return get_value(t->l, pos);\\n    else if (pos == my_idx) return t->s;\\n    else                    return get_value(t->r, pos - my_idx - 1);\\n  }\\n  \\n  static int find_pos(Treap *t, string &s, int val){\\n    int x = 0;                 // x = 0 for position\\n    if(!t) return 0;\\n  \\n    while(true){\\n      if     (val == t->val){\\n        if(s < t->s){\\n          if(t->l) t = t->l;\\n          else return x + (t->l ? t->l->sz : 0);  \\n        }\\n        else{\\n          if(t->r) x += 1 + (t->l ? t->l->sz : 0);\\n          else return x + (t->l ? t->l->sz : 0) + 1;\\n      \\n          t = t->r;  \\n        }\\n      }\\n    \\n      else if(val >  t->val){\\n        if(t->l) t = t->l;\\n        else return x + (t->l ? t->l->sz : 0);\\n      }\\n    \\n      else{\\n        if(t->r) x += (t->l ? t->l->sz : 0) + 1;\\n        else return x + (t->l ? t->l->sz : 0) + 1;\\n      \\n        t = t->r;\\n      }\\n    }\\n\\n    return x;\\n  }\\n};\\n\\nclass SORTracker {\\npublic:  \\n  int id;\\n  Treap *tree;\\n  \\n  SORTracker(){\\n    id = -1;\\n    tree = NULL;\\n  }\\n    \\n  void add(string name, int score){\\n    tree = tree->add(tree, tree->find_pos(tree, name, score), name, score);\\n  }\\n    \\n  string get() {\\n    return tree->get_value(tree, ++id);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658310,
                "title": "clean-solution",
                "content": "Explanation: https://bit.ly/leetcode2102\\n\\nCode\\n```\\nclass SORTracker {\\n\\n    class Location implements Comparable<Location> {\\n        private final String name;\\n        private final int score;\\n        \\n        Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        @Override\\n        public int compareTo(Location other) {\\n            return (score != other.score) ?\\n                other.score - score : name.compareTo(other.name);\\n        }\\n    }\\n    \\n    private final TreeSet<Location> locations = new TreeSet<>();\\n    private Location nextBest;\\n    \\n    public SORTracker() {\\n    }\\n    \\n    public void add(String name, int score) {\\n        Location newLocation = new Location(name, score);\\n        locations.add(newLocation);\\n        \\n        if (nextBest != null) {\\n            if (nextBest.compareTo(newLocation) > 0) {\\n                Location oneAbove = locations.lower(nextBest);\\n                if (oneAbove != null) {\\n                    nextBest = oneAbove;\\n                }\\n            }\\n        } else {\\n            nextBest = locations.last();\\n        }\\n    }\\n    \\n    public String get() {\\n        String nextBestName = nextBest.name;\\n        \\n        nextBest = locations.higher(nextBest);\\n        return nextBestName;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SORTracker {\\n\\n    class Location implements Comparable<Location> {\\n        private final String name;\\n        private final int score;\\n        \\n        Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n        \\n        @Override\\n        public int compareTo(Location other) {\\n            return (score != other.score) ?\\n                other.score - score : name.compareTo(other.name);\\n        }\\n    }\\n    \\n    private final TreeSet<Location> locations = new TreeSet<>();\\n    private Location nextBest;\\n    \\n    public SORTracker() {\\n    }\\n    \\n    public void add(String name, int score) {\\n        Location newLocation = new Location(name, score);\\n        locations.add(newLocation);\\n        \\n        if (nextBest != null) {\\n            if (nextBest.compareTo(newLocation) > 0) {\\n                Location oneAbove = locations.lower(nextBest);\\n                if (oneAbove != null) {\\n                    nextBest = oneAbove;\\n                }\\n            }\\n        } else {\\n            nextBest = locations.last();\\n        }\\n    }\\n    \\n    public String get() {\\n        String nextBestName = nextBest.name;\\n        \\n        nextBest = locations.higher(nextBest);\\n        return nextBestName;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645463,
                "title": "complexity-doubt-tle",
                "content": "I have written the following code- \\n```\\nclass SORTracker {\\n    vector<pair<string,int>> v;\\n    int c=0;\\n    int util(string name, int score){\\n        int l=0,h=v.size();\\n        while(l<h){\\n            int m=l+(h-l)/2;\\n            if(v[m].second>score) l=m+1;\\n            else if(v[m].second<score) h=m;\\n            else{\\n                if(v[m].first>name) h=m;\\n                else l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\npublic:\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        if(v.size()==0) v.push_back({name,score});\\n        else{\\n            int idx=util(name,score);\\n            v.insert(v.begin()+idx,{name,score});\\n        }\\n    }\\n    \\n    string get() {\\n        return v[c++].first;\\n    }\\n};\\n```\\ntime complexity is O(nlogn) which should pass (given n) but I get TLE and passes only 78/81 test cases.\\n\\nCan someone pls explain?\\n\\nThanks",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\n    vector<pair<string,int>> v;\\n    int c=0;\\n    int util(string name, int score){\\n        int l=0,h=v.size();\\n        while(l<h){\\n            int m=l+(h-l)/2;\\n            if(v[m].second>score) l=m+1;\\n            else if(v[m].second<score) h=m;\\n            else{\\n                if(v[m].first>name) h=m;\\n                else l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\npublic:\\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        if(v.size()==0) v.push_back({name,score});\\n        else{\\n            int idx=util(name,score);\\n            v.insert(v.begin()+idx,{name,score});\\n        }\\n    }\\n    \\n    string get() {\\n        return v[c++].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640934,
                "title": "2102-sequentially-ordinal-rank-tracker-c-set-iterator-custom-comparator",
                "content": "```\\nclass SORTracker {\\npublic:\\n    struct cmp{\\n        bool operator() (pair<string, int> a, pair<string, int> b) const{\\n            if(a.second == b.second) return a.first < b.first;\\n            else return a.second > b.second;\\n        }\\n    };\\n    \\n    set<pair<string, int>, cmp> s;\\n    set<pair<string, int>>::iterator it;\\n    \\n    SORTracker() {\\n        s.insert({\"\", INT_MIN});\\n        it = s.begin();\\n    }\\n\\n    void add(string name, int score) {\\n        auto [_name, _score] = *it;\\n        if((_score < score) || (score == _score && _name > name)){\\n            s.insert({name, score});\\n            --it;\\n        } \\n        else s.insert({name, score});\\n    }\\n    \\n    string get() {\\n        string ans = it++->first;\\n        return ans;\\n    }\\n};;\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass SORTracker {\\npublic:\\n    struct cmp{\\n        bool operator() (pair<string, int> a, pair<string, int> b) const{\\n            if(a.second == b.second) return a.first < b.first;\\n            else return a.second > b.second;\\n        }\\n    };\\n    \\n    set<pair<string, int>, cmp> s;\\n    set<pair<string, int>>::iterator it;\\n    \\n    SORTracker() {\\n        s.insert({\"\", INT_MIN});\\n        it = s.begin();\\n    }\\n\\n    void add(string name, int score) {\\n        auto [_name, _score] = *it;\\n        if((_score < score) || (score == _score && _name > name)){\\n            s.insert({name, score});\\n            --it;\\n        } \\n        else s.insert({name, score});\\n    }\\n    \\n    string get() {\\n        string ans = it++->first;\\n        return ans;\\n    }\\n};;\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640851,
                "title": "c-classic-2-heaps-min-heap-max-heap",
                "content": "```\\n/*\\nhttps://leetcode.com/problems/sequentially-ordinal-rank-tracker/discuss/1623309/Python-Explanation-with-Pictures-min-heap\\n\\n-Top N will be the: min heap\\n-Bottom will be the: max heap\\n*/\\n\\nstruct cmp{\\n   \\n    bool operator() (const pair<int,string>& a, const pair<int,string>& b) const{\\n        if(a.first < b.first) \\n            return true;\\n        else if(a.first == b.first)\\n            return a.second > b.second;\\n        else \\n            return false;\\n        \\n    };\\n    \\n};\\nclass SORTracker {\\npublic:\\n \\n    set<pair<int, string>,cmp> topN; // top N: min heap\\n    \\n    set<pair<int, string>> bottom; // bottom: max heap\\n    \\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        topN.insert({score, name});\\n        \\n        auto [s,n] = *topN.begin();\\n        topN.erase(topN.begin());\\n        \\n        bottom.insert({-s, n});\\n        \\n    }\\n    \\n    string get() {\\n        \\n        auto [score, name] = *bottom.begin();\\n        bottom.erase(bottom.begin());\\n        \\n        topN.insert({-score, name});\\n        \\n        return name; \\n        \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nhttps://leetcode.com/problems/sequentially-ordinal-rank-tracker/discuss/1623309/Python-Explanation-with-Pictures-min-heap\\n\\n-Top N will be the: min heap\\n-Bottom will be the: max heap\\n*/\\n\\nstruct cmp{\\n   \\n    bool operator() (const pair<int,string>& a, const pair<int,string>& b) const{\\n        if(a.first < b.first) \\n            return true;\\n        else if(a.first == b.first)\\n            return a.second > b.second;\\n        else \\n            return false;\\n        \\n    };\\n    \\n};\\nclass SORTracker {\\npublic:\\n \\n    set<pair<int, string>,cmp> topN; // top N: min heap\\n    \\n    set<pair<int, string>> bottom; // bottom: max heap\\n    \\n    SORTracker() {\\n        \\n    }\\n    \\n    void add(string name, int score) {\\n        topN.insert({score, name});\\n        \\n        auto [s,n] = *topN.begin();\\n        topN.erase(topN.begin());\\n        \\n        bottom.insert({-s, n});\\n        \\n    }\\n    \\n    string get() {\\n        \\n        auto [score, name] = *bottom.begin();\\n        bottom.erase(bottom.begin());\\n        \\n        topN.insert({-score, name});\\n        \\n        return name; \\n        \\n    }\\n};\\n\\n/**\\n * Your SORTracker object will be instantiated and called as such:\\n * SORTracker* obj = new SORTracker();\\n * obj->add(name,score);\\n * string param_2 = obj->get();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640496,
                "title": "c-add-dummy-element-in-set-10-lines",
                "content": "Basically we add a dummy point which is for sure the smallest element in the set. And we maintain a iterator that always points to the element that should be returned by next get().\\n```\\nclass SORTracker {\\npublic:\\n    struct Location{\\n        string name;\\n        int score;\\n        bool operator<(const Location& l) const {\\n            if(score != l.score) return score > l.score;\\n            return name < l.name;\\n        }\\n    };\\n    set<Location> s;\\n    set<Location>::iterator it;\\n    SORTracker() {\\n        s.insert({\"\",0});\\n        it = s.begin();\\n    }\\n    \\n    void add(string name, int score) {\\n        auto l = Location{name,score};\\n        if(*it<l) s.insert(l);\\n        else{\\n            s.insert(l);\\n            --it;\\n        }\\n    }\\n    \\n    string get() {\\n        string ans = it->name;\\n        it++;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SORTracker {\\npublic:\\n    struct Location{\\n        string name;\\n        int score;\\n        bool operator<(const Location& l) const {\\n            if(score != l.score) return score > l.score;\\n            return name < l.name;\\n        }\\n    };\\n    set<Location> s;\\n    set<Location>::iterator it;\\n    SORTracker() {\\n        s.insert({\"\",0});\\n        it = s.begin();\\n    }\\n    \\n    void add(string name, int score) {\\n        auto l = Location{name,score};\\n        if(*it<l) s.insert(l);\\n        else{\\n            s.insert(l);\\n            --it;\\n        }\\n    }\\n    \\n    string get() {\\n        string ans = it->name;\\n        it++;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638460,
                "title": "python3-1-line-each",
                "content": "This problem basically asks you to implement the ```SortedList```.\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.cnt, self.sorted_list = 0, SortedList()\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.sorted_list.add([-score, name])\\n\\n    def get(self) -> str:\\n        return self.sorted_list[self.cnt - 1][1] if setattr(self, \"cnt\", self.cnt + 1) is None else \"haha\"\\n```",
                "solutionTags": [],
                "code": "```SortedList```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass SORTracker:\\n\\n    def __init__(self):\\n        self.cnt, self.sorted_list = 0, SortedList()\\n\\n    def add(self, name: str, score: int) -> None:\\n        self.sorted_list.add([-score, name])\\n\\n    def get(self) -> str:\\n        return self.sorted_list[self.cnt - 1][1] if setattr(self, \"cnt\", self.cnt + 1) is None else \"haha\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636304,
                "title": "java-treeset-5-lines-logic-init-ds",
                "content": "Basically, you should keep track of the sorted locations (ascending score, descending name if equal score). You also need a pointer to the (i-1)th location. In this case, whenever you want to return, you can return higher of (i-1)th, which is ith location. The only place that you need to update (i-1)th is that a new location comes becore (i-1)th (new location<(i-1)th location). In this case, you just update the pointer and say the new (i-1)th is lower(old (i-1)th location).\\n```\\n    TreeSet<Location> locations; // Keep track of sorted locations ascending score, descending name\\n    Location lastReturned; // Always keep it at (i-1)th. So, the ith will be higher in the tree set\\n    Comparator<Location> locationComparator;\\n\\n    public SORTracker() {\\n        locationComparator = (a, b) -> a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); // Ascending score, descending name\\n        locations = new TreeSet<>(locationComparator);\\n        lastReturned = new Location(\"\", Integer.MAX_VALUE); // Something that bubbled up to the top- 0th location\\n    }\\n\\n    public void add(String name, int score) { // If adding a new location lower than last returned, update the last returned\\n        Location location = new Location(name, score);\\n        locations.add(location); // If location<lastReturned, lastReturned becomes ith instead of being (i-1)th\\n        if (locationComparator.compare(location, lastReturned) < 0) lastReturned = locations.lower(lastReturned);\\n    }\\n\\n    public String get() { // Get the ith location\\n        lastReturned = locations.higher(lastReturned); // lastReturned is pointing to (i-1)th. So, ith will be higher of it.\\n        return lastReturned.name;\\n    }\\n\\n    public class Location { // DS\\n        String name;\\n        int score;\\n        public Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    TreeSet<Location> locations; // Keep track of sorted locations ascending score, descending name\\n    Location lastReturned; // Always keep it at (i-1)th. So, the ith will be higher in the tree set\\n    Comparator<Location> locationComparator;\\n\\n    public SORTracker() {\\n        locationComparator = (a, b) -> a.score != b.score ? b.score - a.score : a.name.compareTo(b.name); // Ascending score, descending name\\n        locations = new TreeSet<>(locationComparator);\\n        lastReturned = new Location(\"\", Integer.MAX_VALUE); // Something that bubbled up to the top- 0th location\\n    }\\n\\n    public void add(String name, int score) { // If adding a new location lower than last returned, update the last returned\\n        Location location = new Location(name, score);\\n        locations.add(location); // If location<lastReturned, lastReturned becomes ith instead of being (i-1)th\\n        if (locationComparator.compare(location, lastReturned) < 0) lastReturned = locations.lower(lastReturned);\\n    }\\n\\n    public String get() { // Get the ith location\\n        lastReturned = locations.higher(lastReturned); // lastReturned is pointing to (i-1)th. So, ith will be higher of it.\\n        return lastReturned.name;\\n    }\\n\\n    public class Location { // DS\\n        String name;\\n        int score;\\n        public Location(String name, int score) {\\n            this.name = name;\\n            this.score = score;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1736637,
                "content": [
                    {
                        "username": "Mostafa_Zahran",
                        "content": "For anyone using python who is trying to solve it using 2 heaps/(Priority Queue), try using SortedList from sortedcontainers ( from sortedcontainers import SortedList )\\nWhy SortedList?...cuz simply its indexed "
                    }
                ]
            }
        ]
    }
]