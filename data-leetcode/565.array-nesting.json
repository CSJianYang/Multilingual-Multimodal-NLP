[
    {
        "title": "Array Nesting",
        "question_content": "You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].\nYou should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:\n\n\tThe first element in s[k] starts with the selection of the element nums[k] of index = k.\n\tThe next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.\n\tWe stop adding right before a duplicate element occurs in s[k].\n\nReturn the longest length of a set s[k].\n&nbsp;\nExample 1:\n\nInput: nums = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne of the longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\n\nExample 2:\n\nInput: nums = [0,1,2]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] < nums.length\n\tAll the values of nums are unique.",
        "solutions": [
            {
                "id": 102432,
                "title": "c-java-clean-code-o-n",
                "content": "The idea is to, start from every number, find ``circle``s in those ``index-pointer-chains``, every time you find a set (a circle) ``mark every number as visited (-1)`` so that next time you won't step on it again.\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& a) {\\n        size_t maxsize = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            size_t size = 0;\\n            for (int k = i; a[k] >= 0; size++) {\\n                int ak = a[k];\\n                a[k] = -1; // mark a[k] as visited;\\n                k = ak;\\n            }\\n            maxsize = max(maxsize, size);\\n        }\\n\\n        return maxsize;\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public int arrayNesting(int[] a) {\\n        int maxsize = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            int size = 0;\\n            for (int k = i; a[k] >= 0; size++) {\\n                int ak = a[k];\\n                a[k] = -1; // mark a[k] as visited;\\n                k = ak;\\n            }\\n            maxsize = Integer.max(maxsize, size);\\n        }\\n\\n        return maxsize;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& a) {\\n        size_t maxsize = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            size_t size = 0;\\n            for (int k = i; a[k] >= 0; size++) {\\n                int ak = a[k];\\n                a[k] = -1; // mark a[k] as visited;\\n                k = ak;\\n            }\\n            maxsize = max(maxsize, size);\\n        }\\n\\n        return maxsize;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int arrayNesting(int[] a) {\\n        int maxsize = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            int size = 0;\\n            for (int k = i; a[k] >= 0; size++) {\\n                int ak = a[k];\\n                a[k] = -1; // mark a[k] as visited;\\n                k = ak;\\n            }\\n            maxsize = Integer.max(maxsize, size);\\n        }\\n\\n        return maxsize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438313,
                "title": "c-python-find-the-longest-length-between-cycles-with-picture-clean-concise",
                "content": "**Version 1: Straightforward - O(N) Space**\\n- Elements in the same set will form a cycle.\\n- We just traverse elements `x` in `nums`:\\n\\t- If `x` is not visited then we `dfs(x)` to find elements in the same cycle with node `x`.\\n\\t- Update the `ans` if the current cycle has length greater than `ans`.\\n- Check the following picture for more clearly.\\n\\n![image](https://assets.leetcode.com/users/images/07a4b748-a8de-4a95-abe0-165255bccee1_1630563859.4152162.png)\\n\\n<iframe src=\"https://leetcode.com/playground/2ivJo73V/shared\" frameBorder=\"0\" width=\"100%\" height=\"360\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is number of elements in `nums` array.\\n- Space: `O(N)`\\n\\n---\\n\\n**Version 2: In space modification - O(1) Space**\\n- We can achieve O(1) in space by modify `nums` array directly, mark `nums[i] = -1` with the meaning `visited[i] = True`.\\n\\n<iframe src=\"https://leetcode.com/playground/BKa3zB4D/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is number of elements in `nums` array.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Version 1: Straightforward - O(N) Space**\\n- Elements in the same set will form a cycle.\\n- We just traverse elements `x` in `nums`:\\n\\t- If `x` is not visited then we `dfs(x)` to find elements in the same cycle with node `x`.\\n\\t- Update the `ans` if the current cycle has length greater than `ans`.\\n- Check the following picture for more clearly.\\n\\n![image](https://assets.leetcode.com/users/images/07a4b748-a8de-4a95-abe0-165255bccee1_1630563859.4152162.png)\\n\\n<iframe src=\"https://leetcode.com/playground/2ivJo73V/shared\" frameBorder=\"0\" width=\"100%\" height=\"360\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is number of elements in `nums` array.\\n- Space: `O(N)`\\n\\n---\\n\\n**Version 2: In space modification - O(1) Space**\\n- We can achieve O(1) in space by modify `nums` array directly, mark `nums[i] = -1` with the meaning `visited[i] = True`.\\n\\n<iframe src=\"https://leetcode.com/playground/BKa3zB4D/shared\" frameBorder=\"0\" width=\"100%\" height=\"380\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N)`, where `N <= 10^5` is number of elements in `nums` array.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 102473,
                "title": "java-c-python-straight-forward",
                "content": "# **Explanation**:\\nFor each element `i` in A,\\nrepetly find `A[i]` until a visited element.\\nUpdate res to the length of the path.\\n<br>\\n\\n# **Complexity**:\\nEach element will be visited once,\\nTime `O(N)`\\nSpace `O(N)` (space can be `O(1)`)\\n<br>\\n\\n**Java:**\\n```java\\n    public int arrayNesting(int[] A) {\\n        int res = 0, n = A.length;\\n        boolean[] seen = new boolean[n];\\n        for (int i : A) {\\n            int cnt = 0;\\n            while (!seen[i]) {\\n                seen[i] = true;\\n                cnt++;\\n                i = A[i];\\n            }\\n            res = Math.max(res, cnt);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int arrayNesting(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        vector<bool> seen(n);\\n        for (int i: A) {\\n            int cnt = 0;\\n            while (!seen[i]) {\\n                seen[i] = true;\\n                cnt++;\\n                i = A[i];\\n            }\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def arrayNesting(self, A):\\n        seen, res = [0] * len(A), 0\\n        for i in A:\\n            cnt = 0\\n            while not seen[i]:\\n                seen[i], cnt, i = 1, cnt + 1, A[i]\\n            res = max(res, cnt)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int arrayNesting(int[] A) {\\n        int res = 0, n = A.length;\\n        boolean[] seen = new boolean[n];\\n        for (int i : A) {\\n            int cnt = 0;\\n            while (!seen[i]) {\\n                seen[i] = true;\\n                cnt++;\\n                i = A[i];\\n            }\\n            res = Math.max(res, cnt);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int arrayNesting(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        vector<bool> seen(n);\\n        for (int i: A) {\\n            int cnt = 0;\\n            while (!seen[i]) {\\n                seen[i] = true;\\n                cnt++;\\n                i = A[i];\\n            }\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def arrayNesting(self, A):\\n        seen, res = [0] * len(A), 0\\n        for i in A:\\n            cnt = 0\\n            while not seen[i]:\\n                seen[i], cnt, i = 1, cnt + 1, A[i]\\n            res = max(res, cnt)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 102472,
                "title": "this-is-actually-dfs",
                "content": "```\\n\\t/ ** \\n\\t * This is actually a DFS.  Use a visited map to keep track of visited node. If a \\nnumber is visited before, then the set that starts at this number must be smaller then\\n previous max. So we can safely skip this number. In total it's O(n) complexity.\\n\\t */\\n\\n\\n\\npublic int arrayNesting(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        boolean[] visited = new boolean[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n        \\tif (visited[i]) \\n        \\t\\tcontinue;\\n        \\tmax = Math.max(max, calcLength(nums, i, visited));\\n        }\\n        return max;\\n    }\\n\\t\\n\\tprivate int calcLength(int[] nums, int start, boolean[] visited) {\\n\\t\\tint i = start, count = 0;\\n\\t\\twhile (count == 0 || i != start) {\\n\\t\\t\\tvisited[i] = true;\\n\\t\\t\\ti = nums[i];\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t/ ** \\n\\t * This is actually a DFS.  Use a visited map to keep track of visited node. If a \\nnumber is visited before, then the set that starts at this number must be smaller then\\n previous max. So we can safely skip this number. In total it's O(n) complexity.\\n\\t */\\n\\n\\n\\npublic int arrayNesting(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        boolean[] visited = new boolean[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n        \\tif (visited[i]) \\n        \\t\\tcontinue;\\n        \\tmax = Math.max(max, calcLength(nums, i, visited));\\n        }\\n        return max;\\n    }\\n\\t\\n\\tprivate int calcLength(int[] nums, int start, boolean[] visited) {\\n\\t\\tint i = start, count = 0;\\n\\t\\twhile (count == 0 || i != start) {\\n\\t\\t\\tvisited[i] = true;\\n\\t\\t\\ti = nums[i];\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438244,
                "title": "c-simple-and-easy-explained-solution-o-n-tc-o-1-sc",
                "content": "**Idea:**\\nWe try to start from each index and build the set as in the problem statement.\\nTo check for duplicates, we will change each visited number to -1.\\n**Time Complexity:** O(n) - we visit each element once.\\n**Space Complexity:** O(1) - we use only constant extra space.\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int res = 0, curr, count, prev;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == -1) continue;\\n            \\n            curr = nums[i], count = 1, nums[i] = -1;\\n            \\n            while (nums[curr] != -1) {\\n                prev = curr;\\n                curr = nums[curr];\\n                nums[prev] = -1;\\n                count++;\\n            }\\n            \\n            res = max(res, count);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int res = 0, curr, count, prev;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == -1) continue;\\n            \\n            curr = nums[i], count = 1, nums[i] = -1;\\n            \\n            while (nums[curr] != -1) {\\n                prev = curr;\\n                curr = nums[curr];\\n                nums[prev] = -1;\\n                count++;\\n            }\\n            \\n            res = max(res, count);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438159,
                "title": "python-loop-detection-explained",
                "content": "Actually, what we have is permutation of numbers, where we need to find the longest loop. What we need to do is to look at our `nums` as graph, imagine we have `nums = [5, 4, 0, 3, 1, 6, 2]`, then we have connections: `0 -> 5, 1 -> 4, 2 -> 0, 3 -> 3, 4 -> 1, 5 -> 6, 6 -> 2`, which in fact can be looked as several disjoint loops `0 -> 5 -> 6 -> 2 -> 0`, `1 -> 4 -> 1`, `3 -> 3`.\\n\\nSo, we start from value `0` and start to traverse our graph. We will keep already visited nodes in `visited` set, so if we already traversed some loop, we never do it again: it is very similar what we do in classical dfs algorithm when we want to find islands.\\n\\n#### Complexity\\nTime and space complexity is `O(n)`, because we never visit node twice.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def arrayNesting(self, nums):\\n        n = len(nums)\\n        visited = [0]*n\\n        for i in range(n):\\n            start, depth = i, 1\\n            while not visited[start]:\\n                visited[start] = depth\\n                start = nums[start]\\n                depth += 1\\n                \\n        return max(visited)    \\n```\\n\\n#### Remark\\nCan we do better? Not in time: we need to look at our data at least once, what about space? We can also rewrite original array with `-1` with `O(n)` time and `O(1)` space. Finally, if we are not allowed to modify data, we can use loop detection technique with slow and fast iterators with `O(n)` time and `O(1)` memory.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def arrayNesting(self, nums):\\n        n = len(nums)\\n        visited = [0]*n\\n        for i in range(n):\\n            start, depth = i, 1\\n            while not visited[start]:\\n                visited[start] = depth\\n                start = nums[start]\\n                depth += 1\\n                \\n        return max(visited)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 166994,
                "title": "what-a-poorly-worded-question",
                "content": "Let me rephrase it for anyone who feels painful to understand the question\\n```\\nLongest Loop in Array\\n\\nA zero-indexed array A of length N contains all integers from 0 to N-1. \\nFind and return the length of longest loop S, where A[Si] = S(i+1) and A[Sn] = S0, \\nwhere each Si is an element in the array and Sn is the last in the loop\\n```",
                "solutionTags": [],
                "code": "```\\nLongest Loop in Array\\n\\nA zero-indexed array A of length N contains all integers from 0 to N-1. \\nFind and return the length of longest loop S, where A[Si] = S(i+1) and A[Sn] = S0, \\nwhere each Si is an element in the array and Sn is the last in the loop\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102449,
                "title": "short-python",
                "content": "Basically this problem means find the biggest cycle. One thing we shall notice is once ```i``` has been visited in previous different cycle, it must **not** in current cycle and we can ignore it.\\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans, step, n = 0, 0, len(nums)\\n        seen = [False] * n\\n        for i in range(n):\\n            while not seen[i]:\\n                seen[i] = True\\n                i, step = nums[i], step + 1\\n            ans = max(ans, step)\\n            step = 0\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```i```\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans, step, n = 0, 0, len(nums)\\n        seen = [False] * n\\n        for i in range(n):\\n            while not seen[i]:\\n                seen[i] = True\\n                i, step = nums[i], step + 1\\n            ans = max(ans, step)\\n            step = 0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102442,
                "title": "java-o-n-time-o-1-space-with-explanation-and-proof",
                "content": "This the code I use:\\n```java\\npublic class Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length, max = 0;\\n        for (int i = 0; i < n; i++) {\\n            int index = i, count = 0;\\n            while (nums[index] < n && nums[index] != i) {\\n                count++;\\n                nums[index] += n;\\n                index = nums[index] - n;\\n            }\\n            if (++count > max)\\n                max = count;\\n            if (max >= (n + 1) / 2)\\n                return max;\\n        }\\n        return max;\\n    }\\n}\\n```\\nThe given condition that **the index domain is the same as the value domain** is frequently encountered in Leetcode problems. When we have this condition, I tend to think of using a technique I call **inplace flag**. Instead of using an extra `visited` array, we can just mutate the input array to reflect the flag information we want.\\n\\nThe usual inplace flagging techniques include:\\n* negating: negate to reflect one visit, use `abs` to get the original value. This only works to detect odd numbers of previous occurrence. It is not appropriate for this problem also because the value can actually be 0 in this problem, so negating 0 does not really flag anything.\\n* module (which I used here): add one `n` to reflect a visit. Mod `n` with the entry to get the original value.\\n* sorting: put each number into its corresponding index. This is not recoverable with O(1) space, so not considered here.\\n\\nRegarding the problem of **Input Pollution**, it is actually easily fixable when using **inplace flagging**, albeit in a way some may argue imperfect. We can just recover the original input array before returning at the end. For negating, just do `abs`; for module method, just mod `n` at the end. This method fixes the problem in some situation but may still cause problem in a multithreading context.\\n\\n## Proof of this method\\nFirst, I personally like this explanation:\\n\\n@szlghl1 said in [\\\\[C\\\\+\\\\+\\\\] \\\\[Java\\\\] Clean Code \\\\- O\\\\(N\\\\)](/post/201606):\\n> Just some supplement.\\n> \\n> From the statement \"The array of size N contains number [0, N-1]\", we can know that in-degree of all nodes are exactly one (n different edges for n nodes).\\n> \\n> Therefore the graph should consist of several cycles and the cycles have no \"tails\". That's why we can skip the visited nodes, where to begin in a visited cycle doesn't matter in this circumstance.\\n\\nIt's concise and good enough for this problem. Also, I have not taken any automata course or learned anything about FSM theory. I have a feeling there are some theorems there to make the proofs here trivially easy. But again, I don't know any.\\n\\nBut in case you are into a more verbose proof, here goes.\\n\\n## Lemma 1: when we start from any `k`, we will eventually go back to `k`.\\n**Proof**: \\nFirst, let's understand each entry of `A[i] = e` as a mapping `i -> e`. Let's simplify. Suppose that there is no `k -> k` mapping for any `k`. That is no `k` is its own value. Then we ca easily see that there will be a cycle and when we start from `k` we will get back: there are only `n` distinct numbers in total. We get a different number each iteration, and then we are guaranteed to have a cycle somewhere.\\nOne caveat: what if there was a cycle when we start from `k`, but the cycle does not actually contain `k` itself? like `k -> a -> b -> c -> a`? This is also impossible, because in such a situation you will see that `a` actually belongs to two different mappings where it's a descendant: `k -> a` and `c -> a`. No number can have two different parents because that would mean in the original array, two different indices have the same value, that is just illegal.\\n\\nNow, what if there are actually *one* `k -> k` mappings? Just think of the subproblem formed by the `N-1` numbers: the lemma is valid in this subproblem. Regarding the sole `k -> k` itself, it's a cycle already, and does not undermine the proof of the lemma. \\nWhat if there are more such `k -> k` mappings? Just think inductively. They don't matter. \\n**End Of Proof**\\n\\nNow, lemma 1 proved why we do the duplicate detection as the loop header. But what about the *visited flag** part? Why is it that as long as we found a visited number, we can leave it there because it's already covered by some cycle from a previous `i`?\\n\\n## Lemma 2: All cycles are disjoint.\\n**Proof**: to make the lemma easier to prove, we rephrase:\\nIf we start from `k` and reached a visited `t`, then `k` must belong to the same cycle as `t`.\\n\\nThis is actually easily provable using the same thought regarding the  `k -> a -> b -> c -> a` above: now that `t` is visited, we know that `t` is in a cycle. And now that `k` can reach `t`, then if we start from `k`, we must enter this very cycle at some point. Say this point is `t'` (`t'` can be the same as `t`):\\n* if `t'` is not `t`: then we know that we must have a mapping `k -> t'`. Suppose `k` is not in this cycle for the purpose of contradiction. Then there must be a node `t''` in the cycle which is not `k` but which also provides `t'' -> t'`. Now `t'` has two distinct parents, and that is illegal. Thus contradiction.\\n* if `t'` equals `t`: so we have `k -> t`. Do something similar to the above case and it's also easily provable.\\n**End of Proof**\\n\\nI think these two lemmas suffice for understanding the problem and the algorithm now. Hope this helps.",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length, max = 0;\\n        for (int i = 0; i < n; i++) {\\n            int index = i, count = 0;\\n            while (nums[index] < n && nums[index] != i) {\\n                count++;\\n                nums[index] += n;\\n                index = nums[index] - n;\\n            }\\n            if (++count > max)\\n                max = count;\\n            if (max >= (n + 1) / 2)\\n                return max;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438213,
                "title": "clean-short-python-o-n-time-o-n-space",
                "content": "* If the number is not present in the global set, then calculate the respective set for that number,\\n* Else just continue because that number will yeild an already visited set ( and that will not make any difference to the result).\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        res, l = 0, len(nums)\\n        globalSet = set()\\n        for k in range(l):\\n            if k not in globalSet:\\n                currLength, currSet, val = 0, set(), k\\n                while True:\\n                    if nums[val] in currSet: break\\n                    currSet.add(nums[val])\\n                    globalSet.add(nums[val])\\n                    currLength, val = currLength + 1, nums[val]\\n                res = max(res, currLength)        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        res, l = 0, len(nums)\\n        globalSet = set()\\n        for k in range(l):\\n            if k not in globalSet:\\n                currLength, currSet, val = 0, set(), k\\n                while True:\\n                    if nums[val] in currSet: break\\n                    currSet.add(nums[val])\\n                    globalSet.add(nums[val])\\n                    currLength, val = currLength + 1, nums[val]\\n                res = max(res, currLength)        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180461,
                "title": "understand-it-like-a-graph-python-code",
                "content": "For the example A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\\nDraw a graph: ![image](https://assets.leetcode.com/users/islander/image_1539323348.png)\\nThe problem can be transformed into a directed graph, and we are asked to get the size of largest connected component. So for example, from 0 we can explore the local connected component, and we don\\'t need to check 5, 6, 2 again.\\nI personally find this model to be easier to undertand, HIH\\n\\nIgnore my code below, this is better: https://leetcode.com/problems/array-nesting/discuss/102473/Python-solution\\nCode: (we can use a count instead of a set, should be easy to change)\\n```\\nseen = set()\\nresult = 0\\nfor (i, num) in enumerate(nums):\\n    if i not in seen:\\n        cur_set = set([i])\\n        seen.add(i)\\n        j = num\\n        while j not in cur_set:\\n            cur_set.add(j)\\n            seen.add(j)\\n            j = nums[j]\\n        result = max(result, len(cur_set))\\nreturn result\\n```",
                "solutionTags": [],
                "code": "```\\nseen = set()\\nresult = 0\\nfor (i, num) in enumerate(nums):\\n    if i not in seen:\\n        cur_set = set([i])\\n        seen.add(i)\\n        j = num\\n        while j not in cur_set:\\n            cur_set.add(j)\\n            seen.add(j)\\n            j = nums[j]\\n        result = max(result, len(cur_set))\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102443,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\npublic int arrayNesting(int[] nums) {\\n    int res = 0;\\n    for (int i=0;i<nums.length;i++) {\\n        if (nums[i] < 0) continue;\\n        int length = 1, val = nums[i];\\n        while (Math.abs(val) != i) {\\n            length++;\\n            val = nums[Math.abs(val)];\\n            nums[Math.abs(val)] *= -1;\\n        }\\n        res = Math.max(res, length);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int arrayNesting(int[] nums) {\\n    int res = 0;\\n    for (int i=0;i<nums.length;i++) {\\n        if (nums[i] < 0) continue;\\n        int length = 1, val = nums[i];\\n        while (Math.abs(val) != i) {\\n            length++;\\n            val = nums[Math.abs(val)];\\n            nums[Math.abs(val)] *= -1;\\n        }\\n        res = Math.max(res, length);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904254,
                "title": "c-o-n-solution-with-detailed-explanation",
                "content": "The key points to this problem:\\n\\n1. All the numbers in the input array are unique so it doesn\\'t exist that two number point to the same index.\\n2. Based on above fact,  all sets are totally isolated. I mean one number of a set will never lead us to the number of another set.\\n3. Treat each set like a circle so no matter you start with any number of this set, it traverses the whole set.\\n\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        vector<bool> visited(nums.size(), false);\\n        int result = 0;\\n\\t\\t//Search for all sets\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int index = i;\\n            int count = 0;\\n\\t\\t\\t//Count the numbers in one set\\n            while(!visited[index])\\n            {\\n                visited[index] = true;\\n                index = nums[index];\\n                count++;                \\n            }\\n\\t\\t\\t//Record the longest set\\n            result = max(result, count);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nPlease upvote if you find my explanation useful.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        vector<bool> visited(nums.size(), false);\\n        int result = 0;\\n\\t\\t//Search for all sets\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int index = i;\\n            int count = 0;\\n\\t\\t\\t//Count the numbers in one set\\n            while(!visited[index])\\n            {\\n                visited[index] = true;\\n                index = nums[index];\\n                count++;                \\n            }\\n\\t\\t\\t//Record the longest set\\n            result = max(result, count);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438215,
                "title": "c-clean-easy-solution-simple-observation",
                "content": "**Solution:**\\n\\n**Approach:** \\n* Each element forms a cycle and gets visited only one time for that particular cycle(try to observe this using multiple examples) \\n* Thus, after observing this just create a visited array/map or mark the integer negative\\n* If the element is already marked, this means we have already visited it and it is present in a unique cycle and continue your search for other elements\\n* Find the maximum size out of all the unique cycles\\n\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_1 = INT_MIN;\\n        for(int i = 0; i < n; i++){\\n            int sz = 0;\\n            int ind = i;\\n            while(1){\\n                if(nums[ind] == ind){\\n                    sz = 1;\\n                    break;\\n                }\\n                else if(nums[ind] < 0)\\n                    break;\\n                sz++;\\n                nums[ind] *= -1;\\n                ind = abs(nums[ind]);\\n            }\\n            max_1 = max(max_1, sz);\\n        }\\n        return max_1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_1 = INT_MIN;\\n        for(int i = 0; i < n; i++){\\n            int sz = 0;\\n            int ind = i;\\n            while(1){\\n                if(nums[ind] == ind){\\n                    sz = 1;\\n                    break;\\n                }\\n                else if(nums[ind] < 0)\\n                    break;\\n                sz++;\\n                nums[ind] *= -1;\\n                ind = abs(nums[ind]);\\n            }\\n            max_1 = max(max_1, sz);\\n        }\\n        return max_1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102428,
                "title": "should-the-example-output-be-4",
                "content": "For the example output, should it be 4 instead?\\n```\\nInput: A = [5,4,0,3,1,6,2]\\nOutput: 6\\nExplanation: \\nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\\n\\nOne of the longest S[K]:\\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\\n```",
                "solutionTags": [],
                "code": "```\\nInput: A = [5,4,0,3,1,6,2]\\nOutput: 6\\nExplanation: \\nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\\n\\nOne of the longest S[K]:\\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439808,
                "title": "java-solution-using-hashset",
                "content": "The main idea is to check for every index and keep count of the distinct elements which is donw by using HashSet.\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n ; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            hs.add(nums[i]);\\n            int x = nums[i];\\n            while(!hs.contains(nums[x])){\\n                hs.add(nums[x]);\\n                x = nums[x];\\n            }\\n            ans = Math.max(ans , hs.size());\\n        }\\n        return ans;\\n    }\\n}\\n```\\nResult: TLE in last 3 test cases.\\n\\nObservation: We can use a single HashSet for the entire operation. Since there are elements from 0 to (n - 1) so overlapping indexes can be avoided by keeping track of the number of times insertion is done. The implementation is given below.\\n\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n ; i++){\\n            int j = i;\\n            int count = 0;\\n            while(!hs.contains(nums[j])){\\n                hs.add(nums[j]);\\n                j = nums[j];\\n                count++;\\n            }\\n            ans = Math.max(ans , count);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nResult : Accepted. \\nDo upvote id it was helpful.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n ; i++){\\n            HashSet<Integer> hs = new HashSet<>();\\n            hs.add(nums[i]);\\n            int x = nums[i];\\n            while(!hs.contains(nums[x])){\\n                hs.add(nums[x]);\\n                x = nums[x];\\n            }\\n            ans = Math.max(ans , hs.size());\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        HashSet<Integer> hs = new HashSet<>();\\n        int ans = Integer.MIN_VALUE;\\n        for(int i = 0 ; i < n ; i++){\\n            int j = i;\\n            int count = 0;\\n            while(!hs.contains(nums[j])){\\n                hs.add(nums[j]);\\n                j = nums[j];\\n                count++;\\n            }\\n            ans = Math.max(ans , count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438695,
                "title": "straighforward-dfs-clean-code",
                "content": "**Intuition:**\\nThis is actually dfs. Start from each element and check for cycle (for that change its value to -1). if cycle found , break and update the maximum ans.\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        \\n        int ans=INT_MIN;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int k=i;\\n            int sz=0;\\n            while(nums[k]>=0)\\n            {\\n                sz++;\\n                int next=nums[k];\\n                nums[k]=-1;\\n                k=next;\\n                \\n            }\\n            ans=max(ans,sz);\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        \\n        int ans=INT_MIN;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int k=i;\\n            int sz=0;\\n            while(nums[k]>=0)\\n            {\\n                sz++;\\n                int next=nums[k];\\n                nums[k]=-1;\\n                k=next;\\n                \\n            }\\n            ans=max(ans,sz);\\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438158,
                "title": "array-nesting-with-clear-explanation",
                "content": "```\\n-> Starting at i = 0.\\nA[0] = 5;   // A[i] == A[0]\\nA[5] = 6;   // A[A[i]] == A[A[0]] == A[5]\\nA[6] = 2;   // A[A[A[i]]] == A[A[A[0]]] == A[A[5]] == A[6]\\nA[2] = 0;   // and so on\\u2026\\nA[0] = 5;   // We reach the start point hence S = 4 elements\\n\\n-> Starting at i = 1.\\nA[1] = 4;   // A[i] == A[1]\\nA[4] = 1;   // A[A[i]] == A[A[1] == A[4]\\nA[1] = 4;   // We reach the start point hence S = 2 elements\\n```\\nAs per the problem statement, out of all these sets possible, we need to give the highest number of elements in such a set.\\n\\nA brute force solution would be to start at each of the indices and try to form sets. We can keep a track of the largest set formed and then return the result.\\nLooking at the problem closely can hint at a better solution.\\n\\nLet us look at the array once again, when we start from i = 0.\\n\\n![Array Nesting Image](https://i1.wp.com/studyalgorithms.com/wp-content/uploads/2019/06/Screen-Shot-2019-06-03-at-1.33.40-AM.png?w=780&ssl=1)\\n\\nWe see that we form a kind of cycle.\\nA similar cycle is seen when we start from i = 1.\\n\\n![Array Nesting Image 2](https://i0.wp.com/studyalgorithms.com/wp-content/uploads/2019/06/Screen-Shot-2019-06-03-at-1.35.01-AM.png?w=703&ssl=1)\\n\\nSo, this means that we will get the same set S if we start from positions (0, 2, 5, 6). Because we are forming a cycle.\\n\\nHence, we should try to leverage this fact and form a solution. While evaluating the set S, we can mark the elements of the array as visited. In the next iteration, if the element is already visited, we do not need to evaluate the set S again.\\n\\n***UPDATE** For marking an element, we can change its value to -1.*\\n\\n***Java Solution***\\n```\\npublic int arrayNesting(int[] nums) {\\n\\n    // boolean[] visited = new boolean[nums.length];\\n    int res = 0;\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i]!=-1) {\\n        int start = nums[i];\\n        int count = 0;\\n        do {\\n          start = nums[start];\\n          count++;\\n\\t\\t  nums[i] = -1;\\n          // visited[start] = true;\\n        }\\n        while (start != nums[i]);\\n        res = Math.max(res, count);\\n      }\\n    }\\n    return res;\\n  }\\n```\\n\\n***C++ Solution***\\n```\\nint arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        // vector<bool> visited(n,false);\\n        int res=0,tmp,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=-1){\\n                tmp = nums[i];\\n                cnt=0;\\n                do{\\n                    nums[i]=-1;\\n                    tmp = nums[tmp];\\n                    cnt++;\\n                }while(tmp!=nums[i]);\\n                res = max(res,cnt);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nTime Complexity: **O(n)**\\nSpace Complexity: **O(1)**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n-> Starting at i = 0.\\nA[0] = 5;   // A[i] == A[0]\\nA[5] = 6;   // A[A[i]] == A[A[0]] == A[5]\\nA[6] = 2;   // A[A[A[i]]] == A[A[A[0]]] == A[A[5]] == A[6]\\nA[2] = 0;   // and so on\\u2026\\nA[0] = 5;   // We reach the start point hence S = 4 elements\\n\\n-> Starting at i = 1.\\nA[1] = 4;   // A[i] == A[1]\\nA[4] = 1;   // A[A[i]] == A[A[1] == A[4]\\nA[1] = 4;   // We reach the start point hence S = 2 elements\\n```\n```\\npublic int arrayNesting(int[] nums) {\\n\\n    // boolean[] visited = new boolean[nums.length];\\n    int res = 0;\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i]!=-1) {\\n        int start = nums[i];\\n        int count = 0;\\n        do {\\n          start = nums[start];\\n          count++;\\n\\t\\t  nums[i] = -1;\\n          // visited[start] = true;\\n        }\\n        while (start != nums[i]);\\n        res = Math.max(res, count);\\n      }\\n    }\\n    return res;\\n  }\\n```\n```\\nint arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        // vector<bool> visited(n,false);\\n        int res=0,tmp,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=-1){\\n                tmp = nums[i];\\n                cnt=0;\\n                do{\\n                    nums[i]=-1;\\n                    tmp = nums[tmp];\\n                    cnt++;\\n                }while(tmp!=nums[i]);\\n                res = max(res,cnt);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144121,
                "title": "using-cycle-detection-approach",
                "content": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        \\n        int max = 0;\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i=0 ; i < nums.length ; i++)\\n        {\\n            if(visited[i] == false) \\n                max = Math.max(max, dfs(i, nums, visited,0));\\n        }     \\n        return max;\\n    }\\n    \\n    \\n    public int dfs(int index, int[] nums, boolean[] visited, int count)\\n    {\\n        if(visited[index] == true)\\n            return count;     \\n        visited[index] = true;\\n        return dfs(nums[index] , nums, visited, count+1);\\n    }\\n}\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int arrayNesting(int[] nums) {\\n        \\n        int max = 0;\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i=0 ; i < nums.length ; i++)\\n        {\\n            if(visited[i] == false) \\n                max = Math.max(max, dfs(i, nums, visited,0));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 638814,
                "title": "easy-java-solution-100-faster-1-ms",
                "content": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n      \\n        int count,max=0;\\n        for(int i=0;i<nums.length;i++){\\n          count=0;\\n            int index=i;\\n            while(nums[index]!=-999){     \\n                int temp=nums[index];\\n                nums[index]=-999;\\n                index=temp;\\n                count++;\\n            }\\n          max=Math.max(count,max);\\n      }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n      \\n        int count,max=0;\\n        for(int i=0;i<nums.length;i++){\\n          count=0;\\n            int index=i;\\n            while(nums[index]!=-999){     \\n                int temp=nums[index];\\n                nums[index]=-999;\\n                index=temp;\\n                count++;\\n            }\\n          max=Math.max(count,max);\\n      }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374743,
                "title": "python-solution-o-1-space",
                "content": "```python\\ndef arrayNesting(self, nums: List[int]) -> int:\\n        mx = 0\\n        for i in range(len(nums)):\\n            if nums[i] == -1: continue # continue if we already met it\\n            length = 0\\n            while nums[i] != -1: # stop when we meet the same number twice\\n                nums[i], i = -1, nums[i]\\n                length += 1\\n            if length > mx: mx = length\\n        return mx\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef arrayNesting(self, nums: List[int]) -> int:\\n        mx = 0\\n        for i in range(len(nums)):\\n            if nums[i] == -1: continue # continue if we already met it\\n            length = 0\\n            while nums[i] != -1: # stop when we meet the same number twice\\n                nums[i], i = -1, nums[i]\\n                length += 1\\n            if length > mx: mx = length\\n        return mx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 102489,
                "title": "java-solution-union-find",
                "content": "This is a typical Union Find problem.\\n\\n```\\npublic class Solution {\\n    class UnionFind {\\n        private int count = 0;\\n        private int[] parent, rank;\\n        \\n        public UnionFind(int n) {\\n            count = n;\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            int q = parent[p];\\n            while (q != parent[q]) {\\n                q = parent[q];\\n            }\\n            parent[p] = q;\\n            return q;\\n        }\\n        \\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n            if (rootP == rootQ) return;\\n            if (rank[rootQ] > rank[rootP]) {\\n                parent[rootP] = rootQ;\\n            }\\n            else {\\n                parent[rootQ] = rootP;\\n                if (rank[rootP] == rank[rootQ]) {\\n                    rank[rootP]++;\\n                }\\n            }\\n            count--;\\n        }\\n        \\n        public int count() {\\n            return count;\\n        }\\n        \\n        public int getMaxUnion() {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int max = 1;\\n            for (int i = 0; i < parent.length; i++) {\\n                int p = find(i);\\n                map.put(p, map.getOrDefault(p, 0) + 1);\\n                max = Math.max(max, map.get(p));\\n            }\\n            return max;\\n        }\\n    }\\n    \\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            uf.union(i, nums[i]);\\n        }\\n        return uf.getMaxUnion();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class UnionFind {\\n        private int count = 0;\\n        private int[] parent, rank;\\n        \\n        public UnionFind(int n) {\\n            count = n;\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            int q = parent[p];\\n            while (q != parent[q]) {\\n                q = parent[q];\\n            }\\n            parent[p] = q;\\n            return q;\\n        }\\n        \\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n            if (rootP == rootQ) return;\\n            if (rank[rootQ] > rank[rootP]) {\\n                parent[rootP] = rootQ;\\n            }\\n            else {\\n                parent[rootQ] = rootP;\\n                if (rank[rootP] == rank[rootQ]) {\\n                    rank[rootP]++;\\n                }\\n            }\\n            count--;\\n        }\\n        \\n        public int count() {\\n            return count;\\n        }\\n        \\n        public int getMaxUnion() {\\n            Map<Integer, Integer> map = new HashMap<>();\\n            int max = 1;\\n            for (int i = 0; i < parent.length; i++) {\\n                int p = find(i);\\n                map.put(p, map.getOrDefault(p, 0) + 1);\\n                max = Math.max(max, map.get(p));\\n            }\\n            return max;\\n        }\\n    }\\n    \\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            uf.union(i, nums[i]);\\n        }\\n        return uf.getMaxUnion();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572456,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& A)\\n     {\\n       int res = 0, n = A.size();\\n        vector<bool> seen(n);\\n        for (int i: A) \\n        {\\n            int cnt = 0;\\n            while (!seen[i])\\n             {\\n                seen[i] = true;\\n                cnt++;\\n                i = A[i];\\n            }\\n            res = max(res, cnt);\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& A)\\n     {\\n       int res = 0, n = A.size();\\n        vector<bool> seen(n);\\n        for (int i: A) \\n        {\\n            int cnt = 0;\\n            while (!seen[i])\\n             {\\n                seen[i] = true;\\n                cnt++;\\n                i = A[i];\\n            }\\n            res = max(res, cnt);\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800303,
                "title": "java-self-explanatory-o-n-easy",
                "content": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int res=0;\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(!visited[i]){\\n                int len = dfs(nums,i,visited);\\n                res = Math.max(res,len);\\n            }\\n        }\\n        return res;\\n    }\\n    public int dfs(int[] nums,int i,boolean[] visited){\\n        if(visited[i]) return 0;\\n        visited[i] = true;\\n        return 1+dfs(nums,nums[i],visited);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int res=0;\\n        boolean[] visited = new boolean[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(!visited[i]){\\n                int len = dfs(nums,i,visited);\\n                res = Math.max(res,len);\\n            }\\n        }\\n        return res;\\n    }\\n    public int dfs(int[] nums,int i,boolean[] visited){\\n        if(visited[i]) return 0;\\n        visited[i] = true;\\n        return 1+dfs(nums,nums[i],visited);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760722,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        result = 0\\n        visited = set()\\n        for i in range(len(nums)):\\n            length = 0\\n            while not i in visited:\\n                length += 1\\n                visited.add(i)\\n                i = nums[i]\\n            result = max(result, length)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        result = 0\\n        visited = set()\\n        for i in range(len(nums)):\\n            length = 0\\n            while not i in visited:\\n                length += 1\\n                visited.add(i)\\n                i = nums[i]\\n            result = max(result, length)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348779,
                "title": "brute-force-c",
                "content": "Please upvote if it helped you :)\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int s=nums.size();\\n        vector<bool>v(s,false);\\n        int res=0;\\n        for(auto x:nums){\\n            int cnt=0;\\n            while(v[x]==false){\\n                v[x]=true;\\n                cnt++;\\n                x=nums[x];\\n            }   \\n            res=max(cnt,res);\\n        }\\n        return res;      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int s=nums.size();\\n        vector<bool>v(s,false);\\n        int res=0;\\n        for(auto x:nums){\\n            int cnt=0;\\n            while(v[x]==false){\\n                v[x]=true;\\n                cnt++;\\n                x=nums[x];\\n            }   \\n            res=max(cnt,res);\\n        }\\n        return res;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298851,
                "title": "565-time-90-23-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize a boolean visited list of size n, where visited[i] indicates if nums[i] has been visited or not.\\nInitialize a variable max_length to zero, which will be used to store the maximum length of any set.\\nIterate over all elements of nums using a for loop with loop variable i:\\nCheck if nums[i] has already been visited, by checking if visited[i] is True. If it has been visited, skip to the next iteration of the loop.\\nIf nums[i] has not been visited, initialize a variable length to zero.\\nSet a variable j to i, which is the starting index of the current set.\\nEnter a while loop that runs until nums[j] has already been visited:\\nMark nums[j] as visited by setting visited[j] to True.\\nSet j to nums[j], which is the index of the next element in the current set.\\nIncrement length by one.\\nIf the length of the current set is greater than max_length, update max_length to the length of the current set.\\nReturn max_length.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        visited = [False] * len(nums)  # mark if a number is visited\\n        max_length = 0\\n        \\n        for i in range(len(nums)):\\n            if visited[i]:  # if already visited, skip\\n                continue\\n                \\n            length = 0\\n            j = i\\n            while not visited[j]:\\n                visited[j] = True  # mark as visited\\n                j = nums[j]  # move to next element in set\\n                length += 1\\n                \\n            max_length = max(max_length, length)  # update max_length\\n            \\n        return max_length\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        visited = [False] * len(nums)  # mark if a number is visited\\n        max_length = 0\\n        \\n        for i in range(len(nums)):\\n            if visited[i]:  # if already visited, skip\\n                continue\\n                \\n            length = 0\\n            j = i\\n            while not visited[j]:\\n                visited[j] = True  # mark as visited\\n                j = nums[j]  # move to next element in set\\n                length += 1\\n                \\n            max_length = max(max_length, length)  # update max_length\\n            \\n        return max_length\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682575,
                "title": "c-python-concise-dfs",
                "content": "# Python\\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        vis = set()\\n\\n        def dfs(i):\\n            if i in vis: return 0;\\n            vis.add(i)\\n            return 1 + dfs(nums[i])\\n        \\n        ans = 0\\n        for i in range(len(nums)):\\n            if i not in vis: ans = max(ans, dfs(i))\\n        \\n        return ans\\n```\\n\\n# C++\\n```\\nclass Solution {\\n    int dfs(int i, vector<int>& nums, unordered_set<int> &vis) {\\n        if(vis.find(i) != vis.end()) return 0;\\n        vis.insert(i);\\n        return 1 + dfs(nums[i], nums, vis);\\n    }\\n\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> vis;\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(vis.find(i) == vis.end()) ans = max(ans, dfs(i, nums, vis));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        vis = set()\\n\\n        def dfs(i):\\n            if i in vis: return 0;\\n            vis.add(i)\\n            return 1 + dfs(nums[i])\\n        \\n        ans = 0\\n        for i in range(len(nums)):\\n            if i not in vis: ans = max(ans, dfs(i))\\n        \\n        return ans\\n```\n```\\nclass Solution {\\n    int dfs(int i, vector<int>& nums, unordered_set<int> &vis) {\\n        if(vis.find(i) != vis.end()) return 0;\\n        vis.insert(i);\\n        return 1 + dfs(nums[i], nums, vis);\\n    }\\n\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> vis;\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(vis.find(i) == vis.end()) ans = max(ans, dfs(i, nums, vis));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580113,
                "title": "python-o-n-98-one-pass-with-early-exit-hashtable-check",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        res, seen = 0, set()\\n        for i in nums:\\n            j, l = i, 0\\n            while j not in seen:\\n                seen.add(j)\\n                j = nums[j]\\n                l += 1\\n            if l > res:\\n                res = l\\n            if l > len(nums) - len(seen):  # early exit\\n                break\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        res, seen = 0, set()\\n        for i in nums:\\n            j, l = i, 0\\n            while j not in seen:\\n                seen.add(j)\\n                j = nums[j]\\n                l += 1\\n            if l > res:\\n                res = l\\n            if l > len(nums) - len(seen):  # early exit\\n                break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480659,
                "title": "solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans = 0,n = nums.size(),k,temp;\\n        for(int i = 0;i<n;i++){\\n            k = i;\\n            temp = 0;\\n            while(nums[k] != -1){\\n                temp++;\\n                int y = k;\\n                k = nums[k];\\n                nums[y] = -1;\\n            }\\n            ans = max(ans,temp);\\n        }\\n        return max(ans,temp);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans = 0,n = nums.size(),k,temp;\\n        for(int i = 0;i<n;i++){\\n            k = i;\\n            temp = 0;\\n            while(nums[k] != -1){\\n                temp++;\\n                int y = k;\\n                k = nums[k];\\n                nums[y] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1470388,
                "title": "java-o-n-solution-o-1-space",
                "content": "Overall idea here is that we need to form sets of elements from the given array and return the length of largest set. All the elements in a particular set will be reachable to each other in the original array.\\nTaking an example to understand this : \\n`index `   0 1 2 3 4 \\n `nums`    2 3 4 1 0   \\n\\nWe start traversal from index = 0, include element 2 (nums[0]) in the set. Then we go to index 2 and include element 4 (nums[2]) in the set. Then we move to index 4 and include the element 0 (nums[4]) in the set. Now when we go to index 0, we can see that the element there is already been seen previously and hence the set formed is (2,4,0) with size 3. Likewise there will be another set formed when we start the traversal from 1 which will be (1,3) with size 2. Largest set size here would be 3 which would be our answer.  \\n\\nFew points to be highlighted here: \\n1. We donot actually need to form sets, so we can keep a counter and increment it till we see an element which is seen previously. Maintain a maxCounter that would hold the length of largest set seen till now.\\n2. We can make use of an explicit visited array to mark an element being visited. visited[i] = 1 when nums[i] is being processed. However inorder to save space, we can make use of the original array to denote an element being processed. Since the array elements will never be negative (as all elements are index values which cannot go negative), have used -1 to denote that an element has being processed. We can also use nums.length + 1 for this as this value will never be in the array.\\n3. For all the elements that belong to same set, we can start from either of the elements in that set and all the elements in that set would be reachable. Taking few examples would clarify this. Putting some for reference : eg1:  nums[] = [5, 2, 3, 1, 0, 4], sets here would be (5, 4, 0) and (2, 3, 1), here we start traversal from 0 or 4 or 5 we can visit all elements since they are linked.       eg2:  nums[] =  [6, 0, 4, 2, 3, 1, 5] sets here would be (6, 5, 1, 0) and (4, 2, 3). Also we can have  values such that all belong to one set, nums[] = [6, 0, 1, 2, 3, 4, 5] set (6, 5, 4, 3, 2, 1, 0).\\n\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int index = -1;\\n        int value = 0;\\n        int maxLen = 0;\\n        int len = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != -1) {\\n                index = i;\\n                len = 0;\\n                while (nums[index] != -1) {\\n                    value = nums[index]; //get the value in the set \\n                    nums[index] = -1; // mark the value as visited \\n                    index = value; //next index to jump\\n                    len++;\\n                }\\n                maxLen = Math.max(len, maxLen);\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int index = -1;\\n        int value = 0;\\n        int maxLen = 0;\\n        int len = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != -1) {\\n                index = i;\\n                len = 0;\\n                while (nums[index] != -1) {\\n                    value = nums[index]; //get the value in the set \\n                    nums[index] = -1; // mark the value as visited \\n                    index = value; //next index to jump\\n                    len++;\\n                }\\n                maxLen = Math.max(len, maxLen);\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440974,
                "title": "c-o-n-logic-without-extra-space-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& arr) {\\n        int i,n = arr.size();\\n        int mx=0;\\n        \\n        for(i=0; i<n; i++){\\n            if(arr[i] != -1){\\n                int x = i;\\n                int l = 0;\\n\\n                while(arr[x] != -1){\\n                    l++;\\n                    int y = arr[x];\\n                    arr[x] = -1;\\n                    x = y;                \\n                }\\n                mx = max(mx, l);\\n            }\\n        }\\n                \\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arrayNesting(vector<int>& arr) {\\n        int i,n = arr.size();\\n        int mx=0;\\n        \\n        for(i=0; i<n; i++){\\n            if(arr[i] != -1){\\n                int x = i;\\n                int l = 0;\\n\\n                while(arr[x] != -1){\\n                    l++;\\n                    int y = arr[x];\\n                    arr[x] = -1;\\n                    x = y;                \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1439892,
                "title": "using-grpah",
                "content": "```\\nclass Solution {\\n  public:\\n\\n\\tint doDfs(vector < vector<int>> &edge, vector<bool>&seen, int src) {\\n\\t\\tseen[src] = true;\\n\\t\\tint res = 0;\\n\\t\\tfor (int dst : edge[src]) {\\n\\t\\t\\tif (seen[dst]) continue;\\n\\t\\t\\tres = max(res, doDfs(edge, seen, dst));\\n\\t\\t}\\n\\t\\treturn res + 1;\\n\\t}\\n\\n\\tint arrayNesting(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector < vector<int>> edge(n, vector<int>());\\n\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tedge[nums[i]].push_back(nums[nums[i]]);\\n\\t\\t}\\n\\t\\tvector<bool> seen(n, false);\\n\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (seen[nums[i]])continue;\\n\\t\\t\\tres = max(res, doDfs(edge, seen, nums[i]));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public:\\n\\n\\tint doDfs(vector < vector<int>> &edge, vector<bool>&seen, int src) {\\n\\t\\tseen[src] = true;\\n\\t\\tint res = 0;\\n\\t\\tfor (int dst : edge[src]) {\\n\\t\\t\\tif (seen[dst]) continue;\\n\\t\\t\\tres = max(res, doDfs(edge, seen, dst));\\n\\t\\t}\\n\\t\\treturn res + 1;\\n\\t}\\n\\n\\tint arrayNesting(vector<int>& nums) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector < vector<int>> edge(n, vector<int>());\\n\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\tedge[nums[i]].push_back(nums[nums[i]]);\\n\\t\\t}\\n\\t\\tvector<bool> seen(n, false);\\n\\n\\t\\tint res = 0;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (seen[nums[i]])continue;\\n\\t\\t\\tres = max(res, doDfs(edge, seen, nums[i]));\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439469,
                "title": "2-easy-python-solutions-with-comments",
                "content": "\\nFirst solution O(n) time and O(n) space by using a seenIndex set\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        seenInd=set()\\n        start=0\\n        res=1\\n        \\n        while start<len(nums):\\n            if start in seenInd:\\n                start+=1\\n                continue\\n            \\n            count=1\\n            nextInd=nums[start]\\n            seenInd.add(start)\\n            while nextInd not in seenInd:\\n                count+=1\\n                res=max(res,count)\\n                seenInd.add(nextInd)\\n                nextInd=nums[nextInd]\\n        return res \\n            \\n```\\n Second solution similar to solution1, but without using extra space, by marking seenIndecees by -1 so O(n0 time and O(1) space\\n ```\\n\\n class Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        start=0\\n        res=1\\n        \\n        while start<len(nums):\\n            if nums[start] == -1: #means that its seen before\\n                start+=1\\n                continue\\n            \\n            count=1 \\n            nextInd=nums[start]\\n            nums[start]=-1 #mark it as seen\\n            while nums[nextInd] != -1: #i.e: not seen before\\n                count+=1\\n                res=max(res,count)\\n                nums[nextInd], nextInd=-1,nums[nextInd]\\n              \\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        seenInd=set()\\n        start=0\\n        res=1\\n        \\n        while start<len(nums):\\n            if start in seenInd:\\n                start+=1\\n                continue\\n            \\n            count=1\\n            nextInd=nums[start]\\n            seenInd.add(start)\\n            while nextInd not in seenInd:\\n                count+=1\\n                res=max(res,count)\\n                seenInd.add(nextInd)\\n                nextInd=nums[nextInd]\\n        return res \\n            \\n```\n```\\n\\n class Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        start=0\\n        res=1\\n        \\n        while start<len(nums):\\n            if nums[start] == -1: #means that its seen before\\n                start+=1\\n                continue\\n            \\n            count=1 \\n            nextInd=nums[start]\\n            nums[start]=-1 #mark it as seen\\n            while nums[nextInd] != -1: #i.e: not seen before\\n                count+=1\\n                res=max(res,count)\\n                nums[nextInd], nextInd=-1,nums[nextInd]\\n              \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438937,
                "title": "java-solution-dfs",
                "content": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<0)\\n                continue;\\n            \\n            max = Math.max(max, calculateNodes(nums, i));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int calculateNodes(int[] arr, int start){\\n        if(start<0 || start==arr.length || arr[start]<0){\\n            return 0;\\n        }\\n        \\n        int nextNodetoVisit = arr[start];\\n        arr[start] = Integer.MIN_VALUE;\\n        return 1 + calculateNodes(arr, nextNodetoVisit);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<0)\\n                continue;\\n            \\n            max = Math.max(max, calculateNodes(nums, i));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int calculateNodes(int[] arr, int start){\\n        if(start<0 || start==arr.length || arr[start]<0){\\n            return 0;\\n        }\\n        \\n        int nextNodetoVisit = arr[start];\\n        arr[start] = Integer.MIN_VALUE;\\n        return 1 + calculateNodes(arr, nextNodetoVisit);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438223,
                "title": "c-disjoint-set-union-solution",
                "content": "Our task is to find the maximum cycle in the permutation. Since all cycles are disjoint we should find the size of the largest set in DSU.\\n\\n```\\nstruct DSU {\\n  vector<int> parent;\\n  vector<int> sizes;\\n\\n  DSU(int sz): parent(sz), sizes(sz) {\\n    for (int i = 0; i < sz; ++i) {\\n      parent[i] = i;\\n      sizes[i] = 1;\\n    }\\n  }\\n\\n  int find(int x) {\\n    if (x == parent[x]) {\\n      return x;\\n    }\\n    return parent[x] = find(parent[x]);\\n  }\\n\\n  void join(int a, int b) {\\n    a = find(a);\\n    b = find(b);\\n\\n    if (a != b) {\\n      if (sizes[a] < sizes[b]) {\\n        swap(a, b);\\n      }\\n      parent[b] = a;\\n      sizes[a] += sizes[b];\\n    }\\n  }\\n};\\n\\nint arrayNesting(vector<int>& nums) {\\n  DSU d(nums.size());\\n\\n  for (int i = 0; i < nums.size(); ++i) {\\n    d.join(i, nums[i]);\\n  }\\n\\n  return *max_element(d.sizes.begin(), d.sizes.end());\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct DSU {\\n  vector<int> parent;\\n  vector<int> sizes;\\n\\n  DSU(int sz): parent(sz), sizes(sz) {\\n    for (int i = 0; i < sz; ++i) {\\n      parent[i] = i;\\n      sizes[i] = 1;\\n    }\\n  }\\n\\n  int find(int x) {\\n    if (x == parent[x]) {\\n      return x;\\n    }\\n    return parent[x] = find(parent[x]);\\n  }\\n\\n  void join(int a, int b) {\\n    a = find(a);\\n    b = find(b);\\n\\n    if (a != b) {\\n      if (sizes[a] < sizes[b]) {\\n        swap(a, b);\\n      }\\n      parent[b] = a;\\n      sizes[a] += sizes[b];\\n    }\\n  }\\n};\\n\\nint arrayNesting(vector<int>& nums) {\\n  DSU d(nums.size());\\n\\n  for (int i = 0; i < nums.size(); ++i) {\\n    d.join(i, nums[i]);\\n  }\\n\\n  return *max_element(d.sizes.begin(), d.sizes.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424880,
                "title": "python-3-array-clean-o-n-explanation",
                "content": "### Explanation\\n- First, you need to understand all numbers in `nums` are unique\\n- Given that, you can basically travel to the next number until you hit a cycle\\n- Record the length during the run\\n- Set visited value to `-1` to avoid revisit\\n### Implementation\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        ans = cnt = 0\\n        for i, idx in enumerate(nums):\\n            if idx < 0: continue                           # avoid revisit\\n            while nums[idx] >= 0:\\n                cnt, nums[idx], idx = cnt+1, -1, nums[idx] # increment length; mark as visited; visit next value\\n            else:    \\n                ans, cnt = max(ans, cnt), 0                # record length and reset `cnt`\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        ans = cnt = 0\\n        for i, idx in enumerate(nums):\\n            if idx < 0: continue                           # avoid revisit\\n            while nums[idx] >= 0:\\n                cnt, nums[idx], idx = cnt+1, -1, nums[idx] # increment length; mark as visited; visit next value\\n            else:    \\n                ans, cnt = max(ans, cnt), 0                # record length and reset `cnt`\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191497,
                "title": "java-1ms-faster-than-100-with-explanation",
                "content": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n=nums.length;\\n        int count=0,max_c=Integer.MIN_VALUE;\\n      //changed the value at nums[i] to -(i+1) to keep track of elements visited\\n\\t  for(int i=0;i<n;i++){\\n        if(nums[i]>=0){ // if nums[i]>=0 means the element is not visited\\n          int indx=nums[i],val=-1*(i+1); \\n     //if the duplicate element occur it will form a cycle i.e starting pt and ending pt will be equal\\n\\t\\t while(indx!=i){ \\n            int tmp=nums[indx];\\n            nums[indx]=val;\\n            val=-1*(indx+1);\\n            indx=tmp;\\n            count++;// count keeps track of no of elements in the cycle\\n          }\\n          nums[indx]=val;\\n          count++; \\n        }\\n\\t\\t//max_c keep track of max value of count for each element in array\\n        max_c=Math.max(max_c,count); \\n        count=0;\\n      }\\n        return max_c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n=nums.length;\\n        int count=0,max_c=Integer.MIN_VALUE;\\n      //changed the value at nums[i] to -(i+1) to keep track of elements visited\\n\\t  for(int i=0;i<n;i++){\\n        if(nums[i]>=0){ // if nums[i]>=0 means the element is not visited\\n          int indx=nums[i],val=-1*(i+1); \\n     //if the duplicate element occur it will form a cycle i.e starting pt and ending pt will be equal\\n\\t\\t while(indx!=i){ \\n            int tmp=nums[indx];\\n            nums[indx]=val;\\n            val=-1*(indx+1);\\n            indx=tmp;\\n            count++;// count keeps track of no of elements in the cycle\\n          }\\n          nums[indx]=val;\\n          count++; \\n        }\\n\\t\\t//max_c keep track of max value of count for each element in array\\n        max_c=Math.max(max_c,count); \\n        count=0;\\n      }\\n        return max_c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626837,
                "title": "javascript-dfs-with-cache-easy-to-understand",
                "content": "```\\nvar arrayNesting = function(nums) {\\n    const visited = new Set();\\n    const dfs = (num, len) => {\\n        if(visited.has(num)) return len;\\n        visited.add(num);\\n        len++;\\n        return dfs(nums[num], len);\\n    }\\n    return nums.reduce((len, curr) => visited.has(curr) ? len : Math.max(dfs(curr,  0), len), 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar arrayNesting = function(nums) {\\n    const visited = new Set();\\n    const dfs = (num, len) => {\\n        if(visited.has(num)) return len;\\n        visited.add(num);\\n        len++;\\n        return dfs(nums[num], len);\\n    }\\n    return nums.reduce((len, curr) => visited.has(curr) ? len : Math.max(dfs(curr,  0), len), 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415283,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, nums):\\n        result = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            curr = i\\n            size = 0\\n            \\n            while not nums[curr] == -1:\\n                size += 1\\n                temp = nums[curr]\\n                nums[curr] = -1\\n                curr = temp\\n            \\n            result = max(result, size)\\n        \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums):\\n        result = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            curr = i\\n            size = 0\\n            \\n            while not nums[curr] == -1:\\n                size += 1\\n                temp = nums[curr]\\n                nums[curr] = -1\\n                curr = temp\\n            \\n            result = max(result, size)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364272,
                "title": "solution-in-python-3-beats-100-only-seven-lines",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, n: List[int]) -> int:\\n    \\tS = {}\\n    \\tfor i in range(len(n)):\\n    \\t\\tif n[i] == -1: continue\\n    \\t\\tm, a = 0, i\\n    \\t\\twhile n[a] != -1: n[a], a, b, m = -1, n[a], a, m + 1\\n    \\t\\tS[i] = m + S.pop(b, 0)\\n    \\treturn max(S.values())\\n\\n\\n- Python 3\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def arrayNesting(self, n: List[int]) -> int:\\n    \\tS = {}",
                "codeTag": "Java"
            },
            {
                "id": 346586,
                "title": "c-solution-it-s-a-loop-does-not-matter-where-it-starts",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint arrayNesting(vector<int>& nums) {\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tint len=0;\\n\\t\\t\\t\\tfor(int tem=i;nums[tem]>=0;){\\n\\t\\t\\t\\t\\tlen++;\\n\\t\\t\\t\\t\\tint tem2;\\n\\t\\t\\t\\t\\ttem2=nums[tem];\\n\\t\\t\\t\\t\\tnums[tem]=-1;\\n\\t\\t\\t\\t\\ttem=tem2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres=max(res,len);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t}\\n\\n\\n\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint arrayNesting(vector<int>& nums) {\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tint len=0;\\n\\t\\t\\t\\tfor(int tem=i;nums[tem]>=0;){\\n\\t\\t\\t\\t\\tlen++;\\n\\t\\t\\t\\t\\tint tem2;\\n\\t\\t\\t\\t\\ttem2=nums[tem];\\n\\t\\t\\t\\t\\tnums[tem]=-1;\\n\\t\\t\\t\\t\\ttem=tem2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 238111,
                "title": "python-simple",
                "content": "Accepted and Easy to understand solution\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: \\'List[int]\\') -> \\'int\\':\\n        res = 0\\n        for i in range(len(nums)):\\n            cache = set()\\n            j = i\\n            while nums[j] < len(nums) and len(cache) <= len(nums) and j not in cache and j >=0:\\n                cache.add(j)\\n                tmp = nums[j]\\n                nums[j] = -1\\n                j = tmp\\n            res = max(len(cache), res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: \\'List[int]\\') -> \\'int\\':\\n        res = 0\\n        for i in range(len(nums)):\\n            cache = set()\\n            j = i\\n            while nums[j] < len(nums) and len(cache) <= len(nums) and j not in cache and j >=0:\\n                cache.add(j)\\n                tmp = nums[j]\\n                nums[j] = -1\\n                j = tmp\\n            res = max(len(cache), res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102441,
                "title": "python-solution",
                "content": "make sure the last element you get is the index that you start.\\nlike ```S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}```, you can find S[**0**] = {5, 6, 2, **0**}\\nbad code but it works, i get it :(\\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):    \\n        count , sum_ , n = 1, [] , len(nums)\\n        for i in range(n):\\n            temp = i\\n            if nums[i] != n:\\n                while 1:\\n                    if nums[temp] == i:\\n                        sum_.append(count)\\n                        nums[temp] = n\\n                        count = 1\\n                        break\\n                    else:\\n                        temp1 = nums[temp]\\n                        nums[temp] = n\\n                        temp = temp1\\n                        count += 1\\n        return max(sum_)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}```\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):    \\n        count , sum_ , n = 1, [] , len(nums)\\n        for i in range(n):\\n            temp = i\\n            if nums[i] != n:\\n                while 1:\\n                    if nums[temp] == i:\\n                        sum_.append(count)\\n                        nums[temp] = n\\n                        count = 1\\n                        break\\n                    else:\\n                        temp1 = nums[temp]\\n                        nums[temp] = n\\n                        temp = temp1\\n                        count += 1\\n        return max(sum_)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102480,
                "title": "easy-understand-python-code",
                "content": "```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic = {}\\n        result = -float('inf')\\n        for index in range(len(nums)):\\n            count = 1\\n            dic[index] = 1\\n            while True:\\n                if nums[index] not in dic:\\n                    count += 1\\n                    dic[nums[index]] = 1\\n                    index = nums[index]\\n                else:\\n                    result = max(result,count)\\n                    break\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dic = {}\\n        result = -float('inf')\\n        for index in range(len(nums)):\\n            count = 1\\n            dic[index] = 1\\n            while True:\\n                if nums[index] not in dic:\\n                    count += 1\\n                    dic[nums[index]] = 1\\n                    index = nums[index]\\n                else:\\n                    result = max(result,count)\\n                    break\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 102488,
                "title": "python-straightforward-with-explanation",
                "content": "For every value ```0 <= x < N```, consider the set ```S_x = {x, A[x], A[A[x]], A[A[A[x]]],...}```\\nEvery node ```x``` belongs to some representative set ```S_i```.  We'll repeatedly take an unvisited node and visit all members of it's representative set.  We keep track of the size of this set ```bns = |S_i|``` and take a running max ```ans = max(ans, bns)```.\\n\\n```\\ndef arrayNesting(self, A):\\n    N = len(A)\\n    ans = 0\\n    seen = [False] * N\\n    for x in xrange(N):\\n    \\tbns = 0\\n    \\twhile not seen[x]:\\n            seen[x] = True\\n            x = A[x]\\n            bns += 1\\n        ans = max(ans, bns)\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```0 <= x < N```\n```S_x = {x, A[x], A[A[x]], A[A[A[x]]],...}```\n```x```\n```S_i```\n```bns = |S_i|```\n```ans = max(ans, bns)```\n```\\ndef arrayNesting(self, A):\\n    N = len(A)\\n    ans = 0\\n    seen = [False] * N\\n    for x in xrange(N):\\n    \\tbns = 0\\n    \\twhile not seen[x]:\\n            seen[x] = True\\n            x = A[x]\\n            bns += 1\\n        ans = max(ans, bns)\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3529101,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans=0;\\n        vector<int>v(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            int cnt=0, k=i;\\n            while(!v[k]){\\n                v[k]=1;\\n                cnt++;\\n                k=nums[k];\\n            }\\n            ans=max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans=0;\\n        vector<int>v(nums.size(), 0);\\n        for(int i=0; i<nums.size(); i++){\\n            int cnt=0, k=i;\\n            while(!v[k]){\\n                v[k]=1;\\n                cnt++;\\n                k=nums[k];\\n            }\\n            ans=max(ans, cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404998,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxLen = 1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i] == i) continue;\\n            int currLen = 1;\\n            while (nums[i] != i) {\\n                int next_i = nums[i];\\n                nums[i] = nums[next_i];\\n                nums[next_i] = next_i;\\n                currLen++;\\n            }\\n            maxLen = max(maxLen, currLen);\\n        }\\n        return maxLen;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        ans = 0\\n        for x in nums:\\n            if x == -1: continue\\n            cnt = 0\\n            while nums[x] != -1:\\n                cnt += 1\\n                nums[x], x = -1, nums[x]\\n            ans = max(ans, cnt)\\n                \\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != Integer.MAX_VALUE) {\\n                int start = nums[i], count = 0;\\n                while (nums[start] != Integer.MAX_VALUE) {\\n                    int temp = start;\\n                    start = nums[start];\\n                    count++;\\n                    nums[temp] = Integer.MAX_VALUE;\\n                }\\n                res = Math.max(res, count);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxLen = 1;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (nums[i] == i) continue;\\n            int currLen = 1;\\n            while (nums[i] != i) {\\n                int next_i = nums[i];\\n                nums[i] = nums[next_i];\\n                nums[next_i] = next_i;\\n                currLen++;\\n            }\\n            maxLen = max(maxLen, currLen);\\n        }\\n        return maxLen;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        ans = 0\\n        for x in nums:\\n            if x == -1: continue\\n            cnt = 0\\n            while nums[x] != -1:\\n                cnt += 1\\n                nums[x], x = -1, nums[x]\\n            ans = max(ans, cnt)\\n                \\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != Integer.MAX_VALUE) {\\n                int start = nums[i], count = 0;\\n                while (nums[start] != Integer.MAX_VALUE) {\\n                    int temp = start;\\n                    start = nums[start];\\n                    count++;\\n                    nums[temp] = Integer.MAX_VALUE;\\n                }\\n                res = Math.max(res, count);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756236,
                "title": "c-easiest-approach",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint arrayNesting(vector<int>& nums) {\\n\\t\\t\\tint l=nums.size();\\n\\t\\t\\tint maxx=0;\\n\\t\\t\\tvector<int> dp(l,-1);\\n\\t\\t\\tfor(int i=0;i<l;i++){\\n\\t\\t\\t\\tint t=i;\\n\\t\\t\\t\\tint size=0;\\n\\t\\t\\t\\twhile(nums[t]!=-1){\\n\\t\\t\\t\\t\\tint r=nums[t];\\n\\t\\t\\t\\t\\tnums[t]=-1;\\n\\t\\t\\t\\t\\tt=r;\\n\\t\\t\\t\\t\\tsize++;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxx=max(maxx,size);\\n\\t\\t\\t}\\n\\t\\t\\treturn maxx;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "Array",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint arrayNesting(vector<int>& nums) {\\n\\t\\t\\tint l=nums.size();\\n\\t\\t\\tint maxx=0;\\n\\t\\t\\tvector<int> dp(l,-1);\\n\\t\\t\\tfor(int i=0;i<l;i++){\\n\\t\\t\\t\\tint t=i;\\n\\t\\t\\t\\tint size=0;\\n\\t\\t\\t\\twhile(nums[t]!=-1){\\n\\t\\t\\t\\t\\tint r=nums[t];\\n\\t\\t\\t\\t\\tnums[t]=-1;\\n\\t\\t\\t\\t\\tt=r;\\n\\t\\t\\t\\t\\tsize++;\\n\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2644420,
                "title": "java-solution-iterative-recursive-o-n-time-o-1-space-dfs",
                "content": "## **Iterative Solution -> 4ms runtime faster than 99.8%**\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int c=0;\\n            while(nums[i]!=-1)\\n            {\\n                int temp = nums[i];\\n                nums[i]=-1;\\n                i = temp;\\n                c++;\\n            }\\n            max = Math.max(c,max);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n## **Recursive Solution**\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n            max = Math.max(dfs(nums,i,0),max);\\n        return max;\\n    }\\n    \\n    private int dfs(int[] nums,int i,int c)\\n    {\\n        if(nums[i]==-1)\\n            return c;\\n        int temp = nums[i];\\n        nums[i]=-1;\\n        return dfs(nums,temp,c+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int c=0;\\n            while(nums[i]!=-1)\\n            {\\n                int temp = nums[i];\\n                nums[i]=-1;\\n                i = temp;\\n                c++;\\n            }\\n            max = Math.max(c,max);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n            max = Math.max(dfs(nums,i,0),max);\\n        return max;\\n    }\\n    \\n    private int dfs(int[] nums,int i,int c)\\n    {\\n        if(nums[i]==-1)\\n            return c;\\n        int temp = nums[i];\\n        nums[i]=-1;\\n        return dfs(nums,temp,c+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625149,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& a) {\\n        size_t maxsize = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            size_t size = 0;\\n            for (int k = i; a[k] >= 0; size++) {\\n                int ak = a[k];\\n                a[k] = -1;\\n                k = ak;\\n            }\\n            maxsize = max(maxsize, size);\\n        }\\n\\n        return maxsize;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int arrayNesting(vector<int>& a) {\\n        size_t maxsize = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            size_t size = 0;\\n            for (int k = i; a[k] >= 0; size++) {\\n                int ak = a[k];\\n                a[k] = -1;\\n                k = ak;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2381342,
                "title": "c-easy-solution",
                "content": "For every index find the number of elements in the set by \\'res\\' variable and take the maximum as result. For identifying the reoccurring element an array \\'arr\\' is taken to mark the visited element as 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>&nums,int ind,int arr[],int res)\\n    {\\n        if(arr[ind]==1)\\n            return res;\\n        res++;\\n        arr[ind]=1;\\n        return dfs(nums,nums[ind],arr,res);\\n    }\\n    int arrayNesting(vector<int>& nums) {\\n        \\n        int arr[nums.size()],ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            arr[i]=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int res=dfs(nums,i,arr,0);\\n            ans=max(res,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>&nums,int ind,int arr[],int res)\\n    {\\n        if(arr[ind]==1)\\n            return res;\\n        res++;\\n        arr[ind]=1;\\n        return dfs(nums,nums[ind],arr,res);\\n    }\\n    int arrayNesting(vector<int>& nums) {\\n        \\n        int arr[nums.size()],ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            arr[i]=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int res=dfs(nums,i,arr,0);\\n            ans=max(res,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375747,
                "title": "c-easiest-and-concise-code",
                "content": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int dfs(map<int,int>&mp,vector<int>&vis,int str)\\n    {\\n        if(vis[str]==1)\\n            return 0;\\n        if(dp[str]!=-1)\\n        {\\n            vis[str]=1;\\n            return dp[str];\\n        }\\n        else\\n        {\\n            vis[str]=1;\\n            return dp[str]=1+dfs(mp,vis,mp[str]);\\n        }\\n    }\\n    int arrayNesting(vector<int>& nums) {\\n        dp.resize(nums.size(),-1);\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n            mp[i]=nums[i];\\n        int n=nums.size();\\n        int count=INT_MIN;\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            count=max(count,dfs(mp,vis,i));\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int dfs(map<int,int>&mp,vector<int>&vis,int str)\\n    {\\n        if(vis[str]==1)\\n            return 0;\\n        if(dp[str]!=-1)\\n        {\\n            vis[str]=1;\\n            return dp[str];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2329990,
                "title": "python-simple-dfs-based-approach-notes-not-very-optimized-though",
                "content": "```\\n/*\\nwe can solve this problem using simple dfs based approach\\nhave a visited set that keep tracks of indices that are already visited\\nstart with index 0 and recursively reach all the indexes possible until it reaches \\nan index which was previously tracked. check the lenght of the current set,\\nif it\\'s greater than max length so far, update the answer\\nRepeat the above step unless all the indexes are marked as visited\\n*/\\n```\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        max_len = 0\\n        visited = set()\\n        def dfs(nums, index, dfs_visited):\\n            if index in dfs_visited:\\n                return len(dfs_visited)\\n            \\n            # add the index to dfs_visited and visited\\n            visited.add(index)\\n            dfs_visited.add(index)\\n            return dfs(nums, nums[index], dfs_visited)\\n            \\n        for i in range(len(nums)):\\n            if i not in visited:\\n                max_len = max(max_len, dfs(nums, i, set()))\\n        return max_len\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\nwe can solve this problem using simple dfs based approach\\nhave a visited set that keep tracks of indices that are already visited\\nstart with index 0 and recursively reach all the indexes possible until it reaches \\nan index which was previously tracked. check the lenght of the current set,\\nif it\\'s greater than max length so far, update the answer\\nRepeat the above step unless all the indexes are marked as visited\\n*/\\n```\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        max_len = 0\\n        visited = set()\\n        def dfs(nums, index, dfs_visited):\\n            if index in dfs_visited:\\n                return len(dfs_visited)\\n            \\n            # add the index to dfs_visited and visited\\n            visited.add(index)\\n            dfs_visited.add(index)\\n            return dfs(nums, nums[index], dfs_visited)\\n            \\n        for i in range(len(nums)):\\n            if i not in visited:\\n                max_len = max(max_len, dfs(nums, i, set()))\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268773,
                "title": "c-solution-easy-and-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {  \\n        vector<int> vis(nums.size(),0);\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int k=i,count=0;\\n            while(!vis[k]){\\n                vis[k]=1;\\n                count++;\\n                k=nums[k];\\n            }\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {  \\n        vector<int> vis(nums.size(),0);\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int k=i,count=0;\\n            while(!vis[k]){\\n                vis[k]=1;\\n                count++;\\n                k=nums[k];\\n            }\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260446,
                "title": "simple-c-solution-w-comments-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums)  {\\n        int maxlen = 0;\\n\\t\\t\\t\\t\\n\\t\\t// try each index\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t// Only explore if it is not INT_MAX (Hasn\\'t been explored)\\n            if (nums[i] != INT_MAX) {\\n                int num=i;\\n                int len=0;\\n\\t\\t\\t\\t// start exploring... while \"current number\" is NOT INT_MAX\\n                while(nums[num] != INT_MAX){\\n\\t\\t\\t\\t\\t// set next_index, set current number to INT_MAX (visited)\\n                    int next_index = nums[num];\\n                    nums[num] = INT_MAX;\\n\\t\\t\\t\\t\\t// add 1 to len\\n                    len++;\\n\\t\\t\\t\\t\\t// update index to next_index\\n                    num = next_index;                    \\n                }\\n\\t\\t\\t\\t// end exploration, update max length\\n                maxlen = max(maxlen, len);\\n            }\\n   \\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums)  {\\n        int maxlen = 0;\\n\\t\\t\\t\\t\\n\\t\\t// try each index\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t// Only explore if it is not INT_MAX (Hasn\\'t been explored)\\n            if (nums[i] != INT_MAX) {\\n                int num=i;\\n                int len=0;\\n\\t\\t\\t\\t// start exploring... while \"current number\" is NOT INT_MAX\\n                while(nums[num] != INT_MAX){\\n\\t\\t\\t\\t\\t// set next_index, set current number to INT_MAX (visited)\\n                    int next_index = nums[num];\\n                    nums[num] = INT_MAX;\\n\\t\\t\\t\\t\\t// add 1 to len\\n                    len++;\\n\\t\\t\\t\\t\\t// update index to next_index\\n                    num = next_index;                    \\n                }\\n\\t\\t\\t\\t// end exploration, update max length\\n                maxlen = max(maxlen, len);\\n            }\\n   \\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214487,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        \\n        def DFS(nums, i, l):\\n            if nums[i] == -1:\\n                return l\\n            nums[i], i = -1, nums[i]\\n            \\n            return DFS(nums, i, l+1)\\n        \\n        m = 0\\n        for i in range(len(nums)):\\n            l = 0\\n            if nums[i] == -1: continue\\n            \\n            l = DFS(nums, i, l)\\n            m = max(m, l)\\n        \\n        return m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        \\n        def DFS(nums, i, l):\\n            if nums[i] == -1:\\n                return l\\n            nums[i], i = -1, nums[i]\\n            \\n            return DFS(nums, i, l+1)\\n        \\n        m = 0\\n        for i in range(len(nums)):\\n            l = 0\\n            if nums[i] == -1: continue\\n            \\n            l = DFS(nums, i, l)\\n            m = max(m, l)\\n        \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1951057,
                "title": "python3-solution",
                "content": "This is the largest connected compent problem.\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        def dfs(node):\\n            visited.add(node)\\n            this_group.add(node)\\n            neigh = nums[node]\\n            if neigh not in visited:\\n                dfs(neigh)\\n        \\n        ans = 0\\n        visited = set()\\n        for node in range(len(nums)):\\n            if node not in visited:\\n                this_group = set()\\n                dfs(node)\\n                ans = max(ans, len(this_group))\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "This is the largest connected compent problem.\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        def dfs(node):\\n            visited.add(node)\\n            this_group.add(node)\\n            neigh = nums[node]\\n            if neigh not in visited:\\n                dfs(neigh)\\n        \\n        ans = 0\\n        visited = set()\\n        for node in range(len(nums)):\\n            if node not in visited:\\n                this_group = set()\\n                dfs(node)\\n                ans = max(ans, len(this_group))\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1873723,
                "title": "c-solution-easy-dfs",
                "content": "```\\nclass Solution {\\n    void dfs(int node,vector<int>&vis,vector<int>&nums,vector<int>&v){\\n    \\n        if(vis[node]==1){\\n            return;\\n        }\\n        vis[node]=1;\\n        v.push_back(node);\\n        if(vis[nums[node]]==0){\\n            dfs(nums[node],vis,nums,v);\\n        }\\n    }\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int i,res=0;\\n        vector<int>vis(nums.size(),0);\\n        for(i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                vector<int>v;\\n                dfs(i,vis,nums,v);\\n                int p=v.size();\\n                res=max(res,p);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node,vector<int>&vis,vector<int>&nums,vector<int>&v){\\n    \\n        if(vis[node]==1){\\n            return;\\n        }\\n        vis[node]=1;\\n        v.push_back(node);\\n        if(vis[nums[node]]==0){\\n            dfs(nums[node],vis,nums,v);\\n        }\\n    }\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int i,res=0;\\n        vector<int>vis(nums.size(),0);\\n        for(i=0;i<nums.size();i++){\\n            if(vis[i]==0){\\n                vector<int>v;\\n                dfs(i,vis,nums,v);\\n                int p=v.size();\\n                res=max(res,p);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718362,
                "title": "straight-forward-c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longest = 1;\\n    int arrayNesting(vector<int>& nums) {\\n        vector<bool> v(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            longest = max(longest, dfs(v, nums, i));\\n            v = {false};\\n        }\\n        return longest;\\n    }\\n    int dfs(vector<bool>& v, vector<int>& nums, int i){\\n        if(v[i])\\n            return 0;\\n        v[i] = true;\\n        return 1 + dfs(v, nums, nums[i]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longest = 1;\\n    int arrayNesting(vector<int>& nums) {\\n        vector<bool> v(nums.size());\\n        for(int i = 0; i < nums.size(); i++){\\n            longest = max(longest, dfs(v, nums, i));\\n            v = {false};\\n        }\\n        return longest;\\n    }\\n    int dfs(vector<bool>& v, vector<int>& nums, int i){\\n        if(v[i])\\n            return 0;\\n        v[i] = true;\\n        return 1 + dfs(v, nums, nums[i]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473845,
                "title": "confusion-about-question-testcase",
                "content": "Hi so i understand the ask of the question. But in the event of a test case of [0,2,1] or [0,1,2] or even [0,anything,anything]\\nHow is it that the answer can be more then 1 if we are starting at index 0 and num[0] points to 0 it would just be a cycle of going to the [0] index in the array, the question states that We stop adding right before a duplicate element occurs in s[k].\\n\\nSo i am confused on how in the test case 0,2,1 how the answer could be more then 1.\\nIm sure its something small i am missing but just stuck after getting 3/4s test cases right.\\n\\nmy basic logic is have an arraylist that we would add the values in.\\n```\\nwhile(!isDup && counter < nums.length){\\n            if(arr.contains(nums[current])){\\n               isDup=true;\\n                break;  // meaning duplicate is found\\n            }\\n                \\n            else\\n                arr.add(nums[current]);\\n                current = nums[current];\\n                counter++;\\n                \\n        }\\n        \\n        return arr.size();\\n```\\n\\nIm sure the code isnt effiencient but this is more to understand the question and test cases fully",
                "solutionTags": [],
                "code": "```\\nwhile(!isDup && counter < nums.length){\\n            if(arr.contains(nums[current])){\\n               isDup=true;\\n                break;  // meaning duplicate is found\\n            }\\n                \\n            else\\n                arr.add(nums[current]);\\n                current = nums[current];\\n                counter++;\\n                \\n        }\\n        \\n        return arr.size();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459051,
                "title": "java-easy-dfs",
                "content": "```\\nclass Solution\\n{\\n    public int arrayNesting(int[] arr)\\n    {\\n        this.dp = new int[arr.length];\\n        this.arr = arr;\\n        int ans = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            if(dp[i] == 0)\\n            {\\n                this.vis = new HashSet<>();\\n                ans = Math.max(ans, dfs(i));\\n            }\\n        return ans;\\n    }\\n    private int dfs(int i)\\n    {\\n        if(vis.contains(i))\\n            return 0;\\n        vis.add(i);\\n        if(dp[i] != 0)\\n            return dp[i];\\n        dp[i] = 1 + dfs(arr[i]);\\n        return dp[i];\\n    }\\n    private int[] arr, dp;\\n    private Set<Integer> vis;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int arrayNesting(int[] arr)\\n    {\\n        this.dp = new int[arr.length];\\n        this.arr = arr;\\n        int ans = 0;\\n        for(int i = 0; i < arr.length; i++)\\n            if(dp[i] == 0)\\n            {\\n                this.vis = new HashSet<>();\\n                ans = Math.max(ans, dfs(i));\\n            }\\n        return ans;\\n    }\\n    private int dfs(int i)\\n    {\\n        if(vis.contains(i))\\n            return 0;\\n        vis.add(i);\\n        if(dp[i] != 0)\\n            return dp[i];\\n        dp[i] = 1 + dfs(arr[i]);\\n        return dp[i];\\n    }\\n    private int[] arr, dp;\\n    private Set<Integer> vis;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451656,
                "title": "javascript-easy-to-understand-loop-recursion",
                "content": "The strategy is straight forward. We just follow the rules and check length for every start value. Then we get the result.\\nWe could modify the flag in `visited` to avoid re-calculate for the set we met.\\n\\nHere\\'s the code based on looping:\\n\\n```js\\nconst arrayNesting = (nums) => {\\n  const visited = new Uint8Array(nums.length);\\n  let max = 0;\\n  for (const num of nums) {\\n    let cur = num;\\n    let len = 0;\\n    while (!visited[cur]) {\\n      visited[cur] = 1;\\n      ++len;\\n      cur = nums[cur];\\n    }\\n    max = Math.max(max, len);\\n  }\\n  return max;\\n};\\n```\\n\\nHere\\'s the code based on recursion:\\n\\n```js\\nconst findPath = (nums, visited, cur, len = 0) => {\\n  if (visited[cur]) return len;\\n  visited[cur] = 1;\\n  return findPath(nums, visited, nums[cur], len + 1);\\n};\\n\\nconst arrayNesting = (nums) => {\\n  const visited = new Uint8Array(nums.length);\\n  let max = 0;\\n  for (const num of nums) {\\n    max = Math.max(max, findPath(nums, visited, num));\\n  }\\n  return max;\\n};\\n```\\n\\nAnd, we could even implement it in only 2 lines via `reduce`:\\n\\n```js\\nconst findPath = (nums, visited, cur, len = 0) => visited[cur] ? len : (visited[cur] = 1, findPath(nums, visited, nums[cur], len + 1));\\nconst arrayNesting = (nums, visited = new Uint8Array(nums.length)) => nums.reduce((max, num) => Math.max(max, findPath(nums, visited, num)), 0);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst arrayNesting = (nums) => {\\n  const visited = new Uint8Array(nums.length);\\n  let max = 0;\\n  for (const num of nums) {\\n    let cur = num;\\n    let len = 0;\\n    while (!visited[cur]) {\\n      visited[cur] = 1;\\n      ++len;\\n      cur = nums[cur];\\n    }\\n    max = Math.max(max, len);\\n  }\\n  return max;\\n};\\n```\n```js\\nconst findPath = (nums, visited, cur, len = 0) => {\\n  if (visited[cur]) return len;\\n  visited[cur] = 1;\\n  return findPath(nums, visited, nums[cur], len + 1);\\n};\\n\\nconst arrayNesting = (nums) => {\\n  const visited = new Uint8Array(nums.length);\\n  let max = 0;\\n  for (const num of nums) {\\n    max = Math.max(max, findPath(nums, visited, num));\\n  }\\n  return max;\\n};\\n```\n```js\\nconst findPath = (nums, visited, cur, len = 0) => visited[cur] ? len : (visited[cur] = 1, findPath(nums, visited, nums[cur], len + 1));\\nconst arrayNesting = (nums, visited = new Uint8Array(nums.length)) => nums.reduce((max, num) => Math.max(max, findPath(nums, visited, num)), 0);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1451604,
                "title": "python-what-s-worng-with-the-solution-its-working-for-0-1-2-not-for-0-2-1",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        s=[]\\n        i=0\\n        while i!=None:\\n            i=nums[i]\\n            if i not in s:\\n                s.append(i)\\n            else:\\n                break\\n        return len(set(s))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        s=[]\\n        i=0\\n        while i!=None:\\n            i=nums[i]\\n            if i not in s:\\n                s.append(i)\\n            else:\\n                break\\n        return len(set(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446514,
                "title": "simple-solution-without-the-need-to-mark-completed",
                "content": "Simply keep swapping the current value with it\\'s correct position until the array is in order:\\n\\n```\\nans = 1\\nfor i in range(len(nums)):\\n    cnt = 1\\n    while nums[i] != i:\\n        nums[nums[i]], nums[i] = nums[i], nums[nums[i]]\\n        cnt += 1\\n    ans = max(ans, cnt)\\n```\\n\\n[5, 4, 0, 3, 1, 6, 2]\\n[6, 4, 0, 3, 1, 5, 2]\\n[2, 4, 0, 3, 1, 5, 6]\\n[0, 4, 2, 3, 1, 5, 6]\\n[0, 1, 2, 3, 4, 5, 6]",
                "solutionTags": [],
                "code": "```\\nans = 1\\nfor i in range(len(nums)):\\n    cnt = 1\\n    while nums[i] != i:\\n        nums[nums[i]], nums[i] = nums[i], nums[nums[i]]\\n        cnt += 1\\n    ans = max(ans, cnt)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444754,
                "title": "c-dfs-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dfs(vector<int> &nums,vector<bool> &vis,int idx){\\n\\n\\t\\t\\tif(vis[idx] == false){\\n\\t\\t\\t\\tvis[idx] = true;\\n\\t\\t\\t\\treturn 1 + dfs(nums,vis,nums[idx]);\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint arrayNesting(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<bool> vis(n,false);\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint mx = INT_MIN;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tif(vis[i] == false){\\n\\t\\t\\t\\t   mx = max(mx,dfs(nums,vis,i));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn mx;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dfs(vector<int> &nums,vector<bool> &vis,int idx){\\n\\n\\t\\t\\tif(vis[idx] == false){\\n\\t\\t\\t\\tvis[idx] = true;\\n\\t\\t\\t\\treturn 1 + dfs(nums,vis,nums[idx]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1440345,
                "title": "javascript-recursion-approach-but-failed-at-speed",
                "content": "```\\nvar arrayNesting = function(nums) {\\n    let len = nums.length\\n    let i = 0\\n    let maxLength = 0\\n    while (i < len) {\\n        var setArr = []\\n        \\n        const recursionBaby = n => {\\n            if(setArr.indexOf(nums[n]) == -1) {\\n                setArr.push(nums[n])\\n                recursionBaby(nums[n])   \\n            }\\n        }\\n\\n        recursionBaby(i)\\n\\n        if(setArr.length > maxLength) {\\n            maxLength = setArr.length\\n        }\\n\\n        i++\\n    }\\n\\n\\n    return maxLength\\n}\\n```\\n\\nhow could i make it faster?",
                "solutionTags": [],
                "code": "```\\nvar arrayNesting = function(nums) {\\n    let len = nums.length\\n    let i = 0\\n    let maxLength = 0\\n    while (i < len) {\\n        var setArr = []\\n        \\n        const recursionBaby = n => {\\n            if(setArr.indexOf(nums[n]) == -1) {\\n                setArr.push(nums[n])\\n                recursionBaby(nums[n])   \\n            }\\n        }\\n\\n        recursionBaby(i)\\n\\n        if(setArr.length > maxLength) {\\n            maxLength = setArr.length\\n        }\\n\\n        i++\\n    }\\n\\n\\n    return maxLength\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440308,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int arrayNesting(vector<int>& nums) \\n    {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                int start = nums[i];\\n                int cnt = 0;\\n                while(nums[start]!=-1)\\n                {\\n                    int temp=start;\\n                    start=nums[start];\\n                    cnt++;\\n                    nums[temp]=-1;\\n                }\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int arrayNesting(vector<int>& nums) \\n    {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                int start = nums[i];\\n                int cnt = 0;\\n                while(nums[start]!=-1)\\n                {\\n                    int temp=start;\\n                    start=nums[start];\\n                    cnt++;\\n                    nums[temp]=-1;\\n                }\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440074,
                "title": "short-simple-ruby",
                "content": "```\\ndef array_nesting(nums)\\n  seen_nums = Hash.new\\n  result = 0\\n  (0 ... nums.length).each do |i|\\n\\n    count = 0\\n    n = nums[i]\\n    while !seen_nums[n]\\n      seen_nums[n] = 1\\n      count += 1\\n      n = nums[n]\\n    end\\n    result = [result, count].max\\n  end\\n  result\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef array_nesting(nums)\\n  seen_nums = Hash.new\\n  result = 0\\n  (0 ... nums.length).each do |i|\\n\\n    count = 0\\n    n = nums[i]\\n    while !seen_nums[n]\\n      seen_nums[n] = 1\\n      count += 1\\n      n = nums[n]\\n    end\\n    result = [result, count].max\\n  end\\n  result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1439661,
                "title": "java-check-cyclic-o-n-time-o-1-space",
                "content": "The problem we can think about both unique and non-unique.\\nIf elements is unique in array we can just simply modify the array to check if we already visited or not.\\n```\\n    public int arrayNesting(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i< nums.length; i++) {\\n            result = Math.max(result, dfs(nums, i));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int dfs(int[] nums, int currentIndex) {\\n        if(nums[currentIndex] < 0) return 0;\\n        int nextIndex = nums[currentIndex];\\n        nums[currentIndex] = -1;\\n        return dfs(nums, nextIndex) + 1;\\n    }\\n```\\n\\nIn non-unique case we can use another array to record the step we already visited last time.\\n```\\n    public int arrayNesting(int[] nums) {\\n        \\n        int[] dp = new int[nums.length];\\n        \\n        int result = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            result = Math.max(result, dfs(nums, i, dp));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int dfs(int[] nums, int currentIndex, int[] dp) {\\n        if(dp[currentIndex] < 0) return 0;\\n        \\n        if(dp[currentIndex] > 0) return dp[currentIndex];\\n        \\n        dp[currentIndex] = -1;\\n        int result = 1 + dfs(nums, nums[currentIndex], dp);\\n        dp[currentIndex] = result;\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int arrayNesting(int[] nums) {\\n        int result = 0;\\n        for(int i = 0; i< nums.length; i++) {\\n            result = Math.max(result, dfs(nums, i));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int dfs(int[] nums, int currentIndex) {\\n        if(nums[currentIndex] < 0) return 0;\\n        int nextIndex = nums[currentIndex];\\n        nums[currentIndex] = -1;\\n        return dfs(nums, nextIndex) + 1;\\n    }\\n```\n```\\n    public int arrayNesting(int[] nums) {\\n        \\n        int[] dp = new int[nums.length];\\n        \\n        int result = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            result = Math.max(result, dfs(nums, i, dp));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int dfs(int[] nums, int currentIndex, int[] dp) {\\n        if(dp[currentIndex] < 0) return 0;\\n        \\n        if(dp[currentIndex] > 0) return dp[currentIndex];\\n        \\n        dp[currentIndex] = -1;\\n        int result = 1 + dfs(nums, nums[currentIndex], dp);\\n        dp[currentIndex] = result;\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439490,
                "title": "java-solution-using-union-find-with-path-compression-and-union-by-size",
                "content": "In this solution, `int[] root` is also used for managing the number of descendants by initializing it by `-1`.\\nWhen `root[i]` is a negative value, then it represents that `i` is the root of the tree and also that it has `-root[i]` descendants. For example, `root[i] == -2` means that it has two descendants including the root node itself.\\n\\nWhen you unite two trees, you can simply add the value of a root node to the another before updating the pointer as usual.\\nImagine a following case: If you unite `root[i] == -1` and `root[j] == -1` then you update `root[i]` to `(-1) + (-1) = -2` and then set `root[j]` to `i`. This exactly representing that `i` has two descendants and `j` is its child node.\\n\\n```\\nclass Solution {\\n    class UnionFind {\\n        private int[] root;\\n        \\n        public UnionFind(int n) {\\n            root = new int[n];\\n            Arrays.fill(root, -1);\\n        }\\n        \\n        public int find(int x) {\\n            if(root[x] < 0) {\\n                return x;\\n            }\\n            \\n            // path compression\\n            return root[x] = find(root[x]);\\n        }\\n        \\n        public void unite(int x, int y) {\\n            x = find(x);\\n            y = find(y);\\n            \\n            if(x == y) {\\n                return;\\n            }\\n            \\n            // Union by size\\n            if(size(x) < size(y)) {\\n                root[y] += root[x];\\n                root[x] = y;\\n            } else {\\n                root[x] += root[y];\\n                root[y] = x;\\n            }\\n        }\\n        \\n        public int size(int x) {\\n            return -root[find(x)];\\n        }\\n    }\\n    \\n    \\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        UnionFind uf = new UnionFind(n);\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            uf.unite(i, nums[i]);\\n            ans = Math.max(ans, uf.size(i));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        private int[] root;\\n        \\n        public UnionFind(int n) {\\n            root = new int[n];\\n            Arrays.fill(root, -1);\\n        }\\n        \\n        public int find(int x) {\\n            if(root[x] < 0) {\\n                return x;\\n            }\\n            \\n            // path compression\\n            return root[x] = find(root[x]);\\n        }\\n        \\n        public void unite(int x, int y) {\\n            x = find(x);\\n            y = find(y);\\n            \\n            if(x == y) {\\n                return;\\n            }\\n            \\n            // Union by size\\n            if(size(x) < size(y)) {\\n                root[y] += root[x];\\n                root[x] = y;\\n            } else {\\n                root[x] += root[y];\\n                root[y] = x;\\n            }\\n        }\\n        \\n        public int size(int x) {\\n            return -root[find(x)];\\n        }\\n    }\\n    \\n    \\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        UnionFind uf = new UnionFind(n);\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            uf.unite(i, nums[i]);\\n            ans = Math.max(ans, uf.size(i));\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439268,
                "title": "a-few-solutions",
                "content": "Each candidate path is a cycle.  Traverse each uniquely `seen` cycle and return the maximum length as the `best` answer.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun arrayNesting(A: IntArray): Int {\\n        var best = 0\\n        var seen = mutableSetOf<Int>()\\n        for (i in 0 until A.size) {\\n            var (cand, j) = listOf(0, i)\\n            while (!seen.contains(j)) {\\n                seen.add(j); j = A[j]; ++cand\\n            }\\n            best = Math.max(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet arrayNesting = (A, seen = new Set(), best = 0) => {\\n    for (let i = 0; i < A.length; ++i) {\\n        let [cand, j] = [0, i];\\n        while (!seen.has(j))\\n            ++cand, seen.add(j), j = A[j];\\n        best = Math.max(best, cand);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def arrayNesting(self, A: List[int], best = 0) -> int:\\n        seen = set()\\n        for i in range(len(A)):\\n            cand, j = 0, i\\n            while j not in seen:\\n                cand += 1; seen.add(j); j = A[j]\\n            best = max(best, cand)\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    int arrayNesting(VI& A, Set seen = {}, int best = 0) {\\n        for (auto i{ 0 }; i < A.size(); ++i) {\\n            auto [cand, j] = make_pair(0, i);\\n            while (seen.insert(j).second)\\n                ++cand, j = A[j];\\n            best = max(best, cand);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun arrayNesting(A: IntArray): Int {\\n        var best = 0\\n        var seen = mutableSetOf<Int>()\\n        for (i in 0 until A.size) {\\n            var (cand, j) = listOf(0, i)\\n            while (!seen.contains(j)) {\\n                seen.add(j); j = A[j]; ++cand\\n            }\\n            best = Math.max(best, cand)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet arrayNesting = (A, seen = new Set(), best = 0) => {\\n    for (let i = 0; i < A.length; ++i) {\\n        let [cand, j] = [0, i];\\n        while (!seen.has(j))\\n            ++cand, seen.add(j), j = A[j];\\n        best = Math.max(best, cand);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def arrayNesting(self, A: List[int], best = 0) -> int:\\n        seen = set()\\n        for i in range(len(A)):\\n            cand, j = 0, i\\n            while j not in seen:\\n                cand += 1; seen.add(j); j = A[j]\\n            best = max(best, cand)\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<int>;\\n    int arrayNesting(VI& A, Set seen = {}, int best = 0) {\\n        for (auto i{ 0 }; i < A.size(); ++i) {\\n            auto [cand, j] = make_pair(0, i);\\n            while (seen.insert(j).second)\\n                ++cand, j = A[j];\\n            best = max(best, cand);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439248,
                "title": "easy-java-solution-naive-to-optimized-o-n-soln",
                "content": "```\\n\\n//naive approach\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max = 0;\\n        \\n        for(int i : nums) {\\n            max = Math.max(max, find(nums,i));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    \\n    public int find(int[] nums, int i) {\\n        int count = 0;\\n        boolean[] flag = new boolean[nums.length];\\n        \\n        while (!flag[i]) {\\n            count++;\\n            flag[i] = true;\\n            i = nums[i];\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n//optimized approach finding cycle length as elements are unique so only one entry and exit\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int count = 0;\\n        int max = 0;\\n        \\n        boolean[] flag = new boolean[nums.length];\\n        \\n        for (int i : nums) {\\n            count = 0;\\n            \\n            while (!flag[i]) {\\n                flag[i] =true;\\n                i = nums[i];\\n                count++;\\n            }\\n            \\n            max = Math.max(max, count);\\n            \\n            if (max > nums.length/2) return max;\\n            \\n        }\\n        \\n        return max;\\n    }\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int arrayNesting(int[] nums) {\\n        int max = 0;\\n        \\n        for(int i : nums) {\\n            max = Math.max(max, find(nums,i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1439193,
                "title": "dynamic-programming-java",
                "content": "class Solution {\\n   \\n    public int arrayNesting(int[] nums) {\\n         int[] dp = new int[nums.length];\\n        int maxLen = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            HashSet<Integer> set = new HashSet<>();\\n          maxLen = Math.max(maxLen,dp(nums,i,dp,0,set));\\n        }\\n        return maxLen;\\n    }\\n    public int dp(int[] nums,int index, int[] dp,int curLen, HashSet<Integer> set){\\n        if(!set.contains(nums[index])){\\n         \\n            set.add(nums[index]);\\n            \\n        if(dp[index]!=0)\\n            return dp[index];\\n        \\n        curLen = dp(nums,nums[index],dp,curLen+1,set);\\n        dp[nums[index]]=curLen;\\n        }\\n        return curLen;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    public int arrayNesting(int[] nums) {\\n         int[] dp = new int[nums.length];\\n        int maxLen = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            HashSet<Integer> set = new HashSet<>();\\n          maxLen = Math.max(maxLen,dp(nums,i,dp,0,set));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1439077,
                "title": "simple-c-solution-using-visited-array-extra-space",
                "content": "Plz upvote if you like -\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool vis[100005];\\n\\t\\tint arrayNesting(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tmemset(vis,false,sizeof vis);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t\\twhile(vis[nums[i]] == false)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvis[nums[i]] = true;\\n\\t\\t\\t\\t\\t\\tnums[i]= nums[nums[i]]; // updating\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans,count);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool vis[100005];\\n\\t\\tint arrayNesting(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint ans = INT_MIN;\\n\\t\\t\\tmemset(vis,false,sizeof vis);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t\\twhile(vis[nums[i]] == false)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvis[nums[i]] = true;\\n\\t\\t\\t\\t\\t\\tnums[i]= nums[nums[i]]; // updating\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1438994,
                "title": "c-python-scala-straight-dfs",
                "content": "**C++ Solution:-**\\n```\\nclass Solution {\\n    \\n    int solve(vector<int>&nums,int i,vector<bool>& vis)\\n    {\\n        int ans=1;\\n        vis[i]=true;\\n        if(!vis[nums[i]])\\n            ans+=solve(nums,nums[i],vis);\\n        return ans;    \\n    }\\n    \\n    \\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool>vis(n,false);\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                maxi=max(maxi,solve(nums,i,vis));\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n**Python Solution:-**\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        vis=[False]*len(nums)\\n        def solve(i):\\n            ans=1\\n            vis[i]=True\\n            if vis[nums[i]]==False:\\n                ans+=solve(nums[i])\\n            return ans\\n        maxi=1\\n        for i in range(len(nums)):\\n            if vis[i]==False:\\n                maxi=max(maxi,solve(i))\\n        return maxi   \\n```\\n\\n**Scala Solution:-**\\n```\\nobject Solution {\\n    def arrayNesting(nums: Array[Int]): Int = {\\n        val n=nums.length\\n        val vis=new Array[Boolean](n)\\n        def solve(i:Int):Int={\\n            var ans=1\\n            vis(i)=true\\n            if(!vis(nums(i)))\\n            ans+=solve(nums(i))\\n            ans\\n        }\\n        var maxi=1;\\n        for(i <- 0 until n)\\n        maxi=maxi max solve(i)\\n        maxi\\n    }\\n}\\n```\\n\\n*If you liked the Solution. Do UPVOTE it!!!!!!*",
                "solutionTags": [
                    "Python",
                    "C",
                    "Scala",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int solve(vector<int>&nums,int i,vector<bool>& vis)\\n    {\\n        int ans=1;\\n        vis[i]=true;\\n        if(!vis[nums[i]])\\n            ans+=solve(nums,nums[i],vis);\\n        return ans;    \\n    }\\n    \\n    \\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool>vis(n,false);\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n                maxi=max(maxi,solve(nums,i,vis));\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        vis=[False]*len(nums)\\n        def solve(i):\\n            ans=1\\n            vis[i]=True\\n            if vis[nums[i]]==False:\\n                ans+=solve(nums[i])\\n            return ans\\n        maxi=1\\n        for i in range(len(nums)):\\n            if vis[i]==False:\\n                maxi=max(maxi,solve(i))\\n        return maxi   \\n```\n```\\nobject Solution {\\n    def arrayNesting(nums: Array[Int]): Int = {\\n        val n=nums.length\\n        val vis=new Array[Boolean](n)\\n        def solve(i:Int):Int={\\n            var ans=1\\n            vis(i)=true\\n            if(!vis(nums(i)))\\n            ans+=solve(nums(i))\\n            ans\\n        }\\n        var maxi=1;\\n        for(i <- 0 until n)\\n        maxi=maxi max solve(i)\\n        maxi\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438980,
                "title": "c",
                "content": "```\\nint arrayNesting(vector<int>& a) {\\n        int n = a.size(), ans = INT_MIN;\\n        vector<int> v(n,0);\\n        for(int i: a) {\\n            int count = 0;\\n            while(!v[i]) {\\n               v[i] = true;\\n               i = a[i];\\n               count++;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint arrayNesting(vector<int>& a) {\\n        int n = a.size(), ans = INT_MIN;\\n        vector<int> v(n,0);\\n        for(int i: a) {\\n            int count = 0;\\n            while(!v[i]) {\\n               v[i] = true;\\n               i = a[i];\\n               count++;\\n            }\\n            ans = max(ans, count);\\n        }\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438863,
                "title": "c-2-method-brute-dp-clean-code-explanation",
                "content": "# Method 1: Brute Force (Faster ironically)\\nWe will iterate through the array looking for **longest cycle** that we can have by **keeping a check of visited elements** using a bool array.\\nfor ex- \\nArray : [ 5 , 4 , 0 , 3 , 1 , 6 , 2 ]\\nIndex:    0   1   2  3   4   5   6\\nYou can see if we start** iterating from left** we get cycles , we just have to keep track of **count of longest cycle** and visited elements we will **stop a cycle if a[i]** is any **already visited** element\\n0-->5-->6-->2-->**X** ( mark 0, 5 6 2 visited )\\n1-->4-->**X**\\n3-->**X**\\n\\nAs we can see 1st iteration give us maximum answer i.e. 4\\n\\n# Code: \\n\\n    int arrayNesting(vector<int>& a) {\\n        int ans=0,count,n=a.size(),x;\\n        vector<bool> visited(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            count=0;\\n            x=i;\\n            while(!visited[x])\\n            {\\n                visited[x]=true;\\n                x=a[x];\\n                count++;\\n            }\\n                \\n            ans=max(ans,count); \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n Here\\'s the link for 2nd approach:\\n https://leetcode.com/explore/challenge/card/september-leetcoding-challenge-2021/636/week-1-september-1st-september-7th/3960/discuss/1438915/C++-2-method-Brute-DP-Clean-code-+-explanation",
                "solutionTags": [],
                "code": "# Method 1: Brute Force (Faster ironically)\\nWe will iterate through the array looking for **longest cycle** that we can have by **keeping a check of visited elements** using a bool array.\\nfor ex- \\nArray : [ 5 , 4 , 0 , 3 , 1 , 6 , 2 ]\\nIndex:    0   1   2  3   4   5   6\\nYou can see if we start** iterating from left** we get cycles , we just have to keep track of **count of longest cycle** and visited elements we will **stop a cycle if a[i]** is any **already visited** element\\n0-->5-->6-->2-->**X** ( mark 0, 5 6 2 visited )\\n1-->4-->**X**\\n3-->**X**\\n\\nAs we can see 1st iteration give us maximum answer i.e. 4\\n\\n# Code: \\n\\n    int arrayNesting(vector<int>& a) {\\n        int ans=0,count,n=a.size(),x;\\n        vector<bool> visited(n,false);\\n        for(int i=0;i<n;i++)\\n        {\\n            count=0;\\n            x=i;\\n            while(!visited[x])\\n            {\\n                visited[x]=true;\\n                x=a[x];\\n                count++;\\n            }\\n                \\n            ans=max(ans,count); \\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n Here\\'s the link for 2nd approach:\\n https://leetcode.com/explore/challenge/card/september-leetcoding-challenge-2021/636/week-1-september-1st-september-7th/3960/discuss/1438915/C++-2-method-Brute-DP-Clean-code-+-explanation",
                "codeTag": "Unknown"
            },
            {
                "id": 1438824,
                "title": "c-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=-1){\\n                int start = nums[i];\\n                int cnt = 0;\\n                while(nums[start]!=-1){\\n                    int temp=start;\\n                    start=nums[start];\\n                    cnt++;\\n                    nums[temp]=-1;\\n                }\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=-1){\\n                int start = nums[i];\\n                int cnt = 0;\\n                while(nums[start]!=-1){\\n                    int temp=start;\\n                    start=nums[start];\\n                    cnt++;\\n                    nums[temp]=-1;\\n                }\\n                ans=max(ans,cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438722,
                "title": "python-solution-explained-array-nesting",
                "content": "Explaination:\\n        given :  unique array of nums\\n        return : length of longest set.\\n        problem: \\n        \\n        indx 0 1 2 3 4 5 6\\n        eg : 5 4 0 3 1 6 2\\n \\n        index choosen = 0\\n        nums[0] = 5,nums[5] = 6,nums[6] = 2 nums[2]= 0 nums[0]=5\\u274C  \\n        length = 4\\n        \\n        index choosen = 1\\n        nums[1] = 4,nums[4] = 1,nums[1]=4\\u274C\\n        length=2\\n        \\n        index choosen = 2\\n        nums[2]=0,nums[0]=5,nums[5]=6,nums[6]=2,nums[2]=0\\n        length=4\\n        \\n        index choosen = 3\\n        nums[3] = 3\\n\\t\\tby observing we can note that cycles are being fromed so we can have an array to just track if this index is visited earlier \\n\\t\\tor not .If it is visited earlier it means it was part of some cycle and there is no point in choosing it now because we will end up        in the same loop (you can see the example when index choosen is=0 and index choosen=2)\\nCode:\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:   \\n        i = 0\\n        max_count = 0\\n        check = [False] * (len(nums))\\n        while i< len(nums):\\n            if check[i] == False:\\n                temp_set = set()\\n                while i not in temp_set:\\n                    temp_set.add(i)\\n                    check[i] = True\\n                    i = nums[i]\\n                max_count = max(max_count,len(temp_set))\\n            i += 1\\n        return max_count\\n```\\nT.C : O(n)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:   \\n        i = 0\\n        max_count = 0\\n        check = [False] * (len(nums))\\n        while i< len(nums):\\n            if check[i] == False:\\n                temp_set = set()\\n                while i not in temp_set:\\n                    temp_set.add(i)\\n                    check[i] = True\\n                    i = nums[i]\\n                max_count = max(max_count,len(temp_set))\\n            i += 1\\n        return max_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438703,
                "title": "c-dfs-solution",
                "content": "Runtime: 22 ms, faster than 45.01% of C++ online submissions for Array Nesting.\\nMemory Usage: 30.8 MB, less than 26.21% of C++ online submissions for Array Nesting.\\n\\n`We have to find the longest cycle length in the array which can do easily using DFS.`\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<int>& nums, int index)\\n    {\\n        if(index==-1)return -1;\\n        \\n        int val = nums[index];\\n        nums[index]=-1;\\n        \\n        return dfs(nums,val) + 1;        \\n    }\\n    \\n    int arrayNesting(vector<int>& nums) {\\n     \\n        int maxLen = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)continue;\\n            \\n            maxLen = max(maxLen,dfs(nums,i));\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(vector<int>& nums, int index)\\n    {\\n        if(index==-1)return -1;\\n        \\n        int val = nums[index];\\n        nums[index]=-1;\\n        \\n        return dfs(nums,val) + 1;        \\n    }\\n    \\n    int arrayNesting(vector<int>& nums) {\\n     \\n        int maxLen = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0)continue;\\n            \\n            maxLen = max(maxLen,dfs(nums,i));\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438693,
                "title": "java-easy-length-of-longest-cycle",
                "content": "```\\nclass Solution {\\n     static class Pair{\\n         int val;\\n         int idx;\\n       \\n         Pair(int val,int idx){\\n           this.val = val;\\n           this.idx = idx;\\n         }\\n     }\\n    public int arrayNesting(int[] arr) {\\n        //This question is nothing but finding the length of longest cycle\\n        int n = arr.length;\\n        Pair p[] = new Pair[n];\\n      \\n        for(int i = 0; i < n ;i++){\\n           p[i] = new Pair(arr[i],i);\\n        }\\n      \\n        Arrays.sort(p,(a,b)->{\\n          return a.val - b.val;\\n        });\\n      \\n        boolean visited[] = new boolean[n];\\n        int maxLenCycle = 1;\\n      \\n        for(int i = 0 ; i <  n ; i++){\\n           if(visited[i] == true || p[i].idx == i){\\n             continue;\\n           }\\n          int len = 0;\\n          int j = i;\\n          \\n          while(visited[j] == false){\\n             visited[j] = true;\\n             len++;\\n             j = p[j].idx;\\n          }\\n          maxLenCycle = Math.max(len,maxLenCycle);\\n        }\\n      return maxLenCycle;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     static class Pair{\\n         int val;\\n         int idx;\\n       \\n         Pair(int val,int idx){\\n           this.val = val;\\n           this.idx = idx;\\n         }\\n     }\\n    public int arrayNesting(int[] arr) {\\n        //This question is nothing but finding the length of longest cycle\\n        int n = arr.length;\\n        Pair p[] = new Pair[n];\\n      \\n        for(int i = 0; i < n ;i++){\\n           p[i] = new Pair(arr[i],i);\\n        }\\n      \\n        Arrays.sort(p,(a,b)->{\\n          return a.val - b.val;\\n        });\\n      \\n        boolean visited[] = new boolean[n];\\n        int maxLenCycle = 1;\\n      \\n        for(int i = 0 ; i <  n ; i++){\\n           if(visited[i] == true || p[i].idx == i){\\n             continue;\\n           }\\n          int len = 0;\\n          int j = i;\\n          \\n          while(visited[j] == false){\\n             visited[j] = true;\\n             len++;\\n             j = p[j].idx;\\n          }\\n          maxLenCycle = Math.max(len,maxLenCycle);\\n        }\\n      return maxLenCycle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438675,
                "title": "python3-solution-explained-with-comments",
                "content": "\\'\\'\\'\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        # you can use set to mark the element where you\\'ve been before but instead of extra memory you can just give the value of -1 to every element you\\'ve visited\\n        # then you just check if the current element is different from -1, if so you have to iterate in order to create a new path \\n        # mark with -1 since the all elements are positive \\n\\t\\t#if you like it, please upvote! ^^\\n        \\n        count_max = 0\\n        for i in range(len(nums)):\\n            if nums[i] != -1: #if it\\'s not visited \\n                count = 0\\n                j = i\\n                while nums[j] != -1:\\n                    t = j\\n                    j = nums[j]\\n                    count += 1\\n                    nums[t] = -1 # marking\\n                if count > count_max:\\n                    count_max = count\\n        return count_max\\n    \\n```\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        # you can use set to mark the element where you\\'ve been before but instead of extra memory you can just give the value of -1 to every element you\\'ve visited\\n        # then you just check if the current element is different from -1, if so you have to iterate in order to create a new path \\n        # mark with -1 since the all elements are positive \\n\\t\\t#if you like it, please upvote! ^^\\n        \\n        count_max = 0\\n        for i in range(len(nums)):\\n            if nums[i] != -1: #if it\\'s not visited \\n                count = 0\\n                j = i\\n                while nums[j] != -1:\\n                    t = j\\n                    j = nums[j]\\n                    count += 1\\n                    nums[t] = -1 # marking\\n                if count > count_max:\\n                    count_max = count\\n        return count_max\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438613,
                "title": "python3-clean-concise-o-n-tc-and-o-1-sc",
                "content": "If you closely look at every possible soltuion we can find that, same numbers are present in every solution. By this we can sum up that we don\\'t need to go down the same path again and again. Instead of maintaining a seperate visited list, we can mark the items in the same list and continue the algorithm.\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        ans = 1\\n        \\n        for i in range(N):\\n            curLen = 0\\n            while nums[i]!= float(inf):\\n                temp = i\\n                curLen+=1\\n                i = nums[i]\\n                nums[temp] = float(inf)\\n\\n            ans = max(ans,curLen)\\n        \\n        return ans\\n            \\n\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        ans = 1\\n        \\n        for i in range(N):\\n            curLen = 0\\n            while nums[i]!= float(inf):\\n                temp = i\\n                curLen+=1\\n                i = nums[i]\\n                nums[temp] = float(inf)\\n\\n            ans = max(ans,curLen)\\n        \\n        return ans\\n            \\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438606,
                "title": "java-self-documented-code-descriptive-variable-names-easy-to-understand",
                "content": "Not the best solution since this can be done using O(1) space but this solution is definitely easy and intuitive to understand.\\n\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        HashSet<Integer> visitedNumbers = new HashSet<Integer>();\\n        int count;\\n        int maxCount = 0;\\n        int currentNumber;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            currentNumber = nums[i];\\n            count = 0;\\n            while(true){\\n                if(visitedNumbers.contains(currentNumber)) \\n                    break;\\n                else {\\n                    visitedNumbers.add(currentNumber);\\n                    currentNumber = nums[currentNumber];\\n                    count++;\\n                }\\n            }\\n            maxCount = Math.max(count, maxCount);\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        HashSet<Integer> visitedNumbers = new HashSet<Integer>();\\n        int count;\\n        int maxCount = 0;\\n        int currentNumber;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            currentNumber = nums[i];\\n            count = 0;\\n            while(true){\\n                if(visitedNumbers.contains(currentNumber)) \\n                    break;\\n                else {\\n                    visitedNumbers.add(currentNumber);\\n                    currentNumber = nums[currentNumber];\\n                    count++;\\n                }\\n            }\\n            maxCount = Math.max(count, maxCount);\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438516,
                "title": "kotlin-clean-and-simple-solution",
                "content": "```\\nclass Solution {\\n    fun arrayNesting(nums: IntArray): Int {\\n        val grouped = BooleanArray(nums.size)\\n        var maxGroupSize = 0\\n        \\n        nums.forEachIndexed { index, num ->\\n            if (!grouped[index]) {\\n                grouped[index] = true\\n                var currentGroupSize = 1\\n                var nextIndex = num\\n                while (!grouped[nextIndex]) {\\n                    ++currentGroupSize\\n                    grouped[nextIndex] = true\\n                    nextIndex = nums[nextIndex]\\n                }\\n                maxGroupSize = maxOf(maxGroupSize, currentGroupSize)\\n            }\\n        }\\n        \\n        return maxGroupSize\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun arrayNesting(nums: IntArray): Int {\\n        val grouped = BooleanArray(nums.size)\\n        var maxGroupSize = 0\\n        \\n        nums.forEachIndexed { index, num ->\\n            if (!grouped[index]) {\\n                grouped[index] = true\\n                var currentGroupSize = 1\\n                var nextIndex = num\\n                while (!grouped[nextIndex]) {\\n                    ++currentGroupSize\\n                    grouped[nextIndex] = true\\n                    nextIndex = nums[nextIndex]\\n                }\\n                maxGroupSize = maxOf(maxGroupSize, currentGroupSize)\\n            }\\n        }\\n        \\n        return maxGroupSize\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438498,
                "title": "java-solution-would-like-to-know-your-thoughts-on-it",
                "content": "I usually post solutions in the discussion when I\\'m sure that I found something interesting. This time howerver, I used an approach that seems bizzare compared to other solutions in the discussion and I would like to know your thoughts on it. Note that I tried it without the dp and it became too slow (Time limit exceeded).\\n\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        Integer[] dp = new Integer[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> visited = new HashSet<> ();\\n            max = Math.max(max, findLongest(nums, i, dp, visited));\\n        }\\n        return max;\\n    }\\n    \\n    public int findLongest(int[] nums, int index, Integer[] dp, HashSet<Integer> visited) {\\n        if (dp[index] != null) return dp[index];\\n        if (visited.contains(index)) {\\n            return 0;\\n        } else {\\n            visited.add(index);\\n            dp[index] = 1 + findLongest(nums, nums[index], dp, visited);\\n            return dp[index];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        Integer[] dp = new Integer[n];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            HashSet<Integer> visited = new HashSet<> ();\\n            max = Math.max(max, findLongest(nums, i, dp, visited));\\n        }\\n        return max;\\n    }\\n    \\n    public int findLongest(int[] nums, int index, Integer[] dp, HashSet<Integer> visited) {\\n        if (dp[index] != null) return dp[index];\\n        if (visited.contains(index)) {\\n            return 0;\\n        } else {\\n            visited.add(index);\\n            dp[index] = 1 + findLongest(nums, nums[index], dp, visited);\\n            return dp[index];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438464,
                "title": "c-dfs-dp",
                "content": "```\\n class Solution {\\npublic:\\n    int dp[100001];\\n    int solve(int k,vector<bool>& vis, vector<int>& nums)\\n    {\\n        if(vis[k])\\n            return 0;\\n        vis[k]=true;\\n        if(dp[k]!=-1) return dp[k];\\n        return dp[k] = 1 + solve(nums[k],vis,nums);\\n    }\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;++i)\\n        {\\n            if(dp[i]==-1){\\n            vector<bool>vis(n,false);\\n            ans=max(ans,solve(i,vis,nums));   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int dp[100001];\\n    int solve(int k,vector<bool>& vis, vector<int>& nums)\\n    {\\n        if(vis[k])\\n            return 0;\\n        vis[k]=true;\\n        if(dp[k]!=-1) return dp[k];\\n        return dp[k] = 1 + solve(nums[k],vis,nums);\\n    }\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<n;++i)\\n        {\\n            if(dp[i]==-1){\\n            vector<bool>vis(n,false);\\n            ans=max(ans,solve(i,vis,nums));   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438459,
                "title": "c-solution-dfs-memo",
                "content": "The Idea is that, an index can only lead to one path, so we can use an array to store the value.\\n```\\nint arrayNesting(vector<int>& nums) {\\n       int n = nums.size(),ans = 0;\\n        vector<bool>visited(n,false);\\n        vector<int>dp(n,-1);\\n        for(int i=0;i<n;i++)\\n            ans = max(ans,dfs(nums,i,visited,dp));\\n        return ans;\\n    }\\n    int dfs(vector<int>&nums,int n, vector<bool>& visited, vector<int>&dp)\\n    {\\n        if(visited[n]) return 0;\\n        if(dp[n] != -1) return dp[n];\\n        visited[n] = true;\\n        dp[n] = 1 + dfs(nums,nums[n],visited,dp);\\n        visited[n] = false;\\n        return dp[n];\\n    }\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nint arrayNesting(vector<int>& nums) {\\n       int n = nums.size(),ans = 0;\\n        vector<bool>visited(n,false);\\n        vector<int>dp(n,-1);\\n        for(int i=0;i<n;i++)\\n            ans = max(ans,dfs(nums,i,visited,dp));\\n        return ans;\\n    }\\n    int dfs(vector<int>&nums,int n, vector<bool>& visited, vector<int>&dp)\\n    {\\n        if(visited[n]) return 0;\\n        if(dp[n] != -1) return dp[n];\\n        visited[n] = true;\\n        dp[n] = 1 + dfs(nums,nums[n],visited,dp);\\n        visited[n] = false;\\n        return dp[n];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438455,
                "title": "simple-brute-force-c-solution",
                "content": "1. Since we do not know the start of our desired sequence, we need to check for every element. \\n2. We need to keep adding the element in our sequence till we encounter a previously added element (cycle). We can maintain a visited array for that or we can simply mark the current element as \"-1\" for the same as we only have positive elements in the given sequence.\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxx = 0;\\n        for(int i = 0 ;i<n;i++){\\n            int size = 0;\\n            int k = i;\\n\\t\\t    while(nums[k] >= 0){\\n                int next_index = nums[k];\\n                nums[k] = -1; // here we are marking the current element as visited.\\n                k = next_index;\\n\\t\\t\\t\\tsize++;\\n            }\\n            maxx = max(maxx , size);\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxx = 0;\\n        for(int i = 0 ;i<n;i++){\\n            int size = 0;\\n            int k = i;\\n\\t\\t    while(nums[k] >= 0){\\n                int next_index = nums[k];\\n                nums[k] = -1; // here we are marking the current element as visited.\\n                k = next_index;\\n\\t\\t\\t\\tsize++;\\n            }\\n            maxx = max(maxx , size);\\n        }\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438323,
                "title": "c-simple-solution-using-flags-tc-o-n-sc-o-1",
                "content": "My solution uses flags to prevent repetition of tested values.\\n```\\nint arrayNesting(int* nums, int numsSize){\\n    int max = 0;\\n    int counter = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] != -1)\\n        {\\n            int j = nums[i]; \\n            counter = 0;\\n            while(j != i)\\n            {\\n                counter++;\\n                int temp = nums[j];\\n                nums[j] = -1;\\n                j = temp;\\n            }\\n            counter++;\\n            if(counter > max)\\n                max = counter;\\n        }\\n            \\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint arrayNesting(int* nums, int numsSize){\\n    int max = 0;\\n    int counter = 0;\\n    for(int i = 0; i < numsSize; i++)\\n    {\\n        if(nums[i] != -1)\\n        {\\n            int j = nums[i]; \\n            counter = 0;\\n            while(j != i)\\n            {\\n                counter++;\\n                int temp = nums[j];\\n                nums[j] = -1;\\n                j = temp;\\n            }\\n            counter++;\\n            if(counter > max)\\n                max = counter;\\n        }\\n            \\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1438256,
                "title": "array-nesting-do-while-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n         int Max=1;\\n         vector<int> ist(nums.size(),0);   \\n         for(int i=0;i<nums.size();i++){\\n          if(!ist[i]){     \\n             int x=nums[i],c=0;\\n             do{\\n                 x=nums[x];\\n                 c++;\\n                 ist[x]=true;\\n             } while(nums[i]!=x);  \\n             Max=max(c,Max);\\n            }\\n         }\\n        return Max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n         int Max=1;\\n         vector<int> ist(nums.size(),0);   \\n         for(int i=0;i<nums.size();i++){\\n          if(!ist[i]){     \\n             int x=nums[i],c=0;\\n             do{\\n                 x=nums[x];\\n                 c++;\\n                 ist[x]=true;\\n             } while(nums[i]!=x);  \\n             Max=max(c,Max);\\n            }\\n         }\\n        return Max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438254,
                "title": "python3-dfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        maxlen = 0\\n\\t\\t\\n\\t\\t#reference array to mark whether an index has been visited or not\\n        ref = [False for _ in range(len(nums))]\\n        \\n\\t\\tfor i in range(len(ref)):\\n\\t\\t\\t#we maintain a visited set for the current nesting -> check the while loop to understand usage\\n            visited = set()\\n            \\n\\t\\t\\t#if we already have visited this element, we do not search for the nesting again\\n\\t\\t\\tif ref[i]==True:\\n                continue\\n            \\n\\t\\t\\t#dummy variable to store the starting index of current nesting\\n\\t\\t\\tj = i\\n\\t\\t\\t\\n            while(True):\\n                k= nums[j]\\n\\n\\t\\t\\t\\t#we mark the index as visited so that when we come across this element in the for loop,\\n\\t\\t\\t\\t#we simply continue\\n\\t\\t\\t\\t\\n                ref[j] = True\\n                \\n\\t\\t\\t\\t#if we have already seen this element in the current nesting, we break (1 - refer below)\\n\\t\\t\\t\\tif k in visited:\\n                    break\\n                visited.add(k)\\n                j = k\\n            maxlen = max(maxlen,len(visited))\\n        \\n        return maxlen\\n```\\n\\nFor Point (1) in code - we could have simply used the original reference array ```ref``` along with a count variable to check whether we visited any element previously and update the max length instead of maintaining a set but I found this a little easier to understand.",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        maxlen = 0\\n\\t\\t\\n\\t\\t#reference array to mark whether an index has been visited or not\\n        ref = [False for _ in range(len(nums))]\\n        \\n\\t\\tfor i in range(len(ref)):\\n\\t\\t\\t#we maintain a visited set for the current nesting -> check the while loop to understand usage\\n            visited = set()\\n            \\n\\t\\t\\t#if we already have visited this element, we do not search for the nesting again\\n\\t\\t\\tif ref[i]==True:\\n                continue\\n            \\n\\t\\t\\t#dummy variable to store the starting index of current nesting\\n\\t\\t\\tj = i\\n\\t\\t\\t\\n            while(True):\\n                k= nums[j]\\n\\n\\t\\t\\t\\t#we mark the index as visited so that when we come across this element in the for loop,\\n\\t\\t\\t\\t#we simply continue\\n\\t\\t\\t\\t\\n                ref[j] = True\\n                \\n\\t\\t\\t\\t#if we have already seen this element in the current nesting, we break (1 - refer below)\\n\\t\\t\\t\\tif k in visited:\\n                    break\\n                visited.add(k)\\n                j = k\\n            maxlen = max(maxlen,len(visited))\\n        \\n        return maxlen\\n```\n```ref```",
                "codeTag": "Java"
            },
            {
                "id": 1438231,
                "title": "java-clean-concise-optimal-code-depth-first-search-technique-o-n-time-100-beats",
                "content": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        \\n        int maxLength = 0;\\n        \\n        for (int i = 0; i < nums.length && maxLength <= nums.length / 2; i++) {\\n            int k = i, length = 0;\\n            \\n            while (nums[k] != -1) {\\n                int temp = k;\\n                k = nums[k];\\n                nums[temp] = -1;\\n                ++length;\\n            }\\n            \\n            maxLength = Math.max (maxLength, length);\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        \\n        int maxLength = 0;\\n        \\n        for (int i = 0; i < nums.length && maxLength <= nums.length / 2; i++) {\\n            int k = i, length = 0;\\n            \\n            while (nums[k] != -1) {\\n                int temp = k;\\n                k = nums[k];\\n                nums[temp] = -1;\\n                ++length;\\n            }\\n            \\n            maxLength = Math.max (maxLength, length);\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438199,
                "title": "array-nesting-help",
                "content": "why my code is giving TLE\\n\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n\\n        int mx = -1;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            vector<int> vis(nums.size(),0);\\n            int j = i;\\n            int cnt = 0;\\n            \\n            while(!vis[j]){\\n                vis[j] = 1;\\n                j = nums[j];\\n                cnt++;\\n            }\\n            \\n            mx = max(mx,cnt);\\n        }\\n        return mx;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n\\n        int mx = -1;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            vector<int> vis(nums.size(),0);\\n            int j = i;\\n            int cnt = 0;\\n            \\n            while(!vis[j]){\\n                vis[j] = 1;\\n                j = nums[j];\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1373874,
                "title": "c-dfs-with-detailed-explanation-of-the-approach",
                "content": "**Approach:**\\nAfter reading this line from the problem statement **You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... }**, we can think about a solution involving graphs. \\n\\nNow, how to build the graph?\\nEach element of the set is defined as chain of accesses to previous values of the same set, more formally **set[i] = nums[set[i - 1]]** for all i >= 1 and the first element of the set is any arbitrary value from the given array. \\n\\nWe can add a directed edge from set[i] to set[i + 1] and the graph thus formed may have self-loops and cycles which can be dealt with using a visited array.\\n\\nFor Example, the graph for the same test case #1 (nums = [5,4,0,3,1,6,2]) will look like the following.\\n\\n![image](https://assets.leetcode.com/users/images/637871ce-61f9-4780-83d2-d698bfb09e81_1627717979.2134528.jpeg)\\n\\nNow, the problem (**Return the longest length of a set s[k]**) reduces to **find the size of the largest connected component**. In the above example, the size of the largest connected component is 4 (Connected Component: 5, 6, 2, 0). This reduced problem is a standard application of DFS and can be easily solved using the same.\\n\\n**Code:**\\n```C++\\n\\tvector<int> adj[(int) 1e5 + 10];\\n    bool visited[(int) 1e5 + 10];\\n  \\n    int cc_size; // stores the size of the current connected component\\n    void dfs(int node) {\\n      visited[node] = true;\\n      cc_size++;\\n      for (auto &child: adj[node]) {\\n        if (!visited[child]) {\\n          dfs(child);\\n        }\\n      }\\n    }\\n  \\n    int arrayNesting(vector<int>& nums) {\\n      const int N = 1e5 + 10;\\n      fill(visited, visited + N, false);\\n      \\n      // build the graph\\n      for (int i = 0; i < nums.size(); i++) {\\n        if (visited[nums[i]]) continue;\\n        for (int node = nums[i]; !visited[node]; node = nums[node]) {\\n          visited[node] = true;\\n          adj[node].push_back(nums[node]);\\n        } \\n      }       \\n      \\n      fill(visited, visited + N, false);\\n      int ans = 0;\\n      for (auto &ai: nums) {\\n        if (visited[ai]) continue;\\n        cc_size = 0;\\n        dfs(ai);\\n        ans = max(ans, cc_size);\\n      }\\n      \\n      return ans;\\n    }\\n```\\n\\n**Time Complexity:** O(N)\\nRunning time of DFS is O(|V| + |E|). Here, |V| = size of the input array and |E| cannot be greater than |V| since the given array is a permutation and each node can have at most one incoming edge / outgoing edge. So, it\\'s O(N) where N is the size of the input array.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```C++\\n\\tvector<int> adj[(int) 1e5 + 10];\\n    bool visited[(int) 1e5 + 10];\\n  \\n    int cc_size; // stores the size of the current connected component\\n    void dfs(int node) {\\n      visited[node] = true;\\n      cc_size++;\\n      for (auto &child: adj[node]) {\\n        if (!visited[child]) {\\n          dfs(child);\\n        }\\n      }\\n    }\\n  \\n    int arrayNesting(vector<int>& nums) {\\n      const int N = 1e5 + 10;\\n      fill(visited, visited + N, false);\\n      \\n      // build the graph\\n      for (int i = 0; i < nums.size(); i++) {\\n        if (visited[nums[i]]) continue;\\n        for (int node = nums[i]; !visited[node]; node = nums[node]) {\\n          visited[node] = true;\\n          adj[node].push_back(nums[node]);\\n        } \\n      }       \\n      \\n      fill(visited, visited + N, false);\\n      int ans = 0;\\n      for (auto &ai: nums) {\\n        if (visited[ai]) continue;\\n        cc_size = 0;\\n        dfs(ai);\\n        ans = max(ans, cc_size);\\n      }\\n      \\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355727,
                "title": "rust-cheapest-best",
                "content": "```\\nimpl Solution {\\n    pub fn array_nesting(nums: Vec<i32>) -> i32 {\\n        (0..nums.len())\\n            .scan(vec![0; nums.len()], |state, i| {\\n                let (mut x, mut j) = (0, i);\\n                while state[nums[j] as usize] != -1 {\\n                    x += 1;\\n                    j = nums[j] as usize;\\n                    state[j] = -1;\\n                }\\n                Some(x)\\n            })\\n            .max()\\n            .expect(\"Invalid input\")\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn array_nesting(nums: Vec<i32>) -> i32 {\\n        (0..nums.len())\\n            .scan(vec![0; nums.len()], |state, i| {\\n                let (mut x, mut j) = (0, i);\\n                while state[nums[j] as usize] != -1 {\\n                    x += 1;\\n                    j = nums[j] as usize;\\n                    state[j] = -1;\\n                }\\n                Some(x)\\n            })\\n            .max()\\n            .expect(\"Invalid input\")\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1235986,
                "title": "40-using-dfs-and-dp",
                "content": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int> &nums,vector<int>&dp,vector<bool>&vis,int i)\\n{\\n    if(vis[nums[i]]==true)\\n    {\\n        return;\\n    }\\n    else\\n    {\\n        vis[nums[i]]=true;\\n        dp[nums[i]]=dp[i]+1;\\n        dfs(nums,dp,vis,nums[i]);\\n    }\\n}\\n    int arrayNesting(vector<int>& nums)\\n    {\\n        vector<int> dp(nums.size(),0);\\n        vector<bool> vis(nums.size(),false);\\n        for(int i=dp.size()-1;i>=0;i--)\\n        {\\n            if(vis[i]==false)\\n            {\\n                vis[i]=true;\\n                dp[i]=1;\\n                dfs(nums,dp,vis,i);\\n            }\\n        }\\n        int maxi=0;\\n        for(int i=0;i<dp.size();i++)\\n        {\\n            maxi=max(maxi,dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int> &nums,vector<int>&dp,vector<bool>&vis,int i)\\n{\\n    if(vis[nums[i]]==true)\\n    {\\n        return;\\n    }\\n    else\\n    {\\n        vis[nums[i]]=true;\\n        dp[nums[i]]=dp[i]+1;\\n        dfs(nums,dp,vis,nums[i]);\\n    }\\n}\\n    int arrayNesting(vector<int>& nums)\\n    {\\n        vector<int> dp(nums.size(),0);\\n        vector<bool> vis(nums.size(),false);\\n        for(int i=dp.size()-1;i>=0;i--)\\n        {\\n            if(vis[i]==false)\\n            {\\n                vis[i]=true;\\n                dp[i]=1;\\n                dfs(nums,dp,vis,i);\\n            }\\n        }\\n        int maxi=0;\\n        for(int i=0;i<dp.size();i++)\\n        {\\n            maxi=max(maxi,dp[i]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138608,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        set<int> s;\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            int start = nums[i];\\n            if(s.find(start) != s.end())\\n                continue;\\n            int count = 0;\\n            do\\n            {\\n                s.insert(start);\\n                start = nums[start];\\n                count++;\\n            }\\n            while(start != nums[i]);\\n            ans = max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        set<int> s;\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            int start = nums[i];\\n            if(s.find(start) != s.end())\\n                continue;\\n            int count = 0;\\n            do\\n            {\\n                s.insert(start);\\n                start = nums[start];\\n                count++;\\n            }\\n            while(start != nums[i]);\\n            ans = max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067090,
                "title": "python-o-n-solution-using-set-beats-99-5",
                "content": "Instead of using list to mark used elements and make idle checks for visited elements later (because we will visit most of array\\'s elements at the end of the day ) we can employ unused elements\\' set and take the next element from it when we need to and remove from it when we visit some cycle.\\n\\n```\\nclass Solution:\\n    \"\"\"https://leetcode.com/problems/array-nesting/submissions/\"\"\"\\n\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        unused = set(nums)\\n        total_result = 0\\n        while unused:\\n            x = next(iter(unused))\\n            cntr = 0\\n            while x in unused:\\n                unused.remove(x)\\n                x = nums[x]\\n                cntr += 1\\n            total_result = max(total_result, cntr)\\n        return total_result\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \"\"\"https://leetcode.com/problems/array-nesting/submissions/\"\"\"\\n\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        unused = set(nums)\\n        total_result = 0\\n        while unused:\\n            x = next(iter(unused))\\n            cntr = 0\\n            while x in unused:\\n                unused.remove(x)\\n                x = nums[x]\\n                cntr += 1\\n            total_result = max(total_result, cntr)\\n        return total_result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018189,
                "title": "java-dp-dfs",
                "content": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int[] memo = new int[nums.length];\\n        Arrays.fill(memo, -1);\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++)\\n            ans = Math.max(ans, dfs(nums, memo, new boolean[nums.length], i));\\n        \\n        return ans;\\n    }\\n    \\n    public int dfs(int[] a, int[] memo, boolean[] visited, int x) {\\n        if(x >= a.length || visited[x]) return 0;\\n        visited[x] = true;\\n        if(memo[x] != -1) return memo[x];\\n        memo[x] = 1 + dfs(a, memo, visited, a[x]);\\n        return memo[x];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int[] memo = new int[nums.length];\\n        Arrays.fill(memo, -1);\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.length; i++)\\n            ans = Math.max(ans, dfs(nums, memo, new boolean[nums.length], i));\\n        \\n        return ans;\\n    }\\n    \\n    public int dfs(int[] a, int[] memo, boolean[] visited, int x) {\\n        if(x >= a.length || visited[x]) return 0;\\n        visited[x] = true;\\n        if(memo[x] != -1) return memo[x];\\n        memo[x] = 1 + dfs(a, memo, visited, a[x]);\\n        return memo[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968767,
                "title": "my-first-memoized-dp-solution",
                "content": "I\\'m so happy! I think this is the first time I was able to solve a DP problem using memoization all by myself :)\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        def f(nums, i, visited = set(), memo={}):\\n            if i in visited:\\n                return len(visited)\\n            if i in memo:\\n                return memo[i]\\n            visited.add(i)\\n            memo[i] = f(nums, nums[i], visited)\\n            return memo[i]\\n        \\n        memo = {}\\n        max_val = 1\\n        for i in range(len(nums)):\\n            if i not in memo:\\n                memo[i] = f(nums, i, set(), memo)\\n            max_val = max(max_val, memo[i])\\n        \\n        return max_val\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        def f(nums, i, visited = set(), memo={}):\\n            if i in visited:\\n                return len(visited)\\n            if i in memo:\\n                return memo[i]\\n            visited.add(i)\\n            memo[i] = f(nums, nums[i], visited)\\n            return memo[i]\\n        \\n        memo = {}\\n        max_val = 1\\n        for i in range(len(nums)):\\n            if i not in memo:\\n                memo[i] = f(nums, i, set(), memo)\\n            max_val = max(max_val, memo[i])\\n        \\n        return max_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898235,
                "title": "c-o-n-solution-faster-than-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<bool> vis(n, 0);\\n        \\n        int res = 0, temp = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int j = i;\\n            temp = 0;\\n            while(!vis[nums[j]]){\\n                vis[nums[j]] = true;\\n                temp++;\\n                j = nums[j];\\n            }\\n            res = max(res, temp);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<bool> vis(n, 0);\\n        \\n        int res = 0, temp = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int j = i;\\n            temp = 0;\\n            while(!vis[nums[j]]){\\n                vis[nums[j]] = true;\\n                temp++;\\n                j = nums[j];\\n            }\\n            res = max(res, temp);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891100,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        \\n        ans = 0\\n        for i, v in enumerate(nums):\\n            count = 0\\n            while v!=-1:\\n                count += 1\\n                nums[i] = -1\\n                v = nums[v]     \\n            ans = max(ans, count)\\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        \\n        ans = 0\\n        for i, v in enumerate(nums):\\n            count = 0\\n            while v!=-1:\\n                count += 1\\n                nums[i] = -1\\n                v = nums[v]     \\n            ans = max(ans, count)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 824761,
                "title": "c-short-o-n-code-with-explanation",
                "content": "Start with the first element and keep track of the elements that are in your current cycle by storing them. I used a bool vector for this, unordered_set can also be used. The logic is that there are cycles in the array. We only need to calculate the cycle once eg A[0] ->A[5]->A[6]->A[2]->A[0] makes a cycle. No matter which element we start from we will get result 4. \\nSo i calculate max size of all cycles and mark them visited.\\nHope this helps :)\\n\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& a) {\\n        \\n        \\n        int n = a.size();\\n        int ans = 0;\\n        vector<int>f(n,1);\\n        \\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(f[i]==1)\\n            {\\n                int t = i;\\n                int c = 0;\\n                while(f[t]==1)\\n                {\\n                    f[t] = 0;\\n                    t = a[t];\\n                    c++;\\n                }\\n                ans = max(ans,c);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int arrayNesting(vector<int>& a) {\\n        \\n        \\n        int n = a.size();\\n        int ans = 0;\\n        vector<int>f(n,1);\\n        \\n        int i = 0;\\n        while(i<n)\\n        {\\n            if(f[i]==1)\\n            {\\n                int t = i;\\n                int c = 0;\\n                while(f[t]==1)\\n                {\\n                    f[t] = 0;\\n                    t = a[t];\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 824756,
                "title": "c-simple-solution-very-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        vector<bool>v(n,0);\\n        for(int i=0;i<n;i++){\\n            if(v[i]==1){\\n                continue;\\n            }\\n            int out=1;\\n            int a=i;\\n            v[a]=1;\\n            a=nums[i];\\n            while(a!=i){\\n                out++;\\n                v[a]=1;\\n                a=nums[a];\\n            }\\n            ans=max(ans,out);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        vector<bool>v(n,0);\\n        for(int i=0;i<n;i++){\\n            if(v[i]==1){\\n                continue;\\n            }\\n            int out=1;\\n            int a=i;\\n            v[a]=1;\\n            a=nums[i];\\n            while(a!=i){\\n                out++;\\n                v[a]=1;\\n                a=nums[a];\\n            }\\n            ans=max(ans,out);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802495,
                "title": "python3-simple-dfs-solution",
                "content": "#### The main logic is to find the maximum no of connected components\\n\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        visited=[-1]*n\\n        t=0\\n        def explore(i,t):\\n            if visited[i]!=-1:\\n                return\\n            visited[i]=t\\n            explore(nums[i],t)\\n        for i in range(n):\\n            if visited[i]==-1:\\n                explore(i,t)\\n                t+=1\\n        c=Counter(visited)\\n        return max(c.values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        visited=[-1]*n\\n        t=0\\n        def explore(i,t):\\n            if visited[i]!=-1:\\n                return\\n            visited[i]=t\\n            explore(nums[i],t)\\n        for i in range(n):\\n            if visited[i]==-1:\\n                explore(i,t)\\n                t+=1\\n        c=Counter(visited)\\n        return max(c.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762950,
                "title": "java-o-n-space-vs-o-1-space",
                "content": "if not allowed to modify array:\\nTIme: O(N), Space: O(N)\\n```\\n    public int arrayNesting(int[] nums) {\\n        int res = 0, len = nums.length;\\n        boolean[] vs = new boolean[len];\\n        for (int i = 0; i < len; i++) {\\n            int size = 0;\\n            for (int k = i; !vs[k]; size++) {\\n                int next = nums[k];\\n                vs[k] = true;\\n                k = next;\\n            }\\n            res = Math.max(res, size);\\n        }\\n        return res;\\n    }\\n```\\n\\nif Allowed:\\nTIme: O(N), Space: O(1)\\n\\n```\\n    public int arrayNesting(int[] nums) {\\n        int res = 0, size = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            size = 0;\\n            for (int k = i; nums[k] >= 0; size++) {\\n                int next = nums[k];\\n                nums[k] = -1;\\n                k = next;\\n            }\\n            res = Math.max(res, size);\\n        }\\n        return res;\\n    }\\n```\\n\\nin place mark, O(1) space:\\nRef: https://leetcode.com/problems/array-nesting/discuss/102432/C%2B%2B-Java-Clean-Code-O(N)\\n```\\n    public int arrayNesting(int[] nums) {\\n        int res = 0, size = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            size = 0;\\n            for (int k = i; nums[k] >= 0; size++) {\\n                int next = nums[k];\\n                nums[k] = -1;\\n                k = next;\\n            }\\n            res = Math.max(res, size);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int arrayNesting(int[] nums) {\\n        int res = 0, len = nums.length;\\n        boolean[] vs = new boolean[len];\\n        for (int i = 0; i < len; i++) {\\n            int size = 0;\\n            for (int k = i; !vs[k]; size++) {\\n                int next = nums[k];\\n                vs[k] = true;\\n                k = next;\\n            }\\n            res = Math.max(res, size);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int arrayNesting(int[] nums) {\\n        int res = 0, size = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            size = 0;\\n            for (int k = i; nums[k] >= 0; size++) {\\n                int next = nums[k];\\n                nums[k] = -1;\\n                k = next;\\n            }\\n            res = Math.max(res, size);\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int arrayNesting(int[] nums) {\\n        int res = 0, size = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            size = 0;\\n            for (int k = i; nums[k] >= 0; size++) {\\n                int next = nums[k];\\n                nums[k] = -1;\\n                k = next;\\n            }\\n            res = Math.max(res, size);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749078,
                "title": "just-keep-on-modifying-the-current-element",
                "content": "Replace the current element with -1 while maintaining the count variable at the same time, and store the maximum count in the res variable.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int res=-1, n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==-1) continue;\\n            int start=nums[i], idx=i, x=nums[i], count=0;\\n            do{\\n                idx=x;\\n                x=nums[idx];\\n                count++;\\n                nums[idx]=-1;\\n            }while(x!=start);\\n            res=max(res,count);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int res=-1, n=nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums[i]==-1) continue;\\n            int start=nums[i], idx=i, x=nums[i], count=0;\\n            do{\\n                idx=x;\\n                x=nums[idx];\\n                count++;\\n                nums[idx]=-1;\\n            }while(x!=start);\\n            res=max(res,count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735702,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        vector<int> visited((int)nums.size(), 0);\\n        int result = 0;\\n        \\n        for(int i = 0; i < (int)nums.size(); ++i){\\n            if(!visited[i]){\\n                int current = nums[nums[i]], count = 1;\\n        \\n                while(current != nums[i]){\\n                    current = nums[current];\\n                    count++;\\n                    visited[current] = 1;\\n                }\\n                \\n                result = (count > result) ? count : result;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        vector<int> visited((int)nums.size(), 0);\\n        int result = 0;\\n        \\n        for(int i = 0; i < (int)nums.size(); ++i){\\n            if(!visited[i]){\\n                int current = nums[nums[i]], count = 1;\\n        \\n                while(current != nums[i]){\\n                    current = nums[current];\\n                    count++;\\n                    visited[current] = 1;\\n                }\\n                \\n                result = (count > result) ? count : result;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700169,
                "title": "python-solution-using-dfs-o-n-approach",
                "content": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        S = [set() for _ in range(len(nums))]\\n        vis = [False]*len(nums)\\n        ans = float(\\'-inf\\')\\n        for i in range(len(nums)):\\n            j = i\\n            while not vis[j]:\\n                S[i].add(nums[j])\\n                vis[j] = True\\n                j = nums[j]\\n            ans = max(ans, len(S[i]))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        S = [set() for _ in range(len(nums))]\\n        vis = [False]*len(nums)\\n        ans = float(\\'-inf\\')\\n        for i in range(len(nums)):\\n            j = i\\n            while not vis[j]:\\n                S[i].add(nums[j])\\n                vis[j] = True\\n                j = nums[j]\\n            ans = max(ans, len(S[i]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457034,
                "title": "java-clean-100-iterative-solution-with-o-1-space",
                "content": "```\\npublic static int arrayNesting(int[] nums) {\\n\\n        if (nums == null || nums.length == 0) return 0;\\n\\n        int maxLen   = 0;\\n        int curLen   = 0;\\n        int curIdx   = 0;\\n        int startIdx = 0;\\n\\t\\t\\n        while (startIdx < nums.length) {\\n            int nextIdx = nums[curIdx];\\n            if (nextIdx != -1) {\\n                nums[curIdx] = -1;\\n                maxLen = Math.max(maxLen, ++curLen);\\n                curIdx = nextIdx;\\n            } else {\\n                startIdx++;\\n                curLen = 0;\\n                curIdx = startIdx;\\n            }\\n        }\\n\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int arrayNesting(int[] nums) {\\n\\n        if (nums == null || nums.length == 0) return 0;\\n\\n        int maxLen   = 0;\\n        int curLen   = 0;\\n        int curIdx   = 0;\\n        int startIdx = 0;\\n\\t\\t\\n        while (startIdx < nums.length) {\\n            int nextIdx = nums[curIdx];\\n            if (nextIdx != -1) {\\n                nums[curIdx] = -1;\\n                maxLen = Math.max(maxLen, ++curLen);\\n                curIdx = nextIdx;\\n            } else {\\n                startIdx++;\\n                curLen = 0;\\n                curIdx = startIdx;\\n            }\\n        }\\n\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437916,
                "title": "a-great-graph-problem",
                "content": "Once you realize the graph is a disjoint set of circles, the solution is easy.\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int result = 0;\\n        vector<bool> visited(n, false);\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            int len = 1;\\n            for (int j = nums[i]; j != i; j = nums[j]) {\\n                visited[j] = true;\\n                len++;\\n            }\\n            result = max(result, len);\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        int result = 0;\\n        vector<bool> visited(n, false);\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n            int len = 1;\\n            for (int j = nums[i]; j != i; j = nums[j]) {\\n                visited[j] = true;\\n                len++;\\n            }\\n            result = max(result, len);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421378,
                "title": "100-tc-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int arrayNesting(int[] nums) {\\n\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tif(nums[i]!=-1){\\n\\t\\t\\t\\t\\tint length=0;\\n\\t\\t\\t\\t\\tint pos=i;\\n\\t\\t\\t\\t\\twhile(nums[pos]!=-1){\\n\\t\\t\\t\\t\\t\\tlength++;\\n\\t\\t\\t\\t\\t\\tint v=nums[pos];\\n\\t\\t\\t\\t\\t\\tnums[pos]=-1;\\n\\t\\t\\t\\t\\t\\tpos=v;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmax=Math.max(length,max);\\n\\n\\t\\t\\t\\t\\tif(max==nums.length) return max;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max!=0?max:1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int arrayNesting(int[] nums) {\\n\\n\\t\\t\\tint max=0;\\n\\t\\t\\tfor(int i=0;i<nums.length;i++){\\n\\t\\t\\t\\tif(nums[i]!=-1){\\n\\t\\t\\t\\t\\tint length=0;\\n\\t\\t\\t\\t\\tint pos=i;\\n\\t\\t\\t\\t\\twhile(nums[pos]!=-1){\\n\\t\\t\\t\\t\\t\\tlength++;\\n\\t\\t\\t\\t\\t\\tint v=nums[pos];\\n\\t\\t\\t\\t\\t\\tnums[pos]=-1;\\n\\t\\t\\t\\t\\t\\tpos=v;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 368080,
                "title": "c-solution-with-time-o-n-space-o-1",
                "content": "by changing the visited element with the negetive tracking length, we can avoid extra space and achieve O(n) time complexity.\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ret=0;\\n        for(int i=0;i<nums.size();i++){\\n            int count=1;\\n            int j=i;\\n            while(nums[j]>=0){\\n                count++;\\n                int tmp=j;\\n                j=nums[j];\\n                nums[tmp]=-count;\\n            }\\n            ret=max(ret,count+nums[j]+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ret=0;\\n        for(int i=0;i<nums.size();i++){\\n            int count=1;\\n            int j=i;\\n            while(nums[j]>=0){\\n                count++;\\n                int tmp=j;\\n                j=nums[j];\\n                nums[tmp]=-count;\\n            }\\n            ret=max(ret,count+nums[j]+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306430,
                "title": "java-o-n-time-o-1-space-with-explanation-beat-100",
                "content": "Given the condition in the Note that `The elements of A are all distinct.` and `Each element of A is an integer within the range [0, N-1].`, we could save space by placing the index value as the value of `nums` array when we loop it. If the index of element in `nums` is equal to value of that element, it means this index is either visited or doesn\\'t have Nesting so that the longest S[K] will be 1\\n\\nFor example, \\nIn the case: [5,4,0,3,1,6,2]\\n\\nwhen i=0, after the first iteration of for loop, `nums` will became\\n[**0**,4,**2**,3,1,**5**,**6**]\\n0, 2, 5, 6 will be placed into correct index. `count` and `res` becomes 4\\n\\nwhen i == 1, \\n`nums` will became\\n[0,**1**,2,3,**4**,5,6]\\n1, 4 will be placed into correct index. `count` becomes 2, but `res` stays 4\\n\\nwhen i == 2, since `nums[i] == i`, it means that 2 is either visited or doesn\\'t have nesting,  \\n`count` becomes 1, but `res` stays 4\\n`nums` will stay as \\n[0,1,2,3,4,5,6]\\n\\n...\\n\\nSince the nums is already sorted, when i = 3,4,5,6, we will get the same result as we got when i=2\\nAs a result, the answer in this case is 4\\n\\n```\\npublic int arrayNesting(int[] nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.length; i++){\\n            if (nums[i] == i)\\n                res = Math.max(res, 1);\\n            else{\\n                int count = 0;\\n                int curr_index = i;\\n                while (nums[curr_index] != curr_index){\\n                    int next_index = nums[curr_index];\\n                    nums[curr_index] = curr_index;\\n                    curr_index = next_index;\\n                    count++;\\n                }\\n                res = Math.max(res, count);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int arrayNesting(int[] nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.length; i++){\\n            if (nums[i] == i)\\n                res = Math.max(res, 1);\\n            else{\\n                int count = 0;\\n                int curr_index = i;\\n                while (nums[curr_index] != curr_index){\\n                    int next_index = nums[curr_index];\\n                    nums[curr_index] = curr_index;\\n                    curr_index = next_index;\\n                    count++;\\n                }\\n                res = Math.max(res, count);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295806,
                "title": "python-10-lines-with-o-1-space",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        for i, v in enumerate(nums):\\n            current = i\\n            while nums[current] > 0:\\n                nex = nums[current]\\n                nums[current] = -i\\n                current = nex\\n        return max(Counter(nums).values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        for i, v in enumerate(nums):\\n            current = i\\n            while nums[current] > 0:\\n                nex = nums[current]\\n                nums[current] = -i\\n                current = nex\\n        return max(Counter(nums).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236156,
                "title": "javascript",
                "content": "```\\nvar arrayNesting = function(nums) {\\n    let result = 0, set = new Set()\\n    for(let i = 0; i < nums.length; i++) {\\n        let j = i, count = 0\\n        while(!set.has(nums[j])){\\n            set.add(nums[j])\\n            j = nums[j]\\n            count += 1\\n        }\\n        result = Math.max(result, count)\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar arrayNesting = function(nums) {\\n    let result = 0, set = new Set()\\n    for(let i = 0; i < nums.length; i++) {\\n        let j = i, count = 0\\n        while(!set.has(nums[j])){\\n            set.add(nums[j])\\n            j = nums[j]\\n            count += 1\\n        }\\n        result = Math.max(result, count)\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 232283,
                "title": "c-straightforward-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int size=nums.size(),res=0,k,count,temp;\\n        for(int i=0;i<size;i++)\\n        {\\n            k=i,count=0;\\n            while(nums[k]>=0)\\n            {\\n                temp=nums[k];\\n                nums[k]=-1;\\n                k=temp;\\n                count++;\\n            }\\n            res=max(res,count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int size=nums.size(),res=0,k,count,temp;\\n        for(int i=0;i<size;i++)\\n        {\\n            k=i,count=0;\\n            while(nums[k]>=0)\\n            {\\n                temp=nums[k];\\n                nums[k]=-1;\\n                k=temp;\\n                count++;\\n            }\\n            res=max(res,count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209108,
                "title": "python-solution",
                "content": "Time complexity: O(n), space complexity: O(n).\\n\\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        seen = [0]*len(nums)\\n        res = 0\\n        for i in range(len(nums)):\\n            if seen[i] != -1:\\n                j = i\\n                count = 0\\n                while seen[j] != -1:\\n                    count += 1\\n                    seen[j] = -1\\n                    j = nums[j]\\n                res = max(res, count)\\n        return res\\n```\\n\\nIf we are allowed to modify `nums`, we don\\'t need to use an extra array `seen` to record visited elements. We can just set the visited elements to `-1` in `nums` and reduce the space complexity to `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] != -1:\\n                j = i\\n                count = 0\\n                while nums[j] != -1:\\n                    count += 1\\n                    tmp = nums[j]\\n                    nums[j] = -1\\n                    j = tmp\\n                res = max(res, count)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        seen = [0]*len(nums)\\n        res = 0\\n        for i in range(len(nums)):\\n            if seen[i] != -1:\\n                j = i\\n                count = 0\\n                while seen[j] != -1:\\n                    count += 1\\n                    seen[j] = -1\\n                    j = nums[j]\\n                res = max(res, count)\\n        return res\\n```\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        for i in range(len(nums)):\\n            if nums[i] != -1:\\n                j = i\\n                count = 0\\n                while nums[j] != -1:\\n                    count += 1\\n                    tmp = nums[j]\\n                    nums[j] = -1\\n                    j = tmp\\n                res = max(res, count)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174863,
                "title": "python-solution-dfs-largest-connected-component",
                "content": "##### DFS (Largest connected component)\\n##### O(n) time and space\\n    def arrayNesting(self, nums):\\n        def find_len(i):\\n            if i not in visited:\\n                visited.add(i)\\n                return 1 + find_len(nums[i])\\n            else:\\n                return 0\\n        visited = set()\\n        max_count = 0\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                max_count = max(max_count, find_len(i))\\n        return max_count\\n\\t\\t\\t\\t\\n##### BFS (Largest connected component\\n##### O(n) time and space\\n\\tdef arrayNesting(self, nums):\\n        # Longest connected component (BFS)\\n        # O(n) time and space        \\n        visited = set()\\n        max_count = 0\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                count = 0\\n                queue = collections.deque()\\n                queue.append(i)\\n                visited.add(i)\\n                while queue:\\n                    v = queue.popleft()\\n                    count+=1\\n                    if nums[v] not in visited:\\n                        queue.append(nums[v])\\n                        visited.add(v)                \\n                max_count = max(max_count, count)\\n        return max_count",
                "solutionTags": [],
                "code": "##### DFS (Largest connected component)\\n##### O(n) time and space\\n    def arrayNesting(self, nums):\\n        def find_len(i):\\n            if i not in visited:\\n                visited.add(i)\\n                return 1 + find_len(nums[i])\\n            else:\\n                return 0\\n        visited = set()\\n        max_count = 0\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                max_count = max(max_count, find_len(i))\\n        return max_count\\n\\t\\t\\t\\t\\n##### BFS (Largest connected component\\n##### O(n) time and space\\n\\tdef arrayNesting(self, nums):\\n        # Longest connected component (BFS)\\n        # O(n) time and space        \\n        visited = set()\\n        max_count = 0\\n        for i in range(len(nums)):\\n            if i not in visited:\\n                count = 0\\n                queue = collections.deque()\\n                queue.append(i)\\n                visited.add(i)\\n                while queue:\\n                    v = queue.popleft()\\n                    count+=1\\n                    if nums[v] not in visited:\\n                        queue.append(nums[v])\\n                        visited.add(v)                \\n                max_count = max(max_count, count)\\n        return max_count",
                "codeTag": "Python3"
            },
            {
                "id": 150349,
                "title": "i-need-help-with-fixing-my-logic-73-of-testcases-have-passed",
                "content": "I am not sure why this logic is not working. Please suggest what needs to be improved. It is failing for testcase [0,2,1]. My output is 1 instead of 2.\\nDo I need to consider all possible set sizes and choose the largest?\\n```\\n        if not nums:\\n            return 0\\n        set_ = set()\\n        set_.add(nums[0])\\n        recent_ele_added = nums[0]\\n        while len(set_) >= 1:\\n            temp = nums[recent_ele_added]\\n            if temp not in set_:\\n                set_.add(temp)\\n                recent_ele_added = temp\\n            else:\\n                break\\n        return len(set_)\\n```",
                "solutionTags": [],
                "code": "```\\n        if not nums:\\n            return 0\\n        set_ = set()\\n        set_.add(nums[0])\\n        recent_ele_added = nums[0]\\n        while len(set_) >= 1:\\n            temp = nums[recent_ele_added]\\n            if temp not in set_:\\n                set_.add(temp)\\n                recent_ele_added = temp\\n            else:\\n                break\\n        return len(set_)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102453,
                "title": "javascript-solution",
                "content": "```\\nvar arrayNesting = function(nums) {\\n    var len = nums.length,i,max = 0,count = 0;\\n    var set = new Set();\\n    for(i=0;i<len;i++){\\n        while(set.has(i) == false){\\n            set.add(i);\\n            i = nums[i];\\n            count++;\\n        }\\n        max = max > count ? max : count;\\n        count = 0;\\n    }\\n    return max;\\n};\\n```\\nPay attention to define set. After each iteration, remember to change count to zero.\\nSorry for my poor English.",
                "solutionTags": [],
                "code": "```\\nvar arrayNesting = function(nums) {\\n    var len = nums.length,i,max = 0,count = 0;\\n    var set = new Set();\\n    for(i=0;i<len;i++){\\n        while(set.has(i) == false){\\n            set.add(i);\\n            i = nums[i];\\n            count++;\\n        }\\n        max = max > count ? max : count;\\n        count = 0;\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 102468,
                "title": "python-o-n",
                "content": "```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # find the size of all the isolated circles\\n        visited = [False] * len(nums)\\n        max_count = 0\\n        for i, num in enumerate(nums):\\n            count = 0\\n            while not visited[i]:\\n                visited[i] = True\\n                count += 1\\n                i = nums[i]\\n            max_count = max(count, max_count)\\n        return max_count",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # find the size of all the isolated circles\\n        visited = [False] * len(nums)\\n        max_count = 0\\n        for i, num in enumerate(nums):\\n            count = 0\\n            while not visited[i]:\\n                visited[i] = True\\n                count += 1\\n                i = nums[i]\\n            max_count = max(count, max_count)\\n        return max_count",
                "codeTag": "Java"
            },
            {
                "id": 4100815,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayNesting = function(nums) {\\n    let n = nums.length;\\n    let maxLen = 0;\\n    for (let i = 0; i < n; i++) {\\n        let idx = i;\\n        let count = 0;\\n        while (nums[idx] !== null) {\\n            let lastIdx = nums[idx];\\n            nums[idx] = null;\\n            idx = lastIdx;\\n            count++;\\n        }\\n        maxLen = Math.max(count, maxLen);\\n    }\\n\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arrayNesting = function(nums) {\\n    let n = nums.length;\\n    let maxLen = 0;\\n    for (let i = 0; i < n; i++) {\\n        let idx = i;\\n        let count = 0;\\n        while (nums[idx] !== null) {\\n            let lastIdx = nums[idx];\\n            nums[idx] = null;\\n            idx = lastIdx;\\n            count++;\\n        }\\n        maxLen = Math.max(count, maxLen);\\n    }\\n\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063293,
                "title": "anti-chatgpt-solution-for-noob",
                "content": "# Approach\\n-1 act as flag, it terminated the while loop once it visit again \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n       int maxLength = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != -1) {\\n                int currentLength = 0;\\n                int start = i;\\n                while (true) {\\n                    int temp = start;\\n                    start = nums[start];\\n                    nums[temp] = -1;\\n                    currentLength++;\\n                    if (start == i) {\\n                        break; // We\\'ve completed a loop\\n                    }\\n                }\\n                maxLength = Math.max(maxLength, currentLength);\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n       int maxLength = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != -1) {\\n                int currentLength = 0;\\n                int start = i;\\n                while (true) {\\n                    int temp = start;\\n                    start = nums[start];\\n                    nums[temp] = -1;\\n                    currentLength++;\\n                    if (start == i) {\\n                        break; // We\\'ve completed a loop\\n                    }\\n                }\\n                maxLength = Math.max(maxLength, currentLength);\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059454,
                "title": "clean-dfs-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        ans = 0\\n        visited = [False]*len(nums)\\n        def dfs(index):\\n            if not visited[index]:\\n                visited[index] = True\\n                return 1+dfs(nums[index])\\n            else:\\n                return 0\\n            \\n        for i in range(len(nums)):\\n            if not visited[i]:\\n                ans = max(ans,dfs(i))\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        ans = 0\\n        visited = [False]*len(nums)\\n        def dfs(index):\\n            if not visited[index]:\\n                visited[index] = True\\n                return 1+dfs(nums[index])\\n            else:\\n                return 0\\n            \\n        for i in range(len(nums)):\\n            if not visited[i]:\\n                ans = max(ans,dfs(i))\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004869,
                "title": "beats-runtime-100-memory-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        visited = [False] * n  \\n        max_length = 0\\n\\n        for i in range(n):\\n            if not visited[i]:\\n                length = 0\\n                while not visited[i]:\\n                    visited[i] = True\\n                    length += 1\\n                    i = nums[i]\\n                max_length = max(max_length, length)\\n\\n        return max_length\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arrayNesting(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(nums)\\n        visited = [False] * n  \\n        max_length = 0\\n\\n        for i in range(n):\\n            if not visited[i]:\\n                length = 0\\n                while not visited[i]:\\n                    visited[i] = True\\n                    length += 1\\n                    i = nums[i]\\n                max_length = max(max_length, length)\\n\\n        return max_length\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002987,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        vector<int> dist(n);\\n        int ans = 0, j;\\n        for(int i = 0; i < n; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            for(j = i; !visited[nums[j]]; j = nums[j]) {\\n                dist[nums[j]] = dist[j] + 1;\\n                visited[nums[j]] = true;\\n            }\\n            ans = max(ans, dist[j] - dist[nums[j]] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<bool> visited(n);\\n        vector<int> dist(n);\\n        int ans = 0, j;\\n        for(int i = 0; i < n; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            for(j = i; !visited[nums[j]]; j = nums[j]) {\\n                dist[nums[j]] = dist[j] + 1;\\n                visited[nums[j]] = true;\\n            }\\n            ans = max(ans, dist[j] - dist[nums[j]] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996681,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.length;i++){\\n            int next =i;\\n            int count =0;\\n            while(nums[next]!= -1){\\n                count++;\\n                int temp= next;\\n                next = nums[next];\\n                nums[temp] = -1;\\n            }\\n            ans = Math.max(ans , count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.length;i++){\\n            int next =i;\\n            int count =0;\\n            while(nums[next]!= -1){\\n                count++;\\n                int temp= next;\\n                next = nums[next];\\n                nums[temp] = -1;\\n            }\\n            ans = Math.max(ans , count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991839,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        vector<bool>visited(n);\\n        \\n\\n\\n        for(int i=0;i<nums.size();i++){\\n            int cnt=0;\\n            while(!visited[i]){\\n                visited[i]=1;\\n                cnt++;\\n                i=nums[i];\\n\\n            }\\n            res=max(res,cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        int res=0;\\n        vector<bool>visited(n);\\n        \\n\\n\\n        for(int i=0;i<nums.size();i++){\\n            int cnt=0;\\n            while(!visited[i]){\\n                visited[i]=1;\\n                cnt++;\\n                i=nums[i];\\n\\n            }\\n            res=max(res,cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977455,
                "title": "intuition-from-find-parent-and-dfs-c",
                "content": "Don\\'t you smell something fishi about this  array and the way they said whey are building \\nsets\\ns[k] = a[i], a[a[i]], ......\\nif u recall in graph we use to do something like find parent  and itrate till \\nwe get p[x]==x\\n```\\nint find_parent (int x, vector<int> &p)\\n{\\n  return x==p[x]? z: find_parent(p[x],p);\\n}\\n```\\n\\n\\n\\nso here the given array is nothing but immidiate child of ith node not ultimate as find_parent function gives us then\\nDon\\'t you see this makes this thing a graph ?\\nwhere each node have one outgoing edge and bcz it\\'s using only 0 to n-1 values then it must form at least one cycle in whole graph we need to just get that means we can start itrating from every unvisited node and do dfs treversal and count the length of each dfs traversal and take max out of it :)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> v;\\n    vector<int> a;\\n    int t=0;\\n    int dfs(int i)\\n    {\\n        // cout<<i<<\" \";\\n        if(i==t|| v[i]) return 0;\\n        v[i]=1;\\n        int ans=1;\\n        ans+=dfs(a[i]);\\n        return ans;\\n        \\n    }\\n    int arrayNesting(vector<int>& a1) \\n    {\\n        a=a1;\\n        int n=a.size();\\n        v.resize(n,0);\\n        int ans=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                t=i;// initial node\\n                ans= max(ans, 1+dfs(a[i]));\\n               // cout<<endl;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nint find_parent (int x, vector<int> &p)\\n{\\n  return x==p[x]? z: find_parent(p[x],p);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> v;\\n    vector<int> a;\\n    int t=0;\\n    int dfs(int i)\\n    {\\n        // cout<<i<<\" \";\\n        if(i==t|| v[i]) return 0;\\n        v[i]=1;\\n        int ans=1;\\n        ans+=dfs(a[i]);\\n        return ans;\\n        \\n    }\\n    int arrayNesting(vector<int>& a1) \\n    {\\n        a=a1;\\n        int n=a.size();\\n        v.resize(n,0);\\n        int ans=1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(v[i]==0)\\n            {\\n                t=i;// initial node\\n                ans= max(ans, 1+dfs(a[i]));\\n               // cout<<endl;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3967884,
                "title": "easy-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int index,vector<int>&vis){\\n        int n=v.size();\\n        vis[index]=1;\\n        int res=1;\\n        if(!vis[v[index]]) res+=solve(v,v[index],vis);\\n        return res;\\n    }\\n    int arrayNesting(vector<int>& v) {\\n        int res=0;\\n        int n=v.size();\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++){\\n            res=max(res,solve(v,i,vis));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int index,vector<int>&vis){\\n        int n=v.size();\\n        vis[index]=1;\\n        int res=1;\\n        if(!vis[v[index]]) res+=solve(v,v[index],vis);\\n        return res;\\n    }\\n    int arrayNesting(vector<int>& v) {\\n        int res=0;\\n        int n=v.size();\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++){\\n            res=max(res,solve(v,i,vis));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937355,
                "title": "dfs-approach",
                "content": "# Intuition\\n\\n```\\nclass Solution {\\npublic:\\nvoid solve(int i,vector<int>& nums,int &ans,vector<int>&vis) {\\n    if(vis[i]) return;\\n    vis[i]=1;\\n    ans++;\\n    solve(nums[i],nums,ans,vis);\\n\\n}\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>vis(n,0);\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            int ans=0;\\n          if(!vis[i]){\\n             solve(i,nums,ans,vis);\\n          }\\n          mx=max(mx,ans);\\n        }\\n     return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int i,vector<int>& nums,int &ans,vector<int>&vis) {\\n    if(vis[i]) return;\\n    vis[i]=1;\\n    ans++;\\n    solve(nums[i],nums,ans,vis);\\n\\n}\\n    int arrayNesting(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>vis(n,0);\\n        int mx=0;\\n        for(int i=0;i<n;i++){\\n            int ans=0;\\n          if(!vis[i]){\\n             solve(i,nums,ans,vis);\\n          }\\n          mx=max(mx,ans);\\n        }\\n     return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934509,
                "title": "easy-approach-clean-code-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity:``O(n)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==INT_MAX)continue;\\n            int start=nums[i];\\n            int count=0;\\n            while(nums[start]!=INT_MAX){\\n                int temp=start;\\n                start=nums[start];\\n                count++;\\n                nums[temp]=INT_MAX;\\n            }\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==INT_MAX)continue;\\n            int start=nums[i];\\n            int count=0;\\n            while(nums[start]!=INT_MAX){\\n                int temp=start;\\n                start=nums[start];\\n                count++;\\n                nums[temp]=INT_MAX;\\n            }\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928090,
                "title": "simple-cyclic-sort-well-you-can-also-do-via-dfs-but-it-will-take-more-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->//just read cyclic sort if you dont know it\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans = 0;\\n        int cnt = 0;\\n        int i =0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                swap(nums[nums[i]],nums[i]);\\n                cnt++;\\n            }\\n            else if(nums[i] == i){\\n                ans = max(ans,cnt);\\n                cnt = 0;\\n                i++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int ans = 0;\\n        int cnt = 0;\\n        int i =0;\\n        while(i<nums.size()){\\n            if(nums[i]!=i){\\n                swap(nums[nums[i]],nums[i]);\\n                cnt++;\\n            }\\n            else if(nums[i] == i){\\n                ans = max(ans,cnt);\\n                cnt = 0;\\n                i++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922826,
                "title": "swift-very-easy-and-concise-solution",
                "content": "```\\nclass Solution {\\n    func arrayNesting(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var depth = [Int](repeating: 0, count: n)\\n\\n        for var start in 0..<n {\\n            var d = 1\\n            while depth[start] == 0 {\\n                depth[start] = d\\n                start = nums[start]\\n                d += 1\\n            }\\n        }\\n        return depth.max()!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arrayNesting(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var depth = [Int](repeating: 0, count: n)\\n\\n        for var start in 0..<n {\\n            var d = 1\\n            while depth[start] == 0 {\\n                depth[start] = d\\n                start = nums[start]\\n                d += 1\\n            }\\n        }\\n        return depth.max()!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893607,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    bool[] visited;\\n    int result = 0;\\n    public int ArrayNesting(int[] nums) {\\n        visited = new bool[nums.Length];\\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            Dfs(nums, i, 1);\\n        }\\n\\n        return result;\\n    }\\n\\n    void Dfs(int[] nums, int index, int count)\\n    {\\n        if(visited[index])\\n        {\\n            return;\\n        }\\n\\n        visited[index] = true;\\n\\n        result = Math.Max(result, count);\\n\\n        Dfs(nums, nums[index], count+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    bool[] visited;\\n    int result = 0;\\n    public int ArrayNesting(int[] nums) {\\n        visited = new bool[nums.Length];\\n        for(int i = 0;i<nums.Length;i++)\\n        {\\n            Dfs(nums, i, 1);\\n        }\\n\\n        return result;\\n    }\\n\\n    void Dfs(int[] nums, int index, int count)\\n    {\\n        if(visited[index])\\n        {\\n            return;\\n        }\\n\\n        visited[index] = true;\\n\\n        result = Math.Max(result, count);\\n\\n        Dfs(nums, nums[index], count+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858879,
                "title": "c-dfs",
                "content": "# Intuition\\nLet me rephrease the question for you - \"Find the longest connected path in the forest(why forest ?)\"\\n\\n# Approach\\nIt is clear from the code that this is a DFS problem. But the problem is we do not know the heads for trees in the forest. No problem just start DFS from any node and mark all the nodes in this iteration. Now DFS stops in when we revisit a node. There can be two cases - \\n(1) We are revisiting the node with MARK(cur_node) == MARK(revisiting_node). Cycle detected stop DFS.\\n(2) We are revisiting the node with MARK(cur_node) > MARK(revisiting_node). Here we can actually go ahead and cover all the node. But we have already covered this node and we can store size in a map (MAP[MARK] = number of nodes covered) and just add to the current node count.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<int> v(len, -1);\\n        int ans = 0, k, temp, mark = 1, depth = 0;\\n        unordered_map<int, int> m;\\n\\n        for(int i = 0; i < len; i++){\\n            if (v[i] == -1){\\n                depth = 0;\\n                k = i;\\n                while(v[k] == -1){\\n                    v[k] = mark;\\n                    k = nums[k];\\n                    depth = depth + 1;\\n                }\\n\\n                if (v[k] == mark){\\n                    m[mark] = depth;\\n                } else{\\n                    m[mark] = depth + m[v[k]];\\n                }\\n\\n                ans = max(ans, m[mark]);\\n                mark++;\\n            }\\n        }\\n\\n        // for(int i = 0; i < len; i++){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) {\\n        int len = nums.size();\\n        vector<int> v(len, -1);\\n        int ans = 0, k, temp, mark = 1, depth = 0;\\n        unordered_map<int, int> m;\\n\\n        for(int i = 0; i < len; i++){\\n            if (v[i] == -1){\\n                depth = 0;\\n                k = i;\\n                while(v[k] == -1){\\n                    v[k] = mark;\\n                    k = nums[k];\\n                    depth = depth + 1;\\n                }\\n\\n                if (v[k] == mark){\\n                    m[mark] = depth;\\n                } else{\\n                    m[mark] = depth + m[v[k]];\\n                }\\n\\n                ans = max(ans, m[mark]);\\n                mark++;\\n            }\\n        }\\n\\n        // for(int i = 0; i < len; i++){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        // cout<<\"\\\\n\";\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3858573,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        res = 0\\n        s = set()\\n        for i, v in enumerate(nums):\\n            cnt = 0\\n            while v not in s:\\n                cnt += 1\\n                s.add(v)\\n                v = nums[v]\\n            if res < cnt:\\n                res = cnt\\n        return res\\n```\\n![catty.png](https://assets.leetcode.com/users/images/86a925e4-83b5-46bd-b051-65da114d689b_1691072305.5465522.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arrayNesting(self, nums: List[int]) -> int:\\n        res = 0\\n        s = set()\\n        for i, v in enumerate(nums):\\n            cnt = 0\\n            while v not in s:\\n                cnt += 1\\n                s.add(v)\\n                v = nums[v]\\n            if res < cnt:\\n                res = cnt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842673,
                "title": "array-nesting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- traverse through array, and check each element loop which are not marked , and return the largest loop \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BRUTE & OPTIMAL- use marking of element as -ve , and use values as indx for next element , and check till  there where it makes loop , ie it gets -ve . and count how much element it has in a loop , and return the max count of loop .(read code for more understanding)\\nT-n S-1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n; i++) {\\n            if (A[i] >= 0) {\\n                int cnt = 0;\\n                while (A[i] >= 0) {\\n                    int temp = i;\\n                    i = A[i];\\n                    A[temp] = -1; // Mark the element as visited\\n                    cnt++;\\n                }\\n                res = max(res, cnt);\\n            }\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& A) {\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n; i++) {\\n            if (A[i] >= 0) {\\n                int cnt = 0;\\n                while (A[i] >= 0) {\\n                    int temp = i;\\n                    i = A[i];\\n                    A[temp] = -1; // Mark the element as visited\\n                    cnt++;\\n                }\\n                res = max(res, cnt);\\n            }\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837669,
                "title": "swift-100-beat-time-space-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func arrayNesting(_ nums: [Int]) -> Int {\\n    \\n    var result = 0\\n    var arrBoolean = Array(repeating: false, count: nums.count)\\n    \\n    for i in 0..<nums.count {\\n        \\n        if !arrBoolean[i] {\\n            \\n            var count = 0\\n            var val = nums[i]\\n            count += 1\\n            arrBoolean[val] = true\\n            \\n            while val != i && i < nums.count {\\n                \\n                val = nums[val]\\n                count += 1\\n                arrBoolean[val] = true\\n            }\\n            \\n            result = max(result, count)\\n        }\\n    }\\n    \\n    return result\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arrayNesting(_ nums: [Int]) -> Int {\\n    \\n    var result = 0\\n    var arrBoolean = Array(repeating: false, count: nums.count)\\n    \\n    for i in 0..<nums.count {\\n        \\n        if !arrBoolean[i] {\\n            \\n            var count = 0\\n            var val = nums[i]\\n            count += 1\\n            arrBoolean[val] = true\\n            \\n            while val != i && i < nums.count {\\n                \\n                val = nums[val]\\n                count += 1\\n                arrBoolean[val] = true\\n            }\\n            \\n            result = max(result, count)\\n        }\\n    }\\n    \\n    return result\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837516,
                "title": "simple-java-solution-using-unionfind-with-path-compression",
                "content": "```\\nclass Solution {\\n    \\n    class UnionFind {\\n        int[] parents;\\n        int[] sizes;\\n        int max = 1;\\n        \\n        public UnionFind(int n) {\\n            this.parents = new int[n];\\n            this.sizes = new int[n];\\n            \\n            for(int i = 0; i < n; i++) {\\n                this.parents[i] = i;\\n                this.sizes[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int u) {\\n            if(u != parents[u])\\n                parents[u] = find(parents[u]);\\n            \\n            return parents[u];\\n        }\\n        \\n        public void union(int u, int v) {\\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if(pu == pv)\\n                return;\\n            \\n            if(sizes[pu] >= sizes[pv]) {\\n                parents[pv] = pu;\\n                sizes[pu] += sizes[pv];\\n                max = Math.max(max, sizes[pu]);\\n            } else {\\n                parents[pu] = pv;\\n                sizes[pv] += sizes[pu];\\n                max = Math.max(max, sizes[pv]);\\n            }\\n        }\\n    }\\n    \\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)\\n            return 0;\\n        \\n        UnionFind uf = new UnionFind(n);\\n        for(int i = 0; i < n; i++) {\\n            uf.union(i, nums[i]);\\n        }\\n        \\n        return uf.max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class UnionFind {\\n        int[] parents;\\n        int[] sizes;\\n        int max = 1;\\n        \\n        public UnionFind(int n) {\\n            this.parents = new int[n];\\n            this.sizes = new int[n];\\n            \\n            for(int i = 0; i < n; i++) {\\n                this.parents[i] = i;\\n                this.sizes[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int u) {\\n            if(u != parents[u])\\n                parents[u] = find(parents[u]);\\n            \\n            return parents[u];\\n        }\\n        \\n        public void union(int u, int v) {\\n            int pu = find(u);\\n            int pv = find(v);\\n            \\n            if(pu == pv)\\n                return;\\n            \\n            if(sizes[pu] >= sizes[pv]) {\\n                parents[pv] = pu;\\n                sizes[pu] += sizes[pv];\\n                max = Math.max(max, sizes[pu]);\\n            } else {\\n                parents[pu] = pv;\\n                sizes[pv] += sizes[pu];\\n                max = Math.max(max, sizes[pv]);\\n            }\\n        }\\n    }\\n    \\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        if(n == 0)\\n            return 0;\\n        \\n        UnionFind uf = new UnionFind(n);\\n        for(int i = 0; i < n; i++) {\\n            uf.union(i, nums[i]);\\n        }\\n        \\n        return uf.max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783402,
                "title": "java-solution-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.length;i++){\\n            int next =i;\\n            int count =0;\\n            while(nums[next]!= -1){\\n                count++;\\n                int temp= next;\\n                next = nums[next];\\n                nums[temp] = -1;\\n            }\\n            ans = Math.max(ans , count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.length;i++){\\n            int next =i;\\n            int count =0;\\n            while(nums[next]!= -1){\\n                count++;\\n                int temp= next;\\n                next = nums[next];\\n                nums[temp] = -1;\\n            }\\n            ans = Math.max(ans , count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753642,
                "title": "easy-java-solution-with-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        int max=Integer.MIN_VALUE;\\n        int vis[]=new int[nums.length];\\n        Arrays.fill(vis,0);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                max=Math.max(helper(dp,i,vis,nums),max);\\n            }\\n        }\\n        return max;\\n    }\\n    public int helper(int dp[],int index,int vis[],int nums[])\\n    {\\n        if(vis[index]==1)\\n        return 0;\\n        vis[index]=1;\\n        if(dp[index]!=-1)\\n        return dp[index];\\n        else\\n        {\\n            return dp[index]=1+helper(dp,nums[index],vis,nums);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        int max=Integer.MIN_VALUE;\\n        int vis[]=new int[nums.length];\\n        Arrays.fill(vis,0);\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(dp[i]==-1)\\n            {\\n                max=Math.max(helper(dp,i,vis,nums),max);\\n            }\\n        }\\n        return max;\\n    }\\n    public int helper(int dp[],int index,int vis[],int nums[])\\n    {\\n        if(vis[index]==1)\\n        return 0;\\n        vis[index]=1;\\n        if(dp[index]!=-1)\\n        return dp[index];\\n        else\\n        {\\n            return dp[index]=1+helper(dp,nums[index],vis,nums);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704415,
                "title": "c-look-for-longest-cycle-o-n",
                "content": "```\\nclass Solution {\\n  static constexpr int SIZE = 1e5+1;\\npublic:\\n    // IDEA: Each element of nums can only be a part of 1 cycle, hence the number of cycles can be in the range [1, n]. \\n\\t//       If we set each unique value as visited we do not need to consider each element of a cycle more than once. Hence\\n\\t//       we can have O(n) time. We can optimise this by tracking the number of remaining elements and when the longest cycle is longer\\n\\t//       than the number of remaining elements we cannot find a longer cycle and leave these elements unchecked.\\n    int arrayNesting(vector<int>& nums) {\\n      int n = nums.size(), remaining = n;\\n      bitset<SIZE> visited;\\n      int res = 1;\\n      for (int i = 0; i < n; i++) {\\n        if (visited[i]) continue;\\n\\t\\t// Set i as visited and every element in the cycle containing i\\n        visited[i] = 1;\\n        int idx = nums[i], len = 1;\\n\\t\\t// The `end` of the cycle will be when nums[idx] = i, as that will take us back to the start.\\n        while (idx != i) {\\n          visited[idx] = 1;\\n          idx = nums[idx];\\n          len++;\\n        }\\n        res = max(res, len);\\n\\t\\t// Remove the elements of the cycle from the total remaining elements\\n        remaining -= len;\\n\\t\\t// if the number of remaining numbers is less than the current max cycle length, we cannot find a longer cycle\\n        if (res > remaining)\\n          break;\\n      }\\n      return res;\\n    }\\n};\\n```\\nIt is important to note that the cycles do not intersect, as each element in `nums` points at exactly 1 element and if 2 cycles were to intersect then at some point `u` there must be `nums[v] = u` and `nums[w] = u` which cannot happen as the elements in `nums` are unique.\\nThis problem is similar to strategy for the [100 prisoners problem](https://en.wikipedia.org/wiki/100_prisoners_problem).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  static constexpr int SIZE = 1e5+1;\\npublic:\\n    // IDEA: Each element of nums can only be a part of 1 cycle, hence the number of cycles can be in the range [1, n]. \\n\\t//       If we set each unique value as visited we do not need to consider each element of a cycle more than once. Hence\\n\\t//       we can have O(n) time. We can optimise this by tracking the number of remaining elements and when the longest cycle is longer\\n\\t//       than the number of remaining elements we cannot find a longer cycle and leave these elements unchecked.\\n    int arrayNesting(vector<int>& nums) {\\n      int n = nums.size(), remaining = n;\\n      bitset<SIZE> visited;\\n      int res = 1;\\n      for (int i = 0; i < n; i++) {\\n        if (visited[i]) continue;\\n\\t\\t// Set i as visited and every element in the cycle containing i\\n        visited[i] = 1;\\n        int idx = nums[i], len = 1;\\n\\t\\t// The `end` of the cycle will be when nums[idx] = i, as that will take us back to the start.\\n        while (idx != i) {\\n          visited[idx] = 1;\\n          idx = nums[idx];\\n          len++;\\n        }\\n        res = max(res, len);\\n\\t\\t// Remove the elements of the cycle from the total remaining elements\\n        remaining -= len;\\n\\t\\t// if the number of remaining numbers is less than the current max cycle length, we cannot find a longer cycle\\n        if (res > remaining)\\n          break;\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683835,
                "title": "c-math-solution",
                "content": "# C++ Math solution\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) \\n    {\\n      int index = 0;\\n      int ans  = 0;\\n\\n      while(index<nums.size())\\n      {\\n          int j = index , curr = 0;\\n          while(nums[j]!=nums.size()){\\n              curr++;\\n              int ii = nums[j];\\n              nums[j] = nums.size();\\n              j = ii;\\n          }\\n          ans = max(ans,curr);\\n          index++;\\n          }\\n          return ans;  \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arrayNesting(vector<int>& nums) \\n    {\\n      int index = 0;\\n      int ans  = 0;\\n\\n      while(index<nums.size())\\n      {\\n          int j = index , curr = 0;\\n          while(nums[j]!=nums.size()){\\n              curr++;\\n              int ii = nums[j];\\n              nums[j] = nums.size();\\n              j = ii;\\n          }\\n          ans = max(ans,curr);\\n          index++;\\n          }\\n          return ans;  \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683784,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> & nums,vector<int> &vis,int &count,int &i){\\n        vis[i]=1;\\n        count++;\\n        if(!vis[nums[i]]){\\n            dfs(nums,vis,count,nums[i]);\\n        }\\n    }\\n    int arrayNesting(vector<int>& nums) {\\n    int n=nums.size();\\n    int ans=0;\\n    vector<int> vis(n,0);\\n    for(int i=0;i<n;i++)\\n    {\\n        int count=0;\\n        dfs(nums,vis,count,i);\\n        ans=max(ans,count);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> & nums,vector<int> &vis,int &count,int &i){\\n        vis[i]=1;\\n        count++;\\n        if(!vis[nums[i]]){\\n            dfs(nums,vis,count,nums[i]);\\n        }\\n    }\\n    int arrayNesting(vector<int>& nums) {\\n    int n=nums.size();\\n    int ans=0;\\n    vector<int> vis(n,0);\\n    for(int i=0;i<n;i++)\\n    {\\n        int count=0;\\n        dfs(nums,vis,count,i);\\n        ans=max(ans,count);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658041,
                "title": "c-faster-than-55",
                "content": "# Intuition\\nGo through array and calculate the intermediate result for each nums[i].\\n\\n# Approach\\nGo through array and calculate the intermediate result for each nums[i]:\\n```\\nfor (int i = 0; i < nums.Length; i++)\\n{\\n    if (!visited[i])\\n    {\\n        var rs0 = PathLength(i, visited, nums);\\n        if (rs < rs0) rs = rs0;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(nums))$$\\n\\n- Space complexity:\\n$$O(len(nums))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ArrayNesting(int[] nums) {\\n        var visited = new bool[nums.Length];\\n        var rs = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (!visited[i])\\n            {\\n                var rs0 = PathLength(i, visited, nums);\\n                if (rs < rs0) rs = rs0;\\n            }\\n        }\\n        return rs;\\n    }\\n    private int PathLength(int index, bool[] visited, int[] nums)\\n    {\\n        var rs = 1;\\n        var curr = nums[index];\\n        while (curr != index)\\n        {\\n            curr = nums[curr];\\n            visited[curr] = true;\\n            rs++;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nfor (int i = 0; i < nums.Length; i++)\\n{\\n    if (!visited[i])\\n    {\\n        var rs0 = PathLength(i, visited, nums);\\n        if (rs < rs0) rs = rs0;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int ArrayNesting(int[] nums) {\\n        var visited = new bool[nums.Length];\\n        var rs = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (!visited[i])\\n            {\\n                var rs0 = PathLength(i, visited, nums);\\n                if (rs < rs0) rs = rs0;\\n            }\\n        }\\n        return rs;\\n    }\\n    private int PathLength(int index, bool[] visited, int[] nums)\\n    {\\n        var rs = 1;\\n        var curr = nums[index];\\n        while (curr != index)\\n        {\\n            curr = nums[curr];\\n            visited[curr] = true;\\n            rs++;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652974,
                "title": "easy-java-solution",
                "content": "# Intuition\\nMark all the indexes visited of one set and keep tracking the max size of the set. It\\'s like finding the cycle size but we have to keep track of cycle - 1. \\n\\n# Approach\\nMark all the indices value as -1 when it\\'s visited and for each indices if not visited try to find cycle. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            int cur = i;\\n            int count = 0;\\n            while(nums[cur] != -1){\\n                int nextcur = nums[cur];\\n                nums[cur] = -1;\\n                cur = nextcur;\\n                count++;\\n            }\\n            ans = Math.max(ans, count);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int arrayNesting(int[] nums) {\\n        int n = nums.length;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            int cur = i;\\n            int count = 0;\\n            while(nums[cur] != -1){\\n                int nextcur = nums[cur];\\n                nums[cur] = -1;\\n                cur = nextcur;\\n                count++;\\n            }\\n            ans = Math.max(ans, count);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574457,
                "content": [
                    {
                        "username": "ashraf_roni",
                        "content": "I do not know, how did you handled this case?\\n[0,2,1]\\nA[0] = 0;\\nIs it a problem statement issue I missed?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "it\\'s not necessarily to start with index 0, you can start with any index to get longest length cycle "
                    },
                    {
                        "username": "mkkamleh",
                        "content": "you can start with any index in the beginning, not necessarily 0, then you need to find longest ring      "
                    },
                    {
                        "username": "pacman",
                        "content": "For test case \\n**[0,2,1]**\\noutput?"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "output->2"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "To solve this problem, you can use a visited array to keep track of the elements that have already been processed, and a variable to keep track of the maximum size of a nested subarray. Starting from each unvisited element in the array, you can use a while loop to follow the nest and increment the size until you reach an element that has already been processed or an element that doesn\\'t belong to the nest. The maximum size of a nested subarray can then be updated if the size of the current nest is greater than the current maximum."
                    },
                    {
                        "username": "liaison",
                        "content": ">The key insight to solve the problem _efficiently_ is that the formed chain can only be a perfect ring, rather than a ring with tail, as revealed in the solution.\\n\\nFor instance, we can expect the chain like:     0 --> 3 --> 1 --> 2 --> 0. \\nWe would never have the chain with loop as:  0 --> 3 --> 1 --> 3\\n\\nYet, the reason behind the insight is not clear. \\n\\nHere is a simple reasoning about the above insight.\\n\\nFor each of the edge in the chain, we are conecting between an **index** and a **value**, e.g.  for 0 --> 3, it is because `A[0] = 3`\\n\\nAs a result, for a ring with tail, as 0 --> 3 --> 1 --> 3, where there are 3 edges, we can convert them into 3 pairs of `A[index] = value`.  As one will discover that, there would be two pairs with the same value, _i.e._(`A[0] =3` and `A[1]=3`)  due to the loop. \\n\\n_In other words, in the above case, we have two elements in the array that have the same value._ \\n\\nThe above conclusion is **contradicted** to the condition of the array, where each element is unique. \\n\\nVoila. This is the reason why we can never form a ring with tail.\\n\\n#### Graph Theory\\n\\nWe can also view the chain as a **graph**, where each node represents an index in the array. \\nAn incoming edge in the above graph would signify that there would be an element is **assigned** with the value of that node.\\n\\n- For a ring with tail, there would be a node with 2 incoming edges, _i.e._ there would be two elements that are assigned with the same value.  e.g. 0 --> 3 --> 1 --> 3.  Node 3 has two incoming edges.\\n\\n- While for a perfect ring, each node has only one incoming edge, _e.g._ 0 --> 3 --> 1 --> 2 --> 0.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "mosafattah",
                        "content": "Why is the output in the description 6 while the set given has a size 4?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Algo for this question.\\n1. Initialize a visited array of the same length as the input array, filled with zeros.\\n2. Initialize a variable to keep track of the maximum size of the nested subarray, call it \"max_size\".\\n3. Loop through each element of the input array.\\n4. If the current element has already been visited, skip it.\\n5. If the current element has not been visited, use a while loop to follow the nest, incrementing the size of the nest until you reach an element that has already been visited or an element that doesn\\'t belong to the nest.\\n6. Mark all the elements visited in the current nest.\\n7. Update \"max_size\" if the size of the current nest is greater than the current \"max_size\".\\n8. Repeat steps 3 to 7 for each unvisited element in the input array.\\n9. Return \"max_size\"."
                    }
                ]
            },
            {
                "id": 1571982,
                "content": [
                    {
                        "username": "ashraf_roni",
                        "content": "I do not know, how did you handled this case?\\n[0,2,1]\\nA[0] = 0;\\nIs it a problem statement issue I missed?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "it\\'s not necessarily to start with index 0, you can start with any index to get longest length cycle "
                    },
                    {
                        "username": "mkkamleh",
                        "content": "you can start with any index in the beginning, not necessarily 0, then you need to find longest ring      "
                    },
                    {
                        "username": "pacman",
                        "content": "For test case \\n**[0,2,1]**\\noutput?"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "output->2"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "To solve this problem, you can use a visited array to keep track of the elements that have already been processed, and a variable to keep track of the maximum size of a nested subarray. Starting from each unvisited element in the array, you can use a while loop to follow the nest and increment the size until you reach an element that has already been processed or an element that doesn\\'t belong to the nest. The maximum size of a nested subarray can then be updated if the size of the current nest is greater than the current maximum."
                    },
                    {
                        "username": "liaison",
                        "content": ">The key insight to solve the problem _efficiently_ is that the formed chain can only be a perfect ring, rather than a ring with tail, as revealed in the solution.\\n\\nFor instance, we can expect the chain like:     0 --> 3 --> 1 --> 2 --> 0. \\nWe would never have the chain with loop as:  0 --> 3 --> 1 --> 3\\n\\nYet, the reason behind the insight is not clear. \\n\\nHere is a simple reasoning about the above insight.\\n\\nFor each of the edge in the chain, we are conecting between an **index** and a **value**, e.g.  for 0 --> 3, it is because `A[0] = 3`\\n\\nAs a result, for a ring with tail, as 0 --> 3 --> 1 --> 3, where there are 3 edges, we can convert them into 3 pairs of `A[index] = value`.  As one will discover that, there would be two pairs with the same value, _i.e._(`A[0] =3` and `A[1]=3`)  due to the loop. \\n\\n_In other words, in the above case, we have two elements in the array that have the same value._ \\n\\nThe above conclusion is **contradicted** to the condition of the array, where each element is unique. \\n\\nVoila. This is the reason why we can never form a ring with tail.\\n\\n#### Graph Theory\\n\\nWe can also view the chain as a **graph**, where each node represents an index in the array. \\nAn incoming edge in the above graph would signify that there would be an element is **assigned** with the value of that node.\\n\\n- For a ring with tail, there would be a node with 2 incoming edges, _i.e._ there would be two elements that are assigned with the same value.  e.g. 0 --> 3 --> 1 --> 3.  Node 3 has two incoming edges.\\n\\n- While for a perfect ring, each node has only one incoming edge, _e.g._ 0 --> 3 --> 1 --> 2 --> 0.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "mosafattah",
                        "content": "Why is the output in the description 6 while the set given has a size 4?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Algo for this question.\\n1. Initialize a visited array of the same length as the input array, filled with zeros.\\n2. Initialize a variable to keep track of the maximum size of the nested subarray, call it \"max_size\".\\n3. Loop through each element of the input array.\\n4. If the current element has already been visited, skip it.\\n5. If the current element has not been visited, use a while loop to follow the nest, incrementing the size of the nest until you reach an element that has already been visited or an element that doesn\\'t belong to the nest.\\n6. Mark all the elements visited in the current nest.\\n7. Update \"max_size\" if the size of the current nest is greater than the current \"max_size\".\\n8. Repeat steps 3 to 7 for each unvisited element in the input array.\\n9. Return \"max_size\"."
                    }
                ]
            },
            {
                "id": 1789418,
                "content": [
                    {
                        "username": "ashraf_roni",
                        "content": "I do not know, how did you handled this case?\\n[0,2,1]\\nA[0] = 0;\\nIs it a problem statement issue I missed?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "it\\'s not necessarily to start with index 0, you can start with any index to get longest length cycle "
                    },
                    {
                        "username": "mkkamleh",
                        "content": "you can start with any index in the beginning, not necessarily 0, then you need to find longest ring      "
                    },
                    {
                        "username": "pacman",
                        "content": "For test case \\n**[0,2,1]**\\noutput?"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "output->2"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "To solve this problem, you can use a visited array to keep track of the elements that have already been processed, and a variable to keep track of the maximum size of a nested subarray. Starting from each unvisited element in the array, you can use a while loop to follow the nest and increment the size until you reach an element that has already been processed or an element that doesn\\'t belong to the nest. The maximum size of a nested subarray can then be updated if the size of the current nest is greater than the current maximum."
                    },
                    {
                        "username": "liaison",
                        "content": ">The key insight to solve the problem _efficiently_ is that the formed chain can only be a perfect ring, rather than a ring with tail, as revealed in the solution.\\n\\nFor instance, we can expect the chain like:     0 --> 3 --> 1 --> 2 --> 0. \\nWe would never have the chain with loop as:  0 --> 3 --> 1 --> 3\\n\\nYet, the reason behind the insight is not clear. \\n\\nHere is a simple reasoning about the above insight.\\n\\nFor each of the edge in the chain, we are conecting between an **index** and a **value**, e.g.  for 0 --> 3, it is because `A[0] = 3`\\n\\nAs a result, for a ring with tail, as 0 --> 3 --> 1 --> 3, where there are 3 edges, we can convert them into 3 pairs of `A[index] = value`.  As one will discover that, there would be two pairs with the same value, _i.e._(`A[0] =3` and `A[1]=3`)  due to the loop. \\n\\n_In other words, in the above case, we have two elements in the array that have the same value._ \\n\\nThe above conclusion is **contradicted** to the condition of the array, where each element is unique. \\n\\nVoila. This is the reason why we can never form a ring with tail.\\n\\n#### Graph Theory\\n\\nWe can also view the chain as a **graph**, where each node represents an index in the array. \\nAn incoming edge in the above graph would signify that there would be an element is **assigned** with the value of that node.\\n\\n- For a ring with tail, there would be a node with 2 incoming edges, _i.e._ there would be two elements that are assigned with the same value.  e.g. 0 --> 3 --> 1 --> 3.  Node 3 has two incoming edges.\\n\\n- While for a perfect ring, each node has only one incoming edge, _e.g._ 0 --> 3 --> 1 --> 2 --> 0.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "mosafattah",
                        "content": "Why is the output in the description 6 while the set given has a size 4?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Algo for this question.\\n1. Initialize a visited array of the same length as the input array, filled with zeros.\\n2. Initialize a variable to keep track of the maximum size of the nested subarray, call it \"max_size\".\\n3. Loop through each element of the input array.\\n4. If the current element has already been visited, skip it.\\n5. If the current element has not been visited, use a while loop to follow the nest, incrementing the size of the nest until you reach an element that has already been visited or an element that doesn\\'t belong to the nest.\\n6. Mark all the elements visited in the current nest.\\n7. Update \"max_size\" if the size of the current nest is greater than the current \"max_size\".\\n8. Repeat steps 3 to 7 for each unvisited element in the input array.\\n9. Return \"max_size\"."
                    }
                ]
            },
            {
                "id": 1574282,
                "content": [
                    {
                        "username": "ashraf_roni",
                        "content": "I do not know, how did you handled this case?\\n[0,2,1]\\nA[0] = 0;\\nIs it a problem statement issue I missed?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "it\\'s not necessarily to start with index 0, you can start with any index to get longest length cycle "
                    },
                    {
                        "username": "mkkamleh",
                        "content": "you can start with any index in the beginning, not necessarily 0, then you need to find longest ring      "
                    },
                    {
                        "username": "pacman",
                        "content": "For test case \\n**[0,2,1]**\\noutput?"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "output->2"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "To solve this problem, you can use a visited array to keep track of the elements that have already been processed, and a variable to keep track of the maximum size of a nested subarray. Starting from each unvisited element in the array, you can use a while loop to follow the nest and increment the size until you reach an element that has already been processed or an element that doesn\\'t belong to the nest. The maximum size of a nested subarray can then be updated if the size of the current nest is greater than the current maximum."
                    },
                    {
                        "username": "liaison",
                        "content": ">The key insight to solve the problem _efficiently_ is that the formed chain can only be a perfect ring, rather than a ring with tail, as revealed in the solution.\\n\\nFor instance, we can expect the chain like:     0 --> 3 --> 1 --> 2 --> 0. \\nWe would never have the chain with loop as:  0 --> 3 --> 1 --> 3\\n\\nYet, the reason behind the insight is not clear. \\n\\nHere is a simple reasoning about the above insight.\\n\\nFor each of the edge in the chain, we are conecting between an **index** and a **value**, e.g.  for 0 --> 3, it is because `A[0] = 3`\\n\\nAs a result, for a ring with tail, as 0 --> 3 --> 1 --> 3, where there are 3 edges, we can convert them into 3 pairs of `A[index] = value`.  As one will discover that, there would be two pairs with the same value, _i.e._(`A[0] =3` and `A[1]=3`)  due to the loop. \\n\\n_In other words, in the above case, we have two elements in the array that have the same value._ \\n\\nThe above conclusion is **contradicted** to the condition of the array, where each element is unique. \\n\\nVoila. This is the reason why we can never form a ring with tail.\\n\\n#### Graph Theory\\n\\nWe can also view the chain as a **graph**, where each node represents an index in the array. \\nAn incoming edge in the above graph would signify that there would be an element is **assigned** with the value of that node.\\n\\n- For a ring with tail, there would be a node with 2 incoming edges, _i.e._ there would be two elements that are assigned with the same value.  e.g. 0 --> 3 --> 1 --> 3.  Node 3 has two incoming edges.\\n\\n- While for a perfect ring, each node has only one incoming edge, _e.g._ 0 --> 3 --> 1 --> 2 --> 0.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "mosafattah",
                        "content": "Why is the output in the description 6 while the set given has a size 4?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Algo for this question.\\n1. Initialize a visited array of the same length as the input array, filled with zeros.\\n2. Initialize a variable to keep track of the maximum size of the nested subarray, call it \"max_size\".\\n3. Loop through each element of the input array.\\n4. If the current element has already been visited, skip it.\\n5. If the current element has not been visited, use a while loop to follow the nest, incrementing the size of the nest until you reach an element that has already been visited or an element that doesn\\'t belong to the nest.\\n6. Mark all the elements visited in the current nest.\\n7. Update \"max_size\" if the size of the current nest is greater than the current \"max_size\".\\n8. Repeat steps 3 to 7 for each unvisited element in the input array.\\n9. Return \"max_size\"."
                    }
                ]
            },
            {
                "id": 1571856,
                "content": [
                    {
                        "username": "ashraf_roni",
                        "content": "I do not know, how did you handled this case?\\n[0,2,1]\\nA[0] = 0;\\nIs it a problem statement issue I missed?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "it\\'s not necessarily to start with index 0, you can start with any index to get longest length cycle "
                    },
                    {
                        "username": "mkkamleh",
                        "content": "you can start with any index in the beginning, not necessarily 0, then you need to find longest ring      "
                    },
                    {
                        "username": "pacman",
                        "content": "For test case \\n**[0,2,1]**\\noutput?"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "output->2"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "To solve this problem, you can use a visited array to keep track of the elements that have already been processed, and a variable to keep track of the maximum size of a nested subarray. Starting from each unvisited element in the array, you can use a while loop to follow the nest and increment the size until you reach an element that has already been processed or an element that doesn\\'t belong to the nest. The maximum size of a nested subarray can then be updated if the size of the current nest is greater than the current maximum."
                    },
                    {
                        "username": "liaison",
                        "content": ">The key insight to solve the problem _efficiently_ is that the formed chain can only be a perfect ring, rather than a ring with tail, as revealed in the solution.\\n\\nFor instance, we can expect the chain like:     0 --> 3 --> 1 --> 2 --> 0. \\nWe would never have the chain with loop as:  0 --> 3 --> 1 --> 3\\n\\nYet, the reason behind the insight is not clear. \\n\\nHere is a simple reasoning about the above insight.\\n\\nFor each of the edge in the chain, we are conecting between an **index** and a **value**, e.g.  for 0 --> 3, it is because `A[0] = 3`\\n\\nAs a result, for a ring with tail, as 0 --> 3 --> 1 --> 3, where there are 3 edges, we can convert them into 3 pairs of `A[index] = value`.  As one will discover that, there would be two pairs with the same value, _i.e._(`A[0] =3` and `A[1]=3`)  due to the loop. \\n\\n_In other words, in the above case, we have two elements in the array that have the same value._ \\n\\nThe above conclusion is **contradicted** to the condition of the array, where each element is unique. \\n\\nVoila. This is the reason why we can never form a ring with tail.\\n\\n#### Graph Theory\\n\\nWe can also view the chain as a **graph**, where each node represents an index in the array. \\nAn incoming edge in the above graph would signify that there would be an element is **assigned** with the value of that node.\\n\\n- For a ring with tail, there would be a node with 2 incoming edges, _i.e._ there would be two elements that are assigned with the same value.  e.g. 0 --> 3 --> 1 --> 3.  Node 3 has two incoming edges.\\n\\n- While for a perfect ring, each node has only one incoming edge, _e.g._ 0 --> 3 --> 1 --> 2 --> 0.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "mosafattah",
                        "content": "Why is the output in the description 6 while the set given has a size 4?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Algo for this question.\\n1. Initialize a visited array of the same length as the input array, filled with zeros.\\n2. Initialize a variable to keep track of the maximum size of the nested subarray, call it \"max_size\".\\n3. Loop through each element of the input array.\\n4. If the current element has already been visited, skip it.\\n5. If the current element has not been visited, use a while loop to follow the nest, incrementing the size of the nest until you reach an element that has already been visited or an element that doesn\\'t belong to the nest.\\n6. Mark all the elements visited in the current nest.\\n7. Update \"max_size\" if the size of the current nest is greater than the current \"max_size\".\\n8. Repeat steps 3 to 7 for each unvisited element in the input array.\\n9. Return \"max_size\"."
                    }
                ]
            },
            {
                "id": 1789457,
                "content": [
                    {
                        "username": "ashraf_roni",
                        "content": "I do not know, how did you handled this case?\\n[0,2,1]\\nA[0] = 0;\\nIs it a problem statement issue I missed?"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "it\\'s not necessarily to start with index 0, you can start with any index to get longest length cycle "
                    },
                    {
                        "username": "mkkamleh",
                        "content": "you can start with any index in the beginning, not necessarily 0, then you need to find longest ring      "
                    },
                    {
                        "username": "pacman",
                        "content": "For test case \\n**[0,2,1]**\\noutput?"
                    },
                    {
                        "username": "ladnijnama",
                        "content": "output->2"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "To solve this problem, you can use a visited array to keep track of the elements that have already been processed, and a variable to keep track of the maximum size of a nested subarray. Starting from each unvisited element in the array, you can use a while loop to follow the nest and increment the size until you reach an element that has already been processed or an element that doesn\\'t belong to the nest. The maximum size of a nested subarray can then be updated if the size of the current nest is greater than the current maximum."
                    },
                    {
                        "username": "liaison",
                        "content": ">The key insight to solve the problem _efficiently_ is that the formed chain can only be a perfect ring, rather than a ring with tail, as revealed in the solution.\\n\\nFor instance, we can expect the chain like:     0 --> 3 --> 1 --> 2 --> 0. \\nWe would never have the chain with loop as:  0 --> 3 --> 1 --> 3\\n\\nYet, the reason behind the insight is not clear. \\n\\nHere is a simple reasoning about the above insight.\\n\\nFor each of the edge in the chain, we are conecting between an **index** and a **value**, e.g.  for 0 --> 3, it is because `A[0] = 3`\\n\\nAs a result, for a ring with tail, as 0 --> 3 --> 1 --> 3, where there are 3 edges, we can convert them into 3 pairs of `A[index] = value`.  As one will discover that, there would be two pairs with the same value, _i.e._(`A[0] =3` and `A[1]=3`)  due to the loop. \\n\\n_In other words, in the above case, we have two elements in the array that have the same value._ \\n\\nThe above conclusion is **contradicted** to the condition of the array, where each element is unique. \\n\\nVoila. This is the reason why we can never form a ring with tail.\\n\\n#### Graph Theory\\n\\nWe can also view the chain as a **graph**, where each node represents an index in the array. \\nAn incoming edge in the above graph would signify that there would be an element is **assigned** with the value of that node.\\n\\n- For a ring with tail, there would be a node with 2 incoming edges, _i.e._ there would be two elements that are assigned with the same value.  e.g. 0 --> 3 --> 1 --> 3.  Node 3 has two incoming edges.\\n\\n- While for a perfect ring, each node has only one incoming edge, _e.g._ 0 --> 3 --> 1 --> 2 --> 0.\\n\\n\\n\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "mosafattah",
                        "content": "Why is the output in the description 6 while the set given has a size 4?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Algo for this question.\\n1. Initialize a visited array of the same length as the input array, filled with zeros.\\n2. Initialize a variable to keep track of the maximum size of the nested subarray, call it \"max_size\".\\n3. Loop through each element of the input array.\\n4. If the current element has already been visited, skip it.\\n5. If the current element has not been visited, use a while loop to follow the nest, incrementing the size of the nest until you reach an element that has already been visited or an element that doesn\\'t belong to the nest.\\n6. Mark all the elements visited in the current nest.\\n7. Update \"max_size\" if the size of the current nest is greater than the current \"max_size\".\\n8. Repeat steps 3 to 7 for each unvisited element in the input array.\\n9. Return \"max_size\"."
                    }
                ]
            }
        ]
    }
]