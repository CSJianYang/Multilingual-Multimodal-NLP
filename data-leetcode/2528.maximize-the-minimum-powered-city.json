[
    {
        "title": "Maximize the Minimum Powered City",
        "question_content": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\n\tNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.\n&nbsp;\nExample 1:\n\nInput: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.\n\nExample 2:\n\nInput: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4.\n\n&nbsp;\nConstraints:\n\n\tn == stations.length\n\t1 <= n <= 105\n\t0 <= stations[i] <= 105\n\t0 <= r&nbsp;<= n - 1\n\t0 <= k&nbsp;<= 109",
        "solutions": [
            {
                "id": 3014943,
                "title": "c-python-binary-search-sliding-window-greedy-clear-explanation",
                "content": "# Intuition\\n- We can see that:\\n   - If we **increase** the minimum power among cities, then we need **more** additional power stations (Given that we have up to `k` additional power stations).\\n   - If we **decrease** the minimum power among cities, then we need **less** additional power stations (Given that we have up to `k` additional power stations).\\n- So we can **binary search** to find the maximum value of `minimum power among cities` as long as we can use up to `k` additional power stations.\\n- We need to build a function `isGood(minPowerRequired, additionalStations = k)` to test if it\\'s good if we set the minium power among cities are `minPowerRequired`?\\n   - We just iterate on each city, calculate its power, test if the power of all cities are at least `minPowerRequired` given that we have `additionalStations` additional power stations.\\n   - To calculate the power of each city fast, we keep window value to store sum of power stations of cities `[i-r...i+r]`, then just sliding window to calculate for all cities.\\n   - When calculate power of `ith` city, if it\\'s not enough powers then we need some additional powers. \\n      - If `additionalStations` is not enough then `minPowerRequired` is invalid!\\n      - Else it\\'s better to plant additional power station to `i+r`th city **(GREEDY)**, so it cover as much as cities as possible.\\n\\n# Complexity\\n- Time complexity: `O(N * log(SUM_STATION + k))`, where `N <= 10^5` is the number of cities, `SUM_STATION <= 10^10` is sum of stations, `k <= 10^9` is the number of additional power stations.\\n- Space complexity: `O(N)`\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/K2GRasqU/shared\" frameBorder=\"0\" width=\"100%\" height=\"1000\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "# Intuition\\n- We can see that:\\n   - If we **increase** the minimum power among cities, then we need **more** additional power stations (Given that we have up to `k` additional power stations).\\n   - If we **decrease** the minimum power among cities, then we need **less** additional power stations (Given that we have up to `k` additional power stations).\\n- So we can **binary search** to find the maximum value of `minimum power among cities` as long as we can use up to `k` additional power stations.\\n- We need to build a function `isGood(minPowerRequired, additionalStations = k)` to test if it\\'s good if we set the minium power among cities are `minPowerRequired`?\\n   - We just iterate on each city, calculate its power, test if the power of all cities are at least `minPowerRequired` given that we have `additionalStations` additional power stations.\\n   - To calculate the power of each city fast, we keep window value to store sum of power stations of cities `[i-r...i+r]`, then just sliding window to calculate for all cities.\\n   - When calculate power of `ith` city, if it\\'s not enough powers then we need some additional powers. \\n      - If `additionalStations` is not enough then `minPowerRequired` is invalid!\\n      - Else it\\'s better to plant additional power station to `i+r`th city **(GREEDY)**, so it cover as much as cities as possible.\\n\\n# Complexity\\n- Time complexity: `O(N * log(SUM_STATION + k))`, where `N <= 10^5` is the number of cities, `SUM_STATION <= 10^10` is sum of stations, `k <= 10^9` is the number of additional power stations.\\n- Space complexity: `O(N)`\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/K2GRasqU/shared\" frameBorder=\"0\" width=\"100%\" height=\"1000\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3014915,
                "title": "binary-search-solution-with-proper-explanation",
                "content": "<h3 >Approach</h3>\\n<p >We will do a binary search for the solution.</p>\\n<p >At first, we will calculate the current power for each city. We can do it using cumulative sum.</p>\\n<p>Suppose we want our minimum value to be <strong>mid</strong>. Now we iterate over the array. There can be two cases for each city <strong>i</strong>:</p><ul id=\"d493aa24-851b-459b-9e79-b0a7e81ed844\" class=\"bulleted-list\"><li style=\"list-style-type:disc\">The power of the city is greater than or equal to mid. In this case, we don\\u2019t need to do anything.</li></ul><ul class=\"bulleted-list\"><li style=\"list-style-type:disc\">The power of the city is less than the mid. Now we need to place some power stations. \\nHow many stations do we put? We need to place <strong>mid - power[i]</strong> stations. \\n<strong>Now, where do we put these stations?</strong> Here comes the actual observation. If we are at city i, we can say that all the cities from 0 to i-1 already have a power\\u2265 mid. Hence, we don\\u2019t need to place any station that updates them. But we don\\u2019t know the information about the upcoming cities. So, we should place the stations in a place that can update as many cities as possible on the right side. If we place the stations in city <strong>i+r, </strong>it will update the current position and the maximum number of positions on the right side. In summary, <strong>place max (0, mid - power[i]) stations in i+r city and update the range.</strong></li></ul><p >In implementation, we need to maintain a cumulative array in the binary search to get the current power of any city after updates.</p>\\n</p></div>\\n<h3>Code</h3>\\n\\n\\n    using ll = long long;\\n    class Solution {\\n    public:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        \\n        int n = stations.size();\\n        vector<ll>a(n+1);\\n        for(int i=0;i<n;i++){\\n            int l = max(i-r,0);\\n            int x = min(i+r,n-1);\\n            a[l]+=1ll*stations[i];\\n            a[x+1]-=1ll*stations[i];\\n            \\n        }\\n        \\n        \\n        for(int i=1;i<n;i++) a[i]+=a[i-1];\\n        \\n        long long hi = LLONG_MAX, lo = 0;\\n        long long ans = 0;\\n        \\n        while(lo<=hi){\\n            long long mid = lo+(hi-lo)/2; // this technique avoids overflow.\\n            \\n            vector<long long> add(n+1); // the array to maintain all updates.\\n            \\n            long long rem = k; // number of stations we can place.\\n            for(int i=0;i<n;i++){\\n                \\n                if(i)add[i]+=add[i-1];\\n                ll got = a[i]+add[i];\\n                \\n                if(got<mid){\\n                    long long need = mid-got;\\n                    rem-=need;\\n                    if(rem<0) break;\\n                    int j = min(i+r+r,n-1);\\n                    add[i]+=need;\\n                    add[j+1]-=need;\\n                }\\n            }\\n            if(rem>=0){\\n                ans = mid;\\n                lo = mid+1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        \\n        int n = stations.size();\\n        vector<ll>a(n+1);\\n        for(int i=0;i<n;i++){\\n            int l = max(i-r,0);\\n            int x = min(i+r,n-1);\\n            a[l]+=1ll*stations[i];\\n            a[x+1]-=1ll*stations[i];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3015103,
                "title": "video-explanation-building-solution-from-scratch",
                "content": "## Explanation\\n\\nhttps://www.youtube.com/watch?v=DxdIQ09YrP4\\n\\n[Click here if the preview doesn\\'t work](https://www.youtube.com/watch?v=DxdIQ09YrP4)\\n\\n## Code\\n```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    \\n    bool IsPossible (ll min_power, const vector<ll>& default_powers, int extra_stations, int r, int num_stations) {\\n        vector<ll> extra_power (num_stations+1);\\n        \\n        for (int j = 0; j < num_stations; j ++) {\\n            extra_power[j] += (j > 0? extra_power[j-1] : 0);\\n            \\n            ll cur_power = default_powers[j] + extra_power[j];\\n            ll required = max (0LL, min_power - cur_power);\\n            if (required == 0) continue;\\n            \\n            if (required > extra_stations) return false;\\n            extra_stations -= required;\\n            \\n            extra_power[j] += required;\\n            extra_power[min(num_stations, j+2*r+1)] -= required;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    long long maxPower(vector<int>& stations, int range, int k) {\\n        int n = stations.size();\\n     \\n        vector<ll> station_powers(n+1);\\n        for (int j = 0; j < n; j ++) {\\n            station_powers[max(0, j-range)] += stations[j];\\n            station_powers[min(n, j+range+1)] -= stations[j];\\n        }\\n        for (int j = 1; j <= n; j ++) station_powers[j] += station_powers[j-1];\\n        \\n        ll l = 0, r = 1e11;\\n        while (l < r) {\\n            ll m = (l+r) >> 1;\\n            \\n            if (IsPossible (m+1, station_powers, k, range, n)) l = m+1;\\n            else r = m;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    \\n    bool IsPossible (ll min_power, const vector<ll>& default_powers, int extra_stations, int r, int num_stations) {\\n        vector<ll> extra_power (num_stations+1);\\n        \\n        for (int j = 0; j < num_stations; j ++) {\\n            extra_power[j] += (j > 0? extra_power[j-1] : 0);\\n            \\n            ll cur_power = default_powers[j] + extra_power[j];\\n            ll required = max (0LL, min_power - cur_power);\\n            if (required == 0) continue;\\n            \\n            if (required > extra_stations) return false;\\n            extra_stations -= required;\\n            \\n            extra_power[j] += required;\\n            extra_power[min(num_stations, j+2*r+1)] -= required;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    long long maxPower(vector<int>& stations, int range, int k) {\\n        int n = stations.size();\\n     \\n        vector<ll> station_powers(n+1);\\n        for (int j = 0; j < n; j ++) {\\n            station_powers[max(0, j-range)] += stations[j];\\n            station_powers[min(n, j+range+1)] -= stations[j];\\n        }\\n        for (int j = 1; j <= n; j ++) station_powers[j] += station_powers[j-1];\\n        \\n        ll l = 0, r = 1e11;\\n        while (l < r) {\\n            ll m = (l+r) >> 1;\\n            \\n            if (IsPossible (m+1, station_powers, k, range, n)) l = m+1;\\n            else r = m;\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015105,
                "title": "c-python3-explained-why-binary-search",
                "content": "# Why Binary search?\\n\\nIts a question that is **based on a certain pattern**. It is hard to come up with binary search without any hints if one hasn\\'t ever solved a question of similar pattern. But once you have solved it then it is trivial to come up with this solution.\\n\\nBut let\\'s say worst case scenario you hadn\\'t solved this pattern, a **bruteforce** solution that may come to your mind is let me try all possible values of my final answer (minimum power in this question) and check if it is possible to have this value. We will linearly check the values and see if it satisfies the condition. If it doesn\\'t, return the previous value since we want the maximum that does satisfy.\\n\\nNow a point to observe here in this particular question is, if a value \"x\" does not satisfies the condition, then neither will x+1 or x+2 and so on. This is where binary search comes to play. We try a value and if it doesn\\'t satisfy, we can reduce our search space to the left half. If it does satisfy then we want to find a bigger value so move to right half (pretty much like a normal binary search). \\n\\n# Tricks to identify that may work sometimes\\n1. When the question asks to return **maximum minimum value**. It doesn\\'t work all the time so don\\'t rely on it.\\n2. If you are thinking of applying DP but the constrains are too big.\\n3. Possible value of answer is an integer and lies between 1 and some big number (like $$10^{9}$$).\\n\\n# Intuition\\nBinary search on possible values of power and check if this value is possible to have.\\n\\n# Approach\\n1. I used binary search to try out different values of power.\\n2. To verify if this value of power is possible, we keep a track of cur_power as a sum of sliding window.\\n3. If the power is less we check if we have enough towers\\n    - If not we return False.\\n    - If yes, then we increase the power of rightmost tower in our window so that maximum cities benefit from it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(NlogN)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# If this post helped, please do upvote : )\\n\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        long long right = LLONG_MAX, left = 0;\\n        long long best = 0;\\n        \\n        while(left<=right){\\n            long long mid = left+(right-left)/2;\\n            if(isPossible(mid,stations,r,k)){\\n                best = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        }\\n        return best;\\n    }\\n    \\n\\n\\n    bool isPossible(long long min_power, vector<int> stations, int r, int k){\\n        long long cur_power = 0,power_needed=0;\\n        int n = stations.size();\\n        for (int i = 0; i <= r; i++) cur_power += stations[i];\\n\\n        int left = 0, right = r;\\n        for (int i = 0; i < n; i++){\\n            if (i-left>r){\\n                cur_power -= stations[left];\\n                left ++;\\n            }\\n            if (right-i<r and right<n-1){\\n                right ++;\\n                cur_power += stations[right];\\n            }\\n\\n            if (cur_power < min_power){\\n                power_needed = min_power-cur_power;\\n                if (k<power_needed) return false;\\n                stations[right] += power_needed;\\n                cur_power += power_needed;\\n                k -= power_needed;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        best = min(stations)\\n        left,right = 0,10**12\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            \\n            if self.isPossible(mid,stations[:],r,k):\\n                left = mid+1\\n                best = mid\\n            else:\\n                right = mid - 1\\n        return best\\n    \\n    def isPossible(self,min_power,stations,r,k):\\n        cur_power = 0\\n        for i in range(r+1):\\n            cur_power += stations[i]\\n        \\n        left,right = 0,r\\n        for i in range(0,len(stations)):\\n            if i-left>r:\\n                cur_power -= stations[left]\\n                left+=1\\n            if right-i<r and right<len(stations)-1:\\n                right+=1\\n                cur_power += stations[right]\\n                \\n            if cur_power < min_power:\\n                power_needed = min_power-cur_power\\n                if k<power_needed: return False\\n                stations[right] += power_needed\\n                cur_power += power_needed\\n                k-=power_needed\\n        return True\\n            \\n```\\n\\n***[This](https://leetcode.com/list/o2pr208d) is a list of similar questions. See if you can come up with a binary search approach for them. Good luck : )***\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Binary Search",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        long long right = LLONG_MAX, left = 0;\\n        long long best = 0;\\n        \\n        while(left<=right){\\n            long long mid = left+(right-left)/2;\\n            if(isPossible(mid,stations,r,k)){\\n                best = mid;\\n                left = mid+1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        }\\n        return best;\\n    }\\n    \\n\\n\\n    bool isPossible(long long min_power, vector<int> stations, int r, int k){\\n        long long cur_power = 0,power_needed=0;\\n        int n = stations.size();\\n        for (int i = 0; i <= r; i++) cur_power += stations[i];\\n\\n        int left = 0, right = r;\\n        for (int i = 0; i < n; i++){\\n            if (i-left>r){\\n                cur_power -= stations[left];\\n                left ++;\\n            }\\n            if (right-i<r and right<n-1){\\n                right ++;\\n                cur_power += stations[right];\\n            }\\n\\n            if (cur_power < min_power){\\n                power_needed = min_power-cur_power;\\n                if (k<power_needed) return false;\\n                stations[right] += power_needed;\\n                cur_power += power_needed;\\n                k -= power_needed;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        best = min(stations)\\n        left,right = 0,10**12\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            \\n            if self.isPossible(mid,stations[:],r,k):\\n                left = mid+1\\n                best = mid\\n            else:\\n                right = mid - 1\\n        return best\\n    \\n    def isPossible(self,min_power,stations,r,k):\\n        cur_power = 0\\n        for i in range(r+1):\\n            cur_power += stations[i]\\n        \\n        left,right = 0,r\\n        for i in range(0,len(stations)):\\n            if i-left>r:\\n                cur_power -= stations[left]\\n                left+=1\\n            if right-i<r and right<len(stations)-1:\\n                right+=1\\n                cur_power += stations[right]\\n                \\n            if cur_power < min_power:\\n                power_needed = min_power-cur_power\\n                if k<power_needed: return False\\n                stations[right] += power_needed\\n                cur_power += power_needed\\n                k-=power_needed\\n        return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014952,
                "title": "c-java-python3-binary-search-sliding-window-with-comment",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. Notice \"Maximize the Minimum\", obviously binary searching on the value domain should be considered.\\n2. When checking, traverse from $0$ to $n-1$ and count how many power stations are missing for each city.\\n3. Obviously, if a city is found to lack a power station, it should be greedily placed in the rightmost city which can heat it.\\n\\n# Approach\\n1. Binary search for result. Notice the maximum possible value will not exceed $k+\\\\sum_{i=0}^{n-1}stations[i]$, binary search in this range. Each time, check if $k$ is sufficient.\\n2. Use a sliding window to maintain the number of power stations the current city has.\\n3. Each time, city $i+r$ may be added, while city $i-r-1$ may be removed. \\n\\n**Additional, I found that the same Python code accepted in [LeetCode CN](https://leetcode.cn/problems/maximize-the-minimum-powered-city/submissions/393714497/), but TLE in [LeetCode US](https://leetcode.com/contest/biweekly-contest-95/submissions/detail/873396839/).** \\n\\n**Interesting.**\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log (k+\\\\sum_{i=0}^{n-1}stations[i]))$\\n- Space complexity: $O(n)$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        long long left = 0;\\n        long long right = k + accumulate(stations.begin(), stations.end(), 0ll);\\n        // v is the stations after adding\\n        vector<long long> v(n);\\n        while (left <= right) {\\n            long long x = (left + right) / 2;\\n            for (int i = 0; i < n; ++i) v[i] = stations[i];\\n            long long use = 0;\\n            // s maintains the power of city i\\n            // at first, it record the sum of v[0,r)\\n            long long s = accumulate(stations.begin(), stations.begin() + r, 0ll);\\n            for (int i = 0; i < n; ++i) {\\n                // add to t if needed\\n                int t = min(n - 1, i + r);\\n                // update s\\n                // find a city should be added\\n                if (i + r < n) s += v[i + r];\\n                // find a city should be removed\\n                if (i - r > 0) s -= v[i - r - 1];\\n                // mising power stations\\n                long long diff = max(0ll, x - s);\\n                v[t] += diff;\\n                s += diff;\\n                use += diff;\\n            }\\n            if (use <= k) left = x + 1;\\n            else right = x - 1;\\n        }\\n        return right;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length;\\n        long left = 0, right = k;\\n        for (int x: stations)\\n            right += x;\\n        // v is the stations after adding\\n        long []v = new long[n];\\n        while (left <= right) {\\n            long x = (left + right) / 2;\\n            for (int i = 0; i < n; ++i) \\n                v[i] = stations[i];\\n            // s means the power of city i\\n            // at first, it record the sum of v[0,r)\\n            long s = 0, use = 0;\\n            for (int i = 0; i < r; ++i) \\n                s += v[i];\\n            for (int i = 0; i < n; ++i) {\\n                // add to t if needed\\n                int t = Math.min(n - 1, i + r);\\n                // update s\\n                // find a city should be added\\n                if (i + r < n) s += v[i + r];\\n                // find a city should be removed\\n                if (i - r > 0) s -= v[i - r - 1];\\n                // mising power stations\\n                long diff = Math.max(0, x - s);\\n                v[t] += diff;\\n                s += diff;\\n                use += diff;\\n            }\\n            if (use <= k) left = x + 1;\\n            else right = x - 1;\\n        }\\n        return right;\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        left, right = 0, k + sum(stations)\\n        while left <= right:\\n            x = (left + right) // 2\\n            use = 0\\n            # v is the stations after adding\\n            v = stations.copy()\\n            # s means the power of city i\\n            # at first, it record the sum of v[0,r)\\n            s = sum(stations[0: r])\\n            for i in range(n):\\n                # add to t if needed\\n                t = n - 1 if n - 1 < i + r else i + r\\n                # update s\\n                # find a city should be added\\n                if i + r < n: s += v[i+r]\\n                # find a city should be removed\\n                if i - r > 0: s -= v[i-r-1]\\n                # mising power stations\\n                diff = x - s if x - s > 0 else 0 \\n                v[t] += diff\\n                s += diff\\n                use += diff\\n            \\n            if use <= k:\\n                left = x + 1\\n            else:\\n                right = x - 1\\n        return right\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        long long left = 0;\\n        long long right = k + accumulate(stations.begin(), stations.end(), 0ll);\\n        // v is the stations after adding\\n        vector<long long> v(n);\\n        while (left <= right) {\\n            long long x = (left + right) / 2;\\n            for (int i = 0; i < n; ++i) v[i] = stations[i];\\n            long long use = 0;\\n            // s maintains the power of city i\\n            // at first, it record the sum of v[0,r)\\n            long long s = accumulate(stations.begin(), stations.begin() + r, 0ll);\\n            for (int i = 0; i < n; ++i) {\\n                // add to t if needed\\n                int t = min(n - 1, i + r);\\n                // update s\\n                // find a city should be added\\n                if (i + r < n) s += v[i + r];\\n                // find a city should be removed\\n                if (i - r > 0) s -= v[i - r - 1];\\n                // mising power stations\\n                long long diff = max(0ll, x - s);\\n                v[t] += diff;\\n                s += diff;\\n                use += diff;\\n            }\\n            if (use <= k) left = x + 1;\\n            else right = x - 1;\\n        }\\n        return right;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length;\\n        long left = 0, right = k;\\n        for (int x: stations)\\n            right += x;\\n        // v is the stations after adding\\n        long []v = new long[n];\\n        while (left <= right) {\\n            long x = (left + right) / 2;\\n            for (int i = 0; i < n; ++i) \\n                v[i] = stations[i];\\n            // s means the power of city i\\n            // at first, it record the sum of v[0,r)\\n            long s = 0, use = 0;\\n            for (int i = 0; i < r; ++i) \\n                s += v[i];\\n            for (int i = 0; i < n; ++i) {\\n                // add to t if needed\\n                int t = Math.min(n - 1, i + r);\\n                // update s\\n                // find a city should be added\\n                if (i + r < n) s += v[i + r];\\n                // find a city should be removed\\n                if (i - r > 0) s -= v[i - r - 1];\\n                // mising power stations\\n                long diff = Math.max(0, x - s);\\n                v[t] += diff;\\n                s += diff;\\n                use += diff;\\n            }\\n            if (use <= k) left = x + 1;\\n            else right = x - 1;\\n        }\\n        return right;\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        left, right = 0, k + sum(stations)\\n        while left <= right:\\n            x = (left + right) // 2\\n            use = 0\\n            # v is the stations after adding\\n            v = stations.copy()\\n            # s means the power of city i\\n            # at first, it record the sum of v[0,r)\\n            s = sum(stations[0: r])\\n            for i in range(n):\\n                # add to t if needed\\n                t = n - 1 if n - 1 < i + r else i + r\\n                # update s\\n                # find a city should be added\\n                if i + r < n: s += v[i+r]\\n                # find a city should be removed\\n                if i - r > 0: s -= v[i-r-1]\\n                # mising power stations\\n                diff = x - s if x - s > 0 else 0 \\n                v[t] += diff\\n                s += diff\\n                use += diff\\n            \\n            if use <= k:\\n                left = x + 1\\n            else:\\n                right = x - 1\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015292,
                "title": "c-binary-search-sliding-window-solution",
                "content": "\\n\\n# Approach\\nIt uses binary search and sliding window\\nHere it is important to use long long data type to avoid integer overflow\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long  mid , vector<long long>  ans, int r , int k){\\n        long long sum=0;\\n        int n=ans.size();\\n        for(int i=0;i<r;i++)\\n            sum+=ans[i];\\n        for(int i=0;i<n;i++){\\n            sum+=((i+r<=n-1)?ans[i+r]:0)-((i-r-1>=0)?ans[i-r-1]:0);\\n            if(sum<mid){\\n                    if(mid-sum>k)\\n                        return false;\\n                if(i+r<=n-1)ans[i+r]+=mid-sum;\\n                k-=mid-sum;\\n                sum=mid;\\n            }\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        long long  l=0;\\n        long long h=k;\\n        int n=stations.size();\\n        for(int i=0;i<n;i++)\\n            h+=1LL*stations[i];\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++)\\n            ans[i]=stations[i];\\n        while(l<h){\\n            long long  mid=h+(l-h)/2;\\n            if(check(mid,ans,r,k))\\n                l=mid;\\n            else\\n                h=mid-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long  mid , vector<long long>  ans, int r , int k){\\n        long long sum=0;\\n        int n=ans.size();\\n        for(int i=0;i<r;i++)\\n            sum+=ans[i];\\n        for(int i=0;i<n;i++){\\n            sum+=((i+r<=n-1)?ans[i+r]:0)-((i-r-1>=0)?ans[i-r-1]:0);\\n            if(sum<mid){\\n                    if(mid-sum>k)\\n                        return false;\\n                if(i+r<=n-1)ans[i+r]+=mid-sum;\\n                k-=mid-sum;\\n                sum=mid;\\n            }\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        long long  l=0;\\n        long long h=k;\\n        int n=stations.size();\\n        for(int i=0;i<n;i++)\\n            h+=1LL*stations[i];\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++)\\n            ans[i]=stations[i];\\n        while(l<h){\\n            long long  mid=h+(l-h)/2;\\n            if(check(mid,ans,r,k))\\n                l=mid;\\n            else\\n                h=mid-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014899,
                "title": "python-binary-search-video-solution",
                "content": "I have explained the complete solution [here](https://youtu.be/E6aEq7V9TDk).\\n\\n# Intuition\\nThis is a problem to maximize, so Binary Search is a candidate pattern.\\nGiven an answer, we can reverse cross-check too if it is valid or not.\\n\\n# Logic\\n**Min ans** can obviously be the min. of array\\n\\n**Max ans** can be `sum(stations) + K`\\n\\nSince, the power of a city is a range from `city - r` to `city + r`, we can keep a Sliding Window.\\n\\nFor handling, corner cases, so as not to exceed length of array, \\nlet\\'s add bunch of `0s` to both left & right.\\n\\n`stations = [0]*r + stations + [0]*r`\\n\\nInitially, our window will be sum of stations (`0` to `r-1`)\\n\\nWe\\'ll start from  stations `0` ( currently index `r` in array) and add `station[ind+r` to the window.\\n\\nWe\\'ll see if there is a deficiency we\\'ll try to use stations from our `available` stations and decrease the `available` accordingly.\\n\\nIt makes sense, to add the power to `ind+r` because, hence it will be available for the next `2r` cities. This is the most optimal.\\n\\nWe also have to keep track that `diff` was added to the `ind+r` city.\\nSo, when this city goes out of range, we decrease it from `window`.\\n\\n**Time:** `O(N.log(sum(N))`\\n**Space:** `O(N)`\\n\\nIf this was helpful, please Upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        lo = min(stations)\\n        hi = max(stations) * len(stations) + k\\n        \\n        # Adding bunch of (r+1) 0s to left, and (r) 0s to right for handling corner cases.\\n        stations = [0]*(r) + stations + [0]*r\\n        res = lo\\n        \\n        def check(med):\\n            available = k\\n            ind = r                         # ind of our first city\\n            \\n            window = sum(stations[:2*r])    # Sliding window will store power of stations for city\\n                                            # initially it will have values from 0th station to (r-1) stn\\n            \\n\\t\\t\\t# This will store, in which city we have added station because of deficiency. \\n\\t\\t\\t# Because we need to remove that val when that city is out of range.\\n            added = defaultdict(int)        \\n                                            \\n            while ind < len(stations)-r:\\n                window += stations[ind + r]\\n                \\n                if window < med:\\n                    diff = med-window\\n                    if diff>available:\\n                        return False\\n                    window+=diff\\n                    added[ind+r]=diff \\n                    available-=diff\\n\\t\\t\\t\\t\\t\\n                window -= (stations[ind - r] + added[ind-r])\\n                ind+=1\\n            return True\\n        \\n        while lo<=hi:                       # Typical Binary Search\\n            m = (lo + hi )//2\\n            if check(m):\\n                res = m\\n                lo = m + 1\\n            else:\\n                hi = m-1\\n        return res",
                "solutionTags": [
                    "Python3",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "I have explained the complete solution [here](https://youtu.be/E6aEq7V9TDk).\\n\\n# Intuition\\nThis is a problem to maximize, so Binary Search is a candidate pattern.\\nGiven an answer, we can reverse cross-check too if it is valid or not.\\n\\n# Logic\\n**Min ans** can obviously be the min. of array\\n\\n**Max ans** can be `sum(stations) + K`\\n\\nSince, the power of a city is a range from `city - r` to `city + r`, we can keep a Sliding Window.\\n\\nFor handling, corner cases, so as not to exceed length of array, \\nlet\\'s add bunch of `0s` to both left & right.\\n\\n`stations = [0]*r + stations + [0]*r`\\n\\nInitially, our window will be sum of stations (`0` to `r-1`)\\n\\nWe\\'ll start from  stations `0` ( currently index `r` in array) and add `station[ind+r` to the window.\\n\\nWe\\'ll see if there is a deficiency we\\'ll try to use stations from our `available` stations and decrease the `available` accordingly.\\n\\nIt makes sense, to add the power to `ind+r` because, hence it will be available for the next `2r` cities. This is the most optimal.\\n\\nWe also have to keep track that `diff` was added to the `ind+r` city.\\nSo, when this city goes out of range, we decrease it from `window`.\\n\\n**Time:** `O(N.log(sum(N))`\\n**Space:** `O(N)`\\n\\nIf this was helpful, please Upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        lo = min(stations)\\n        hi = max(stations) * len(stations) + k\\n        \\n        # Adding bunch of (r+1) 0s to left, and (r) 0s to right for handling corner cases.\\n        stations = [0]*(r) + stations + [0]*r\\n        res = lo\\n        \\n        def check(med):\\n            available = k\\n            ind = r                         # ind of our first city\\n            \\n            window = sum(stations[:2*r])    # Sliding window will store power of stations for city\\n                                            # initially it will have values from 0th station to (r-1) stn\\n            \\n\\t\\t\\t# This will store, in which city we have added station because of deficiency. \\n\\t\\t\\t# Because we need to remove that val when that city is out of range.\\n            added = defaultdict(int)        \\n                                            \\n            while ind < len(stations)-r:\\n                window += stations[ind + r]\\n                \\n                if window < med:\\n                    diff = med-window\\n                    if diff>available:\\n                        return False\\n                    window+=diff\\n                    added[ind+r]=diff \\n                    available-=diff\\n\\t\\t\\t\\t\\t\\n                window -= (stations[ind - r] + added[ind-r])\\n                ind+=1\\n            return True\\n        \\n        while lo<=hi:                       # Typical Binary Search\\n            m = (lo + hi )//2\\n            if check(m):\\n                res = m\\n                lo = m + 1\\n            else:\\n                hi = m-1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3177796,
                "title": "binary-search",
                "content": "I got stuck trying to find a greedy method, and the binary search did not occur to me :(\\n\\nWe binary-search for a maximum minimum power `m`.\\n\\nFor each power `m`, we check if we can achieve that power with up to `k` new power stations in O(n).\\n\\nWe track the current `power` using the sliding window.\\n\\nIf a city `i` is underpowered (`power < m`), we place `m - power` new plants at point `i + r`.\\n\\n**C++**\\n```cpp\\nlong long maxPower(vector<int>& s, int r, int k) {\\n    long long n = s.size(), l = 0, h = 11000000000LL;\\n    long long st_pwr = accumulate(begin(s), begin(s) + r, 0LL);\\n    vector<long long> ps(n + 1);\\n    while (l < h) {\\n        long long m = (l + h + 1) / 2, build = 0, power = st_pwr;\\n        for (int i = 0; i < n && build <= k; ++i) {\\n            power += i + r < n ? s[i + r] : 0;\\n            power -= i > r ? ps[i - r - 1] + s[i - r - 1] : 0;\\n            if (i + r < n)\\n                ps[i + r] = max(0LL, m - power);\\n            build += max(0LL, m - power);\\n            power += max(0LL, m - power);\\n        }\\n        if (build > k)\\n            h = m - 1;\\n        else\\n            l = m;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long maxPower(vector<int>& s, int r, int k) {\\n    long long n = s.size(), l = 0, h = 11000000000LL;\\n    long long st_pwr = accumulate(begin(s), begin(s) + r, 0LL);\\n    vector<long long> ps(n + 1);\\n    while (l < h) {\\n        long long m = (l + h + 1) / 2, build = 0, power = st_pwr;\\n        for (int i = 0; i < n && build <= k; ++i) {\\n            power += i + r < n ? s[i + r] : 0;\\n            power -= i > r ? ps[i - r - 1] + s[i - r - 1] : 0;\\n            if (i + r < n)\\n                ps[i + r] = max(0LL, m - power);\\n            build += max(0LL, m - power);\\n            power += max(0LL, m - power);\\n        }\\n        if (build > k)\\n            h = m - 1;\\n        else\\n            l = m;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3014973,
                "title": "c-solution-using-binary-serach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int>&nums,int r,int k,long long mid)\\n    {\\n        int n=nums.size();\\n        vector<long long>prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=max(0,i-r);\\n            int right=min(n-1,i+r);\\n            \\n            prefix[left]+=nums[i];\\n            if(right+1<n)\\n            {\\n                prefix[right+1]-=nums[i];\\n            }\\n        }\\n        long long sum=0;\\n        long long count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=prefix[i];\\n            if(sum<mid)\\n            {\\n                long long extra=mid-sum;\\n                if(extra>k)\\n                {\\n                    return false;\\n                }\\n                k-=extra;\\n                sum+=extra;\\n                if((i+2*r+1)<n)\\n                {\\n                    prefix[i+2*r+1]-=extra;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>&nums, int R, int K) \\n    {\\n        long long ans=0;\\n        long long l=0;\\n        long long r=1e18;\\n        while(l<=r)\\n        {\\n            long long mid=(l+r)/2;\\n            if(find(nums,R,K,mid))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int>&nums,int r,int k,long long mid)\\n    {\\n        int n=nums.size();\\n        vector<long long>prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=max(0,i-r);\\n            int right=min(n-1,i+r);\\n            \\n            prefix[left]+=nums[i];\\n            if(right+1<n)\\n            {\\n                prefix[right+1]-=nums[i];\\n            }\\n        }\\n        long long sum=0;\\n        long long count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=prefix[i];\\n            if(sum<mid)\\n            {\\n                long long extra=mid-sum;\\n                if(extra>k)\\n                {\\n                    return false;\\n                }\\n                k-=extra;\\n                sum+=extra;\\n                if((i+2*r+1)<n)\\n                {\\n                    prefix[i+2*r+1]-=extra;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>&nums, int R, int K) \\n    {\\n        long long ans=0;\\n        long long l=0;\\n        long long r=1e18;\\n        while(l<=r)\\n        {\\n            long long mid=(l+r)/2;\\n            if(find(nums,R,K,mid))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040986,
                "title": "sweep-line-binary-search",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N*logN)\\n\\n- Space complexity:\\nO(N*logN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long mid,vector<long long> &psum,int r,int k)\\n    {\\n        vector<long long> a(psum.size()+1,0);\\n        long long j=(r*2)+1;\\n        long long sum=0;\\n        for(int i=0;i<psum.size();i++)\\n        {\\n            sum+=a[i];\\n            if(psum[i]+sum<mid)\\n            {\\n                long long needed=mid-(psum[i]+sum);\\n                if(needed>k)return false;\\n                k-=needed;\\n                sum+=needed;\\n                if(i+j<psum.size())a[i+j]+=(-needed);\\n            }\\n\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& s, int r, int k) {\\n        if(s.size()==1)return s[0]+k;\\n        int n=s.size();\\n        vector<long long> psum(s.size(),0);\\n        long long ri=0,l=0;\\n        for(int i=0;i<r;i++)ri+=s[i];\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i+r<n)ri+=s[i+r];\\n            psum[i]+=ri+l;\\n            if(i>=r)l-=s[i-r];\\n            l+=s[i];\\n            ri-=s[i];\\n        }\\n        long long low=0,high=1e10+1e9+1,mid=0;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            bool flag=check(mid,psum,r,k);\\n            if(flag)\\n            {\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long mid,vector<long long> &psum,int r,int k)\\n    {\\n        vector<long long> a(psum.size()+1,0);\\n        long long j=(r*2)+1;\\n        long long sum=0;\\n        for(int i=0;i<psum.size();i++)\\n        {\\n            sum+=a[i];\\n            if(psum[i]+sum<mid)\\n            {\\n                long long needed=mid-(psum[i]+sum);\\n                if(needed>k)return false;\\n                k-=needed;\\n                sum+=needed;\\n                if(i+j<psum.size())a[i+j]+=(-needed);\\n            }\\n\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& s, int r, int k) {\\n        if(s.size()==1)return s[0]+k;\\n        int n=s.size();\\n        vector<long long> psum(s.size(),0);\\n        long long ri=0,l=0;\\n        for(int i=0;i<r;i++)ri+=s[i];\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(i+r<n)ri+=s[i+r];\\n            psum[i]+=ri+l;\\n            if(i>=r)l-=s[i-r];\\n            l+=s[i];\\n            ri-=s[i];\\n        }\\n        long long low=0,high=1e10+1e9+1,mid=0;\\n        long long ans=0;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            bool flag=check(mid,psum,r,k);\\n            if(flag)\\n            {\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031291,
                "title": "java-easiest-approach-binary-search-on-answer-sliding-window-greedy",
                "content": "**Intuition**\\nWhen they say maximum, *Binary Search On Answer* comes to mind. You just need to figure out the check function.\\nIf you see the problem basically boils down to, find maximum of minimum subarray sum of length >= r+1.\\nSo suppose you calculate a sum and it is smaller than mid of BS. What is the optimal place to add the difference between sum-mid?\\nIf you figure that out, the question is solved.\\n\\n**Approach**\\nIt uses binary search and sliding window\\nHere it is important to use long data type to avoid integer overflow\\n\\n**Time complexity:**\\nO(nlog(n))\\n\\nSpace complexity:\\nO(n)\\n\\n\\n\\n**Code**\\n```\\nclass Solution {\\n    boolean check(int[] stations, long mid, int r, int k){\\n        long sum=0;\\n        int n=stations.length;\\n        long[] ans = new long[n];\\n            for(int i=0;i<n;i++)\\n            ans[i]=stations[i];\\n        \\n        for(int i=0;i<r;i++)\\n            sum+=ans[i];\\n        for(int i=0;i<n;i++){\\n            sum+=((i+r<=n-1)?ans[i+r]:0)-((i-r-1>=0)?ans[i-r-1]:0); //sliding window\\n            if(sum<mid){\\n                    if((mid-sum)>k)\\n                        return false;\\n                if(i+r<=n-1) ans[i+r]+=(mid-sum); //greedy\\n                k-=(mid-sum);\\n                sum=mid;\\n            }\\n        }\\n        return true;\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n        long l=0;\\n        long h=k;\\n        int n=stations.length;\\n        for(int i=0;i<n;i++)\\n            h+=(long)stations[i];\\n\\t\\t\\t\\n        // Binary Search on ans\\n        while(l<h){\\n            long mid=h+(l-h)/2;\\n            if(check(stations,mid,r,k)) l=mid;\\n            else h=mid-1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    boolean check(int[] stations, long mid, int r, int k){\\n        long sum=0;\\n        int n=stations.length;\\n        long[] ans = new long[n];\\n            for(int i=0;i<n;i++)\\n            ans[i]=stations[i];\\n        \\n        for(int i=0;i<r;i++)\\n            sum+=ans[i];\\n        for(int i=0;i<n;i++){\\n            sum+=((i+r<=n-1)?ans[i+r]:0)-((i-r-1>=0)?ans[i-r-1]:0); //sliding window\\n            if(sum<mid){\\n                    if((mid-sum)>k)\\n                        return false;\\n                if(i+r<=n-1) ans[i+r]+=(mid-sum); //greedy\\n                k-=(mid-sum);\\n                sum=mid;\\n            }\\n        }\\n        return true;\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n        long l=0;\\n        long h=k;\\n        int n=stations.length;\\n        for(int i=0;i<n;i++)\\n            h+=(long)stations[i];\\n\\t\\t\\t\\n        // Binary Search on ans\\n        while(l<h){\\n            long mid=h+(l-h)/2;\\n            if(check(stations,mid,r,k)) l=mid;\\n            else h=mid-1;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015035,
                "title": "c-java-python3-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7360be4d63ffa8b13518401baa628a6f6800d326) for solutions of weekly 95. \\n\\n**Intuition**\\nBinary search for the desired answer. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size(); \\n        long long lo = 0, hi = 2e10; \\n        while (lo < hi) {\\n            long long mid = lo + (hi-lo+1)/2, prefix = 0; \\n\\t\\t\\tint kk = k; \\n\\t\\t\\tbool ok = true; \\n\\t\\t\\tvector<int> ss = stations; \\n            for (int i = 0; i < n+r; ++i) {\\n                if (i < n) prefix += ss[i]; \\n                if (i >= 2*r+1) prefix -= ss[i-2*r-1]; \\n                if (i >= r && prefix < mid) {\\n                    if (kk < mid - prefix) {\\n\\t\\t\\t\\t\\t\\tok = false; \\n\\t\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\n                    kk -= mid - prefix; \\n                    if (i < n) ss[i] += mid - prefix; \\n                    prefix = mid; \\n                }\\n            }\\n            if (ok) lo = mid; \\n            else hi = mid-1; \\n        }\\n        return lo; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length; \\n        long lo = 0, hi = k + Arrays.stream(stations).asLongStream().sum();\\n        while (lo < hi) {\\n            long mid = lo + (hi-lo+1)/2, prefix = 0; \\n            int kk = k; \\n            int[] ss = stations.clone(); \\n            boolean ok = true; \\n            for (int i = 0; i < n+r; ++i) {\\n                if (i < n) prefix += ss[i]; \\n                if (i >= 2*r+1) prefix -= ss[i-2*r-1]; \\n                if (i >= r && prefix < mid) {\\n                    if (kk < mid - prefix) {\\n                        ok = false; \\n                        break; \\n                    }\\n                    kk -= mid - prefix; \\n                    if (i < n) ss[i] += mid - prefix; \\n                    prefix = mid; \\n                }\\n            }\\n            if (ok) lo = mid; \\n            else hi = mid - 1; \\n        }\\n        return lo; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        lo, hi = 0, sum(stations)+k\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            ok = True \\n            kk = k \\n            ss = stations.copy()\\n            prefix = 0 \\n            for i in range(n+r): \\n                if i < n: prefix += ss[i]\\n                if i >= 2*r+1: prefix -= ss[i-2*r-1]\\n                if i >= r and prefix < mid: \\n                    if kk < mid - prefix: \\n                        ok = False\\n                        break \\n                    kk -= mid - prefix \\n                    if i < n: ss[i] += mid - prefix\\n                    prefix = mid\\n            if ok: lo = mid\\n            else: hi = mid - 1\\n        return lo\\n```\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(N)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size(); \\n        long long lo = 0, hi = 2e10; \\n        while (lo < hi) {\\n            long long mid = lo + (hi-lo+1)/2, prefix = 0; \\n\\t\\t\\tint kk = k; \\n\\t\\t\\tbool ok = true; \\n\\t\\t\\tvector<int> ss = stations; \\n            for (int i = 0; i < n+r; ++i) {\\n                if (i < n) prefix += ss[i]; \\n                if (i >= 2*r+1) prefix -= ss[i-2*r-1]; \\n                if (i >= r && prefix < mid) {\\n                    if (kk < mid - prefix) {\\n\\t\\t\\t\\t\\t\\tok = false; \\n\\t\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\n                    kk -= mid - prefix; \\n                    if (i < n) ss[i] += mid - prefix; \\n                    prefix = mid; \\n                }\\n            }\\n            if (ok) lo = mid; \\n            else hi = mid-1; \\n        }\\n        return lo; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length; \\n        long lo = 0, hi = k + Arrays.stream(stations).asLongStream().sum();\\n        while (lo < hi) {\\n            long mid = lo + (hi-lo+1)/2, prefix = 0; \\n            int kk = k; \\n            int[] ss = stations.clone(); \\n            boolean ok = true; \\n            for (int i = 0; i < n+r; ++i) {\\n                if (i < n) prefix += ss[i]; \\n                if (i >= 2*r+1) prefix -= ss[i-2*r-1]; \\n                if (i >= r && prefix < mid) {\\n                    if (kk < mid - prefix) {\\n                        ok = false; \\n                        break; \\n                    }\\n                    kk -= mid - prefix; \\n                    if (i < n) ss[i] += mid - prefix; \\n                    prefix = mid; \\n                }\\n            }\\n            if (ok) lo = mid; \\n            else hi = mid - 1; \\n        }\\n        return lo; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        lo, hi = 0, sum(stations)+k\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            ok = True \\n            kk = k \\n            ss = stations.copy()\\n            prefix = 0 \\n            for i in range(n+r): \\n                if i < n: prefix += ss[i]\\n                if i >= 2*r+1: prefix -= ss[i-2*r-1]\\n                if i >= r and prefix < mid: \\n                    if kk < mid - prefix: \\n                        ok = False\\n                        break \\n                    kk -= mid - prefix \\n                    if i < n: ss[i] += mid - prefix\\n                    prefix = mid\\n            if ok: lo = mid\\n            else: hi = mid - 1\\n        return lo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415220,
                "title": "c-binary-search-easy-to-understnd",
                "content": "````\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v,ll m,ll r,ll k){\\n        ll cur = 0;\\n        int i = 0, n = v.size();\\n        for(i = 0; i < r; i++){\\n            cur += v[i];\\n        }\\n        int a,b;\\n        vector<ll> add(n,0);\\n        for(i = 0; i < n; i++){\\n            if(i+r<n){\\n                cur += v[i+r];\\n                cur += add[i+r];\\n            }\\n            if(m > cur){//for 2*k+1 window\\'s curr power < to mid power\\n                ll need = m-cur;\\n                if(need>k){\\n                    return false;\\n                }\\n                k -= need;\\n                cur = m;\\n                a = n-1,b = r+i;\\n                add[min(a,b)] = need;//update extra power at last index of window because it can be used be max possible stations.\\n            }\\n            if(i-r>=0){\\n                cur -= v[i-r];\\n                cur -= add[i-r];\\n            }\\n        }\\n        return true;\\n    }\\n    ll maxPower(vector<int>& v, int r, int k) {\\n        ll ans,mx = 1e11,mn = 0, mid;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;//always check mid is possible ans or not\\n            if(check(v,mid,r*1LL,k*1LL)){//if mid is possible ans than try to maximize it\\n                ans = mid;\\n                mn = mid+1;\\n            }else{\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Greedy",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "````\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool check(vector<int> &v,ll m,ll r,ll k){\\n        ll cur = 0;\\n        int i = 0, n = v.size();\\n        for(i = 0; i < r; i++){\\n            cur += v[i];\\n        }\\n        int a,b;\\n        vector<ll> add(n,0);\\n        for(i = 0; i < n; i++){\\n            if(i+r<n){\\n                cur += v[i+r];\\n                cur += add[i+r];\\n            }\\n            if(m > cur){//for 2*k+1 window\\'s curr power < to mid power\\n                ll need = m-cur;\\n                if(need>k){\\n                    return false;\\n                }\\n                k -= need;\\n                cur = m;\\n                a = n-1,b = r+i;\\n                add[min(a,b)] = need;//update extra power at last index of window because it can be used be max possible stations.\\n            }\\n            if(i-r>=0){\\n                cur -= v[i-r];\\n                cur -= add[i-r];\\n            }\\n        }\\n        return true;\\n    }\\n    ll maxPower(vector<int>& v, int r, int k) {\\n        ll ans,mx = 1e11,mn = 0, mid;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;//always check mid is possible ans or not\\n            if(check(v,mid,r*1LL,k*1LL)){//if mid is possible ans than try to maximize it\\n                ans = mid;\\n                mn = mid+1;\\n            }else{\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024401,
                "title": "bit-solution",
                "content": "# Approach\\nusing BIT \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(nlog^2(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass FenTree{\\n     public:\\n        FenTree(int n){\\n            this->size=n+1;\\n            this->tree.resize(size);\\n        }\\n        unsigned long long int sum(int i){\\n            if(i<0)return 0;\\n            unsigned long long int res=0;\\n            for(++i;i>0;i-=i&-i){\\n                res+=tree[i];\\n            }\\n            return res;\\n\\n        }\\n        void update(int id,int delta){\\n            for(++id;id<size;id+=id&(-id)){\\n                tree[id]+=delta;\\n            }\\n        }\\n       private:\\n        vector<unsigned long long int>tree;\\n        int size;\\n\\n };\\n\\n\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& st, int r, int k) {\\n        long long int lo=0,hi=11000000000+1,ans=-1;\\n        int n=st.size();\\n        while(lo<=hi){\\n            long long int mid=(lo+hi)/2;\\n            FenTree bt(n);\\n            int K=k;\\n            for(int i=0;i<n;i++){bt.update(i,st[i]);}\\n            for(int i=0;i<n;i++){\\n                unsigned long long int rd=bt.sum(min(i+r,n-1))-bt.sum(i-1);\\n                unsigned long long int ld=bt.sum(i-1)-bt.sum(i-r-1);\\n                unsigned long long int res=(ld+rd);\\n                if(res<mid){\\n                    if(mid-res>K){K=-1;break;}\\n                    K-=(mid-res);\\n                    bt.update(min(i+r,n-1),(mid-res));\\n                }\\n                if(K<0){break;}\\n            }\\n            if(K>=0){ans=mid;lo=mid+1;}\\n            else{hi=mid-1;}\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FenTree{\\n     public:\\n        FenTree(int n){\\n            this->size=n+1;\\n            this->tree.resize(size);\\n        }\\n        unsigned long long int sum(int i){\\n            if(i<0)return 0;\\n            unsigned long long int res=0;\\n            for(++i;i>0;i-=i&-i){\\n                res+=tree[i];\\n            }\\n            return res;\\n\\n        }\\n        void update(int id,int delta){\\n            for(++id;id<size;id+=id&(-id)){\\n                tree[id]+=delta;\\n            }\\n        }\\n       private:\\n        vector<unsigned long long int>tree;\\n        int size;\\n\\n };\\n\\n\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& st, int r, int k) {\\n        long long int lo=0,hi=11000000000+1,ans=-1;\\n        int n=st.size();\\n        while(lo<=hi){\\n            long long int mid=(lo+hi)/2;\\n            FenTree bt(n);\\n            int K=k;\\n            for(int i=0;i<n;i++){bt.update(i,st[i]);}\\n            for(int i=0;i<n;i++){\\n                unsigned long long int rd=bt.sum(min(i+r,n-1))-bt.sum(i-1);\\n                unsigned long long int ld=bt.sum(i-1)-bt.sum(i-r-1);\\n                unsigned long long int res=(ld+rd);\\n                if(res<mid){\\n                    if(mid-res>K){K=-1;break;}\\n                    K-=(mid-res);\\n                    bt.update(min(i+r,n-1),(mid-res));\\n                }\\n                if(K<0){break;}\\n            }\\n            if(K>=0){ans=mid;lo=mid+1;}\\n            else{hi=mid-1;}\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016453,
                "title": "very-simple-code-with-intuition-and-approach-c-binary-search-prefix-sum",
                "content": "# Intuition\\nLOOKING AT THE STATEMENT \"MAXIMUM POSSIBLE MINIMUM POWER \" AND THE CONSTRAINTS, ONE CAN FEEL THAT BINARY SEARCH WOULD BE THE WAY TO GO.\\n\\n# Approach\\nTHE MAIN LOGIC IS TO START FROM THE LEFT AND PLACE THE NEW TOWER TO THE RIGHTMOST VALID POSITON FROM WHICH IT CAN GET POWER. SUPPOSE THE RANGE IS 2 AND WE ARE AT 0 IDX, THEN WE WOULD PLACE THE NEW TOWER AT 2ND IDX SO THAT MOST OF THE TOWERS ARE COVERED.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define ll long long\\nclass Solution {\\npublic:\\n    int n;\\n    bool f(ll min_power,vector<ll>&a,int r,int k){  \\n        vector<ll>ps(n,0);// stores the prefix_sum\\n        ll tot_stat_req=0,stations_req=0;\\n        for(int i=0;i<n;i++){\\n            if(i-1>=0) ps[i]+=ps[i-1];\\n            if(a[i]+ps[i]<min_power){// if the total power at that idx is less than min_power\\n                stations_req=min_power-a[i]-ps[i];\\n                tot_stat_req+=stations_req;\\n                ps[i]+=stations_req;\\n                if(i+2*r+1<n) ps[i+2*r+1]-=stations_req; \\n            }\\n        }\\n        return tot_stat_req<=k;\\n    }\\n    long long maxPower(vector<int>& sta, int r, int k) {\\n        ll st=0,end=1e11,ans=-1;\\n        n=sta.size();\\n        vector<ll>pre(n);\\n        pre[0]=sta[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+sta[i];\\n        }\\n        vector<ll>a(n);//stores the total power at the particular index\\n        for(int i=0;i<n;i++){\\n            a[i]=((i+r<=n-1)? pre[i+r]:pre[n-1])-((i-r-1>=0)?pre[i-r-1]:0);\\n        }\\n        while(st<=end){\\n            ll min_power=st+(end-st)/2;\\n            if(f(min_power,a,r,k)){\\n                ans=min_power;\\n                st=min_power+1;\\n            }\\n            else end=min_power-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define ll long long\\nclass Solution {\\npublic:\\n    int n;\\n    bool f(ll min_power,vector<ll>&a,int r,int k){  \\n        vector<ll>ps(n,0);// stores the prefix_sum\\n        ll tot_stat_req=0,stations_req=0;\\n        for(int i=0;i<n;i++){\\n            if(i-1>=0) ps[i]+=ps[i-1];\\n            if(a[i]+ps[i]<min_power){// if the total power at that idx is less than min_power\\n                stations_req=min_power-a[i]-ps[i];\\n                tot_stat_req+=stations_req;\\n                ps[i]+=stations_req;\\n                if(i+2*r+1<n) ps[i+2*r+1]-=stations_req; \\n            }\\n        }\\n        return tot_stat_req<=k;\\n    }\\n    long long maxPower(vector<int>& sta, int r, int k) {\\n        ll st=0,end=1e11,ans=-1;\\n        n=sta.size();\\n        vector<ll>pre(n);\\n        pre[0]=sta[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+sta[i];\\n        }\\n        vector<ll>a(n);//stores the total power at the particular index\\n        for(int i=0;i<n;i++){\\n            a[i]=((i+r<=n-1)? pre[i+r]:pre[n-1])-((i-r-1>=0)?pre[i-r-1]:0);\\n        }\\n        while(st<=end){\\n            ll min_power=st+(end-st)/2;\\n            if(f(min_power,a,r,k)){\\n                ans=min_power;\\n                st=min_power+1;\\n            }\\n            else end=min_power-1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3015311,
                "title": "c-easy-solution-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool is(vector<long long> &a,int r,int k,long long m){\\n        long long h , sum=0,ans =0;\\n        if(r==0){\\n            for(auto &i:a){\\n                if(i<m) ans += m-i;\\n                if(ans>k) return 0;\\n            }\\n            return 1;\\n        }\\n        queue<int> q;\\n        h =r*2;\\n        while(h--) q.push(0);\\n        for(auto &i:a){\\n            h = i+sum;\\n            if(h>=m) q.push(0);\\n            else{\\n                ans += (m-h);\\n                q.push(m-h);\\n                sum += (m-h);\\n            }\\n            if(ans>k) return 0;\\n            h = q.front();\\n            q.pop();\\n            sum -= h;\\n        }\\n        return 1;\\n    }\\n    \\n    long long maxPower(vector<int>& num, int r, int k) {\\n        long long l= 0 , h = 2e10 , m , ans,n = num.size() ,sum =0 ;\\n        vector<long long> a(n);\\n        for(int i=0;i<=r;i++) sum += num[i];\\n        for(int i=0;i<n;i++){\\n            a[i] = sum;\\n            if(i+r+1<n) sum += num[i+r+1];\\n            if(i>=r) sum -= num[i-r];\\n        }\\n        while(l<=h){\\n            m = l+(h-l)/2;\\n            if(!is(a,r,k,m)) h = m-1;\\n            else{ \\n                ans = m;\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(vector<long long> &a,int r,int k,long long m){\\n        long long h , sum=0,ans =0;\\n        if(r==0){\\n            for(auto &i:a){\\n                if(i<m) ans += m-i;\\n                if(ans>k) return 0;\\n            }\\n            return 1;\\n        }\\n        queue<int> q;\\n        h =r*2;\\n        while(h--) q.push(0);\\n        for(auto &i:a){\\n            h = i+sum;\\n            if(h>=m) q.push(0);\\n            else{\\n                ans += (m-h);\\n                q.push(m-h);\\n                sum += (m-h);\\n            }\\n            if(ans>k) return 0;\\n            h = q.front();\\n            q.pop();\\n            sum -= h;\\n        }\\n        return 1;\\n    }\\n    \\n    long long maxPower(vector<int>& num, int r, int k) {\\n        long long l= 0 , h = 2e10 , m , ans,n = num.size() ,sum =0 ;\\n        vector<long long> a(n);\\n        for(int i=0;i<=r;i++) sum += num[i];\\n        for(int i=0;i<n;i++){\\n            a[i] = sum;\\n            if(i+r+1<n) sum += num[i+r+1];\\n            if(i>=r) sum -= num[i-r];\\n        }\\n        while(l<=h){\\n            m = l+(h-l)/2;\\n            if(!is(a,r,k,m)) h = m-1;\\n            else{ \\n                ans = m;\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015294,
                "title": "python-3-work-on-the-left-bounary-binary-search-line-sweep",
                "content": "If we can distribute k power stations to bring minimun power level to x, power level x - 1 is also achieveable. Intuitively, the problem can be solved by binary search of the maximum minimum power level.\\n\\nFirst we use a size 2 * r + 1 sliding window to find the current power level. Left and right bounds for binary search is the min(current power level) and max(current power level) + k.\\n\\nFor each target power level mid = (left + right + 1) // 2, we want to check whether mid can be realized. At each city, we can calculate the gap between the city\\'s current power and mid, then, we start to place new stations to fill the gaps. At the stage, we sweep from 0 to n - 1, if a non-zero gap[i] encountered, we greedily place a new station such that **the left boundary of influence of the new station is at [i]** as a result, all cities in [i to i + 2 * r inclusively] are powered (gap reduced). Implementation-wise, we do not want to update the the city gaps [i to i + 2 * r inclusively], which will TLE, instead, we use a diffiential array to track the right bounary of influence of the new station, and use a cumulative vairable `c` to represent influences of the new stations. See function `check` below for details.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        pw = [0] * n\\n        pw[0] = sum(stations[0:r + 1])\\n        for i in range(1, n): # sliding window to obtain current power level\\n            pw[i] = pw[i - 1] \\\\\\n                    - (stations[i - r - 1] if i - r - 1 >= 0 else 0) \\\\\\n                    + (stations[i + r] if i + r < n else 0)\\n        \\n        def check(mid, k):\\n            gap = [max(0, mid - p) for p in pw]\\n            diff = [0] * (n + 1 + r * 2) # differential array for stations our of range\\n            c = 0\\n            for i in range(n):\\n                c += diff[i] # remove the stations out of range\\n                if gap[i] <= c:\\n                    continue\\n                if gap[i] - c > k: # unachievable, return False\\n                    return False\\n                else:\\n                    x = gap[i] - c # number of stations to build where i is the left boundary of influence\\n                    k -= x\\n                    c += x # influence of the new stations\\n                    diff[i + 1 + r * 2] -= x # track end of the influence\\n            return True\\n        \\n        mi, ma = min(pw), max(pw)\\n        le, ri = mi, ma + k\\n        while le < ri: # binary search\\n            mid = (le + ri + 1) // 2\\n            if check(mid, k):\\n                le = mid\\n            else:\\n                ri = mid - 1\\n        return le\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        pw = [0] * n\\n        pw[0] = sum(stations[0:r + 1])\\n        for i in range(1, n): # sliding window to obtain current power level\\n            pw[i] = pw[i - 1] \\\\\\n                    - (stations[i - r - 1] if i - r - 1 >= 0 else 0) \\\\\\n                    + (stations[i + r] if i + r < n else 0)\\n        \\n        def check(mid, k):\\n            gap = [max(0, mid - p) for p in pw]\\n            diff = [0] * (n + 1 + r * 2) # differential array for stations our of range\\n            c = 0\\n            for i in range(n):\\n                c += diff[i] # remove the stations out of range\\n                if gap[i] <= c:\\n                    continue\\n                if gap[i] - c > k: # unachievable, return False\\n                    return False\\n                else:\\n                    x = gap[i] - c # number of stations to build where i is the left boundary of influence\\n                    k -= x\\n                    c += x # influence of the new stations\\n                    diff[i + 1 + r * 2] -= x # track end of the influence\\n            return True\\n        \\n        mi, ma = min(pw), max(pw)\\n        le, ri = mi, ma + k\\n        while le < ri: # binary search\\n            mid = (le + ri + 1) // 2\\n            if check(mid, k):\\n                le = mid\\n            else:\\n                ri = mid - 1\\n        return le\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014982,
                "title": "binary-search-greedy-detailed-explanation",
                "content": "# Intuition\\nThe first thing I did was to think of the input as an array of ***power*** rather than power stations.\\n\\nFor example, if your input is:\\n\\n```\\nstations = [1,2,4,5,0], r = 1, k = 2\\n```\\n\\nthen you can calculate power to be\\n\\n```\\npower = [3,7,11,9,5]\\n```\\n\\nFrom here you can guess a maximum power, then check if it is achievable\\n\\nFor example\\n\\n```\\npower = 3: Achievable by doing nothing\\npower = 4: Achievable by adding 1 station at i=1\\npower = 5: Achievable by adding 2 stations at i=1\\npower = 6: NOT Achievable because k < 4\\n```\\n\\nAs you can see 5 is the highest value that is still achievable, therefore it is the answer. This hopefully screams at you to do a binary search optimization so you only have to do log(n) checks.\\n\\n# Approach\\n\\nSo with that general strategy, we just need an efficient algorithm for computing if a given max power is achievable or not.\\n\\nThis will require a greedy algorithm. Let\\'s loop through the array of cities.\\n\\nIf the current power of a city is already greater than the required power, do nothing. However if the current power is less than what is needed, we need to add `goal - currPower` stations somewhere. So where do you add them? Well, one option is at the current city `i`. But we can do better! If we add the stations at `i + r`, we not only benefitting the current city, but also as many other potentially needy cities as possible.  \\n\\nThe next challenge is actually computing the power at a given city. If this is done naiively, you will have to sum up around `2r` numbers each time. This isn\\'t efficient enough. A better approach is a rolling two pointer algorithm. Everytime you move to a new city `currSum += power[i + r]` and `currSum -= power[i - r]`.\\n\\nWith these techniques, we are ready to start coding! \\n\\n# Code\\n\\n```js\\nvar maxPower = function(stations_, r, k) {\\n    // Returns 0 if the goal is acheivable, 1 if not.\\n    // The answer is the goal which returned the last zero\\n    // This is best calculated with binary search\\n    function check(goal) {\\n        let additions = 0;\\n        let stations = [...stations_]; // mutable clone of the stations\\n        let [i, j] = [-r, r]; // the current window\\n        let currPower = _.sum(stations.slice(0, j + 1)); // sum within the current window\\n        for (const station of stations) {\\n            if (currPower < goal) {\\n                // we need to add power stations at k + r\\n                // we also need to update currPower and additions\\n                const delta = goal - currPower;\\n                additions += delta\\n                currPower += delta\\n                stations[Math.min(j, stations.length - 1)] += delta;\\n            }\\n            // keep track of the rolling sum\\n            j++\\n            currPower += ( stations[j] || 0)\\n            currPower -= ( stations[i] || 0)\\n            i++\\n        }\\n        return additions <= k ? 0 : 1;\\n    }\\n    \\n    // binary search to find last achievable goal\\n    const max = _.sum(stations_) + k;\\n    return lastIndexLessThan(1, 0, max, check);\\n};\\n\\n// Handy Reusable Binary Search Function\\nfunction lastIndexLessThan(val, a, b, f = (i) => i) {\\n    if (a > b) return null;\\n    if (f(a) >= val) return null;\\n    if (f(b) < val) return b;\\n    \\n    while (a <= b) {\\n        const mid = Math.floor(a / 2 + b / 2);\\n        if (f(mid) < val) {\\n            a = mid + 1;\\n            if (f(a) >= val) {\\n                return mid;\\n            }\\n        } else {\\n            b = mid - 1;\\n            if (f(b) < val) {\\n                return b;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n# Complexity\\nn = len(stations)\\nmax = sum(stations) + k\\n- Time complexity: $$O(n log(max))$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nstations = [1,2,4,5,0], r = 1, k = 2\\n```\n```\\npower = [3,7,11,9,5]\\n```\n```\\npower = 3: Achievable by doing nothing\\npower = 4: Achievable by adding 1 station at i=1\\npower = 5: Achievable by adding 2 stations at i=1\\npower = 6: NOT Achievable because k < 4\\n```\n```js\\nvar maxPower = function(stations_, r, k) {\\n    // Returns 0 if the goal is acheivable, 1 if not.\\n    // The answer is the goal which returned the last zero\\n    // This is best calculated with binary search\\n    function check(goal) {\\n        let additions = 0;\\n        let stations = [...stations_]; // mutable clone of the stations\\n        let [i, j] = [-r, r]; // the current window\\n        let currPower = _.sum(stations.slice(0, j + 1)); // sum within the current window\\n        for (const station of stations) {\\n            if (currPower < goal) {\\n                // we need to add power stations at k + r\\n                // we also need to update currPower and additions\\n                const delta = goal - currPower;\\n                additions += delta\\n                currPower += delta\\n                stations[Math.min(j, stations.length - 1)] += delta;\\n            }\\n            // keep track of the rolling sum\\n            j++\\n            currPower += ( stations[j] || 0)\\n            currPower -= ( stations[i] || 0)\\n            i++\\n        }\\n        return additions <= k ? 0 : 1;\\n    }\\n    \\n    // binary search to find last achievable goal\\n    const max = _.sum(stations_) + k;\\n    return lastIndexLessThan(1, 0, max, check);\\n};\\n\\n// Handy Reusable Binary Search Function\\nfunction lastIndexLessThan(val, a, b, f = (i) => i) {\\n    if (a > b) return null;\\n    if (f(a) >= val) return null;\\n    if (f(b) < val) return b;\\n    \\n    while (a <= b) {\\n        const mid = Math.floor(a / 2 + b / 2);\\n        if (f(mid) < val) {\\n            a = mid + 1;\\n            if (f(a) >= val) {\\n                return mid;\\n            }\\n        } else {\\n            b = mid - 1;\\n            if (f(b) < val) {\\n                return b;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917553,
                "title": "c-segment-tree-binary-search-prefix-sum-greedy-beats-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, mod = (int)1e9 + 7;\\n    public class Node{\\n        public int l, r;\\n        public long cnt, add;\\n        public Node(int l, int r){\\n            this.l = l;\\n            this.r = r;\\n            this.cnt = 0;\\n            this.add = 0;\\n        }\\n    }\\n    Node[] tr = new Node[N * 4];\\n\\n    public long MaxPower(int[] stations, int t, int k) {\\n        int n = stations.Length;\\n        long[] qwq = new long[n];\\n        Build(1, 1, n + 1);\\n        for(int i = 0; i < n; i++) Update(1, i + 1, i + 1, stations[i]);\\n        for(int i = 0; i < n; i++) \\n            qwq[i] = Query(1, Math.Max(i + 1 - t, 1), Math.Min(n, i + 1 + t));\\n        long l = 0, r = (long)1e14 + 1;;\\n        while(l < r){\\n            long mid = (r - l) / 2 + l;\\n            if(!Search(qwq, mid, t, k)) r = mid;\\n            else l = mid + 1; \\n        }\\n        return l - 1;\\n    }\\n\\n    public bool Search(long[] qaq, long mid, int r, long k){\\n        long[] ysy = new long[qaq.Length], cum = new long[(int)1e5 + 1];\\n        for(int i = 0; i < qaq.Length; i++) ysy[i] = qaq[i] - mid;\\n        for(int i = 0; i < ysy.Length; i++){\\n            if(i > 0) cum[i] += cum[i - 1];\\n            if(ysy[i] + cum[i] >= 0) continue;\\n            if(ysy[i] + cum[i] < 0 && k >= -(cum[i] + ysy[i])){\\n                k += ysy[i] + cum[i];\\n                if(i + r * 2 + 1 < qaq.Length) cum[i + r * 2 + 1] += (cum[i] + ysy[i]);\\n                cum[i] += -(cum[i] + ysy[i]);\\n            }\\n            else if(ysy[i] + cum[i] < 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public void Build(int u, int l, int r){\\n        tr[u] = new Node(l, r);\\n        if(l == r) return;\\n        int mid = l + r >> 1;\\n        Build(u << 1, l, mid);\\n        Build(u << 1 | 1, mid + 1, r);\\n    }\\n\\n    public void PushUp(int u){\\n        tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;\\n    }\\n\\n    public void PushDown(int u){\\n        if(tr[u].add == 0) return;\\n        tr[u << 1].add += tr[u].add;\\n        tr[u << 1 | 1].add += tr[u].add;\\n        tr[u << 1].cnt += tr[u].add * (tr[u << 1].r - tr[u << 1].l + 1);\\n        tr[u << 1 | 1].cnt += tr[u].add * (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1);\\n        tr[u].add = 0;\\n    }\\n\\n    public void Update(int u, int l, int r, long v){\\n        if(l <= tr[u].l && tr[u].r <= r){\\n            tr[u].cnt += (tr[u].r - tr[u].l + 1) * v;\\n            tr[u].add += v;\\n            return;\\n        }\\n        PushDown(u);\\n        int mid = tr[u].l + tr[u].r >> 1;\\n        if(l <= mid) Update(u << 1, l, r, v);\\n        if(r > mid) Update(u << 1 | 1, l, r, v);\\n        PushUp(u);\\n    }\\n\\n    public long Query(int u, int l, int r){\\n        if(l <= tr[u].l && tr[u].r <= r) return tr[u].cnt;\\n        PushDown(u);\\n        int mid = tr[u].l + tr[u].r >> 1;\\n        long ans = 0;\\n        if(l <= mid) ans = Query(u << 1, l, r);\\n        if(r > mid) ans += Query(u << 1 | 1, l, r);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, mod = (int)1e9 + 7;\\n    public class Node{\\n        public int l, r;\\n        public long cnt, add;\\n        public Node(int l, int r){\\n            this.l = l;\\n            this.r = r;\\n            this.cnt = 0;\\n            this.add = 0;\\n        }\\n    }\\n    Node[] tr = new Node[N * 4];\\n\\n    public long MaxPower(int[] stations, int t, int k) {\\n        int n = stations.Length;\\n        long[] qwq = new long[n];\\n        Build(1, 1, n + 1);\\n        for(int i = 0; i < n; i++) Update(1, i + 1, i + 1, stations[i]);\\n        for(int i = 0; i < n; i++) \\n            qwq[i] = Query(1, Math.Max(i + 1 - t, 1), Math.Min(n, i + 1 + t));\\n        long l = 0, r = (long)1e14 + 1;;\\n        while(l < r){\\n            long mid = (r - l) / 2 + l;\\n            if(!Search(qwq, mid, t, k)) r = mid;\\n            else l = mid + 1; \\n        }\\n        return l - 1;\\n    }\\n\\n    public bool Search(long[] qaq, long mid, int r, long k){\\n        long[] ysy = new long[qaq.Length], cum = new long[(int)1e5 + 1];\\n        for(int i = 0; i < qaq.Length; i++) ysy[i] = qaq[i] - mid;\\n        for(int i = 0; i < ysy.Length; i++){\\n            if(i > 0) cum[i] += cum[i - 1];\\n            if(ysy[i] + cum[i] >= 0) continue;\\n            if(ysy[i] + cum[i] < 0 && k >= -(cum[i] + ysy[i])){\\n                k += ysy[i] + cum[i];\\n                if(i + r * 2 + 1 < qaq.Length) cum[i + r * 2 + 1] += (cum[i] + ysy[i]);\\n                cum[i] += -(cum[i] + ysy[i]);\\n            }\\n            else if(ysy[i] + cum[i] < 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public void Build(int u, int l, int r){\\n        tr[u] = new Node(l, r);\\n        if(l == r) return;\\n        int mid = l + r >> 1;\\n        Build(u << 1, l, mid);\\n        Build(u << 1 | 1, mid + 1, r);\\n    }\\n\\n    public void PushUp(int u){\\n        tr[u].cnt = tr[u << 1].cnt + tr[u << 1 | 1].cnt;\\n    }\\n\\n    public void PushDown(int u){\\n        if(tr[u].add == 0) return;\\n        tr[u << 1].add += tr[u].add;\\n        tr[u << 1 | 1].add += tr[u].add;\\n        tr[u << 1].cnt += tr[u].add * (tr[u << 1].r - tr[u << 1].l + 1);\\n        tr[u << 1 | 1].cnt += tr[u].add * (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1);\\n        tr[u].add = 0;\\n    }\\n\\n    public void Update(int u, int l, int r, long v){\\n        if(l <= tr[u].l && tr[u].r <= r){\\n            tr[u].cnt += (tr[u].r - tr[u].l + 1) * v;\\n            tr[u].add += v;\\n            return;\\n        }\\n        PushDown(u);\\n        int mid = tr[u].l + tr[u].r >> 1;\\n        if(l <= mid) Update(u << 1, l, r, v);\\n        if(r > mid) Update(u << 1 | 1, l, r, v);\\n        PushUp(u);\\n    }\\n\\n    public long Query(int u, int l, int r){\\n        if(l <= tr[u].l && tr[u].r <= r) return tr[u].cnt;\\n        PushDown(u);\\n        int mid = tr[u].l + tr[u].r >> 1;\\n        long ans = 0;\\n        if(l <= mid) ans = Query(u << 1, l, r);\\n        if(r > mid) ans += Query(u << 1 | 1, l, r);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055524,
                "title": "69-63-faster-c-binary-search-ad-hoc-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool check(vector<ll>&arr,int r,int k,ll mid,ll n){\\n        ll sum=0;\\n        vector<ll>container(n,0);\\n        for(ll i=0;i<n;i++){\\n            sum+=container[i];\\n            ll diff=mid-(arr[i]+sum);\\n            if(diff>0){\\n                if(k<diff){\\n                    return false;\\n                }\\n                k-=diff;\\n                sum+=diff;\\n                if(i+(r<<1)+1<n){\\n                    container[i+(r<<1)+1]-=diff;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<ll> pre(vector<int>&stations,ll n,int r){\\n        ll sum=0,i=0;\\n        vector<ll>answer(n);\\n        while(i<n && i<=r){\\n            sum+=stations[i];\\n            answer[i]=sum;\\n            i++;\\n        }\\n        while(i<n){\\n            sum+=stations[i]-stations[i-r-1];\\n            answer[i]=sum;\\n            i++;\\n        }\\n        return answer;\\n    }\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        ll n=stations.size(),sum=0;\\n        vector<ll>arr(n),prefix=pre(stations,n,r);\\n        reverse(stations.begin(),stations.end());\\n        vector<ll>suffix=pre(stations,n,r);\\n        reverse(suffix.begin(),suffix.end());\\n        reverse(stations.begin(),stations.end());\\n        for(ll i=0;i<n;i++){\\n            arr[i]=prefix[i]+suffix[i]-stations[i];\\n        }\\n        ll low=0,high=1e18,mid,answer;\\n        while(low<=high){\\n            mid=(low+high)>>1;\\n            if(check(arr,r,k,mid,n)){\\n                answer=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool check(vector<ll>&arr,int r,int k,ll mid,ll n){\\n        ll sum=0;\\n        vector<ll>container(n,0);\\n        for(ll i=0;i<n;i++){\\n            sum+=container[i];\\n            ll diff=mid-(arr[i]+sum);\\n            if(diff>0){\\n                if(k<diff){\\n                    return false;\\n                }\\n                k-=diff;\\n                sum+=diff;\\n                if(i+(r<<1)+1<n){\\n                    container[i+(r<<1)+1]-=diff;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<ll> pre(vector<int>&stations,ll n,int r){\\n        ll sum=0,i=0;\\n        vector<ll>answer(n);\\n        while(i<n && i<=r){\\n            sum+=stations[i];\\n            answer[i]=sum;\\n            i++;\\n        }\\n        while(i<n){\\n            sum+=stations[i]-stations[i-r-1];\\n            answer[i]=sum;\\n            i++;\\n        }\\n        return answer;\\n    }\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        ll n=stations.size(),sum=0;\\n        vector<ll>arr(n),prefix=pre(stations,n,r);\\n        reverse(stations.begin(),stations.end());\\n        vector<ll>suffix=pre(stations,n,r);\\n        reverse(suffix.begin(),suffix.end());\\n        reverse(stations.begin(),stations.end());\\n        for(ll i=0;i<n;i++){\\n            arr[i]=prefix[i]+suffix[i]-stations[i];\\n        }\\n        ll low=0,high=1e18,mid,answer;\\n        while(low<=high){\\n            mid=(low+high)>>1;\\n            if(check(arr,r,k,mid,n)){\\n                answer=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022116,
                "title": "java-prefix-sum-binary-search-greedy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    private int len, r;\\n    public long maxPower(int[] stations, int r, int k) {\\n        this.len = stations.length;\\n        this.r = r;\\n\\n        long[] prefixSum = new long[len + 1], powers = new long[len + 1];\\n        for (int i = 1; i <= len; ++i) {\\n            prefixSum[i] += prefixSum[i - 1] + stations[i - 1];\\n        }\\n        for (int i = 1; i <= len; ++i) {\\n            int ub = Math.min(len, i + r), lb = Math.max(0, i - r - 1);\\n            powers[i] = prefixSum[ub] - prefixSum[lb];\\n        }\\n\\n        long start = 0L, end = prefixSum[len] + k;\\n        while (start < end - 1) {\\n            long mid = start + (end - start) / 2;\\n            if (isReachable(mid, k, powers)) {\\n                start = mid;                \\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        if (isReachable(end, k, powers)) return end;\\n        return start;\\n    }\\n    private boolean isReachable(long required, int extra, long[] powers) {\\n\\n        // check the power of each city\\n        long[] diff = new long[len + 1];\\n        long powerDiff = 0L;\\n        for (int i = 1; i <= len; ++i) {\\n            powerDiff += diff[i - 1];\\n            long needed = required - powers[i] - powerDiff;\\n            if (needed > 0) {\\n                extra -= needed;\\n                if (extra < 0) return false;\\n                diff[i] += needed;\\n                if (i + 2 * r <= len) diff[i + 2 * r] -= needed;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    private int len, r;\\n    public long maxPower(int[] stations, int r, int k) {\\n        this.len = stations.length;\\n        this.r = r;\\n\\n        long[] prefixSum = new long[len + 1], powers = new long[len + 1];\\n        for (int i = 1; i <= len; ++i) {\\n            prefixSum[i] += prefixSum[i - 1] + stations[i - 1];\\n        }\\n        for (int i = 1; i <= len; ++i) {\\n            int ub = Math.min(len, i + r), lb = Math.max(0, i - r - 1);\\n            powers[i] = prefixSum[ub] - prefixSum[lb];\\n        }\\n\\n        long start = 0L, end = prefixSum[len] + k;\\n        while (start < end - 1) {\\n            long mid = start + (end - start) / 2;\\n            if (isReachable(mid, k, powers)) {\\n                start = mid;                \\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        if (isReachable(end, k, powers)) return end;\\n        return start;\\n    }\\n    private boolean isReachable(long required, int extra, long[] powers) {\\n\\n        // check the power of each city\\n        long[] diff = new long[len + 1];\\n        long powerDiff = 0L;\\n        for (int i = 1; i <= len; ++i) {\\n            powerDiff += diff[i - 1];\\n            long needed = required - powers[i] - powerDiff;\\n            if (needed > 0) {\\n                extra -= needed;\\n                if (extra < 0) return false;\\n                diff[i] += needed;\\n                if (i + 2 * r <= len) diff[i + 2 * r] -= needed;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015788,
                "title": "simple-binary-search-on-answer",
                "content": "# Intuition\\nBinary Search and Prefix Sum\\n\\n# Approach\\nWe will run a Binary Search on answer, and will try to check if this particular value(i.e. mid) can be formed by use of less than \\'k\\' power stations or not, if it can be formed then increase the value of left margin else decrease right margin and so on... \\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& v, int r, int k) {\\n        int n=v.size();\\n        vector<long long>val(n),pr(n+1);\\n        pr[0]=v[0];\\n        for(int i=1;i<n;i++){\\n            pr[i]=(pr[i-1]+v[i]);\\n        }\\n        pr[n]=pr[n-1];\\n        for(int i=0;i<n;i++){\\n            val[i]=pr[min(n,i+r)];\\n            if(i-r>=1){\\n                val[i]-=pr[i-r-1];\\n            }\\n        }\\n        // Binary Search on answer;\\n        long long L=0,R=1e15;\\n        while(L<R){\\n            long long mid=(L+R+1)/2;\\n            long long x=mid;\\n            // Let us suppose min(power) = x ; check if it is possible;\\n            vector<long long>dup=val;\\n            long long cnt=0;\\n            long long ans=0;\\n            vector<long long>mp(n+1);\\n            for(int i=0;i<n;i++){\\n                cnt-=mp[i];\\n                if(dup[i]+cnt>=x){\\n                    continue;\\n                }\\n                else{\\n                    long long diff=x-(dup[i]+cnt);\\n                    ans+=diff;\\n                    if(ans>k){\\n                        break;\\n                    }\\n                    cnt+=diff;\\n                    if(i+(2*r)+1<n){\\n                        mp[i+(2*r)+1]=diff;\\n                    }\\n                }\\n            }\\n            if(ans<=k){\\n                L=mid;\\n            }\\n            else{\\n                R=mid-1;\\n            }\\n        }\\n        \\n        return L;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& v, int r, int k) {\\n        int n=v.size();\\n        vector<long long>val(n),pr(n+1);\\n        pr[0]=v[0];\\n        for(int i=1;i<n;i++){\\n            pr[i]=(pr[i-1]+v[i]);\\n        }\\n        pr[n]=pr[n-1];\\n        for(int i=0;i<n;i++){\\n            val[i]=pr[min(n,i+r)];\\n            if(i-r>=1){\\n                val[i]-=pr[i-r-1];\\n            }\\n        }\\n        // Binary Search on answer;\\n        long long L=0,R=1e15;\\n        while(L<R){\\n            long long mid=(L+R+1)/2;\\n            long long x=mid;\\n            // Let us suppose min(power) = x ; check if it is possible;\\n            vector<long long>dup=val;\\n            long long cnt=0;\\n            long long ans=0;\\n            vector<long long>mp(n+1);\\n            for(int i=0;i<n;i++){\\n                cnt-=mp[i];\\n                if(dup[i]+cnt>=x){\\n                    continue;\\n                }\\n                else{\\n                    long long diff=x-(dup[i]+cnt);\\n                    ans+=diff;\\n                    if(ans>k){\\n                        break;\\n                    }\\n                    cnt+=diff;\\n                    if(i+(2*r)+1<n){\\n                        mp[i+(2*r)+1]=diff;\\n                    }\\n                }\\n            }\\n            if(ans<=k){\\n                L=mid;\\n            }\\n            else{\\n                R=mid-1;\\n            }\\n        }\\n        \\n        return L;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015112,
                "title": "binary-search-python-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nkey points-\\n    -optimization problem\\n    -\"at max some k\"\\n\\nSo I thought binary search could work\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search on answer, this solution is weird because we are copying the whole array, but it\\'s still O(n), so it works.\\n\\nUse sliding window to calculate the range sum.\\nIn the check function, we greedly update the rightmost index in the sliding window if current sum is less than the selected mid \\'m\\'.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nLog(n))$$ - binary search \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - copy the array Log(n) times\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, nums: List[int], r: int, k: int) -> int:\\n        def check(m):\\n            res=0\\n            temp = nums.copy()\\n            curr = sum(temp[:r])\\n            for i in range(n):\\n                if i+r < n:\\n                    curr+=temp[i+r]\\n                if i-r-1 > -1:\\n                    curr-=temp[i-r-1]\\n                if curr<m:\\n                    diff = m-curr\\n                    rr = min(i+r,n-1)\\n                    curr+=diff     #wasted 1 hour because i forgot this\\n                    temp[rr]+=diff\\n                    res+=diff\\n            return res<=k\\n        \\n        n = len(nums)\\n        s,e = 0,sum(nums)+k\\n        while s<e:\\n            m = s+e+1>>1\\n            if check(m):\\n                s=m\\n            else:\\n                e=m-1\\n        return s\\n                    \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, nums: List[int], r: int, k: int) -> int:\\n        def check(m):\\n            res=0\\n            temp = nums.copy()\\n            curr = sum(temp[:r])\\n            for i in range(n):\\n                if i+r < n:\\n                    curr+=temp[i+r]\\n                if i-r-1 > -1:\\n                    curr-=temp[i-r-1]\\n                if curr<m:\\n                    diff = m-curr\\n                    rr = min(i+r,n-1)\\n                    curr+=diff     #wasted 1 hour because i forgot this\\n                    temp[rr]+=diff\\n                    res+=diff\\n            return res<=k\\n        \\n        n = len(nums)\\n        s,e = 0,sum(nums)+k\\n        while s<e:\\n            m = s+e+1>>1\\n            if check(m):\\n                s=m\\n            else:\\n                e=m-1\\n        return s\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015063,
                "title": "python3-binary-search-on-the-answer-and-sliding-window",
                "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978535,
                "title": "rust-binary-search-sliding-window",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n \\\\log usize::MAX)$$\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```rust\\nuse std::collections::VecDeque;\\n\\npub struct SlidingWindow {\\n    window_size_0: usize,\\n    window_size_1: usize,\\n    baseline: usize,\\n\\n    queue: VecDeque<usize>,\\n    queue_sum: usize,\\n}\\n\\nimpl SlidingWindow {\\n    pub fn new(radius: usize, baseline: usize) -> Self {\\n        let window_size_0 = radius + 1;\\n        let window_size_1 = radius * 2 + 1;\\n\\n        let queue = VecDeque::new();\\n        let queue_sum = usize::MIN;\\n\\n        Self {\\n            window_size_0, window_size_1,\\n            baseline,\\n            queue, queue_sum,\\n        }\\n    }\\n\\n    pub fn scan(&mut self, token: usize) -> Option<usize> {\\n        self.queue.push_back(token);\\n        self.queue_sum += token;\\n\\n        while self.queue.len() > self.window_size_1 {\\n            let token_frnt = self.queue.pop_front().unwrap();\\n            self.queue_sum -= token_frnt;\\n        }\\n\\n        if self.queue.len() < self.window_size_0 {\\n            return None;\\n        }\\n\\n        // window is valid\\n        if self.queue_sum >= self.baseline {\\n            return None; // above baseline\\n        }\\n\\n        let mut ret = usize::MIN;\\n        ret += self.baseline;\\n        ret -= self.queue_sum;\\n\\n        let e_back = self.queue.pop_back().unwrap();\\n        self.queue_sum -= e_back;\\n\\n        let e_back_next = e_back + ret;\\n        self.queue.push_back(e_back_next);\\n        self.queue_sum += e_back_next;\\n\\n        assert!(self.queue_sum >= self.baseline);\\n\\n        Some(ret)\\n    }\\n\\n    pub fn drain(mut self) -> usize {\\n        let mut ret = usize::MIN;\\n        while self.queue.len() > self.window_size_0 {\\n            let e_frnt = self.queue.pop_front().unwrap();\\n            self.queue_sum -= e_frnt;\\n\\n            if self.queue_sum >= self.baseline {\\n                continue;\\n            }\\n\\n            let mut _ret = usize::MIN;\\n            _ret += self.baseline;\\n            _ret -= self.queue_sum;\\n\\n            let e_back = self.queue.pop_back().unwrap();\\n            self.queue_sum -= e_back;\\n\\n            let e_back_next = e_back + _ret;\\n            self.queue.push_back(e_back_next);\\n            self.queue_sum += e_back_next;\\n\\n            assert!(self.queue_sum >= self.baseline);\\n\\n            ret += _ret;\\n        }\\n\\n        ret\\n    }\\n}\\n\\npub fn count_stations(\\n    stations: &Vec<usize>,\\n    radius: usize,\\n    baseline: usize,\\n) -> usize {\\n    let mut ret = usize::MIN;\\n\\n    let mut window = SlidingWindow::new(radius, baseline);\\n    for &token in stations.iter() {\\n        if let Some(_ret) = window.scan(token) {\\n            ret += _ret;\\n        }\\n    }\\n    ret += window.drain();\\n\\n    ret\\n}\\n\\n// Given a partitioned vector of [True, True, ..., False, False],\\n//   find the index to the partition point.\\n//\\n// This function is identical to Vec::partition_point(),\\n//   but it generates elements in the vector on-demand from `predicate`,\\n//   making it O(\\\\log n) space-wise.\\n//\\n// This is especially useful when searching across a large solution space.\\npub fn partition_point<P: FnMut(usize) -> bool>(p0: usize, p1: usize, mut predicate: P) -> usize {\\n    if p0 >= p1 { return p0; }\\n\\n    let p_decision = p0 + (p1 - p0) / 2;\\n    let (p0_next, p1_next) = if predicate(p_decision) {\\n        (p_decision + 1, p1)\\n    } else { (p0, p_decision) };\\n\\n    partition_point(p0_next, p1_next, predicate) // tail recursion\\n}\\n\\nimpl Solution {\\n    pub fn max_power(\\n        stations: Vec<i32>,\\n        radius: i32,\\n        num_stations: i32,\\n    ) -> i64 {\\n        let stations = stations.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>();\\n        let radius = radius as usize;\\n        let num_stations = num_stations as usize;\\n\\n        let mut ret = partition_point(\\n            usize::MIN, 100_000_000_000,\\n            |baseline| count_stations(&stations, radius, baseline) <= num_stations\\n        );\\n\\n        ret as i64 - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```rust\\nuse std::collections::VecDeque;\\n\\npub struct SlidingWindow {\\n    window_size_0: usize,\\n    window_size_1: usize,\\n    baseline: usize,\\n\\n    queue: VecDeque<usize>,\\n    queue_sum: usize,\\n}\\n\\nimpl SlidingWindow {\\n    pub fn new(radius: usize, baseline: usize) -> Self {\\n        let window_size_0 = radius + 1;\\n        let window_size_1 = radius * 2 + 1;\\n\\n        let queue = VecDeque::new();\\n        let queue_sum = usize::MIN;\\n\\n        Self {\\n            window_size_0, window_size_1,\\n            baseline,\\n            queue, queue_sum,\\n        }\\n    }\\n\\n    pub fn scan(&mut self, token: usize) -> Option<usize> {\\n        self.queue.push_back(token);\\n        self.queue_sum += token;\\n\\n        while self.queue.len() > self.window_size_1 {\\n            let token_frnt = self.queue.pop_front().unwrap();\\n            self.queue_sum -= token_frnt;\\n        }\\n\\n        if self.queue.len() < self.window_size_0 {\\n            return None;\\n        }\\n\\n        // window is valid\\n        if self.queue_sum >= self.baseline {\\n            return None; // above baseline\\n        }\\n\\n        let mut ret = usize::MIN;\\n        ret += self.baseline;\\n        ret -= self.queue_sum;\\n\\n        let e_back = self.queue.pop_back().unwrap();\\n        self.queue_sum -= e_back;\\n\\n        let e_back_next = e_back + ret;\\n        self.queue.push_back(e_back_next);\\n        self.queue_sum += e_back_next;\\n\\n        assert!(self.queue_sum >= self.baseline);\\n\\n        Some(ret)\\n    }\\n\\n    pub fn drain(mut self) -> usize {\\n        let mut ret = usize::MIN;\\n        while self.queue.len() > self.window_size_0 {\\n            let e_frnt = self.queue.pop_front().unwrap();\\n            self.queue_sum -= e_frnt;\\n\\n            if self.queue_sum >= self.baseline {\\n                continue;\\n            }\\n\\n            let mut _ret = usize::MIN;\\n            _ret += self.baseline;\\n            _ret -= self.queue_sum;\\n\\n            let e_back = self.queue.pop_back().unwrap();\\n            self.queue_sum -= e_back;\\n\\n            let e_back_next = e_back + _ret;\\n            self.queue.push_back(e_back_next);\\n            self.queue_sum += e_back_next;\\n\\n            assert!(self.queue_sum >= self.baseline);\\n\\n            ret += _ret;\\n        }\\n\\n        ret\\n    }\\n}\\n\\npub fn count_stations(\\n    stations: &Vec<usize>,\\n    radius: usize,\\n    baseline: usize,\\n) -> usize {\\n    let mut ret = usize::MIN;\\n\\n    let mut window = SlidingWindow::new(radius, baseline);\\n    for &token in stations.iter() {\\n        if let Some(_ret) = window.scan(token) {\\n            ret += _ret;\\n        }\\n    }\\n    ret += window.drain();\\n\\n    ret\\n}\\n\\n// Given a partitioned vector of [True, True, ..., False, False],\\n//   find the index to the partition point.\\n//\\n// This function is identical to Vec::partition_point(),\\n//   but it generates elements in the vector on-demand from `predicate`,\\n//   making it O(\\\\log n) space-wise.\\n//\\n// This is especially useful when searching across a large solution space.\\npub fn partition_point<P: FnMut(usize) -> bool>(p0: usize, p1: usize, mut predicate: P) -> usize {\\n    if p0 >= p1 { return p0; }\\n\\n    let p_decision = p0 + (p1 - p0) / 2;\\n    let (p0_next, p1_next) = if predicate(p_decision) {\\n        (p_decision + 1, p1)\\n    } else { (p0, p_decision) };\\n\\n    partition_point(p0_next, p1_next, predicate) // tail recursion\\n}\\n\\nimpl Solution {\\n    pub fn max_power(\\n        stations: Vec<i32>,\\n        radius: i32,\\n        num_stations: i32,\\n    ) -> i64 {\\n        let stations = stations.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>();\\n        let radius = radius as usize;\\n        let num_stations = num_stations as usize;\\n\\n        let mut ret = partition_point(\\n            usize::MIN, 100_000_000_000,\\n            |baseline| count_stations(&stations, radius, baseline) <= num_stations\\n        );\\n\\n        ret as i64 - 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933662,
                "title": "golang-line-sweep-binary-search-easy-understanding",
                "content": "# Code\\n```\\nfunc maxPower(stations []int, r int, k int) int64 {\\n  n := len(stations)\\n  power := make([]int64, n)\\n  for i := 0; i < len(stations); i++ {\\n    left, right := i - r, i + r + 1\\n    if left < 0 {\\n      left = 0\\n    }\\n    power[left] += int64(stations[i])\\n    if right < n {\\n      power[right] -= int64(stations[i])\\n    }\\n  }\\n  minP, maxP := power[0], power[0]\\n  for i := 1; i < n; i++ {\\n    power[i] += power[i-1]\\n    minP = min(minP, power[i])\\n    maxP = max(maxP, power[i])\\n  }\\n  left, right := minP, maxP + int64(k)\\n  var res int64\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if check(power, mid, r, int64(k)) {\\n      res = mid\\n      left = mid + 1\\n    } else {\\n      right = mid - 1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc check(power []int64, target int64, r int, k int64) bool {\\n  q := list.New() // Queue to remove the stations that fall out of range\\n  var extra int64 // additional stations that are in range.\\n  for i := 0; i < len(power); i++ {\\n    for q.Len() > 0 && q.Front().Value.([2]int64)[0] <= int64(i) {\\n      extra += q.Remove(q.Front()).([2]int64)[1]\\n    }\\n    if power[i] + extra < target {\\n      needed := target - power[i] - extra\\n      if k < needed {\\n        return false\\n      }\\n      extra += needed\\n      k -= needed\\n      if i + r + 1 < len(power) {\\n        // It is optimal to find a place farther from the current position that is still\\n        // within the range so we can get as many stations as possible. \\n        // We\\'re building the stations at i + r so its range is going to be from [i...i+2*r]\\n        q.PushBack([2]int64{int64(i+2*r+1), -needed})\\n      }\\n    }\\n  }\\n  return true\\n} \\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc min(a, b int64) int64 {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxPower(stations []int, r int, k int) int64 {\\n  n := len(stations)\\n  power := make([]int64, n)\\n  for i := 0; i < len(stations); i++ {\\n    left, right := i - r, i + r + 1\\n    if left < 0 {\\n      left = 0\\n    }\\n    power[left] += int64(stations[i])\\n    if right < n {\\n      power[right] -= int64(stations[i])\\n    }\\n  }\\n  minP, maxP := power[0], power[0]\\n  for i := 1; i < n; i++ {\\n    power[i] += power[i-1]\\n    minP = min(minP, power[i])\\n    maxP = max(maxP, power[i])\\n  }\\n  left, right := minP, maxP + int64(k)\\n  var res int64\\n  for left <= right {\\n    mid := left + (right - left)/2\\n    if check(power, mid, r, int64(k)) {\\n      res = mid\\n      left = mid + 1\\n    } else {\\n      right = mid - 1\\n    }\\n  }\\n  return res\\n}\\n\\nfunc check(power []int64, target int64, r int, k int64) bool {\\n  q := list.New() // Queue to remove the stations that fall out of range\\n  var extra int64 // additional stations that are in range.\\n  for i := 0; i < len(power); i++ {\\n    for q.Len() > 0 && q.Front().Value.([2]int64)[0] <= int64(i) {\\n      extra += q.Remove(q.Front()).([2]int64)[1]\\n    }\\n    if power[i] + extra < target {\\n      needed := target - power[i] - extra\\n      if k < needed {\\n        return false\\n      }\\n      extra += needed\\n      k -= needed\\n      if i + r + 1 < len(power) {\\n        // It is optimal to find a place farther from the current position that is still\\n        // within the range so we can get as many stations as possible. \\n        // We\\'re building the stations at i + r so its range is going to be from [i...i+2*r]\\n        q.PushBack([2]int64{int64(i+2*r+1), -needed})\\n      }\\n    }\\n  }\\n  return true\\n} \\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc min(a, b int64) int64 {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878943,
                "title": "binary-search-greedy-140-ms",
                "content": "# Complexity\\n- Time complexity:\\nO(log(maxPower + k - minPower) * n) + O(n) + O(n) ~= O(log(Range(Powers) + k) * n)\\n\\nwhere n is the number of cities, k is the number of additional power stations to install.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  public long maxPower(int[] stations, int r, int k) {\\n    long[] prefSumStations = new long[stations.length];\\n    for (int i = 0; i < stations.length; i++) {\\n      prefSumStations[i] = i == 0 ? stations[i] : (long) stations[i] + prefSumStations[i - 1];\\n    }\\n\\n    long[] powers = new long[stations.length];\\n    long maxPower = Long.MIN_VALUE, minPower = Long.MAX_VALUE;\\n    for (int i = 0; i < stations.length; i++) {\\n      powers[i] = (i + r >= stations.length ? prefSumStations[stations.length - 1] : prefSumStations[i + r])\\n          - (i - r - 1 >= 0 ? prefSumStations[i - r - 1] : 0);\\n      maxPower = Math.max(maxPower, powers[i]);\\n      minPower = Math.min(minPower, powers[i]);\\n    }\\n\\n    long left = minPower, right = maxPower + k;\\n    Map<Integer, Long> activeLocations = new HashMap<>();\\n    long minMaxPower = minPower;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      int countStations = k;\\n      activeLocations.clear();\\n      int i = 0, j = 0;\\n      long activeAddlPower = 0;\\n      long diff = -1;\\n      while (i < powers.length && j < powers.length) {\\n        if (j - i == r + 1) {\\n          diff = mid - powers[i] - activeAddlPower;\\n          activeLocations.put(Math.min(powers.length - 1, j - 1 + r), diff);\\n          activeAddlPower += diff - (activeLocations.containsKey(i) ? activeLocations.get(i) : 0);\\n          countStations -= diff;\\n\\n          if (countStations < 0) {\\n            break;\\n          }\\n          i++;\\n        }\\n\\n        while (j < powers.length && j - i <= r && powers[i] + activeAddlPower >= mid) {\\n          activeAddlPower -= activeLocations.containsKey(i) ? activeLocations.get(i) : 0;\\n          j += i == j ? 1 : 0;\\n          i += 1;\\n        }\\n\\n\\n        if (j == powers.length) {\\n          break;\\n        }\\n\\n        j++;\\n      }\\n\\n      if (j == powers.length) {\\n        diff = 0;\\n        while (i < powers.length) {\\n          diff = Math.max(mid - powers[i] - activeAddlPower, diff);\\n          activeAddlPower -= activeLocations.containsKey(i) ? activeLocations.get(i) : 0;\\n          i++;\\n        }\\n\\n        if (countStations - diff >= 0) {\\n          minMaxPower = mid;\\n          left = mid + 1;\\n          continue;\\n        }\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return minMaxPower;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public long maxPower(int[] stations, int r, int k) {\\n    long[] prefSumStations = new long[stations.length];\\n    for (int i = 0; i < stations.length; i++) {\\n      prefSumStations[i] = i == 0 ? stations[i] : (long) stations[i] + prefSumStations[i - 1];\\n    }\\n\\n    long[] powers = new long[stations.length];\\n    long maxPower = Long.MIN_VALUE, minPower = Long.MAX_VALUE;\\n    for (int i = 0; i < stations.length; i++) {\\n      powers[i] = (i + r >= stations.length ? prefSumStations[stations.length - 1] : prefSumStations[i + r])\\n          - (i - r - 1 >= 0 ? prefSumStations[i - r - 1] : 0);\\n      maxPower = Math.max(maxPower, powers[i]);\\n      minPower = Math.min(minPower, powers[i]);\\n    }\\n\\n    long left = minPower, right = maxPower + k;\\n    Map<Integer, Long> activeLocations = new HashMap<>();\\n    long minMaxPower = minPower;\\n    while (left <= right) {\\n      long mid = left + (right - left) / 2;\\n      int countStations = k;\\n      activeLocations.clear();\\n      int i = 0, j = 0;\\n      long activeAddlPower = 0;\\n      long diff = -1;\\n      while (i < powers.length && j < powers.length) {\\n        if (j - i == r + 1) {\\n          diff = mid - powers[i] - activeAddlPower;\\n          activeLocations.put(Math.min(powers.length - 1, j - 1 + r), diff);\\n          activeAddlPower += diff - (activeLocations.containsKey(i) ? activeLocations.get(i) : 0);\\n          countStations -= diff;\\n\\n          if (countStations < 0) {\\n            break;\\n          }\\n          i++;\\n        }\\n\\n        while (j < powers.length && j - i <= r && powers[i] + activeAddlPower >= mid) {\\n          activeAddlPower -= activeLocations.containsKey(i) ? activeLocations.get(i) : 0;\\n          j += i == j ? 1 : 0;\\n          i += 1;\\n        }\\n\\n\\n        if (j == powers.length) {\\n          break;\\n        }\\n\\n        j++;\\n      }\\n\\n      if (j == powers.length) {\\n        diff = 0;\\n        while (i < powers.length) {\\n          diff = Math.max(mid - powers[i] - activeAddlPower, diff);\\n          activeAddlPower -= activeLocations.containsKey(i) ? activeLocations.get(i) : 0;\\n          i++;\\n        }\\n\\n        if (countStations - diff >= 0) {\\n          minMaxPower = mid;\\n          left = mid + 1;\\n          continue;\\n        }\\n      }\\n\\n      right = mid - 1;\\n    }\\n\\n    return minMaxPower;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744215,
                "title": "c-python-binary-search-difference-array-solution-with-explanation",
                "content": "### binary search + difference array\\n\\nWe can use binary search to find maximum min power of city,\\n```check(min_power)``` function return true if power each city have >=```min_power```, if not, we can build a power stations to increase power of city ```[i, min(number of city, i+2r+1) )```, for example, if power of city 0 < ```min_power```, and ```r=1```, we can build some power stations at  power of city 1 (as right as possible, city 0 is leftmost city for power station we build), city 0,1,2 can use these power stations we build.\\nIf number of power stations we build additionally > k, return False.\\nIf not, return True.\\n\\nLeft bound of ```min_power``` is minimum power of a city has, right bound is left bound + k.\\n\\n```\\npower each city has [3, 7, 11, 9, 5], k = 2, r = 1\\nserach space is [3, 3+2]\\nmin_power          3 4 5 6\\ncheck(min_power)   T T T F\\nreturn 5\\nfind min_power which is rightmost true.\\n```\\n\\n\\nFirst, we should know power of each city has, we can use prefix sum to calculate.\\nAnd becaue we can build some power stations at city ```i``` additionally, it will make power of city ```[i-r, i+r]``` increase,\\nwhich is to adding a number of an interval, we can use differece array to do it.\\n\\n```stations``` is power of each city after we use prefix sum to calculate. \\n```cur_diff``` is accumlated difference value from city 0 to city i.\\n\\nTo add a ```n``` to city [i, j], add ```n``` to ```cur_diff``` at city ```i```, substract ```n``` to ```diff[j+1]```,\\nwhen we walk to city j+1, ```diff[j+1]``` will added to  ```cur_diff```.\\n\\ntc is O(nlogk), sc is O(n).\\n\\n### python\\n\\n```python\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n\\t\\n        prefix = [0] # prefix sum array\\n        size = len(stations)\\n\\t\\t\\n\\t\\t# calculate prefix sum with each city, we can get total number of power stations in city i to j\\n        for i in stations:\\n            prefix.append(prefix[-1] + i)\\n        \\n\\t\\t# calculate power each city has using prefix sum \\n        for i in range(size):\\n            stations[i] = prefix[min(i+r+1, size)] - prefix[max(0, i-r)]\\n        \\n\\t\\t# check(min_power) return True if number of power stations we build additionally <= k,\\n\\t\\t# if power of a city has < min_power,  build a power stations to increase power of city to meet power of a city >= k\\n\\t\\t# if number of power stations  we build additionally > k, return False\\n        def check(min_power):\\n\\t\\t\\n\\t\\t\\t\\n            diff = [0] * size # difference array\\n            cur_diff = 0 # number of stations we build\\n            cnt_station = 0 # accumlated difference value from city 0 to city i\\n            \\n\\t\\t\\t# for each city\\n            for i, power in enumerate(stations):\\n\\t\\t\\t\\t\\n                cur_diff += diff[i] # get current difference value\\n\\t\\t\\t\\t\\n                power_diff = min_power - power - cur_diff # power difference\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if power is insuffcient, build power stations\\n                if power_diff > 0: \\n\\t\\t\\t\\t\\t\\n                    cnt_station += power_diff # accumulte number of stations we build\\n\\t\\t\\t\\t\\t\\n                    if cnt_station > k: return False # if number of stations we build > k, reutrn False\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# city [i, i+2r] can use these station we build, these city\\'s power is increased \\n                    cur_diff += power_diff\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# out of range, power of city [i, size -1] is increased \\n                    if i + 2 * r + 1 < size: diff[i + 2 * r + 1] -= power_diff\\n            return True\\n        \\n        left = min(stations)\\n        right = left + k\\n\\t\\t\\n\\t\\t# search space is [left, right]\\n\\t\\t\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n\\t\\t\\t# try to increase min_power \\n            if check(mid): left = mid + 1\\n\\t\\t\\t# decrease min_power\\n            else: right = mid - 1\\n\\t\\t\\n        return right\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        vector<long> prefix {0};\\n        int size = stations.size();\\n        vector<long> power (size);\\n        \\n        for (int& p: stations)\\n            prefix.emplace_back(prefix.back() + p);\\n        \\n        for (int i = 0; i < size; i+=1)\\n            power[i] = prefix[min(size, i + r + 1)] - prefix[max(0, i - r)];\\n        \\n        auto check = [&] (long & min_power) -> bool {\\n            vector<long> diff (size);\\n            long cur_diff = 0, cnt_station = 0, power_diff;\\n            for (int i = 0; i < size; i+=1) {\\n                cur_diff += diff[i];\\n                power_diff = min_power - power[i] - cur_diff;\\n                if (power_diff > 0) {\\n                    cnt_station += power_diff;\\n                    if (cnt_station > k) return false;\\n                    cur_diff += power_diff;\\n                    if (i + 2 * r + 1 < size) diff[i + 2 * r + 1] -= power_diff;\\n                }\\n            }\\n            return true;\\n        };\\n        \\n        long left = *min_element(power.begin(), power.end());\\n        long right = left + k, mid;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (check(mid)) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "```check(min_power)```\n```min_power```\n```[i, min(number of city, i+2r+1) )```\n```min_power```\n```r=1```\n```min_power```\n```\\npower each city has [3, 7, 11, 9, 5], k = 2, r = 1\\nserach space is [3, 3+2]\\nmin_power          3 4 5 6\\ncheck(min_power)   T T T F\\nreturn 5\\nfind min_power which is rightmost true.\\n```\n```i```\n```[i-r, i+r]```\n```stations```\n```cur_diff```\n```n```\n```n```\n```cur_diff```\n```i```\n```n```\n```diff[j+1]```\n```diff[j+1]```\n```cur_diff```\n```python\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n\\t\\n        prefix = [0] # prefix sum array\\n        size = len(stations)\\n\\t\\t\\n\\t\\t# calculate prefix sum with each city, we can get total number of power stations in city i to j\\n        for i in stations:\\n            prefix.append(prefix[-1] + i)\\n        \\n\\t\\t# calculate power each city has using prefix sum \\n        for i in range(size):\\n            stations[i] = prefix[min(i+r+1, size)] - prefix[max(0, i-r)]\\n        \\n\\t\\t# check(min_power) return True if number of power stations we build additionally <= k,\\n\\t\\t# if power of a city has < min_power,  build a power stations to increase power of city to meet power of a city >= k\\n\\t\\t# if number of power stations  we build additionally > k, return False\\n        def check(min_power):\\n\\t\\t\\n\\t\\t\\t\\n            diff = [0] * size # difference array\\n            cur_diff = 0 # number of stations we build\\n            cnt_station = 0 # accumlated difference value from city 0 to city i\\n            \\n\\t\\t\\t# for each city\\n            for i, power in enumerate(stations):\\n\\t\\t\\t\\t\\n                cur_diff += diff[i] # get current difference value\\n\\t\\t\\t\\t\\n                power_diff = min_power - power - cur_diff # power difference\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if power is insuffcient, build power stations\\n                if power_diff > 0: \\n\\t\\t\\t\\t\\t\\n                    cnt_station += power_diff # accumulte number of stations we build\\n\\t\\t\\t\\t\\t\\n                    if cnt_station > k: return False # if number of stations we build > k, reutrn False\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# city [i, i+2r] can use these station we build, these city\\'s power is increased \\n                    cur_diff += power_diff\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# out of range, power of city [i, size -1] is increased \\n                    if i + 2 * r + 1 < size: diff[i + 2 * r + 1] -= power_diff\\n            return True\\n        \\n        left = min(stations)\\n        right = left + k\\n\\t\\t\\n\\t\\t# search space is [left, right]\\n\\t\\t\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n\\t\\t\\t# try to increase min_power \\n            if check(mid): left = mid + 1\\n\\t\\t\\t# decrease min_power\\n            else: right = mid - 1\\n\\t\\t\\n        return right\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        vector<long> prefix {0};\\n        int size = stations.size();\\n        vector<long> power (size);\\n        \\n        for (int& p: stations)\\n            prefix.emplace_back(prefix.back() + p);\\n        \\n        for (int i = 0; i < size; i+=1)\\n            power[i] = prefix[min(size, i + r + 1)] - prefix[max(0, i - r)];\\n        \\n        auto check = [&] (long & min_power) -> bool {\\n            vector<long> diff (size);\\n            long cur_diff = 0, cnt_station = 0, power_diff;\\n            for (int i = 0; i < size; i+=1) {\\n                cur_diff += diff[i];\\n                power_diff = min_power - power[i] - cur_diff;\\n                if (power_diff > 0) {\\n                    cnt_station += power_diff;\\n                    if (cnt_station > k) return false;\\n                    cur_diff += power_diff;\\n                    if (i + 2 * r + 1 < size) diff[i + 2 * r + 1] -= power_diff;\\n                }\\n            }\\n            return true;\\n        };\\n        \\n        long left = *min_element(power.begin(), power.end());\\n        long right = left + k, mid;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (check(mid)) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624879,
                "title": "simple-fully-explained-c-solution-binary-search-tc-nlogn-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> nlogn\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool chek(vector<long long>&p_sum , long long m , long long k , long long r){\\n        long long a = k , n = p_sum.size();\\n        n--;\\n        /* V1[i] stores the power by building new stations in [i - r , i + r] */\\n        vector<long long>v1( n+1 , 0 ) ;\\n        for(long long i = 0 ; i < n ; i++){\\n            // Taking prefix sum of v1 .\\n            if(i > 0)v1[i] += v1[i-1] ;\\n            /* If initial power + power by new staions is <= m , than go inside this condition and chek \\n              do we have enough stations to fulfill the requirements if have than continue else it \\n              can\\'t possible to have minimum power = m so return false .*/\\n            if(p_sum[i] + v1[i] < m ){\\n                long long s = m - p_sum[i] - v1[i];\\n                if(s <= a){\\n                v1[i] += s ;\\n                v1[min(n , i + 2*r + 1)] -= (s) ;\\n                a = a - s;\\n                }\\n                else return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        // p_sum vector store the total power in this city because of every station which is <= r distance far from it or inside it .\\n        vector<long long>p_sum(n+1 , 0);\\n        /* \\n        Range of station  ,  r = 2\\n                        indices ->  0 1 2 3 4 5 6 7 8\\n Number of stations in ith city ->  2 3 4 1 1 3 0 0 1\\n because of the power station at index 4 the power come to \\n         i = 4 , stations at (i = 4) is 1 ;\\n         2  <-  3  <- [4]  ->  5  ->  6\\n         |                            |\\n        i - r                        i + r\\npower   +1     +1     +1       +1     +1\\nas station[4] = 1 , means we have 1 station at 4 so we have to add 1 from i = 2 to i = 6 which is done above .\\n            2  <-  3  <- [4]  ->  5  ->  6     7\\n            |                            |     |\\n          i - r                        i + r  i + r + 1\\npower       +1     +1     +1      +1     +1     0\\n            +1                                 -1\\nRather than adding station[i] from i - r to i + r , we can add \\nstation[i] at i - r and subtract station[i] from i + r + 1 . At last take prefix. \\n       */\\n        for(int i = 0 ; i < n ; i++){\\n            p_sum[max(0 , i-r)] += stations[i];\\n            p_sum[min(n , i+r+1)] -= stations[i];\\n        }\\n        for(int i = 1 ; i < n ; i++)p_sum[i] += p_sum[i-1] ;\\n        long long s = 0 , e = *max_element(p_sum.begin() , p_sum.end()) + k ;\\n        /* Here I chek every minimum power by building new stations optimally by using binary search and returning maximum of every minimum power , so binary search is applied on minimum power */\\n        while(e - s > 1){\\n            long long m  = s + (e - s)/2 ;\\n            if(chek(p_sum , m , k , r))s = m ;\\n            else e = m - 1 ;\\n        }\\n        if(chek(p_sum , e , k , r))return e ;\\n        return s ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool chek(vector<long long>&p_sum , long long m , long long k , long long r){\\n        long long a = k , n = p_sum.size();\\n        n--;\\n        /* V1[i] stores the power by building new stations in [i - r , i + r] */\\n        vector<long long>v1( n+1 , 0 ) ;\\n        for(long long i = 0 ; i < n ; i++){\\n            // Taking prefix sum of v1 .\\n            if(i > 0)v1[i] += v1[i-1] ;\\n            /* If initial power + power by new staions is <= m , than go inside this condition and chek \\n              do we have enough stations to fulfill the requirements if have than continue else it \\n              can\\'t possible to have minimum power = m so return false .*/\\n            if(p_sum[i] + v1[i] < m ){\\n                long long s = m - p_sum[i] - v1[i];\\n                if(s <= a){\\n                v1[i] += s ;\\n                v1[min(n , i + 2*r + 1)] -= (s) ;\\n                a = a - s;\\n                }\\n                else return false ;\\n            }\\n        }\\n        return true ;\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        // p_sum vector store the total power in this city because of every station which is <= r distance far from it or inside it .\\n        vector<long long>p_sum(n+1 , 0);\\n        /* \\n        Range of station  ,  r = 2\\n                        indices ->  0 1 2 3 4 5 6 7 8\\n Number of stations in ith city ->  2 3 4 1 1 3 0 0 1\\n because of the power station at index 4 the power come to \\n         i = 4 , stations at (i = 4) is 1 ;\\n         2  <-  3  <- [4]  ->  5  ->  6\\n         |                            |\\n        i - r                        i + r\\npower   +1     +1     +1       +1     +1\\nas station[4] = 1 , means we have 1 station at 4 so we have to add 1 from i = 2 to i = 6 which is done above .\\n            2  <-  3  <- [4]  ->  5  ->  6     7\\n            |                            |     |\\n          i - r                        i + r  i + r + 1\\npower       +1     +1     +1      +1     +1     0\\n            +1                                 -1\\nRather than adding station[i] from i - r to i + r , we can add \\nstation[i] at i - r and subtract station[i] from i + r + 1 . At last take prefix. \\n       */\\n        for(int i = 0 ; i < n ; i++){\\n            p_sum[max(0 , i-r)] += stations[i];\\n            p_sum[min(n , i+r+1)] -= stations[i];\\n        }\\n        for(int i = 1 ; i < n ; i++)p_sum[i] += p_sum[i-1] ;\\n        long long s = 0 , e = *max_element(p_sum.begin() , p_sum.end()) + k ;\\n        /* Here I chek every minimum power by building new stations optimally by using binary search and returning maximum of every minimum power , so binary search is applied on minimum power */\\n        while(e - s > 1){\\n            long long m  = s + (e - s)/2 ;\\n            if(chek(p_sum , m , k , r))s = m ;\\n            else e = m - 1 ;\\n        }\\n        if(chek(p_sum , e , k , r))return e ;\\n        return s ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615118,
                "title": "simple-c-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    bool ispos(ll mid,vector<int>stations,ll r,ll k){\\n        ll sum = accumulate(begin(stations),begin(stations)+r,0LL);\\n        ll n = stations.size();\\n        // vector<ll>additions(n,0);\\n        for(ll i=0;i<n;i++){\\n            if(i+r<n){\\n                sum += stations[i+r];\\n            }\\n\\n            if(sum < mid){\\n                ll need = mid-sum;\\n\\n                if(need > k) return false;\\n                \\n                stations[min(n-1,i+r)] += need;\\n                sum += need;\\n                k -= need;\\n            }\\n\\n            if(i-r>=0){\\n                sum -= stations[i-r];\\n            }\\n        }\\n        return true;\\n    }\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        ll low = 0;\\n        ll high = 1e14;\\n        ll ans = 0;\\n\\n        while(low <= high){\\n            ll mid = low + (high-low)/2;\\n\\n            if(ispos(mid,stations,r,k)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    bool ispos(ll mid,vector<int>stations,ll r,ll k){\\n        ll sum = accumulate(begin(stations),begin(stations)+r,0LL);\\n        ll n = stations.size();\\n        // vector<ll>additions(n,0);\\n        for(ll i=0;i<n;i++){\\n            if(i+r<n){\\n                sum += stations[i+r];\\n            }\\n\\n            if(sum < mid){\\n                ll need = mid-sum;\\n\\n                if(need > k) return false;\\n                \\n                stations[min(n-1,i+r)] += need;\\n                sum += need;\\n                k -= need;\\n            }\\n\\n            if(i-r>=0){\\n                sum -= stations[i-r];\\n            }\\n        }\\n        return true;\\n    }\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        ll low = 0;\\n        ll high = 1e14;\\n        ll ans = 0;\\n\\n        while(low <= high){\\n            ll mid = low + (high-low)/2;\\n\\n            if(ispos(mid,stations,r,k)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid-1;\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513620,
                "title": "300ms-js-maximize-the-minimum-powered-city",
                "content": "# Intuition\\nIn this problem, we are given an array stations that represents the number of power stations in each city. Each power station has a fixed range denoted by r, which means it can provide power to all cities within a distance of r from itself. We are also given the number of additional power stations k that can be built. The task is to determine the maximum possible minimum power of a city if the additional power stations are built optimally.\\n\\n# Approach\\nTo solve this problem, we can use a binary search approach. We start by calculating the maximum possible total power by summing up the initial power stations in each city and adding k to it. We initialize the search range with start = 0 and end = sum.\\n\\nIn each iteration of the binary search, we calculate the mid value as mid = Math.floor(start + (end - start) / 2). We then check if it is possible to achieve the minimum power of mid using the canFinish function.\\n\\nThe canFinish function simulates the distribution of additional power stations and checks if the total number of additional power stations used is less than or equal to k. It iterates through each city, calculates the power within the range using the sliding window technique, and adjusts the power if necessary. It keeps track of the count of additional power stations used and compares it with k.\\n\\nIf it is possible to achieve the minimum power of mid, we update start = mid. Otherwise, we update end = mid.\\n\\nFinally, when start + 1 >= end, we check if it is possible to achieve the minimum power of end using the canFinish function. If it is possible, we return end; otherwise, we return start.\\n\\n# Complexity\\nTime complexity: The binary search approach reduces the search space in each iteration, resulting in a time complexity of O(log(sum)), where sum is the sum of all elements in the stations array.\\n\\nSpace complexity: We are using additional space to store the intermediate values and for the canFinish function, resulting in a space complexity of O(n), where n is the length of the stations array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} stations\\n * @param {number} r\\n * @param {number} k\\n * @return {number}\\n */\\nconst maxPower = (stations, r, k) => {\\n    const canFinish = (stations, r, k, target) => {\\n        let arr = stations.slice();\\n        let sum = 0;\\n        let count = 0;\\n        for (let j = 0; j < r; j++) sum += arr[j];\\n        for (let i = 0; i < arr.length; i++) {\\n            sum += (i + r < arr.length) ? arr[i + r] : 0;\\n            sum -= (i - r - 1 >= 0) ? arr[i - r - 1] : 0;\\n            if (sum < target) {\\n                count += target - sum;\\n                (i + r < arr.length) ? arr[i + r] += target - sum : arr[arr.length - 1] += target - sum;\\n                sum = target;\\n            }\\n        }\\n        return count <= k;\\n    };\\n\\n    let sum = k;\\n    for (let station of stations) sum += station;\\n\\n    let start = 0, end = sum;\\n    while (start + 1 < end) {\\n        let mid = Math.floor(start + (end - start) / 2);\\n        canFinish(stations, r, k, mid) ? start = mid : end = mid;\\n    }\\n    \\n    return canFinish(stations, r, k, end) ? end : start;\\n};\\n\\n```\\n\\n\\n# Breaking this down:\\n\\nIf you are interested in a breaking this code down, I wrote an [article on medium about it](https://medium.com/javascript-first/explaining-pointless-leetcode-2c4a492d9778).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stations\\n * @param {number} r\\n * @param {number} k\\n * @return {number}\\n */\\nconst maxPower = (stations, r, k) => {\\n    const canFinish = (stations, r, k, target) => {\\n        let arr = stations.slice();\\n        let sum = 0;\\n        let count = 0;\\n        for (let j = 0; j < r; j++) sum += arr[j];\\n        for (let i = 0; i < arr.length; i++) {\\n            sum += (i + r < arr.length) ? arr[i + r] : 0;\\n            sum -= (i - r - 1 >= 0) ? arr[i - r - 1] : 0;\\n            if (sum < target) {\\n                count += target - sum;\\n                (i + r < arr.length) ? arr[i + r] += target - sum : arr[arr.length - 1] += target - sum;\\n                sum = target;\\n            }\\n        }\\n        return count <= k;\\n    };\\n\\n    let sum = k;\\n    for (let station of stations) sum += station;\\n\\n    let start = 0, end = sum;\\n    while (start + 1 < end) {\\n        let mid = Math.floor(start + (end - start) / 2);\\n        canFinish(stations, r, k, mid) ? start = mid : end = mid;\\n    }\\n    \\n    return canFinish(stations, r, k, end) ? end : start;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455153,
                "title": "binary-search-for-possible-minimum-power-values-explanation",
                "content": "The required amount of power stations(**req**) to reach a minimum value \\'**x**\\' can be calculated in O(n).\\nif **req** is greater than **k** we try a smaller **x** value otherwise we try a larger x value.\\n**x** values are bounded by **min(initial powers)** ans **min(initial powers) + k** .\\nhence searching for this x in binary search fashion will require **log(k)** computation steps.\\nhence, TC = O(nlogk).\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        vector<long long> pow(stations.size(), 0);\\n        for(int i = 0; i <= r; i++){\\n            pow[0] += stations[i];\\n        }\\n        long long mi = pow[0];\\n        for(int i = 1; i < stations.size(); i++){\\n            pow[i] = pow[i - 1];\\n            if(i > r) pow[i] -= stations[i - r - 1];\\n            if(i + r < stations.size()) pow[i] += stations[i + r];\\n            mi = min(pow[i], mi);\\n        }\\n        long long ma = mi + k;\\n        long long m;\\n        long long req;\\n        int c;\\n        long long ans;\\n        while(mi <= ma){\\n            m = (ma + mi)/2;\\n            vector<int> mark(stations.size(), 0);\\n            int influence = 0;\\n            req = 0;\\n            for(int i = 0; i < stations.size(); i++){\\n                if(i > r) influence -= mark[i - r - 1];\\n                if(pow[i] + influence < m){\\n                    c =  m - (pow[i] + influence);\\n                    mark[min(i + r, (int)stations.size() - 1)] += c;\\n                    req += c;\\n                    influence +=c;\\n                }\\n            }\\n            if(req > k) ma = m - 1;\\n            else {\\n                ans = m;\\n                mi = m + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        vector<long long> pow(stations.size(), 0);\\n        for(int i = 0; i <= r; i++){\\n            pow[0] += stations[i];\\n        }\\n        long long mi = pow[0];\\n        for(int i = 1; i < stations.size(); i++){\\n            pow[i] = pow[i - 1];\\n            if(i > r) pow[i] -= stations[i - r - 1];\\n            if(i + r < stations.size()) pow[i] += stations[i + r];\\n            mi = min(pow[i], mi);\\n        }\\n        long long ma = mi + k;\\n        long long m;\\n        long long req;\\n        int c;\\n        long long ans;\\n        while(mi <= ma){\\n            m = (ma + mi)/2;\\n            vector<int> mark(stations.size(), 0);\\n            int influence = 0;\\n            req = 0;\\n            for(int i = 0; i < stations.size(); i++){\\n                if(i > r) influence -= mark[i - r - 1];\\n                if(pow[i] + influence < m){\\n                    c =  m - (pow[i] + influence);\\n                    mark[min(i + r, (int)stations.size() - 1)] += c;\\n                    req += c;\\n                    influence +=c;\\n                }\\n            }\\n            if(req > k) ma = m - 1;\\n            else {\\n                ans = m;\\n                mi = m + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274263,
                "title": "difference-array-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    # \\u5DEE\\u5206:[0, |0, 0, 0|, 0] -> \\u533A\\u95F4\\u52A0k [0, k, 0, 0, -k] -> \\u524D\\u7F00\\u548C[0, k, k, k, 0]\\u4E3A\\u53D8\\u5316\\u540E\\u7684\\u6570\\u7EC4\\n    # \\u521D\\u59CB\\u6570\\u76EE [3, 7, 11, 9, 5]: s[i] = prefix[max(n, i + r + 1)] - prefix[min(0, i - r)]\\n    # \\u5DEE\\u5206\\u6570\\u7EC4: min_power, \\u9700\\u8981\\u989D\\u5916\\u4FEE\\u5EFA min_power - s[i], \\u8D2A\\u5FC3\\u5EFA\\u5728 min(i + r, n - 1) \\u80FD\\u6700\\u5927\\u5F71\\u54CD, \\u5F71\\u54CD\\u7684\\u8303\\u56F4\\u662F(i, min(n-1, i + 2r)), \\u6BCF\\u4E00\\u6B21\\u9700\\u8981\\u989D\\u5916\\u4FEE\\u5EFA\\u90FD\\u4F1A\\u8BA9\\u540E\\u9762\\u5F71\\u54CD\\u8303\\u56F4\\u5185\\u7684\\u6570\\u7EC4\\u90FD+delta, \\u7528sum_diff\\u7528\\u6765\\u8BB0\\u5F55\\u7D2F\\u8BA1\\u7684\\u5DEE\\u5206\\u503C\\u7528\\u6765\\u66F4\\u65B0\\u6570\\u7EC4\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        prefix, n = [0], len(stations)\\n        for station in stations:\\n            prefix.append(prefix[-1] + station)\\n        \\n        # \\u521D\\u59CB\\u6570\\u7EC4\\n        for i in range(len(stations)):\\n            stations[i] = prefix[min(n, i + r + 1)] - prefix[max(0, i - r)]\\n        \\n        # check each answer min_power valid or not\\n        def check(min_power):\\n            sum_diff, extra = 0, 0\\n            diff = [0] * n\\n            for i, power in enumerate(stations):\\n                sum_diff += diff[i]\\n                cur_power = power + sum_diff\\n                d = min_power - cur_power \\n                if d > 0: # current need more d station\\n                    extra += d # acc to the total extra\\n                    if extra > k:\\n                        return False\\n                    sum_diff += d\\n                    if i + 2 * r + 1 < n:\\n                        diff[i + 2 * r + 1] -= d\\n            return True\\n        \\n        #\\u4E8C\\u5206\\u7B54\\u6848\\n        left, right = 0, prefix[n] + k + 1\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if check(mid):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return left - 1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # \\u5DEE\\u5206:[0, |0, 0, 0|, 0] -> \\u533A\\u95F4\\u52A0k [0, k, 0, 0, -k] -> \\u524D\\u7F00\\u548C[0, k, k, k, 0]\\u4E3A\\u53D8\\u5316\\u540E\\u7684\\u6570\\u7EC4\\n    # \\u521D\\u59CB\\u6570\\u76EE [3, 7, 11, 9, 5]: s[i] = prefix[max(n, i + r + 1)] - prefix[min(0, i - r)]\\n    # \\u5DEE\\u5206\\u6570\\u7EC4: min_power, \\u9700\\u8981\\u989D\\u5916\\u4FEE\\u5EFA min_power - s[i], \\u8D2A\\u5FC3\\u5EFA\\u5728 min(i + r, n - 1) \\u80FD\\u6700\\u5927\\u5F71\\u54CD, \\u5F71\\u54CD\\u7684\\u8303\\u56F4\\u662F(i, min(n-1, i + 2r)), \\u6BCF\\u4E00\\u6B21\\u9700\\u8981\\u989D\\u5916\\u4FEE\\u5EFA\\u90FD\\u4F1A\\u8BA9\\u540E\\u9762\\u5F71\\u54CD\\u8303\\u56F4\\u5185\\u7684\\u6570\\u7EC4\\u90FD+delta, \\u7528sum_diff\\u7528\\u6765\\u8BB0\\u5F55\\u7D2F\\u8BA1\\u7684\\u5DEE\\u5206\\u503C\\u7528\\u6765\\u66F4\\u65B0\\u6570\\u7EC4\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        prefix, n = [0], len(stations)\\n        for station in stations:\\n            prefix.append(prefix[-1] + station)\\n        \\n        # \\u521D\\u59CB\\u6570\\u7EC4\\n        for i in range(len(stations)):\\n            stations[i] = prefix[min(n, i + r + 1)] - prefix[max(0, i - r)]\\n        \\n        # check each answer min_power valid or not\\n        def check(min_power):\\n            sum_diff, extra = 0, 0\\n            diff = [0] * n\\n            for i, power in enumerate(stations):\\n                sum_diff += diff[i]\\n                cur_power = power + sum_diff\\n                d = min_power - cur_power \\n                if d > 0: # current need more d station\\n                    extra += d # acc to the total extra\\n                    if extra > k:\\n                        return False\\n                    sum_diff += d\\n                    if i + 2 * r + 1 < n:\\n                        diff[i + 2 * r + 1] -= d\\n            return True\\n        \\n        #\\u4E8C\\u5206\\u7B54\\u6848\\n        left, right = 0, prefix[n] + k + 1\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if check(mid):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return left - 1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140119,
                "title": "c-sliding-window-greedy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerable(vector<int> stations, long long minPower, int k, int r) {\\n        int start = -1*r;\\n        int end = r;\\n        int n = stations.size();\\n        \\n        long long current_pow = 0;\\n        for(int i=0; i<=r && i<n; i++){\\n            current_pow += stations[i];\\n        }\\n        \\n        int mid = 0;\\n        while(mid<n) {\\n            if(current_pow < minPower) {\\n                long long diff = minPower - current_pow;\\n                if(diff>k)return false;\\n                k -= diff;\\n                stations[min(mid+r, n-1)] += diff;\\n            }\\n            current_pow = max(current_pow, minPower);\\n            current_pow -= start>=0?stations[start]:0;\\n            current_pow += end<=n-2?stations[end+1]:0;\\n            start++;\\n            end++;\\n            mid++;\\n        }\\n        \\n        return true;\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n     \\n        long long start = 0;\\n        long long end = LONG_LONG_MAX;\\n        long long maxPow = 0;\\n        \\n        while(start<=end) {\\n            long long mid = (start + end)/2;\\n            if(isPowerable(stations, mid, k, r)) {\\n                start = mid+1;\\n                maxPow = max(maxPow, mid);\\n            }else {\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return maxPow;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerable(vector<int> stations, long long minPower, int k, int r) {\\n        int start = -1*r;\\n        int end = r;\\n        int n = stations.size();\\n        \\n        long long current_pow = 0;\\n        for(int i=0; i<=r && i<n; i++){\\n            current_pow += stations[i];\\n        }\\n        \\n        int mid = 0;\\n        while(mid<n) {\\n            if(current_pow < minPower) {\\n                long long diff = minPower - current_pow;\\n                if(diff>k)return false;\\n                k -= diff;\\n                stations[min(mid+r, n-1)] += diff;\\n            }\\n            current_pow = max(current_pow, minPower);\\n            current_pow -= start>=0?stations[start]:0;\\n            current_pow += end<=n-2?stations[end+1]:0;\\n            start++;\\n            end++;\\n            mid++;\\n        }\\n        \\n        return true;\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n     \\n        long long start = 0;\\n        long long end = LONG_LONG_MAX;\\n        long long maxPow = 0;\\n        \\n        while(start<=end) {\\n            long long mid = (start + end)/2;\\n            if(isPowerable(stations, mid, k, r)) {\\n                start = mid+1;\\n                maxPow = max(maxPow, mid);\\n            }else {\\n                end = mid-1;\\n            }\\n        }\\n        \\n        return maxPow;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130617,
                "title": "python3-binary-search-with-sliding-window-to-determine-possibility",
                "content": "```python\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        \"\"\"We know this is a binary search problem from the start, but the\\n        implementation has still evaded me for a quite a while.\\n\\n        First, we need to obtain the current power level for each station. I\\n        tried to use a sliding window for this, but it was kind of complicated.\\n        Thus, I opted for a simpler prefix sum.\\n\\n        Then, we do the binary search. The trick is to find a way to check\\n        whether the current power level can be reached given r and k.\\n\\n        A simple case is when the lowest powered station requires much more\\n        power than k. We can immediately consider this case impossible.\\n\\n        Otherwise, we need to go station by station that is currently lower\\n        than the desired power level. An implementation of sliding window and\\n        dynamically updated how much power is allowed to add to the current\\n        station thanks to the powers added in its previous neighbors wihtin the\\n        r range.\\n\\n        The rest is formality for binary search.\\n\\n        O(Nlog(sum of stations + k)), 4459 ms, faster than 49.77%\\n        \"\"\"\\n        N = len(stations)\\n        prestations = list(accumulate(stations))\\n        powers = []\\n        for i in range(N):\\n            lo, hi = i - r - 1, min(i + r, N - 1)\\n            powers.append(prestations[hi] - (prestations[lo] if lo >= 0 else 0))\\n        \\n        min_power = min(powers)\\n        lo, hi = min_power, max(powers) + k + 1\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if mid - min_power > k:\\n                hi = mid\\n            else:\\n                added_power = deque()\\n                # total_added is the total power added so far. We use this to\\n                # check against k.\\n                # allowed_to_add is the power allowed to be added for the\\n                # current station. allowed_to_add is updated dynamically,\\n                # because when the current station falls outside the range, any\\n                # added power at the beginning of added_power deque must be\\n                # removed from allowed_to_add.\\n                total_added = allowed_to_add = 0\\n                for i, p in ((i, p) for i, p in enumerate(powers) if p < mid):\\n                    while added_power and i - added_power[0][0] > 2 * r:\\n                        # current station is outside the influence of the first\\n                        # station in the dequa that gets additional power,\\n                        # thus it cannot take the additional power from the\\n                        # first station\\n                        _, pp = added_power.popleft()\\n                        allowed_to_add -= pp\\n                    to_add = max(0, mid - p - allowed_to_add)\\n                    total_added += to_add\\n                    if total_added > k:\\n                        break\\n                    allowed_to_add += to_add\\n                    added_power.append((i, to_add))\\n                else:\\n                    lo = mid + 1\\n                    continue\\n                hi = mid\\n        return lo - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        \"\"\"We know this is a binary search problem from the start, but the\\n        implementation has still evaded me for a quite a while.\\n\\n        First, we need to obtain the current power level for each station. I\\n        tried to use a sliding window for this, but it was kind of complicated.\\n        Thus, I opted for a simpler prefix sum.\\n\\n        Then, we do the binary search. The trick is to find a way to check\\n        whether the current power level can be reached given r and k.\\n\\n        A simple case is when the lowest powered station requires much more\\n        power than k. We can immediately consider this case impossible.\\n\\n        Otherwise, we need to go station by station that is currently lower\\n        than the desired power level. An implementation of sliding window and\\n        dynamically updated how much power is allowed to add to the current\\n        station thanks to the powers added in its previous neighbors wihtin the\\n        r range.\\n\\n        The rest is formality for binary search.\\n\\n        O(Nlog(sum of stations + k)), 4459 ms, faster than 49.77%\\n        \"\"\"\\n        N = len(stations)\\n        prestations = list(accumulate(stations))\\n        powers = []\\n        for i in range(N):\\n            lo, hi = i - r - 1, min(i + r, N - 1)\\n            powers.append(prestations[hi] - (prestations[lo] if lo >= 0 else 0))\\n        \\n        min_power = min(powers)\\n        lo, hi = min_power, max(powers) + k + 1\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if mid - min_power > k:\\n                hi = mid\\n            else:\\n                added_power = deque()\\n                # total_added is the total power added so far. We use this to\\n                # check against k.\\n                # allowed_to_add is the power allowed to be added for the\\n                # current station. allowed_to_add is updated dynamically,\\n                # because when the current station falls outside the range, any\\n                # added power at the beginning of added_power deque must be\\n                # removed from allowed_to_add.\\n                total_added = allowed_to_add = 0\\n                for i, p in ((i, p) for i, p in enumerate(powers) if p < mid):\\n                    while added_power and i - added_power[0][0] > 2 * r:\\n                        # current station is outside the influence of the first\\n                        # station in the dequa that gets additional power,\\n                        # thus it cannot take the additional power from the\\n                        # first station\\n                        _, pp = added_power.popleft()\\n                        allowed_to_add -= pp\\n                    to_add = max(0, mid - p - allowed_to_add)\\n                    total_added += to_add\\n                    if total_added > k:\\n                        break\\n                    allowed_to_add += to_add\\n                    added_power.append((i, to_add))\\n                else:\\n                    lo = mid + 1\\n                    continue\\n                hi = mid\\n        return lo - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084806,
                "title": "javascript-clean-code-binarysearch-sliding-window",
                "content": "# Code\\n```\\nvar maxPower = function(stations, r, k) {\\n    const isPossible = (minPower, windowPower) => {\\n        const n = stations.length, extraStations = Array(n).fill(0);\\n        let totalExtraStations = 0;\\n\\n        for (let i = 0, availableExtraPower = 0; i < n; i++) {\\n            if (i + r < n) windowPower += stations[i + r];\\n            if (i > r) windowPower -= stations[i - r - 1];\\n\\n            const extraPower = \\n                Math.max(minPower - (windowPower + availableExtraPower), 0);\\n            if (i + 2 * r < n)\\n                extraStations[i + 2 * r] = -extraPower;\\n            totalExtraStations += extraPower;\\n            availableExtraPower += extraPower + extraStations[i];\\n        }\\n\\n        return totalExtraStations <= k;\\n    };\\n\\n    let windowPower = 0, lPower = 0,\\n        rPower = stations.reduce((acc, cur) => acc + cur, k);\\n\\n    for (let i = 0; i < r; i++) windowPower += stations[i];\\n\\n    while (lPower < rPower) {\\n        const midPower = Math.floor((lPower + rPower + 1) / 2);\\n        isPossible(midPower, windowPower) \\n            ? lPower = midPower : rPower = midPower - 1;\\n    }\\n\\n    return lPower;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nvar maxPower = function(stations, r, k) {\\n    const isPossible = (minPower, windowPower) => {\\n        const n = stations.length, extraStations = Array(n).fill(0);\\n        let totalExtraStations = 0;\\n\\n        for (let i = 0, availableExtraPower = 0; i < n; i++) {\\n            if (i + r < n) windowPower += stations[i + r];\\n            if (i > r) windowPower -= stations[i - r - 1];\\n\\n            const extraPower = \\n                Math.max(minPower - (windowPower + availableExtraPower), 0);\\n            if (i + 2 * r < n)\\n                extraStations[i + 2 * r] = -extraPower;\\n            totalExtraStations += extraPower;\\n            availableExtraPower += extraPower + extraStations[i];\\n        }\\n\\n        return totalExtraStations <= k;\\n    };\\n\\n    let windowPower = 0, lPower = 0,\\n        rPower = stations.reduce((acc, cur) => acc + cur, k);\\n\\n    for (let i = 0; i < r; i++) windowPower += stations[i];\\n\\n    while (lPower < rPower) {\\n        const midPower = Math.floor((lPower + rPower + 1) / 2);\\n        isPossible(midPower, windowPower) \\n            ? lPower = midPower : rPower = midPower - 1;\\n    }\\n\\n    return lPower;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3080910,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is(vector<long long> &a,int r,int k,long long m){\\n        long long h , sum=0,ans =0;\\n        if(r==0){\\n            for(auto &i:a){\\n                if(i<m) ans += m-i;\\n                if(ans>k) return 0;\\n            }\\n            return 1;\\n        }\\n        queue<int> q;\\n        h =r*2;\\n        while(h--) q.push(0);\\n        for(auto &i:a){\\n            h = i+sum;\\n            if(h>=m) q.push(0);\\n            else{\\n                ans += (m-h);\\n                q.push(m-h);\\n                sum += (m-h);\\n            }\\n            if(ans>k) return 0;\\n            h = q.front();\\n            q.pop();\\n            sum -= h;\\n        }\\n        return 1;\\n    }\\n    \\n    long long maxPower(vector<int>& num, int r, int k) {\\n        long long l= 0 , h = 2e10 , m , ans,n = num.size() ,sum =0 ;\\n        vector<long long> a(n);\\n        for(int i=0;i<=r;i++) sum += num[i];\\n        for(int i=0;i<n;i++){\\n            a[i] = sum;\\n            if(i+r+1<n) sum += num[i+r+1];\\n            if(i>=r) sum -= num[i-r];\\n        }\\n        while(l<=h){\\n            m = l+(h-l)/2;\\n            if(!is(a,r,k,m)) h = m-1;\\n            else{ \\n                ans = m;\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(vector<long long> &a,int r,int k,long long m){\\n        long long h , sum=0,ans =0;\\n        if(r==0){\\n            for(auto &i:a){\\n                if(i<m) ans += m-i;\\n                if(ans>k) return 0;\\n            }\\n            return 1;\\n        }\\n        queue<int> q;\\n        h =r*2;\\n        while(h--) q.push(0);\\n        for(auto &i:a){\\n            h = i+sum;\\n            if(h>=m) q.push(0);\\n            else{\\n                ans += (m-h);\\n                q.push(m-h);\\n                sum += (m-h);\\n            }\\n            if(ans>k) return 0;\\n            h = q.front();\\n            q.pop();\\n            sum -= h;\\n        }\\n        return 1;\\n    }\\n    \\n    long long maxPower(vector<int>& num, int r, int k) {\\n        long long l= 0 , h = 2e10 , m , ans,n = num.size() ,sum =0 ;\\n        vector<long long> a(n);\\n        for(int i=0;i<=r;i++) sum += num[i];\\n        for(int i=0;i<n;i++){\\n            a[i] = sum;\\n            if(i+r+1<n) sum += num[i+r+1];\\n            if(i>=r) sum -= num[i-r];\\n        }\\n        while(l<=h){\\n            m = l+(h-l)/2;\\n            if(!is(a,r,k,m)) h = m-1;\\n            else{ \\n                ans = m;\\n                l = m+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079075,
                "title": "c-binary-search",
                "content": "# Intuition\\nBinary search the result, provide additional stations when the first station deficiency occurs, eliminate the effect after 2*range.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(LONG\\\\_LONG\\\\_MAX))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int range, int k) {\\n        long long l = 0, r = LONG_LONG_MAX - 1;\\n        int len = stations.size();\\n        vector<long long> cnts(len);\\n        long long pre = 0;\\n        // forward\\n        for (int i = 0; i < len; ++i) {\\n            pre += stations[i];\\n            cnts[i] += pre;\\n            if (i >= range) {\\n                pre -= stations[i - range];\\n            }\\n        }\\n        // backward\\n        pre = 0;\\n        for (int i = len - 1; i >= 0; --i) {\\n            cnts[i] += pre;\\n            pre += stations[i];\\n            if (i <= len - 1 - range) {\\n                pre -= stations[i + range];\\n            }\\n        }\\n        while (l < r) {\\n            long long mid = (l + r + 1) >> 1;\\n            auto check = [&]() -> bool {\\n                long long pre = 0;\\n                long long cum = 0;\\n                vector<long long> adds(len);\\n                for (int i = 0; i < len; ++i) {\\n                    if (i - 2 * range - 1 >= 0) pre -= adds[i - 2 * range - 1];\\n                    if (cnts[i] < mid) {\\n                        long long diff = mid - cnts[i];\\n                        if (diff > pre) {\\n                            adds[i] = diff - pre;\\n                            cum += adds[i];\\n                            pre = diff;\\n                        }\\n                    }\\n                    if (cum > k) {\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            };\\n            if (check()) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int range, int k) {\\n        long long l = 0, r = LONG_LONG_MAX - 1;\\n        int len = stations.size();\\n        vector<long long> cnts(len);\\n        long long pre = 0;\\n        // forward\\n        for (int i = 0; i < len; ++i) {\\n            pre += stations[i];\\n            cnts[i] += pre;\\n            if (i >= range) {\\n                pre -= stations[i - range];\\n            }\\n        }\\n        // backward\\n        pre = 0;\\n        for (int i = len - 1; i >= 0; --i) {\\n            cnts[i] += pre;\\n            pre += stations[i];\\n            if (i <= len - 1 - range) {\\n                pre -= stations[i + range];\\n            }\\n        }\\n        while (l < r) {\\n            long long mid = (l + r + 1) >> 1;\\n            auto check = [&]() -> bool {\\n                long long pre = 0;\\n                long long cum = 0;\\n                vector<long long> adds(len);\\n                for (int i = 0; i < len; ++i) {\\n                    if (i - 2 * range - 1 >= 0) pre -= adds[i - 2 * range - 1];\\n                    if (cnts[i] < mid) {\\n                        long long diff = mid - cnts[i];\\n                        if (diff > pre) {\\n                            adds[i] = diff - pre;\\n                            cum += adds[i];\\n                            pre = diff;\\n                        }\\n                    }\\n                    if (cum > k) {\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            };\\n            if (check()) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074958,
                "title": "c-binary-search",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    bool check(ll target,vector<int> stations,ll r,ll k)\\n    {\\n        ll n=stations.size();\\n        ll cur=0;\\n        for(int i=0;i<=r;i++)cur+=stations[i];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i-r-1>=0)cur-=stations[i-r-1];\\n            if(cur<target)\\n            {\\n                int right=min(n-1,i+r);\\n                ll dif=target-cur;\\n                if(dif>k)return false;\\n                k-=dif;\\n                stations[right]+=dif;\\n                cur+=dif;\\n            }\\n            if(i+r+1<n)cur+=stations[i+r+1];\\n        }\\n        return true;\\n    }\\n\\n    long long maxPower(vector<int>& stations, int range, int k) \\n    {\\n        ll l=0,r=5e11;\\n        while(l<r)\\n        {\\n            ll mid=(l+r)>>1;\\n            if(check(mid,stations,range,k))l=mid+1;\\n            else r=mid;\\n        }\\n        return l-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    bool check(ll target,vector<int> stations,ll r,ll k)\\n    {\\n        ll n=stations.size();\\n        ll cur=0;\\n        for(int i=0;i<=r;i++)cur+=stations[i];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i-r-1>=0)cur-=stations[i-r-1];\\n            if(cur<target)\\n            {\\n                int right=min(n-1,i+r);\\n                ll dif=target-cur;\\n                if(dif>k)return false;\\n                k-=dif;\\n                stations[right]+=dif;\\n                cur+=dif;\\n            }\\n            if(i+r+1<n)cur+=stations[i+r+1];\\n        }\\n        return true;\\n    }\\n\\n    long long maxPower(vector<int>& stations, int range, int k) \\n    {\\n        ll l=0,r=5e11;\\n        while(l<r)\\n        {\\n            ll mid=(l+r)>>1;\\n            if(check(mid,stations,range,k))l=mid+1;\\n            else r=mid;\\n        }\\n        return l-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063293,
                "title": "queue-binary-search-line-sweep-solution-python",
                "content": "**Intuition**\\nThe range of each station is `2r + 1`\\n\\n**Approach**\\nWe can use sweep line technique to find the power in each city before adding any extra stations. \\n\\n**For a given value** `minPower`, **can you find the number of extra stations needed such that power in each station** `>= minPower` **?**\\n\\nEvery time you come across a city which doesnt have enough power, add an extra station.\\nThe extra power effect of this new station will also increase the power of  next `2r` cities. \\n\\nWe can track the effect of **new** stations using a queue and if the top element of the que is out of range then we just pop it.\\n\\nWe can use this method with combination of binary search to find the max `minPower`\\n\\n**Time: O(n log n)\\nSpace: O(n)**\\n```\\ndef maxPower(self, stations: List[int], r: int, k: int) -> int:\\n    n = len(stations)\\n\\n    def extraCount(minPower):\\n        que = deque([]); queSum = 0\\n        count = 0\\n        for i in range(n):\\n            while que and que[0][0] < i:\\n                j, val = que.popleft()\\n                queSum -= val\\n            if power[i] + queSum < minPower:\\n                diff = minPower - queSum - power[i]\\n                que.append([i + 2*r, diff])\\n                queSum += diff\\n                count += diff\\n        return count\\n    \\n    sweep = [0]*(n+1)\\n    for i in range(n):\\n        sweep[max(i-r, 0)] += stations[i]\\n        sweep[min(i+r+1, n)] -= stations[i]\\n    power = list(accumulate(sweep)); power.pop()\\n    \\n    L = 0; R = min(power) + k\\n    while L < R:\\n        M = (L+R+1)//2\\n        if extraCount(M) <= k:\\n            L = M\\n        else:\\n            R = M-1\\n    return L\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Queue",
                    "Sliding Window",
                    "Line Sweep"
                ],
                "code": "```\\ndef maxPower(self, stations: List[int], r: int, k: int) -> int:\\n    n = len(stations)\\n\\n    def extraCount(minPower):\\n        que = deque([]); queSum = 0\\n        count = 0\\n        for i in range(n):\\n            while que and que[0][0] < i:\\n                j, val = que.popleft()\\n                queSum -= val\\n            if power[i] + queSum < minPower:\\n                diff = minPower - queSum - power[i]\\n                que.append([i + 2*r, diff])\\n                queSum += diff\\n                count += diff\\n        return count\\n    \\n    sweep = [0]*(n+1)\\n    for i in range(n):\\n        sweep[max(i-r, 0)] += stations[i]\\n        sweep[min(i+r+1, n)] -= stations[i]\\n    power = list(accumulate(sweep)); power.pop()\\n    \\n    L = 0; R = min(power) + k\\n    while L < R:\\n        M = (L+R+1)//2\\n        if extraCount(M) <= k:\\n            L = M\\n        else:\\n            R = M-1\\n    return L\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3053792,
                "title": "easy-java-solution-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# O(n log n)\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --\\nO(n)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean check(int[] stations,long mid,int r,int k){\\n        long sum = 0;\\n        int n = stations.length;\\n        long[] ans = new long[n];\\n            for(int i=0;i<n;i++)\\n            ans[i] = stations[i];\\n        for(int i=0;i<r;i++)\\n            sum+=ans[i];\\n        for(int i=0;i<n;i++){\\n            sum+=((i+r<=n-1)?ans[i+r]:0)-((i-r-1>=0)?ans[i-r-1]:0);\\n            if(sum<mid){\\n            if((mid-sum)>k)\\n            return false;\\n\\n            if(i+r<=n-1) ans[i+r] += (mid-sum); //greedy //required and added stations operations\\n            k-=(mid-sum);\\n            sum = mid;\\n            }\\n        }\\n        return true;\\n\\n\\n\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n        long l=0;\\n        long h =k;\\n        int n = stations.length;\\n        for(int i=0;i<n;i++)\\n           h+=(long)stations[i];\\n\\n        //binary search on ans\\n        while(l<h){\\n            long mid = h+(l-h)/2;\\n            if(check(stations,mid,r,k)) l = mid;\\n            else h = mid-1;\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean check(int[] stations,long mid,int r,int k){\\n        long sum = 0;\\n        int n = stations.length;\\n        long[] ans = new long[n];\\n            for(int i=0;i<n;i++)\\n            ans[i] = stations[i];\\n        for(int i=0;i<r;i++)\\n            sum+=ans[i];\\n        for(int i=0;i<n;i++){\\n            sum+=((i+r<=n-1)?ans[i+r]:0)-((i-r-1>=0)?ans[i-r-1]:0);\\n            if(sum<mid){\\n            if((mid-sum)>k)\\n            return false;\\n\\n            if(i+r<=n-1) ans[i+r] += (mid-sum); //greedy //required and added stations operations\\n            k-=(mid-sum);\\n            sum = mid;\\n            }\\n        }\\n        return true;\\n\\n\\n\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n        long l=0;\\n        long h =k;\\n        int n = stations.length;\\n        for(int i=0;i<n;i++)\\n           h+=(long)stations[i];\\n\\n        //binary search on ans\\n        while(l<h){\\n            long mid = h+(l-h)/2;\\n            if(check(stations,mid,r,k)) l = mid;\\n            else h = mid-1;\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051950,
                "title": "binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaxMin indicates binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOn a high level:\\n1. Binary search to find the maxMin;\\n2. Dp to store the continuous sum;\\n3. Two-pointer (or sliding window) to calculate the continuous sum;\\n4. Greedy + sliding window to check the validity of a specific middle value from binary search. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(1e14))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        vector<long long> dp1(n), dp2(n);\\n        long long s1 = 0, s2= 0;\\n        for(int i=0; i<n; ++i) {\\n            s1 += stations[i];\\n            if(i>r) s1 -= stations[i-r-1];\\n            dp1[i] = s1;\\n        }\\n        for(int i=n-1; i>=0; --i) {\\n            s2 += stations[i];\\n            if(i<n-r-1) s2 -= stations[i+r+1];\\n            dp2[i] = s2;\\n        }\\n        long long lt = 0, rt = 1e14;\\n        while(lt < rt) {\\n            long long m = lt + (rt - lt) / 2;\\n            if(isV(stations, dp1, dp2, m, k, r)) lt = m + 1;\\n            else rt = m;\\n        }   \\n        return isV(stations, dp1, dp2, lt, k, r) ? lt : lt - 1;\\n    }\\nprivate:\\n    bool isV(vector<int>& ss, vector<long long>& dp1, vector<long long>& dp2, long long m, int k, int r) {\\n        int n = ss.size(), ct = 0, rm = k;\\n        vector<int> ds(n, 0);\\n        for(int i=0; i<n; ++i) {\\n            if(i>r) ct -= ds[i-r-1];\\n            long long sum = dp1[i] + dp2[i] - ss[i] + ct;\\n            if(sum >= m) continue;\\n            long long diff = abs(sum - m);\\n            if(diff > rm) return false;\\n            int id = min(i+r, n-1);\\n            ds[id] += diff;\\n            rm -= diff;\\n            ct += diff;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        vector<long long> dp1(n), dp2(n);\\n        long long s1 = 0, s2= 0;\\n        for(int i=0; i<n; ++i) {\\n            s1 += stations[i];\\n            if(i>r) s1 -= stations[i-r-1];\\n            dp1[i] = s1;\\n        }\\n        for(int i=n-1; i>=0; --i) {\\n            s2 += stations[i];\\n            if(i<n-r-1) s2 -= stations[i+r+1];\\n            dp2[i] = s2;\\n        }\\n        long long lt = 0, rt = 1e14;\\n        while(lt < rt) {\\n            long long m = lt + (rt - lt) / 2;\\n            if(isV(stations, dp1, dp2, m, k, r)) lt = m + 1;\\n            else rt = m;\\n        }   \\n        return isV(stations, dp1, dp2, lt, k, r) ? lt : lt - 1;\\n    }\\nprivate:\\n    bool isV(vector<int>& ss, vector<long long>& dp1, vector<long long>& dp2, long long m, int k, int r) {\\n        int n = ss.size(), ct = 0, rm = k;\\n        vector<int> ds(n, 0);\\n        for(int i=0; i<n; ++i) {\\n            if(i>r) ct -= ds[i-r-1];\\n            long long sum = dp1[i] + dp2[i] - ss[i] + ct;\\n            if(sum >= m) continue;\\n            long long diff = abs(sum - m);\\n            if(diff > rm) return false;\\n            int id = min(i+r, n-1);\\n            ds[id] += diff;\\n            rm -= diff;\\n            ct += diff;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043976,
                "title": "c-binary-search-sliding-window-gready",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxPower(vector<int>& S, int r, int k) {\\n        auto check = [&](int a, ll m) {\\n            ll sum = 0;\\n            unordered_map<int, ll> mp;\\n            queue<int> q;\\n            for(int i = 0; i < S.size()+r; i++) {\\n                if(i < S.size()) sum += S[i];\\n                if(i >= r && sum < m) {\\n                    ll diff = m - sum;\\n                    if(diff > a) return false;\\n                    a -= diff;\\n                    sum += diff;\\n                    q.push(i);\\n                    mp[i] = diff;\\n                }\\n                if(i >= 2*r) {\\n                    int p = i - 2*r;\\n                    sum -= S[p];\\n                    if(!q.empty() && q.front() <= p) {\\n                        sum -= mp[q.front()];\\n                        q.pop();\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n\\n        ll l = 0, h = 1e11;\\n        while(l < h) {\\n            ll m = l + (h-l+1)/2;\\n            if(check(k, m)) l = m;\\n            else h = m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxPower(vector<int>& S, int r, int k) {\\n        auto check = [&](int a, ll m) {\\n            ll sum = 0;\\n            unordered_map<int, ll> mp;\\n            queue<int> q;\\n            for(int i = 0; i < S.size()+r; i++) {\\n                if(i < S.size()) sum += S[i];\\n                if(i >= r && sum < m) {\\n                    ll diff = m - sum;\\n                    if(diff > a) return false;\\n                    a -= diff;\\n                    sum += diff;\\n                    q.push(i);\\n                    mp[i] = diff;\\n                }\\n                if(i >= 2*r) {\\n                    int p = i - 2*r;\\n                    sum -= S[p];\\n                    if(!q.empty() && q.front() <= p) {\\n                        sum -= mp[q.front()];\\n                        q.pop();\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n\\n        ll l = 0, h = 1e11;\\n        while(l < h) {\\n            ll m = l + (h-l+1)/2;\\n            if(check(k, m)) l = m;\\n            else h = m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037500,
                "title": "binary-search-with-two-pointers-works-but-not-sure-why",
                "content": "# Intuition and Approach\\nThe idea is simple, I am checking if all the cities can have a minimum power of some \\'mid\\' value or not.\\nFor this I have pre-computed the current power of all cities in a vector v. Now comes the two pointer part. \\nLet\\'s denote the first index with value less than mid as l and the last index with value less than mid as r(**I had changed the input \\'int r\\' to \\'int range\\' for distinction.**).\\nNow if the span of this [l, r] is less than (2*range+1) then we can simply traverse v from l to r and find to minimum value in it and then simply decrease k by (mid-minimum_value).\\nElse, as soon as we reach such l, I am increasing the next 2*range values by mid-a[l]. Simlarly, for such r, I am increasing previous 2*range value by mid-a[r].\\nIf at any moment k becomes negative function returns false else it returns true.\\n\\n# Complexity\\n- Time complexity:\\nI believe the time complexity to be O(n^2) but the code still works. Any help would be appreciated.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long int mid, vector<long long int> ans, long long int k, int range)\\n    {\\n        int n=ans.size();\\n        int l=0, r=n-1;\\n        while(l<=r)\\n        {\\n            if(ans[l]>=mid)\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(ans[r]>=mid)\\n            {\\n                r--;\\n                continue;\\n            }\\n            int span=r-l+1;\\n            if(span<(2*range+1))\\n            {\\n                long long int mini=9e18;\\n                for(int i=l;i<=r;i++)\\n                {\\n                    mini=min(mini, ans[i]);\\n                }\\n                long long int req=mid-mini;\\n                k-=req;\\n                break;\\n            }\\n            long long int req=mid-ans[l];\\n            for(int i=l;i<(l+2*range+1);i++)\\n                ans[i]+=req;\\n            k-=req;\\n            l++;\\n            req=mid-ans[r];\\n            for(int i=r;i>=(r-2*range);i--)\\n                ans[i]+=req;\\n            k-=req;\\n            r--;\\n        }\\n        if(k<0)\\n            return false;\\n        return true;\\n    }\\n    long long int maxPower(vector<int>& a, int range, int k)\\n    {\\n        int n=a.size();\\n        vector<long long int> prefix(n), ans(n);\\n        prefix[0]=a[0];\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+a[i];\\n        long long int L=1e18, R=-1e18;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=i-range;\\n            l=max(l, 0);\\n            int r=i+range;\\n            r=min(r, n-1);\\n            if(l==0)\\n                ans[i]=prefix[r];\\n            else\\n                ans[i]=(prefix[r]-prefix[l-1]);\\n            L=min(ans[i], L);\\n            R=max(ans[i], R);\\n        }\\n        R+=k;\\n        long long int vv, temp_k=k;\\n        while(L<=R)\\n        {\\n            long long int mid=(L+R)/2;\\n            if(check(mid, ans, temp_k, range))\\n            {\\n                vv=mid;\\n                L=mid+1;\\n            }\\n            else\\n            {\\n                R=mid-1;\\n            }\\n        }\\n        return vv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long int mid, vector<long long int> ans, long long int k, int range)\\n    {\\n        int n=ans.size();\\n        int l=0, r=n-1;\\n        while(l<=r)\\n        {\\n            if(ans[l]>=mid)\\n            {\\n                l++;\\n                continue;\\n            }\\n            if(ans[r]>=mid)\\n            {\\n                r--;\\n                continue;\\n            }\\n            int span=r-l+1;\\n            if(span<(2*range+1))\\n            {\\n                long long int mini=9e18;\\n                for(int i=l;i<=r;i++)\\n                {\\n                    mini=min(mini, ans[i]);\\n                }\\n                long long int req=mid-mini;\\n                k-=req;\\n                break;\\n            }\\n            long long int req=mid-ans[l];\\n            for(int i=l;i<(l+2*range+1);i++)\\n                ans[i]+=req;\\n            k-=req;\\n            l++;\\n            req=mid-ans[r];\\n            for(int i=r;i>=(r-2*range);i--)\\n                ans[i]+=req;\\n            k-=req;\\n            r--;\\n        }\\n        if(k<0)\\n            return false;\\n        return true;\\n    }\\n    long long int maxPower(vector<int>& a, int range, int k)\\n    {\\n        int n=a.size();\\n        vector<long long int> prefix(n), ans(n);\\n        prefix[0]=a[0];\\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+a[i];\\n        long long int L=1e18, R=-1e18;\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=i-range;\\n            l=max(l, 0);\\n            int r=i+range;\\n            r=min(r, n-1);\\n            if(l==0)\\n                ans[i]=prefix[r];\\n            else\\n                ans[i]=(prefix[r]-prefix[l-1]);\\n            L=min(ans[i], L);\\n            R=max(ans[i], R);\\n        }\\n        R+=k;\\n        long long int vv, temp_k=k;\\n        while(L<=R)\\n        {\\n            long long int mid=(L+R)/2;\\n            if(check(mid, ans, temp_k, range))\\n            {\\n                vv=mid;\\n                L=mid+1;\\n            }\\n            else\\n            {\\n                R=mid-1;\\n            }\\n        }\\n        return vv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036034,
                "title": "binary-search-explanation",
                "content": "# Intuition\\n\\nThere are 2 key points:\\n1. We have a function `canAchieve` which determind if we can achieve **provided** minimum power by adding `k` stations. In other words we assume that we know a possible answer and try to check if it\\'s true.\\n2. We have a binary search from `min(stations)` to `sum(stations) + k`. `min(stations)` is a minimum possible answer if we cannot increase a power of minimum city. `sum(stations) + k` is a maximum possible answer if `r` >= `n`.\\n\\n`canAchieve` function logic:\\n1. Go though all cities and calculate a power of `i` city.\\n2. If the power is bigger or equals to the provided minimum power we do nothing.\\n3. If the power is less then the provided minimum power we put needed count of stations to `i + r` city. Previous cities are meet minimum requiring power and more reasonable is covering as much next stations as we can. That\\'s why we set all of them to `i + r` city.\\n4. If we can make all cities have power more or equals to a provided minimum power we store the provided power untill we get a better answer.\\n\\n# Approach\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        left = min(stations)\\n        right = sum(stations) + k\\n        result = left\\n        while left <= right:\\n            m = left + (right - left) // 2\\n            if self.canAchieve(stations[:], r, k, m):\\n                left = m + 1\\n                result = m\\n            else:\\n                right = m - 1\\n        return result\\n\\n    def canAchieve(self, stations: List[int], r: int, k: int, minV: int) -> bool:\\n        currentSum = sum(stations[:r])\\n        n = len(stations)\\n        for i in range(n):\\n            if r == 0:\\n                currentSum = stations[i]\\n            else:\\n                if i - r - 1 >= 0:\\n                    currentSum -= stations[i - 1 - r]\\n                if i + r < n:\\n                    currentSum += stations[i + r]\\n            if currentSum < minV:\\n                delta = minV - currentSum\\n                stations[min(n - 1, i + r)] += delta\\n                currentSum += delta\\n                k -= delta\\n            if k < 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        left = min(stations)\\n        right = sum(stations) + k\\n        result = left\\n        while left <= right:\\n            m = left + (right - left) // 2\\n            if self.canAchieve(stations[:], r, k, m):\\n                left = m + 1\\n                result = m\\n            else:\\n                right = m - 1\\n        return result\\n\\n    def canAchieve(self, stations: List[int], r: int, k: int, minV: int) -> bool:\\n        currentSum = sum(stations[:r])\\n        n = len(stations)\\n        for i in range(n):\\n            if r == 0:\\n                currentSum = stations[i]\\n            else:\\n                if i - r - 1 >= 0:\\n                    currentSum -= stations[i - 1 - r]\\n                if i + r < n:\\n                    currentSum += stations[i + r]\\n            if currentSum < minV:\\n                delta = minV - currentSum\\n                stations[min(n - 1, i + r)] += delta\\n                currentSum += delta\\n                k -= delta\\n            if k < 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3035686,
                "title": "racker-binary-search-with-comments",
                "content": "# Approach\\nWe can check, how many additional stations we have to build if we asked to reach certain minimum city power.\\n\\nWe can go through the cities keeping track of the current power for each city, whenever it\\'s lower than required minimum we can build the station at the right-most border, so it would power as many next cities as possible (the **Greedy** part)\\n\\nWe can track of the current amount of station powering the city, simply adding stations at the right-most reach border, and removing at the left-most reach-border (the **Sliding Window** part)\\n\\nUsing that we can execute binary search checking greatest minimum city power reachable with no more than k additional stations built.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\cdot log(m))$$\\n- Space complexity:\\n$$O(n \\\\cdot log(m))$$\\n\\nWhere $$n$$ - is the size of array stations and $$m$$ - is upper bound for the search currently ``sum(stations) + r``\\n# Code\\n```\\n(define (max-power stations r k)\\n  (define init (apply vector stations)) ; converting to vector\\n  (define n* (sub1 (vector*-length init))) ; index of the last element\\n  (define (can-provide u) ; the function that be called during binary search\\n    (define vs (vector-copy init)) ; mutable array instead of queue with modified stations\\n    (define (getv i) (if (<= 0 i n*) (vector*-ref vs i) 0)) ; get current power of the city stations\\n    (define (addv i x) (when (> x 0) ; build additional stations at the city\\n                         (define i* (max 0 (min i n*))) ; next \\n                         (define cur (vector*-ref vs i*))\\n                         (vector*-set! vs i* (+ cur x))))\\n    (define zero-power (for/sum ((i (in-range (add1 r)))) (getv i))) ; power at city 0\\n    (let go ((cur 0) (i 0) (power zero-power)) ; loop through the cities can exit early\\n      (define (step) ; analyze current and go to the next city\\n        (define lack (max 0 (- u power))) ; lack of power due to requirement\\n        (define cur* (+ cur lack)) ; updated added stations\\n        (addv (+ i r) lack)        ; building stations due to lack at the rightmost edge\\n        (define power* (+          ; power of the next city, including\\n                        power      ; ... current power\\n                        lack       ; ... additional stations\\n                        (getv (+ i r 1)) ; ... stations at the next right-border city\\n                        (- (getv (- i r))))) ; excluding stations at the previous left-border city\\n        (go cur* (add1 i) power*)) ; go to the next city\\n\\n      (cond ((> cur k) false)      ; we\\'ve built too many additional stations? exit with fail\\n            ((> i n*)  true)       ; reached the end of the array - exit with success\\n            (else      (step)))))  ; go to the next city\\n  (define init-high (+ k (apply + stations) 1)) ; maximum unreachable power\\n  (let bin-search ((low 0) (high init-high)) ; binary search loop\\n    (define m (quotient (+ high low) 2))     ; middle\\n    (cond  \\n      ((<= (- high low) 1) low)                  ; end of the search\\n      ((can-provide m)     (bin-search m high))  ; if middle value successfully veridfied, try greater\\n      (else                (bin-search low m))))) ; if failed try lower\\n\\n```",
                "solutionTags": [
                    "Racket",
                    "Binary Search",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\n(define (max-power stations r k)\\n  (define init (apply vector stations)) ; converting to vector\\n  (define n* (sub1 (vector*-length init))) ; index of the last element\\n  (define (can-provide u) ; the function that be called during binary search\\n    (define vs (vector-copy init)) ; mutable array instead of queue with modified stations\\n    (define (getv i) (if (<= 0 i n*) (vector*-ref vs i) 0)) ; get current power of the city stations\\n    (define (addv i x) (when (> x 0) ; build additional stations at the city\\n                         (define i* (max 0 (min i n*))) ; next \\n                         (define cur (vector*-ref vs i*))\\n                         (vector*-set! vs i* (+ cur x))))\\n    (define zero-power (for/sum ((i (in-range (add1 r)))) (getv i))) ; power at city 0\\n    (let go ((cur 0) (i 0) (power zero-power)) ; loop through the cities can exit early\\n      (define (step) ; analyze current and go to the next city\\n        (define lack (max 0 (- u power))) ; lack of power due to requirement\\n        (define cur* (+ cur lack)) ; updated added stations\\n        (addv (+ i r) lack)        ; building stations due to lack at the rightmost edge\\n        (define power* (+          ; power of the next city, including\\n                        power      ; ... current power\\n                        lack       ; ... additional stations\\n                        (getv (+ i r 1)) ; ... stations at the next right-border city\\n                        (- (getv (- i r))))) ; excluding stations at the previous left-border city\\n        (go cur* (add1 i) power*)) ; go to the next city\\n\\n      (cond ((> cur k) false)      ; we\\'ve built too many additional stations? exit with fail\\n            ((> i n*)  true)       ; reached the end of the array - exit with success\\n            (else      (step)))))  ; go to the next city\\n  (define init-high (+ k (apply + stations) 1)) ; maximum unreachable power\\n  (let bin-search ((low 0) (high init-high)) ; binary search loop\\n    (define m (quotient (+ high low) 2))     ; middle\\n    (cond  \\n      ((<= (- high low) 1) low)                  ; end of the search\\n      ((can-provide m)     (bin-search m high))  ; if middle value successfully veridfied, try greater\\n      (else                (bin-search low m))))) ; if failed try lower\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031098,
                "title": "binary-search-java",
                "content": "\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canIBeTheMinimum(long[] power,long minimum,int k,int r)\\n    {\\n        int n=power.length;\\n        //System.out.print(minimum+\" : \");\\n        long[] extrapower=new long[n];\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0) extrapower[i]+=extrapower[i-1];\\n            long curPower=power[i]+extrapower[i];\\n\\n            long req=minimum-curPower;\\n            //System.out.print(req+\" \");\\n            if(req<=0) continue;\\n\\n            if(req>k) return false;\\n\\n            k-=req;\\n\\n            extrapower[i]+=(req);\\n            if(i+2*r+1<n)\\n                extrapower[i+2*r+1]-=(req);\\n\\n        }\\n        System.out.println();\\n            return true;\\n    }\\n    long[] calculatePowerArray(int[] stations,int r)\\n    {\\n        int n=stations.length;\\n        long[] preSum=new long[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int st=i-r,last=i+r+1;\\n            if(st<0) st=0;\\n            preSum[st]+=stations[i];\\n\\n            if(last<n)\\n                preSum[last]-=stations[i];\\n        }\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            preSum[i]+=preSum[i-1];\\n        }\\n\\n            return preSum;\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n     \\n        long min=0;\\n        long sum=(long)Math.pow(10,10)+(long)Math.pow(10,9);\\n\\n        long[] power=calculatePowerArray(stations,r);\\n        long ans=-1;\\n        //System.out.println(Arrays.toString(power));\\n        while(min<=sum)\\n        {\\n            long mid=(min+sum)>>1;\\n            if(canIBeTheMinimum(power,mid,k,r))\\n            {\\n                ans=mid;\\n                min=mid+1;\\n            }\\n            else\\n            {\\n                sum=mid-1;\\n            }\\n        }\\n        \\n\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canIBeTheMinimum(long[] power,long minimum,int k,int r)\\n    {\\n        int n=power.length;\\n        //System.out.print(minimum+\" : \");\\n        long[] extrapower=new long[n];\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0) extrapower[i]+=extrapower[i-1];\\n            long curPower=power[i]+extrapower[i];\\n\\n            long req=minimum-curPower;\\n            //System.out.print(req+\" \");\\n            if(req<=0) continue;\\n\\n            if(req>k) return false;\\n\\n            k-=req;\\n\\n            extrapower[i]+=(req);\\n            if(i+2*r+1<n)\\n                extrapower[i+2*r+1]-=(req);\\n\\n        }\\n        System.out.println();\\n            return true;\\n    }\\n    long[] calculatePowerArray(int[] stations,int r)\\n    {\\n        int n=stations.length;\\n        long[] preSum=new long[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int st=i-r,last=i+r+1;\\n            if(st<0) st=0;\\n            preSum[st]+=stations[i];\\n\\n            if(last<n)\\n                preSum[last]-=stations[i];\\n        }\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            preSum[i]+=preSum[i-1];\\n        }\\n\\n            return preSum;\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n     \\n        long min=0;\\n        long sum=(long)Math.pow(10,10)+(long)Math.pow(10,9);\\n\\n        long[] power=calculatePowerArray(stations,r);\\n        long ans=-1;\\n        //System.out.println(Arrays.toString(power));\\n        while(min<=sum)\\n        {\\n            long mid=(min+sum)>>1;\\n            if(canIBeTheMinimum(power,mid,k,r))\\n            {\\n                ans=mid;\\n                min=mid+1;\\n            }\\n            else\\n            {\\n                sum=mid-1;\\n            }\\n        }\\n        \\n\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030864,
                "title": "binary-search-sliding-window",
                "content": "# Intuition\\nWhen they say maximum, BS comes to mind. You just need to figure out the check function. \\n\\nIf you see the problem basically boils down to, find maximum of minimum subarray sum of length >= r+1.\\n\\nSo suppose you calculate a sum and it is smaller than mid of BS. What is the optimal place to add the difference between sum-mid?\\n\\nIf you figure that out, the question is solved.\\n\\n# Approach\\nBinary Search + Sliding Window\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> st, long long mid, int rs, int k)\\n    {\\n        long long sum = 0;\\n        for (int i=0; i<rs; i++) sum += st[i];\\n        int l = 0, r = rs, n = st.size();\\n        // cout << endl;\\n        // cout << mid << endl;\\n        for (int i=0; i<n; i++)\\n        {\\n            // cout << sum << endl;\\n            if (r < n)\\n                sum += st[r];\\n            // cout << l << \" \" << r << endl;\\n            if (r-l >= (rs*2+1))\\n                sum -= st[l++];\\n            // cout << sum << endl;\\n            r++;\\n            if (sum < mid && mid-sum <= k)\\n            {\\n            // below line is the gist of the problem\\n                st[min(r-1, n-1)] += (mid-sum);\\n                k -= (mid-sum);\\n                sum = mid;\\n            }\\n            if (sum < mid)\\n                return false;\\n        }\\n        // cout << endl;\\n        return true;\\n    }\\n    long long maxPower(vector<int>& st, int rs, int k) \\n    {\\n        long long lo = 0, hi = 1e15, ans = 0;\\n        while (lo <= hi)\\n        {\\n            long long mid = (lo+hi)/2;\\n            if (check(st, mid, rs, k))\\n            {\\n                // cout << mid << endl;\\n                lo = mid+1;\\n                ans = max(ans, mid);\\n            }\\n            else\\n                hi = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> st, long long mid, int rs, int k)\\n    {\\n        long long sum = 0;\\n        for (int i=0; i<rs; i++) sum += st[i];\\n        int l = 0, r = rs, n = st.size();\\n        // cout << endl;\\n        // cout << mid << endl;\\n        for (int i=0; i<n; i++)\\n        {\\n            // cout << sum << endl;\\n            if (r < n)\\n                sum += st[r];\\n            // cout << l << \" \" << r << endl;\\n            if (r-l >= (rs*2+1))\\n                sum -= st[l++];\\n            // cout << sum << endl;\\n            r++;\\n            if (sum < mid && mid-sum <= k)\\n            {\\n            // below line is the gist of the problem\\n                st[min(r-1, n-1)] += (mid-sum);\\n                k -= (mid-sum);\\n                sum = mid;\\n            }\\n            if (sum < mid)\\n                return false;\\n        }\\n        // cout << endl;\\n        return true;\\n    }\\n    long long maxPower(vector<int>& st, int rs, int k) \\n    {\\n        long long lo = 0, hi = 1e15, ans = 0;\\n        while (lo <= hi)\\n        {\\n            long long mid = (lo+hi)/2;\\n            if (check(st, mid, rs, k))\\n            {\\n                // cout << mid << endl;\\n                lo = mid+1;\\n                ans = max(ans, mid);\\n            }\\n            else\\n                hi = mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3026925,
                "title": "java-most-simple-binary-search-sliding-window-and-greedy-with-comments",
                "content": "# Complexity\\n- Time complexity: O(nlog(high))\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int[]sta,int r,int k,long mid){\\n        long sum=0;\\n        int []arr=sta.clone();\\n        for(int i=0;i<=r;i++) sum+=arr[i];\\n        int ind=0;\\n        long aval=k;\\n        while(ind<arr.length){\\n            if(ind-r-1>=0)sum-=arr[ind-r-1];\\n            if(ind+r<arr.length&&ind!=0)sum+=arr[ind+r];\\n            if(sum<mid){\\n                long diff=mid-sum;\\n                if(diff>aval)return false;\\n                arr[Math.min(arr.length-1,ind+r)]+=diff;\\n                //put the diff in the rightmost range to get Maximum Benifit\\n                aval-=diff;\\n                sum=mid;\\n                //sum+=mid-sum\\n            }\\n            ind++;\\n        }\\n        return true;\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n        long low=Integer.MAX_VALUE;\\n        long high=0;\\n        for(int i:stations){\\n            high+=i;\\n            low=Math.min(low,i);\\n        }dsad\\n        //to Get the highest and lowest value in the station\\n        //for limited binary Search Operations.\\n        high+=k;\\n        long ans=-1;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if(isPossible(stations,r,k,mid)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int[]sta,int r,int k,long mid){\\n        long sum=0;\\n        int []arr=sta.clone();\\n        for(int i=0;i<=r;i++) sum+=arr[i];\\n        int ind=0;\\n        long aval=k;\\n        while(ind<arr.length){\\n            if(ind-r-1>=0)sum-=arr[ind-r-1];\\n            if(ind+r<arr.length&&ind!=0)sum+=arr[ind+r];\\n            if(sum<mid){\\n                long diff=mid-sum;\\n                if(diff>aval)return false;\\n                arr[Math.min(arr.length-1,ind+r)]+=diff;\\n                //put the diff in the rightmost range to get Maximum Benifit\\n                aval-=diff;\\n                sum=mid;\\n                //sum+=mid-sum\\n            }\\n            ind++;\\n        }\\n        return true;\\n    }\\n    public long maxPower(int[] stations, int r, int k) {\\n        long low=Integer.MAX_VALUE;\\n        long high=0;\\n        for(int i:stations){\\n            high+=i;\\n            low=Math.min(low,i);\\n        }dsad\\n        //to Get the highest and lowest value in the station\\n        //for limited binary Search Operations.\\n        high+=k;\\n        long ans=-1;\\n        while(low<=high){\\n            long mid=low+(high-low)/2;\\n            if(isPossible(stations,r,k,mid)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026682,
                "title": "c-binary-search-concise-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        using ll = long long;\\n        int n = size(stations);\\n        ll lo = 0, hi = LLONG_MAX;\\n        while (lo < hi) {\\n            ll mid = hi - (hi - lo) / 2;\\n            vector<int> v(stations);\\n            ll cnt = k, cur = accumulate(begin(v), begin(v)+r+1, 0LL);\\n            bool valid = true;\\n            for (int i = 0; i < n; i++) {\\n                if (cur < mid) {\\n                    ll need = mid - cur;\\n                    if (need > cnt) {\\n                        valid = false;\\n                        break;\\n                    }\\n                    cnt -= need;\\n                    cur += need;\\n                    v[min(n-1, i+r)] += need;\\n                }\\n                if (i >= r) cur -= v[i-r];\\n                if (i+r+1 < n) cur += v[i+r+1];\\n            }\\n            if (valid) lo = mid;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        using ll = long long;\\n        int n = size(stations);\\n        ll lo = 0, hi = LLONG_MAX;\\n        while (lo < hi) {\\n            ll mid = hi - (hi - lo) / 2;\\n            vector<int> v(stations);\\n            ll cnt = k, cur = accumulate(begin(v), begin(v)+r+1, 0LL);\\n            bool valid = true;\\n            for (int i = 0; i < n; i++) {\\n                if (cur < mid) {\\n                    ll need = mid - cur;\\n                    if (need > cnt) {\\n                        valid = false;\\n                        break;\\n                    }\\n                    cnt -= need;\\n                    cur += need;\\n                    v[min(n-1, i+r)] += need;\\n                }\\n                if (i >= r) cur -= v[i-r];\\n                if (i+r+1 < n) cur += v[i+r+1];\\n            }\\n            if (valid) lo = mid;\\n            else hi = mid - 1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026294,
                "title": "c-faster-than-100-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Binary Search\\n\\n# Complexity\\n- Time complexity:O(N*log(sum of powerstations+k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bs(long long l,long long h,long long&ans,long long power[],int r,int k,int n){\\n        long long minus[n];\\n        while(l<=h){\\n            long long mid=(l+h)/2;\\n            int avlk=k;\\n            long long ext=0;\\n            for(int i=0;i<n;i++){\\n                minus[i]=0;\\n            }\\n            bool possible=true;\\n            for(int i=0;i<n;i++){\\n                ext-=minus[i];\\n                if(power[i]+ext<mid){\\n                    long long diff=mid-(power[i]+ext);\\n                    if(diff>avlk){\\n                        h=mid-1;\\n                        possible=false;\\n                        break;\\n                    }\\n                    else{\\n                        avlk-=diff;\\n                        ext+=diff;\\n                        int ir=i+2*r+1;\\n                        if(ir<n){\\n                            minus[ir]+=diff;\\n                        }\\n                    }\\n                }\\n            }\\n            if(possible){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n        }\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n=stations.size();\\n        long long pre[n];\\n        pre[0]=stations[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+stations[i];\\n        }\\n        long long power[n];\\n        for(int i=0;i<n;i++){\\n            if(i-r-1<0){\\n                power[i]=pre[i];\\n            }\\n            else{\\n                power[i]=pre[i]-pre[i-r-1];\\n            }\\n            if(i+r<n){\\n                power[i]=power[i]+pre[i+r]-pre[i];\\n            }\\n            else{\\n                power[i]=power[i]+pre[n-1]-pre[i];\\n            }\\n        }\\n        long long ans=0;\\n        bs(0,pre[n-1]+k,ans,power,r,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bs(long long l,long long h,long long&ans,long long power[],int r,int k,int n){\\n        long long minus[n];\\n        while(l<=h){\\n            long long mid=(l+h)/2;\\n            int avlk=k;\\n            long long ext=0;\\n            for(int i=0;i<n;i++){\\n                minus[i]=0;\\n            }\\n            bool possible=true;\\n            for(int i=0;i<n;i++){\\n                ext-=minus[i];\\n                if(power[i]+ext<mid){\\n                    long long diff=mid-(power[i]+ext);\\n                    if(diff>avlk){\\n                        h=mid-1;\\n                        possible=false;\\n                        break;\\n                    }\\n                    else{\\n                        avlk-=diff;\\n                        ext+=diff;\\n                        int ir=i+2*r+1;\\n                        if(ir<n){\\n                            minus[ir]+=diff;\\n                        }\\n                    }\\n                }\\n            }\\n            if(possible){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n        }\\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n=stations.size();\\n        long long pre[n];\\n        pre[0]=stations[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+stations[i];\\n        }\\n        long long power[n];\\n        for(int i=0;i<n;i++){\\n            if(i-r-1<0){\\n                power[i]=pre[i];\\n            }\\n            else{\\n                power[i]=pre[i]-pre[i-r-1];\\n            }\\n            if(i+r<n){\\n                power[i]=power[i]+pre[i+r]-pre[i];\\n            }\\n            else{\\n                power[i]=power[i]+pre[n-1]-pre[i];\\n            }\\n        }\\n        long long ans=0;\\n        bs(0,pre[n-1]+k,ans,power,r,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024301,
                "title": "c-presum-concept-binary-search-video-solution",
                "content": "Such a great problem, absolutely loved it, a lot of great concept I learned from this problem\\u2764\\uFE0F\\nVideo solution greatly explained, but not mine, once check it\\nhttps://youtu.be/DxdIQ09YrP4\\nClick on the link\\u261D\\uFE0F for learning\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t#define ll long long\\n    \\n\\t\\tbool isPossible( ll min_power, const vector<ll>& default_powers, int extra_stations, int r, int num_stations ){\\n\\t\\t\\tvector<ll> extra_power(num_stations+1, 0);\\n\\t\\t\\tfor( int j = 0; j < num_stations; j++ ){\\n\\t\\t\\t\\textra_power[j] += ( j > 0 ? extra_power[j-1] : 0 );\\n\\t\\t\\t\\tll cur_power = default_powers[j] + extra_power[j];\\n\\t\\t\\t\\tll required = max( (ll) 0, min_power - cur_power );\\n\\t\\t\\t\\tif( required <= 0 ) continue; \\n\\t\\t\\t\\tif( required > extra_stations ) return false;\\n\\t\\t\\t\\textra_stations -= required;\\n\\t\\t\\t\\textra_power[j] += required;\\n\\t\\t\\t\\textra_power[min(num_stations, j+ 2*r+1)] -= required;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tlong long maxPower(vector<int>& stations, int range, int k) {\\n\\t\\t\\tint n = stations.size();\\n\\t\\t\\tvector<ll> station_powers(n+1, 0);\\n\\t\\t\\tfor(int j = 0; j < n; j++ ){\\n\\t\\t\\t\\tstation_powers[ max(0, j-range) ]   += stations[j];\\n\\t\\t\\t\\tstation_powers[ min(n, j+range+1) ] -= stations[j];\\n\\t\\t\\t}\\n\\t\\t\\tfor(int j = 1; j < n; j++ ){\\n\\t\\t\\t\\tstation_powers[j] += station_powers[j-1];\\n\\t\\t\\t}\\n\\n\\t\\t\\tll l = 0, r = 1e18;\\n\\t\\t\\twhile( l < r ){\\n\\t\\t\\t\\tll m = (l+r)>>1;\\n\\t\\t\\t\\tif( isPossible( m+1, station_powers, k, range, n ) ){\\n\\t\\t\\t\\t\\tl = m+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tr = m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn l;    \\n\\t\\t}\\n\\t};\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t#define ll long long\\n    \\n\\t\\tbool isPossible( ll min_power, const vector<ll>& default_powers, int extra_stations, int r, int num_stations ){\\n\\t\\t\\tvector<ll> extra_power(num_stations+1, 0);\\n\\t\\t\\tfor( int j = 0; j < num_stations; j++ ){\\n\\t\\t\\t\\textra_power[j] += ( j > 0 ? extra_power[j-1] : 0 );\\n\\t\\t\\t\\tll cur_power = default_powers[j] + extra_power[j];\\n\\t\\t\\t\\tll required = max( (ll) 0, min_power - cur_power );\\n\\t\\t\\t\\tif( required <= 0 ) continue; \\n\\t\\t\\t\\tif( required > extra_stations ) return false;\\n\\t\\t\\t\\textra_stations -= required;\\n\\t\\t\\t\\textra_power[j] += required;\\n\\t\\t\\t\\textra_power[min(num_stations, j+ 2*r+1)] -= required;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3024051,
                "title": "python3-o-nlogk-binary-search-sliding-window-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search is ofen used to solve min-max problems.\\nWe process stations from left to right while keep a sliding window of size 2 * r + 1. when we meet a city cannot satisfy the power stations number, greedily add the needed stations to the rightmost city.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        lo, hi = min(stations), sum(stations) + k\\n        ans = lo\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            ts, left = stations[:], k\\n            cur = sum(ts[:r + 1])\\n            if cur < mid:\\n                left -= mid - cur\\n                ts[r] += mid - cur\\n                cur = mid\\n            for i in range(1, len(ts)):\\n                if i + r < len(ts): cur += ts[i + r]\\n                if i - r - 1 >= 0: cur -= ts[i - r - 1]\\n                if cur < mid:\\n                    left -= mid - cur\\n                    ts[min(i + r, len(ts) - 1)] += mid - cur\\n                    cur = mid\\n                if left < 0: break\\n            if left >= 0:\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n            else: hi = mid - 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        lo, hi = min(stations), sum(stations) + k\\n        ans = lo\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            ts, left = stations[:], k\\n            cur = sum(ts[:r + 1])\\n            if cur < mid:\\n                left -= mid - cur\\n                ts[r] += mid - cur\\n                cur = mid\\n            for i in range(1, len(ts)):\\n                if i + r < len(ts): cur += ts[i + r]\\n                if i - r - 1 >= 0: cur -= ts[i - r - 1]\\n                if cur < mid:\\n                    left -= mid - cur\\n                    ts[min(i + r, len(ts) - 1)] += mid - cur\\n                    cur = mid\\n                if left < 0: break\\n            if left >= 0:\\n                ans = max(ans, mid)\\n                lo = mid + 1\\n            else: hi = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023819,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e18 + 7;\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        long long sol = 0;\\n        int len = 2 * r + 1;\\n        vector<long long> prefixSum(n);\\n        prefixSum[0] = stations[0];\\n        for (int i = 0; i < n - 1; i++) {\\n            prefixSum[i + 1] = prefixSum[i] + stations[i + 1];\\n        }\\n        vector<long long> power(n);\\n        for (int i = 0; i < n; i++) {\\n            int x = max(0, i - r);\\n            int y = min(n - 1, i + r);\\n            long long total = prefixSum[y] - (x == 0 ? 0ll : prefixSum[x - 1]);\\n            power[i] = total;\\n        }\\n        auto isPossible = [&] (long long value) -> bool {\\n            vector<long long> add(n);\\n            long long K = k;\\n            for (int i = 0; i < n; i++) {\\n                if (power[i] + add[i] < value) {\\n                    int nxt = min(n - 1, i + len - 1);\\n                    long long ad = value - power[i] - add[i];\\n                    K -= ad;\\n                    if (K < 0) {\\n                        return false;\\n                    }\\n                    add[i] += ad;\\n                    if (nxt + 1 < n) {\\n                        add[nxt + 1] -= ad;\\n                    }\\n                }\\n                if (i + 1 < n) {\\n                    add[i + 1] += add[i];\\n                }\\n            }\\n            return true;\\n        };\\n        long long low = 0;\\n        long long high = INF;\\n        while (low <= high) {\\n            long long mid = (low + high) / 2;\\n            if (isPossible(mid)) {\\n                sol = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e18 + 7;\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        long long sol = 0;\\n        int len = 2 * r + 1;\\n        vector<long long> prefixSum(n);\\n        prefixSum[0] = stations[0];\\n        for (int i = 0; i < n - 1; i++) {\\n            prefixSum[i + 1] = prefixSum[i] + stations[i + 1];\\n        }\\n        vector<long long> power(n);\\n        for (int i = 0; i < n; i++) {\\n            int x = max(0, i - r);\\n            int y = min(n - 1, i + r);\\n            long long total = prefixSum[y] - (x == 0 ? 0ll : prefixSum[x - 1]);\\n            power[i] = total;\\n        }\\n        auto isPossible = [&] (long long value) -> bool {\\n            vector<long long> add(n);\\n            long long K = k;\\n            for (int i = 0; i < n; i++) {\\n                if (power[i] + add[i] < value) {\\n                    int nxt = min(n - 1, i + len - 1);\\n                    long long ad = value - power[i] - add[i];\\n                    K -= ad;\\n                    if (K < 0) {\\n                        return false;\\n                    }\\n                    add[i] += ad;\\n                    if (nxt + 1 < n) {\\n                        add[nxt + 1] -= ad;\\n                    }\\n                }\\n                if (i + 1 < n) {\\n                    add[i + 1] += add[i];\\n                }\\n            }\\n            return true;\\n        };\\n        long long low = 0;\\n        long long high = INF;\\n        while (low <= high) {\\n            long long mid = (low + high) / 2;\\n            if (isPossible(mid)) {\\n                sol = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023067,
                "title": "c-binary-search-solution",
                "content": "# Observation\\nIn this type of questions which ask maximize the minimum always use **Binary search**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use Binary search and for each *mid* check if at all indexes atleast mid number of station available \\n- If not, provide remaining needed station. and the main key point in this question is how we provide a station so if we want station at ith index it means all the 0 to i-1 indexes have enough stations so we are going to provide a station to index which going to provide power to the stating form i and so on, so in that case more appropriate positon is (i+r)th index it will give power in range of i to i+r+r\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stat, int r, int k) {\\n        int n=stat.size();\\n        vector<long long> a(n+1,0);\\n\\n        for(int i=0;i<n;i++){\\n            int l=max(i-r,0);\\n            int x=min(i+r,n-1);\\n            a[l]+=1ll*stat[i];\\n            a[x+1]-=1ll*stat[i];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            a[i]+=a[i-1];\\n        }\\n\\n        long long low=0, high=LLONG_MAX;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;  //want atleast this much at each position\\n\\n            vector<long long> add(n+1,0);  //for extra add\\n            long long rem=k;\\n            for(int i=0;i<n;i++){\\n                if(i){\\n                    add[i]+=add[i-1];\\n                }\\n                long long got=a[i]+add[i];\\n\\n                if(got<mid){\\n                    long long need=mid-got;\\n                    rem-=need;\\n                    if(rem<0){\\n                        break;\\n                    }\\n                    long long far=min(i+r+r,n-1);       //give i+r th index station and it will provide b/w i to i+r+r \\n                    add[i]+=need;\\n                    add[far+1]-=need;   //at this index station not going to give power \\n                }\\n            }\\n            if(rem>=0){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n       return ans;\\n       \\n    }\\n};\\n//code by sachin\\n```\\n**Upvote if solution was helpful**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stat, int r, int k) {\\n        int n=stat.size();\\n        vector<long long> a(n+1,0);\\n\\n        for(int i=0;i<n;i++){\\n            int l=max(i-r,0);\\n            int x=min(i+r,n-1);\\n            a[l]+=1ll*stat[i];\\n            a[x+1]-=1ll*stat[i];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            a[i]+=a[i-1];\\n        }\\n\\n        long long low=0, high=LLONG_MAX;\\n        long long ans=0;\\n        while(low<=high){\\n            long long mid=low+(high-low)/2;  //want atleast this much at each position\\n\\n            vector<long long> add(n+1,0);  //for extra add\\n            long long rem=k;\\n            for(int i=0;i<n;i++){\\n                if(i){\\n                    add[i]+=add[i-1];\\n                }\\n                long long got=a[i]+add[i];\\n\\n                if(got<mid){\\n                    long long need=mid-got;\\n                    rem-=need;\\n                    if(rem<0){\\n                        break;\\n                    }\\n                    long long far=min(i+r+r,n-1);       //give i+r th index station and it will provide b/w i to i+r+r \\n                    add[i]+=need;\\n                    add[far+1]-=need;   //at this index station not going to give power \\n                }\\n            }\\n            if(rem>=0){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n       return ans;\\n       \\n    }\\n};\\n//code by sachin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021709,
                "title": "python-painful-binary-search-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        \"\"\"\\n            [1,2,4,5,0] # of power station in ith city\\n            \\n            The power of a city is the total number of power stations it is being provided power from.\\n            \\n            city i can provide station[i] power to (i+k) - (i-k) cities\\n\\n            add k more power stations and tell, what will be max possible min power for a city (ie for city with lower power, increase it to make it better )\\n            \\n            \\n            we have to find lowest power getting city/cities and add station nearby there\\n        \"\"\"\\n        \\n        \"\"\"\\n            we can binary search for\\n                ispossible(min_power) -> is it possible to make all cities get atleast min_power power in linear time\\n                \\n                ispossible(min_power, stations, r, k)\\n                    is it possible to convert all stations to get atleast min_power with k stations to add with range r \\n                    \\n                    sum of range(r) has to be min_power\\n                                 V\\n                       i-r ----- i ---- i+r\\n                      \\n                     if it is good\\n                     else:\\n                        i+r element ko improve (why i+r bcz isse pehle wale toh sorted hi hai, and then will add to furhter ones in case they need it)\\n                \\n        \"\"\"\\n        orig = stations[:]\\n        stations = [0]*r + stations + [0]*r\\n        \\n        prefix_sum = sum(stations[:(r*2)+1])\\n        \\n        def ispossible(min_power, power, _range, k):\\n            \\n            nonlocal prefix_sum\\n            \\n            l = 0\\n            r = _range * 2\\n            s = prefix_sum\\n            \\n            \\n            while r < len(power) :\\n                \\n                if s < min_power and k >= min_power - s: # if sum is not enough but we have enough k (min_power - s is required k)\\n                    k -= (min_power - s)\\n                    power[r] += (min_power - s)\\n                    s = min_power\\n                \\n                if s < min_power:\\n                    return False\\n                \\n                if r == len(power) - 1 : break\\n                r += 1\\n                # bring in range\\n                if  r - l  > 2 * _range:\\n                    s -= power[l]\\n                    l += 1\\n                \\n                s += power[r] # add current\\n                \\n            return True\\n      \\n        l = 0\\n        right = 10 ** 14\\n        \\n        while l < right:\\n            mid = (l+right) // 2\\n                \\n            if ispossible(mid, stations.copy(), r, k):\\n                l = mid + 1\\n            else:\\n                right = mid\\n        \\n        return l - 1\\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        \"\"\"\\n            [1,2,4,5,0] # of power station in ith city\\n            \\n            The power of a city is the total number of power stations it is being provided power from.\\n            \\n            city i can provide station[i] power to (i+k) - (i-k) cities\\n\\n            add k more power stations and tell, what will be max possible min power for a city (ie for city with lower power, increase it to make it better )\\n            \\n            \\n            we have to find lowest power getting city/cities and add station nearby there\\n        \"\"\"\\n        \\n        \"\"\"\\n            we can binary search for\\n                ispossible(min_power) -> is it possible to make all cities get atleast min_power power in linear time\\n                \\n                ispossible(min_power, stations, r, k)\\n                    is it possible to convert all stations to get atleast min_power with k stations to add with range r \\n                    \\n                    sum of range(r) has to be min_power\\n                                 V\\n                       i-r ----- i ---- i+r\\n                      \\n                     if it is good\\n                     else:\\n                        i+r element ko improve (why i+r bcz isse pehle wale toh sorted hi hai, and then will add to furhter ones in case they need it)\\n                \\n        \"\"\"\\n        orig = stations[:]\\n        stations = [0]*r + stations + [0]*r\\n        \\n        prefix_sum = sum(stations[:(r*2)+1])\\n        \\n        def ispossible(min_power, power, _range, k):\\n            \\n            nonlocal prefix_sum\\n            \\n            l = 0\\n            r = _range * 2\\n            s = prefix_sum\\n            \\n            \\n            while r < len(power) :\\n                \\n                if s < min_power and k >= min_power - s: # if sum is not enough but we have enough k (min_power - s is required k)\\n                    k -= (min_power - s)\\n                    power[r] += (min_power - s)\\n                    s = min_power\\n                \\n                if s < min_power:\\n                    return False\\n                \\n                if r == len(power) - 1 : break\\n                r += 1\\n                # bring in range\\n                if  r - l  > 2 * _range:\\n                    s -= power[l]\\n                    l += 1\\n                \\n                s += power[r] # add current\\n                \\n            return True\\n      \\n        l = 0\\n        right = 10 ** 14\\n        \\n        while l < right:\\n            mid = (l+right) // 2\\n                \\n            if ispossible(mid, stations.copy(), r, k):\\n                l = mid + 1\\n            else:\\n                right = mid\\n        \\n        return l - 1\\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021606,
                "title": "binary-search-prefx-sum-line-sweep",
                "content": "\\r\\n    class Solution {\\r\\n    public:\\r\\n        bool isMinPowerStationPossible(long long mid, vector<long long> &nums, int r, int k){\\r\\n        \\r\\n        int n = nums.size();\\r\\n        vector<int> mp(n, 0);\\r\\n        long long extra = 0;\\r\\n        for(auto i = 0; i < n; i++){\\r\\n            extra += mp[i];\\r\\n            auto tmp = mid - nums[i] - extra;\\r\\n            if(tmp > 0){\\r\\n                k -= tmp;\\r\\n                extra += tmp;\\r\\n                if(i + 2 * r + 1 < n) mp[i + 2 * r + 1] = -tmp;\\r\\n            }\\r\\n            \\r\\n            if(k < 0) return 0;\\r\\n        }\\r\\n        \\r\\n        return 1;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    long long maxPower(vector<int>& stations, int r, int k) {\\r\\n        int n = stations.size();\\r\\n        \\r\\n        vector<long long> pref(n, 0), nums(n, 0);\\r\\n        pref[0] = stations[0];\\r\\n        for(auto i = 1; i < n; i++){\\r\\n            pref[i] = pref[i - 1] + stations[i];\\r\\n        }\\r\\n\\r\\n        for(auto i = 0; i < n; i++){\\r\\n            nums[i] = (i + r < n ? pref[i + r] : pref[n - 1]) - (i - r - 1 >= 0 ? pref[i - r - 1] : 0);\\r\\n        }\\r\\n        \\r\\n        long long low = *min_element(nums.begin(), nums.end());\\r\\n        long long high = (long long)*max_element(nums.begin(), nums.end()) + k;\\r\\n        \\r\\n        while(low < high){\\r\\n            long long mid = low + (high - low + 1) / 2;\\r\\n\\r\\n            if(isMinPowerStationPossible(mid, nums, r, k)){\\r\\n                low = mid;\\r\\n            }else{\\r\\n                high = mid - 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return low;\\r\\n    }\\r\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\r\\n    public:\\r\\n        bool isMinPowerStationPossible(long long mid, vector<long long> &nums, int r, int k){\\r\\n        \\r\\n        int n = nums.size();\\r\\n        vector<int> mp(n, 0);\\r\\n        long long extra = 0;\\r\\n        for(auto i = 0; i < n; i++){\\r\\n            extra += mp[i];\\r\\n            auto tmp = mid - nums[i] - extra;\\r\\n            if(tmp > 0){\\r\\n                k -= tmp;\\r\\n                extra += tmp;\\r\\n                if(i + 2 * r + 1 < n) mp[i + 2 * r + 1] = -tmp;\\r\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3021123,
                "title": "python-simple-sweep-line-algorithm-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations, r, k):\\n        n, dict1 = len(stations), collections.defaultdict(int)\\n\\n        for i in range(n):\\n            dict1[max(0,i-r)] += stations[i]\\n            dict1[min(i+r,n-1) + 1] -= stations[i]\\n\\n        def func_(min_power):\\n            running_sum, d, total = 0, dict1.copy(), 0\\n\\n            for i in range(n):\\n                running_sum += d[i]\\n\\n                if min_power > running_sum:\\n                    total += min_power - running_sum\\n                    d[i] += min_power - running_sum\\n                    d[min(i+2*r,n-1) + 1] -= min_power - running_sum\\n                    running_sum = min_power\\n\\n            return total <= k\\n\\n        low, high = 0, sum(stations) + k\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n            if func_(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n            \\n        return dict1\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, stations, r, k):\\n        n, dict1 = len(stations), collections.defaultdict(int)\\n\\n        for i in range(n):\\n            dict1[max(0,i-r)] += stations[i]\\n            dict1[min(i+r,n-1) + 1] -= stations[i]\\n\\n        def func_(min_power):\\n            running_sum, d, total = 0, dict1.copy(), 0\\n\\n            for i in range(n):\\n                running_sum += d[i]\\n\\n                if min_power > running_sum:\\n                    total += min_power - running_sum\\n                    d[i] += min_power - running_sum\\n                    d[min(i+2*r,n-1) + 1] -= min_power - running_sum\\n                    running_sum = min_power\\n\\n            return total <= k\\n\\n        low, high = 0, sum(stations) + k\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n            if func_(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n            \\n        return dict1\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021015,
                "title": "binary-search-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        long long left = 1;\\n        long long right = 0;\\n\\n        for(int ele: stations) {\\n            right += ele;\\n        }\\n        right += k+1;\\n\\n        long long pre_sum = 0;\\n        vector<long long> cur_powers;\\n        for(int i=0;i<stations.size();i++) {\\n            pre_sum += stations[i];\\n            if(i>=r+1) {\\n                pre_sum -= stations[i-r-1];\\n            }\\n            cur_powers.push_back(pre_sum);\\n        }\\n\\n\\n        long long suffix_sum = 0;\\n        for(int i=stations.size()-1;i>=0;i--) {\\n            if(i+r+1<stations.size()) {\\n                suffix_sum -= stations[i+r+1];\\n            }\\n\\n            cur_powers[i] += suffix_sum;\\n            suffix_sum += stations[i];\\n        }\\n\\n\\n        std::function<bool(long long, int)> check_func = [&](long long mid, int k) {\\n            long long pre_sum = 0;\\n            vector<long long> tmp(cur_powers.size(), 0);\\n            long long cur = 0;\\n            long long total_add = 0;\\n\\n            for(int i=0;i<cur_powers.size();i++) {\\n                if(i-r-1>=0) {\\n                    cur -= tmp[i-r-1];\\n                }\\n\\n                if(cur_powers[i] + cur < mid) {\\n                    long long add = mid-cur_powers[i]-cur;\\n                    if(i+r<cur_powers.size()) {\\n                        tmp[i+r] = add;\\n                    }else {\\n                        tmp[tmp.size()-1] = add;\\n                    }\\n\\n                    cur += add;\\n                    total_add+=add;\\n                }\\n\\n                if(total_add>k) {\\n                    return false;\\n                }\\n            }\\n             return true;    \\n        };\\n\\n        while(left < right) {\\n            long long mid = (left+right)/2;\\n            bool check_flag = check_func(mid, k);\\n            if(check_flag) {\\n                left = mid+1;\\n            }else {\\n                right = mid;\\n            }\\n        }\\n\\n\\n        return left-1;\\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        long long left = 1;\\n        long long right = 0;\\n\\n        for(int ele: stations) {\\n            right += ele;\\n        }\\n        right += k+1;\\n\\n        long long pre_sum = 0;\\n        vector<long long> cur_powers;\\n        for(int i=0;i<stations.size();i++) {\\n            pre_sum += stations[i];\\n            if(i>=r+1) {\\n                pre_sum -= stations[i-r-1];\\n            }\\n            cur_powers.push_back(pre_sum);\\n        }\\n\\n\\n        long long suffix_sum = 0;\\n        for(int i=stations.size()-1;i>=0;i--) {\\n            if(i+r+1<stations.size()) {\\n                suffix_sum -= stations[i+r+1];\\n            }\\n\\n            cur_powers[i] += suffix_sum;\\n            suffix_sum += stations[i];\\n        }\\n\\n\\n        std::function<bool(long long, int)> check_func = [&](long long mid, int k) {\\n            long long pre_sum = 0;\\n            vector<long long> tmp(cur_powers.size(), 0);\\n            long long cur = 0;\\n            long long total_add = 0;\\n\\n            for(int i=0;i<cur_powers.size();i++) {\\n                if(i-r-1>=0) {\\n                    cur -= tmp[i-r-1];\\n                }\\n\\n                if(cur_powers[i] + cur < mid) {\\n                    long long add = mid-cur_powers[i]-cur;\\n                    if(i+r<cur_powers.size()) {\\n                        tmp[i+r] = add;\\n                    }else {\\n                        tmp[tmp.size()-1] = add;\\n                    }\\n\\n                    cur += add;\\n                    total_add+=add;\\n                }\\n\\n                if(total_add>k) {\\n                    return false;\\n                }\\n            }\\n             return true;    \\n        };\\n\\n        while(left < right) {\\n            long long mid = (left+right)/2;\\n            bool check_flag = check_func(mid, k);\\n            if(check_flag) {\\n                left = mid+1;\\n            }else {\\n                right = mid;\\n            }\\n        }\\n\\n\\n        return left-1;\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020729,
                "title": "line-sweep-binary-search",
                "content": "# Intuition\\n<..\\n\\n# Approach\\n.. Line Sweep Algo +Binary Search\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n- \\n\\n# Code\\n```\\n#define ll long long\\nclass Solution\\n{\\npublic:\\n    bool checkSuccessful(vector<ll> power, ll mid, int r, int k)\\n    {\\n        for (int i = 0; i < power.size() - 1; i++)\\n        {\\n            if (power[i] >= mid)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                ll required = mid - power[i];\\n               \\n                if (required <= k)\\n                {\\n                    for (int j = i; j <= i + r + r && j < power.size(); j++)\\n                    {\\n                        power[j] += required;\\n                    }\\n                    k = k - required;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long long maxPower(vector<int> &st, int r, int k)\\n    {\\n\\n        int n = st.size();\\n        map<pair<int, int>, int> mp;\\n        vector<ll> power(n + 1, 0);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            int lowerLimit = max(0, i - r);\\n            int higherLimit = min(n - 1, i + r);\\n\\n            mp[{lowerLimit, higherLimit}] += st[i];\\n        }\\n        \\n        for (auto it : mp)\\n        {\\n            int l = it.first.first;\\n            int h = it.first.second;\\n            int val = it.second;\\n\\n            power[l] += val;\\n            power[h + 1] -= val;\\n        }\\n        // using linesweep calculated initial power of city\\n        for (int i = 1; i < power.size(); i++)\\n        {\\n            power[i] += power[i - 1];\\n        }\\n       \\n\\n        ll low = INT_MAX,high;\\n        // search space min(power array) to  min power arr+k*r\\n        for (int i = 0; i < power.size() - 1; i++)\\n        {\\n            low = min(low, power[i]);\\n        }\\n        \\n        if (r == 0)\\n        {\\n            high = low + k;\\n        }\\n        else\\n        {\\n            high = low + k * 1LL * r;\\n        }\\n\\n        ll res = 0;\\n        \\n        while (low <= high)\\n        {\\n            ll mid = low + (high - low) / 2;\\n\\n            if (checkSuccessful(power, mid, r, k))\\n            {\\n                res = mid;\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution\\n{\\npublic:\\n    bool checkSuccessful(vector<ll> power, ll mid, int r, int k)\\n    {\\n        for (int i = 0; i < power.size() - 1; i++)\\n        {\\n            if (power[i] >= mid)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                ll required = mid - power[i];\\n               \\n                if (required <= k)\\n                {\\n                    for (int j = i; j <= i + r + r && j < power.size(); j++)\\n                    {\\n                        power[j] += required;\\n                    }\\n                    k = k - required;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    long long maxPower(vector<int> &st, int r, int k)\\n    {\\n\\n        int n = st.size();\\n        map<pair<int, int>, int> mp;\\n        vector<ll> power(n + 1, 0);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            int lowerLimit = max(0, i - r);\\n            int higherLimit = min(n - 1, i + r);\\n\\n            mp[{lowerLimit, higherLimit}] += st[i];\\n        }\\n        \\n        for (auto it : mp)\\n        {\\n            int l = it.first.first;\\n            int h = it.first.second;\\n            int val = it.second;\\n\\n            power[l] += val;\\n            power[h + 1] -= val;\\n        }\\n        // using linesweep calculated initial power of city\\n        for (int i = 1; i < power.size(); i++)\\n        {\\n            power[i] += power[i - 1];\\n        }\\n       \\n\\n        ll low = INT_MAX,high;\\n        // search space min(power array) to  min power arr+k*r\\n        for (int i = 0; i < power.size() - 1; i++)\\n        {\\n            low = min(low, power[i]);\\n        }\\n        \\n        if (r == 0)\\n        {\\n            high = low + k;\\n        }\\n        else\\n        {\\n            high = low + k * 1LL * r;\\n        }\\n\\n        ll res = 0;\\n        \\n        while (low <= high)\\n        {\\n            ll mid = low + (high - low) / 2;\\n\\n            if (checkSuccessful(power, mid, r, k))\\n            {\\n                res = mid;\\n                low = mid + 1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020725,
                "title": "binary-search-prefix-sum-slide-window-difference-series",
                "content": "# Intuition\\nGiven a power P, test if we are able to build k statation in a way such that the maximum possible minimum power >= P.\\nIf P is not feasbile, any number greater than P is not feasible. The value of P maintains a liner relation.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculate the power of cities by prefix sum.\\nProvide the extra power (from newly built station) by sliding window + difference series.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        \\n        vector<LL> ss(stations.begin(), stations.end());   \\n        std::partial_sum(ss.begin(), ss.end(), ss.begin());\\n\\n        vector<LL> powers(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if ((i + r) < n) {\\n                powers[i] += ss[i + r];\\n            }\\n            else {\\n                powers[i] += ss.back();\\n            }\\n\\n            if (0 <= (i - r - 1)) {\\n                powers[i] -= ss[i - r - 1];\\n            }\\n        }\\n\\n        LL windowSize = 2 * r + 1;\\n        auto isOk = [&powers, &windowSize, &n, &k](LL target) -> bool {\\n            vector<LL> diffs(n, 0);\\n            LL count = 0;\\n            LL curSum = 0;\\n            for (int i = 0; i < n; ++i) {\\n                curSum += diffs[i];\\n                LL power = powers[i] + curSum;\\n                if (power < target) {\\n                    count += (target - power);\\n                    curSum += (target - power);\\n                    if (count > k) {\\n                        return false;\\n                    }\\n                    if ((i + windowSize) < n) {\\n                        diffs[i + windowSize] -= (target - power);\\n                    }\\n                }\\n            }\\n\\n            return true;\\n        };\\n\\n        LL lft = *std::min_element(powers.begin(), powers.end()), rht = 1e10 + 1e9;\\n        while (lft < rht) {\\n            LL mid = rht - (rht - lft) / 2;\\n            if (isOk(mid)) {\\n                lft = mid;\\n            }\\n            else {\\n                rht = mid - 1;\\n            }\\n        }\\n\\n        return lft;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        \\n        vector<LL> ss(stations.begin(), stations.end());   \\n        std::partial_sum(ss.begin(), ss.end(), ss.begin());\\n\\n        vector<LL> powers(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if ((i + r) < n) {\\n                powers[i] += ss[i + r];\\n            }\\n            else {\\n                powers[i] += ss.back();\\n            }\\n\\n            if (0 <= (i - r - 1)) {\\n                powers[i] -= ss[i - r - 1];\\n            }\\n        }\\n\\n        LL windowSize = 2 * r + 1;\\n        auto isOk = [&powers, &windowSize, &n, &k](LL target) -> bool {\\n            vector<LL> diffs(n, 0);\\n            LL count = 0;\\n            LL curSum = 0;\\n            for (int i = 0; i < n; ++i) {\\n                curSum += diffs[i];\\n                LL power = powers[i] + curSum;\\n                if (power < target) {\\n                    count += (target - power);\\n                    curSum += (target - power);\\n                    if (count > k) {\\n                        return false;\\n                    }\\n                    if ((i + windowSize) < n) {\\n                        diffs[i + windowSize] -= (target - power);\\n                    }\\n                }\\n            }\\n\\n            return true;\\n        };\\n\\n        LL lft = *std::min_element(powers.begin(), powers.end()), rht = 1e10 + 1e9;\\n        while (lft < rht) {\\n            LL mid = rht - (rht - lft) / 2;\\n            if (isOk(mid)) {\\n                lft = mid;\\n            }\\n            else {\\n                rht = mid - 1;\\n            }\\n        }\\n\\n        return lft;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020724,
                "title": "binary-search-prefix-sum-slide-window-difference-series",
                "content": "# Intuition\\nGiven a power P, test if we are able to build k statation in a way such that the maximum possible minimum power = P.\\nIf P is not feasbile, any number greater than P is not feasible. The value of P maintains a liner relation.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCalculate the power of cities by prefix sum.\\nProvide the extra power (from newly built station) by sliding window + difference series.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        \\n        vector<LL> ss(stations.begin(), stations.end());   \\n        std::partial_sum(ss.begin(), ss.end(), ss.begin());\\n\\n        vector<LL> powers(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if ((i + r) < n) {\\n                powers[i] += ss[i + r];\\n            }\\n            else {\\n                powers[i] += ss.back();\\n            }\\n\\n            if (0 <= (i - r - 1)) {\\n                powers[i] -= ss[i - r - 1];\\n            }\\n        }\\n\\n        LL windowSize = 2 * r + 1;\\n        auto isOk = [&powers, &windowSize, &n, &k](LL target) -> bool {\\n            vector<LL> diffs(n, 0);\\n            LL count = 0;\\n            LL curSum = 0;\\n            for (int i = 0; i < n; ++i) {\\n                curSum += diffs[i];\\n                LL power = powers[i] + curSum;\\n                if (power < target) {\\n                    count += (target - power);\\n                    curSum += (target - power);\\n                    if (count > k) {\\n                        return false;\\n                    }\\n                    if ((i + windowSize) < n) {\\n                        diffs[i + windowSize] -= (target - power);\\n                    }\\n                }\\n            }\\n\\n            return true;\\n        };\\n\\n        LL lft = *std::min_element(powers.begin(), powers.end()), rht = 1e10 + 1e9;\\n        while (lft < rht) {\\n            LL mid = rht - (rht - lft) / 2;\\n            if (isOk(mid)) {\\n                lft = mid;\\n            }\\n            else {\\n                rht = mid - 1;\\n            }\\n        }\\n\\n        return lft;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        int n = stations.size();\\n        \\n        vector<LL> ss(stations.begin(), stations.end());   \\n        std::partial_sum(ss.begin(), ss.end(), ss.begin());\\n\\n        vector<LL> powers(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            if ((i + r) < n) {\\n                powers[i] += ss[i + r];\\n            }\\n            else {\\n                powers[i] += ss.back();\\n            }\\n\\n            if (0 <= (i - r - 1)) {\\n                powers[i] -= ss[i - r - 1];\\n            }\\n        }\\n\\n        LL windowSize = 2 * r + 1;\\n        auto isOk = [&powers, &windowSize, &n, &k](LL target) -> bool {\\n            vector<LL> diffs(n, 0);\\n            LL count = 0;\\n            LL curSum = 0;\\n            for (int i = 0; i < n; ++i) {\\n                curSum += diffs[i];\\n                LL power = powers[i] + curSum;\\n                if (power < target) {\\n                    count += (target - power);\\n                    curSum += (target - power);\\n                    if (count > k) {\\n                        return false;\\n                    }\\n                    if ((i + windowSize) < n) {\\n                        diffs[i + windowSize] -= (target - power);\\n                    }\\n                }\\n            }\\n\\n            return true;\\n        };\\n\\n        LL lft = *std::min_element(powers.begin(), powers.end()), rht = 1e10 + 1e9;\\n        while (lft < rht) {\\n            LL mid = rht - (rht - lft) / 2;\\n            if (isOk(mid)) {\\n                lft = mid;\\n            }\\n            else {\\n                rht = mid - 1;\\n            }\\n        }\\n\\n        return lft;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018655,
                "title": "c-binary-search-prefix-sum-difference-array-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search on answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\n\\nclass Solution {\\n    vector<ll> psum;\\n    \\n    ll get_sum(int l, int r) {\\n        if (l == 0)\\n            return psum[r];\\n        return psum[r] - psum[l-1];\\n    } \\n    \\n    bool possible(ll sum, int r, int k, int n) {\\n        ll curr = 0;\\n        vector<int> da(n, 0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            int l = max(0, i-r);\\n            int h = min(i+r, n-1);\\n            \\n            ll ps = get_sum(l, h);\\n            curr += da[i];\\n            \\n            // add power station to i\\'th city\\n            if(ps + curr < sum) {\\n                ll need = sum - (ps+curr);\\n                if(need > k)\\n                    return false;\\n                k -= need;\\n                curr += need;\\n\\n                // add -need to after range\\n                int nxt = i+2*r + 1;\\n                if(nxt < n)\\n                    da[nxt] -= need;\\n            }\\n            \\n            // cout << ps << \" \" << curr << endl;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    long long maxPower(vector<int>& a, int r, int k) {\\n        int n = a.size();\\n        \\n        psum.resize(n);\\n        for(int i = 0; i < n; i++) {\\n            psum[i] = a[i];\\n            if(i > 0)\\n                psum[i] += psum[i-1];\\n        }\\n        \\n//         possible(5, 0, 3, 4);\\n        \\n//         if(true)\\n//             return false;\\n        \\n        \\n        ll low = 0, high = 1e18;\\n        ll ans = 0;\\n        while(low <= high) {\\n            ll mid = (low + high) / 2;\\n            if(possible(mid, r, k, n)) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\n    vector<ll> psum;\\n    \\n    ll get_sum(int l, int r) {\\n        if (l == 0)\\n            return psum[r];\\n        return psum[r] - psum[l-1];\\n    } \\n    \\n    bool possible(ll sum, int r, int k, int n) {\\n        ll curr = 0;\\n        vector<int> da(n, 0);\\n        \\n        for(int i = 0; i < n; i++) {\\n            int l = max(0, i-r);\\n            int h = min(i+r, n-1);\\n            \\n            ll ps = get_sum(l, h);\\n            curr += da[i];\\n            \\n            // add power station to i\\'th city\\n            if(ps + curr < sum) {\\n                ll need = sum - (ps+curr);\\n                if(need > k)\\n                    return false;\\n                k -= need;\\n                curr += need;\\n\\n                // add -need to after range\\n                int nxt = i+2*r + 1;\\n                if(nxt < n)\\n                    da[nxt] -= need;\\n            }\\n            \\n            // cout << ps << \" \" << curr << endl;\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    long long maxPower(vector<int>& a, int r, int k) {\\n        int n = a.size();\\n        \\n        psum.resize(n);\\n        for(int i = 0; i < n; i++) {\\n            psum[i] = a[i];\\n            if(i > 0)\\n                psum[i] += psum[i-1];\\n        }\\n        \\n//         possible(5, 0, 3, 4);\\n        \\n//         if(true)\\n//             return false;\\n        \\n        \\n        ll low = 0, high = 1e18;\\n        ll ans = 0;\\n        while(low <= high) {\\n            ll mid = (low + high) / 2;\\n            if(possible(mid, r, k, n)) {\\n                ans = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3016615,
                "title": "binary-search-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n log(1e11))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\nbool isok(vector<ll> a,ll r,ll k,ll mid) {\\n    ll n = a.size();\\n    vector<ll> vec(n+1,0);\\n    ll g=-1,b=0;\\n    for(ll i=0;i<n;i++) {\\n        ll now = a[i];\\n        vec[i]=i==0 ? vec[i] : vec[i-1]+vec[i];\\n        now+=vec[i];\\n        if(now<mid) {\\n            ll req = mid-now;\\n            if(req>k)   return false;\\n            k-=req;\\n            vec[i+1]+=req;\\n            vec[min(n,i+(2*r+1))] -= req;\\n        }\\n    }\\n    return true;\\n}\\n\\nll maxPower(vector<int> &a,int r,int k) {\\n    int n = a.size();\\n    vector<ll> pre(n+1,0),suf(n+1,0);\\n    for(int i=1;i<=n;i++)   pre[i] += (pre[i-1]+(ll)a[i-1]);\\n    for(int i=n-1;i>=0;i--)     suf[i] += (suf[i+1]+(ll)a[i]);\\n\\n    vector<ll> vec(n);\\n    for(int i=1;i<=n;i++) {\\n        vec[i-1] = a[i-1] + (pre[i-1]-pre[max(0,i-r-1)]) + (suf[i]-suf[min(n,i+r)]);\\n    }\\n    ll low = 0;\\n   // ll high = *max_element(vec.begin(),vec.end())+(ll)k;\\n    ll high = 1e11;\\n    ll ans = low;\\n    while(low<=high) {\\n        ll mid = (low+high) / 2;\\n        if(isok(vec,r,k,mid)) {\\n            ans = mid;\\n            low = mid+1;\\n        }\\n        else {\\n            high = mid-1;\\n        }\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\nbool isok(vector<ll> a,ll r,ll k,ll mid) {\\n    ll n = a.size();\\n    vector<ll> vec(n+1,0);\\n    ll g=-1,b=0;\\n    for(ll i=0;i<n;i++) {\\n        ll now = a[i];\\n        vec[i]=i==0 ? vec[i] : vec[i-1]+vec[i];\\n        now+=vec[i];\\n        if(now<mid) {\\n            ll req = mid-now;\\n            if(req>k)   return false;\\n            k-=req;\\n            vec[i+1]+=req;\\n            vec[min(n,i+(2*r+1))] -= req;\\n        }\\n    }\\n    return true;\\n}\\n\\nll maxPower(vector<int> &a,int r,int k) {\\n    int n = a.size();\\n    vector<ll> pre(n+1,0),suf(n+1,0);\\n    for(int i=1;i<=n;i++)   pre[i] += (pre[i-1]+(ll)a[i-1]);\\n    for(int i=n-1;i>=0;i--)     suf[i] += (suf[i+1]+(ll)a[i]);\\n\\n    vector<ll> vec(n);\\n    for(int i=1;i<=n;i++) {\\n        vec[i-1] = a[i-1] + (pre[i-1]-pre[max(0,i-r-1)]) + (suf[i]-suf[min(n,i+r)]);\\n    }\\n    ll low = 0;\\n   // ll high = *max_element(vec.begin(),vec.end())+(ll)k;\\n    ll high = 1e11;\\n    ll ans = low;\\n    while(low<=high) {\\n        ll mid = (low+high) / 2;\\n        if(isok(vec,r,k,mid)) {\\n            ans = mid;\\n            low = mid+1;\\n        }\\n        else {\\n            high = mid-1;\\n        }\\n    }\\n    return ans;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016560,
                "title": "c-binary-search-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere is good case for the *binary search*: we can guarantee, that we can *ever* have `min(stations)` and *never* get `sum(stations) + k + 1`. In order to check if we can have arbitrary `min` stations we can use typical sliding window approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sliding window to compute power in each city\\n- Binary search to find maximum of min power\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`O(n * log(n))`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n`O(n)`\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    public static bool CanDo(int[] data, int r, long avail, long min) {\\n        long[] stations = new long[data.Length + r];\\n\\n        for (int i = 0; i < data.Length; ++i)\\n            stations[i] = data[i];\\n\\n        long total = 0;\\n\\n        for (int i = 0; i < stations.Length; ++i) {\\n            total += stations[i];\\n\\n            if (i < r)\\n                continue;\\n\\n            if (i >= 2 * r + 1)\\n                total -= stations[i - (2 * r + 1)];\\n\\n            if (total >= min)\\n                continue;   \\n\\n            long delta = (min - total);\\n\\n            stations[i] += delta;\\n            avail -= delta;\\n            total = min;\\n\\n            if (avail < 0)\\n                return false;      \\n        }\\n\\n        if (total < min) \\n            avail -= (min - total);\\n\\n        return avail >= 0;\\n    }\\n\\n    public long MaxPower(int[] stations, int r, int k) {\\n        long ever = stations.Min();\\n        long never = stations.Sum(x => (long) x) + k + 1;\\n\\n        while (never - ever > 1) {\\n            long middle = (never + ever) / 2;\\n\\n            if (CanDo(stations, r, k, middle))\\n                ever = middle;\\n            else \\n                never = middle;\\n        }    \\n\\n        return ever;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public static bool CanDo(int[] data, int r, long avail, long min) {\\n        long[] stations = new long[data.Length + r];\\n\\n        for (int i = 0; i < data.Length; ++i)\\n            stations[i] = data[i];\\n\\n        long total = 0;\\n\\n        for (int i = 0; i < stations.Length; ++i) {\\n            total += stations[i];\\n\\n            if (i < r)\\n                continue;\\n\\n            if (i >= 2 * r + 1)\\n                total -= stations[i - (2 * r + 1)];\\n\\n            if (total >= min)\\n                continue;   \\n\\n            long delta = (min - total);\\n\\n            stations[i] += delta;\\n            avail -= delta;\\n            total = min;\\n\\n            if (avail < 0)\\n                return false;      \\n        }\\n\\n        if (total < min) \\n            avail -= (min - total);\\n\\n        return avail >= 0;\\n    }\\n\\n    public long MaxPower(int[] stations, int r, int k) {\\n        long ever = stations.Min();\\n        long never = stations.Sum(x => (long) x) + k + 1;\\n\\n        while (never - ever > 1) {\\n            long middle = (never + ever) / 2;\\n\\n            if (CanDo(stations, r, k, middle))\\n                ever = middle;\\n            else \\n                never = middle;\\n        }    \\n\\n        return ever;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016499,
                "title": "same-code-python-tle-java-ac-why-binary-search-fenwick-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximizing Minimum? smells like agressive cows problem.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\nSame code but python give me TLE during contest, wasted 30min!\\n\\n```Python []\\nfrom itertools import accumulate\\nclass FenwickTree:\\n    def __init__(self, nums):\\n        self.tree = [0]*(len(nums)+1)\\n\\n    def update(self, i, diff):\\n        i += 1\\n        while i < len(self.tree):\\n            self.tree[i] += diff\\n            i += i & (-i)\\n\\n    def _rangeSum(self, i):\\n        i += 1\\n        sum = 0\\n        while i > 0:\\n            sum += self.tree[i]\\n            i -= i & (-i)\\n        return sum\\n\\n    def rangeSum(self, i, j):\\n        return self._rangeSum(j) - self._rangeSum(i-1)\\nclass Solution:\\n    def maxPower(self, nums: List[int], r: int, k: int) -> int:\\n        def ok(x):\\n            temp = k\\n            acc = FenwickTree(nums)\\n            for i in range(len(nums)):\\n                acc.update(i, nums[i])\\n            for i in range(len(nums)):\\n                dff = acc.rangeSum(max(0,i-r),min(len(nums)-1,i+r))-x\\n                if(dff+temp<0): \\n                    return False\\n                if(dff<0):\\n                    temp += dff\\n                    acc.update(min(len(nums)-1,i+r),-dff)\\n            return True\\n        high = 10**8\\n        low = 0\\n        while(low<high):\\n            mid = (low+high)//2;\\n            if(ok(mid)):\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low-1\\n```\\n```Java []\\nimport java.util.*;\\npublic class Solution {\\n    static class FenwickTree {\\n        long[] tree;\\n        public FenwickTree(int[] nums) {\\n            tree = new long[nums.length+1];\\n        }\\n        public void update(int i, long diff) {\\n            i += 1;\\n            while (i < tree.length) {\\n                tree[i] += diff;\\n                i += i & (-i);\\n            }\\n        }\\n        public long _rangeSum(int i) {\\n            i += 1;\\n            long sum = 0;\\n            while (i > 0) {\\n                sum += tree[i];\\n                i -= i & (-i);\\n            }\\n            return sum;\\n        }\\n        public long rangeSum(int i, int j) {\\n            return _rangeSum(j) - _rangeSum(i-1);\\n        }\\n    }\\n    public long maxPower(int[] nums, int r, int k) {\\n        long low = 0;\\n        long high = (long)Math.pow(10,12);\\n        while (low < high) {\\n            long mid = (low+high)/2;\\n            if (ok(mid, nums, r, k)) low = mid+1;\\n            else high = mid;\\n        }\\n        return low-1;\\n    }\\n    public boolean ok(long x, int[] nums, int r, int k) {\\n        long temp = k;\\n        FenwickTree acc = new FenwickTree(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            acc.update(i, nums[i]);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            long dff = (long)acc.rangeSum(Math.max(0,i-r),Math.min(nums.length-1,i+r))-x;\\n            if (dff+temp < 0) return false;\\n            if (dff < 0) {\\n                temp += dff;\\n                acc.update(Math.min(nums.length-1,i+r),-dff);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Python []\\nfrom itertools import accumulate\\nclass FenwickTree:\\n    def __init__(self, nums):\\n        self.tree = [0]*(len(nums)+1)\\n\\n    def update(self, i, diff):\\n        i += 1\\n        while i < len(self.tree):\\n            self.tree[i] += diff\\n            i += i & (-i)\\n\\n    def _rangeSum(self, i):\\n        i += 1\\n        sum = 0\\n        while i > 0:\\n            sum += self.tree[i]\\n            i -= i & (-i)\\n        return sum\\n\\n    def rangeSum(self, i, j):\\n        return self._rangeSum(j) - self._rangeSum(i-1)\\nclass Solution:\\n    def maxPower(self, nums: List[int], r: int, k: int) -> int:\\n        def ok(x):\\n            temp = k\\n            acc = FenwickTree(nums)\\n            for i in range(len(nums)):\\n                acc.update(i, nums[i])\\n            for i in range(len(nums)):\\n                dff = acc.rangeSum(max(0,i-r),min(len(nums)-1,i+r))-x\\n                if(dff+temp<0): \\n                    return False\\n                if(dff<0):\\n                    temp += dff\\n                    acc.update(min(len(nums)-1,i+r),-dff)\\n            return True\\n        high = 10**8\\n        low = 0\\n        while(low<high):\\n            mid = (low+high)//2;\\n            if(ok(mid)):\\n                low = mid+1\\n            else:\\n                high = mid\\n        return low-1\\n```\n```Java []\\nimport java.util.*;\\npublic class Solution {\\n    static class FenwickTree {\\n        long[] tree;\\n        public FenwickTree(int[] nums) {\\n            tree = new long[nums.length+1];\\n        }\\n        public void update(int i, long diff) {\\n            i += 1;\\n            while (i < tree.length) {\\n                tree[i] += diff;\\n                i += i & (-i);\\n            }\\n        }\\n        public long _rangeSum(int i) {\\n            i += 1;\\n            long sum = 0;\\n            while (i > 0) {\\n                sum += tree[i];\\n                i -= i & (-i);\\n            }\\n            return sum;\\n        }\\n        public long rangeSum(int i, int j) {\\n            return _rangeSum(j) - _rangeSum(i-1);\\n        }\\n    }\\n    public long maxPower(int[] nums, int r, int k) {\\n        long low = 0;\\n        long high = (long)Math.pow(10,12);\\n        while (low < high) {\\n            long mid = (low+high)/2;\\n            if (ok(mid, nums, r, k)) low = mid+1;\\n            else high = mid;\\n        }\\n        return low-1;\\n    }\\n    public boolean ok(long x, int[] nums, int r, int k) {\\n        long temp = k;\\n        FenwickTree acc = new FenwickTree(nums);\\n        for (int i = 0; i < nums.length; i++) {\\n            acc.update(i, nums[i]);\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            long dff = (long)acc.rangeSum(Math.max(0,i-r),Math.min(nums.length-1,i+r))-x;\\n            if (dff+temp < 0) return false;\\n            if (dff < 0) {\\n                temp += dff;\\n                acc.update(Math.min(nums.length-1,i+r),-dff);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016487,
                "title": "prefix-sum-intervals-and-binary-search-the-answer",
                "content": "```\\nclass Solution:\\n    def check(self, freq, n, k, r, minval):\\n        adds = [0] * (n + 1)\\n        for i in range(n):\\n            if i > 0:\\n                adds[i] += adds[i - 1]\\n            curr = freq[i] + adds[i]\\n            if curr < minval:\\n                diff = minval - curr\\n                if k >= diff:\\n                    adds[i] += diff\\n                    adds[min(i + 2 * r + 1, n)] -= diff\\n                    k -= diff\\n                else:\\n                    return False\\n        return True\\n    \\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        freq = [0] * (n + 1)\\n        for i in range(n):\\n            a = max(i - r, 0)\\n            b = min(i + r, n - 1)\\n            freq[a] += stations[i]\\n            freq[b + 1] -= stations[i]\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        freq.pop()\\n        beg = min(freq)\\n        end = max(freq) + k\\n        res = beg\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            if self.check(freq, n, k, r, mid):\\n                res = mid\\n                beg = mid + 1\\n            else:\\n                end = mid - 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def check(self, freq, n, k, r, minval):\\n        adds = [0] * (n + 1)\\n        for i in range(n):\\n            if i > 0:\\n                adds[i] += adds[i - 1]\\n            curr = freq[i] + adds[i]\\n            if curr < minval:\\n                diff = minval - curr\\n                if k >= diff:\\n                    adds[i] += diff\\n                    adds[min(i + 2 * r + 1, n)] -= diff\\n                    k -= diff\\n                else:\\n                    return False\\n        return True\\n    \\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        freq = [0] * (n + 1)\\n        for i in range(n):\\n            a = max(i - r, 0)\\n            b = min(i + r, n - 1)\\n            freq[a] += stations[i]\\n            freq[b + 1] -= stations[i]\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        freq.pop()\\n        beg = min(freq)\\n        end = max(freq) + k\\n        res = beg\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            if self.check(freq, n, k, r, mid):\\n                res = mid\\n                beg = mid + 1\\n            else:\\n                end = mid - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016424,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  long long maxPower(const vector<int> &stations, const int r, const int k) {\\n    const int n = static_cast<int>(stations.size());\\n    long long power = 0;\\n    long long powers[n];\\n    memset(powers, 0, sizeof(powers));\\n    for (int i = 0; i < r + 1; ++i) {\\n      power += stations[i];\\n    }\\n    long long min_power = power;\\n    long long max_power = power;\\n    powers[0] = power;\\n    for (int i = 1; i < n; ++i) {\\n      if (i + r < n) {\\n        power += stations[i + r];\\n      }\\n      if (i - r > 0) {\\n        power -= stations[i - r - 1];\\n      }\\n      powers[i] = power;\\n      min_power = min(min_power, power);\\n      max_power = max(max_power, power);\\n    }\\n    \\n    long long diffs[n];\\n    long long low = min_power;\\n    long long high = max_power + k + 1;\\n    while (low < high) {\\n      const long long mid = low + (high - low) / 2;\\n      \\n      memset(diffs, 0, sizeof(diffs));\\n      long long power_needed = 0;\\n      long long power_diff = 0;\\n      for (int i = 0; i < n; ++i) {\\n        power_diff += diffs[i];\\n        const long long power = powers[i] + power_diff;\\n        if (power < mid) {\\n          power_needed += mid - power;\\n          diffs[i] += mid - power;\\n          power_diff += mid - power;\\n          if (i + 2 * r + 1 < n) {\\n            diffs[i + 2 * r + 1] -= mid - power;\\n          }\\n        }\\n      }\\n      \\n      if (power_needed <= k) {\\n        low = mid + 1;\\n      } else {\\n        high = mid;\\n      }\\n    }\\n    return high - 1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  long long maxPower(const vector<int> &stations, const int r, const int k) {\\n    const int n = static_cast<int>(stations.size());\\n    long long power = 0;\\n    long long powers[n];\\n    memset(powers, 0, sizeof(powers));\\n    for (int i = 0; i < r + 1; ++i) {\\n      power += stations[i];\\n    }\\n    long long min_power = power;\\n    long long max_power = power;\\n    powers[0] = power;\\n    for (int i = 1; i < n; ++i) {\\n      if (i + r < n) {\\n        power += stations[i + r];\\n      }\\n      if (i - r > 0) {\\n        power -= stations[i - r - 1];\\n      }\\n      powers[i] = power;\\n      min_power = min(min_power, power);\\n      max_power = max(max_power, power);\\n    }\\n    \\n    long long diffs[n];\\n    long long low = min_power;\\n    long long high = max_power + k + 1;\\n    while (low < high) {\\n      const long long mid = low + (high - low) / 2;\\n      \\n      memset(diffs, 0, sizeof(diffs));\\n      long long power_needed = 0;\\n      long long power_diff = 0;\\n      for (int i = 0; i < n; ++i) {\\n        power_diff += diffs[i];\\n        const long long power = powers[i] + power_diff;\\n        if (power < mid) {\\n          power_needed += mid - power;\\n          diffs[i] += mid - power;\\n          power_diff += mid - power;\\n          if (i + 2 * r + 1 < n) {\\n            diffs[i + 2 * r + 1] -= mid - power;\\n          }\\n        }\\n      }\\n      \\n      if (power_needed <= k) {\\n        low = mid + 1;\\n      } else {\\n        high = mid;\\n      }\\n    }\\n    return high - 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016413,
                "title": "binary-search-and-rolling-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using integer = long long;\\npublic:\\n    integer maxPower(vector<int>& stations, int r, int k) {\\n        std::vector<integer> base_power;\\n        {\\n            integer window_sum = 0;\\n            for (int i = 0; i < r; ++i) {\\n                window_sum += stations[i];\\n            }\\n            for (int center = 0; center < stations.size(); ++center) {\\n                const int rhs_bound = center + r;\\n                if (rhs_bound < stations.size()) {\\n                    window_sum += stations[rhs_bound];\\n                }\\n                const int lhs_bound = center - r - 1;\\n                if (lhs_bound >= 0) {\\n                    window_sum -= stations[lhs_bound];\\n                }\\n                base_power.push_back(window_sum);\\n            }\\n        }        \\n\\n        const int num_items = stations.size();\\n        const integer system_extra_power = k;\\n        const integer max_cover = *std::max_element(base_power.begin(), base_power.end());\\n        integer lower = 0, upper = max_cover + k + 1;\\n        struct Record {\\n            int idx;\\n            integer power;\\n        };\\n        while (lower < upper) {\\n            const integer target_min_power = lower + (upper - lower) / 2;\\n            std::queue<Record> window_records;\\n            integer window_sum = 0;\\n            integer total_required_extra_power = 0;\\n            for (int center = 0; center < base_power.size(); ++center) {\\n                const int rhs_bound = std::min(center + r, num_items - 1);\\n                const int lhs_bound = std::max(center - r, 0);\\n                for (; !window_records.empty(); window_records.pop()) {\\n                    const auto curr = window_records.front();\\n                    if (curr.idx >= lhs_bound) {\\n                        break;\\n                    }\\n                    total_required_extra_power += curr.power;\\n                    window_sum -= curr.power;\\n                }\\n                const integer required = target_min_power - base_power[center];\\n                if (required <= window_sum) {\\n                    continue;\\n                }\\n                const integer delta = required - window_sum;\\n                window_records.push(Record{\\n                    .idx = rhs_bound,\\n                    .power = delta\\n                });\\n                window_sum += delta;\\n            }\\n            total_required_extra_power += window_sum;\\n            if (total_required_extra_power > system_extra_power) {\\n                upper = target_min_power;\\n            } else {\\n                lower = target_min_power + 1;\\n            }\\n        }\\n        return upper - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using integer = long long;\\npublic:\\n    integer maxPower(vector<int>& stations, int r, int k) {\\n        std::vector<integer> base_power;\\n        {\\n            integer window_sum = 0;\\n            for (int i = 0; i < r; ++i) {\\n                window_sum += stations[i];\\n            }\\n            for (int center = 0; center < stations.size(); ++center) {\\n                const int rhs_bound = center + r;\\n                if (rhs_bound < stations.size()) {\\n                    window_sum += stations[rhs_bound];\\n                }\\n                const int lhs_bound = center - r - 1;\\n                if (lhs_bound >= 0) {\\n                    window_sum -= stations[lhs_bound];\\n                }\\n                base_power.push_back(window_sum);\\n            }\\n        }        \\n\\n        const int num_items = stations.size();\\n        const integer system_extra_power = k;\\n        const integer max_cover = *std::max_element(base_power.begin(), base_power.end());\\n        integer lower = 0, upper = max_cover + k + 1;\\n        struct Record {\\n            int idx;\\n            integer power;\\n        };\\n        while (lower < upper) {\\n            const integer target_min_power = lower + (upper - lower) / 2;\\n            std::queue<Record> window_records;\\n            integer window_sum = 0;\\n            integer total_required_extra_power = 0;\\n            for (int center = 0; center < base_power.size(); ++center) {\\n                const int rhs_bound = std::min(center + r, num_items - 1);\\n                const int lhs_bound = std::max(center - r, 0);\\n                for (; !window_records.empty(); window_records.pop()) {\\n                    const auto curr = window_records.front();\\n                    if (curr.idx >= lhs_bound) {\\n                        break;\\n                    }\\n                    total_required_extra_power += curr.power;\\n                    window_sum -= curr.power;\\n                }\\n                const integer required = target_min_power - base_power[center];\\n                if (required <= window_sum) {\\n                    continue;\\n                }\\n                const integer delta = required - window_sum;\\n                window_records.push(Record{\\n                    .idx = rhs_bound,\\n                    .power = delta\\n                });\\n                window_sum += delta;\\n            }\\n            total_required_extra_power += window_sum;\\n            if (total_required_extra_power > system_extra_power) {\\n                upper = target_min_power;\\n            } else {\\n                lower = target_min_power + 1;\\n            }\\n        }\\n        return upper - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016371,
                "title": "python-time-o-n-lgk-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince k is in the range of $[0, 10^9]$, time requirement will not be satisified, if the algorithm with time complexity O(NK), N is the length of stations, K is k.\\n\\nSo how to make the time complexity of algorithm not linear with K?\\nGenerally, we try to reduce from K to lgK. And the method is binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1. Calculate the power each city can get at the begining. Store them in the list of pArray;\\n\\nStep 2. left and right of the possible min power of the city:\\n    left = min(pArray)\\n    right = min(pArray) + k\\nStep 3. Binary search to until left >= right\\n\\nIn each step of binary search, we need to check whether mid (mid = (left + right) // 2) can be satisified with k more power station or not, which we use function checkMid(mid, k) to evaluate.\\n\\nIn checkMid(mid, k) function, we go through pArray from 0 to n, if pArray[i] + new power effect < mid, then more new power needed.\\n\\nThe power effect is maintained by a deque list with length (2 * r + 2). \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(NlogK)$ K is k, N is len(stations)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        \\n        n = len(stations)\\n        if(n == 1):\\n            return k + stations[0]\\n        \\n        winLen = r * 2 + 1\\n        stations = [0] * r + stations + [0] * r\\n        pArray = [0 for i in range(n)]\\n        pArray[0] = sum(stations[: 2 * r + 1])        \\n        for i in range(1, n):\\n            pArray[i] = pArray[i - 1] + stations[2 * r + i] - stations[i - 1]\\n\\n        def checkMid(mid, rK):          \\n            aWin = {}\\n            curA = 0\\n            for i in range(n):\\n                if(aWin and i in aWin):\\n                    curA += aWin[i]\\n                    aWin.pop(i)    \\n                tmp = pArray[i] + curA\\n                if(tmp < mid):\\n                    dec = mid - tmp\\n                    if(rK >= dec):\\n                        rK -= dec\\n                        curA += dec\\n                        aWin[i + winLen] = -dec   \\n                    else:\\n                        return False\\n            return True\\n\\n        left, right = min(pArray), min(pArray) + k\\n        while(left < right):\\n            mid = (left + right) >> 1\\n            isWork = checkMid(mid, k)\\n            if(isWork):\\n                left = mid + 1 \\n            else:\\n                right = mid - 1\\n  \\n        if(checkMid(left + 1, k)):\\n            return left + 1\\n        elif(checkMid(left, k)):\\n            return left\\n        else:\\n            return left - 1\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        \\n        n = len(stations)\\n        if(n == 1):\\n            return k + stations[0]\\n        \\n        winLen = r * 2 + 1\\n        stations = [0] * r + stations + [0] * r\\n        pArray = [0 for i in range(n)]\\n        pArray[0] = sum(stations[: 2 * r + 1])        \\n        for i in range(1, n):\\n            pArray[i] = pArray[i - 1] + stations[2 * r + i] - stations[i - 1]\\n\\n        def checkMid(mid, rK):          \\n            aWin = {}",
                "codeTag": "Java"
            },
            {
                "id": 3016285,
                "title": "javascript-binary-search-prefix-sum-318ms",
                "content": "```\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n\\nlet a, n, r, k, pre, p;\\nconst maxPower = (A, R, K) => {\\n    a = A, r = R, k = K, n = a.length, pre = preSum(a), p = compute();\\n    return BinarySearch(0, 2e10);\\n};\\n\\n// get the initial power array\\nconst compute = () => {\\n    let p = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        let L = Math.max(0, i - r), R = Math.min(n - 1, i + r);\\n        let rangeSum = subArraySum(pre, L, R);\\n        p[i] = rangeSum;\\n    }\\n    return p;\\n};\\n\\nconst BinarySearch = (low, high) => {\\n    while (low <= high) {\\n        let mid = low + parseInt((high - low) / 2);\\n        if (possible(mid)) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return high;\\n};\\n\\nconst cover = (r) => 2 * r + 1; // one power can spread the most range\\n\\nconst possible = (v) => {\\n    let d = Array(n + 1).fill(0), cur = 0, sum = 0;\\n    for (let i = 0; i < n; i++) {\\n        cur += d[i];\\n        if (cur + p[i] < v) {\\n            let needPower = v - p[i] - cur;\\n            sum += needPower;\\n            let idx = Math.min(i + cover(r), n);\\n            d[idx] -= needPower;\\n            cur += needPower;\\n        }\\n    }\\n    return sum <= k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Prefix Sum"
                ],
                "code": "```\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n\\nlet a, n, r, k, pre, p;\\nconst maxPower = (A, R, K) => {\\n    a = A, r = R, k = K, n = a.length, pre = preSum(a), p = compute();\\n    return BinarySearch(0, 2e10);\\n};\\n\\n// get the initial power array\\nconst compute = () => {\\n    let p = Array(n).fill(0);\\n    for (let i = 0; i < n; i++) {\\n        let L = Math.max(0, i - r), R = Math.min(n - 1, i + r);\\n        let rangeSum = subArraySum(pre, L, R);\\n        p[i] = rangeSum;\\n    }\\n    return p;\\n};\\n\\nconst BinarySearch = (low, high) => {\\n    while (low <= high) {\\n        let mid = low + parseInt((high - low) / 2);\\n        if (possible(mid)) {\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return high;\\n};\\n\\nconst cover = (r) => 2 * r + 1; // one power can spread the most range\\n\\nconst possible = (v) => {\\n    let d = Array(n + 1).fill(0), cur = 0, sum = 0;\\n    for (let i = 0; i < n; i++) {\\n        cur += d[i];\\n        if (cur + p[i] < v) {\\n            let needPower = v - p[i] - cur;\\n            sum += needPower;\\n            let idx = Math.min(i + cover(r), n);\\n            d[idx] -= needPower;\\n            cur += needPower;\\n        }\\n    }\\n    return sum <= k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016173,
                "title": "binary-search-sliding-window-java",
                "content": "\\n```JAVA []\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k)\\n    {\\n        long[] arr = new long[stations.length];\\n        for (int i = 0; i < stations.length; i++)\\n        {\\n            arr[i] = stations[i];\\n        }\\n        return helper(arr, r, k);\\n    }\\n\\n    public long helper(long[] stations, int r, long k)\\n    {\\n        int n = stations.length;\\n        long max = 0;\\n        for (long e : stations)\\n        {\\n            max = Math.max(e, max);\\n        }\\n        long low = 0;\\n        long high = Long.MAX_VALUE;\\n        long ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / (long)2;\\n            long windowSum = 0;\\n            long need = 0;\\n            long[] temp = stations.clone();\\n            for (int i = 0; i < r; i++)\\n            {\\n                windowSum += temp[i];\\n            }\\n            for (int i = 0, rear = r, front = i - r - 1; i < n && need <= k; i++, front++, rear++)\\n            {\\n\\n                if (front >= 0)\\n                {\\n                    windowSum -= temp[front];\\n                }\\n                if (rear < n)\\n                {\\n                    windowSum += temp[rear];\\n                }\\n                if (windowSum < mid)\\n                {\\n                    long remain = mid - windowSum;\\n                    need += remain;\\n                    windowSum += remain;\\n                    temp[Math.min(rear, n - 1)] += remain;\\n                }\\n\\n            }\\n            if (need <= k)\\n            {\\n                low = mid + (long) 1;\\n                ans = mid;\\n            }\\n            else\\n            {\\n                high = mid - (long) 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nTime Complexity :- $$O(n)$$",
                "solutionTags": [
                    "Java"
                ],
                "code": "```JAVA []\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k)\\n    {\\n        long[] arr = new long[stations.length];\\n        for (int i = 0; i < stations.length; i++)\\n        {\\n            arr[i] = stations[i];\\n        }\\n        return helper(arr, r, k);\\n    }\\n\\n    public long helper(long[] stations, int r, long k)\\n    {\\n        int n = stations.length;\\n        long max = 0;\\n        for (long e : stations)\\n        {\\n            max = Math.max(e, max);\\n        }\\n        long low = 0;\\n        long high = Long.MAX_VALUE;\\n        long ans = 0;\\n        while (low <= high) {\\n            long mid = (low + high) / (long)2;\\n            long windowSum = 0;\\n            long need = 0;\\n            long[] temp = stations.clone();\\n            for (int i = 0; i < r; i++)\\n            {\\n                windowSum += temp[i];\\n            }\\n            for (int i = 0, rear = r, front = i - r - 1; i < n && need <= k; i++, front++, rear++)\\n            {\\n\\n                if (front >= 0)\\n                {\\n                    windowSum -= temp[front];\\n                }\\n                if (rear < n)\\n                {\\n                    windowSum += temp[rear];\\n                }\\n                if (windowSum < mid)\\n                {\\n                    long remain = mid - windowSum;\\n                    need += remain;\\n                    windowSum += remain;\\n                    temp[Math.min(rear, n - 1)] += remain;\\n                }\\n\\n            }\\n            if (need <= k)\\n            {\\n                low = mid + (long) 1;\\n                ans = mid;\\n            }\\n            else\\n            {\\n                high = mid - (long) 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016148,
                "title": "rust-binary-search-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * Log (i64::MAX))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_power(stations: Vec<i32>, r: i32, k: i32) -> i64 {\\n        let (mut left, mut right) = (0, i64::MAX); \\n\\n        while left < right {\\n            let mid = right - (right - left) / 2;\\n            if Self::check(&stations, r, k as i64, mid) { left = mid; }\\n            else { right = mid - 1; }\\n        }\\n        left\\n    }\\n\\n    fn check(stations: &Vec<i32>, r: i32, k: i64, amt: i64) -> bool {\\n        let mut stations = stations.clone();\\n        let (n, mut sum, mut k) = (stations.len(), 0, k);\\n        let (mut left, mut right) = (0, r as usize);\\n\\n        for i in left ..= right { sum += stations[i] as i64; }\\n        for i in 0 .. n {\\n            if amt > sum {\\n                if amt > sum + k { return false }\\n                k -= amt - sum;\\n                stations[right] += (amt - sum) as i32;\\n                sum = amt;\\n            }\\n            if left as i32 == i as i32 - r {\\n                sum -= stations[left] as i64;\\n                left += 1;\\n            }\\n\\n            if right + 1 < n {\\n                right += 1;\\n                sum += stations[right] as i64;\\n            }\\n        }\\n        \\n        true       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_power(stations: Vec<i32>, r: i32, k: i32) -> i64 {\\n        let (mut left, mut right) = (0, i64::MAX); \\n\\n        while left < right {\\n            let mid = right - (right - left) / 2;\\n            if Self::check(&stations, r, k as i64, mid) { left = mid; }\\n            else { right = mid - 1; }\\n        }\\n        left\\n    }\\n\\n    fn check(stations: &Vec<i32>, r: i32, k: i64, amt: i64) -> bool {\\n        let mut stations = stations.clone();\\n        let (n, mut sum, mut k) = (stations.len(), 0, k);\\n        let (mut left, mut right) = (0, r as usize);\\n\\n        for i in left ..= right { sum += stations[i] as i64; }\\n        for i in 0 .. n {\\n            if amt > sum {\\n                if amt > sum + k { return false }\\n                k -= amt - sum;\\n                stations[right] += (amt - sum) as i32;\\n                sum = amt;\\n            }\\n            if left as i32 == i as i32 - r {\\n                sum -= stations[left] as i64;\\n                left += 1;\\n            }\\n\\n            if right + 1 < n {\\n                right += 1;\\n                sum += stations[right] as i64;\\n            }\\n        }\\n        \\n        true       \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016117,
                "title": "binary-search-sliding-window",
                "content": "```\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length;\\n        long left = 0, right = k;\\n        for (int x: stations)\\n            right += x;\\n        long []v = new long[n];\\n        while (left <= right) {\\n            long x = (left + right) / 2;\\n            for (int i = 0; i < n; ++i) \\n                v[i] = stations[i];\\n            long s = 0, use = 0;\\n            for (int i = 0; i < r; ++i) \\n                s += v[i];\\n            for (int i = 0; i < n; ++i) {\\n                int t = Math.min(n - 1, i + r);\\n                if (i + r < n) s += v[i + r];\\n                if (i - r > 0) s -= v[i - r - 1];\\n                long diff = Math.max(0, x - s);\\n                v[t] += diff;\\n                s += diff;\\n                use += diff;\\n            }\\n            if (use <= k) left = x + 1;\\n            else right = x - 1;\\n        }\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maxPower(int[] stations, int r, int k) {\\n        int n = stations.length;\\n        long left = 0, right = k;\\n        for (int x: stations)\\n            right += x;\\n        long []v = new long[n];\\n        while (left <= right) {\\n            long x = (left + right) / 2;\\n            for (int i = 0; i < n; ++i) \\n                v[i] = stations[i];\\n            long s = 0, use = 0;\\n            for (int i = 0; i < r; ++i) \\n                s += v[i];\\n            for (int i = 0; i < n; ++i) {\\n                int t = Math.min(n - 1, i + r);\\n                if (i + r < n) s += v[i + r];\\n                if (i - r > 0) s -= v[i - r - 1];\\n                long diff = Math.max(0, x - s);\\n                v[t] += diff;\\n                s += diff;\\n                use += diff;\\n            }\\n            if (use <= k) left = x + 1;\\n            else right = x - 1;\\n        }\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015995,
                "title": "golang-binary-search-swipeline-solution-with-line-by-line-explanation",
                "content": "# Intuition\\nThe question title \"Maximize the Minimum of xxx \" gives a strong hint of using binary search to \"guess\" the answer\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunc maxPower(stations []int, rad int, k int) int64 {\\n    sm , n := int64(0), len(stations)\\n    arr, cities := make([]int64, n), make([]int64, n)\\n    for i:= 0; i < n; i ++ {\\n        arr[max(0, i-rad)] += int64(stations[i])\\n        if i+rad+1 < n { arr[i+rad+1]-=int64(stations[i]) }\\n    }\\n    // Binary search boundary: l: initial min value of cities, r: inital max value of cities + k. The maximized min power must between l and r\\n    l, r := int64(0), int64(0)\\n    // Using sliding window to calculate the initial power on each city\\n    // Also getting the l and r value.\\n    for i:=0; i<n; i++ {\\n        sm += arr[i]\\n        cities[i] = sm\\n        l , r = minInt64(l, sm), maxInt64(r, sm)\\n    }\\n    r += int64(k)\\n    // Using binary search to guess the maximized min power\\n    for l + int64(1) < r {\\n        mid := l + (r - l) / 2\\n        if checkOk(mid, int64(k),rad, cities) { l = mid } else { r = mid }\\n    }\\n    if checkOk(r, int64(k),rad, cities) {return r} else {return l}\\n}\\n\\n// Validate our guessed mid value with gready method\\nfunc checkOk(mid, k int64, r int, cities []int64) bool {\\n    arr, tmp := make([]int64, len(cities)), make([]int64, len(cities))\\n    copy(arr, cities)\\n    // sm is the current accumuated sum of newly added power.\\n    sm := int64(0)\\n    for i:= 0; i < len(arr); i ++ {\\n        sm += tmp[i]\\n        // No need to handle current city if it already has power >= mid\\n        if sm + arr[i] >= mid { continue }\\n        // Amount of addtional power this city needs \\n        diff := mid - sm - cities[i]\\n        if diff > k {return false}\\n        k -= diff\\n        sm += diff\\n        // We put the additional power stations at city i + r so that they can benefit the as much incoming cities as possible.\\n        if (i + 2*r+1 < len(tmp)) {tmp[i + 2*r+1]-=diff}\\n    }\\n    return true\\n}\\nfunc maxInt64(a, b int64) int64 { if a > b { return a } else {return b} }\\nfunc max(a, b int) int { if a > b { return a } else {return b} }\\nfunc minInt64(a, b int64) int64 { if a < b { return a } else {return b} }\\nfunc min(a, b int) int { if a < b { return a } else {return b} }\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc maxPower(stations []int, rad int, k int) int64 {\\n    sm , n := int64(0), len(stations)\\n    arr, cities := make([]int64, n), make([]int64, n)\\n    for i:= 0; i < n; i ++ {\\n        arr[max(0, i-rad)] += int64(stations[i])\\n        if i+rad+1 < n { arr[i+rad+1]-=int64(stations[i]) }\\n    }\\n    // Binary search boundary: l: initial min value of cities, r: inital max value of cities + k. The maximized min power must between l and r\\n    l, r := int64(0), int64(0)\\n    // Using sliding window to calculate the initial power on each city\\n    // Also getting the l and r value.\\n    for i:=0; i<n; i++ {\\n        sm += arr[i]\\n        cities[i] = sm\\n        l , r = minInt64(l, sm), maxInt64(r, sm)\\n    }\\n    r += int64(k)\\n    // Using binary search to guess the maximized min power\\n    for l + int64(1) < r {\\n        mid := l + (r - l) / 2\\n        if checkOk(mid, int64(k),rad, cities) { l = mid } else { r = mid }\\n    }\\n    if checkOk(r, int64(k),rad, cities) {return r} else {return l}\\n}\\n\\n// Validate our guessed mid value with gready method\\nfunc checkOk(mid, k int64, r int, cities []int64) bool {\\n    arr, tmp := make([]int64, len(cities)), make([]int64, len(cities))\\n    copy(arr, cities)\\n    // sm is the current accumuated sum of newly added power.\\n    sm := int64(0)\\n    for i:= 0; i < len(arr); i ++ {\\n        sm += tmp[i]\\n        // No need to handle current city if it already has power >= mid\\n        if sm + arr[i] >= mid { continue }\\n        // Amount of addtional power this city needs \\n        diff := mid - sm - cities[i]\\n        if diff > k {return false}\\n        k -= diff\\n        sm += diff\\n        // We put the additional power stations at city i + r so that they can benefit the as much incoming cities as possible.\\n        if (i + 2*r+1 < len(tmp)) {tmp[i + 2*r+1]-=diff}\\n    }\\n    return true\\n}\\nfunc maxInt64(a, b int64) int64 { if a > b { return a } else {return b} }\\nfunc max(a, b int) int { if a > b { return a } else {return b} }\\nfunc minInt64(a, b int64) int64 { if a < b { return a } else {return b} }\\nfunc min(a, b int) int { if a < b { return a } else {return b} }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015772,
                "title": "java-100",
                "content": "```\\nclass Solution {\\n    long[] prefix;\\n    int n;\\n    int r;\\n    public long maxPower(int[] nums, int r, int k) {\\n        this.n = nums.length;\\n        this.r = r;\\n        prefix = new long[n];\\n        \\n        prefix[0] = nums[0];\\n        long sum = nums[0];\\n        \\n        //Fetch the Prefix Sum\\n        for(int i = 1 ; i < n; i++) { \\n           prefix[i] = prefix[i - 1] + nums[i];\\n            sum += nums[i];\\n        }\\n \\n        long[] powers = new long[n];\\n        for(int i = 0 ; i < n; i++){\\n            powers[i] = getPower(i);\\n           // System.out.println(powers[i]);\\n        }\\n       \\n        long low = 0, high = k + sum;\\n        long ans = 0 ;\\n        while(low <= high){\\n            long mid = low + (high - low)/2;\\n            \\n            if(good(mid, k, r, powers)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        } \\n        return ans;   \\n    }\\n    \\n    public boolean good(long x, int k, int r, long[] powers){\\n        long res = 0 ;\\n        int n = powers.length;\\n        //additional array to store the differences\\n        long[] e = new long[n];\\n        \\n        for(int i = 0 ; i < powers.length; i++){\\n            if(i > 0)\\n                e[i] += e[i - 1];\\n            \\n            long diff = x - powers[i] - e[i];\\n            if(diff <= 0)\\n                continue;\\n            if(diff > k)\\n                return false;\\n            \\n            k -= diff;\\n            e[i] += diff;\\n            if(2 * r + i + 1 < n)\\n                e[2 * r + i + 1] -= diff;\\n            \\n        }\\n        \\n        return true;\\n    }\\n    \\n    public long getPower(int i){\\n        long b = 0;\\n        if(i - r - 1 >= 0){\\n            b = prefix[i - r - 1]; ;\\n        }\\n        \\n        //prefix[i + r] - prefix[i - r - 1] is the range sum\\n        return prefix[i + r >= n ? n - 1 : i + r] - b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    long[] prefix;\\n    int n;\\n    int r;\\n    public long maxPower(int[] nums, int r, int k) {\\n        this.n = nums.length;\\n        this.r = r;\\n        prefix = new long[n];\\n        \\n        prefix[0] = nums[0];\\n        long sum = nums[0];\\n        \\n        //Fetch the Prefix Sum\\n        for(int i = 1 ; i < n; i++) { \\n           prefix[i] = prefix[i - 1] + nums[i];\\n            sum += nums[i];\\n        }\\n \\n        long[] powers = new long[n];\\n        for(int i = 0 ; i < n; i++){\\n            powers[i] = getPower(i);\\n           // System.out.println(powers[i]);\\n        }\\n       \\n        long low = 0, high = k + sum;\\n        long ans = 0 ;\\n        while(low <= high){\\n            long mid = low + (high - low)/2;\\n            \\n            if(good(mid, k, r, powers)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        } \\n        return ans;   \\n    }\\n    \\n    public boolean good(long x, int k, int r, long[] powers){\\n        long res = 0 ;\\n        int n = powers.length;\\n        //additional array to store the differences\\n        long[] e = new long[n];\\n        \\n        for(int i = 0 ; i < powers.length; i++){\\n            if(i > 0)\\n                e[i] += e[i - 1];\\n            \\n            long diff = x - powers[i] - e[i];\\n            if(diff <= 0)\\n                continue;\\n            if(diff > k)\\n                return false;\\n            \\n            k -= diff;\\n            e[i] += diff;\\n            if(2 * r + i + 1 < n)\\n                e[2 * r + i + 1] -= diff;\\n            \\n        }\\n        \\n        return true;\\n    }\\n    \\n    public long getPower(int i){\\n        long b = 0;\\n        if(i - r - 1 >= 0){\\n            b = prefix[i - r - 1]; ;\\n        }\\n        \\n        //prefix[i + r] - prefix[i - r - 1] is the range sum\\n        return prefix[i + r >= n ? n - 1 : i + r] - b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015638,
                "title": "java-binary-search",
                "content": "# 2.Binary search\\n```\\n    //2.Binary search\\n    //Runtime: 63ms 88%; Memory: 50.7MB 100%\\n    //Time: O(N + logM * (R + N)); Space: O(N)\\n    //let N be the number of cities\\n    //let M the number of stations in all cities\\n    //R be the range\\n    public long maxPower_2(int[] stations, int r, int k) {\\n        long left = Integer.MAX_VALUE, right = k;\\n        for (int station : stations) {\\n            right += station;\\n            left = Math.min(left, station);\\n        }\\n\\n        while (left <= right) {\\n            long mid = (left + right) >> 1;\\n            if (helper_2(Arrays.copyOf(stations, stations.length), r, k, mid))\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return right;\\n    }\\n\\n    //Time: O(R + N); Space: O(1)\\n    private boolean helper_2(int[] stations, int r, int k, long x){\\n        long res = 0, used = 0;\\n        for (int i = 0; i < r; i++)\\n            res += stations[i];\\n\\n        for (int i = 0; i < stations.length && k >= used; i++) {\\n            if (i + r < stations.length) res += stations[i + r];\\n            if (i - r > 0) res -= stations[i - r - 1];\\n\\n            long diff = Math.max(0, x - res);\\n            res += diff;\\n            stations[Math.min(stations.length - 1, i + r)] += diff;\\n            used += diff;\\n        }\\n        return k >= used;\\n    }\\n```\\n# 1.iteration\\n```\\n    //1.iteration\\n    //TLE\\n    //Time: O(K * (R + N); Space: O(1)\\n    public long maxPower(int[] stations, int r, int k) {\\n        long res = 0;\\n        while (k >= 0) {\\n            Pair<Integer, Long> pair = helper_min(stations, r);\\n            res = pair.getValue();\\n            int idx = Math.min(stations.length - 1, pair.getKey() + r);\\n            stations[idx]++;\\n            k--;\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(R + N); Space: O(1)\\n    private Pair<Integer, Long> helper_min(int[] stations, int r){\\n        long power = 0, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < r; i++)\\n            power += stations[i];\\n\\n        int idx = 0;\\n        for (int i = 0; i < stations.length; i++) {\\n            if (i + r < stations.length) power += stations[i + r];\\n            if (i - r > 0) power -= stations[i - r - 1];\\n\\n            if (power < min) {\\n                min = power; idx = i;\\n            }\\n        }\\n        return new Pair<>(idx, min);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //2.Binary search\\n    //Runtime: 63ms 88%; Memory: 50.7MB 100%\\n    //Time: O(N + logM * (R + N)); Space: O(N)\\n    //let N be the number of cities\\n    //let M the number of stations in all cities\\n    //R be the range\\n    public long maxPower_2(int[] stations, int r, int k) {\\n        long left = Integer.MAX_VALUE, right = k;\\n        for (int station : stations) {\\n            right += station;\\n            left = Math.min(left, station);\\n        }\\n\\n        while (left <= right) {\\n            long mid = (left + right) >> 1;\\n            if (helper_2(Arrays.copyOf(stations, stations.length), r, k, mid))\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return right;\\n    }\\n\\n    //Time: O(R + N); Space: O(1)\\n    private boolean helper_2(int[] stations, int r, int k, long x){\\n        long res = 0, used = 0;\\n        for (int i = 0; i < r; i++)\\n            res += stations[i];\\n\\n        for (int i = 0; i < stations.length && k >= used; i++) {\\n            if (i + r < stations.length) res += stations[i + r];\\n            if (i - r > 0) res -= stations[i - r - 1];\\n\\n            long diff = Math.max(0, x - res);\\n            res += diff;\\n            stations[Math.min(stations.length - 1, i + r)] += diff;\\n            used += diff;\\n        }\\n        return k >= used;\\n    }\\n```\n```\\n    //1.iteration\\n    //TLE\\n    //Time: O(K * (R + N); Space: O(1)\\n    public long maxPower(int[] stations, int r, int k) {\\n        long res = 0;\\n        while (k >= 0) {\\n            Pair<Integer, Long> pair = helper_min(stations, r);\\n            res = pair.getValue();\\n            int idx = Math.min(stations.length - 1, pair.getKey() + r);\\n            stations[idx]++;\\n            k--;\\n        }\\n        return res;\\n    }\\n\\n    //Time: O(R + N); Space: O(1)\\n    private Pair<Integer, Long> helper_min(int[] stations, int r){\\n        long power = 0, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < r; i++)\\n            power += stations[i];\\n\\n        int idx = 0;\\n        for (int i = 0; i < stations.length; i++) {\\n            if (i + r < stations.length) power += stations[i + r];\\n            if (i - r > 0) power -= stations[i - r - 1];\\n\\n            if (power < min) {\\n                min = power; idx = i;\\n            }\\n        }\\n        return new Pair<>(idx, min);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015567,
                "title": "easy-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsearch for a mid value using binary search and validate it,where you have to add the extra power supplies to the end of the window\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlog(1e18))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>s,int r,ll k,ll m){\\n        ll sum=0,n=s.size();\\n        for(ll i=0;i<=r;i++)sum+=s[i];\\n        for(ll i=0;i<n;i++){\\n            if(m>sum){\\n                ll req=m-sum;\\n                s[min(n-1,i+r)]+=req;\\n                sum+=min(req,k);\\n                k-=min(req,k);\\n            }\\n            if(sum<m)return false;\\n            if(i>=r){\\n                sum-=s[i-r];\\n            }\\n            if(i+r+1<n){\\n                sum+=s[i+r+1];\\n            }\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& s, int r, int k) {\\n        ll L=0,R=1e18,ans=-1;\\n        while(L<=R){\\n            ll mid=L+(R-L)/2;\\n            if(isPossible(s,r,k*1LL,mid)){\\n                ans=mid;\\n                L=mid+1;\\n            }else{\\n                R=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>s,int r,ll k,ll m){\\n        ll sum=0,n=s.size();\\n        for(ll i=0;i<=r;i++)sum+=s[i];\\n        for(ll i=0;i<n;i++){\\n            if(m>sum){\\n                ll req=m-sum;\\n                s[min(n-1,i+r)]+=req;\\n                sum+=min(req,k);\\n                k-=min(req,k);\\n            }\\n            if(sum<m)return false;\\n            if(i>=r){\\n                sum-=s[i-r];\\n            }\\n            if(i+r+1<n){\\n                sum+=s[i+r+1];\\n            }\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& s, int r, int k) {\\n        ll L=0,R=1e18,ans=-1;\\n        while(L<=R){\\n            ll mid=L+(R-L)/2;\\n            if(isPossible(s,r,k*1LL,mid)){\\n                ans=mid;\\n                L=mid+1;\\n            }else{\\n                R=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015543,
                "title": "c-code-binary-search-on-answer",
                "content": "\\n# Code\\n```\\n#define ll long long\\n\\nll min(ll a, ll b){\\n    return a<b?a:b;\\n}\\nclass Solution {\\npublic:\\n    bool check(vector<ll>& v,int &n, ll val, ll k,int r){\\n        set<int> s;\\n        ll cnt=0;\\n       queue<ll>vv;\\n        for(int i =0;i<n;i++){\\n            if(v[i]+cnt<val){\\n                k-=val-(v[i]+cnt);\\n                if(k<0) return false;\\n                vv.push(val-v[i]-cnt);\\n                cnt +=(val-v[i]-cnt);\\n                s.insert(min(n-1,i+2*r));\\n            }\\n            auto it = s.find(i);\\n            if(it!=s.end()){\\n             \\n                cnt-=vv.front();\\n                vv.pop();\\n                s.erase(it);\\n            }\\n        }\\n        return k>=0;\\n        \\n    }\\n    long long maxPower(vector<int>& st, int r, int k) {\\n        ll cnt=0;\\n        set<int> s;\\n        int n = st.size();\\n        vector<ll> v(n);\\n        queue<ll> q;\\n        for(int i =0;i<n;i++){\\n            ll x = st[i];\\n            v[i] = x+cnt;\\n            if(r)\\n            cnt+=x;\\n            auto it = s.find(i);\\n            if(it!=s.end()){\\n                cnt-=q.front();\\n                q.pop();\\n                s.erase(it);\\n            }\\n            q.push(x);\\n            s.insert(min(n-1,i+r));\\n        }\\n        s.clear();\\n       while(q.size()) q.pop();\\n        cnt=0;\\n         for(int i =n-1;i>=0;i--){\\n             ll x= st[i];\\n            v[i] = v[i]+cnt;\\n             if(r)\\n            cnt+=x;\\n            auto it = s.find(i);\\n            if(it!=s.end()){\\n                cnt-=q.front();\\n                q.pop();\\n                s.erase(it);\\n            }\\n             q.push(x);\\n            s.insert(max(0,(i-r)));\\n        }\\n        ll ans = INT_MIN;\\n        ll str = 0 ,en = 1e12, mid;\\n        while(str<=en){\\n            mid = (str+en)>>1;\\n            if(check(v,n,mid,k,r)){\\n                ans = ans>mid?ans:mid;\\n                str = mid+1;\\n            }else{\\n                en = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nll min(ll a, ll b){\\n    return a<b?a:b;\\n}\\nclass Solution {\\npublic:\\n    bool check(vector<ll>& v,int &n, ll val, ll k,int r){\\n        set<int> s;\\n        ll cnt=0;\\n       queue<ll>vv;\\n        for(int i =0;i<n;i++){\\n            if(v[i]+cnt<val){\\n                k-=val-(v[i]+cnt);\\n                if(k<0) return false;\\n                vv.push(val-v[i]-cnt);\\n                cnt +=(val-v[i]-cnt);\\n                s.insert(min(n-1,i+2*r));\\n            }\\n            auto it = s.find(i);\\n            if(it!=s.end()){\\n             \\n                cnt-=vv.front();\\n                vv.pop();\\n                s.erase(it);\\n            }\\n        }\\n        return k>=0;\\n        \\n    }\\n    long long maxPower(vector<int>& st, int r, int k) {\\n        ll cnt=0;\\n        set<int> s;\\n        int n = st.size();\\n        vector<ll> v(n);\\n        queue<ll> q;\\n        for(int i =0;i<n;i++){\\n            ll x = st[i];\\n            v[i] = x+cnt;\\n            if(r)\\n            cnt+=x;\\n            auto it = s.find(i);\\n            if(it!=s.end()){\\n                cnt-=q.front();\\n                q.pop();\\n                s.erase(it);\\n            }\\n            q.push(x);\\n            s.insert(min(n-1,i+r));\\n        }\\n        s.clear();\\n       while(q.size()) q.pop();\\n        cnt=0;\\n         for(int i =n-1;i>=0;i--){\\n             ll x= st[i];\\n            v[i] = v[i]+cnt;\\n             if(r)\\n            cnt+=x;\\n            auto it = s.find(i);\\n            if(it!=s.end()){\\n                cnt-=q.front();\\n                q.pop();\\n                s.erase(it);\\n            }\\n             q.push(x);\\n            s.insert(max(0,(i-r)));\\n        }\\n        ll ans = INT_MIN;\\n        ll str = 0 ,en = 1e12, mid;\\n        while(str<=en){\\n            mid = (str+en)>>1;\\n            if(check(v,n,mid,k,r)){\\n                ans = ans>mid?ans:mid;\\n                str = mid+1;\\n            }else{\\n                en = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015540,
                "title": "python-solution-binary-search-sweep-line",
                "content": "```\\ndef maxPower(self, nums: List[int], r: int, k: int) -> int:\\n\\td, n = [0]*(len(nums)+1), len(nums)\\n\\tfor i in range(n):\\n\\t\\tleft, right = max(0, i-r), min(i+r, n-1)\\n\\t\\td[left] += nums[i]\\n\\t\\td[right+1] -= nums[i] \\n\\n\\tdef valid(x, t):\\n\\t\\td_cur, s = d[:], 0\\n\\t\\tfor i in range(n):\\n\\t\\t\\ts += d_cur[i]\\n\\t\\t\\tdx = x-s\\n\\t\\t\\tif dx>0:\\n\\t\\t\\t\\tt += dx\\n\\t\\t\\t\\td_cur[i] += dx\\n\\t\\t\\t\\td_cur[min(i+2*r,n-1)+1] -= dx\\n\\t\\t\\t\\ts = x\\n\\t\\treturn t<=k\\n\\n\\n\\tlo, hi = 0, sum(nums)+k\\n\\twhile(lo<hi):\\n\\t\\tmid = (lo+hi+1)//2\\n\\t\\tif valid(mid, 0):\\n\\t\\t\\tlo = mid\\n\\t\\telse:\\n\\t\\t\\thi = mid-1\\n\\treturn lo\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxPower(self, nums: List[int], r: int, k: int) -> int:\\n\\td, n = [0]*(len(nums)+1), len(nums)\\n\\tfor i in range(n):\\n\\t\\tleft, right = max(0, i-r), min(i+r, n-1)\\n\\t\\td[left] += nums[i]\\n\\t\\td[right+1] -= nums[i] \\n\\n\\tdef valid(x, t):\\n\\t\\td_cur, s = d[:], 0\\n\\t\\tfor i in range(n):\\n\\t\\t\\ts += d_cur[i]\\n\\t\\t\\tdx = x-s\\n\\t\\t\\tif dx>0:\\n\\t\\t\\t\\tt += dx\\n\\t\\t\\t\\td_cur[i] += dx\\n\\t\\t\\t\\td_cur[min(i+2*r,n-1)+1] -= dx\\n\\t\\t\\t\\ts = x\\n\\t\\treturn t<=k\\n\\n\\n\\tlo, hi = 0, sum(nums)+k\\n\\twhile(lo<hi):\\n\\t\\tmid = (lo+hi+1)//2\\n\\t\\tif valid(mid, 0):\\n\\t\\t\\tlo = mid\\n\\t\\telse:\\n\\t\\t\\thi = mid-1\\n\\treturn lo\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3015450,
                "title": "python-3-hint-solution-binary-search-line-sweep",
                "content": "Binary Search using line sweep and keep a running offset.\\n\\nExample\\n```\\nstations = [13,12,8,14,7]\\nr = 2\\nk = 23\\n```\\n\\nLet\\'s say the target is 52.\\nOriginal powered stations = [33, 47, 54, 41, 29]\\nInitiate offsets = [0, 0, 0, 0, 0, 0]\\ncur_offset = 0\\n\\n- i = 0\\n\\t-  cur_offset += offsets[i] = 0\\n\\t-  diff = 52 - (33 + cur_offset) = 19\\n\\t-  Thus we set offsets = [19, 0, 0, 0, 0, -19] (end index = 0 + 2 * r + 1) to maximize its coverage, \\n\\t-  k = 23 - 19 = 4\\n\\t-  cur_offset = 0 + 19 = 19\\n- i = 1\\n\\t- cut_offset = cur_offset + offsets[1] = 19 + 0 = 19\\n\\t- diff = 52 - (47 + 19) < 0; continue\\n- i = 2\\n\\t- cut_offset = cur_offset + offsets[2] = 19 + 0 = 19\\n\\t- diff = 52 - (54 + 19) < 0; continue\\n- i = 3\\n\\t- cut_offset = cur_offset + offsets[3] = 19 + 0 = 19\\n\\t- diff = 41 - (47 + 19) < 0; continue\\n- i = 4\\n\\t- cut_offset = cur_offset + offsets[3] = 19 + 0 = 19\\n\\t- diff = 29 - (47 + 19) = 1\\n\\t- Thus we set offsets = [19, 0, 0, 0, 1, -19-1] \\n\\t- k = 4 - 1\\n\\t- cut_offset = 19 + 1 = 20\\n\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        n = len(stations)\\n        acc = list(accumulate(stations, initial=0))\\n        \\n        # precompute original power stations on each city\\n        cands = [0] * n\\n        for i in range(n):\\n            cands[i] = acc[min(i + r + 1, len(acc)-1)] - acc[max(0, i - r)]\\n            \\n        # binary search\\n        def bs(x, k):\\n            # offsets\\n            offsets = [0] * (n + 1)\\n            # running offset\\n            cur_offset = 0\\n            for i, cand in enumerate(cands):\\n                cur_offset += offsets[i]\\n                diff = x - (cand + cur_offset)\\n                # met minimum \\n                if diff <= 0: continue\\n                # no more extra stations\\n                if abs(diff) > k: return False\\n                k -= abs(diff)\\n                # set the range of affected indexes\\n                left, right = i, min(i+2*r+1, n)\\n                offsets[left] += diff\\n                offsets[right] -= diff            \\n                # compensate for the diff\\n                cur_offset += diff            \\n            \\n            return True\\n        \\n        \\n        l, h = min(cands), max(cands) + k\\n        \\n        while l < h:\\n            mid = l + (h - l + 1) // 2\\n            if bs(mid, k):\\n                l = mid\\n            else:\\n                h = mid - 1\\n    \\n        return l",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nstations = [13,12,8,14,7]\\nr = 2\\nk = 23\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3015423,
                "title": "binary-search-solution-predicate-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will take some value of our answer and check if it is possible to have that as our answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*log(10^12))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*log(10^12))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     //maximum possible minimum power\\n    // maximize the minimum power in all the cities\\n    //maximize the minimum of power\\n    // power is the total station it is being provided power from\\n   // T T T T T T T T T F F F F F F \\n    typedef long long ll;\\n    \\n    \\n    bool helper(ll minPower, vector<ll>&power, int range, ll extra, int n){\\n        //cout<<minPower<<\"   \"<<extra<<\"    \";\\n        vector<ll>additional(n+1, 0);\\n        for(int i=0; i<n; i++){\\n            if(i!=0)additional[i]+=additional[i-1];\\n            ll p= power[i]+additional[i];\\n            if(p>=minPower)continue;\\n            //cout<<minPower-p<<endl;\\n            additional[i]+=minPower-p;\\n            additional[min(n, i+2*range+1)]-=minPower-p;\\n            extra-=minPower-p;\\n        }\\n        //cout<<extra<<endl;\\n        return extra>=0;\\n    }\\n    \\n    ll maximum(vector<ll>&power, int r, int k, int n){\\n        ll lo=0, hi= 1e12;\\n        while(hi-lo>1){\\n            ll mid= lo+(hi-lo)/2;\\n            if(helper(mid, power, r, k, n)){\\n                //cout<<mid<<endl;\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if(helper(hi, power, r, k, n))return hi;\\n        return lo;\\n    }\\n    \\n    ll maxPower(vector<int>& stations, int r, int k) {\\n        int n=stations.size();\\n        vector<ll>power(n+1, 0);\\n        for(int i=0; i<n; i++){\\n            power[max(0, i-r)]+=stations[i];\\n            power[min(i+r+1, n)]-=stations[i];\\n        }\\n        //cout<<power[0]<<endl;\\n        for(int i=1; i<n; i++){\\n            power[i]+=power[i-1];\\n            //cout<<power[i]<<endl;\\n        }\\n        return maximum(power, r, k, n);\\n    }\\n};\\n\\n\\n// \\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     //maximum possible minimum power\\n    // maximize the minimum power in all the cities\\n    //maximize the minimum of power\\n    // power is the total station it is being provided power from\\n   // T T T T T T T T T F F F F F F \\n    typedef long long ll;\\n    \\n    \\n    bool helper(ll minPower, vector<ll>&power, int range, ll extra, int n){\\n        //cout<<minPower<<\"   \"<<extra<<\"    \";\\n        vector<ll>additional(n+1, 0);\\n        for(int i=0; i<n; i++){\\n            if(i!=0)additional[i]+=additional[i-1];\\n            ll p= power[i]+additional[i];\\n            if(p>=minPower)continue;\\n            //cout<<minPower-p<<endl;\\n            additional[i]+=minPower-p;\\n            additional[min(n, i+2*range+1)]-=minPower-p;\\n            extra-=minPower-p;\\n        }\\n        //cout<<extra<<endl;\\n        return extra>=0;\\n    }\\n    \\n    ll maximum(vector<ll>&power, int r, int k, int n){\\n        ll lo=0, hi= 1e12;\\n        while(hi-lo>1){\\n            ll mid= lo+(hi-lo)/2;\\n            if(helper(mid, power, r, k, n)){\\n                //cout<<mid<<endl;\\n                lo=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        if(helper(hi, power, r, k, n))return hi;\\n        return lo;\\n    }\\n    \\n    ll maxPower(vector<int>& stations, int r, int k) {\\n        int n=stations.size();\\n        vector<ll>power(n+1, 0);\\n        for(int i=0; i<n; i++){\\n            power[max(0, i-r)]+=stations[i];\\n            power[min(i+r+1, n)]-=stations[i];\\n        }\\n        //cout<<power[0]<<endl;\\n        for(int i=1; i<n; i++){\\n            power[i]+=power[i-1];\\n            //cout<<power[i]<<endl;\\n        }\\n        return maximum(power, r, k, n);\\n    }\\n};\\n\\n\\n// \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3015401,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    bool func(const vi(int)&v, ll r, ll k, ll m){\\n        ll n=v.size(), sum=0, rem=k;\\n        vi(ll)pre(n);\\n        for(ll in=0;in<n;++in){\\n            ll i=max(0LL, in-r), j=min(n-1, in+r);\\n            pre[i]+=v[in];\\n            if(j+1<n){\\n                pre[j+1]-=v[in]; // net cumulative effect\\n            }\\n        }\\n        for(ll i=0;i<n;++i){\\n            sum+=pre[i];\\n            if(sum>=m){\\n                continue;\\n            }\\n            ll dif=m-sum;\\n            if(dif>rem){\\n                return 0;\\n            }\\n            sum+=dif, rem-=dif;\\n            if(i+(2*r)+1<n){\\n                pre[i+(2*r)+1]-=dif;\\n            }\\n        }\\n        return 1;\\n    }\\n    long long maxPower(vector<int>&v, int r, int k) {\\n        ll n=v.size(), x=0, y=1e18, ans=-1;\\n        while(x<=y){\\n            ll m=x+((y-x)>>1);\\n            if(func(v, r, k, m)){\\n                ans=m, x=m+1;\\n            }\\n            else{\\n                y=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    bool func(const vi(int)&v, ll r, ll k, ll m){\\n        ll n=v.size(), sum=0, rem=k;\\n        vi(ll)pre(n);\\n        for(ll in=0;in<n;++in){\\n            ll i=max(0LL, in-r), j=min(n-1, in+r);\\n            pre[i]+=v[in];\\n            if(j+1<n){\\n                pre[j+1]-=v[in]; // net cumulative effect\\n            }\\n        }\\n        for(ll i=0;i<n;++i){\\n            sum+=pre[i];\\n            if(sum>=m){\\n                continue;\\n            }\\n            ll dif=m-sum;\\n            if(dif>rem){\\n                return 0;\\n            }\\n            sum+=dif, rem-=dif;\\n            if(i+(2*r)+1<n){\\n                pre[i+(2*r)+1]-=dif;\\n            }\\n        }\\n        return 1;\\n    }\\n    long long maxPower(vector<int>&v, int r, int k) {\\n        ll n=v.size(), x=0, y=1e18, ans=-1;\\n        while(x<=y){\\n            ll m=x+((y-x)>>1);\\n            if(func(v, r, k, m)){\\n                ans=m, x=m+1;\\n            }\\n            else{\\n                y=m-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015300,
                "title": "binary-search-deque-prefix-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long int>presum;\\n    bool ispossible(vector<int>& arr, long long int r, long long int k,long long int mid){\\n        long long int add=0;\\n        \\n        deque<pair<long long int,long long int>>q;\\n        for(int i=0;i<arr.size();i++){\\n            while(!q.empty() && q.front().first<i){\\n                add-=q.front().second;\\n                q.pop_front();\\n            }\\n            long long int curr=(long long int)(i+r>=arr.size()?presum.back():presum[i+r])-\\n                (long long int)(i-r-1<0?0:presum[i-r-1])+add;\\n            if(curr>=mid){\\n                continue;\\n            }\\n            long long int req=mid-curr;\\n            if((k-req)<0)return false;\\n            k-=req;\\n            //we have to add req number of powers to current city.\\n            //Now where we can add these req number of power stations so that current city can also get power along with maximum cities can get power so for best case we can add req number of power stations to (i+r)th city so that current city along with maximum number of city (upto i+2*r) get benifit\\n            q.push_back({i+2*r,req});\\n            add+=req;\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& arr, long long int r, long long int k) {\\n        long long int l=0,h=0;\\n        long long int ans;\\n        presum.resize(arr.size());\\n        presum[0]=arr[0];\\n        for(long long int i=1;i<arr.size();i++){\\n            presum[i]=(long long int)arr[i]+presum[i-1];\\n        }\\n        h=presum.back()+k;\\n        while(h>=l){\\n            long long int mid=l+(h-l)/2;\\n            if(ispossible(arr,r,k,mid)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Do Upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Queue",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long int>presum;\\n    bool ispossible(vector<int>& arr, long long int r, long long int k,long long int mid){\\n        long long int add=0;\\n        \\n        deque<pair<long long int,long long int>>q;\\n        for(int i=0;i<arr.size();i++){\\n            while(!q.empty() && q.front().first<i){\\n                add-=q.front().second;\\n                q.pop_front();\\n            }\\n            long long int curr=(long long int)(i+r>=arr.size()?presum.back():presum[i+r])-\\n                (long long int)(i-r-1<0?0:presum[i-r-1])+add;\\n            if(curr>=mid){\\n                continue;\\n            }\\n            long long int req=mid-curr;\\n            if((k-req)<0)return false;\\n            k-=req;\\n            //we have to add req number of powers to current city.\\n            //Now where we can add these req number of power stations so that current city can also get power along with maximum cities can get power so for best case we can add req number of power stations to (i+r)th city so that current city along with maximum number of city (upto i+2*r) get benifit\\n            q.push_back({i+2*r,req});\\n            add+=req;\\n        }\\n        return true;\\n    }\\n    long long maxPower(vector<int>& arr, long long int r, long long int k) {\\n        long long int l=0,h=0;\\n        long long int ans;\\n        presum.resize(arr.size());\\n        presum[0]=arr[0];\\n        for(long long int i=1;i<arr.size();i++){\\n            presum[i]=(long long int)arr[i]+presum[i-1];\\n        }\\n        h=presum.back()+k;\\n        while(h>=l){\\n            long long int mid=l+(h-l)/2;\\n            if(ispossible(arr,r,k,mid)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015265,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThese kind of problems where we have to maximize or minimize some value can generally be solved using binary search. You just have to deduce what you are searching for and how you verify that a value is acceptable or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution has 2 parts: \\ni. Binary search on the maximum minimum power we can get.\\nii. Checking if a certain minimum power is attainable after adding `k` power stations.\\n\\n**Binary Search** part is rather simple. You just have to be careful of overflow while calculating `mid`.\\n\\n**Verification Part** can be deduced from observation. Suppose you are going left -> right in the array, and you find a station the is not getting enough power. What position should you place the required stations? It is most optimal to place it `r` places ahead as you don\\'t need to increase the power of the stations you have already covered. Rather placing it `r` places ahead might even increase the power of some low power stations which we haven\\'t yet encountered.\\nFinally if you can satisfy the min power constraint in the given number of stations then we can try a higher value, otherwise we go lower.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(Nlog2(1e11)) ~ O(37 * N)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(N)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& a, int r, int k) {\\n        long long low = 0;\\n        long long  high = 1e11;\\n        long long  ans = -1;\\n        \\n        while (low < high) {\\n            // to avoid integer overflow use this\\n            long long mid = low + ((high - low) >> 1); \\n            if (check(a, r, k, mid)) {\\n                ans = mid; \\n                low = mid + 1; \\n            } else {\\n                high = mid - 1; \\n            }\\n        }\\n        // since we are performing integer division(right shift) for calculating mid, there is a chance we might miss some higher values\\n        if (check(a, r, k, ans + 1)) {\\n            ans++;\\n        }\\n        return ans; \\n    }\\nprivate: \\n    bool check(vector<int> &a, int r, long long k, long long m) {\\n        int n = (int)a.size();\\n        vector<long long> f(n + 1, 0ll); // something like a prefix sum array\\n        for (int i = 0; i < n; i++) {\\n            f[max(i - r, 0)] += a[i];\\n            f[min(i + r + 1, n)] -= a[i];\\n        }\\n        long long curr = 0; \\n        for (int i = 0; i < n; i++) {\\n            curr += f[i];\\n            if (curr < m) {\\n                long long t = max(0ll, m - curr); \\n                k -= t; \\n                f[min(i + (2 * r) + 1, n)] -= t;\\n                curr += t; \\n            }\\n        }\\n        return k >= 0;\\n    }\\n};\\n```\\n\\n***Incase you have any doubts mention them in comments, will get explain***",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& a, int r, int k) {\\n        long long low = 0;\\n        long long  high = 1e11;\\n        long long  ans = -1;\\n        \\n        while (low < high) {\\n            // to avoid integer overflow use this\\n            long long mid = low + ((high - low) >> 1); \\n            if (check(a, r, k, mid)) {\\n                ans = mid; \\n                low = mid + 1; \\n            } else {\\n                high = mid - 1; \\n            }\\n        }\\n        // since we are performing integer division(right shift) for calculating mid, there is a chance we might miss some higher values\\n        if (check(a, r, k, ans + 1)) {\\n            ans++;\\n        }\\n        return ans; \\n    }\\nprivate: \\n    bool check(vector<int> &a, int r, long long k, long long m) {\\n        int n = (int)a.size();\\n        vector<long long> f(n + 1, 0ll); // something like a prefix sum array\\n        for (int i = 0; i < n; i++) {\\n            f[max(i - r, 0)] += a[i];\\n            f[min(i + r + 1, n)] -= a[i];\\n        }\\n        long long curr = 0; \\n        for (int i = 0; i < n; i++) {\\n            curr += f[i];\\n            if (curr < m) {\\n                long long t = max(0ll, m - curr); \\n                k -= t; \\n                f[min(i + (2 * r) + 1, n)] -= t;\\n                curr += t; \\n            }\\n        }\\n        return k >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015264,
                "title": "binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThese kind of problems where we have to maximize or minimize some value can generally be solved using binary search. You just have to deduce what you are searching for and how you verify that a value is acceptable or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution has 2 parts: \\ni. Binary search on the maximum minimum power we can get.\\nii. Checking if a certain minimum power is attainable after adding `k` power stations.\\n\\n**Binary Search** part is rather simple. You just have to be careful of overflow while calculating `mid`.\\n\\n**Verification Part** can be deduced from observation. Suppose you are going left -> right in the array, and you find a station the is not getting enough power. What position should you place the required stations? It is most optimal to place it `r` places ahead as you don\\'t need to increase the power of the stations you have already covered. Rather placing it `r` places ahead might even increase the power of some low power stations which we haven\\'t yet encountered.\\nFinally if you can satisfy the min power constraint in the given number of stations then we can try a higher value, otherwise we go lower.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(Nlog2(1e11)) ~ O(37 * N)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(N)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& a, int r, int k) {\\n        long long low = 0;\\n        long long  high = 1e11;\\n        long long  ans = -1;\\n        \\n        while (low < high) {\\n            // to avoid integer overflow use this\\n            long long mid = low + ((high - low) >> 1); \\n            if (check(a, r, k, mid)) {\\n                ans = mid; \\n                low = mid + 1; \\n            } else {\\n                high = mid - 1; \\n            }\\n        }\\n        // since we are performing integer division(right shift) for calculating mid, there is a chance we might miss some higher values\\n        if (check(a, r, k, ans + 1)) {\\n            ans++;\\n        }\\n        return ans; \\n    }\\nprivate: \\n    bool check(vector<int> &a, int r, long long k, long long m) {\\n        int n = (int)a.size();\\n        vector<long long> f(n + 1, 0ll); // something like a prefix sum array\\n        for (int i = 0; i < n; i++) {\\n            f[max(i - r, 0)] += a[i];\\n            f[min(i + r + 1, n)] -= a[i];\\n        }\\n        long long curr = 0; \\n        for (int i = 0; i < n; i++) {\\n            curr += f[i];\\n            if (curr < m) {\\n                long long t = max(0ll, m - curr); \\n                k -= t; \\n                f[min(i + (2 * r) + 1, n)] -= t;\\n                curr += t; \\n            }\\n        }\\n        return k >= 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxPower(vector<int>& a, int r, int k) {\\n        long long low = 0;\\n        long long  high = 1e11;\\n        long long  ans = -1;\\n        \\n        while (low < high) {\\n            // to avoid integer overflow use this\\n            long long mid = low + ((high - low) >> 1); \\n            if (check(a, r, k, mid)) {\\n                ans = mid; \\n                low = mid + 1; \\n            } else {\\n                high = mid - 1; \\n            }\\n        }\\n        // since we are performing integer division(right shift) for calculating mid, there is a chance we might miss some higher values\\n        if (check(a, r, k, ans + 1)) {\\n            ans++;\\n        }\\n        return ans; \\n    }\\nprivate: \\n    bool check(vector<int> &a, int r, long long k, long long m) {\\n        int n = (int)a.size();\\n        vector<long long> f(n + 1, 0ll); // something like a prefix sum array\\n        for (int i = 0; i < n; i++) {\\n            f[max(i - r, 0)] += a[i];\\n            f[min(i + r + 1, n)] -= a[i];\\n        }\\n        long long curr = 0; \\n        for (int i = 0; i < n; i++) {\\n            curr += f[i];\\n            if (curr < m) {\\n                long long t = max(0ll, m - curr); \\n                k -= t; \\n                f[min(i + (2 * r) + 1, n)] -= t;\\n                curr += t; \\n            }\\n        }\\n        return k >= 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015238,
                "title": "c-binary-search-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    bool check(vector<int> s,ll m,ll r, ll k){\\n        ll cur=0;\\n        int n=s.size();\\n        int i;\\n        for( i=0;i<=r;i++)\\n            cur+=s[i];\\n        // cout<<m<<\" \"<<cur<<\"\\\\n\";\\n        if(cur<m){\\n            ll d=m-cur;\\n            if(k<d)return 0;\\n            cur+=d;\\n            k-=d;\\n           \\n            s[r]+=d;\\n        }\\n        // cout<<m<<\" \"<<cur<<\"\\\\n\";\\n        int st=0;\\n        for(i=r+1;i<n;i++){\\n            cur+=s[i];\\n            if(i-st> 2*r)\\n            cur-=s[st++];\\n            \\n            if(cur<m){\\n            ll d=m-cur;\\n            if(k<d)return 0;\\n            cur+=d;\\n            k-=d;\\n            s[i]+=d;\\n        }\\n        }\\n        \\n        // for(int ii=0;ii<s.size();ii++)\\n        //     cout<<s[ii]<<\" \";\\n        n--;\\n        cur=0;\\n        // cout<<\"\\\\n\";\\n        while(r>=0){\\n            cur+=s[n];\\n            n--;\\n            r--;\\n        }\\n        // cout<<cur<<\"\\\\n\";\\n        if(cur<m){\\n            ll d=m-cur;\\n            if(k<d)return 0;\\n            cur+=d;\\n            k-=d;\\n        }\\n        \\n        return 1;\\n        \\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        ll low=0,high=10e10;\\n        ll ans=0;\\n        while(low<=high){\\n            ll mid = low +(high-low)/2;\\n            if(check(stations,mid,r,k)){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    bool check(vector<int> s,ll m,ll r, ll k){\\n        ll cur=0;\\n        int n=s.size();\\n        int i;\\n        for( i=0;i<=r;i++)\\n            cur+=s[i];\\n        // cout<<m<<\" \"<<cur<<\"\\\\n\";\\n        if(cur<m){\\n            ll d=m-cur;\\n            if(k<d)return 0;\\n            cur+=d;\\n            k-=d;\\n           \\n            s[r]+=d;\\n        }\\n        // cout<<m<<\" \"<<cur<<\"\\\\n\";\\n        int st=0;\\n        for(i=r+1;i<n;i++){\\n            cur+=s[i];\\n            if(i-st> 2*r)\\n            cur-=s[st++];\\n            \\n            if(cur<m){\\n            ll d=m-cur;\\n            if(k<d)return 0;\\n            cur+=d;\\n            k-=d;\\n            s[i]+=d;\\n        }\\n        }\\n        \\n        // for(int ii=0;ii<s.size();ii++)\\n        //     cout<<s[ii]<<\" \";\\n        n--;\\n        cur=0;\\n        // cout<<\"\\\\n\";\\n        while(r>=0){\\n            cur+=s[n];\\n            n--;\\n            r--;\\n        }\\n        // cout<<cur<<\"\\\\n\";\\n        if(cur<m){\\n            ll d=m-cur;\\n            if(k<d)return 0;\\n            cur+=d;\\n            k-=d;\\n        }\\n        \\n        return 1;\\n        \\n    }\\n    long long maxPower(vector<int>& stations, int r, int k) {\\n        ll low=0,high=10e10;\\n        ll ans=0;\\n        while(low<=high){\\n            ll mid = low +(high-low)/2;\\n            if(check(stations,mid,r,k)){\\n                ans=max(ans,mid);\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3015216,
                "title": "c-binary-search-with-the-greedy-check",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxPower(vector<int>& stations, int r, int k) {\\n        const int n = size(stations);\\n        vector<ll> powers(n);\\n        for (int i = 0; i < n; ++i) {\\n            powers[max(0, i - r)] += stations[i];\\n            if (i + r < n - 1) {\\n                powers[i + r + 1] -= stations[i];\\n            }\\n        }\\n        for (int i = 1; i < n; ++i) {\\n            powers[i] += powers[i - 1];\\n        }\\n        const auto check = [&](ll m) {\\n            vector<ll> events(n);\\n            ll stationsAvailable = k;\\n            ll additionalPower = 0;\\n            for (int i = 0; i < n; ++i) {\\n                additionalPower -= events[i];\\n                if (powers[i] + additionalPower < m) {\\n                    if (stationsAvailable < m - powers[i] - additionalPower) {\\n                        return false;\\n                    }\\n                    const ll stationsRequired = m - powers[i] - additionalPower;\\n                    if (i + 2 * r + 1 < n) {\\n                        events[i + 2 * r + 1] += stationsRequired;\\n                        additionalPower += stationsRequired;\\n                        stationsAvailable -= stationsRequired;\\n                    }\\n                } \\n            }\\n            return true;\\n        };\\n        ll left = 0, right = 1\\'000\\'000\\'000\\'000\\'000\\'000l;\\n        while (left + 1 < right) {\\n            const auto m = (left + right) / 2;\\n            if (check(m)) {\\n                left = m;\\n            }\\n            else {\\n                right = m;\\n            }\\n        }\\n        return check(right) ? right : left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxPower(vector<int>& stations, int r, int k) {\\n        const int n = size(stations);\\n        vector<ll> powers(n);\\n        for (int i = 0; i < n; ++i) {\\n            powers[max(0, i - r)] += stations[i];\\n            if (i + r < n - 1) {\\n                powers[i + r + 1] -= stations[i];\\n            }\\n        }\\n        for (int i = 1; i < n; ++i) {\\n            powers[i] += powers[i - 1];\\n        }\\n        const auto check = [&](ll m) {\\n            vector<ll> events(n);\\n            ll stationsAvailable = k;\\n            ll additionalPower = 0;\\n            for (int i = 0; i < n; ++i) {\\n                additionalPower -= events[i];\\n                if (powers[i] + additionalPower < m) {\\n                    if (stationsAvailable < m - powers[i] - additionalPower) {\\n                        return false;\\n                    }\\n                    const ll stationsRequired = m - powers[i] - additionalPower;\\n                    if (i + 2 * r + 1 < n) {\\n                        events[i + 2 * r + 1] += stationsRequired;\\n                        additionalPower += stationsRequired;\\n                        stationsAvailable -= stationsRequired;\\n                    }\\n                } \\n            }\\n            return true;\\n        };\\n        ll left = 0, right = 1\\'000\\'000\\'000\\'000\\'000\\'000l;\\n        while (left + 1 < right) {\\n            const auto m = (left + right) / 2;\\n            if (check(m)) {\\n                left = m;\\n            }\\n            else {\\n                right = m;\\n            }\\n        }\\n        return check(right) ? right : left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015151,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        N=len(stations)\\n        prefix=[0]\\n        for x in stations:\\n            prefix.append(prefix[-1]+x)\\n            \\n        def good(target):\\n            curr=0\\n            added=0\\n            q=collections.deque()\\n            \\n            for i in range(N):\\n                while len(q)>0 and q[0][0]<i:\\n                    _,t=q.popleft()\\n                    curr-=t\\n                    \\n                mn=i-r\\n                if mn<0:\\n                    mn=0\\n                \\n                mx=i+r\\n                if mx>=N:\\n                    mx=N-1\\n                    \\n                    \\n                now=prefix[mx+1]-prefix[mn]+curr\\n                \\n                if now<=target:\\n                    delta=target-now\\n                    added+=delta\\n                    curr+=delta\\n                    q.append((i+r+r,delta))\\n                    \\n                if added>k:\\n                    return False\\n                \\n            return added<=k\\n        left=0\\n        right=10**20\\n        while left<right:\\n            mid=(left+right+1)//2\\n            if good(mid):\\n                left=mid\\n                \\n            else:\\n                right=mid-1\\n                \\n        return left        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        N=len(stations)\\n        prefix=[0]\\n        for x in stations:\\n            prefix.append(prefix[-1]+x)\\n            \\n        def good(target):\\n            curr=0\\n            added=0\\n            q=collections.deque()\\n            \\n            for i in range(N):\\n                while len(q)>0 and q[0][0]<i:\\n                    _,t=q.popleft()\\n                    curr-=t\\n                    \\n                mn=i-r\\n                if mn<0:\\n                    mn=0\\n                \\n                mx=i+r\\n                if mx>=N:\\n                    mx=N-1\\n                    \\n                    \\n                now=prefix[mx+1]-prefix[mn]+curr\\n                \\n                if now<=target:\\n                    delta=target-now\\n                    added+=delta\\n                    curr+=delta\\n                    q.append((i+r+r,delta))\\n                    \\n                if added>k:\\n                    return False\\n                \\n            return added<=k\\n        left=0\\n        right=10**20\\n        while left<right:\\n            mid=(left+right+1)//2\\n            if good(mid):\\n                left=mid\\n                \\n            else:\\n                right=mid-1\\n                \\n        return left        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015147,
                "title": "python-binary-search-for-maximum-minimum-power-explained-the-best",
                "content": "# Intuition\\nOnce per-city power has been computed, we can determine in linear time whether a given minimum power can be sustained. Thus, binary search for such maximum minimum power.\\n\\nThe Best!\\n\\n# Approach\\nCompute per-city power by accumulating sums over the stations array. To determine if given minimum power can be sustained, maintain a queue of last power stations that contribute power to cities being iterated over.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log P)$$ where $$P=k+\\\\sum p_i$$ is maximal power that needs to be considered\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```py\\ndef maxPower(self, stations: list[int], r: int, k: int) -> int:\\n    def is_not_enough(mp):\\n        cur_k, last, lastsum = k, collections.deque(), 0\\n        for i, p in enumerate(power):\\n            while last and i-last[0][0] > r:\\n                lastsum -= last[0][1]\\n                last.popleft()\\n            p += lastsum\\n            if p < mp:\\n                lastsum, cur_k = lastsum + mp-p, cur_k - (mp-p)\\n                if cur_k < 0:\\n                    return True\\n                last.append((i+r, mp-p))\\n        return False\\n    n = len(stations)\\n    acc_power = list(itertools.accumulate([0] + stations + [0]))\\n    power = [acc_power[min(i+1+r, n+1)] - acc_power[max(i-r, 0)] for i in range(n)]\\n    min_power = min(power)\\n    return bisect.bisect(range(min_power+1, acc_power[-1]+k+1), False, key=is_not_enough) + min_power\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\ndef maxPower(self, stations: list[int], r: int, k: int) -> int:\\n    def is_not_enough(mp):\\n        cur_k, last, lastsum = k, collections.deque(), 0\\n        for i, p in enumerate(power):\\n            while last and i-last[0][0] > r:\\n                lastsum -= last[0][1]\\n                last.popleft()\\n            p += lastsum\\n            if p < mp:\\n                lastsum, cur_k = lastsum + mp-p, cur_k - (mp-p)\\n                if cur_k < 0:\\n                    return True\\n                last.append((i+r, mp-p))\\n        return False\\n    n = len(stations)\\n    acc_power = list(itertools.accumulate([0] + stations + [0]))\\n    power = [acc_power[min(i+1+r, n+1)] - acc_power[max(i-r, 0)] for i in range(n)]\\n    min_power = min(power)\\n    return bisect.bisect(range(min_power+1, acc_power[-1]+k+1), False, key=is_not_enough) + min_power\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1746726,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746619,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1749259,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1748809,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746696,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1752074,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1751093,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746633,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746599,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746497,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746726,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746619,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1749259,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1748809,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746696,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1752074,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1751093,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746633,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746599,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            },
            {
                "id": 1746497,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "This is XXXtra hard"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Probably one of the hardest problem on binary search I feel, figured out it was prefix sum+binary search during contest itself, but was not able to implement"
                    },
                    {
                        "username": "kenchan0824",
                        "content": "Me too. It has the greedy element too, I could not figure out this  part during the contest."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "Its actually not that hard if you have solve questions similar to aggressive cows. You don't necessarily need to do prefix sum or anything. I did it using sliding window to keep track of cur_power for each city. You can look at my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/) here."
                    },
                    {
                        "username": "Tensor08",
                        "content": "Can someone explain that why\\n [2,10,12,3]\\n0\\n14\\nshould return 9?"
                    },
                    {
                        "username": "MantisPraying",
                        "content": "As the range is 0, the stations can only provide power to that particular city.\\nPower of the city with minimum power has to be maximized.\\nIf we build a station in city 0 (idx=0), the Array will become [3,10,12,3]\\nNow there are 2 cities with min power, and we can build 13 new stations.\\nIf we divide 13 stations in 2 we will get 7+6, so one of the cities with 3 stations will only get 6 new stations. 3+6=9, hence the answer."
                    },
                    {
                        "username": "saam_neu",
                        "content": "What will be the brute force solution and how to know binary search is needed because the stations aren\\'t sorted and if anyone hasn\\'t solved the aggressive cow problem."
                    },
                    {
                        "username": "Aquanox",
                        "content": "Descent problem, rest of the contest = boring"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "miss Makima \\uD83E\\uDD70"
                    },
                    {
                        "username": "yashtomar208",
                        "content": "bro how can i get classes from u ?"
                    },
                    {
                        "username": "Algebros",
                        "content": "I really love such problems based on standard binary search where the logic needs to be applied only in the checker function. I knew exactly what was needed to be done but dont know why , found it a bit hard to implement.  Overall a good bs  problem. "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "I\\'ve never deal with that type of problems and it\\'s was really hard for me. I\\'ve tried my own solution and got timeout, optimized it and timeout again, and again...\\n\\nSolution with binary search has blown my mind."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I did it using sliding window + binary search. Here\\'s my [solution](https://leetcode.com/problems/maximize-the-minimum-powered-city/solutions/3015105/python3-binary-search-sliding-window-o-nlogn/)"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "can someone tell me why [4,2] r=1 k=1 should return 7 ? "
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "[@Finesse](/Finesse) thanks you bro!"
                    },
                    {
                        "username": "rayanfadhlaoui",
                        "content": "[@Finesse](/Finesse)  thanks !"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially both cities get 6 of power (4 + 2). If you add a new station to any city, both cities will get 7 of power."
                    },
                    {
                        "username": "RealFan",
                        "content": "Right bound of binary search should be sum instead of the max. "
                    },
                    {
                        "username": "smurf69",
                        "content": "why it isnt working"
                    }
                ]
            }
        ]
    }
]