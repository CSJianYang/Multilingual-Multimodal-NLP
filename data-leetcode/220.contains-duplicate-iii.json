[
    {
        "title": "Contains Duplicate III",
        "question_content": "You are given an integer array nums and two integers indexDiff and valueDiff.\nFind a pair of indices (i, j) such that:\n\n\ti != j,\n\tabs(i - j) <= indexDiff.\n\tabs(nums[i] - nums[j]) <= valueDiff, and\n\nReturn true if such pair exists or false otherwise.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\n\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 105\n\t-109 <= nums[i] <= 109\n\t1 <= indexDiff <= nums.length\n\t0 <= valueDiff <= 109",
        "solutions": [
            {
                "id": 61645,
                "title": "ac-o-n-solution-in-java-using-buckets-with-explanation",
                "content": "As a followup question, it naturally also requires maintaining a window of size k. When t == 0, it reduces to the previous question so we just reuse the solution.\\n\\nSince there is now a constraint on the range of the values of the elements to be considered duplicates, it reminds us of doing a range check which is implemented in tree data structure and would take O(LogN) if a balanced tree structure is used, or doing a bucket check which is constant time. We shall just discuss the idea using bucket here.\\n\\nBucketing means we map a range of values to the a bucket. For example, if the bucket size is 3, we consider 0, 1, 2 all map to the same bucket. However, if t == 3, (0, 3) is a considered duplicates but does not map to the same bucket. This is fine since we are checking the buckets immediately before and after as well. So, as a rule of thumb, just make sure the size of the bucket is reasonable such that elements having the same bucket is immediately considered duplicates or duplicates must lie within adjacent buckets. So this actually gives us a range of possible bucket size, i.e. t and t + 1. We just choose it to be t and a bucket mapping to be *num / t*.\\n\\nAnother complication is that negative ints are allowed. A simple *num / t* just shrinks everything towards 0. Therefore, we can just reposition every element to start from Integer.MIN_VALUE.\\n\\n     public class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (k < 1 || t < 0) return false;\\n            Map<Long, Long> map = new HashMap<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n                long bucket = remappedNum / ((long) t + 1);\\n                if (map.containsKey(bucket)\\n                        || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\\n                            || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\\n                                return true;\\n                if (map.entrySet().size() >= k) {\\n                    long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\\n                    map.remove(lastBucket);\\n                }\\n                map.put(bucket, remappedNum);\\n            }\\n            return false;\\n        }\\n    }\\n\\nEdits:\\n\\nActually, we can use t + 1 as the bucket size to get rid of the case when t == 0. It simplifies the code. The above code is therefore the updated version.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (k < 1 || t < 0) return false;\\n            Map<Long, Long> map = new HashMap<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n                long bucket = remappedNum / ((long) t + 1);\\n                if (map.containsKey(bucket)\\n                        || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\\n                            || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\\n                                return true;\\n                if (map.entrySet().size() >= k) {\\n                    long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\\n                    map.remove(lastBucket);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61639,
                "title": "java-python-one-pass-solution-o-n-time-o-n-space-using-buckets",
                "content": "The idea is like the bucket sort algorithm. Suppose we have consecutive buckets covering the range of nums with each bucket a width of (t+1). If there are two item with difference <= t, one of the two will happen:\\n\\n    (1) the two in the same bucket\\n    (2) the two in neighbor buckets\\n\\nFor detailed explanation see my blog [here](http://algobox.org/contains-duplicate-iii/)\\n\\n**Python**\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if t < 0: return False\\n        n = len(nums)\\n        d = {}\\n        w = t + 1\\n        for i in xrange(n):\\n            m = nums[i] / w\\n            if m in d:\\n                return True\\n            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\\n                return True\\n            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\\n                return True\\n            d[m] = nums[i]\\n            if i >= k: del d[nums[i - k] / w]\\n        return False\\n\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 93.81%\\n\\n\\n**Java**\\n\\n    private long getID(long i, long w) {\\n        return i < 0 ? (i + 1) / w - 1 : i / w;\\n    }\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        Map<Long, Long> d = new HashMap<>();\\n        long w = (long)t + 1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            long m = getID(nums[i], w);\\n            if (d.containsKey(m))\\n                return true;\\n            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)\\n                return true;\\n            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)\\n                return true;\\n            d.put(m, (long)nums[i]);\\n            if (i >= k) d.remove(getID(nums[i - k], w));\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "The idea is like the bucket sort algorithm. Suppose we have consecutive buckets covering the range of nums with each bucket a width of (t+1). If there are two item with difference <= t, one of the two will happen:\\n\\n    (1) the two in the same bucket\\n    (2) the two in neighbor buckets\\n\\nFor detailed explanation see my blog [here](http://algobox.org/contains-duplicate-iii/)\\n\\n**Python**\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if t < 0: return False\\n        n = len(nums)\\n        d = {}\\n        w = t + 1\\n        for i in xrange(n):\\n            m = nums[i] / w\\n            if m in d:\\n                return True\\n            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\\n                return True\\n            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\\n                return True\\n            d[m] = nums[i]\\n            if i >= k: del d[nums[i - k] / w]\\n        return False\\n\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 93.81%\\n\\n\\n**Java**\\n\\n    private long getID(long i, long w) {\\n        return i < 0 ? (i + 1) / w - 1 : i / w;\\n    }\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        Map<Long, Long> d = new HashMap<>();\\n        long w = (long)t + 1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            long m = getID(nums[i], w);\\n            if (d.containsKey(m))\\n                return true;\\n            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)\\n                return true;\\n            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)\\n                return true;\\n            d.put(m, (long)nums[i]);\\n            if (i >= k) d.remove(getID(nums[i - k], w));\\n        }\\n        return false;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 824578,
                "title": "c-o-n-time-complexity-explained-buckets-o-k-space-complexity",
                "content": "**Explanation**\\n\\nWe use the concept of sliding window and buckets together to achieve an optimal solution with O(N) time complexity.\\n\\nSliding window ensures only those indices are considered whose the absolute difference is at most k. We only consider k indices at a time. This fulfills the second condition.\\n\\nBuckets are used to ensure that the absolute difference between two numbers is at most t. Let\\'s take a deeper look at them.\\nWe (floor) divide each number by t+1 and put it in a bucket with key as the quotient.\\nFor example,\\n\\n```\\n[1,5,2,4,3,9,1,5,9], k = 2, t = 3\\n\\n1 // (3+1) = 0\\n5 // (3+1) = 1\\n2 // (3+1) = 0\\n4 // (3+1) = 1\\n3 // (3+1) = 0\\n9 // (3+1) = 2\\n\\nHere, Bucket[0] will contain numbers 0,1,2,3.\\nBucket[1] will contain numbers 4,5,6,7.\\nBucket[2] will contain numbers 8,9,10,11.\\n\\nOn observing carefully, we can see that the absolute difference\\nbetween any two numbers in any bucket is at most t, which is what we want.\\n\\nAlso, there can be a case where the neighbouring bucket has some number\\nwhose absolute difference with a number in the current bucket is at most t.\\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too.\\n```\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n = nums.size();\\n        \\n        if(n == 0 || k < 0  || t < 0) return false;\\n        \\n        unordered_map<int,int> buckets;\\n        \\n        for(int i=0; i<n; ++i) {\\n            int bucket = nums[i] / ((long)t + 1);\\n            \\n\\t\\t\\t// For negative numbers, we need to decrement bucket by 1\\n\\t\\t\\t// to ensure floor division.\\n\\t\\t\\t// For example, -1/2 = 0 but -1 should be put in Bucket[-1].\\n\\t\\t\\t// Therefore, decrement by 1.\\n            if(nums[i] < 0) --bucket;\\n            \\n            if(buckets.find(bucket) != buckets.end()) return true;\\n            else {\\n                buckets[bucket] = nums[i];\\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\\n                \\n                if(buckets.size() > k) {\\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\\n                    \\n                    if(nums[i-k] < 0) --key_to_remove;\\n                    \\n                    buckets.erase(key_to_remove);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nIf you have any questions, feel free to ask. If you like the solution and explanation, please **Upvote** to help others!\\nHave a great day!\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n[1,5,2,4,3,9,1,5,9], k = 2, t = 3\\n\\n1 // (3+1) = 0\\n5 // (3+1) = 1\\n2 // (3+1) = 0\\n4 // (3+1) = 1\\n3 // (3+1) = 0\\n9 // (3+1) = 2\\n\\nHere, Bucket[0] will contain numbers 0,1,2,3.\\nBucket[1] will contain numbers 4,5,6,7.\\nBucket[2] will contain numbers 8,9,10,11.\\n\\nOn observing carefully, we can see that the absolute difference\\nbetween any two numbers in any bucket is at most t, which is what we want.\\n\\nAlso, there can be a case where the neighbouring bucket has some number\\nwhose absolute difference with a number in the current bucket is at most t.\\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too.\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n = nums.size();\\n        \\n        if(n == 0 || k < 0  || t < 0) return false;\\n        \\n        unordered_map<int,int> buckets;\\n        \\n        for(int i=0; i<n; ++i) {\\n            int bucket = nums[i] / ((long)t + 1);\\n            \\n\\t\\t\\t// For negative numbers, we need to decrement bucket by 1\\n\\t\\t\\t// to ensure floor division.\\n\\t\\t\\t// For example, -1/2 = 0 but -1 should be put in Bucket[-1].\\n\\t\\t\\t// Therefore, decrement by 1.\\n            if(nums[i] < 0) --bucket;\\n            \\n            if(buckets.find(bucket) != buckets.end()) return true;\\n            else {\\n                buckets[bucket] = nums[i];\\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\\n                \\n                if(buckets.size() > k) {\\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\\n                    \\n                    if(nums[i-k] < 0) --key_to_remove;\\n                    \\n                    buckets.erase(key_to_remove);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61655,
                "title": "java-o-n-lg-k-solution",
                "content": "This problem requires to maintain a window of size k of the previous values that can be queried for value ranges. The best data structure to do that is Binary Search Tree. As a result maintaining the tree of size k will result in time complexity O(N lg K). In order to check if there exists any value of range abs(nums[i] - nums[j]) to simple queries can be executed both of time complexity O(lg K)\\n\\nHere is the whole solution using TreeMap.\\n\\n----------\\n\\n    public class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (nums == null || nums.length == 0 || k <= 0) {\\n                return false;\\n            }\\n    \\n            final TreeSet<Integer> values = new TreeSet<>();\\n            for (int ind = 0; ind < nums.length; ind++) {\\n    \\n                final Integer floor = values.floor(nums[ind] + t);\\n                final Integer ceil = values.ceiling(nums[ind] - t);\\n                if ((floor != null && floor >= nums[ind])\\n                        || (ceil != null && ceil <= nums[ind])) {\\n                    return true;\\n                }\\n    \\n                values.add(nums[ind]);\\n                if (ind >= k) {\\n                    values.remove(nums[ind - k]);\\n                }\\n            }\\n    \\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (nums == null || nums.length == 0 || k <= 0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61641,
                "title": "c-using-set-less-10-lines-with-simple-explanation",
                "content": "     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        set<int> window; // set is ordered automatically \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k\\n            // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;\\n            auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t \\n            // x - nums[i] <= t ==> |x - nums[i]| <= t    \\n            if (pos != window.end() && *pos - nums[i] <= t) return true;\\n            window.insert(nums[i]);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        set<int> window; // set is ordered automatically \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k\\n            // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;\\n            auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t \\n            // x - nums[i] <= t ==> |x - nums[i]| <= t    \\n            if (pos != window.end() && *pos - nums[i] <= t) return true;\\n            window.insert(nums[i]);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 824603,
                "title": "python-sortedlist-o-n-log-k-solution-explained",
                "content": "In my opinion it is more like **hard** problem, because brute-force solution will get you TLE and all other solutions uses some not easy trick: either heaps or BST or bucket sort. If you know some other solution without these ideas, please let me know!\\n\\nIn this problem we need to iterate over window of size `k+1` and check if there is numbers with difference `<=t` in this window. What we need to do efficiently is to add and remove elements from our window, and my choice of data structure is BST, which is implemented in `SortedList` in python. So on each step we have sorted list of elements in this window. Imagine the case:\\n\\n`[1, 3, 7, 12]` and new number we need to insert is `10`, and `t = 2`. Then we need to consider range `[8,12]` and check if we have numbers in our `SList` in this range. We can do two binary searches here: `bisect_left` for left boundary and `bisect_right` for right boundary. Also we need to check if `pos1 != len(SList)`, if this is the case, it means that new number is bigger than bigges number in list + `t`, so in this case we just put it directly to our list. If `pos1 != pos2`, this means, that we found some number i our `[nums[i] - t, nums[i] + t]` range, so we immediatly return `True`.\\n\\n**Complexity**: time complexity is `O(n log k)`, because we do `n` steps, each one with `O(log k)` complexity to do binary search, remove and add elements. Space complexity is `O(k)` to keep our `SortedList` updated.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        SList = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: SList.remove(nums[i-k-1])   \\n            pos1 = SortedList.bisect_left(SList, nums[i] - t)\\n            pos2 = SortedList.bisect_right(SList, nums[i] + t)\\n            \\n            if pos1 != pos2 and pos1 != len(SList): return True\\n            \\n            SList.add(nums[i])\\n        \\n        return False\\n```\\n\\n**PS** because of time complexity `O(n log k)`, this solution will not be on top, there is `O(n)` bucket sort solution, but in my opinion it is for certain hard level.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        SList = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: SList.remove(nums[i-k-1])   \\n            pos1 = SortedList.bisect_left(SList, nums[i] - t)\\n            pos2 = SortedList.bisect_right(SList, nums[i] + t)\\n            \\n            if pos1 != pos2 and pos1 != len(SList): return True\\n            \\n            SList.add(nums[i])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174416,
                "title": "python-balanced-bst-solution",
                "content": "This solution is slow compared to other Python solutions because it uses balanced BST, and time complexity is O(n log k), while solutions using buckets are O(n). I am posting this because I don\\'t see anyone posting the BST solution.\\n\\n```\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.height = 1\\n\\n\\nclass AVLTree(object):\\n    def __init__(self):\\n        self.root = None\\n        self.size = 0\\n        \\n\\t\\t\\t\\t\\n    def height(self, node):\\n        if node:\\n            return node.height\\n        return 0\\n    \\n\\t\\t\\n    def setHeight(self, node):\\n        if node is None:\\n            return 0\\n        return 1 + max(self.height(node.left), self.height(node.right))\\n    \\n\\t\\t\\n    def rightRotate(self, node):\\n        new_root = node.left\\n        node.left = node.left.right\\n        new_root.right = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n    \\n    \\n    def leftRotate(self, node):\\n        new_root = node.right\\n        node.right = node.right.left\\n        new_root.left = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n        \\n    \\n    def insert(self, node, val):\\n        if node == self.root:\\n            self.size += 1\\n        # Returns a Node pointing to updated subtree\\n        if node is None:\\n            return Node(val)\\n        if node.val < val:\\n            node.right = self.insert(node.right, val)\\n        else:\\n            node.left = self.insert(node.left, val)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def getMinValNode(self, node):\\n        if node is None or node.left is None:\\n            return node\\n        return self.getMinValNode(node.left)\\n    \\n\\t\\t\\n    def remove(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val < val:\\n            node.right = self.remove(node.right, val)\\n        elif node.val > val:\\n            node.left = self.remove(node.left, val)\\n        else:\\n            if node.left is None:\\n                return node.right\\n            elif node.right is None:\\n                return node.left\\n            else:\\n                right_min_val_node = self.getMinValNode(node.right)\\n                node.val = right_min_val_node.val\\n                node.right = self.remove(node.right, right_min_val_node.val)\\n        \\n        node.height = self.setHeight(node)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def predecessor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val > val:\\n            return self.predecessor(node.left, val)\\n        else:\\n            right_res = self.predecessor(node.right, val)\\n            return right_res if right_res else node.val    \\n            \\n\\t\\t\\t\\t\\t\\t\\n    def successor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val < val:\\n            return self.successor(node.right, val)\\n        else:\\n            left_res = self.successor(node.left, val)\\n            return left_res if left_res else node.val\\n    \\n\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        avltree = AVLTree()\\n        root = avltree.root\\n        for i, num in enumerate(nums):            \\n            predecessor = avltree.predecessor(root, num)\\n            if predecessor is not None and abs(predecessor - num) <= t:\\n                return True\\n            successor = avltree.successor(root, num)\\n            if successor is not None and abs(successor - num) <= t:\\n                return True\\n                        \\n            root = avltree.insert(root, num)\\n            \\n            if avltree.size > k:\\n                root = avltree.remove(root, nums[i-k])\\n                \\n        return False\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.height = 1\\n\\n\\nclass AVLTree(object):\\n    def __init__(self):\\n        self.root = None\\n        self.size = 0\\n        \\n\\t\\t\\t\\t\\n    def height(self, node):\\n        if node:\\n            return node.height\\n        return 0\\n    \\n\\t\\t\\n    def setHeight(self, node):\\n        if node is None:\\n            return 0\\n        return 1 + max(self.height(node.left), self.height(node.right))\\n    \\n\\t\\t\\n    def rightRotate(self, node):\\n        new_root = node.left\\n        node.left = node.left.right\\n        new_root.right = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n    \\n    \\n    def leftRotate(self, node):\\n        new_root = node.right\\n        node.right = node.right.left\\n        new_root.left = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n        \\n    \\n    def insert(self, node, val):\\n        if node == self.root:\\n            self.size += 1\\n        # Returns a Node pointing to updated subtree\\n        if node is None:\\n            return Node(val)\\n        if node.val < val:\\n            node.right = self.insert(node.right, val)\\n        else:\\n            node.left = self.insert(node.left, val)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def getMinValNode(self, node):\\n        if node is None or node.left is None:\\n            return node\\n        return self.getMinValNode(node.left)\\n    \\n\\t\\t\\n    def remove(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val < val:\\n            node.right = self.remove(node.right, val)\\n        elif node.val > val:\\n            node.left = self.remove(node.left, val)\\n        else:\\n            if node.left is None:\\n                return node.right\\n            elif node.right is None:\\n                return node.left\\n            else:\\n                right_min_val_node = self.getMinValNode(node.right)\\n                node.val = right_min_val_node.val\\n                node.right = self.remove(node.right, right_min_val_node.val)\\n        \\n        node.height = self.setHeight(node)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def predecessor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val > val:\\n            return self.predecessor(node.left, val)\\n        else:\\n            right_res = self.predecessor(node.right, val)\\n            return right_res if right_res else node.val    \\n            \\n\\t\\t\\t\\t\\t\\t\\n    def successor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val < val:\\n            return self.successor(node.right, val)\\n        else:\\n            left_res = self.successor(node.left, val)\\n            return left_res if left_res else node.val\\n    \\n\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        avltree = AVLTree()\\n        root = avltree.root\\n        for i, num in enumerate(nums):            \\n            predecessor = avltree.predecessor(root, num)\\n            if predecessor is not None and abs(predecessor - num) <= t:\\n                return True\\n            successor = avltree.successor(root, num)\\n            if successor is not None and abs(successor - num) <= t:\\n                return True\\n                        \\n            root = avltree.insert(root, num)\\n            \\n            if avltree.size > k:\\n                root = avltree.remove(root, nums[i-k])\\n                \\n        return False\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 61731,
                "title": "o-n-python-using-buckets-with-explanation-10-lines",
                "content": "    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # Bucket sort. Each bucket has size of t. For each number, the possible\\n        # candidate can only be in the same bucket or the two buckets besides.\\n        # Keep as many as k buckets to ensure that the difference is at most k.\\n        buckets = {}\\n        for i, v in enumerate(nums):\\n            # t == 0 is a special case where we only have to check the bucket\\n            # that v is in.\\n            bucketNum, offset = (v / t, 1) if t else (v, 0)\\n            for idx in xrange(bucketNum - offset, bucketNum + offset + 1):\\n                if idx in buckets and abs(buckets[idx] - nums[i]) <= t:\\n                    return True\\n\\n            buckets[bucketNum] = nums[i]\\n            if len(buckets) > k:\\n                # Remove the bucket which is too far away. Beware of zero t.\\n                del buckets[nums[i - k] / t if t else nums[i - k]]\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # Bucket sort. Each bucket has size of t. For each number, the possible\\n        # candidate can only be in the same bucket or the two buckets besides.\\n        # Keep as many as k buckets to ensure that the difference is at most k.\\n        buckets = {}\\n        for i, v in enumerate(nums):\\n            # t == 0 is a special case where we only have to check the bucket\\n            # that v is in.\\n            bucketNum, offset = (v / t, 1) if t else (v, 0)\\n            for idx in xrange(bucketNum - offset, bucketNum + offset + 1):\\n                if idx in buckets and abs(buckets[idx] - nums[i]) <= t:\\n                    return True\\n\\n            buckets[bucketNum] = nums[i]\\n            if len(buckets) > k:\\n                # Remove the bucket which is too far away. Beware of zero t.\\n                del buckets[nums[i - k] / t if t else nums[i - k]]\\n\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 61756,
                "title": "python-ordereddict",
                "content": "    class Solution:\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 1 or t < 0:\\n            return False\\n        dic = collections.OrderedDict()\\n        for n in nums:\\n            key = n if not t else n // t\\n            for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)):\\n                if m is not None and abs(n - m) <= t:\\n                    return True\\n            if len(dic) == k:\\n                dic.popitem(False)\\n            dic[key] = n\\n        return False",
                "solutionTags": [],
                "code": "    class Solution:\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 1 or t < 0:\\n            return False\\n        dic = collections.OrderedDict()\\n        for n in nums:\\n            key = n if not t else n // t\\n            for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)):\\n                if m is not None and abs(n - m) <= t:\\n                    return True\\n            if len(dic) == k:\\n                dic.popitem(False)\\n            dic[key] = n\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 61676,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Contains Duplicate III** https://leetcode.com/problems/contains-duplicate-iii/\\n\\n**Brute Force Solution**\\n* Brute force solution is use two loops and test both the conditions. The inner loop starts from i+1 to i+k. Because of that, we no longer need to test one of the conditions since that is taken care of automatically.\\n* Time complexity : O(n * k). \\n\\n```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(0, len(nums)):\\n            for j in range(i+1, i+k+1):\\n                if j < len(nums):\\n                    if abs(nums[i]-nums[j]) <= t:\\n                        return True\\n        return False\\n```\\n\\n**Binary Search Tree Solution**\\n* Maintain a BST of previous k elements. This is the invariant for this problem!\\n* When you get element x, we want to find an element y in the BST such that (y-x)<=t or (x-y)<=t\\n* How do we find (y-x)<=t ? Solution: Find the smallest value in the BST greater than or equal to x i.e. ceiling of x. Then test that value for the above condition.If the smallest value greater than x doesnt meet the criterion, then no other value y greater than x will meet the condition. One may consider the smallest element y that is greater or equal to x as the successor of x in the BST, as in: \"What is the next greater value of x?\"\\n* How do we find (x-y)<=t? Find the greatest element y in the BST which is smaller than or equal to x. Again if this y doesnt meet the condition, no other y in the BST will meet the condition. We consider the greatest element y that is smaller or equal to x as the predecessor of x in the BST, as in: \"What is the previous smaller value of x?\\n* Visualize or imagine this as x and its two closest neighbors.\\n* After trying the above tests, if they fail, then put x in set\\n* If the size of the set is larger than k, remove the oldest item - this maintains the invariant.\\n* Time complexity : O(n * log (min(n,k))). Space complexity: O(min(n,k))\\n\\n**Buckets Method**\\n* Maintain buckets each of size t+1 holding the last k elements. This is the invariant.\\n* Buckets are [0, t], [t+1,2t+1], [2t+2, 3t+2],....\\n* What are the conditions of a match? Either x lies in a bucket which already has a member (this directly means that x and this element are within t of each other). Or the two neighbors of around this bucket may have a potential match. Check the code for an explanation.\\n* Lastly we notice how we purge elements from the cache/buckets which are stale i.e. outside the window of k elements.\\n* Notice one more thing: -3//5 = -1 - Python does this automatically and hence we dont need any special magic for handling negative numbers.\\n\\n```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0:\\n            return False\\n        cache = {}\\n        for i in range(len(nums)):\\n            if i-k > 0:\\n                bucket_id_to_delete = nums[i-k-1]//(t+1)\\n                del cache[bucket_id_to_delete]\\n            bucket_id = nums[i]//(t+1)\\n            condition1 = (bucket_id in cache)\\n            condition2 = ((bucket_id-1 in cache and abs(cache[bucket_id-1]-nums[i])<= t))\\n            condition3 = ((bucket_id+1 in cache and abs(cache[bucket_id+1]-nums[i])<= t))\\n            if condition1 or condition2 or condition3:\\n                return True\\n            cache[bucket_id] = nums[i]\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(0, len(nums)):\\n            for j in range(i+1, i+k+1):\\n                if j < len(nums):\\n                    if abs(nums[i]-nums[j]) <= t:\\n                        return True\\n        return False\\n```\n```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0:\\n            return False\\n        cache = {}\\n        for i in range(len(nums)):\\n            if i-k > 0:\\n                bucket_id_to_delete = nums[i-k-1]//(t+1)\\n                del cache[bucket_id_to_delete]\\n            bucket_id = nums[i]//(t+1)\\n            condition1 = (bucket_id in cache)\\n            condition2 = ((bucket_id-1 in cache and abs(cache[bucket_id-1]-nums[i])<= t))\\n            condition3 = ((bucket_id+1 in cache and abs(cache[bucket_id+1]-nums[i])<= t))\\n            if condition1 or condition2 or condition3:\\n                return True\\n            cache[bucket_id] = nums[i]\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825267,
                "title": "python3-summarizing-contain-duplicates-i-ii-iii",
                "content": "This is a very self-consistent series. Although ad-hoc implementations exist (please check the corresponding posts in Dicuss), their solutions bear great resemblance to each other. \\n\\nStarting with [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/), the key is to memoize what has been seen in a set\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for x in nums:\\n            if x in seen: return True \\n            seen.add(x)\\n        return False\\n```\\n\\nProgressing to [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/), extra info needs to be memoized, i.e. position via a dictionary. \\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        for i, x in enumerate(nums): \\n            if x in seen and i - seen[x] <= k: return True \\n            seen[x] = i\\n        return False \\n```\\n\\nComing back to this problem, we can summarize numbers in a given range into bucket. By bucketing numbers properly, this becomes almost identical to 219. Contains Duplicate except that numbers in adjacent buckets need to be check as well. \\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t < 0: return False # edge case \\n        \\n        seen = {}\\n        for i, x in enumerate(nums): \\n            bkt = x//(t+1)\\n            if bkt in seen and i - seen[bkt][0] <= k: return True \\n            if bkt-1 in seen and i - seen[bkt-1][0] <= k and abs(x - seen[bkt-1][1]) <= t: return True \\n            if bkt+1 in seen and i - seen[bkt+1][0] <= k and abs(x - seen[bkt+1][1]) <= t: return True \\n            seen[bkt] = (i, x) \\n        return False \\n```\\n\\nAs mentioned in the beginning, ad-hoc implementations do exist. But these three questions can all be solved by properly memoizing certain info, which makes them quite consistent for practice.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for x in nums:\\n            if x in seen: return True \\n            seen.add(x)\\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        for i, x in enumerate(nums): \\n            if x in seen and i - seen[x] <= k: return True \\n            seen[x] = i\\n        return False \\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t < 0: return False # edge case \\n        \\n        seen = {}\\n        for i, x in enumerate(nums): \\n            bkt = x//(t+1)\\n            if bkt in seen and i - seen[bkt][0] <= k: return True \\n            if bkt-1 in seen and i - seen[bkt-1][0] <= k and abs(x - seen[bkt-1][1]) <= t: return True \\n            if bkt+1 in seen and i - seen[bkt+1][0] <= k and abs(x - seen[bkt+1][1]) <= t: return True \\n            seen[bkt] = (i, x) \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 61764,
                "title": "i-finally-got-ac-in-c",
                "content": "Using a set container to keep the k+1-length array,which all elements are distinct.Before the container's size reached k+1, we just find the first element that is not less than [nums[i]-t] and judge the element's value whether it is less than [nums[i]+t]. Starting to move forward by erasing the head and adding element at the backend after the container's size reached k+1. The existence of the first element ,which is not less than [nums[i]-t]  and less than [nums[i]+t], is the prerequisite of existing other eligible elements.\\n\\n     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t)\\n        {\\n        \\t\\tif (!k || t<0 || nums.size()<2)\\n            \\t\\treturn false;\\n            \\tset<int>record;                   \\n            \\tauto nLen = nums.size();\\n            \\tfor (int i = 0; i < nLen;++i)\\n            \\t{\\n            \\t\\tif (i>k)\\n            \\t\\t\\trecord.erase(nums[i - k - 1]);         \\n            \\t\\tset<int>::iterator lower = record.lower_bound(nums[i] - t);\\n            \\t\\tif (lower != record.end() && abs(nums[i] - *lower) <= t)\\n            \\t\\t\\treturn true;\\n            \\n            \\t\\trecord.insert(nums[i]);\\n            \\t}\\n            \\treturn false;\\n        }",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "Using a set container to keep the k+1-length array,which all elements are distinct.Before the container's size reached k+1, we just find the first element that is not less than [nums[i]-t] and judge the element's value whether it is less than [nums[i]+t]. Starting to move forward by erasing the head and adding element at the backend after the container's size reached k+1. The existence of the first element ,which is not less than [nums[i]-t]  and less than [nums[i]+t], is the prerequisite of existing other eligible elements.\\n\\n     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t)\\n        {\\n        \\t\\tif (!k || t<0 || nums.size()<2)\\n            \\t\\treturn false;\\n            \\tset<int>record;                   \\n            \\tauto nLen = nums.size();\\n            \\tfor (int i = 0; i < nLen;++i)\\n            \\t{\\n            \\t\\tif (i>k)\\n            \\t\\t\\trecord.erase(nums[i - k - 1]);         \\n            \\t\\tset<int>::iterator lower = record.lower_bound(nums[i] - t);\\n            \\t\\tif (lower != record.end() && abs(nums[i] - *lower) <= t)\\n            \\t\\t\\treturn true;\\n            \\n            \\t\\trecord.insert(nums[i]);\\n            \\t}\\n            \\treturn false;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 61774,
                "title": "accept-c-solution",
                "content": "My idea is to preserve a sliding window containing nearest k numbers, and check if next number collides to the numbers in the window.\\n\\n    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            if (nums.size() < 2 || k == 0)\\n                return false;\\n            deque<int> windows_deq;\\n            multiset<long> windows;\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (windows.size() > k) {\\n                    int num = windows_deq.front();\\n                    windows_deq.pop_front();\\n                    windows.erase(windows.find(num));\\n                }\\n                auto it = windows.lower_bound((long)nums[i] - (long)t);\\n                if (it == windows.end() || *it > (long)nums[i] + (long)t) {\\n                    // not found\\n                    windows_deq.push_back(nums[i]);\\n                    windows.insert(nums[i]);\\n                }\\n                else return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            if (nums.size() < 2 || k == 0)\\n                return false;\\n            deque<int> windows_deq;\\n            multiset<long> windows;\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (windows.size() > k) {\\n                    int num = windows_deq.front();\\n                    windows_deq.pop_front();\\n                    windows.erase(windows.find(num));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1500895,
                "title": "java-tc-o-n-sc-o-min-n-k-sliding-window-using-buckets",
                "content": "```java\\n/**\\n * Sliding Window solution using Buckets\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(min(N, K+1))\\n *\\n * N = Length of input array. K = Input difference between indexes.\\n */\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) {\\n            return false;\\n        }\\n\\n        HashMap<Long, Long> buckets = new HashMap<>();\\n        // The bucket size is t+1 as the ranges are from 0..t, t+1..2t+1, ..\\n        long bucketSize = (long) t + 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            // Making sure only K buckets exists in map.\\n            if (i > k) {\\n                long lastBucket = ((long) nums[i - k - 1] - Integer.MIN_VALUE) / bucketSize;\\n                buckets.remove(lastBucket);\\n            }\\n\\n            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n            long bucket = remappedNum / bucketSize;\\n\\n            // If 2 numbers belong to same bucket\\n            if (buckets.containsKey(bucket)) {\\n                return true;\\n            }\\n\\n            // If numbers are in adjacent buckets and the difference between them is at most\\n            // t.\\n            if (buckets.containsKey(bucket - 1) && remappedNum - buckets.get(bucket - 1) <= t) {\\n                return true;\\n            }\\n            if (buckets.containsKey(bucket + 1) && buckets.get(bucket + 1) - remappedNum <= t) {\\n                return true;\\n            }\\n\\n            buckets.put(bucket, remappedNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Contains Duplicate question on LeetCode:\\n- [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/discuss/1500880/Java-or-TC:-O(N)-or-SC:-O(N)-or-Clean-and-concise-solution-using-HashSet)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n\\n---\\n\\nSolutions to other Sliding Window questions on LeetCode:\\n- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/1496754/Java-or-TC:-O(S+T)-or-SC:-O(T)-or-Space-optimized-Sliding-Window-using-Two-Pointers)\\n- [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1496838/Java-or-TC:-O(N)-or-SC:-O(K)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1496840/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1500039/Java-or-TC:-O(S+P)-or-SC:-O(1)-or-Sliding-window-solution)\\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1500874/Java-or-TC:-O(N)-or-SC:-O(1)-or-Sliding-Window-using-HashMap-and-Two-Pointers)\\n- [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/1500877/Java-or-Both-O(N)-and-O(N-logN)-solutions-with-O(1)-space-or-Sliding-Window-and-Binary-Search-solutions)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/discuss/1500902/Java-or-TC:-O(S2)-or-SC:-O(1)-or-Constant-space-Sliding-Window-solution)\\n- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/1506048/Java-or-TC:-O(N)-or-SC:-O(K)-or-Using-Deque-as-Sliding-Window)\\n- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/discuss/1507981/Java-or-TC:-O(N*logK)-or-SC:-(K)-or-Optimized-sliding-window-using-TreeSet)\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```java\\n/**\\n * Sliding Window solution using Buckets\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(min(N, K+1))\\n *\\n * N = Length of input array. K = Input difference between indexes.\\n */\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) {\\n            return false;\\n        }\\n\\n        HashMap<Long, Long> buckets = new HashMap<>();\\n        // The bucket size is t+1 as the ranges are from 0..t, t+1..2t+1, ..\\n        long bucketSize = (long) t + 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            // Making sure only K buckets exists in map.\\n            if (i > k) {\\n                long lastBucket = ((long) nums[i - k - 1] - Integer.MIN_VALUE) / bucketSize;\\n                buckets.remove(lastBucket);\\n            }\\n\\n            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n            long bucket = remappedNum / bucketSize;\\n\\n            // If 2 numbers belong to same bucket\\n            if (buckets.containsKey(bucket)) {\\n                return true;\\n            }\\n\\n            // If numbers are in adjacent buckets and the difference between them is at most\\n            // t.\\n            if (buckets.containsKey(bucket - 1) && remappedNum - buckets.get(bucket - 1) <= t) {\\n                return true;\\n            }\\n            if (buckets.containsKey(bucket + 1) && buckets.get(bucket + 1) - remappedNum <= t) {\\n                return true;\\n            }\\n\\n            buckets.put(bucket, remappedNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61734,
                "title": "ac-java-solution-without-set-or-dictionary-sort-the-nums-and-record-the-positions",
                "content": "public class Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\tif(nums.length<2||k<1||t<0) return false;\\n    \\tValuePosPair[] valPosArr = new ValuePosPair[nums.length];\\n    \\tfor(int i =0;i<nums.length;i++) valPosArr[i] = new ValuePosPair(nums[i],i); \\n    \\tArrays.sort(valPosArr);\\t\\n    \\tfor(int i=0;i<valPosArr.length;i++){\\n    \\t\\tfor(int j=i+1;j<valPosArr.length&&((long)valPosArr[j].val-(long)valPosArr[i].val<=(long)t);j++){\\n    \\t\\t\\tif(Math.abs(valPosArr[j].pos-valPosArr[i].pos)<=k) return true;\\t\\n    \\t\\t}\\n    \\t}\\n    \\treturn false;\\n    }  \\n}\\n\\n    class ValuePosPair implements Comparable<ValuePosPair>{\\n    \\n    \\tint val;\\n    \\tint pos;\\n\\n    \\tValuePosPair(int v, int p) { val = v; pos = p;}\\n\\n    \\tpublic int compareTo(ValuePosPair x){\\n    \\t\\treturn this.val - x.val;\\n    \\t}\\t\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\tif(nums.length<2||k<1||t<0) return false;\\n    \\tValuePosPair[] valPosArr = new ValuePosPair[nums.length];\\n    \\tfor(int i =0;i<nums.length;i++) valPosArr[i] = new ValuePosPair(nums[i],i); \\n    \\tArrays.sort(valPosArr);\\t\\n    \\tfor(int i=0;i<valPosArr.length;i++){\\n    \\t\\tfor(int j=i+1;j<valPosArr.length&&((long)valPosArr[j].val-(long)valPosArr[i].val<=(long)t);j++){\\n    \\t\\t\\tif(Math.abs(valPosArr[j].pos-valPosArr[i].pos)<=k) return true;\\t\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 61662,
                "title": "java-treeset-implementation-nlogk",
                "content": "this is a very good demonstration of the use of TreeSet ---- which we rarely use normally. \\n\\n\\n\\n        public class Solution {\\n    \\n        public boolean containsNearbyAlmostDuplicate(final int[] nums, int kk, long t) {\\n            if (nums.length < 2) return false;\\n            if (kk == 0) return false;\\n            TreeSet<Long> window = new TreeSet<Long>();\\n            \\n            for(int i=0;i<nums.length;i++) {\\n    \\n                // check dup, window size <= kk right now\\n            \\tif ( window.floor(nums[i] + t) !=null && window.floor(nums[i]+t) >= nums[i]-t ) return true;\\n            \\t\\n                window.add(new Long(nums[i]));\\n                \\n                \\n                if (i >= kk) {\\n                    //remove one, the size has to be kk on the next fresh step\\n                \\twindow.remove(new Long(nums[i-kk]));\\n                }\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n        public boolean containsNearbyAlmostDuplicate(final int[] nums, int kk, long t) {\\n            if (nums.length < 2) return false;\\n            if (kk == 0) return false;\\n            TreeSet<Long> window = new TreeSet<Long>();\\n            \\n            for(int i=0;i<nums.length;i++) {\\n    \\n                // check dup, window size <= kk right now\\n            \\tif ( window.floor(nums[i] + t) !=null && window.floor(nums[i]+t) >= nums[i]-t ) return true;\\n            \\t\\n                window.add(new Long(nums[i]));\\n                \\n                \\n                if (i >= kk) {\\n                    //remove one, the size has to be kk on the next fresh step\\n                \\twindow.remove(new Long(nums[i-kk]));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61666,
                "title": "short-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            map<long long,int> M;\\n            int l=0;\\n            for (int r=0;r<nums.size();r++) {\\n                if (r-l>k && M[nums[l]]==l)\\n                    M.erase(nums[l++]);\\n                auto it=M.lower_bound(nums[r]-t);\\n                if (it!=M.end() && abs(it->first-nums[r])<=t)\\n                    return true;\\n                M[nums[r]]=r;\\n            }\\n            return false;\\n         }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            map<long long,int> M;\\n            int l=0;\\n            for (int r=0;r<nums.size();r++) {\\n                if (r-l>k && M[nums[l]]==l)\\n                    M.erase(nums[l++]);\\n                auto it=M.lower_bound(nums[r]-t);\\n                if (it!=M.end() && abs(it->first-nums[r])<=t)\\n                    return true;\\n                M[nums[r]]=r;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 825726,
                "title": "contains-duplicate-iii-best-theoretical-time-complexity-java",
                "content": "Note a few ideas that will help you understand this problem and make the optimal time complexity approach easier for you:\\n\\n* Consider the edge cases. What are the edge cases? What happens when the array is empty, singleton etc. And what about when ```k``` is 0? Consider edge cases that you know are unlikely to be included in a general solution, and take care of those cases right away.\\n* Then, you understand that for any element ```x```  in ```nums```, you\\'re actually looking for its partner. This partner element is at most ```k``` hops away from ```x```, and doesn\\'t differ from ```x``` by more than ```t```.\\n* So, if you happen to have ```k``` elements in your hand, and look at a ```(k + 1)th``` element, you ask \"does this ```(k + 1)th``` guy find a partner in the ```k``` I\\'m already holding on to?\" \\nIf not, well guess what? The oldest element in the ```k``` ones you have can no more find its partner so you can get rid of it and let ```(k + 1)th``` guy get in.\\n* For an example, let\\'s consider the first one given i.e. ```nums = [1,2,3,1] | k = 3 | t = 0```. \\n* Now, you\\'re holding on to the first ```k``` elements i.e. ```[1,2,3]```. Your supposed loop considers the next element i.e. ```[..., 1]```. Now if this ```1``` has a partner in ```[1,2,3]```, great, we\\'re done. But if not, then there\\'s no problem in throwing the first ```[1...]```, because well, all the elements you see now are going to be more than ```k``` hops away from him. So you end up with ```[2,3,1]```.\\n* That was the basic processing idea. \\n* Finally, you understand that upon processing each element ```x```, if the largest number smaller than ```x``` or the smallest number greater than ```x```, in the ```k``` elements you already have, produce something bounded by ```t```, you have an answer.\\n* Now it\\'s your turn to research what data structure can hold onto elements such that it can yeild a ceiling/floor relative to some number efficiently (clearly it will have to keep its elements in a sorted manner...) \\n* (P.S. think a bit about why ceiling/floor and not just max/min)\\n\\n```java\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        int len = nums.length;\\n        \\n        // return false when given parameters makes two distinct indices impossible \\n        if (len <= 1 || k <= 0) {\\n            return false;\\n        }\\n        \\n        /**\\n        * Important, question definition:\\n        *   Absolute diff between nums[i] and nums[j] <= t\\n        *   Absolute diff between indices i and j <= k\\n        **/\\n        \\n        TreeSet<Long> set = new TreeSet();\\n        for (int i = 0; i < nums.length; i++) {\\n            Long number = new Long(nums[i]);\\n            Long ceil = set.ceiling(number);\\n            Long floor = set.floor(number);\\n            \\n            if (ceil != null && ceil - number <= t) {\\n                return true;\\n            }\\n            \\n            if (floor != null && number - floor <= t) {\\n                return true;\\n            }\\n            \\n            set.add(number);\\n            if (set.size() > k) {\\n                Long oldest = new Long(nums[i - k]);\\n                set.remove(oldest);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```k```\n```x```\n```nums```\n```k```\n```x```\n```x```\n```t```\n```k```\n```(k + 1)th```\n```(k + 1)th```\n```k```\n```k```\n```(k + 1)th```\n```nums = [1,2,3,1] | k = 3 | t = 0```\n```k```\n```[1,2,3]```\n```[..., 1]```\n```1```\n```[1,2,3]```\n```[1...]```\n```k```\n```[2,3,1]```\n```x```\n```x```\n```x```\n```k```\n```t```",
                "codeTag": "Unknown"
            },
            {
                "id": 825606,
                "title": "python-3-official-solution-in-python-3-2-methods-explanation",
                "content": "Below is Python 3 version of official solution: https://leetcode.com/problems/contains-duplicate-iii/solution/\\n### Approach \\\\#1\\n- Omitted since it will TLE\\n\\n### Approach \\\\#2 \\n- The official Java solution used `TreeSet` as help, which provide the ability to maintain the order. At the same time it search and remove is relatively efficient. \\n- Python standard library doesn\\'t come with a data struction like `TreeSet`, but from library `sortedcontainers`, we can simulate the same process using `SortedSet` (`SortedList` should also work in this scenario).\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        from sortedcontainers import SortedSet\\n        if not nums or t < 0: return False     # Handle special cases\\n        ss, n = SortedSet(), 0                 # Create SortedSet. `n` is the size of sortedset, max value of `n` is `k` from input\\n        for i, num in enumerate(nums):\\n            ceiling_idx = ss.bisect_left(num)  # index whose value is greater than or equal to `num`\\n            floor_idx = ceiling_idx - 1        # index whose value is smaller than `num`\\n            if ceiling_idx < n and abs(ss[ceiling_idx]-num) <= t: return True  # check right neighbour \\n            if 0 <= floor_idx and abs(ss[floor_idx]-num) <= t: return True     # check left neighbour\\n            ss.add(num)\\n            n += 1\\n            if i - k >= 0:  # maintain the size of sortedset by finding & removing the earliest number in sortedset\\n                ss.remove(nums[i-k])\\n                n -= 1\\n        return False\\n```\\n### Approach \\\\#3 \\n- This is pretty much a re-write of the official Java version. \\n- But by using `defaultdict`, the code is cleaner (since we don\\'t have to check the existance of a key in dictionary).\\n- Use `OrderedDict` is also a feasible way, since it is more efficient to maintain the size\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or t < 0: return False\\n        min_val = min(nums)\\n        bucket_key = lambda x: (x-min_val) // (t+1)       # A lambda function generate buckey key given a value\\n        d = collections.defaultdict(lambda: sys.maxsize)  # A bucket simulated with defaultdict\\n        for i, num in enumerate(nums):\\n            key = bucket_key(num)                         # key for current number `num`\\n            for nei in [d[key-1], d[key], d[key+1]]:      # check left bucket, current bucket and right bucket\\n                if abs(nei - num) <= t: return True\\n            d[key] = num    \\n            if i >= k: d.pop(bucket_key(nums[i-k]))       # maintain a size of `k` \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        from sortedcontainers import SortedSet\\n        if not nums or t < 0: return False     # Handle special cases\\n        ss, n = SortedSet(), 0                 # Create SortedSet. `n` is the size of sortedset, max value of `n` is `k` from input\\n        for i, num in enumerate(nums):\\n            ceiling_idx = ss.bisect_left(num)  # index whose value is greater than or equal to `num`\\n            floor_idx = ceiling_idx - 1        # index whose value is smaller than `num`\\n            if ceiling_idx < n and abs(ss[ceiling_idx]-num) <= t: return True  # check right neighbour \\n            if 0 <= floor_idx and abs(ss[floor_idx]-num) <= t: return True     # check left neighbour\\n            ss.add(num)\\n            n += 1\\n            if i - k >= 0:  # maintain the size of sortedset by finding & removing the earliest number in sortedset\\n                ss.remove(nums[i-k])\\n                n -= 1\\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or t < 0: return False\\n        min_val = min(nums)\\n        bucket_key = lambda x: (x-min_val) // (t+1)       # A lambda function generate buckey key given a value\\n        d = collections.defaultdict(lambda: sys.maxsize)  # A bucket simulated with defaultdict\\n        for i, num in enumerate(nums):\\n            key = bucket_key(num)                         # key for current number `num`\\n            for nei in [d[key-1], d[key], d[key+1]]:      # check left bucket, current bucket and right bucket\\n                if abs(nei - num) <= t: return True\\n            d[key] = num    \\n            if i >= k: d.pop(bucket_key(nums[i-k]))       # maintain a size of `k` \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61742,
                "title": "cpp-solution-by-using-multiset-n-log-k",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            multiset<int> mySet;\\n            for(int i = 0; i<nums.size(); i++){\\n            \\tauto lb = mySet.lower_bound(nums[i]-t);\\n            \\t//lower_bound returns the iterator (the most near to value equals to nums[i] - t) , this is tricky\\n            \\tif(lb!=mySet.end() && *lb - nums[i]<=t) return true;\\n            \\tmySet.insert(nums[i]);\\n            \\tif(mySet.size()>k) mySet.erase(nums[i-k]);\\n    \\n            }\\n        return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            multiset<int> mySet;\\n            for(int i = 0; i<nums.size(); i++){\\n            \\tauto lb = mySet.lower_bound(nums[i]-t);\\n            \\t//lower_bound returns the iterator (the most near to value equals to nums[i] - t) , this is tricky\\n            \\tif(lb!=mySet.end() && *lb - nums[i]<=t) return true;\\n            \\tmySet.insert(nums[i]);\\n            \\tif(mySet.size()>k) mySet.erase(nums[i-k]);\\n    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61706,
                "title": "python-without-dictionary",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @param {integer} k\\n        # @param {integer} t\\n        # @return {boolean}\\n        def containsNearbyAlmostDuplicate(self, nums, k, t):\\n            ind = sorted(range(len(nums)), key = lambda x: nums[x])\\n            for i in range(len(nums)-1):\\n                j = i + 1\\n                while j < len(nums) and nums[ind[j]] - nums[ind[i]] <= t:\\n                    if abs(ind[i]-ind[j]) <= k:\\n                        return True\\n                    j += 1\\n            return False\\n\\nind is an array of the indexes of sorted num. Iterate through ind to check if nums are within t and ind are within k.",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 2570864,
                "title": "c-sliding-window-w-easy-explanation",
                "content": "**Sliding Window:**\\n1. Create a winodw (multiset) of size k+1(as index to index+k will come in set) and it will be sorted.           i = left of window, j=right of window\\n2. If diff of adjacent elements <= t \\n\\t\\t\\tthen return true;\\n    b/c adjacent elements will be the one with min diff in a sorted set\\n3. For any element its adjacent left & right will be just less & just greater to it respectively.\\n4. Before inserting the current element(curr) in window(multiset) we look for the upper bound of curr in pre-exisiting window (also to avoid the number itself to become its upper bound if inserted first and then checked for upper bound) \\n5. If upper bound is not the end of multiset means just greater element is present in set and if absolute difference of upper bound(just greater) and curr <= valueDifference then return true\\n6. If upper bound is not the beginning of multiset means there is also a lower bound exisiting for curr which will be at index upper_bound - 1. If absolute difference of lower bound(just smaller) and curr <= valueDifference then return true\\n7. Keep a check if window size = k+1 then remove the ith element and increment i (slide the window)\\n8. If after traversing whole vector no such two elements are found return false at last.\\n\\n**If it helped, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        int n = nums.size();\\n        multiset<int> ms;     //to store window elements in sorted order\\n        \\n\\t\\tint i=0, j=0;\\n        while(j<n)\\n        {\\n            auto up = ms.upper_bound(nums[j]);\\n            if((up != ms.end() and *up-nums[j] <= t) || (up != ms.begin() and nums[j] - *(--up) <= t))\\n                return true;\\n            ms.insert(nums[j]);\\n            \\n            if(ms.size() == k+1)\\n            {\\n                ms.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        int n = nums.size();\\n        multiset<int> ms;     //to store window elements in sorted order\\n        \\n\\t\\tint i=0, j=0;\\n        while(j<n)\\n        {\\n            auto up = ms.upper_bound(nums[j]);\\n            if((up != ms.end() and *up-nums[j] <= t) || (up != ms.begin() and nums[j] - *(--up) <= t))\\n                return true;\\n            ms.insert(nums[j]);\\n            \\n            if(ms.size() == k+1)\\n            {\\n                ms.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255877,
                "title": "who-gives-this-shit",
                "content": "what is this testcase really mean for?\\n\\n```\\n[-1,-1]\\n1\\n-1\\n```",
                "solutionTags": [],
                "code": "```\\n[-1,-1]\\n1\\n-1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61740,
                "title": "easy-ac-solution-using-treeset-long-in-java",
                "content": "\\n    public class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0) return false;\\n        TreeSet<Long> set = new TreeSet<>();\\n        set.add((long) nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > k) set.remove((long) nums[i - k - 1]);\\n            long left = (long) nums[i] - t;\\n            long right = (long) nums[i] + t;\\n            if (left <= right && !set.subSet(left, right + 1).isEmpty()) return true;\\n            set.add((long) nums[i]);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0) return false;\\n        TreeSet<Long> set = new TreeSet<>();\\n        set.add((long) nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > k) set.remove((long) nums[i - k - 1]);\\n            long left = (long) nums[i] - t;\\n            long right = (long) nums[i] + t;\\n            if (left <= right && !set.subSet(left, right + 1).isEmpty()) return true;\\n            set.add((long) nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 599885,
                "title": "python-bucket-sort-ordered-map-solution-beats-95-53-with-handwriting-explanation",
                "content": "**Time Complexity: O(n)**\\n\\nMedium blog [Here](https://medium.com/@yilingliu1994/the-application-of-bucket-sort-ordered-dict-leetcode-220-6f99d0eb375?postPublishedType=initial)\\n\\nCode:\\n```\\nimport collections\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 0 or t < 0:\\n            return False\\n        # example: set([1,1,2,3]) = {1,2,3}, length = 3 != 4, so there are duplicated numbers\\n        if t == 0:\\n            return len(set(nums)) != len(nums)\\n        bucket = collections.OrderedDict()\\n        b_size = t + 1\\n        for num in nums:\\n\\t\\t\\t# explanation in picture 1 and 2\\n            key = num//b_size\\n            if key in bucket:\\n                return True\\n            bucket[key] = num\\n\\t\\t\\t# end of picture 1 and 2\\n\\t\\t\\t# explanation in picture 3\\n            if key - 1 in bucket and num - bucket[key - 1] <= t:\\n                return True\\n            if key + 1 in bucket and bucket[key + 1] - num <= t:\\n                return True\\n\\t\\t\\t# end of picture 3\\n            # remove the first added key\\n            if len(bucket) > k:\\n                bucket.popitem(last = False)\\n        return False\\n```\\n\\nPicture 1:\\n![image](https://assets.leetcode.com/users/yilingliu/image_1587981434.png)\\n\\nPicture 2:\\n![image](https://assets.leetcode.com/users/yilingliu/image_1587981438.png)\\n\\nPicture 3:\\n![image](https://assets.leetcode.com/users/yilingliu/image_1587981976.png)\\n\\n\\nWhy use OrderedDict:\\n\\n```\\n\\'\\'\\'\\nOrderedDict.popitem(last: bool) -> Tuple[Unknown]\\nRemove and return a (key, value) pair from the dictionary.\\n\\nPairs are returned in LIFO order if last is true or FIFO order if false.\\n\\'\\'\\'\\n```\\n\\nSo if the dictionary is full and we need to move to the next element, the first element added to dict could be removed",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 0 or t < 0:\\n            return False\\n        # example: set([1,1,2,3]) = {1,2,3}, length = 3 != 4, so there are duplicated numbers\\n        if t == 0:\\n            return len(set(nums)) != len(nums)\\n        bucket = collections.OrderedDict()\\n        b_size = t + 1\\n        for num in nums:\\n\\t\\t\\t# explanation in picture 1 and 2\\n            key = num//b_size\\n            if key in bucket:\\n                return True\\n            bucket[key] = num\\n\\t\\t\\t# end of picture 1 and 2\\n\\t\\t\\t# explanation in picture 3\\n            if key - 1 in bucket and num - bucket[key - 1] <= t:\\n                return True\\n            if key + 1 in bucket and bucket[key + 1] - num <= t:\\n                return True\\n\\t\\t\\t# end of picture 3\\n            # remove the first added key\\n            if len(bucket) > k:\\n                bucket.popitem(last = False)\\n        return False\\n```\n```\\n\\'\\'\\'\\nOrderedDict.popitem(last: bool) -> Tuple[Unknown]\\nRemove and return a (key, value) pair from the dictionary.\\n\\nPairs are returned in LIFO order if last is true or FIFO order if false.\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163715,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n        guard !nums.isEmpty else { return false }\\n        let ids = [Int](0..<nums.count).sorted{ nums[$0] < nums[$1] }\\n        \\n        for a in 0...ids.count - 1 {\\n            for b in (a + 1)..<nums.count {\\n                let lhs = ids[a], rhs = ids[b]\\n                if nums[rhs] - nums[lhs] > t { break }\\n                if abs(rhs - lhs) <= k { return true }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 1 test, with 0 failures (0 unexpected) in 0.004 (0.005) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        XCTAssertEqual(solution.containsNearbyAlmostDuplicate([1,2,3,1], 3, 0), true)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n        guard !nums.isEmpty else { return false }\\n        let ids = [Int](0..<nums.count).sorted{ nums[$0] < nums[$1] }\\n        \\n        for a in 0...ids.count - 1 {\\n            for b in (a + 1)..<nums.count {\\n                let lhs = ids[a], rhs = ids[b]\\n                if nums[rhs] - nums[lhs] > t { break }\\n                if abs(rhs - lhs) <= k { return true }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        XCTAssertEqual(solution.containsNearbyAlmostDuplicate([1,2,3,1], 3, 0), true)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658158,
                "title": "python-well-explained-sliding-window-bucket-sort",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t>=0:\\n            bs,w = {}, t+1\\n            for i, v in enumerate(nums):\\n                b = v // w\\n                if b in bs:\\n                    return True\\n                else:\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n        return False \\n```\\n\\nSo the general idea is simple. We need to check two things:\\n\\n1. The indexes of the elements are `>=k` apart. That can be done by using a sliding window.\\n2. The values of the elements are `>=t` apart. This is a bit more interesting. Let\\'s say we have buckets of size `t+1`. If our element value is `v`, it will go into bucket `v//(t+1)`.  So if we get 2 values in the same bucket - they are withing `t+1` - so we found a solution. It\\'s also possible that we might have an element close enough in the previous or next bucket.\\n3. Finally, as we move sliding window, we need to remove left element from the buckets.\\n\\nOk, now we put everything together:\\n\\n1. The absolute difference can\\'t be a negative number, but apparently they have an edge test case where `t=-1` and it causes division by 0, so we take care of this explicitely:\\n\\n```\\n        if t>=0:\\n```\\n\\n2. Now we define our buckets and the bucket width w:\\n```\\n            bs,w = {}, t+1\\n```\\n3. Our main loop:\\n```\\n            for i, v in enumerate(nums):\\n```\\n\\t4. `b` is the bucket number for the current value `v`:\\n```\\n               b = v // w\\n```\\n5. If that bucket already has another value - we found a pair!\\n```\\n                if b in bs:\\n                    return True\\n```\\n6. Otherwise we add the current value into the new bucket and check the buckets just above and below. Make sure that you check that the element is in bs first before you try to use it\\'s value, not the other way around!\\n```\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n```\\n7. Finally, if we exceeded sliding window - we remove the leftmost value from its bucket:\\n```\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n```\\n8. If we haven\\'t found any good pairs, we return False:\\n\\n```\\n        return False \\n```\\n\\nThat\\'s it!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t>=0:\\n            bs,w = {}, t+1\\n            for i, v in enumerate(nums):\\n                b = v // w\\n                if b in bs:\\n                    return True\\n                else:\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n        return False \\n```\n```\\n        if t>=0:\\n```\n```\\n            bs,w = {}, t+1\\n```\n```\\n            for i, v in enumerate(nums):\\n```\n```\\n               b = v // w\\n```\n```\\n                if b in bs:\\n                    return True\\n```\n```\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n```\n```\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n```\n```\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809732,
                "title": "c-sliding-window-multiset-solution-with-comments-easy-understanding",
                "content": "\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        t=(long)t;          // taking t as long because difference between numbers can be greater than INT_MAX\\n        multiset<long> s;   //window\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>k){\\n                s.erase((long)nums[i-k-1]);         // if size of window > k, we are removing elements from window\\n            }\\n            \\n            auto it=s.lower_bound((long)nums[i]-t); // searching for numbers with difference at most t\\n\\t\\t\\tlong dif=*it-(long)nums[i];             // difference is calculated for further comparisons\\n\\t\\t\\t\\n            if(it!=s.end() and dif<=t){             // if number in window with at most t difference is present \\n                return true;\\n            }\\n            s.insert(nums[i]); // inserting element in window \\n        }\\n        return false;\\n    }\\n\\t// Thanks\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        t=(long)t;          // taking t as long because difference between numbers can be greater than INT_MAX\\n        multiset<long> s;   //window\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>k){\\n                s.erase((long)nums[i-k-1]);         // if size of window > k, we are removing elements from window\\n            }\\n            \\n            auto it=s.lower_bound((long)nums[i]-t); // searching for numbers with difference at most t\\n\\t\\t\\tlong dif=*it-(long)nums[i];             // difference is calculated for further comparisons\\n\\t\\t\\t\\n            if(it!=s.end() and dif<=t){             // if number in window with at most t difference is present \\n                return true;\\n            }\\n            s.insert(nums[i]); // inserting element in window \\n        }\\n        return false;\\n    }\\n\\t// Thanks\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 829231,
                "title": "python3-easy-to-understand-o-n-solution-contains-duplicate-iii",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        d = OrderedDict()\\n        window = t + 1\\n        for i, n in enumerate(nums):\\n            while len(d) > k:\\n                d.popitem(last=False)\\n            if (b := n//window) in d:\\n                return True \\n            if b - 1 in d and abs(d[b-1] - n) <= t:\\n                return True\\n            if b + 1 in d and abs(d[b+1] - n) <= t:\\n                return True\\n            d[b] = nums[i]  \\n        return False \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        d = OrderedDict()\\n        window = t + 1\\n        for i, n in enumerate(nums):\\n            while len(d) > k:\\n                d.popitem(last=False)\\n            if (b := n//window) in d:\\n                return True \\n            if b - 1 in d and abs(d[b-1] - n) <= t:\\n                return True\\n            if b + 1 in d and abs(d[b+1] - n) <= t:\\n                return True\\n            d[b] = nums[i]  \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 339421,
                "title": "python-bucket-method-in-detail",
                "content": "Thanks to @dietpepsi, here I am explaining his solution as simple as I can.\\n\\nWe take bucketSize = t+1\\nSo when we encounter a number N we can get its bucket index = N / bucketSize\\nThere are 2 cases our code will return True:\\n```\\n(1) When two numbers lie in the same bucket, they already have difference <= t because of bucket size\\n(2) When two numbers lie in the adjacent bucket and they have difference<=t\\n```\\n\\nCreate a dictionary allBuckets = {}\\nOur allBuckets store only buckets corresponding to at max k numbers inside our k sized window.\\n\\n**In the below code when i>=k we delete the bucket of (i-k)th index from our allBuckets,\\nin this way we only maintain buckets for indexes (i-k+1) to i --> k numbers**\\n\\n```\\ndef containsNearbyAlmostDuplicate(self, nums, k, t):\\n\\tif t<0 or k<0:\\n\\t\\treturn False\\n\\tallBuckets = {}\\n\\tbucketSize = t+1\\n\\tfor i in xrange(len(nums)):\\n\\t\\t# m is bucket Index for nums[i]\\n\\t\\tm = nums[i]/bucketSize\\n\\t\\t\\n\\t\\t#if there is a bucket already present corresponding to current number\\n\\t\\tif m in allBuckets:\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\t\\t#checking two adjacent buckets  m, m-1\\n\\t\\tif (m-1) in allBuckets and abs(nums[i]-allBuckets[m-1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\t#checking two adjacent buckets m, m+1\\n\\t\\tif (m+1) in allBuckets and abs(nums[i]-allBuckets[m+1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\tallBuckets[m]= nums[i]\\n\\t\\t\\n\\t\\t#removing the bucket corresponding to number out of our k sized window\\n\\t\\tif i>=k:\\n\\t\\t\\tdel allBuckets[ nums[i-k]/bucketSize ]\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\n(1) When two numbers lie in the same bucket, they already have difference <= t because of bucket size\\n(2) When two numbers lie in the adjacent bucket and they have difference<=t\\n```\n```\\ndef containsNearbyAlmostDuplicate(self, nums, k, t):\\n\\tif t<0 or k<0:\\n\\t\\treturn False\\n\\tallBuckets = {}\\n\\tbucketSize = t+1\\n\\tfor i in xrange(len(nums)):\\n\\t\\t# m is bucket Index for nums[i]\\n\\t\\tm = nums[i]/bucketSize\\n\\t\\t\\n\\t\\t#if there is a bucket already present corresponding to current number\\n\\t\\tif m in allBuckets:\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\t\\t#checking two adjacent buckets  m, m-1\\n\\t\\tif (m-1) in allBuckets and abs(nums[i]-allBuckets[m-1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\t#checking two adjacent buckets m, m+1\\n\\t\\tif (m+1) in allBuckets and abs(nums[i]-allBuckets[m+1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\tallBuckets[m]= nums[i]\\n\\t\\t\\n\\t\\t#removing the bucket corresponding to number out of our k sized window\\n\\t\\tif i>=k:\\n\\t\\t\\tdel allBuckets[ nums[i-k]/bucketSize ]\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1423174,
                "title": "c-sliding-window-easiest-sol-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        if(t<0 || k<=0)\\n            return false;\\n        \\n        t = (long)t;\\n        k = (long)k;\\n        multiset<long> window;//window of size k\\n\\n        for(int right=0; right<nums.size(); right++)\\n        {\\n            if(right > k)//abs(i - j) <= k.\\n                window.erase((long)nums[right-k-1]);//slide the window\\n\\n           //search within the window for the number which can satisfy the condition\\n            auto number_satisfy  = window.lower_bound((long)nums[right]-t);\\n            long diff = *number_satisfy - (long)nums[right];\\n            //abs(nums[i] - nums[j]) <= t\\n            if(number_satisfy != window.end() and diff <= t)\\n                return true;\\n\\n            window.insert(nums[right]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        if(t<0 || k<=0)\\n            return false;\\n        \\n        t = (long)t;\\n        k = (long)k;\\n        multiset<long> window;//window of size k\\n\\n        for(int right=0; right<nums.size(); right++)\\n        {\\n            if(right > k)//abs(i - j) <= k.\\n                window.erase((long)nums[right-k-1]);//slide the window\\n\\n           //search within the window for the number which can satisfy the condition\\n            auto number_satisfy  = window.lower_bound((long)nums[right]-t);\\n            long diff = *number_satisfy - (long)nums[right];\\n            //abs(nums[i] - nums[j]) <= t\\n            if(number_satisfy != window.end() and diff <= t)\\n                return true;\\n\\n            window.insert(nums[right]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 824724,
                "title": "c-16-ms-96-solution-with-map-and-2-pointers-explanation",
                "content": "1. create map < nums[i]  ,  [i]> where  0 < i < nums.size()\\n2. Now we have orderd numbers from vector nums in our map\\n3. We sequentially scan the numbers in the map (in the range from i, until the number in the map exceeds the original number + t)\\n\\nRuntime: 16 ms, faster than 96.45% of C++ online submissions for Contains Duplicate III.\\nMemory Usage: 15.2 MB, less than 46.57% of C++ online submissions for Contains Duplicate III.\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap <int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp.insert(pair< int, int >(nums[i], i));\\n        \\n        multimap <int,int>::iterator it, itnext;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            itnext = it;\\n            while(true){\\n                itnext++;\\n                if(itnext == mp.end()) break;\\n                long long a = (*it).first;\\n                long long b = (*itnext).first;\\n                if( b - a <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n                else break;\\n            }\\n        }            \\n        return false;\\n    }\\n};\\n```\\n\\n**original it was writed as it:**\\n```\\nclass Solution {\\npublic:\\n  bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    multimap <int,int> mp;\\n    for(int i = 0; i != nums.size(); i++) mp.insert({nums[i], i});\\n        \\n    for(multimap <int,int>::iterator it = mp.begin(), itnext = mp.begin(); it != mp.end(); itnext = ++it)\\n      while(++itnext != mp.end())\\n        if(long((*itnext).first) - long((*it).first) <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n        else break;\\n        \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap <int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp.insert(pair< int, int >(nums[i], i));\\n        \\n        multimap <int,int>::iterator it, itnext;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            itnext = it;\\n            while(true){\\n                itnext++;\\n                if(itnext == mp.end()) break;\\n                long long a = (*it).first;\\n                long long b = (*itnext).first;\\n                if( b - a <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n                else break;\\n            }\\n        }            \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    multimap <int,int> mp;\\n    for(int i = 0; i != nums.size(); i++) mp.insert({nums[i], i});\\n        \\n    for(multimap <int,int>::iterator it = mp.begin(), itnext = mp.begin(); it != mp.end(); itnext = ++it)\\n      while(++itnext != mp.end())\\n        if(long((*itnext).first) - long((*it).first) <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n        else break;\\n        \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805542,
                "title": "python-bst-approach-with-sortedcontainers",
                "content": "```\\nimport sortedcontainers\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        def floor(n, bst):\\n            le = bst.bisect_right(n) - 1\\n            return bst[le] if le >= 0 else None\\n        \\n        def ceiling(n, bst):\\n            ge = bst.bisect_right(n)\\n            return bst[ge] if ge < len(bst) else None\\n        \\n        bst = sortedcontainers.SortedList()\\n        for i, n in enumerate(nums):\\n            le = floor(n, bst)\\n            if le is not None and n <= le + t:\\n                return True\\n            ge = ceiling(n, bst)\\n            if ge is not None and ge <= n + t:\\n                return True\\n            bst.add(n)\\n            if len(bst) > k:\\n                bst.remove(nums[i-k])\\n        return False\\n    # time:  O(nlogk)\\n    # space: O(k)\\n```\\n*Edit: tags*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nimport sortedcontainers\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        def floor(n, bst):\\n            le = bst.bisect_right(n) - 1\\n            return bst[le] if le >= 0 else None\\n        \\n        def ceiling(n, bst):\\n            ge = bst.bisect_right(n)\\n            return bst[ge] if ge < len(bst) else None\\n        \\n        bst = sortedcontainers.SortedList()\\n        for i, n in enumerate(nums):\\n            le = floor(n, bst)\\n            if le is not None and n <= le + t:\\n                return True\\n            ge = ceiling(n, bst)\\n            if ge is not None and ge <= n + t:\\n                return True\\n            bst.add(n)\\n            if len(bst) > k:\\n                bst.remove(nums[i-k])\\n        return False\\n    # time:  O(nlogk)\\n    # space: O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295563,
                "title": "c-sortedset-getviewbetween",
                "content": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        var n = nums.Length;\\n        var sortedSet = new SortedSet<long>();\\n        for (int i = 0; i < n; i++) {\\n            if (sortedSet.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            sortedSet.Add(nums[i]);\\n            if (i >= k) sortedSet.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        var n = nums.Length;\\n        var sortedSet = new SortedSet<long>();\\n        for (int i = 0; i < n; i++) {\\n            if (sortedSet.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            sortedSet.Add(nums[i]);\\n            if (i >= k) sortedSet.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61668,
                "title": "10ms-non-cheating-solution-beats-98-84-submissions",
                "content": "Unlike some solutions in the forum that convert int to long which is kinda of cheating, this solution doesn't convert.. Converting defeats the purpose of having max value test case (if the input contains max long itself, how to handle?)\\n\\n```\\nimport java.util.Hashtable;\\n\\npublic class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n\\tif(k<=0||t<0||nums.length < 2) return false;\\n\\t\\t\\n        Hashtable<Integer,Integer> hs = new Hashtable<Integer,Integer>();\\n\\n        if (t==0) {\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\ths.remove(nums[i-k-1]);\\n                }\\n                if (hs.containsKey(nums[i])){\\n                    return true;\\n                }\\n                hs.put(nums[i],i);\\n            }\\n            return false;\\n        } else{\\n\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\t// windowing, only preserve k#\\n                \\ths.remove(nums[i-k-1]/t);\\n                }\\n                if (hs.get(nums[i]/t) != null ){\\n                \\tint delta = Math.abs(nums[i] - nums[hs.get(nums[i]/t)]);\\n                \\t// The delta value could be larger than t, if one number is in (-t,0) and the other is in (0,t)\\n                \\tif ( delta<=t) return true;\\n                }\\n                if (hs.get(nums[i]/t-1) != null ){\\n                \\tint delta = nums[i] - nums[hs.get(nums[i]/t-1)];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n                }\\n                if (hs.get(nums[i]/t+1) != null ){\\n                \\tint delta = nums[hs.get(nums[i]/t+1)] - nums[i];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n\\n                }\\n    \\n                hs.put(nums[i]/t,i);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Hashtable;\\n\\npublic class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n\\tif(k<=0||t<0||nums.length < 2) return false;\\n\\t\\t\\n        Hashtable<Integer,Integer> hs = new Hashtable<Integer,Integer>();\\n\\n        if (t==0) {\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\ths.remove(nums[i-k-1]);\\n                }\\n                if (hs.containsKey(nums[i])){\\n                    return true;\\n                }\\n                hs.put(nums[i],i);\\n            }\\n            return false;\\n        } else{\\n\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\t// windowing, only preserve k#\\n                \\ths.remove(nums[i-k-1]/t);\\n                }\\n                if (hs.get(nums[i]/t) != null ){\\n                \\tint delta = Math.abs(nums[i] - nums[hs.get(nums[i]/t)]);\\n                \\t// The delta value could be larger than t, if one number is in (-t,0) and the other is in (0,t)\\n                \\tif ( delta<=t) return true;\\n                }\\n                if (hs.get(nums[i]/t-1) != null ){\\n                \\tint delta = nums[i] - nums[hs.get(nums[i]/t-1)];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n                }\\n                if (hs.get(nums[i]/t+1) != null ){\\n                \\tint delta = nums[hs.get(nums[i]/t+1)] - nums[i];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n\\n                }\\n    \\n                hs.put(nums[i]/t,i);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61736,
                "title": "o-n-solution-in-c-using-bucket-sort",
                "content": "    // time: O(n); space: O(n)\\n    class Solution {\\n        long long getBucketId(long long i, long long w) {\\n            return i < 0 ? (i + 1) / w - 1 : i / w;\\n        }\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            int n = nums.size();\\n            if (n < 2 || k < 1 || t < 0)\\n            {\\n                return false;\\n            }\\n    \\n            unordered_map<long long, long long> buckets;\\n            long long width = (long long)t + 1;\\n            for (int i = 0; i < n; i++)\\n            {\\n                long long id = getBucketId(nums[i], width);\\n    \\n                // found the value in the same bucket\\n                if (buckets.find(id) != buckets.end())\\n                {\\n                    return true;\\n                }\\n    \\n                // found the value in the adjacent bucket\\n                if ((buckets.find(id - 1) != buckets.end() && nums[i] - buckets[id - 1] < width) ||\\n                    (buckets.find(id + 1) != buckets.end() && buckets[id + 1] - nums[i] < width))\\n                {\\n                    return true;\\n                }\\n    \\n                // insert current value to buckets\\n                buckets[id] = nums[i];\\n    \\n                if (i >= k)    // remove out of range element\\n                {\\n                    buckets.erase(getBucketId(nums[i - k], width));\\n                }\\n            }\\n    \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        long long getBucketId(long long i, long long w) {\\n            return i < 0 ? (i + 1) / w - 1 : i / w;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3546546,
                "title": "python-bucketsort-o-n-beat-98-with-comments",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        buckets = {} #store values for diapason (i-indexDiff:i]\\n        valueDiff +=1 #if valueDiff = zero it\\'s simplify proces edge-cases\\n        \\n        for idx, curVal in enumerate(nums):\\n            bucketId = curVal // valueDiff #bucket for new element\\n            if bucketId in buckets: return True # have \\'duplicate value\\' in current bucket\\n            #check neighboring buckets if they are exists\\n            for i in (bucketId - 1, bucketId + 1):\\n                if i in buckets: # bucket exist\\n                    if abs(buckets[i] - curVal) < valueDiff: # because valueDiff+1 then check only strict <\\n                        return True\\n            \\n            #add current value to bucket\\n            buckets[bucketId] = curVal\\n            \\n            # remove value out of available window\\n            if idx >= indexDiff:\\n                removeVal = nums[idx - indexDiff]\\n                del buckets[removeVal//valueDiff]\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        buckets = {} #store values for diapason (i-indexDiff:i]\\n        valueDiff +=1 #if valueDiff = zero it\\'s simplify proces edge-cases\\n        \\n        for idx, curVal in enumerate(nums):\\n            bucketId = curVal // valueDiff #bucket for new element\\n            if bucketId in buckets: return True # have \\'duplicate value\\' in current bucket\\n            #check neighboring buckets if they are exists\\n            for i in (bucketId - 1, bucketId + 1):\\n                if i in buckets: # bucket exist\\n                    if abs(buckets[i] - curVal) < valueDiff: # because valueDiff+1 then check only strict <\\n                        return True\\n            \\n            #add current value to bucket\\n            buckets[bucketId] = curVal\\n            \\n            # remove value out of available window\\n            if idx >= indexDiff:\\n                removeVal = nums[idx - indexDiff]\\n                del buckets[removeVal//valueDiff]\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407967,
                "title": "clean-python-solution-self-explained-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(N)\\nSpace: O(K)\\n\\nImagine there are several different buckets. Each bucket can only contain one number.\\nBucket1 contains a number within [0, t]\\nBucket2 contains a number within [t+1, 2t+1]\\nBucket3 contains a number within [2t+2, 3t+2]\\n...\\n\\nFor each num, put it in the bucket.\\nBefore that.\\nIf the bucket is already occupied, there must be another num that \"abs(anotherNum - num) <= t\", return True.\\nCheck the neighbor buckets, the number within those might also \"abs(anotherNum - num) <= t\". If so, return True.\\n\\nWe only consider k numbers before num.\\nSo remove nums[i-k-1] from the bucket if we already have k elements in the buckets.\\n\"\"\"\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        bucket = {}\\n        \\n        for i, num in enumerate(nums):\\n            if len(bucket)>k:\\n                bidToRemove = nums[i-k-1]//(t+1)\\n                del bucket[bidToRemove]\\n            \\n            bid = num//(t+1)\\n            if bid in bucket: return True\\n            if bid+1 in bucket and abs(bucket[bid+1]-num)<=t: return True\\n            if bid-1 in bucket and abs(bucket[bid-1]-num)<=t: return True\\n            bucket[bid] = num\\n        \\n        return False\\n\\t\\t\\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N)\\nSpace: O(K)\\n\\nImagine there are several different buckets. Each bucket can only contain one number.\\nBucket1 contains a number within [0, t]\\nBucket2 contains a number within [t+1, 2t+1]\\nBucket3 contains a number within [2t+2, 3t+2]\\n...\\n\\nFor each num, put it in the bucket.\\nBefore that.\\nIf the bucket is already occupied, there must be another num that \"abs(anotherNum - num) <= t\", return True.\\nCheck the neighbor buckets, the number within those might also \"abs(anotherNum - num) <= t\". If so, return True.\\n\\nWe only consider k numbers before num.\\nSo remove nums[i-k-1] from the bucket if we already have k elements in the buckets.\\n\"\"\"\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        bucket = {}\\n        \\n        for i, num in enumerate(nums):\\n            if len(bucket)>k:\\n                bidToRemove = nums[i-k-1]//(t+1)\\n                del bucket[bidToRemove]\\n            \\n            bid = num//(t+1)\\n            if bid in bucket: return True\\n            if bid+1 in bucket and abs(bucket[bid+1]-num)<=t: return True\\n            if bid-1 in bucket and abs(bucket[bid-1]-num)<=t: return True\\n            bucket[bid] = num\\n        \\n        return False\\n\\t\\t\\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825264,
                "title": "a-sortedset-based-solution",
                "content": "```\\npublic class Solution\\n{\\n    private SortedSet<long> neighbors = new SortedSet<long>();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t)\\n    {\\n        if(k < 0 || t < 0) return false;\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(IsThereNeighbor(nums[i], t)) return true;\\n            neighbors.Add(nums[i]);\\n            if(i >= k) neighbors.Remove(nums[i-k]);\\n        }\\n        return false;\\n    }\\n    \\n    private bool IsThereNeighbor(long num, int distance)\\n    {\\n        return neighbors.GetViewBetween(num - distance, num + distance).Any();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private SortedSet<long> neighbors = new SortedSet<long>();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t)\\n    {\\n        if(k < 0 || t < 0) return false;\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(IsThereNeighbor(nums[i], t)) return true;\\n            neighbors.Add(nums[i]);\\n            if(i >= k) neighbors.Remove(nums[i-k]);\\n        }\\n        return false;\\n    }\\n    \\n    private bool IsThereNeighbor(long num, int distance)\\n    {\\n        return neighbors.GetViewBetween(num - distance, num + distance).Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548969,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nk = max size of window \\nt = max diff between nums[startOfWindow] and nums[endOfWindow]\\n\\nWe need to find if there are i and j such that (1) their size of window is <= k and (2) their diff is <= t.\\n*/\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i+1; j <= i+k; j++) { // satisfies (1)\\n            let diff = Math.abs(nums[i] - nums[j]);\\n            if (diff <= t) { // satisfies (2)\\n                return true; \\n            }\\n        }\\n    }\\n    return false;\\n    // T.C: O(N*K)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nk = max size of window \\nt = max diff between nums[startOfWindow] and nums[endOfWindow]\\n\\nWe need to find if there are i and j such that (1) their size of window is <= k and (2) their diff is <= t.\\n*/\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i+1; j <= i+k; j++) { // satisfies (1)\\n            let diff = Math.abs(nums[i] - nums[j]);\\n            if (diff <= t) { // satisfies (2)\\n                return true; \\n            }\\n        }\\n    }\\n    return false;\\n    // T.C: O(N*K)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541412,
                "title": "javascript-binary-search-tree",
                "content": "- Time Complexity: O(NH)\\n- Space Compexity: O(K)\\n\\n```JavaScript\\n/**\\n * @param {number} x\\n */\\nconst BST  = function(x) {\\n    this.val = x;\\n    this.left = null;\\n    this.right = null;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.add = function(x, t) {\\n    if (x < this.val) {\\n        this.left ? this.left.add(x) : this.left = new BST(x);\\n        return this.val - x <= t \\n    } else {\\n        this.right ? this.right.add(x) : this.right = new BST(x);\\n    }\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst predecessor = function(node) {\\n    node = node.left;\\n    while (node.right) {\\n        node = node.right;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst successor = function(node) {\\n    node = node.right;\\n    while (node.left) {\\n        node = node.left;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.delete = function(x) {\\n    if (this.val === x) {\\n        if (this.right) {\\n            const next = successor(this);\\n            this.val = next.val;\\n            this.right = this.right.delete(next.val);\\n        } else if (this.left) {\\n            const prev = predecessor(this);\\n            this.val = prev.val;\\n            this.left = this.left.delete(prev.val);\\n        } else {\\n            return null;\\n        }\\n    } else {\\n        this.val < x\\n            ? this.right = this.right.delete(x)\\n            : this.left = this.left.delete(x);\\n    }\\n    return this;\\n}\\n\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @return {boolean}\\n */\\nBST.prototype.between = function(a,b) {\\n    if (a <= this.val && this.val <= b) {\\n        return true;\\n    }\\n    if (this.left && a < this.val && b < this.val) {\\n        return this.left.between(a,b);\\n    }\\n    if (this.right && a > this.val && b > this.val) {\\n        return this.right.between(a,b);\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let root = null;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (root && root.between(nums[i] - t, nums[i] + t)) {\\n            return true;\\n        }\\n        root ? root.add(nums[i]) : root = new BST(nums[i]);\\n        if (k <= i) {\\n            root = root.delete(nums[i-k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} x\\n */\\nconst BST  = function(x) {\\n    this.val = x;\\n    this.left = null;\\n    this.right = null;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.add = function(x, t) {\\n    if (x < this.val) {\\n        this.left ? this.left.add(x) : this.left = new BST(x);\\n        return this.val - x <= t \\n    } else {\\n        this.right ? this.right.add(x) : this.right = new BST(x);\\n    }\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst predecessor = function(node) {\\n    node = node.left;\\n    while (node.right) {\\n        node = node.right;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst successor = function(node) {\\n    node = node.right;\\n    while (node.left) {\\n        node = node.left;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.delete = function(x) {\\n    if (this.val === x) {\\n        if (this.right) {\\n            const next = successor(this);\\n            this.val = next.val;\\n            this.right = this.right.delete(next.val);\\n        } else if (this.left) {\\n            const prev = predecessor(this);\\n            this.val = prev.val;\\n            this.left = this.left.delete(prev.val);\\n        } else {\\n            return null;\\n        }\\n    } else {\\n        this.val < x\\n            ? this.right = this.right.delete(x)\\n            : this.left = this.left.delete(x);\\n    }\\n    return this;\\n}\\n\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @return {boolean}\\n */\\nBST.prototype.between = function(a,b) {\\n    if (a <= this.val && this.val <= b) {\\n        return true;\\n    }\\n    if (this.left && a < this.val && b < this.val) {\\n        return this.left.between(a,b);\\n    }\\n    if (this.right && a > this.val && b > this.val) {\\n        return this.right.between(a,b);\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let root = null;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (root && root.between(nums[i] - t, nums[i] + t)) {\\n            return true;\\n        }\\n        root ? root.add(nums[i]) : root = new BST(nums[i]);\\n        if (k <= i) {\\n            root = root.delete(nums[i-k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508393,
                "title": "java-easy-solution-with-explanation",
                "content": "In this question, we can use a TreeSet which offers functinos like floor and ceiling. \\n**floor()** returns the greatest element in this set less than or equal to the given element, or null if there is no such element. \\n**ceiling()** returns the least element in this set greater than or equal to the given element, or null if there is no such element. \\n\\nAt all times, the TreeSet will represent **a  window of k numbers**. When the index goes beyond k, we keep on removing index-k th number form the TreeSet.\\n\\n```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\tif(nums.length == 0) return false;\\n\\tTreeSet<Long> window = new TreeSet<>();\\n\\tfor(int i=0; i<nums.length; i++) {\\n\\t\\tlong num = nums[i];\\n\\t\\tLong floor = window.floor(num+t);\\n\\t\\tLong ceiling = window.ceiling(num-t);\\n\\t\\tif(floor != null && floor >= num) return true;\\n\\t\\tif(ceiling !=null && ceiling <= num) return true;\\n\\t\\twindow.add(num);\\n\\t\\tif(i >= k) window.remove((long)nums[i-k]);\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\tif(nums.length == 0) return false;\\n\\tTreeSet<Long> window = new TreeSet<>();\\n\\tfor(int i=0; i<nums.length; i++) {\\n\\t\\tlong num = nums[i];\\n\\t\\tLong floor = window.floor(num+t);\\n\\t\\tLong ceiling = window.ceiling(num-t);\\n\\t\\tif(floor != null && floor >= num) return true;\\n\\t\\tif(ceiling !=null && ceiling <= num) return true;\\n\\t\\twindow.add(num);\\n\\t\\tif(i >= k) window.remove((long)nums[i-k]);\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61768,
                "title": "16-ms-accepted-a-unusual-c-solution-even-faster-than-c",
                "content": "I save the nums to a pointer array, then sort the pointer array ascending. At last, I use the most plain algorithm.\\n\\n    bool cmpptr(int *a, int *b){\\n        return *a < *b; \\n    }\\n    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n          const int N = nums.size();\\n          vector<int*> numptrs(N);\\n          for(int i = 0; i < N; ++i){\\n             numptrs[i] = &nums[i];\\n          }\\n          sort(numptrs.begin(), numptrs.end(), cmpptr);\\n          if(0 == k) return false;\\n          for(int i = 0; i < N; ++i){\\n              for(int j = i + 1; j < N; ++j){\\n                   //nums[i] and nums[j] is at most t\\n                  if((*numptrs[j]) > (*numptrs[i]) + t) \\n                         break;\\n                  //the difference between i and j is at most k\\n                  if(abs(numptrs[j] - numptrs[i]) <= k) return true;\\n              }\\n          }\\n           return false;\\n        }\\n\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n          const int N = nums.size();\\n          vector<int*> numptrs(N);\\n          for(int i = 0; i < N; ++i){\\n             numptrs[i] = &nums[i];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2717465,
                "title": "java-3-approaches-brute-to-optimal",
                "content": "### **Please Upvote** :D\\n##### 1. Brute force (47/48 passed - TLE):\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (Math.abs((long) (nums[i] - nums[j])) <= valueDiff\\n                        && j - i <= indexDiff) {\\n                    return true;\\n                }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### 2. A little optimization to brute force (Accepted / Very Slow):\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int i = 0, j = 1;\\n\\n        while(j < nums.length){\\n            int currValueDiff = Math.abs(nums[i] - nums[j]);\\n            int currIndexDiff = Math.abs(i - j);\\n\\n            if (currValueDiff <= valueDiff && currIndexDiff <= indexDiff){\\n                return true;\\n            }\\n\\n            else if(currIndexDiff == indexDiff || j == nums.length - 1){\\n                j = ++i;\\n            }\\n\\n            j++;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### 3. Optimal Solution:\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        TreeSet<Long> set = new TreeSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            Long num = new Long(nums[i]);\\n            Long floor = set.floor(num);\\n            Long ceil = set.ceiling(num);\\n\\n            if (floor != null && Math.abs(floor - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            if (ceil != null && Math.abs(ceil - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            set.add(num);\\n\\n            if (set.size() > indexDiff) {\\n                set.remove(1L * nums[i - indexDiff]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logk), SC: O(k)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (Math.abs((long) (nums[i] - nums[j])) <= valueDiff\\n                        && j - i <= indexDiff) {\\n                    return true;\\n                }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int i = 0, j = 1;\\n\\n        while(j < nums.length){\\n            int currValueDiff = Math.abs(nums[i] - nums[j]);\\n            int currIndexDiff = Math.abs(i - j);\\n\\n            if (currValueDiff <= valueDiff && currIndexDiff <= indexDiff){\\n                return true;\\n            }\\n\\n            else if(currIndexDiff == indexDiff || j == nums.length - 1){\\n                j = ++i;\\n            }\\n\\n            j++;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        TreeSet<Long> set = new TreeSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            Long num = new Long(nums[i]);\\n            Long floor = set.floor(num);\\n            Long ceil = set.ceiling(num);\\n\\n            if (floor != null && Math.abs(floor - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            if (ceil != null && Math.abs(ceil - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            set.add(num);\\n\\n            if (set.size() > indexDiff) {\\n                set.remove(1L * nums[i - indexDiff]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logk), SC: O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212714,
                "title": "neat-python-code-implementing-bucket-using-dict-o-n-time",
                "content": "```\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if k <= 0 or t < 0 or len(nums) < 2:\\n            return False\\n\\n        min_val = min(nums)\\n        if min_val < 0:\\n            nums = [n - min_val for n in nums]\\n            min_val = 0\\n        max_val = max(nums)\\n        bucket_dict = {}\\n        for i, num in enumerate(nums):\\n            idx = int(num/(t+1))\\n            if len(bucket_dict) == k+1:\\n                bucket_dict.pop(int(nums[i-k-1]/(t+1)))\\n            if idx in bucket_dict:\\n                return True\\n            elif idx-1 in bucket_dict and num - bucket_dict[idx-1] <= t:\\n                return True\\n            elif idx+1 in bucket_dict and bucket_dict[idx+1] - num <= t:\\n                return True\\n            else:\\n                bucket_dict[idx] = num\\n        \\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if k <= 0 or t < 0 or len(nums) < 2:\\n            return False\\n\\n        min_val = min(nums)\\n        if min_val < 0:\\n            nums = [n - min_val for n in nums]\\n            min_val = 0\\n        max_val = max(nums)\\n        bucket_dict = {}\\n        for i, num in enumerate(nums):\\n            idx = int(num/(t+1))\\n            if len(bucket_dict) == k+1:\\n                bucket_dict.pop(int(nums[i-k-1]/(t+1)))\\n            if idx in bucket_dict:\\n                return True\\n            elif idx-1 in bucket_dict and num - bucket_dict[idx-1] <= t:\\n                return True\\n            elif idx+1 in bucket_dict and bucket_dict[idx+1] - num <= t:\\n                return True\\n            else:\\n                bucket_dict[idx] = num\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571794,
                "title": "simple-python-solution-77-faster-with-detailed-explanation",
                "content": "class Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t < 0:\\n            return False\\n\\n        n = len(nums)\\n        num_arr = []\\n        # create a array of tuple where first index hold the element\\n        # and 2nd Index hold its index\\n        for i in range(n):\\n            temp = (nums[i],i)\\n            num_arr.append(temp)\\n\\n        # sort the array\\n        num_arr = sorted(num_arr)\\n\\n        # loop through array from 0th position\\n        for i in range(n):\\n            # loop array from i+1 postion\\n            for j in range(i+1,n):\\n                # check if difference of two elements is less than t or not\\n                # if not, no need to check further as array is already sorted\\n                # so further element\\'s different will also not meet this criteria\\n                if abs(num_arr[i][0] - num_arr[j][0]) <= t :\\n                    # if above condition met, check if both index\\'s position defference is less than k\\n                    if abs(num_arr[i][1] - num_arr[j][1]) <= k:\\n                        # if yes, return True\\n                        return True\\n                else:\\n                    break\\n        return False",
                "solutionTags": [],
                "code": "class Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t < 0:\\n            return False\\n\\n        n = len(nums)\\n        num_arr = []\\n        # create a array of tuple where first index hold the element\\n        # and 2nd Index hold its index\\n        for i in range(n):\\n            temp = (nums[i],i)\\n            num_arr.append(temp)\\n\\n        # sort the array\\n        num_arr = sorted(num_arr)\\n\\n        # loop through array from 0th position\\n        for i in range(n):\\n            # loop array from i+1 postion\\n            for j in range(i+1,n):\\n                # check if difference of two elements is less than t or not\\n                # if not, no need to check further as array is already sorted\\n                # so further element\\'s different will also not meet this criteria\\n                if abs(num_arr[i][0] - num_arr[j][0]) <= t :\\n                    # if above condition met, check if both index\\'s position defference is less than k\\n                    if abs(num_arr[i][1] - num_arr[j][1]) <= k:\\n                        # if yes, return True\\n                        return True\\n                else:\\n                    break\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 138067,
                "title": "clean-javascript-solution",
                "content": "```js\\nconst containsNearbyAlmostDuplicate = (nums, k, t) => {\\n  const map = nums\\n    .map((val, idx) => ({ val, idx }))\\n    .sort((a, b) => a.val - b.val);\\n\\n  let l = 0;\\n  let r = 1;\\n\\n  while (r < map.length) {\\n    const diff = Math.abs(map[r].val - map[l].val);\\n    const range = Math.abs(map[r].idx - map[l].idx);\\n\\n    if (diff <= t && range <= k) return true;\\n    else if (diff > t) l++;\\n    else if (range > k) r++;\\n\\n    if (l === r) r++;\\n  }\\n\\n  return false;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst containsNearbyAlmostDuplicate = (nums, k, t) => {\\n  const map = nums\\n    .map((val, idx) => ({ val, idx }))\\n    .sort((a, b) => a.val - b.val);\\n\\n  let l = 0;\\n  let r = 1;\\n\\n  while (r < map.length) {\\n    const diff = Math.abs(map[r].val - map[l].val);\\n    const range = Math.abs(map[r].idx - map[l].idx);\\n\\n    if (diff <= t && range <= k) return true;\\n    else if (diff > t) l++;\\n    else if (range > k) r++;\\n\\n    if (l === r) r++;\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61737,
                "title": "20ms-simple-c-code",
                "content": "   \\n\\n    class Solution {\\n        public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector< pair<long, int> > vec;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                vec.push_back(make_pair(nums[i], i));\\n            }\\n            sort(vec.begin(), vec.end());\\n            for (int i = 0; i < nums.size(); ++i) {\\n                int j = i + 1;\\n                while(j < nums.size() && vec[j].first-vec[i].first <= t) {\\n                    if (abs(vec[j].second-vec[i].second) <= k) return true;\\n                    j++;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector< pair<long, int> > vec;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                vec.push_back(make_pair(nums[i], i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61692,
                "title": "my-o-n-accepted-java-solution-using-hashmap",
                "content": "I didn't use bs.\\n\\nThx lx223 for his corner case. His answer is https://leetcode.com/discuss/38206/ac-solution-in-java-using-o-n-bucket-with-explanation\\n\\nAlready updated for his corner case {-3,3},2,4\\n \\n\\n    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        Map<Long, Long> map = new java.util.LinkedHashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long j = t == 0 ? (long) nums[i] - Integer.MIN_VALUE : (((long) nums[i] - Integer.MIN_VALUE) / t);\\n            if (map.containsKey(j) || (map.containsKey(j - 1) && Math.abs(map.get(j - 1) - nums[i]) <= t)\\n                    || (map.containsKey(j + 1) && Math.abs(map.get(j + 1) - nums[i]) <= t)) return true;\\n            if (map.keySet().size() == k) map.remove(map.keySet().iterator().next());\\n            map.put(j, (long) nums[i]);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "I didn't use bs.\\n\\nThx lx223 for his corner case. His answer is https://leetcode.com/discuss/38206/ac-solution-in-java-using-o-n-bucket-with-explanation\\n\\nAlready updated for his corner case {-3,3},2,4\\n \\n\\n    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        Map<Long, Long> map = new java.util.LinkedHashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long j = t == 0 ? (long) nums[i] - Integer.MIN_VALUE : (((long) nums[i] - Integer.MIN_VALUE) / t);\\n            if (map.containsKey(j) || (map.containsKey(j - 1) && Math.abs(map.get(j - 1) - nums[i]) <= t)\\n                    || (map.containsKey(j + 1) && Math.abs(map.get(j + 1) - nums[i]) <= t)) return true;\\n            if (map.keySet().size() == k) map.remove(map.keySet().iterator().next());\\n            map.put(j, (long) nums[i]);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61654,
                "title": "java-solution-with-treeset",
                "content": "A TreeSet with size less than k is used here. So the time should be O(n * log(k)). \\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || k < 0 || t < 0)\\n            return false;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i - k - 1 >= 0)\\n                set.remove(nums[i - k - 1]);\\n            int n = nums[i];\\n            if (set.floor(n) != null && n <= t + set.floor(n) || \\n                    set.ceiling(n) != null && set.ceiling(n) <= t + n)\\n                return true;\\n            set.add(n);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "A TreeSet with size less than k is used here. So the time should be O(n * log(k)). \\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || k < 0 || t < 0)\\n            return false;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i - k - 1 >= 0)\\n                set.remove(nums[i - k - 1]);\\n            int n = nums[i];\\n            if (set.floor(n) != null && n <= t + set.floor(n) || \\n                    set.ceiling(n) != null && set.ceiling(n) <= t + n)\\n                return true;\\n            set.add(n);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2514560,
                "title": "pair-c-easy",
                "content": "class Solution {\\npublic:\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> vec(nums.size());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            vec[i].first = nums[i];\\n            vec[i].second = i;\\n        }\\n        sort(vec.begin(),vec.end());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            for(int j = i+1 ; j < nums.size() ; j++)\\n            {\\n                if(abs(vec[i].first + t >= vec[j].first))\\n                {  \\n                    if(abs(vec[i].second - vec[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> vec(nums.size());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            vec[i].first = nums[i];\\n            vec[i].second = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 828127,
                "title": "python-js-go-o-n-by-sliding-window-and-bucket-w-comment",
                "content": "Python/Go O(n) by sliding-window and bucket\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t == 0 and len(set(nums)) == len(nums):\\n            \\n            # Quick response for t = 0\\n            # t = 0 requires at least one pair of repeated element\\n            \\n            return False\\n            \\n        \\n        size = len(nums)\\n        \\n        bucket = {}\\n        \\n        width = t + 1\\n        \\n        for idx, number in enumerate(nums):\\n            \\n            bucket_idx = number // width\\n            \\n            if bucket_idx in bucket:\\n                \\n                # two numbers in the same bucket, gap must be smaller than width\\n                return True\\n            \\n            elif bucket_idx + 1 in bucket and abs(number - bucket[bucket_idx + 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            elif bucket_idx - 1 in bucket and abs(number - bucket[bucket_idx - 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            # put current number into corresponding bucket\\n            bucket[bucket_idx] = number\\n            \\n            \\n            if idx >= k:\\n                \\n                # delete old number whose index distance larger than k\\n                del bucket[ nums[idx-k] //width ]\\n                \\n        return False\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n    if(  (valueDiff == 0) && ( new Set(nums).size == nums.length ) ) {\\n        \\n        // Quick response for valueDiff = 0\\n        // valueDiff = 9 requires at least one pair ofrepeated element\\n        return false;\\n    }\\n    \\n    // key: element value / width\\n    // value: corresponding element \\n    let bucket = new Map();\\n    \\n    const width = valueDiff + 1;\\n    \\n    for( let idx = 0 ; idx < nums.length ; idx++ ){\\n        \\n        let curNumber = nums[idx];\\n        \\n        let bucketIdx = Math.floor( curNumber / width );\\n        \\n        if( bucket.has(bucketIdx) ){\\n            \\n            // two numbers in the same bucket, gap must be smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx+1) && Math.abs( curNumber - bucket.get(bucketIdx+1) ) < width ){\\n        \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx-1) && Math.abs( curNumber - bucket.get(bucketIdx-1) ) < width ){\\n            \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket.set( bucketIdx,  curNumber );\\n        \\n        if( idx >= indexDiff ){\\n            \\n            let oldNumber = nums[ idx - indexDiff ];\\n            let oldNumberBucketIdx = Math.floor( oldNumber / width);\\n            bucket.delete( oldNumberBucketIdx );\\n        } \\n        \\n    }\\n    \\n   \\n    \\n    return false;\\n};\\n```\\n\\n---\\n\\n```\\n\\nGo:\\n\\nfunc Abs(x int) int {\\n    if x < 0{\\n        return -x\\n    }else{\\n        return x\\n    }\\n}\\n\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n \\n    \\n    //size := len(nums)\\n    \\n    bucket := make( map[int]int)\\n    \\n    width := t+1\\n    \\n    for idx, number := range nums{\\n        \\n        var bucketIdx int\\n        \\n        if number >= 0 {\\n            \\n            bucketIdx = number / width\\n            \\n        }else{\\n            \\n            // offset patch for negative number\\n            bucketIdx = (number / width) - 1\\n        }\\n        \\n        if _, exist := bucket[bucketIdx]; exist{\\n            \\n            // two numbers in the smae bucket, gap must be smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx+1]; exist && ( Abs( number - bucket[bucketIdx+1] ) < width ) {\\n            \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx-1]; exist && ( Abs(number - bucket[bucketIdx-1] ) < width ) {\\n        \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket[bucketIdx] = number\\n        \\n        if idx >= k{\\n            delete(bucket, (nums[idx - k] / width) )\\n        }\\n        \\n    }\\n    \\n    return false\\n}\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #217 Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)\\n\\n[Leetcode #219 Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii)\\n\\n[Leetcode #220 Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t == 0 and len(set(nums)) == len(nums):\\n            \\n            # Quick response for t = 0\\n            # t = 0 requires at least one pair of repeated element\\n            \\n            return False\\n            \\n        \\n        size = len(nums)\\n        \\n        bucket = {}\\n        \\n        width = t + 1\\n        \\n        for idx, number in enumerate(nums):\\n            \\n            bucket_idx = number // width\\n            \\n            if bucket_idx in bucket:\\n                \\n                # two numbers in the same bucket, gap must be smaller than width\\n                return True\\n            \\n            elif bucket_idx + 1 in bucket and abs(number - bucket[bucket_idx + 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            elif bucket_idx - 1 in bucket and abs(number - bucket[bucket_idx - 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            # put current number into corresponding bucket\\n            bucket[bucket_idx] = number\\n            \\n            \\n            if idx >= k:\\n                \\n                # delete old number whose index distance larger than k\\n                del bucket[ nums[idx-k] //width ]\\n                \\n        return False\\n```\n```\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n    if(  (valueDiff == 0) && ( new Set(nums).size == nums.length ) ) {\\n        \\n        // Quick response for valueDiff = 0\\n        // valueDiff = 9 requires at least one pair ofrepeated element\\n        return false;\\n    }\\n    \\n    // key: element value / width\\n    // value: corresponding element \\n    let bucket = new Map();\\n    \\n    const width = valueDiff + 1;\\n    \\n    for( let idx = 0 ; idx < nums.length ; idx++ ){\\n        \\n        let curNumber = nums[idx];\\n        \\n        let bucketIdx = Math.floor( curNumber / width );\\n        \\n        if( bucket.has(bucketIdx) ){\\n            \\n            // two numbers in the same bucket, gap must be smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx+1) && Math.abs( curNumber - bucket.get(bucketIdx+1) ) < width ){\\n        \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx-1) && Math.abs( curNumber - bucket.get(bucketIdx-1) ) < width ){\\n            \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket.set( bucketIdx,  curNumber );\\n        \\n        if( idx >= indexDiff ){\\n            \\n            let oldNumber = nums[ idx - indexDiff ];\\n            let oldNumberBucketIdx = Math.floor( oldNumber / width);\\n            bucket.delete( oldNumberBucketIdx );\\n        } \\n        \\n    }\\n    \\n   \\n    \\n    return false;\\n};\\n```\n```\\n\\nGo:\\n\\nfunc Abs(x int) int {\\n    if x < 0{\\n        return -x\\n    }else{\\n        return x\\n    }\\n}\\n\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n \\n    \\n    //size := len(nums)\\n    \\n    bucket := make( map[int]int)\\n    \\n    width := t+1\\n    \\n    for idx, number := range nums{\\n        \\n        var bucketIdx int\\n        \\n        if number >= 0 {\\n            \\n            bucketIdx = number / width\\n            \\n        }else{\\n            \\n            // offset patch for negative number\\n            bucketIdx = (number / width) - 1\\n        }\\n        \\n        if _, exist := bucket[bucketIdx]; exist{\\n            \\n            // two numbers in the smae bucket, gap must be smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx+1]; exist && ( Abs( number - bucket[bucketIdx+1] ) < width ) {\\n            \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx-1]; exist && ( Abs(number - bucket[bucketIdx-1] ) < width ) {\\n        \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket[bucketIdx] = number\\n        \\n        if idx >= k{\\n            delete(bucket, (nums[idx - k] / width) )\\n        }\\n        \\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825273,
                "title": "c-multiset-solution-with-detailed-explanation",
                "content": "```\\n// we can maintain a sliding window of K elements after ith element to satisfy the index condition(k)\\n// the idea is to maintain a BST of K elements, so that search, insert and delete can be done in O(log(k))\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    if (k == 0) return false;\\n\\n    multiset<long> kelements;\\n    int kend = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        long currentNum = nums[i];\\n        // remove ith element from the window\\n        auto curItr = kelements.find(currentNum);\\n        if (curItr != kelements.end()) kelements.erase(curItr);\\n\\n        // this inserts K elements when i = 0 and only 1 element for each subsequent iteration\\n        while (kelements.size() < k && kend < nums.size()) {\\n            kelements.insert(nums[kend]);\\n            kend++;\\n        }\\n\\n        // we need to find a number that is between currentNum - t and currentNum + t\\n        // so the smallest numer greater than or equal to currentNum - t should be our candidate\\n        // an alternate way is to find the largest number less than or equal to currentNum + t\\n        auto closest = kelements.lower_bound(currentNum - t);\\n\\n        // it is possible that no such number exists\\n        if (closest == kelements.end()) continue;\\n\\n        // check for the condition on the potential candidate\\n        if (abs(currentNum - *closest) <= t) return true;\\n    }\\n\\n    return false;\\n}\\n```\\n\\nTime Complexity: ``` O(nlog(k))```\\nSpace Complexity: ```O(k)```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Sliding Window"
                ],
                "code": "```\\n// we can maintain a sliding window of K elements after ith element to satisfy the index condition(k)\\n// the idea is to maintain a BST of K elements, so that search, insert and delete can be done in O(log(k))\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    if (k == 0) return false;\\n\\n    multiset<long> kelements;\\n    int kend = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        long currentNum = nums[i];\\n        // remove ith element from the window\\n        auto curItr = kelements.find(currentNum);\\n        if (curItr != kelements.end()) kelements.erase(curItr);\\n\\n        // this inserts K elements when i = 0 and only 1 element for each subsequent iteration\\n        while (kelements.size() < k && kend < nums.size()) {\\n            kelements.insert(nums[kend]);\\n            kend++;\\n        }\\n\\n        // we need to find a number that is between currentNum - t and currentNum + t\\n        // so the smallest numer greater than or equal to currentNum - t should be our candidate\\n        // an alternate way is to find the largest number less than or equal to currentNum + t\\n        auto closest = kelements.lower_bound(currentNum - t);\\n\\n        // it is possible that no such number exists\\n        if (closest == kelements.end()) continue;\\n\\n        // check for the condition on the potential candidate\\n        if (abs(currentNum - *closest) <= t) return true;\\n    }\\n\\n    return false;\\n}\\n```\n``` O(nlog(k))```\n```O(k)```",
                "codeTag": "Unknown"
            },
            {
                "id": 824538,
                "title": "java-treeset-easy-to-understand-o-n-log-k",
                "content": "Coming up with this solution, think of it like a number line.\\nIf you want the difference of x and y to be 0 then you want x = y (on top of each other).\\nAs you raise the allowed difference, think of the allowed range increasing in both positive and negative direction equally.\\nE.g. allowed distance is \\'k\\' then x can be in range [y - k, y +k] and y can be in range [x - k, x +k].\\n\\nAnd TreeSet is perfect for testing range.contains.\\n\\nYou could read about https://en.wikipedia.org/wiki/Interval_(mathematics).\\n\\n```\\n  public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    if (t < 0) {\\n      return false;\\n    }\\n\\n    // sliding window\\n\\t// Need ugly Long to handle int overflows.\\n    TreeSet<Long> set = new TreeSet<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      // abs difference\\n      // |nums[i] - nums[j]| <= t\\n\\n      // if nums[j] <= nums[i] then:\\n      // nums[i] - t <= nums[j]\\n\\n      // if nums[j] >= nums[i] then:\\n      // nums[j] <= t + nums[i]\\n\\n      // which is:\\n      // nums[i] - t <= nums[j] <= t + nums[i]\\n\\n      // basically, is there anything in the range [num - t, num + t]?\\n\\n      if (!set.subSet((long) nums[i] - t, true, (long) nums[i] + t, true).isEmpty()) {\\n        return true;\\n      }\\n\\n      set.add((long) nums[i]);\\n      if (set.size() > k) {\\n        set.remove((long) nums[i - k]);\\n      }\\n    }\\n    return false;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n  public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    if (t < 0) {\\n      return false;\\n    }\\n\\n    // sliding window\\n\\t// Need ugly Long to handle int overflows.\\n    TreeSet<Long> set = new TreeSet<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      // abs difference\\n      // |nums[i] - nums[j]| <= t\\n\\n      // if nums[j] <= nums[i] then:\\n      // nums[i] - t <= nums[j]\\n\\n      // if nums[j] >= nums[i] then:\\n      // nums[j] <= t + nums[i]\\n\\n      // which is:\\n      // nums[i] - t <= nums[j] <= t + nums[i]\\n\\n      // basically, is there anything in the range [num - t, num + t]?\\n\\n      if (!set.subSet((long) nums[i] - t, true, (long) nums[i] + t, true).isEmpty()) {\\n        return true;\\n      }\\n\\n      set.add((long) nums[i]);\\n      if (set.size() > k) {\\n        set.remove((long) nums[i - k]);\\n      }\\n    }\\n    return false;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 715483,
                "title": "java-brute-force-optimal-explained",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n    BRUTE FORCE APPROACH-----------------------------------------------------------------------------\\n\\n    The brute force approach is to account for the requirement: |i - j| <= k\\n    We can do this by iterating over every index as i, then calculate the MAX value\\n    of j such that the requirement is met.\\n    j <= k + i hence maxJ <= k + i.\\n    \\n    Now we know that for index i, we can use elements from i+1 up to maxJ to represent index j\\n    Given indices for j, we can now evalutate the second requirement for |nums[i] - nums[j]| <= t\\n    If that requirement is also true, we can return true.\\n    \\n    In the worst case, k == nums.length. So every index i can be paired with any other index j.\\n    So we would evalute each pair of i & j for both requirements.\\n    \\n    Time: O(N^2) | Space: O(1)\\n    \\n    OPTIMAL APPROACH-----------------------------------------------------------------------------\\n    \\n    Can we improve the time and space? Well yes we can. What if we evaluate the requirements\\n    differently? Let\\'s handle the |nums[i] - nums[j]| <= t first. To handle this requirement\\n    we can take some nums[i] and ask, \\n        \"Which values in the array are closest to nums[i]?\"\\n    \\n    This is a good question because the difference between 2 close elements will have the\\n    smallest difference! If the min possible difference does not satisfy the requirement then\\n    then no other values will satisfy it for the current nums[i], and we should move on\\n    to the next nums[i]. But finding the closest element can take N time for each nums[i] evaluated\\n    and this does not improve our time ;( so lets use some space!\\n    \\n    Which data structure can store values, and lookup the nearest values to any nums[i] we give?\\n    Well we would have to sort these values, so one data structure that sorts elements and has\\n    a good lookup time is a TreeSet! The TreeSet can get the successor of a value with .ceiling(nums[i])\\n    and the predecessor of a value with .floor(nums[i]) and a single lookup is log(N) time.\\n    \\n    But how do we handle the first requirement where |i-j| <= k ???\\n    This requirement sets a window of elements we can examine for our floor annd ceiling, so\\n    we can make sure that our TreeSet holds at most K elements! Simply remove nums[i-k]\\n\\tfrom the set when the size exceeds k.\\n\\n\\tTime: O(N*log(K)) | Space: O(K) but K can be equal to N so...\\n    Time: O(N*log(N)) | Space: O(N)\\n\\n    */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> sortedWindow = new TreeSet<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            Integer numJ = sortedWindow.ceiling(nums[i]); //get successor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            numJ = sortedWindow.floor(nums[i]); //get predecessor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            sortedWindow.add(nums[i]); //add value to set\\n            \\n            if (sortedWindow.size() > k) //keep window at most length k from index i\\n                sortedWindow.remove(nums[i-k]);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public static boolean bruteForce(int[] nums, int k, int t) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int maxJ = Math.min(k + i, nums.length - 1);\\n            for (int j = i + 1; j <= maxJ; j++) {\\n                long diff = Math.abs((long) nums[i] - (long) nums[j]);\\n                if (diff <= t) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    /*\\n    BRUTE FORCE APPROACH-----------------------------------------------------------------------------\\n\\n    The brute force approach is to account for the requirement: |i - j| <= k\\n    We can do this by iterating over every index as i, then calculate the MAX value\\n    of j such that the requirement is met.\\n    j <= k + i hence maxJ <= k + i.\\n    \\n    Now we know that for index i, we can use elements from i+1 up to maxJ to represent index j\\n    Given indices for j, we can now evalutate the second requirement for |nums[i] - nums[j]| <= t\\n    If that requirement is also true, we can return true.\\n    \\n    In the worst case, k == nums.length. So every index i can be paired with any other index j.\\n    So we would evalute each pair of i & j for both requirements.\\n    \\n    Time: O(N^2) | Space: O(1)\\n    \\n    OPTIMAL APPROACH-----------------------------------------------------------------------------\\n    \\n    Can we improve the time and space? Well yes we can. What if we evaluate the requirements\\n    differently? Let\\'s handle the |nums[i] - nums[j]| <= t first. To handle this requirement\\n    we can take some nums[i] and ask, \\n        \"Which values in the array are closest to nums[i]?\"\\n    \\n    This is a good question because the difference between 2 close elements will have the\\n    smallest difference! If the min possible difference does not satisfy the requirement then\\n    then no other values will satisfy it for the current nums[i], and we should move on\\n    to the next nums[i]. But finding the closest element can take N time for each nums[i] evaluated\\n    and this does not improve our time ;( so lets use some space!\\n    \\n    Which data structure can store values, and lookup the nearest values to any nums[i] we give?\\n    Well we would have to sort these values, so one data structure that sorts elements and has\\n    a good lookup time is a TreeSet! The TreeSet can get the successor of a value with .ceiling(nums[i])\\n    and the predecessor of a value with .floor(nums[i]) and a single lookup is log(N) time.\\n    \\n    But how do we handle the first requirement where |i-j| <= k ???\\n    This requirement sets a window of elements we can examine for our floor annd ceiling, so\\n    we can make sure that our TreeSet holds at most K elements! Simply remove nums[i-k]\\n\\tfrom the set when the size exceeds k.\\n\\n\\tTime: O(N*log(K)) | Space: O(K) but K can be equal to N so...\\n    Time: O(N*log(N)) | Space: O(N)\\n\\n    */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> sortedWindow = new TreeSet<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            Integer numJ = sortedWindow.ceiling(nums[i]); //get successor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            numJ = sortedWindow.floor(nums[i]); //get predecessor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            sortedWindow.add(nums[i]); //add value to set\\n            \\n            if (sortedWindow.size() > k) //keep window at most length k from index i\\n                sortedWindow.remove(nums[i-k]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 367234,
                "title": "python-o-n-solution-using-sliding-window-and-dict",
                "content": "We need to find `i`, `j` such that `|i-j|<=k` and `|nums[i]-nums[j]|<=t`, we use sliding window to mainteniance the nums before nums[i] when we use for iteration.\\n\\nWe can see that `|nums[i]-nums[j]|<=t` is equalivalent `|nums[i]/t-nums[j]/t|<=1`, which we can obtain `|floor(nums[i]/t)-floor(nums[j]/t)|<=1` and we call it (1). We can easily see if (1) doesn\\'t hold, then `|nums[i]-nums[j]>t|`, thus we only need to consider j satisfies (1).\\n\\nWe use dict to solve this, the key is `floor(nums[i]/t)` and the value is `nums[i]`.\\n\\n\\n```python\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or k < 1 or t < 0:\\n            return False\\n        \\n        n = len(nums)\\n        l = 0\\n        d = {nums[0] // max(1, t): nums[0]}\\n        for r in range(1, n):\\n            if r - l == k + 1:\\n                d.pop(nums[l] // max(1, t))\\n                l += 1\\n            tmp = nums[r] // max(1, t)\\n            for key in {tmp-1, tmp, tmp+1}:\\n                if key in d and abs(d.get(key) - nums[r]) <= t:\\n                    return True\\n            d[tmp] = nums[r]\\n            \\n        return False\\n```\\n\\nThere are some other solutions in my Notion HomePage:\\nhttps://www.notion.so/quicy/Contains-Duplicate-III-db8e5402b20d481cb29daaf1cd7f6e59\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or k < 1 or t < 0:\\n            return False\\n        \\n        n = len(nums)\\n        l = 0\\n        d = {nums[0] // max(1, t): nums[0]}\\n        for r in range(1, n):\\n            if r - l == k + 1:\\n                d.pop(nums[l] // max(1, t))\\n                l += 1\\n            tmp = nums[r] // max(1, t)\\n            for key in {tmp-1, tmp, tmp+1}:\\n                if key in d and abs(d.get(key) - nums[r]) <= t:\\n                    return True\\n            d[tmp] = nums[r]\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61650,
                "title": "c-bst-o-nlogk-84-64",
                "content": "Or just use `std::set`, implementing BST in C++ is a pain in ass.\\n\\n```\\n/**\\n * class TreeNode {\\n * public:\\n *     int val;\\n *     TreeNode* left;\\n *     TreeNode* right;\\n * \\n *     TreeNode(int val) {\\n *         this->val = val;\\n *         this->left = nullptr;\\n *         this->right = nullptr;\\n *     }\\n * };\\n */\\nclass BST {\\npublic:\\n    TreeNode* root;\\n    \\n    BST() {\\n        root = nullptr;\\n    }\\n    \\n    TreeNode* insert(int val) {\\n        root = insert(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* now, int val) {\\n        if (!now) now = new TreeNode(val);\\n        else if (val > now->val) now->right = insert(now->right, val);\\n        else if (val < now->val) now->left = insert(now->left, val);\\n        return now;\\n    }\\n    \\n    TreeNode* remove(int val) {\\n        root = remove(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* remove(TreeNode* now, int val) {\\n        if (!now) {\\n            return nullptr;\\n        } else if (val < now->val) {\\n            now->left = remove(now->left, val);\\n        } else if (val > now->val) {\\n            now->right = remove(now->right, val);\\n        } else {\\n            if (!now->left) {\\n                TreeNode *tmp = now->right;\\n                delete now;\\n                return tmp;\\n            } else if (!now->right) {\\n                TreeNode *tmp = now->left;\\n                delete now;\\n                return tmp;\\n            } else {\\n                TreeNode *tmp = now->right;\\n                while (tmp->left) tmp = tmp->left;\\n                now->val = tmp->val;\\n                now->right = remove(now->right, now->val);\\n            }\\n        }\\n        return now;\\n    }\\n    \\n    bool search(int val, int t) {\\n        return search(root, val, t);\\n    }\\n    \\n    bool search(TreeNode* now, long val, int t) {\\n        if (!now) return false;\\n        else if (abs(val - now->val) <= t) return true;\\n        else if (now->val - t > val) return search(now->left, val, t);\\n        else return search(now->right, val, t);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (nums.empty() || k == 0) return false;\\n        BST bst;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            bst.insert(nums[i - 1]);\\n            if (i > k) bst.remove(nums[i - k - 1]);\\n            if (bst.search(long(nums[i]), t)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * class TreeNode {\\n * public:\\n *     int val;\\n *     TreeNode* left;\\n *     TreeNode* right;\\n * \\n *     TreeNode(int val) {\\n *         this->val = val;\\n *         this->left = nullptr;\\n *         this->right = nullptr;\\n *     }\\n * };\\n */\\nclass BST {\\npublic:\\n    TreeNode* root;\\n    \\n    BST() {\\n        root = nullptr;\\n    }\\n    \\n    TreeNode* insert(int val) {\\n        root = insert(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* now, int val) {\\n        if (!now) now = new TreeNode(val);\\n        else if (val > now->val) now->right = insert(now->right, val);\\n        else if (val < now->val) now->left = insert(now->left, val);\\n        return now;\\n    }\\n    \\n    TreeNode* remove(int val) {\\n        root = remove(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* remove(TreeNode* now, int val) {\\n        if (!now) {\\n            return nullptr;\\n        } else if (val < now->val) {\\n            now->left = remove(now->left, val);\\n        } else if (val > now->val) {\\n            now->right = remove(now->right, val);\\n        } else {\\n            if (!now->left) {\\n                TreeNode *tmp = now->right;\\n                delete now;\\n                return tmp;\\n            } else if (!now->right) {\\n                TreeNode *tmp = now->left;\\n                delete now;\\n                return tmp;\\n            } else {\\n                TreeNode *tmp = now->right;\\n                while (tmp->left) tmp = tmp->left;\\n                now->val = tmp->val;\\n                now->right = remove(now->right, now->val);\\n            }\\n        }\\n        return now;\\n    }\\n    \\n    bool search(int val, int t) {\\n        return search(root, val, t);\\n    }\\n    \\n    bool search(TreeNode* now, long val, int t) {\\n        if (!now) return false;\\n        else if (abs(val - now->val) <= t) return true;\\n        else if (now->val - t > val) return search(now->left, val, t);\\n        else return search(now->right, val, t);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (nums.empty() || k == 0) return false;\\n        BST bst;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            bst.insert(nums[i - 1]);\\n            if (i > k) bst.remove(nums[i - k - 1]);\\n            if (bst.search(long(nums[i]), t)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61783,
                "title": "a-c-o-nlogk-solution-by-using-sortedset",
                "content": "EDIT: Fix it by using SortedSet.GetViewBetween\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if(t < 0) return false;\\n        SortedSet<long> ss = new SortedSet<long>();\\n        for(int i = 0; i < nums.Length; i++){\\n            if(ss.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            ss.Add(nums[i]);\\n            if(i >= k) ss.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n\\nBelow is the old version of O(Log(N*K))\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        SortedList<int, int> sdc = new SortedList<int, int>();\\n        for (int i = 0; i < nums.Length && k != 0; i++){\\n            for (int j = 0, l = sdc.Count - 1; j <= l;)\\n                if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2]  > (long)t)\\n                    l = (j + l) / 2 - 1;\\n                else if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2] < -(long)t)\\n                    j = (j + l) / 2 + 1;\\n                else return true;\\n            if (sdc.Count == k)\\n               sdc.RemoveAt(sdc.IndexOfValue(i - k));\\n            sdc.Add(nums[i], i);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "EDIT: Fix it by using SortedSet.GetViewBetween\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if(t < 0) return false;\\n        SortedSet<long> ss = new SortedSet<long>();\\n        for(int i = 0; i < nums.Length; i++){\\n            if(ss.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            ss.Add(nums[i]);\\n            if(i >= k) ss.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n\\nBelow is the old version of O(Log(N*K))\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        SortedList<int, int> sdc = new SortedList<int, int>();\\n        for (int i = 0; i < nums.Length && k != 0; i++){\\n            for (int j = 0, l = sdc.Count - 1; j <= l;)\\n                if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2]  > (long)t)\\n                    l = (j + l) / 2 - 1;\\n                else if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2] < -(long)t)\\n                    j = (j + l) / 2 + 1;\\n                else return true;\\n            if (sdc.Count == k)\\n               sdc.RemoveAt(sdc.IndexOfValue(i - k));\\n            sdc.Add(nums[i], i);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1838689,
                "title": "o-nlogn-sliding-window-multiset-binary-search-based-solution",
                "content": "```\\n#define ll long long\\n#define push insert\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n       \\n        multiset<ll>st;\\n        for(ll i=0;i<nums.size();i++)\\n       {\\n            if(!st.size())\\n                st.push(nums[i]);\\n            \\n            else\\n            {\\n                if(st.size()>k)\\n                {\\n                     st.erase(nums[i-k-1]);\\n                }\\n                 \\n                \\n                if(st.size())\\n                {\\n                    auto x=st.lower_bound((ll)nums[i]-t);\\n               if(x!=st.end()&&*x<=(ll)nums[i]+t)\\n               {\\n                    return 1;\\n               }\\n                   \\n                if(abs(nums[i]-*st.begin())<=t)\\n                {\\n                     return 1;\\n                }\\n\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n  \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/b367c6c4-6008-479e-a820-9a512c23e323_1646977841.2182415.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\n#define push insert\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n       \\n        multiset<ll>st;\\n        for(ll i=0;i<nums.size();i++)\\n       {\\n            if(!st.size())\\n                st.push(nums[i]);\\n            \\n            else\\n            {\\n                if(st.size()>k)\\n                {\\n                     st.erase(nums[i-k-1]);\\n                }\\n                 \\n                \\n                if(st.size())\\n                {\\n                    auto x=st.lower_bound((ll)nums[i]-t);\\n               if(x!=st.end()&&*x<=(ll)nums[i]+t)\\n               {\\n                    return 1;\\n               }\\n                   \\n                if(abs(nums[i]-*st.begin())<=t)\\n                {\\n                     return 1;\\n                }\\n\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848915,
                "title": "javascript-bucket-sort-o-n",
                "content": "```\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let bucket = {}, w = t+1;\\n    for (let i =0;i<nums.length;i++) {\\n        idx = Math.floor(nums[i]/w);\\n        if (bucket.hasOwnProperty(idx)) return true;\\n        else if (bucket.hasOwnProperty(idx+1) && Math.abs(nums[i] - bucket[idx+1]) < w) return true;\\n        else if (bucket.hasOwnProperty(idx-1) && Math.abs(nums[i] - bucket[idx-1]) < w) return true;\\n        bucket[idx] = nums[i];\\n        if (i >= k) {\\n            delete bucket[Math.floor(nums[i-k]/w)];\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bucket Sort"
                ],
                "code": "```\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let bucket = {}, w = t+1;\\n    for (let i =0;i<nums.length;i++) {\\n        idx = Math.floor(nums[i]/w);\\n        if (bucket.hasOwnProperty(idx)) return true;\\n        else if (bucket.hasOwnProperty(idx+1) && Math.abs(nums[i] - bucket[idx+1]) < w) return true;\\n        else if (bucket.hasOwnProperty(idx-1) && Math.abs(nums[i] - bucket[idx-1]) < w) return true;\\n        bucket[idx] = nums[i];\\n        if (i >= k) {\\n            delete bucket[Math.floor(nums[i-k]/w)];\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825714,
                "title": "a-few-solutions",
                "content": "**Synopsis:**\\n\\nUse a sliding window of size `K`.  Return true immediately if two values within the window differ by less-than `T`.  To reduce the asymptotic bound for finding candidates within the window who\\'s values may differ by less-than `T`, use buckets who\\'s key is the value divided by `T`.  We divide into buckets of size `T` because only values in adjacent buckets are candidates who\\'s values may differ by less-than `T`, ie. if two candidates are two or more `T` bucket away from eachother, then their difference cannot be less-than `T` due to the fact that their values differ by greater-than `T` by definition of each bucket size `T`.  Candidates in the same bucket differ by less-than `T` due to the fact that each bucket covers a range of `T` values.\\n\\nLet `N` denote the cardinality of `A`, then we have `N / T` buckets, each covering a range of size `T` values.  Let `j` denote an arbitrary bucket.  Map each `i`<sup>th</sup> value in `A` to a `j`<sup>th</sup> bucket, and there are 3 use cases to consider for each `j`<sup>th</sup> bucket:\\n\\n* **Case 1:** there exists a value in the `\\uD83D\\uDC48 ` adjacent bucket to-the-left who\\'s difference with `A[i]` is less-than `T`\\n* **Case 2:** there already exists a value in the `\\uD83C\\uDFAF` same `j`<sup>th</sup> bucket\\n* **Case 3:** there exists a value in the `\\uD83D\\uDC49` adjacent bucket to-the-right who\\'s difference with `A[i]` is less-than `T`\\n\\nAnd we return true for any of those 3 use cases.  Otherwise return false.\\n\\n**Notes:**\\n* When `T == 0`, the bucket key would be equal to infinity, thus we add 1 for this use case to avoid division by 0.\\n* For the use case in which the same bucket is added onto the sliding window and simultaneously removed from the sliding window, it is important to add the value onto the window *before* removing the value from the window because the `i - K`<sup>th</sup> value which \"fell off the end\" of the window of size `K` is non-inclusive of the window of size `K`, ie. the window has \"slid\" to-the-right `\\uD83D\\uDC49` by one position to occupy `[i - K + 1 .. i]`, and `i`<sup>th</sup> value is added onto the window *before* the `i - K`<sup>th</sup> value is removed from the window.\\n* We only need to store one value per bucket, because we will return true immediately if there exists two values mapped to the same bucket.  Let `m[j] = A[i]` denote the the `i`<sup>th</sup> value of `A` is mapped to the `j`<sup>th</sup> bucket.\\n* A data type larger than a 32-bit integer is needed to store the result of the absolute differences of the 32-bit integer values in `A`, since C++ is the only statically typed language below, I explicitly chose to use a `long long` to store the map\\'s value, whereas the data type is implicit for Javascript and Python3.\\n\\n---\\n\\n**Similiar Problems:**\\n\\n* [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/discuss/824996/Javascript-Python3-C%2B%2B-1-Liners-Seen-Set)\\n* [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/825078/javascript-python3-c-sliding-window-seen-set)\\n\\n---\\n\\n*Javascript*\\n```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, A: List[int], K: int, T: int) -> bool:\\n        m = {}\\n        N = len(A)\\n        if N < 2:\\n            return False\\n        bucket = lambda x: x // T if T else x // (T + 1)  # \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        ok = lambda i, j: j in m and abs(m[j] - A[i]) <= T\\n        for i in range(N):\\n\\t\\t\\t#  1. check each j-th bucket for case 1 || case 2 || case 3\\n            j = bucket(A[i])\\n            if ok(i, j - 1) or ok(i, j) or ok(i, j + 1):  # (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return True\\n            # slide window \\uD83D\\uDC49\\n            m[j] = A[i]                 # \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if 0 <= i - K:\\n                end = bucket(A[i - K])  # \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                del m[end]\\n        return False\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, long long>;\\n    bool containsNearbyAlmostDuplicate(VI& A, int K, int T, Map m = {}) {\\n        int N = A.size();\\n        if (N < 2)\\n            return false;\\n        auto bucket = [=](auto x) { return T ? x / T : x / (T + 1); };  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        auto ok = [&](auto i, auto j) { return m.find(j) != m.end() && abs(m[j] - A[i]) <= T; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            // 1. check each j-th bucket for case 1 || case 2 || case 3\\n            auto j = bucket(A[i]);\\n            if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return true;\\n            // 2. slide window \\uD83D\\uDC49\\n            m[j] = A[i];                      // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if (0 <= i - K) {\\n                auto end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                m.erase(end);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, A: List[int], K: int, T: int) -> bool:\\n        m = {}\\n        N = len(A)\\n        if N < 2:\\n            return False\\n        bucket = lambda x: x // T if T else x // (T + 1)  # \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        ok = lambda i, j: j in m and abs(m[j] - A[i]) <= T\\n        for i in range(N):\\n\\t\\t\\t#  1. check each j-th bucket for case 1 || case 2 || case 3\\n            j = bucket(A[i])\\n            if ok(i, j - 1) or ok(i, j) or ok(i, j + 1):  # (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return True\\n            # slide window \\uD83D\\uDC49\\n            m[j] = A[i]                 # \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if 0 <= i - K:\\n                end = bucket(A[i - K])  # \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                del m[end]\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, long long>;\\n    bool containsNearbyAlmostDuplicate(VI& A, int K, int T, Map m = {}) {\\n        int N = A.size();\\n        if (N < 2)\\n            return false;\\n        auto bucket = [=](auto x) { return T ? x / T : x / (T + 1); };  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        auto ok = [&](auto i, auto j) { return m.find(j) != m.end() && abs(m[j] - A[i]) <= T; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            // 1. check each j-th bucket for case 1 || case 2 || case 3\\n            auto j = bucket(A[i]);\\n            if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return true;\\n            // 2. slide window \\uD83D\\uDC49\\n            m[j] = A[i];                      // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if (0 <= i - K) {\\n                auto end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                m.erase(end);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824742,
                "title": "java-clean-code-sliding-window-and-binary-search-tree-treeset",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate (int[] nums, int k, int t) {\\n\\t\\t\\n\\t\\tTreeSet<Integer> set = new TreeSet <>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tInteger leftMax = set.floor (nums[i]);\\n\\t\\t\\tInteger rightMin = set.ceiling (nums[i]);\\n\\t\\t\\tif ((leftMax != null && (long) nums[i] - leftMax <= t) || (rightMin != null && (long) rightMin - nums[i] <= t)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tset.add (nums[i]);\\n\\t\\t\\tif (i >= k) {\\n\\t\\t\\t\\tset.remove (nums[i - k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nTime Complexity: O(N log N)\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate (int[] nums, int k, int t) {\\n\\t\\t\\n\\t\\tTreeSet<Integer> set = new TreeSet <>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tInteger leftMax = set.floor (nums[i]);\\n\\t\\t\\tInteger rightMin = set.ceiling (nums[i]);\\n\\t\\t\\tif ((leftMax != null && (long) nums[i] - leftMax <= t) || (rightMin != null && (long) rightMin - nums[i] <= t)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tset.add (nums[i]);\\n\\t\\t\\tif (i >= k) {\\n\\t\\t\\t\\tset.remove (nums[i - k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nTime Complexity: O(N log N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824545,
                "title": "java-10ms-beats-87-time-binary-src-idea-easy-explained-o-nlogn",
                "content": "```\\n// idea is that we can solve it using brute force which wil give O(nk) avg case bt worst case \\n // On^2  where k = n, it might give tle , so to improve we can sort the temp capy array once \\n // and then binary search for every elt in nums , if we can find an elt in temp which satifies 3 conditions \\n // 1 . abs(nums[i] - temp [i] [1] ) <= t \\n // 2.  abs ( i - temp[i][0]) <= k\\n // 3 . i != temp[i][0] , so now we get two seperate loops both Onlogn \\n // and we know On + On = On , so Onlogn + Onlogn = Onlogn\\n \\nclass Solution {\\n    private static boolean binSrc(int [][] temp , int val , int i ,int k , int t){\\n        int low = 0 ;\\n        int high = temp.length - 1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2; \\n            long n_dif = (long)temp[mid][1] - (long)val; // take long to prevent integer over flow\\n            int i_diff = temp[mid][0] - i;\\n            // if we find an elt satisfying the two condtions also , they are diiferent elts , ie ->  i != j \\n            if( Math.abs(n_dif) <= t && Math.abs(i_diff) <= k && temp[mid][0] != i)\\n                return true;\\n            // else if abs diff b/w val and curr_mid elt > t our possible ans lies on the left part \\n            else if(Math.abs(n_dif) > t)\\n                high = mid - 1 ;\\n            else  // else our possible lies on the right part \\n                low = mid + 1;\\n           \\n        }\\n        return false;\\n    }\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        // temporary pair arr , tmp [i][0] = index , tmp[i][1] = its coresponding elt\\n        int temp [][] = new int [nums.length][2];\\n        for(int i = 0 ; i < nums.length ; i++){\\n            temp[i][0] = i; // index\\n            temp[i][1] = nums[i]; // elt \\n        }\\n        // sort in  ascending order of elts \\n        Arrays.sort(temp, (a,b) -> {\\n            return a[1] - b[1];\\n        });\\n        // for every elt in unsorted nums , binary src the sorted tmp array and check the given condition \\n        // required in question\\n        for(int i = 0 ; i < nums.length ; i++){\\n            int elt = nums[i];\\n            if(binSrc(temp,elt,i, k,t))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n// hope it helps , tysm , if u",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\n    private static boolean binSrc(int [][] temp , int val , int i ,int k , int t){\\n        int low = 0 ;\\n        int high = temp.length - 1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2; \\n            long n_dif = (long)temp[mid][1] - (long)val; // take long to prevent integer over flow\\n            int i_diff = temp[mid][0] - i;\\n            // if we find an elt satisfying the two condtions also , they are diiferent elts , ie ->  i != j \\n            if( Math.abs(n_dif) <= t && Math.abs(i_diff) <= k && temp[mid][0] != i)\\n                return true;\\n            // else if abs diff b/w val and curr_mid elt > t our possible ans lies on the left part \\n            else if(Math.abs(n_dif) > t)\\n                high = mid - 1 ;\\n            else  // else our possible lies on the right part \\n                low = mid + 1;\\n           \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 512781,
                "title": "java-simple-with-detailed-explanation",
                "content": "```\\n   // core logic: sliding window + tree set. maintain the tree set in such a way that it always contains K elements and slide them accordingly (remove 1st element when we reach size >=k, etc..)\\n    // the fact that the absolute diff should always be utmost t means that we need to check the greatest low and lowest high for all the elements. if that satisfies the given condition, return true. eg: if t = 2 and nums[i] = 4, for the condition to be true the greatest element smaller than 4 should be in between 2 and 4, while smallest element greater than 4 should lie between 4 and 6. \\n    // TC: O(NlogK) - as the size of tree set is always k and n is the size of the array\\n    private static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length <= 1) {\\n            return false;\\n        }\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer low = treeSet.floor(nums[i]);   // get the greatest element smaller than this number\\n            Integer high = treeSet.ceiling(nums[i]);  // get the smallest element greater than this number\\n\\n            if ((low != null && (long) nums[i] - low <= t) || (high != null && (long) high - nums[i] <= t)) {   // check for absolute differences\\n                return true;\\n            }\\n            treeSet.add(nums[i]);\\n\\n            if (i >= k) {   // remove the first element when size of the tree set exceeds K\\n                treeSet.remove(nums[i - k]);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   // core logic: sliding window + tree set. maintain the tree set in such a way that it always contains K elements and slide them accordingly (remove 1st element when we reach size >=k, etc..)\\n    // the fact that the absolute diff should always be utmost t means that we need to check the greatest low and lowest high for all the elements. if that satisfies the given condition, return true. eg: if t = 2 and nums[i] = 4, for the condition to be true the greatest element smaller than 4 should be in between 2 and 4, while smallest element greater than 4 should lie between 4 and 6. \\n    // TC: O(NlogK) - as the size of tree set is always k and n is the size of the array\\n    private static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length <= 1) {\\n            return false;\\n        }\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer low = treeSet.floor(nums[i]);   // get the greatest element smaller than this number\\n            Integer high = treeSet.ceiling(nums[i]);  // get the smallest element greater than this number\\n\\n            if ((low != null && (long) nums[i] - low <= t) || (high != null && (long) high - nums[i] <= t)) {   // check for absolute differences\\n                return true;\\n            }\\n            treeSet.add(nums[i]);\\n\\n            if (i >= k) {   // remove the first element when size of the tree set exceeds K\\n                treeSet.remove(nums[i - k]);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61777,
                "title": "ac-python-code-using-window-and-bucketing",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @param {integer} k\\n        # @param {integer} t\\n        # @return {boolean}\\n        def containsNearbyAlmostDuplicate(self, nums, k, t):\\n            if k <= 0 or t < 0:\\n                return False\\n            numsDict = {}\\n            for i in range(len(nums)):\\n                bucket = nums[i]/(t+1)\\n                for key in [bucket-1, bucket, bucket+1]:\\n                    if key in numsDict and abs(numsDict[key] - nums[i]) <= t:\\n                        return True\\n                numsDict[bucket] = nums[i]\\n                if i+1 > k:\\n                    pop_key = nums[i-k]/(t+1)\\n                    numsDict.pop(pop_key)\\n            return False\\n\\nBasically, I kept a window of size k and put all integers in that window into buckets. The index of the bucket is integer mod (t+1), as to avoid zeroDivisionError when t = 0. The runtime should be O(n) for this algorithm.",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3227563,
                "title": "220-time-94-72-and-space-92-33-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution uses bucketing technique to solve the problem.\\n\\n1. First, we check if the input list nums is not empty and if indexDiff is greater than 0 and valueDiff is non-negative. If not, we return False as no such pair exists.\\n\\n2. We find the minimum value in the list nums.\\n\\n3. We set the diff as valueDiff + 1. This is because, in case valueDiff is 0, we need to ensure that a difference of 0 is allowed.\\n\\n4. We create an empty dictionary bucket to store the elements in the current and adjacent buckets.\\n\\n5. We define a function getKey which takes an integer num as input and returns the key of the bucket to which the element belongs.\\n\\n6. We iterate through each element in the list nums along with its index i. For each element, we get its corresponding key using getKey function.\\n\\n7. We first check if the element already exists in the current bucket. If yes, then we return True as we have found the required pair.\\n\\n8. If not, we check if the left adjacent bucket exists and if the difference between the current element and the maximum element in the left adjacent bucket is less than diff. If yes, then we return True.\\n\\n9. Similarly, we check if the right adjacent bucket exists and if the difference between the minimum element in the right adjacent bucket and the current element is less than diff. If yes, then we return True.\\n\\n10. If none of the above conditions hold, we add the current element to the bucket with the key as the value returned by getKey. We also remove the element from the bucket whose index is greater than or equal to indexDiff.\\n\\n11. Finally, if no such pair exists in the entire list, we return False.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n94.72%\\n- Space complexity:\\nBeats\\n92.33%\\n\\n# Code\\n```\\nclass Solution:\\n  def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n    if not nums or indexDiff <= 0 or valueDiff < 0:\\n      return False\\n\\n    mini = min(nums)\\n    diff = valueDiff + 1  # In case of valueDiff = 0\\n    bucket = {}\\n\\n    def getKey(num: int) -> int:\\n      return (num - mini) // diff\\n\\n    for i, num in enumerate(nums):\\n      key = getKey(num)\\n      if key in bucket:  # Current bucket\\n        return True\\n      # Left adjacent bucket\\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\\n        return True\\n      # Right adjacent bucket\\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\\n        return True\\n      bucket[key] = num\\n      if i >= indexDiff:\\n        del bucket[getKey(nums[i - indexDiff])]\\n\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n  def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n    if not nums or indexDiff <= 0 or valueDiff < 0:\\n      return False\\n\\n    mini = min(nums)\\n    diff = valueDiff + 1  # In case of valueDiff = 0\\n    bucket = {}\\n\\n    def getKey(num: int) -> int:\\n      return (num - mini) // diff\\n\\n    for i, num in enumerate(nums):\\n      key = getKey(num)\\n      if key in bucket:  # Current bucket\\n        return True\\n      # Left adjacent bucket\\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\\n        return True\\n      # Right adjacent bucket\\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\\n        return True\\n      bucket[key] = num\\n      if i >= indexDiff:\\n        del bucket[getKey(nums[i - indexDiff])]\\n\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267867,
                "title": "sliding-window-multiset-o-n-log-k-easy-c-solution",
                "content": "So the idea is to make windows of k+1 (as (k+1-1) - 0 <= k) size in which the elements are sorted.\\nIt can be done with multiset.\\nNow lets understand with an example.\\n\\nLets suppose there is a window of size k+1 and some t (given)\\n\\nNow as soon as we found a consecutive pair of elements whose difference is <= t,\\nWe return true (as our window is of k+1 already size and we found diff <= t).\\n\\nOtherwise lets suppose a new element comes into play (say x at index k) and\\n\\nu = upper_bound(x) in a[0...k], return true if u - x <= t\\np = previous of upper bound, return true if x - p <= t\\n\\nelse, remove the (i-k)th element from the window and continue to next element.\\n\\nreturn false if no such element was found in the entire process.\\n\\n```\\na[] = 17 4 1 14 11 7 25 2 15 7\\nk = 4\\nt = 2\\n| 1 4 11 14 17 | 7 25 2 15 7\\n    3  7  3  3\\n17 | 1 4 7 11 14 | 25 2 15 7\\n       3 3  4  3\\n17 4 | 1 7 11 14 25 | 2 15 7\\n         6  4  3 11\\n17 4 1 | 2 7 11 14 25 | 15 7\\n           5  4  3 11\\n17 4 1 14 | 2 7 11 15 25 | 7\\n              5  4  4 10\\n17 4 1 14 11 | 2 7 7 15 25 |\\n                 5 0  8 10         0 <= t so return true\\n```\\n\\n\\n\\n```\\nstruct Solution {\\n\\n    bool containsNearbyAlmostDuplicate(vector<int> &a, int k, int t) {\\n        \\n        int n = a.size();\\n        k = min(k, n);\\n        \\n        multiset<long long> s(a.begin(), a.begin() + k);\\n        \\n        auto x = s.begin();\\n        \\n        for (int j = 1, i = *x; j < k; ++j) {\\n            ++x;\\n            if (*x - i <= t) {\\n                return 1;\\n            }\\n            i = *x;\\n        }\\n        \\n        for (int i = k; i < n; ++i) {\\n            \\n            x = s.upper_bound(a[i]);\\n            \\n            if (x != s.end() && *x - a[i] <= t) {\\n                return 1;\\n            }\\n            if (x != s.begin()) {\\n                --x;\\n                if (a[i] - *x <= t) {\\n                    return 1;\\n                }\\n            }\\n            \\n            s.insert(a[i]);\\n            s.erase(a[i-k]);\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\nPS: Please upvote, if found helpful...",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\na[] = 17 4 1 14 11 7 25 2 15 7\\nk = 4\\nt = 2\\n| 1 4 11 14 17 | 7 25 2 15 7\\n    3  7  3  3\\n17 | 1 4 7 11 14 | 25 2 15 7\\n       3 3  4  3\\n17 4 | 1 7 11 14 25 | 2 15 7\\n         6  4  3 11\\n17 4 1 | 2 7 11 14 25 | 15 7\\n           5  4  3 11\\n17 4 1 14 | 2 7 11 15 25 | 7\\n              5  4  4 10\\n17 4 1 14 11 | 2 7 7 15 25 |\\n                 5 0  8 10         0 <= t so return true\\n```\n```\\nstruct Solution {\\n\\n    bool containsNearbyAlmostDuplicate(vector<int> &a, int k, int t) {\\n        \\n        int n = a.size();\\n        k = min(k, n);\\n        \\n        multiset<long long> s(a.begin(), a.begin() + k);\\n        \\n        auto x = s.begin();\\n        \\n        for (int j = 1, i = *x; j < k; ++j) {\\n            ++x;\\n            if (*x - i <= t) {\\n                return 1;\\n            }\\n            i = *x;\\n        }\\n        \\n        for (int i = k; i < n; ++i) {\\n            \\n            x = s.upper_bound(a[i]);\\n            \\n            if (x != s.end() && *x - a[i] <= t) {\\n                return 1;\\n            }\\n            if (x != s.begin()) {\\n                --x;\\n                if (a[i] - *x <= t) {\\n                    return 1;\\n                }\\n            }\\n            \\n            s.insert(a[i]);\\n            s.erase(a[i-k]);\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2048581,
                "title": "python-sliding-window-sortedlist-simple-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        window = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: \\n                window.remove(nums[i-k-1])   \\n            idx1 = SortedList.bisect_left(window, nums[i] - t)\\n            idx2 = SortedList.bisect_right(window, nums[i] + t)\\n            \\n            if idx1 != idx2 and idx1 != len(window): \\n                return True\\n            \\n            window.add(nums[i])\\n        \\n        return False\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        window = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: \\n                window.remove(nums[i-k-1])   \\n            idx1 = SortedList.bisect_left(window, nums[i] - t)\\n            idx2 = SortedList.bisect_right(window, nums[i] + t)\\n            \\n            if idx1 != idx2 and idx1 != len(window): \\n                return True\\n            \\n            window.add(nums[i])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488457,
                "title": "20-ms-faster-than-97-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int,int>> res;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            res.push_back({nums[i],i});\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            for(int j = i+1; j<res.size(); j++)\\n            {\\n                if(abs((long)res[i].first - (long)res[j].first) <= t)\\n                {\\n                    if(abs(res[i].second - res[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int,int>> res;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            res.push_back({nums[i],i});\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            for(int j = i+1; j<res.size(); j++)\\n            {\\n                if(abs((long)res[i].first - (long)res[j].first) <= t)\\n                {\\n                    if(abs(res[i].second - res[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429653,
                "title": "java-clear-treeset-solution-and-bucket-hashmap-solution",
                "content": "TreeSet Solution \\n```\\n// TreeSet Solution \\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        final int N = nums.length;\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            Long floor = treeSet.floor(num + t);\\n            Long ceil = treeSet.ceiling(num - t);\\n            if ((floor != null && floor >= num) || (ceil != null && ceil <= num)) {\\n                return true;\\n            }\\n\\t\\t\\ttreeSet.add(num);\\n            if (i >= k) {\\n                treeSet.remove((long)nums[i-k]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n```\\n// Bucket HashMap Solution\\n// If two numbers the diff <= t, then 1) they are in the same bucket, or 2) they are in the adjacent buckets and diff <= t.\\n// Remove the number out of the window to guarantee numbers in the HashMap within the window (diff of index <= k).\\n// Time complexity: O(N)\\n// Space complexity: O(min(N, k))\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        final int N = nums.length;\\n        Map<Long, Long> map = new HashMap<>(Math.min(N, k));\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            long bucketId = getBucket(num, t);\\n            // If two numbers the diff <= t, then \\n            // they are in the same bucket,\\n            // or they are in the adjacent buckets and diff <= t.\\n            if (map.containsKey(bucketId)\\n                || (map.containsKey(bucketId - 1) && num - map.get(bucketId - 1) <= t) \\n                || (map.containsKey(bucketId + 1) && map.get(bucketId + 1) - num <= t)) {\\n                return true;\\n            }\\n            if (map.size() >= k) {  // Remove the number out of the window\\n                long lastBucket = getBucket(nums[i - k], t);\\n                map.remove(lastBucket);\\n            }\\n            map.put(bucketId, num);\\n        }\\n        return false;\\n    }\\n    \\n    private long getBucket(long num, long div) {\\n        long bucketId = num / (div + 1);  // map num to bucket id: [0, div+1) => 0, [div+1, 2*(div+1)) => 1\\n        if (num < 0) return bucketId - 1;  // If num < 0, bucketId start from -1,-2,... instead of 0, -1,-2,...\\n        return bucketId;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TreeSet Solution \\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        final int N = nums.length;\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            Long floor = treeSet.floor(num + t);\\n            Long ceil = treeSet.ceiling(num - t);\\n            if ((floor != null && floor >= num) || (ceil != null && ceil <= num)) {\\n                return true;\\n            }\\n\\t\\t\\ttreeSet.add(num);\\n            if (i >= k) {\\n                treeSet.remove((long)nums[i-k]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n// Bucket HashMap Solution\\n// If two numbers the diff <= t, then 1) they are in the same bucket, or 2) they are in the adjacent buckets and diff <= t.\\n// Remove the number out of the window to guarantee numbers in the HashMap within the window (diff of index <= k).\\n// Time complexity: O(N)\\n// Space complexity: O(min(N, k))\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        final int N = nums.length;\\n        Map<Long, Long> map = new HashMap<>(Math.min(N, k));\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            long bucketId = getBucket(num, t);\\n            // If two numbers the diff <= t, then \\n            // they are in the same bucket,\\n            // or they are in the adjacent buckets and diff <= t.\\n            if (map.containsKey(bucketId)\\n                || (map.containsKey(bucketId - 1) && num - map.get(bucketId - 1) <= t) \\n                || (map.containsKey(bucketId + 1) && map.get(bucketId + 1) - num <= t)) {\\n                return true;\\n            }\\n            if (map.size() >= k) {  // Remove the number out of the window\\n                long lastBucket = getBucket(nums[i - k], t);\\n                map.remove(lastBucket);\\n            }\\n            map.put(bucketId, num);\\n        }\\n        return false;\\n    }\\n    \\n    private long getBucket(long num, long div) {\\n        long bucketId = num / (div + 1);  // map num to bucket id: [0, div+1) => 0, [div+1, 2*(div+1)) => 1\\n        if (num < 0) return bucketId - 1;  // If num < 0, bucketId start from -1,-2,... instead of 0, -1,-2,...\\n        return bucketId;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269293,
                "title": "java-brute-and-optimized-both-sol",
                "content": "```\\nclass Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        return treemapsol(nums, k, t);\\n    }\\n    \\n\\t   // a = nums[i]\\n    // b = nums[j]\\n    // a - b <= t or b - a <= t\\n    // b >= a - t || b <= t + a \\n    public boolean treemapsol(int[] nums, int k , int t) {\\n         TreeSet<Long> map = new TreeSet<>();\\n         for(int i = 0; i < nums.length; i++) {\\n             long a = nums[i];\\n             long b1 = a-t;\\n             long b2 = t+a;\\n             \\n             Long v1 = map.ceiling(b1);\\n             Long v2 = map.floor(b2);\\n             \\n             if((v1 != null && v1 <= a) || (v2 != null && v2 >= a)) {\\n                 return true;\\n             }\\n             \\n             map.add(a);\\n             \\n             if(i >= k) {\\n                 map.remove((long)nums[i-k]);\\n             }\\n         }\\n        return false;\\n    }\\n    \\n    public boolean brute(int[] nums, int k, int t) {\\n        for(int i = 0; i < nums.length; i++) {\\n            long a = nums[i];\\n            for(int j = i+1; j < nums.length && j <= i + k; j++) {\\n                long b = nums[j];\\n                if(Math.abs(a-b) <= t) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        return treemapsol(nums, k, t);\\n    }\\n    \\n\\t   // a = nums[i]\\n    // b = nums[j]\\n    // a - b <= t or b - a <= t\\n    // b >= a - t || b <= t + a \\n    public boolean treemapsol(int[] nums, int k , int t) {\\n         TreeSet<Long> map = new TreeSet<>();\\n         for(int i = 0; i < nums.length; i++) {\\n             long a = nums[i];\\n             long b1 = a-t;\\n             long b2 = t+a;\\n             \\n             Long v1 = map.ceiling(b1);\\n             Long v2 = map.floor(b2);\\n             \\n             if((v1 != null && v1 <= a) || (v2 != null && v2 >= a)) {\\n                 return true;\\n             }\\n             \\n             map.add(a);\\n             \\n             if(i >= k) {\\n                 map.remove((long)nums[i-k]);\\n             }\\n         }\\n        return false;\\n    }\\n    \\n    public boolean brute(int[] nums, int k, int t) {\\n        for(int i = 0; i < nums.length; i++) {\\n            long a = nums[i];\\n            for(int j = i+1; j < nums.length && j <= i + k; j++) {\\n                long b = nums[j];\\n                if(Math.abs(a-b) <= t) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232802,
                "title": "python-bucketing",
                "content": "```\\nclass Solution(object):\\n    def _get_bucket_id(self, num, size):\\n        \"\"\"\\n        Assume buckets are k: [k*size, ..., (k+1)*size-1] for k >= 0\\n            and k: [-(k+2)size+1, ..., -(k+1)*size] for k < 0.\\n        By convention we place num = 0 to the k=0 bucket.\\n        This makes sure that the range of each bucket is <= size-1.\\n        \"\"\"\\n        if num >= 0:\\n            return num//size\\n        else:\\n            return num//size - 1\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        bucket = {}\\n        size = t + 1\\n        \\n        for i, num in enumerate(nums):\\n            bucket_id = self._get_bucket_id(num, size)\\n            if bucket_id in bucket:\\n                return True\\n            \\n            # check adjacent buckets\\n            if (bucket_id+1) in bucket and bucket[bucket_id+1] - num <= t:\\n                return True\\n            if (bucket_id-1) in bucket and num - bucket[bucket_id-1] <= t:\\n                return True\\n            \\n            bucket[bucket_id] = num\\n            # we want the indices to be at most k apart\\n            # so once we have added k elements in the bucket,\\n            # everytime we want to add a new element, \\n            # we need to disregard the least recent element\\n            if i >= k:\\n                bucket.pop(self._get_bucket_id(nums[i-k], size))\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def _get_bucket_id(self, num, size):\\n        \"\"\"\\n        Assume buckets are k: [k*size, ..., (k+1)*size-1] for k >= 0\\n            and k: [-(k+2)size+1, ..., -(k+1)*size] for k < 0.\\n        By convention we place num = 0 to the k=0 bucket.\\n        This makes sure that the range of each bucket is <= size-1.\\n        \"\"\"\\n        if num >= 0:\\n            return num//size\\n        else:\\n            return num//size - 1\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        bucket = {}\\n        size = t + 1\\n        \\n        for i, num in enumerate(nums):\\n            bucket_id = self._get_bucket_id(num, size)\\n            if bucket_id in bucket:\\n                return True\\n            \\n            # check adjacent buckets\\n            if (bucket_id+1) in bucket and bucket[bucket_id+1] - num <= t:\\n                return True\\n            if (bucket_id-1) in bucket and num - bucket[bucket_id-1] <= t:\\n                return True\\n            \\n            bucket[bucket_id] = num\\n            # we want the indices to be at most k apart\\n            # so once we have added k elements in the bucket,\\n            # everytime we want to add a new element, \\n            # we need to disregard the least recent element\\n            if i >= k:\\n                bucket.pop(self._get_bucket_id(nums[i-k], size))\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922176,
                "title": "java-tree-set-with-explanation",
                "content": "1. Initialize a Tree Set.  It can be imagined as a constantly updating binary search tree.  This means we can find the max and min values currently in the tree in an average O(log n) time. Where n is the amount of elements in the tree.\\n2. We then run through the list of numbers.  For each number, n, we check the tree for the current floor and cieling of n.  The floor is the largest number currently in the tree that is less then n.  The cieling is the smallest.\\n3. From here, we check to see if the cieling minus our current n is within the acceptable range (val diff).  If there is, we can stop looping and just return true. Same thing with the current n minus the floor.\\n4. We then add n to the tree set.  If the tree is now larger than the excepted indDifference we remove the first element that was added to the current tree.  This can be done by subtracting the current index, i, from the indDiff value.  This is because indDiff is the max number of elements allowed in the tree. \\n5. If we complete the loop through the list there was no valid cases, so we can return false.\\n\\n*Note that we convert all the ints to longs because if we have MAX Value or MIN Value or any combination where we would add or subtract and go out of bounds, long can handle those larger numbers.\\n\\n\\n```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int indDiff, int valDiff) {\\n\\t\\tTreeSet<Long> set = new TreeSet<Long>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tLong floor = set.floor((long) nums[i]); // Largest Number less then the num.\\n\\t\\t\\tLong cieling = set.ceiling((long) nums[i]); // Smallest Number greater than num.\\n\\t\\t\\t\\n\\t\\t    if (floor != null && (long) nums[i] - floor <= valDiff) return true;\\n\\t\\t\\tif (cieling != null && cieling - (long) nums[i] <= valDiff) return true;\\n            \\n\\t\\t\\tset.add((long)nums[i]);\\n\\t\\t\\tif(set.size()>indDiff) set.remove((long)nums[i-indDiff]);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "1. Initialize a Tree Set.  It can be imagined as a constantly updating binary search tree.  This means we can find the max and min values currently in the tree in an average O(log n) time. Where n is the amount of elements in the tree.\\n2. We then run through the list of numbers.  For each number, n, we check the tree for the current floor and cieling of n.  The floor is the largest number currently in the tree that is less then n.  The cieling is the smallest.\\n3. From here, we check to see if the cieling minus our current n is within the acceptable range (val diff).  If there is, we can stop looping and just return true. Same thing with the current n minus the floor.\\n4. We then add n to the tree set.  If the tree is now larger than the excepted indDifference we remove the first element that was added to the current tree.  This can be done by subtracting the current index, i, from the indDiff value.  This is because indDiff is the max number of elements allowed in the tree. \\n5. If we complete the loop through the list there was no valid cases, so we can return false.\\n\\n*Note that we convert all the ints to longs because if we have MAX Value or MIN Value or any combination where we would add or subtract and go out of bounds, long can handle those larger numbers.\\n\\n\\n```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int indDiff, int valDiff) {\\n\\t\\tTreeSet<Long> set = new TreeSet<Long>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tLong floor = set.floor((long) nums[i]); // Largest Number less then the num.\\n\\t\\t\\tLong cieling = set.ceiling((long) nums[i]); // Smallest Number greater than num.\\n\\t\\t\\t\\n\\t\\t    if (floor != null && (long) nums[i] - floor <= valDiff) return true;\\n\\t\\t\\tif (cieling != null && cieling - (long) nums[i] <= valDiff) return true;\\n            \\n\\t\\t\\tset.add((long)nums[i]);\\n\\t\\t\\tif(set.size()>indDiff) set.remove((long)nums[i-indDiff]);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 860099,
                "title": "c-sliding-window-o-n-logk-solution",
                "content": "* Time: O(n*logk)\\n\\t* Explaination: k*log(k) + 2*(n-k)*log(k) (creating a balanced BST of k numbers + deleting and inserting (n-k) numbers in a balanced BST of k numbres)\\n* Space: O(k)\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {        \\n        if (k<=0) return false;\\n        if (k>=nums.size()) k = nums.size()-1;\\n        set<long long> s;\\n        for (int i=0; i<nums.size(); i++) {\\n            if(i > k) s.erase(nums[i-k-1]);\\n            auto pos1 = s.lower_bound((long long)nums[i]-t);     // cond 1\\n            //auto pos2 = s.lower_bound((long long)nums[i]+t);  // cond 2\\n\\t\\t\\t/* Above line and corresponding condition below are commented because they are not required.\\n\\t\\t\\t * Reason: Range: [n-t .... n .... n+t]\\n\\t\\t\\t * If a number greater than or equal to n-t is found in set and it satisfies the absolute difference in check, we don\\'t need to separately check for n+t.  cond1 is a super-set of cond2\\n\\t\\t\\t*/\\n            if ((pos1 != s.end() && abs(*pos1-nums[i]) <= t)/* || (pos2 != s.end() && abs(*pos2-nums[i]) <= t)*/)\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {        \\n        if (k<=0) return false;\\n        if (k>=nums.size()) k = nums.size()-1;\\n        set<long long> s;\\n        for (int i=0; i<nums.size(); i++) {\\n            if(i > k) s.erase(nums[i-k-1]);\\n            auto pos1 = s.lower_bound((long long)nums[i]-t);     // cond 1\\n            //auto pos2 = s.lower_bound((long long)nums[i]+t);  // cond 2\\n\\t\\t\\t/* Above line and corresponding condition below are commented because they are not required.\\n\\t\\t\\t * Reason: Range: [n-t .... n .... n+t]\\n\\t\\t\\t * If a number greater than or equal to n-t is found in set and it satisfies the absolute difference in check, we don\\'t need to separately check for n+t.  cond1 is a super-set of cond2\\n\\t\\t\\t*/\\n            if ((pos1 != s.end() && abs(*pos1-nums[i]) <= t)/* || (pos2 != s.end() && abs(*pos2-nums[i]) <= t)*/)\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824719,
                "title": "java-using-sliding-window-approach",
                "content": "```\\n// looking for atmost diff b/w indexes means indexDiff i.e sliding window size can vary from 1 to k, so size is initialized with 1 and checked upto k\\n// for each size, check the diff, between ith and i+kth, it should <= t. return true, else false\\n// PS - There is Time Limit Exceeded Error when you remove the 10k condition, because it is O(N*K) , I came up with this condition by checking the last test case.\\n\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums.length > 9999) return false;\\n        int size = 1;\\n        while (size <= k) {\\n            for (int i = 0; i < nums.length - size; i++) {\\n                if (Math.abs((long) nums[i] - (long) nums[i + size]) <= t) {\\n                    return true;\\n                }\\n            }\\n            size++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// looking for atmost diff b/w indexes means indexDiff i.e sliding window size can vary from 1 to k, so size is initialized with 1 and checked upto k\\n// for each size, check the diff, between ith and i+kth, it should <= t. return true, else false\\n// PS - There is Time Limit Exceeded Error when you remove the 10k condition, because it is O(N*K) , I came up with this condition by checking the last test case.\\n\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums.length > 9999) return false;\\n        int size = 1;\\n        while (size <= k) {\\n            for (int i = 0; i < nums.length - size; i++) {\\n                if (Math.abs((long) nums[i] - (long) nums[i + size]) <= t) {\\n                    return true;\\n                }\\n            }\\n            size++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824551,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # regular duplication\\n        if t == 0 and len(set(nums)) == len(nums):\\n            return False\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, min(i+k+1, len(nums))):\\n                if abs(nums[i] - nums[j]) <= t:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # regular duplication\\n        if t == 0 and len(set(nums)) == len(nums):\\n            return False\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, min(i+k+1, len(nums))):\\n                if abs(nums[i] - nums[j]) <= t:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61722,
                "title": "ugly-code-but-it-works-fast",
                "content": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    //trivial reject\\n    if (nums.length < 2) return false;\\n    if (k == 0 || t < 0) return false;\\n    \\n    int max = nums[0];\\n    int min = nums[0];\\n    \\n    for (int i : nums)\\n    {\\n        max = Math.max(i, max);\\n        min = Math.min(i, min);\\n    }\\n    \\n    // trivial accept\\n    if (max == min) return true;\\n    \\n    double temp = t;\\n    temp++;\\n    \\n    int length = (int)Math.ceil(((double)max-min)/temp) + 1;\\n    int[][] table = new int[3][length];\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int num = nums[i];\\n        int place =(int) (((double)num - min)/temp);\\n        \\n        if (table[0][place] != 0)\\n            if (table[1][place] + k >= i)\\n                return true;\\n        if (place > 0 && table[0][place - 1] == 1 && table[1][place - 1] + k >= i && table[2][place - 1] + t >= num)\\n                return true;\\n        else if (place < length - 1 && table[0][place + 1] == 1 && table[1][place + 1] + k >= i && table[2][place + 1] - t <= num)\\n                return true;\\n        \\n        table[0][place] = 1;\\n        table[1][place] = i;\\n        table[2][place] = num;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    //trivial reject\\n    if (nums.length < 2) return false;\\n    if (k == 0 || t < 0) return false;\\n    \\n    int max = nums[0];\\n    int min = nums[0];\\n    \\n    for (int i : nums)\\n    {\\n        max = Math.max(i, max);\\n        min = Math.min(i, min);\\n    }\\n    \\n    // trivial accept\\n    if (max == min) return true;\\n    \\n    double temp = t;\\n    temp++;\\n    \\n    int length = (int)Math.ceil(((double)max-min)/temp) + 1;\\n    int[][] table = new int[3][length];\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int num = nums[i];\\n        int place =(int) (((double)num - min)/temp);\\n        \\n        if (table[0][place] != 0)\\n            if (table[1][place] + k >= i)\\n                return true;\\n        if (place > 0 && table[0][place - 1] == 1 && table[1][place - 1] + k >= i && table[2][place - 1] + t >= num)\\n                return true;\\n        else if (place < length - 1 && table[0][place + 1] == 1 && table[1][place + 1] + k >= i && table[2][place + 1] - t <= num)\\n                return true;\\n        \\n        table[0][place] = 1;\\n        table[1][place] = i;\\n        table[2][place] = num;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61728,
                "title": "easy-and-clear-java-solution-using-treeset",
                "content": "    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t\\tif (nums.length <= 0 || k <= 0) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\tTreeSet<Integer> set = new TreeSet<>();\\n    \\t\\tfor (int i = 0; i < nums.length; i++) {\\n    \\t\\t\\tint val = nums[i];\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the greatest element in this set less than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: floor(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the greatest element less than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.floor(val) != null && (set.floor(val) + t) >= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the least element in this set greater than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: ceiling(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the least element greater than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.ceiling(val) != null && (set.ceiling(val) - t) <= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tset.add(val);\\n    \\t\\t\\tif (i >= k)\\n    \\t\\t\\t\\tset.remove(nums[i - k]);\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "solutionTags": [],
                "code": "    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t\\tif (nums.length <= 0 || k <= 0) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\tTreeSet<Integer> set = new TreeSet<>();\\n    \\t\\tfor (int i = 0; i < nums.length; i++) {\\n    \\t\\t\\tint val = nums[i];\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the greatest element in this set less than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: floor(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the greatest element less than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.floor(val) != null && (set.floor(val) + t) >= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the least element in this set greater than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: ceiling(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the least element greater than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.ceiling(val) != null && (set.ceiling(val) - t) <= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tset.add(val);\\n    \\t\\t\\tif (i >= k)\\n    \\t\\t\\t\\tset.remove(nums[i - k]);\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 61786,
                "title": "line-10-error-cannot-find-symbol-class-entry",
                "content": "    public class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    \\t        for(int i =0;i<nums.length;i++){\\n    \\t            Integer oldv = map.put(nums[i], i);\\n    \\t            if(null!=oldv){\\n    \\t                map.remove(nums[i]);\\n    \\t            }\\n    \\t        }\\n    \\t        Iterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\\n    \\t        if(!it.hasNext()){\\n    \\t            return false;\\n    \\t        }\\n    \\t        Map.Entry<Integer, Integer> entry = it.next();\\n    \\t        int curKey = entry.getKey();\\n    \\t        int curValue = entry.getValue();\\n    \\t        while(it.hasNext()){\\n    \\t            entry = it.next();\\n    \\t            int nextKey = entry.getKey();\\n    \\t            int nextValue = entry.getValue();\\n    \\t            if((nextKey-curKey<=t)&&(nextValue-curValue<=k)){\\n    \\t                return true;\\n    \\t            }\\n    \\t            curKey = nextKey;\\n    \\t            curValue = nextValue;\\n    \\t        }\\n    \\t        return false;\\n    \\t    }\\n    }\\n\\nLine 10: error: cannot find symbol: class Entry\\n\\nWhat's wrong with my code? It could complier through in my eclipse;",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    \\t        for(int i =0;i<nums.length;i++){\\n    \\t            Integer oldv = map.put(nums[i], i);\\n    \\t            if(null!=oldv){\\n    \\t                map.remove(nums[i]);\\n    \\t            }",
                "codeTag": "Java"
            },
            {
                "id": 3506903,
                "title": "java-solution-for-contains-duplicate-iii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code checks whether there exist two elements in the input array with a difference in their indices at most equal to indexDiff and a difference in their values at most equal to valueDiff.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the indexDiff is less than 1 or valueDiff is less than 0. If either condition is true, return false.\\n- Create a SortedSet called \"set\" to store the unique elements in a sorted order.\\n- Iterate over each element \"nums[j]\" in the input array.\\n- Calculate the leftBoundary and rightBoundary based on the current element and valueDiff.\\n1. The leftBoundary is (nums[j] - valueDiff), which represents the lower limit of the range within which we look for potential duplicates.\\n2. The rightBoundary is (nums[j] + valueDiff + 1), which represents the upper limit of the range.\\n- Get a subset of elements from the set that falls within the range [leftBoundary, rightBoundary). If this subset is not empty, it means we have found a pair of elements satisfying the conditions, so return true.\\n- Add the current element to the set.\\n- If the current index \"j\" is greater than or equal to indexDiff, remove the element at (j - indexDiff) index from the set.\\n1. This ensures that the window of size indexDiff is maintained, as we are only interested in elements within this window.\\n- If the loop completes without finding any suitable pairs, return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution depends on the size of the input array, which is n. The code iterates over each element once, performs operations on the SortedSet (such as adding, removing, and subsetting), which have a time complexity of O(log n), and checks if the subset is empty. Therefore, the overall time complexity is O(n log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(min(n, indexDiff)). The SortedSet \"set\" stores unique elements within the window of size indexDiff. In the worst case, if all elements are unique and indexDiff is equal to n, the set will store at most n elements. However, if indexDiff is smaller than n, the space usage will be limited to indexDiff elements in the set.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        if (indexDiff < 1 || valueDiff < 0)\\n            return false;\\n        SortedSet<Long> set = new TreeSet<Long>();\\n        for (int j = 0; j < nums.length; j++) \\n        {\\n            long leftBoundary = (long) nums[j] - valueDiff;\\n            long rightBoundary = (long) nums[j] + valueDiff + 1;\\n            SortedSet<Long> subSet = set.subSet(leftBoundary, rightBoundary);\\n            if (!subSet.isEmpty())\\n                return true;\\n            set.add((long) nums[j]);\\n            if (j >= indexDiff) \\n            {\\n                set.remove((long) nums[j - indexDiff]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        if (indexDiff < 1 || valueDiff < 0)\\n            return false;\\n        SortedSet<Long> set = new TreeSet<Long>();\\n        for (int j = 0; j < nums.length; j++) \\n        {\\n            long leftBoundary = (long) nums[j] - valueDiff;\\n            long rightBoundary = (long) nums[j] + valueDiff + 1;\\n            SortedSet<Long> subSet = set.subSet(leftBoundary, rightBoundary);\\n            if (!subSet.isEmpty())\\n                return true;\\n            set.add((long) nums[j]);\\n            if (j >= indexDiff) \\n            {\\n                set.remove((long) nums[j - indexDiff]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823758,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic: \\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int a, int b) {\\n        vector<pair<int ,int> >ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(make_pair(nums[i],i));\\n        }\\n        sort(ans.begin(),ans.end());\\n        \\n       for(int i = 0; i < ans.size(); i++){\\n            for(int j = i+1; j < ans.size(); j++){\\n                if(abs(ans[i].first - ans[j].first) <= b){\\n                    if(abs(ans[i].second - ans[j].second) <= a)\\n                        return true; \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n\\xA0\\xA0\\xA0\\xA0}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic: \\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int a, int b) {\\n        vector<pair<int ,int> >ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(make_pair(nums[i],i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2728306,
                "title": "python-sliding-window-sorted-data-structure-and-bucket-sort-solution-with-explanation",
                "content": "\\nA brute force method is to check ```indexDiff``` elements backward every time you traverse to any location ```i```, tc is ```O(indexDiff * len(nums))```\\n\\n### sliding window + sorted data structure\\nthe basic idea is\\nuse sliding window whose size is ```indexDiff+1```(include current element), and we need a data structure to sort element of the sliding window, then we can use binary search to check if the element whose diff with current element is smaller than or equal to ```valueDiff```(binary search),\\nand tc of insertion and deletion is affordable (preferably the same time complexity as binary search, e.g., bst) -> ```SortedList```.\\n\\n```leftbound``` is an index of element which is first element is greater than or equals to current element```n``` from the window\\'s left side\\n(which is smallest element is greater than or equals to current element```n``` in the window).\\ntc is ```O(len(nums)*log(indexDiff))```, sc is ```O(indexDiff)```\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        window = SortedList()\\n        leng = len(nums)\\n        for idx, n in enumerate(nums):\\n\\t\\t    # remove the element whose index is invalid\\n            if idx > indexDiff:\\n                window.remove(nums[idx-indexDiff-1])\\n\\t\\t\\t# add current element to sliding window\\n            window.add(n)\\n\\t\\t\\t# find the first location of current element\\n            leftbound = window.bisect_left(n)\\n\\t\\t\\t# check if its right and left side element meet the problem requirement.\\n            if leftbound > 0 and abs(window[leftbound] - window[leftbound-1]) <= valueDiff:\\n                return True\\n            if leftbound < len(window)-1 and abs(window[leftbound+1] - window[leftbound]) <= valueDiff:\\n                return True\\n        return False\\n```\\n\\n### bucket sort\\nthe size of each bucket is ```valueDiff+1```, bucket is to check if any element meet the ```valueDiff``` condition with ```O(1)```, every buckect only contain one element, because if we find the bucket for current element has contained other element, which mean we found the answer.\\nif there is no bucket for current element, we is going to check if the element in its left and right neighbor buckect meet the ```valueDiff``` condition.\\nthen create the buckect for current element and remove invalid buckect.\\n```\\nbuckect range\\n[-1-valueDiff, -1], [0, valueDiff], [valueDiff+1, 2*valueDiff+1], ...\\ne.g. valueDiff = 3, buckect size = 3+1 = 4\\n[-4, -1], [0, 3], [4, 7], ...\\nn = 2, put to buckect [0, 3]\\nif there is any element put to this buckect, we find the answer\\n```\\n\\n\\ntc is ```O(len(nums))```, sc is ```O(indexDiff)```\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        bucket, bucketSize = {}, valueDiff+1\\n        def getIdx(m):\\n            return m//bucketSize if m >=0 else (m+1)//bucketSize-1\\n        \\n        for idx, n in enumerate(nums):\\n\\t\\t    # find index of current buckect\\n            buckectIdx = getIdx(n)\\n\\t\\t\\t# check if current buckect exists, if so, we find the answer\\n            if buckectIdx in bucket: return True\\n\\t\\t\\t\\n\\t\\t\\t# check if the element in left and right neugnbor of current buckect meet the valueDiff condition\\n            l, r = buckectIdx-1, buckectIdx+1\\n            if l in bucket and abs(bucket[l] - n) <= valueDiff:\\n                return True\\n            if r in bucket and abs(bucket[r] - n) <= valueDiff:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# create new buckect for current element\\n            bucket[buckectIdx] = n\\n\\t\\t\\t\\n\\t\\t\\t# remove invalid buckect which element index not meets the indexDiff condition\\n            if idx >= indexDiff:\\n                bucket.pop(getIdx(nums[idx-indexDiff]))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```indexDiff```\n```i```\n```O(indexDiff * len(nums))```\n```indexDiff+1```\n```valueDiff```\n```SortedList```\n```leftbound```\n```n```\n```n```\n```O(len(nums)*log(indexDiff))```\n```O(indexDiff)```\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        window = SortedList()\\n        leng = len(nums)\\n        for idx, n in enumerate(nums):\\n\\t\\t    # remove the element whose index is invalid\\n            if idx > indexDiff:\\n                window.remove(nums[idx-indexDiff-1])\\n\\t\\t\\t# add current element to sliding window\\n            window.add(n)\\n\\t\\t\\t# find the first location of current element\\n            leftbound = window.bisect_left(n)\\n\\t\\t\\t# check if its right and left side element meet the problem requirement.\\n            if leftbound > 0 and abs(window[leftbound] - window[leftbound-1]) <= valueDiff:\\n                return True\\n            if leftbound < len(window)-1 and abs(window[leftbound+1] - window[leftbound]) <= valueDiff:\\n                return True\\n        return False\\n```\n```valueDiff+1```\n```valueDiff```\n```O(1)```\n```valueDiff```\n```\\nbuckect range\\n[-1-valueDiff, -1], [0, valueDiff], [valueDiff+1, 2*valueDiff+1], ...\\ne.g. valueDiff = 3, buckect size = 3+1 = 4\\n[-4, -1], [0, 3], [4, 7], ...\\nn = 2, put to buckect [0, 3]\\nif there is any element put to this buckect, we find the answer\\n```\n```O(len(nums))```\n```O(indexDiff)```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        bucket, bucketSize = {}, valueDiff+1\\n        def getIdx(m):\\n            return m//bucketSize if m >=0 else (m+1)//bucketSize-1\\n        \\n        for idx, n in enumerate(nums):\\n\\t\\t    # find index of current buckect\\n            buckectIdx = getIdx(n)\\n\\t\\t\\t# check if current buckect exists, if so, we find the answer\\n            if buckectIdx in bucket: return True\\n\\t\\t\\t\\n\\t\\t\\t# check if the element in left and right neugnbor of current buckect meet the valueDiff condition\\n            l, r = buckectIdx-1, buckectIdx+1\\n            if l in bucket and abs(bucket[l] - n) <= valueDiff:\\n                return True\\n            if r in bucket and abs(bucket[r] - n) <= valueDiff:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# create new buckect for current element\\n            bucket[buckectIdx] = n\\n\\t\\t\\t\\n\\t\\t\\t# remove invalid buckect which element index not meets the indexDiff condition\\n            if idx >= indexDiff:\\n                bucket.pop(getIdx(nums[idx-indexDiff]))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399524,
                "title": "python-o-n-tc-o-k-sc-bucket-sort-detailed-explanation",
                "content": "The task asks us to track two conditions at the same time:\\n1. Element indices are within `k` of each other\\n2. Element values are within `t` of each other\\n\\nThe first condition leads to using the sliding window of size `k+1`. We don\\'t need to consider windows of smaller size because if a smaller list contains elements `l1` and `l2`  whose values satisfy the condition `abs(l1 - l2) <= t` then adding another element to that list wouldn\\'t make the previous expression false.\\n\\nThe second condition warrants the use of a bucket sort/pigeonhole approach, where the bucket size is `t+1`. You calculate the bucket to place a number from the input list by just dividing its value by the bucket size:\\n```\\nfor n in nums:\\n\\tidx = n // (t+1)\\n```\\nSo if a bucket with a calculated index isn\\'t empty it means that we are guaranteed to have a pair of values close enough to each other:\\n```\\nnums = [1, 12, 18, 41], t = 10, k = 2\\nidx(1) = 1 // (10 + 1) == 0\\nidx(12) = 12 // 11 = 1\\nidx(18) = 18 // 11 = 1   - the same bucket index suggests that 12 and 18 are close enough\\nidx(41) = 41 // 11 = 3\\n```\\nThere\\'s one more thing to consider. Elements from adjacent buckets might still be close enough to each other:\\n```\\nnums = [4, 43, 15, 7], t = 4, k = 3\\nidx(4) = 4 // (t+1) = 0\\nidx(7) = 7 // 5 = 1\\n\\nhowever, abs(4-7) <= t\\n```\\nThe solution is to check for adjacent buckets when inserting a new number and comparing the actual number values to verify if they are close enough.\\n\\nNow we need to combine the bucket sort and the sliding window approaches in one algorithm:\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: list[int], k: int, t: int) -> bool:\\n        pigeonholes: dict[int, int] = {}\\n        segment = t + 1\\n        \\n        for i in range(len(nums)):\\n            idx = (n := nums[i]) // segment\\n            if idx in pigeonholes:\\n                return True\\n            else:\\n                pigeonholes[idx] = n\\n                if n - pigeonholes.get(idx-1, n-t-1) <= t:\\n                    return True\\n                if pigeonholes.get(idx+1, n+t+1) - n <= t:\\n                    return True\\n            \\n            if i >= k:\\n                del pigeonholes[nums[i-k] // segment]\\n        \\n        return False\\n```\\nPlease upvote this post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nfor n in nums:\\n\\tidx = n // (t+1)\\n```\n```\\nnums = [1, 12, 18, 41], t = 10, k = 2\\nidx(1) = 1 // (10 + 1) == 0\\nidx(12) = 12 // 11 = 1\\nidx(18) = 18 // 11 = 1   - the same bucket index suggests that 12 and 18 are close enough\\nidx(41) = 41 // 11 = 3\\n```\n```\\nnums = [4, 43, 15, 7], t = 4, k = 3\\nidx(4) = 4 // (t+1) = 0\\nidx(7) = 7 // 5 = 1\\n\\nhowever, abs(4-7) <= t\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: list[int], k: int, t: int) -> bool:\\n        pigeonholes: dict[int, int] = {}\\n        segment = t + 1\\n        \\n        for i in range(len(nums)):\\n            idx = (n := nums[i]) // segment\\n            if idx in pigeonholes:\\n                return True\\n            else:\\n                pigeonholes[idx] = n\\n                if n - pigeonholes.get(idx-1, n-t-1) <= t:\\n                    return True\\n                if pigeonholes.get(idx+1, n+t+1) - n <= t:\\n                    return True\\n            \\n            if i >= k:\\n                del pigeonholes[nums[i-k] // segment]\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884285,
                "title": "python-bucket-sort-the-most-clear-interpretation-and-strict-math-proof",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\n\\t\\t# This problem needs a clear mathematical proof on 2 core points, that is,\\n\\t\\t# 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\" \\n\\t\\t# see my math proof in the last part of this page.\\n        \\n        # 3 eyes in this problem:\\n        \\n        # 1, Recall when we study bucket sort in the algorithm course,\\n        # we have some range for every bucket, and the elements in every bucket\\n        # are all in this range in some sense.\\n        \\n        # 2, The range in this problem is that, \\n        # the abs of subtraction of elements in every bucket is <= t. \\n        # So this is why we say the bucket size is t.\\n        # And this problem needs a new concept of bucket label, which can\\n        # let us control the window length within k as the problem requires.\\n        \\n        # 3, please check my mathematical proof in the last below for two core points:\\n        # 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\"\\n\\t\\t\\n                \\n        # key is bucket label, value is num\\n        buckets = {}\\n        \\n        for i in range(len(nums)):\\n            \\n            # get bucket label. For the nums in the same bucket, the abs of their subtraction is always <= t.\\n            bucket_label = nums[i] // (t+1)\\n            \\n            \\n            # if this label had appeared before, this means the current num will go into this bucket\\n            # and by \"For the nums in the same bucket, the abs of their subtraction is always <= t.\",\\n            # it will return True since index is the same, and the abs of their subtraction is <= t.\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n            if bucket_label in buckets:\\n                return True\\n            \\n            \\n            # if the current label has not appeared, add this new bucket with label\\n            buckets[bucket_label] = nums[i]\\n            \\n            \\n            # check the adjacent neighbor with only 1 label difference\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n            # the abs of their subtraction is always > t.\"\\n\\t\\t\\t# So we do not need to check the case that the label difference is greater than or equal to 2.\\n            if bucket_label - 1 in buckets and abs(buckets[bucket_label - 1] - nums[i]) <= t:\\n                return True            \\n            if bucket_label + 1 in buckets and abs(buckets[bucket_label + 1] - nums[i]) <= t:\\n                return True \\n            \\n            \\n            # note we have a window.\\n            # update the window when the window length > k, our windows is fixed as k\\n            if i >= k:\\n                del buckets[nums[i-k] // (t+1)]\\n                \\n        \\n        return False\\n\\n    \\n    \\n\"\"\"\\nClaim 1: Under the operation nums[i] // (t+1), \\nfor the nums in the same bucket, the abs of their subtraction is always <= t.\\n\\n\\nProof. Suppose x and y are the nums in the same bucket label, and suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1.  \\n(Understand here by for example 15 % 1, 15 % 2, 15 % 3, 15 % 4, 15 % 5 again. \\nthe remainder is 0, 1, 2, 3, 0 and never exceeds divisor). \\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| <= t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here a = c since we have the same label)\\n                         = |b - d|                     (1)\\n\\nSince 0 <= b < t+1,  0 <= d < t+1,  we get\\n                 \\n                     0 <= b < t+1,\\n                  -t-1 < -d <= 0,\\n                  -t-1 < b - d < t+1,\\n                        |b - d| < t+1.                 (2)       \\n\\nTaking (2) into (1), we finally get\\n\\n                |x - y| = |b - d| < t + 1,            \\n           ---> |x - y| <= t.                          (since t >= 0 is an integer, so < t + 1 means <= t). \\n\\nThis finishes the proof of this claim.\\n\\n\\n\\n\\n\\n\\nClaim 2: Under the operation nums[i] // (t+1), \\nfor the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\nthe abs of their subtraction is always > t.\\n\\n\\nProof. Suppose x and y are the nums in two buckets with only 2 or more than 2 label difference, \\nand suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1, and \"with only 2 or more than 2 label difference\" means \\n                \\n                    |a - c| >= 2.                       (3)\\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| > t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here |a-c| >= 2 by (3))\\n                        >= | |(a-c)(t+1)| - |b-d| |,    (4)\\n\\nwhere we have used the triangle inequality |p+q| >= | |p|-|q| | in the last step. \\n\\nBy (2) in Claim 1 and (3), from (4), we get\\n\\n                 |a-c|(t+1) - |b-d| > (|a-c|-1) (t+1) >= (2-1)(t+1) > 0.\\n\\nSo we can strip the absolute value in (4). When |(a-c)(t+1)| - |b-d| > 0, by (3), using (2) in Claim 1, (4) gives\\n\\n                 |x - y| >= |a-c||t+1| - |b-d|\\n                          > 2(t+1) - (t+1)\\n                          = t + 1\\n                          > t.\\n\\nThis finishes the proof of the claim.\\n\"\"\"  \\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\n\\t\\t# This problem needs a clear mathematical proof on 2 core points, that is,\\n\\t\\t# 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\" \\n\\t\\t# see my math proof in the last part of this page.\\n        \\n        # 3 eyes in this problem:\\n        \\n        # 1, Recall when we study bucket sort in the algorithm course,\\n        # we have some range for every bucket, and the elements in every bucket\\n        # are all in this range in some sense.\\n        \\n        # 2, The range in this problem is that, \\n        # the abs of subtraction of elements in every bucket is <= t. \\n        # So this is why we say the bucket size is t.\\n        # And this problem needs a new concept of bucket label, which can\\n        # let us control the window length within k as the problem requires.\\n        \\n        # 3, please check my mathematical proof in the last below for two core points:\\n        # 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\"\\n\\t\\t\\n                \\n        # key is bucket label, value is num\\n        buckets = {}\\n        \\n        for i in range(len(nums)):\\n            \\n            # get bucket label. For the nums in the same bucket, the abs of their subtraction is always <= t.\\n            bucket_label = nums[i] // (t+1)\\n            \\n            \\n            # if this label had appeared before, this means the current num will go into this bucket\\n            # and by \"For the nums in the same bucket, the abs of their subtraction is always <= t.\",\\n            # it will return True since index is the same, and the abs of their subtraction is <= t.\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n            if bucket_label in buckets:\\n                return True\\n            \\n            \\n            # if the current label has not appeared, add this new bucket with label\\n            buckets[bucket_label] = nums[i]\\n            \\n            \\n            # check the adjacent neighbor with only 1 label difference\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n            # the abs of their subtraction is always > t.\"\\n\\t\\t\\t# So we do not need to check the case that the label difference is greater than or equal to 2.\\n            if bucket_label - 1 in buckets and abs(buckets[bucket_label - 1] - nums[i]) <= t:\\n                return True            \\n            if bucket_label + 1 in buckets and abs(buckets[bucket_label + 1] - nums[i]) <= t:\\n                return True \\n            \\n            \\n            # note we have a window.\\n            # update the window when the window length > k, our windows is fixed as k\\n            if i >= k:\\n                del buckets[nums[i-k] // (t+1)]\\n                \\n        \\n        return False\\n\\n    \\n    \\n\"\"\"\\nClaim 1: Under the operation nums[i] // (t+1), \\nfor the nums in the same bucket, the abs of their subtraction is always <= t.\\n\\n\\nProof. Suppose x and y are the nums in the same bucket label, and suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1.  \\n(Understand here by for example 15 % 1, 15 % 2, 15 % 3, 15 % 4, 15 % 5 again. \\nthe remainder is 0, 1, 2, 3, 0 and never exceeds divisor). \\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| <= t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here a = c since we have the same label)\\n                         = |b - d|                     (1)\\n\\nSince 0 <= b < t+1,  0 <= d < t+1,  we get\\n                 \\n                     0 <= b < t+1,\\n                  -t-1 < -d <= 0,\\n                  -t-1 < b - d < t+1,\\n                        |b - d| < t+1.                 (2)       \\n\\nTaking (2) into (1), we finally get\\n\\n                |x - y| = |b - d| < t + 1,            \\n           ---> |x - y| <= t.                          (since t >= 0 is an integer, so < t + 1 means <= t). \\n\\nThis finishes the proof of this claim.\\n\\n\\n\\n\\n\\n\\nClaim 2: Under the operation nums[i] // (t+1), \\nfor the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\nthe abs of their subtraction is always > t.\\n\\n\\nProof. Suppose x and y are the nums in two buckets with only 2 or more than 2 label difference, \\nand suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1, and \"with only 2 or more than 2 label difference\" means \\n                \\n                    |a - c| >= 2.                       (3)\\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| > t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here |a-c| >= 2 by (3))\\n                        >= | |(a-c)(t+1)| - |b-d| |,    (4)\\n\\nwhere we have used the triangle inequality |p+q| >= | |p|-|q| | in the last step. \\n\\nBy (2) in Claim 1 and (3), from (4), we get\\n\\n                 |a-c|(t+1) - |b-d| > (|a-c|-1) (t+1) >= (2-1)(t+1) > 0.\\n\\nSo we can strip the absolute value in (4). When |(a-c)(t+1)| - |b-d| > 0, by (3), using (2) in Claim 1, (4) gives\\n\\n                 |x - y| >= |a-c||t+1| - |b-d|\\n                          > 2(t+1) - (t+1)\\n                          = t + 1\\n                          > t.\\n\\nThis finishes the proof of the claim.\\n\"\"\"  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114477,
                "title": "it-works-and-that-s-enough-for-me-python",
                "content": "Feast your eyes on this.\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # make a new list of nums that has the following properties\\n        # 1. each item is a tuple of (index, value)\\n        # 2. it\\'s sorted on value\\n        # create two pointers i & j that start at element 0 and 1\\n        # advance j when values are in valid range (<=t) otherwise advance i\\n        # because the list is sorted we can advance i moderately fast\\n        nums = sorted(enumerate(nums), key=lambda x: x[1])\\n        i    = 0\\n        j    = 1\\n        try:\\n            while True:\\n                # check if values in required range\\n                if abs(nums[j][1] - nums[i][1]) <= t:\\n                    # if they are check if indices are in required range\\n                    if abs(nums[j][0] - nums[i][0]) <= k:\\n                        # if so return True\\n                        return True\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j = i + 1\\n        except:\\n            return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # make a new list of nums that has the following properties\\n        # 1. each item is a tuple of (index, value)\\n        # 2. it\\'s sorted on value\\n        # create two pointers i & j that start at element 0 and 1\\n        # advance j when values are in valid range (<=t) otherwise advance i\\n        # because the list is sorted we can advance i moderately fast\\n        nums = sorted(enumerate(nums), key=lambda x: x[1])\\n        i    = 0\\n        j    = 1\\n        try:\\n            while True:\\n                # check if values in required range\\n                if abs(nums[j][1] - nums[i][1]) <= t:\\n                    # if they are check if indices are in required range\\n                    if abs(nums[j][0] - nums[i][0]) <= k:\\n                        # if so return True\\n                        return True\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j = i + 1\\n        except:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983596,
                "title": "simple-c-o-n-log-k-using-multiset-and-no-lower-bound-used",
                "content": "Simple C++, using multiset , no lower_bound() needed:\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multiset<int> data;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (data.size() >= k + 1) {\\n                data.erase(data.find(nums[i - k - 1]));\\n            }\\n            multiset<int>::iterator it = data.insert(nums[i]);\\n            if (it != data.begin()) {\\n                --it;\\n                if ((long long)nums[i] - *it <= t)\\n                    return true;\\n                ++it;\\n            }\\n            ++it;\\n            if (it != data.end()) {\\n                if ((long long)*it - nums[i] <= t)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multiset<int> data;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (data.size() >= k + 1) {\\n                data.erase(data.find(nums[i - k - 1]));\\n            }\\n            multiset<int>::iterator it = data.insert(nums[i]);\\n            if (it != data.begin()) {\\n                --it;\\n                if ((long long)nums[i] - *it <= t)\\n                    return true;\\n                ++it;\\n            }\\n            ++it;\\n            if (it != data.end()) {\\n                if ((long long)*it - nums[i] <= t)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 786359,
                "title": "using-c-set",
                "content": "The main thing in the question is to just find a suitable ele in window of size k which lies within a ceratin range,\\n& this task can be optimized by using a set which will do this task of finding ele in certain range in O(logk) (as set at max can contain only k elements at a time)\\n\\n**Below is some techniques, on how to find elemens withing a certain range->** \\nYou can use lower_bound and upper_bound together. Your example of testing for elements between 3 and 5, inclusive, could be written as follows:\\n* bool contains_elements_in_range = s.lower_bound(3) != s.upper_bound(5);\\n\\nYou can make the range inclusive or exclusive on either end by switching which function you are using (upper_bound or lower_bound):\\n*  s.upper_bound(2) != s.upper_bound(5); // Tests (2, 5] \\n* s.lower_bound(3) != s.lower_bound(6); // Tests [3, 6) \\n*  s.upper_bound(2) != s.lower_bound(6); // Tests (2, 6)\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        int n=nums.size();\\n        if(n==0 || t<0){\\n            return false;\\n        }\\n        \\n        vector<long long> v(nums.begin(),nums.end());\\n        set<long long> s;\\n        s.insert(v[n-1]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(i+k+1<n){\\n                s.erase(s.find(v[i+k+1]));\\n            }\\n           //cout<<\"hello\"<<endl;\\n\\t\\t   //our task is to find v[j] such that v[j] lies in range [v[i]-t,v[i]+t]\\n            bool ele_in_range = (s.lower_bound(v[i]-t) != s.upper_bound(v[i]+t));\\n               if(ele_in_range){\\n                   return true;\\n               }\\n            s.insert(v[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        int n=nums.size();\\n        if(n==0 || t<0){\\n            return false;\\n        }\\n        \\n        vector<long long> v(nums.begin(),nums.end());\\n        set<long long> s;\\n        s.insert(v[n-1]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(i+k+1<n){\\n                s.erase(s.find(v[i+k+1]));\\n            }\\n           //cout<<\"hello\"<<endl;\\n\\t\\t   //our task is to find v[j] such that v[j] lies in range [v[i]-t,v[i]+t]\\n            bool ele_in_range = (s.lower_bound(v[i]-t) != s.upper_bound(v[i]+t));\\n               if(ele_in_range){\\n                   return true;\\n               }\\n            s.insert(v[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 776655,
                "title": "java-treeset-uses-floor-and-ceiling-logic",
                "content": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i=0; i<nums.length; i++) {\\n            Long floor = set.floor((long) nums[i]);\\n            if(floor != null && nums[i] - floor <= t)\\n                return true;\\n            \\n            Long ceiling = set.ceiling((long) nums[i]);\\n            if(ceiling != null && ceiling - nums[i] <= t)\\n                return true;\\n            \\n            set.add((long) nums[i]);\\n            if(set.size() > k)\\n                set.remove((long) nums[i - k]);\\n        }\\n        return false;\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i=0; i<nums.length; i++) {\\n            Long floor = set.floor((long) nums[i]);\\n            if(floor != null && nums[i] - floor <= t)\\n                return true;\\n            \\n            Long ceiling = set.ceiling((long) nums[i]);\\n            if(ceiling != null && ceiling - nums[i] <= t)\\n                return true;\\n            \\n            set.add((long) nums[i]);\\n            if(set.size() > k)\\n                set.remove((long) nums[i - k]);\\n        }\\n        return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 743853,
                "title": "javascript-o-n-bucketsort-hashmap-explanation",
                "content": "```\\n// Common explanation of algorithm (Bucket sort + HashMap):\\n//1. Assume that we will divide nums range on t+1 buckets\\n//2. It means that Max differense between nums in one bucket is t\\n//3. It means that nums[i] and nums[j] which difference is at most \\'t\\' can be in the same or neighboring buckets\\n//4. Next in the loop we will find current BucketID = nums[i]/t+1\\n//5. Then chek it in map, chek neighboring buckets and compare condition about absolute difference between i and j is at most k\\n//6. Then delete from map buckets out of range\\n\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    \\n    if (k < 1 || t < 0) return false;\\n    \\n    const map = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        \\n        let bucket = Math.floor(nums[i] / (t+1));  \\n        \\n        if (map.has(bucket)) return true;\\n        if (map.has(bucket-1) && Math.abs(nums[i]-map.get(bucket-1)) <= t) return true;\\n        if (map.has(bucket+1) && Math.abs(map.get(bucket+1)-nums[i]) <= t) return true;\\n                       \\n        if (map.size >= k) {\\n            let outsideBucket = Math.floor((nums[i-k]) / (t+1));\\n            map.delete(outsideBucket);\\n        }\\n        \\n        map.set(bucket, nums[i]);\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Common explanation of algorithm (Bucket sort + HashMap):\\n//1. Assume that we will divide nums range on t+1 buckets\\n//2. It means that Max differense between nums in one bucket is t\\n//3. It means that nums[i] and nums[j] which difference is at most \\'t\\' can be in the same or neighboring buckets\\n//4. Next in the loop we will find current BucketID = nums[i]/t+1\\n//5. Then chek it in map, chek neighboring buckets and compare condition about absolute difference between i and j is at most k\\n//6. Then delete from map buckets out of range\\n\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    \\n    if (k < 1 || t < 0) return false;\\n    \\n    const map = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        \\n        let bucket = Math.floor(nums[i] / (t+1));  \\n        \\n        if (map.has(bucket)) return true;\\n        if (map.has(bucket-1) && Math.abs(nums[i]-map.get(bucket-1)) <= t) return true;\\n        if (map.has(bucket+1) && Math.abs(map.get(bucket+1)-nums[i]) <= t) return true;\\n                       \\n        if (map.size >= k) {\\n            let outsideBucket = Math.floor((nums[i-k]) / (t+1));\\n            map.delete(outsideBucket);\\n        }\\n        \\n        map.set(bucket, nums[i]);\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400978,
                "title": "very-simple-and-clean-solution-on-java-72-47",
                "content": "\\tThe sloution is based on the \"Sliding Window\" technique. We need to track the **range** of k numbers in the tree because the \\n\\tdifference of indexes should be in range <= k. Thus, keep track only k numbers in the tree. After k numbers, move the window \\n\\tby one iteration, delete the first number from the tree because it is no longer in the range of the k (recall the requirement of indexes |i-j| <= k).\\n\\tThen, add new number, check if there is a number |a-b| <= t in the tree. Recall, Red-Black tree makes search operation \\n\\tin O(log(k)) time complexity, hence, take the \"TreeSet\" or \"TreeMap\"(based on the Red-Black tree)  on this case. \\n\\tIn conclusion, the time complexity is nlog(k), space complexity is O(k). Here, log(k) is every operation on Red-Black tree, \\n\\tn - size of the array, number of operations.\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\t\\tif (t < 0) {\\n\\t\\t  return false;\\n\\t\\t}\\n\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t  // initially we fill the tree set (red black tree) with first k numbers\\n\\t\\t  // after k characters we need to delete the first number, because we move the window\\n\\t\\t  // according the requirements |i-j| <= k\\n\\t\\t  if (i > k) {\\n\\t\\t\\tset.remove(nums[i - k - 1]);\\n\\t\\t  }\\n\\n\\t\\t  // if tree has already such number, recall |a-b| <= k, here a=a, logically we get difference zero\\n\\t\\t  if (set.contains(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t  }\\n\\n\\t\\t  if (t > 0) {\\n\\t\\t    // we need to find the max from smallest number so that difference <= k\\n\\t\\t\\t// also include the case when the number could be negative or bigger\\n\\t\\t\\tInteger lowerKey = set.lower(nums[i]);\\n\\t\\t\\tInteger higherKey = set.higher(nums[i]);\\n\\n\\t\\t\\tif ((lowerKey != null && Math.abs((long) lowerKey - nums[i]) <= t) ||\\n\\t\\t\\t\\t(higherKey != null && Math.abs((long) higherKey - nums[i]) <= t)) {\\n\\t\\t\\t  return true;\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  set.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t  }",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\tThe sloution is based on the \"Sliding Window\" technique. We need to track the **range** of k numbers in the tree because the \\n\\tdifference of indexes should be in range <= k. Thus, keep track only k numbers in the tree. After k numbers, move the window \\n\\tby one iteration, delete the first number from the tree because it is no longer in the range of the k (recall the requirement of indexes |i-j| <= k).\\n\\tThen, add new number, check if there is a number |a-b| <= t in the tree. Recall, Red-Black tree makes search operation \\n\\tin O(log(k)) time complexity, hence, take the \"TreeSet\" or \"TreeMap\"(based on the Red-Black tree)  on this case. \\n\\tIn conclusion, the time complexity is nlog(k), space complexity is O(k). Here, log(k) is every operation on Red-Black tree, \\n\\tn - size of the array, number of operations.\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\t\\tif (t < 0) {\\n\\t\\t  return false;\\n\\t\\t}\\n\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t  // initially we fill the tree set (red black tree) with first k numbers\\n\\t\\t  // after k characters we need to delete the first number, because we move the window\\n\\t\\t  // according the requirements |i-j| <= k\\n\\t\\t  if (i > k) {\\n\\t\\t\\tset.remove(nums[i - k - 1]);\\n\\t\\t  }\\n\\n\\t\\t  // if tree has already such number, recall |a-b| <= k, here a=a, logically we get difference zero\\n\\t\\t  if (set.contains(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t  }\\n\\n\\t\\t  if (t > 0) {\\n\\t\\t    // we need to find the max from smallest number so that difference <= k\\n\\t\\t\\t// also include the case when the number could be negative or bigger\\n\\t\\t\\tInteger lowerKey = set.lower(nums[i]);\\n\\t\\t\\tInteger higherKey = set.higher(nums[i]);\\n\\n\\t\\t\\tif ((lowerKey != null && Math.abs((long) lowerKey - nums[i]) <= t) ||\\n\\t\\t\\t\\t(higherKey != null && Math.abs((long) higherKey - nums[i]) <= t)) {\\n\\t\\t\\t  return true;\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  set.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 141084,
                "title": "python-sliding-window-and-bucket",
                "content": "```\\nclass Solution(object):\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0: # Input sanity check\\n            return False\\n        buckets = {}\\n        for i in xrange(0, len(nums)):\\n            m = nums[i] / (t+1)\\n            if m in buckets:\\n                return True\\n            if m-1 in buckets and abs(nums[i] - buckets[m-1]) <= t:\\n                return True\\n            if m+1 in buckets and abs(nums[i] - buckets[m+1]) <= t:\\n                return True\\n            buckets[m] = nums[i]\\n            if i - k >= 0:\\n                m_pop = nums[i-k] / (t+1)\\n                buckets.pop(m_pop, None)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0: # Input sanity check\\n            return False\\n        buckets = {}\\n        for i in xrange(0, len(nums)):\\n            m = nums[i] / (t+1)\\n            if m in buckets:\\n                return True\\n            if m-1 in buckets and abs(nums[i] - buckets[m-1]) <= t:\\n                return True\\n            if m+1 in buckets and abs(nums[i] - buckets[m+1]) <= t:\\n                return True\\n            buckets[m] = nums[i]\\n            if i - k >= 0:\\n                m_pop = nums[i-k] / (t+1)\\n                buckets.pop(m_pop, None)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61717,
                "title": "java-solution-10-12ms-bit-97-65-97-27",
                "content": "```\\npublic class Solution {\\n    TreeNode root = null;\\n    boolean flag = false;\\n\\n    /**\\n     * I think a lot time, but I still can deal with it in my way.\\n     * So I see this hint tags: binary search tree, so I try below method to solve.\\n     * <p>\\n     * <strong>result of test:</strong><br/>\\n     * 31 / 31 test cases passed\\n     * Status: Accepted\\n     * Runtime: 10 - 12ms, bit 97.65 - 97.27%\\n     * \\n     * @param nums\\n     * @param k\\n     * @param t\\n     * @return\\n     */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > k) {\\n                root = delete(root, nums[i - k - 1]);\\n            }\\n            root = insert(root, nums[i], t);\\n            if (flag) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public TreeNode insert(TreeNode root, int num, int t) {\\n        if (root == null) {\\n            TreeNode curNode = new TreeNode(num);\\n            return curNode;\\n        }\\n\\n        if (Math.abs((long) (root.val - num)) <= t) {\\n            flag = true;\\n            return root;\\n        }\\n\\n        if (root.val < num) {\\n            root.right = insert(root.right, num, t);\\n        } else if (root.val > num) {\\n            root.left = insert(root.left, num, t);\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode delete(TreeNode root, int num) {\\n        if (root == null) return null;\\n\\n        if (root.val < num) {\\n            root.right = delete(root.right, num);\\n        } else if (root.val > num) {\\n            root.left = delete(root.left, num);\\n        } else {\\n            if (root.left == null || root.right == null) {\\n                return root.left == null ? root.right : root.left;\\n            } else {\\n                //this sense that left and right is none null\\n                //this is a easy method to deal with it.\\n                //that exchange the root val with the min or max node\\n                root.val = findMin(root.right).val;\\n                root.right = delete(root.right, root.val);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode findMin(TreeNode node) {\\n        if (node == null) return null;\\n        while (node.left != null) {\\n            node = node.left;\\n        }\\n        return node;\\n    }\\n\\n    class TreeNode {\\n        /**\\n         * \\u6570\\u8282\\u70b9\\u503c\\n         */\\n        public int val;\\n        /**\\n         * \\u5de6\\u5b50\\u6811\\n         */\\n        public TreeNode left;\\n        /**\\n         * \\u53f3\\u5b50\\u6811\\n         */\\n        public TreeNode right;\\n\\n        public TreeNode(int x) {\\n            val = x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    TreeNode root = null;\\n    boolean flag = false;\\n\\n    /**\\n     * I think a lot time, but I still can deal with it in my way.\\n     * So I see this hint tags: binary search tree, so I try below method to solve.\\n     * <p>\\n     * <strong>result of test:</strong><br/>\\n     * 31 / 31 test cases passed\\n     * Status: Accepted\\n     * Runtime: 10 - 12ms, bit 97.65 - 97.27%\\n     * \\n     * @param nums\\n     * @param k\\n     * @param t\\n     * @return\\n     */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > k) {\\n                root = delete(root, nums[i - k - 1]);\\n            }\\n            root = insert(root, nums[i], t);\\n            if (flag) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public TreeNode insert(TreeNode root, int num, int t) {\\n        if (root == null) {\\n            TreeNode curNode = new TreeNode(num);\\n            return curNode;\\n        }\\n\\n        if (Math.abs((long) (root.val - num)) <= t) {\\n            flag = true;\\n            return root;\\n        }\\n\\n        if (root.val < num) {\\n            root.right = insert(root.right, num, t);\\n        } else if (root.val > num) {\\n            root.left = insert(root.left, num, t);\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode delete(TreeNode root, int num) {\\n        if (root == null) return null;\\n\\n        if (root.val < num) {\\n            root.right = delete(root.right, num);\\n        } else if (root.val > num) {\\n            root.left = delete(root.left, num);\\n        } else {\\n            if (root.left == null || root.right == null) {\\n                return root.left == null ? root.right : root.left;\\n            } else {\\n                //this sense that left and right is none null\\n                //this is a easy method to deal with it.\\n                //that exchange the root val with the min or max node\\n                root.val = findMin(root.right).val;\\n                root.right = delete(root.right, root.val);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode findMin(TreeNode node) {\\n        if (node == null) return null;\\n        while (node.left != null) {\\n            node = node.left;\\n        }\\n        return node;\\n    }\\n\\n    class TreeNode {\\n        /**\\n         * \\u6570\\u8282\\u70b9\\u503c\\n         */\\n        public int val;\\n        /**\\n         * \\u5de6\\u5b50\\u6811\\n         */\\n        public TreeNode left;\\n        /**\\n         * \\u53f3\\u5b50\\u6811\\n         */\\n        public TreeNode right;\\n\\n        public TreeNode(int x) {\\n            val = x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61701,
                "title": "simple-and-elegant-c-20ms-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector<pair<int, int>> a;\\n            for(int i = 0; i < nums.size(); ++i){\\n                a.push_back(make_pair(nums[i], i));\\n            }\\n            sort(a.begin(), a.end(), [](const pair<int, int> & a, const pair<int, int> & b)->bool{ return a.first < b.first; });\\n            int fast = 0, slow = 0;\\n            for(fast = 1; fast < nums.size(); ++fast){\\n                while((long long)a[fast].first - a[slow].first > t) ++slow;\\n                for(int i = slow; i < fast; ++i){\\n                    if(abs(a[i].second - a[fast].second) <= k) return 1;\\n                }\\n            }\\n            return 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector<pair<int, int>> a;\\n            for(int i = 0; i < nums.size(); ++i){\\n                a.push_back(make_pair(nums[i], i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61651,
                "title": "o-nlgk-solution-using-binary-search-tree-java",
                "content": "public class Solution {\\n    class TreeNode{\\n        long val;\\n        TreeNode left;\\n        TreeNode right;\\n        public TreeNode(long x) {\\n            val = x;\\n        }\\n    }\\n    \\n    private TreeNode add(TreeNode root, TreeNode nNode) {\\n        if(root == null) {\\n            return nNode;\\n        }\\n        else if(root.val < nNode.val) {\\n            root.right = add(root.right, nNode);\\n            return root;\\n        }\\n        else {\\n            root.left = add(root.left, nNode);\\n            return root;\\n        }\\n    }\\n\\n    private TreeNode delete(TreeNode root, TreeNode dNode) {\\n        if(root == null) {\\n            return null;\\n        }\\n        else if(root.val < dNode.val) {\\n            root.right = delete(root.right, dNode);\\n            return root;\\n        }\\n        else if(root.val > dNode.val) {\\n            root.left = delete(root.left, dNode);\\n            return root;\\n        }\\n        else if(root == dNode) {\\n             if(dNode.left == null && dNode.right == null) return null;\\n             else if(dNode.left != null && dNode.right == null) return dNode.left;\\n             else if(dNode.right != null && dNode.left == null) return dNode.right;\\n             else {\\n                 TreeNode p = dNode.right;\\n                 while(p.left != null) p = p.left;\\n                 dNode.right = delete(dNode.right, p);\\n                 p.left = dNode.left;\\n                 p.right = dNode.right;\\n                 return p;\\n             }\\n        }\\n        else {\\n            return root;\\n        }\\n    }\\n\\n    private boolean search(TreeNode root, long val, int t) {\\n        if(root == null) {\\n            return false;\\n        }\\n        else if(Math.abs((root.val - val)) <= t) {\\n            return true;\\n        }\\n        else if((root.val - val) > t) {\\n            return search(root.left, val, t);\\n        }\\n        else {\\n            return search(root.right, val, t);\\n        }\\n    }\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if(k < 1 || t < 0 || nums.length <= 1) {\\n            return false;\\n        }\\n        int len = nums.length;\\n        TreeNode[] map = new TreeNode[len];\\n        map[0] = new TreeNode((long)nums[0]);\\n        TreeNode root = null;\\n        root = add(root, map[0]);\\n        for(int i = 1; i < len; i++) {\\n            if(search(root, (long)nums[i], t)) {\\n                return true;\\n            }\\n            map[i] = new TreeNode((long)nums[i]);\\n            if(i - k >= 0) {\\n                root = delete(root, map[i-k]);\\n            }\\n            root = add(root, map[i]);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    class TreeNode{\\n        long val;\\n        TreeNode left;\\n        TreeNode right;\\n        public TreeNode(long x) {\\n            val = x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 61715,
                "title": "ac-java-solution-using-subset",
                "content": "\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    /*handle special case*/\\n        if(nums.length <= 1 || t < 0 || k < 1) {return false;}\\n        TreeSet<Long> set = new TreeSet<Long>();\\n        for(int i = 0; i < nums.length; i++){\\n            long min = Math.min((long)nums[i] - t,(long)nums[i] + t + 1);\\n            long max = Math.max((long)nums[i] - t, (long)nums[i] + t + 1);\\n        /*1.if the subset is not empty, means that we have the element that satisfy the requirement \\n          2.if we cannot add the element to the set, that means we already have the element*/\\n            if(!set.subSet(min,max).isEmpty() || !set.add((long)nums[i])) {return true;}\\n            set.add((long)nums[i]);\\n            if(i >= k) {set.remove((long)nums[i - k]);}\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    /*handle special case*/\\n        if(nums.length <= 1 || t < 0 || k < 1) {return false;}\\n        TreeSet<Long> set = new TreeSet<Long>();\\n        for(int i = 0; i < nums.length; i++){\\n            long min = Math.min((long)nums[i] - t,(long)nums[i] + t + 1);\\n            long max = Math.max((long)nums[i] - t, (long)nums[i] + t + 1);\\n        /*1.if the subset is not empty, means that we have the element that satisfy the requirement \\n          2.if we cannot add the element to the set, that means we already have the element*/\\n            if(!set.subSet(min,max).isEmpty() || !set.add((long)nums[i])) {return true;}\\n            set.add((long)nums[i]);\\n            if(i >= k) {set.remove((long)nums[i - k]);}\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 61729,
                "title": "java-treeset-26-ms-solution-optimized-with-a-custom-comparator",
                "content": "The problem with TreeSet solutions is not only that they are O(n log k) when there are O(n) solutions, but also that they search multiple times for the same value. Consider a typical `floor / ceiling` solution: first it checks for `floor` and `ceiling`, then it inserts the new value, and each of those operations is basically a search for the same value! How can we deal with that?\\n\\nOne idea is to perform the search once, finding the floor, ceiling and insertion point at the same time. Moreover, if the floor or the ceiling are too close, we don't even want to continue the search: we can return true immediately. But how do we do this?\\n\\nOne way is to create a custom BST implementation. This can get ugly especially if you do RBT rebalancing. But there is a smarter way. Note that `TreeSet` doesn't insert a value if there is already such value in the set (it is a set, after all). What if we want to achieve the same effect when the value is not exactly equal to some other, but almost equal (within the margin of `t`)? Why not trick it into thinking that these values are indeed equal? Especially since the docs openly state that `TreeSet` / `TreeMap` only relies on `compare` / `Comparator` and not on `equals` when checking for equality.\\n\\nNote that our \"equality\" violates one property of equality: it's not transitive. No big deal, though, because the set will only contain distinct (according to our \"equality\" criterion) values, and for \"less\" / \"greater\" relationships transitivity is preserved.\\n\\nSo here you go. Still O(n log k) but twice faster than the `floor / ceiling` one.\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, final int t) {\\n        if (k == 0 || nums.length <= 1) {\\n            return false;\\n        }\\n        if (k >= nums.length) {\\n            k = nums.length - 1; // note: mutating a formal parameter!\\n        }\\n        NavigableSet<Integer> kSet = new TreeSet<>(new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer i1, Integer i2) {\\n                long diff = (long) i1 - i2; // long because can overflow\\n                if (Math.abs(diff) <= t) {\\n                    return 0;\\n                } else {\\n                    return diff > 0 ? +1 : -1;\\n                }\\n            }\\n        });\\n        for (int i = 0; i <= k; ++i) {\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        for (int i = k + 1; i < nums.length; ++i) {\\n            kSet.remove(nums[i - k - 1]);\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "The problem with TreeSet solutions is not only that they are O(n log k) when there are O(n) solutions, but also that they search multiple times for the same value. Consider a typical `floor / ceiling` solution: first it checks for `floor` and `ceiling`, then it inserts the new value, and each of those operations is basically a search for the same value! How can we deal with that?\\n\\nOne idea is to perform the search once, finding the floor, ceiling and insertion point at the same time. Moreover, if the floor or the ceiling are too close, we don't even want to continue the search: we can return true immediately. But how do we do this?\\n\\nOne way is to create a custom BST implementation. This can get ugly especially if you do RBT rebalancing. But there is a smarter way. Note that `TreeSet` doesn't insert a value if there is already such value in the set (it is a set, after all). What if we want to achieve the same effect when the value is not exactly equal to some other, but almost equal (within the margin of `t`)? Why not trick it into thinking that these values are indeed equal? Especially since the docs openly state that `TreeSet` / `TreeMap` only relies on `compare` / `Comparator` and not on `equals` when checking for equality.\\n\\nNote that our \"equality\" violates one property of equality: it's not transitive. No big deal, though, because the set will only contain distinct (according to our \"equality\" criterion) values, and for \"less\" / \"greater\" relationships transitivity is preserved.\\n\\nSo here you go. Still O(n log k) but twice faster than the `floor / ceiling` one.\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, final int t) {\\n        if (k == 0 || nums.length <= 1) {\\n            return false;\\n        }\\n        if (k >= nums.length) {\\n            k = nums.length - 1; // note: mutating a formal parameter!\\n        }\\n        NavigableSet<Integer> kSet = new TreeSet<>(new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer i1, Integer i2) {\\n                long diff = (long) i1 - i2; // long because can overflow\\n                if (Math.abs(diff) <= t) {\\n                    return 0;\\n                } else {\\n                    return diff > 0 ? +1 : -1;\\n                }\\n            }\\n        });\\n        for (int i = 0; i <= k; ++i) {\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        for (int i = k + 1; i < nums.length; ++i) {\\n            kSet.remove(nums[i - k - 1]);\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61709,
                "title": "22ms-java-straight-forward-sorting-solution-beats-87-92-solutions-surprisingly-fast",
                "content": "This is my first thought on this problem, sort the input with index info saved and search as far as the value difference is less than or equal to k.  For worst case scenario, the search would be O(n^2), but this solution is surprisingly fast, my thought would be the test cases are not covering the case that all the input is within the value difference of k.\\n\\n    public class Solution {\\n        \\n        class Pair {\\n            int val;\\n            int index;\\n            Pair(int v, int i) {\\n                this.val = v;\\n                this.index = i;\\n            }\\n        }\\n        \\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (nums == null || nums.length < 2 || t < 0 || k < 1) {\\n                return false;\\n            }\\n            int len = nums.length;\\n            Pair[] pair = new Pair[len];\\n            for(int i = 0; i < len; i++) {\\n                pair[i] = new Pair(nums[i], i);\\n            }\\n            \\n            Arrays.sort(pair, new Comparator<Pair> () {\\n              public int compare(Pair p1, Pair p2) {\\n                  return p1.val - p2.val;\\n              } \\n            });\\n            \\n            for(int i = 0; i < len; i++) {\\n                for(int j = i + 1; j < len && Math.abs((long)pair[j].val - (long)pair[i].val) <= (long)t; j++){\\n                    int indexDiff = Math.abs(pair[i].index - pair[j].index);\\n                    if (indexDiff <= k) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        class Pair {\\n            int val;\\n            int index;\\n            Pair(int v, int i) {\\n                this.val = v;\\n                this.index = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61719,
                "title": "why-no-one-posted-o-n-solution-in-c-using-bucket-sort",
                "content": "I couldn't find the C++ solution using bucket sort in the discussions. So I want to share my accepted version. Hopefully it could help those who only use C++ like me and really want to see people could improve upon it since it now runs 36ms.\\nHere is the explanation of this code. The logic is borrowed from https://leetcode.com/discuss/38206/ac-o-n-solution-in-java-using-buckets-with-explanation by lx223. My initial effort using the bucket sort on this problem failed miserably because I did not consider the situation that nums[i] and nums[j] could be put into neighboring buckets even if their difference is not greater than t. So I searched the forum and saw lx223's brilliant design/implementation. As the Java version, I used a unordered_map \"buckets\" to store the most recent k nums,\\nwhere the key is the bucket index calculated from nums[i] , and the value is simply the nums[i]. Therefore, whenever we encounter a new nums[i] there are 3 possibilities we can find a match: 1. the same bucket index of nums[i]: \"idx\" is already in buckets, since we define the bucket width to be w=t+1, this means a match has been found. 2. If the neighboring index idx-1 is in \"buckets\" and it's corresponding value nums[j] satisfies the constraint: abs(nums[i]-nums[j])<=t, then a match is also found. 3. The same condition check as #2 for the neighbor idx+1. Finally, whenever the size of buckets reached the limit k, we need to remove the oldest idx from buckets for the new one. However C++ unordered_map does not keep the insertion order of its keys, so I used a list to keep track of the oldest idx which is always the first node in the list. BTW: the using of long long is to handle the test cases where the t and values of nums are INT_MAX.\\n\\n    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            int len=(int) nums.size();\\n            if(len<2||k<1||t<0) return false;\\n            \\n            int mn=nums[0]];\\n            for(int i=1; i<len; ++i) mn=min(mn, nums[i]);\\n            \\n            long long w=t+1;\\n            int numBuckets=k;\\n            unordered_map<int, int> buckets;\\n            list<int> idxList;\\n            for(int i=0; i<len; ++i) {\\n                int idx=((long long)nums[i]-mn)/w;\\n                \\n                if(buckets.find(idx)!=buckets.end()) return true;\\n                else if(buckets.find(idx-1)!=buckets.end()\\n                        &&abs((long long)nums[i]-buckets[idx-1])<=t) return true;\\n                else if(buckets.find(idx+1)!=buckets.end()\\n                         &&abs((long long)nums[i]-buckets[idx+1])<=t) return true;\\n                         \\n                if((int)buckets.size()==numBuckets) {\\n                    buckets.erase(idxList.front());\\n                    idxList.pop_front();\\n                }\\n                \\n                buckets[idx]=nums[i];\\n                idxList.push_back(idx);\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            int len=(int) nums.size();\\n            if(len<2||k<1||t<0) return false;\\n            \\n            int mn=nums[0]];\\n            for(int i=1; i<len; ++i) mn=min(mn, nums[i]);\\n            \\n            long long w=t+1;\\n            int numBuckets=k;\\n            unordered_map<int, int> buckets;\\n            list<int> idxList;\\n            for(int i=0; i<len; ++i) {\\n                int idx=((long long)nums[i]-mn)/w;\\n                \\n                if(buckets.find(idx)!=buckets.end()) return true;\\n                else if(buckets.find(idx-1)!=buckets.end()\\n                        &&abs((long long)nums[i]-buckets[idx-1])<=t) return true;\\n                else if(buckets.find(idx+1)!=buckets.end()\\n                         &&abs((long long)nums[i]-buckets[idx+1])<=t) return true;\\n                         \\n                if((int)buckets.size()==numBuckets) {\\n                    buckets.erase(idxList.front());\\n                    idxList.pop_front();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61747,
                "title": "c-28ms-solution-using-multimap",
                "content": "    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap<long, int> map;\\n        //sort and record index\\n        for (int i = 0; i < nums.size(); i++) {\\n            map.insert(make_pair(nums[i], i));\\n        }\\n        auto p1 = map.begin();\\n        while (p1 != map.end()) {\\n            auto p2 = p1;\\n            p2++;\\n            while (p2 != map.end() && p2->first - p1->first <= t) {\\n                if (abs(p1->second - p2->second) <= k)\\n                    return true;\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap<long, int> map;\\n        //sort and record index\\n        for (int i = 0; i < nums.size(); i++) {\\n            map.insert(make_pair(nums[i], i));\\n        }\\n        auto p1 = map.begin();\\n        while (p1 != map.end()) {\\n            auto p2 = p1;\\n            p2++;\\n            while (p2 != map.end() && p2->first - p1->first <= t) {\\n                if (abs(p1->second - p2->second) <= k)\\n                    return true;\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2683830,
                "title": "custom-sliding-window-no-data-structure-used",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        int window ;\\n        for (int i = 0; i < n; i++) {\\n            window = i + indexDiff;\\n            for (int j = i + 1; j <= window ; j++) {\\n                if(j == n){\\n                    break;\\n                }\\n                if (Math.abs(nums[i] - nums[j]) <= valueDiff){\\n                    return true;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        int window ;\\n        for (int i = 0; i < n; i++) {\\n            window = i + indexDiff;\\n            for (int j = i + 1; j <= window ; j++) {\\n                if(j == n){\\n                    break;\\n                }\\n                if (Math.abs(nums[i] - nums[j]) <= valueDiff){\\n                    return true;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298891,
                "title": "two-python-solutions-memory-optimization-speed-optimization",
                "content": "Good Memory Optimization But Slow\\n\\n```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k +=1\\n        res = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(res)):\\n            if res[i]-res[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            res.remove(nums[i-1])\\n            res.add(nums[i+k-1])\\n            idx = bisect.bisect_left(res, num)\\n            \\n            if (idx-1 >= 0 and num-res[idx-1]<=t) or (idx+1<k and res[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n```\\n\\nVery Fast but takes lot of memory\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t == 0 and len(set(nums)) == len(nums): return False\\n        \\n        bucket = {}\\n        width = t + 1\\n        \\n        for i, n in enumerate(nums):\\n            bucket_i = n // width\\n            \\n            if bucket_i in bucket: return True\\n            elif bucket_i + 1 in bucket and abs(n - bucket[bucket_i + 1]) < width: return True\\n            elif bucket_i - 1 in bucket and abs(n - bucket[bucket_i - 1]) < width: return True\\n            \\n            bucket[bucket_i] = n\\n            if i >= k: del bucket[ nums[i-k] //width ]\\n                \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k +=1\\n        res = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(res)):\\n            if res[i]-res[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            res.remove(nums[i-1])\\n            res.add(nums[i+k-1])\\n            idx = bisect.bisect_left(res, num)\\n            \\n            if (idx-1 >= 0 and num-res[idx-1]<=t) or (idx+1<k and res[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t == 0 and len(set(nums)) == len(nums): return False\\n        \\n        bucket = {}\\n        width = t + 1\\n        \\n        for i, n in enumerate(nums):\\n            bucket_i = n // width\\n            \\n            if bucket_i in bucket: return True\\n            elif bucket_i + 1 in bucket and abs(n - bucket[bucket_i + 1]) < width: return True\\n            elif bucket_i - 1 in bucket and abs(n - bucket[bucket_i - 1]) < width: return True\\n            \\n            bucket[bucket_i] = n\\n            if i >= k: del bucket[ nums[i-k] //width ]\\n                \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191052,
                "title": "simple-java-solution-using-treeset",
                "content": "\\tclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        //nums = [1,2,3,1], k = 3, t = 0\\n        for(int i = 0; i < nums.length; i++){\\n            Long cur = (long) nums[i];\\n            //greatest element that is less than or equal to current\\n            Long floor = treeSet.floor(cur);\\n            //smallest element that is greater than or equal to current\\n            Long ceiling = treeSet.ceiling(cur);\\n            \\n            if(null != floor && Math.abs(floor - cur) <= t)\\n                return true;\\n            \\n            if(null != ceiling && Math.abs(ceiling - cur) <= t)\\n                return true;\\n            \\n            treeSet.add(cur);\\n            if(treeSet.size() > k)\\n                treeSet.remove((long)nums[i-k]);            \\n        }\\n        return false;        \\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        //nums = [1,2,3,1], k = 3, t = 0\\n        for(int i = 0; i < nums.length; i++){\\n            Long cur = (long) nums[i];\\n            //greatest element that is less than or equal to current\\n            Long floor = treeSet.floor(cur);\\n            //smallest element that is greater than or equal to current\\n            Long ceiling = treeSet.ceiling(cur);\\n            \\n            if(null != floor && Math.abs(floor - cur) <= t)\\n                return true;\\n            \\n            if(null != ceiling && Math.abs(ceiling - cur) <= t)\\n                return true;\\n            \\n            treeSet.add(cur);\\n            if(treeSet.size() > k)\\n                treeSet.remove((long)nums[i-k]);            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2184020,
                "title": "c-o-n-hashmap-buckets-well-commented-easy-to-understand-beats-95",
                "content": "```\\n// The idea is that we maintain a set of ranges (buckets) that the given condition can be satisfied in.\\n// I.e. \\'k\\' buckets of size t + 1 - for each nums[i] that is currently in the window (hence the size k).\\n// The size of each container is t + 1 so that the absolute difference of any 2 numbers in the group will be at most t.\\n// E.g. 4, 5, 6, 7 or 0, -1, -2, -3\\n// Then, each number is mapped into its bucket by getBucketId. It\\'s a bit tricky in order to corrently handle negtive numbers.\\n// For example, buckets[0] has both positive and negative numbers mapped to it. E.g. when t = 3, number 3 and -3 would be mapped to \\n// buckets[0] if we just used simple division.\\n// As specified, the program should return true if any of the following conditions is true for a given nums[i]\\n// 1. the bucket for nums[i] already has a number in it - this means the existing number and nums[i] are within the range t\\n// 2. the bucket immediately to the left has a value and that value is within the range t\\n// 3. the bucket immediately to the right has a value and that value is within the range t\\n// Note that those are only 3 buckets that we need to check as by definition all other buckets are more than t apart from nums[i]\\n\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        Dictionary<long, long> buckets = new();\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            long bucket = getBucketId(nums[i]);\\n            \\n            if (buckets.ContainsKey(bucket)) return true;\\n            \\n            if (buckets.TryGetValue(bucket - 1, out long leftValue) && Math.Abs(leftValue - nums[i]) <= t) return true;\\n            \\n            if (buckets.TryGetValue(bucket + 1, out long rightValue) && Math.Abs(rightValue - nums[i]) <= t) return true;\\n            \\n            buckets.Add(bucket, nums[i]);\\n            \\n            if (buckets.Count > k) buckets.Remove(getBucketId(nums[i - k]));\\n        }\\n        \\n        return false;\\n        \\n        \\n        int getBucketId(int number)\\n        {\\n            int bucketId = number / (t + 1);\\n            \\n            if (number < 0) bucketId--;\\n            \\n            return bucketId;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// The idea is that we maintain a set of ranges (buckets) that the given condition can be satisfied in.\\n// I.e. \\'k\\' buckets of size t + 1 - for each nums[i] that is currently in the window (hence the size k).\\n// The size of each container is t + 1 so that the absolute difference of any 2 numbers in the group will be at most t.\\n// E.g. 4, 5, 6, 7 or 0, -1, -2, -3\\n// Then, each number is mapped into its bucket by getBucketId. It\\'s a bit tricky in order to corrently handle negtive numbers.\\n// For example, buckets[0] has both positive and negative numbers mapped to it. E.g. when t = 3, number 3 and -3 would be mapped to \\n// buckets[0] if we just used simple division.\\n// As specified, the program should return true if any of the following conditions is true for a given nums[i]\\n// 1. the bucket for nums[i] already has a number in it - this means the existing number and nums[i] are within the range t\\n// 2. the bucket immediately to the left has a value and that value is within the range t\\n// 3. the bucket immediately to the right has a value and that value is within the range t\\n// Note that those are only 3 buckets that we need to check as by definition all other buckets are more than t apart from nums[i]\\n\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        Dictionary<long, long> buckets = new();\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            long bucket = getBucketId(nums[i]);\\n            \\n            if (buckets.ContainsKey(bucket)) return true;\\n            \\n            if (buckets.TryGetValue(bucket - 1, out long leftValue) && Math.Abs(leftValue - nums[i]) <= t) return true;\\n            \\n            if (buckets.TryGetValue(bucket + 1, out long rightValue) && Math.Abs(rightValue - nums[i]) <= t) return true;\\n            \\n            buckets.Add(bucket, nums[i]);\\n            \\n            if (buckets.Count > k) buckets.Remove(getBucketId(nums[i - k]));\\n        }\\n        \\n        return false;\\n        \\n        \\n        int getBucketId(int number)\\n        {\\n            int bucketId = number / (t + 1);\\n            \\n            if (number < 0) bucketId--;\\n            \\n            return bucketId;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850389,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    private SortedSet<long> neighbours = new();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        \\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            if(neighbours.GetViewBetween(Convert.ToInt64(nums[i]) - t, Convert.ToInt64(nums[i]) + t).Any())\\n                return true;\\n            \\n            neighbours.Add(nums[i]);\\n            \\n            if(i>=k)\\n                neighbours.Remove(nums[i-k]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private SortedSet<long> neighbours = new();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        \\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            if(neighbours.GetViewBetween(Convert.ToInt64(nums[i]) - t, Convert.ToInt64(nums[i]) + t).Any())\\n                return true;\\n            \\n            neighbours.Add(nums[i]);\\n            \\n            if(i>=k)\\n                neighbours.Remove(nums[i-k]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790952,
                "title": "c-solution-beats-90-vector-simple-and-clean-code",
                "content": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n\\tint n=nums.size();\\n\\tvector<pair<long,int>> vec;//vector to store <value,index> pair\\n\\tfor(int i=0;i<n;i++) vec.push_back({nums[i],i});\\n\\tsort(vec.begin(),vec.end());//sort based on values\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t//iterate from i+1th index to some j such that differnce of values (vec[j]-vec[i])<=t  \\n\\t\\tfor(int j=i+1;j<n and (vec[j].first*1L-vec[i].first)<=t;j++){\\n\\t\\t\\t//if the absolute difference of indices <=k then required pair is found \\n\\t\\t\\tif(abs(vec[j].second-vec[i].second)<=k) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Please Upvote :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n\\tint n=nums.size();\\n\\tvector<pair<long,int>> vec;//vector to store <value,index> pair\\n\\tfor(int i=0;i<n;i++) vec.push_back({nums[i],i});\\n\\tsort(vec.begin(),vec.end());//sort based on values\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t//iterate from i+1th index to some j such that differnce of values (vec[j]-vec[i])<=t  \\n\\t\\tfor(int j=i+1;j<n and (vec[j].first*1L-vec[i].first)<=t;j++){\\n\\t\\t\\t//if the absolute difference of indices <=k then required pair is found \\n\\t\\t\\tif(abs(vec[j].second-vec[i].second)<=k) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1754612,
                "title": "python-o-nlogk-sliding-window-sortedcontainers-binary-search",
                "content": "```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k+=1\\n        temp = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(temp)):\\n            if temp[i]-temp[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            temp.remove(nums[i-1])\\n            temp.add(nums[i+k-1])\\n            idx = bisect.bisect_left(temp, num)\\n            \\n            if (idx-1 >= 0 and num-temp[idx-1]<=t) or (idx+1<k and temp[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k+=1\\n        temp = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(temp)):\\n            if temp[i]-temp[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            temp.remove(nums[i-1])\\n            temp.add(nums[i+k-1])\\n            idx = bisect.bisect_left(temp, num)\\n            \\n            if (idx-1 >= 0 and num-temp[idx-1]<=t) or (idx+1<k and temp[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515793,
                "title": "go-clean-code-16ms-beats-100",
                "content": "```\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n\\tdata := make(map[int]int)\\n\\tfor i, num := range nums {\\n\\t\\tbucket := helper(num, t+1)\\n\\t\\tif _, ok := data[bucket]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket-1]; ok && num-value <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket+1]; ok && value-num <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tdata[bucket] = num\\n\\t\\tif i >= k {\\n\\t\\t\\tdelete(data, helper(nums[i-k], t+1))\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc helper(num, w int) int {\\n\\tif num < 0 {\\n\\t\\treturn num/w - 1\\n\\t}\\n\\treturn num / w\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n\\tdata := make(map[int]int)\\n\\tfor i, num := range nums {\\n\\t\\tbucket := helper(num, t+1)\\n\\t\\tif _, ok := data[bucket]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket-1]; ok && num-value <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket+1]; ok && value-num <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tdata[bucket] = num\\n\\t\\tif i >= k {\\n\\t\\t\\tdelete(data, helper(nums[i-k], t+1))\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc helper(num, w int) int {\\n\\tif num < 0 {\\n\\t\\treturn num/w - 1\\n\\t}\\n\\treturn num / w\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441301,
                "title": "python-simple-solution-without-using-heaps-bst-bucket-sort",
                "content": "A brute force solution for this problem would entail checking all the possible pairs and then see if their absolute values differ by less than equal to t and their indices differ by less than equal to k.\\n\\nThe following code considers the values and indices of each of the elements in the array and sorts them. We can then go through the sorted array and perform checks for each encountered index until it meets another index such that their difference is <= k as long as the abs difference between their values is <= t. We return such a find immediately so as to not continue checking.\\n\\nYour suggestions are welcome! Happy learning! \\n\\t\\n```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n       \\n\\tsorted_nums = []\\n\\tfor i, num in enumerate(nums):\\n\\t\\tsorted_nums.append((num,i))\\n\\n\\tsorted_nums = sorted(sorted_nums)\\n\\n\\tfor i in range(len(nums)-1):\\n\\t\\tj = i+1\\n\\t\\twhile(j <= len(nums)-1 and abs(sorted_nums[j][0]-sorted_nums[i][0])<=t):\\n\\t\\t\\tif abs(sorted_nums[j][1]-sorted_nums[i][1]) <= k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tj+=1\\n\\treturn False\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n       \\n\\tsorted_nums = []\\n\\tfor i, num in enumerate(nums):\\n\\t\\tsorted_nums.append((num,i))\\n\\n\\tsorted_nums = sorted(sorted_nums)\\n\\n\\tfor i in range(len(nums)-1):\\n\\t\\tj = i+1\\n\\t\\twhile(j <= len(nums)-1 and abs(sorted_nums[j][0]-sorted_nums[i][0])<=t):\\n\\t\\t\\tif abs(sorted_nums[j][1]-sorted_nums[i][1]) <= k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tj+=1\\n\\treturn False\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1093140,
                "title": "c-easy-solution-using-pair-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        if(n==0) return false; // Null vector\\n        pair<long long int,int> a[n]; \\n        for(int i=0;i<n;++i)\\n        {\\n            a[i].first = (long long int)nums[i]; // Elements \\n            a[i].second = i; // Indices\\n        }\\n        sort(a,a+n); // Sort the pair array in ascending order\\n        for(int i=0;i<n;++i)\\n        {\\n            long long int n1 = a[i].first; // Current element\\n            for(int j=i+1;j<n;++j) // Next element\\n            {\\n                long long int n2 = a[j].first; \\n                long long int diff = abs(n1-n2);\\n                if(diff>t) // We do not need to check any further\\n                    break;\\n                if(diff<=(long)t && abs(a[i].second-a[j].second)<=k) // Checking for both conditions\\n                    return true; // Return true if found such pair\\n            }\\n        }\\n        return false; // Return false if no such pair is found\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        if(n==0) return false; // Null vector\\n        pair<long long int,int> a[n]; \\n        for(int i=0;i<n;++i)\\n        {\\n            a[i].first = (long long int)nums[i]; // Elements \\n            a[i].second = i; // Indices\\n        }\\n        sort(a,a+n); // Sort the pair array in ascending order\\n        for(int i=0;i<n;++i)\\n        {\\n            long long int n1 = a[i].first; // Current element\\n            for(int j=i+1;j<n;++j) // Next element\\n            {\\n                long long int n2 = a[j].first; \\n                long long int diff = abs(n1-n2);\\n                if(diff>t) // We do not need to check any further\\n                    break;\\n                if(diff<=(long)t && abs(a[i].second-a[j].second)<=k) // Checking for both conditions\\n                    return true; // Return true if found such pair\\n            }\\n        }\\n        return false; // Return false if no such pair is found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842070,
                "title": "javascript-version-of-bst-implement-solution",
                "content": "Javascript has no TreeSet so just manually implement it.\\n\\n```\\nclass Node {\\n    constructor (x) {\\n        this.val = x;\\n        this.left = null;\\n        this.right = null;\\n    }\\n    \\n    successor () {\\n        var node = this;\\n        if (node && node.right) {\\n            node = node.right;\\n            while (node.left) {\\n                node = node.left;\\n            }\\n        }\\n        return node;\\n    }\\n    \\n    predecessor () {\\n        var node = this;\\n        if (node && node.left) {\\n            node = node.left;\\n            while (node.right) {\\n                node = node.right;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n\\nclass BST {\\n    constructor () {\\n        this.root = null;\\n    }\\n    \\n    add (root, val) {\\n        if (!root) {\\n            return new Node(val);\\n        }\\n        if (root.val < val) root.right = this.add(root.right, val);\\n        else root.left = this.add(root.left, val);\\n        return root;\\n    }\\n    \\n    search (root, val) {\\n        if (!root) return null;\\n        if (root.val === val) return root;\\n        if (root.val < val) return this.search(root.right, val);\\n        else return this.search(root.left, val);\\n    }\\n    \\n    nextBigger(root, val) {\\n        var nextBigger = null;\\n        while (root) {\\n            if (root.val >= val) {\\n                nextBigger = root;\\n                root = root.left;\\n            }\\n            else {\\n                root = root.right;\\n            }\\n        }\\n        return nextBigger;\\n    }\\n    \\n    prevSmaller (root, val) {\\n        var prevSmaller = null;\\n        while (root) {\\n            if (root.val <= val) {\\n                prevSmaller = root;\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            }\\n        }\\n        return prevSmaller;\\n    }\\n    \\n    delete (root, val) {\\n        if (!root) return null;\\n        if (root.val < val) {\\n            root.right = this.delete(root.right, val);\\n        }\\n        else if (root.val > val) {\\n            root.left = this.delete(root.left, val);\\n        }\\n        else {\\n            if (root.right) {\\n                var next = root.successor();\\n                root.val = next.val;\\n                root.right = this.delete(root.right, next.val);\\n            }\\n            else if (root.left) {\\n                var prev = root.predecessor();\\n                root.val = prev.val;\\n                root.left = this.delete(root.left, prev.val);\\n            }\\n            else root = null;\\n        }\\n        return root;\\n    }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    var bst = new BST();\\n    for (var i = 0; i < nums.length; i++) {\\n        // Get first node that is >= nums[i]\\n        var next = bst.nextBigger(bst.root, nums[i]);\\n        if (next && next.val <= nums[i] + t) return true;\\n        // Get last node that is <= nums[i]\\n        var prev = bst.prevSmaller(bst.root, nums[i]);\\n        if (prev && prev.val >= nums[i] - t) return true;\\n        bst.root = bst.add(bst.root, nums[i]);\\n        if (k <= i) {\\n            bst.root = bst.delete(bst.root, nums[i - k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Node {\\n    constructor (x) {\\n        this.val = x;\\n        this.left = null;\\n        this.right = null;\\n    }\\n    \\n    successor () {\\n        var node = this;\\n        if (node && node.right) {\\n            node = node.right;\\n            while (node.left) {\\n                node = node.left;\\n            }\\n        }\\n        return node;\\n    }\\n    \\n    predecessor () {\\n        var node = this;\\n        if (node && node.left) {\\n            node = node.left;\\n            while (node.right) {\\n                node = node.right;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n\\nclass BST {\\n    constructor () {\\n        this.root = null;\\n    }\\n    \\n    add (root, val) {\\n        if (!root) {\\n            return new Node(val);\\n        }\\n        if (root.val < val) root.right = this.add(root.right, val);\\n        else root.left = this.add(root.left, val);\\n        return root;\\n    }\\n    \\n    search (root, val) {\\n        if (!root) return null;\\n        if (root.val === val) return root;\\n        if (root.val < val) return this.search(root.right, val);\\n        else return this.search(root.left, val);\\n    }\\n    \\n    nextBigger(root, val) {\\n        var nextBigger = null;\\n        while (root) {\\n            if (root.val >= val) {\\n                nextBigger = root;\\n                root = root.left;\\n            }\\n            else {\\n                root = root.right;\\n            }\\n        }\\n        return nextBigger;\\n    }\\n    \\n    prevSmaller (root, val) {\\n        var prevSmaller = null;\\n        while (root) {\\n            if (root.val <= val) {\\n                prevSmaller = root;\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            }\\n        }\\n        return prevSmaller;\\n    }\\n    \\n    delete (root, val) {\\n        if (!root) return null;\\n        if (root.val < val) {\\n            root.right = this.delete(root.right, val);\\n        }\\n        else if (root.val > val) {\\n            root.left = this.delete(root.left, val);\\n        }\\n        else {\\n            if (root.right) {\\n                var next = root.successor();\\n                root.val = next.val;\\n                root.right = this.delete(root.right, next.val);\\n            }\\n            else if (root.left) {\\n                var prev = root.predecessor();\\n                root.val = prev.val;\\n                root.left = this.delete(root.left, prev.val);\\n            }\\n            else root = null;\\n        }\\n        return root;\\n    }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    var bst = new BST();\\n    for (var i = 0; i < nums.length; i++) {\\n        // Get first node that is >= nums[i]\\n        var next = bst.nextBigger(bst.root, nums[i]);\\n        if (next && next.val <= nums[i] + t) return true;\\n        // Get last node that is <= nums[i]\\n        var prev = bst.prevSmaller(bst.root, nums[i]);\\n        if (prev && prev.val >= nums[i] - t) return true;\\n        bst.root = bst.add(bst.root, nums[i]);\\n        if (k <= i) {\\n            bst.root = bst.delete(bst.root, nums[i - k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825896,
                "title": "go-golang-solution",
                "content": ">Runtime: 4 ms, faster than 100.00% of Go online submissions for Contains Duplicate III.\\nMemory Usage: 3.9 MB, less than 46.59% of Go online submissions for Contains Duplicate III.\\n\\n```go\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n    if t < 0 { return false }\\n    m := make(map[int]int)\\n    for i := 0; i < len(nums); i++ {\\n        key := nums[i] / max(t, 1)\\n        if nums[i] < 0 { key-- }\\n        if _, ok := m[key]; ok { return true }\\n        if v, ok := m[key - 1]; ok && abs(nums[i] - v) <= t { return true }\\n        if v, ok := m[key + 1]; ok && abs(nums[i] - v) <= t { return true }\\n        m[key] = nums[i]\\n        if i >= k { delete(m, nums[i - k] / max(t, 1)) }\\n    }\\n    return false\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n    if t < 0 { return false }\\n    m := make(map[int]int)\\n    for i := 0; i < len(nums); i++ {\\n        key := nums[i] / max(t, 1)\\n        if nums[i] < 0 { key-- }\\n        if _, ok := m[key]; ok { return true }\\n        if v, ok := m[key - 1]; ok && abs(nums[i] - v) <= t { return true }\\n        if v, ok := m[key + 1]; ok && abs(nums[i] - v) <= t { return true }\\n        m[key] = nums[i]\\n        if i >= k { delete(m, nums[i - k] / max(t, 1)) }\\n    }\\n    return false\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825231,
                "title": "o-n-time-o-k-space-solution-code-explanation",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n        bucket_dict = {}\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n            # Checking cache for duplicates\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            # Adding new bucket to cache\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n        return False\\n```\\n**Explanation**\\nFirst things first: there are some annoying test cases to consider. For example: nums = [-1,-1], k = 1, t = -1 where t (absolute value) can be negative... Another weird case is when k = 0. Thus in the very first step we make sure that when k <= 0 or t < 0 the function returns False:\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n```\\nLet\\'s get to the main idea. We want to solve this problem in one-pass, that is in a time O(N).  First we divide all integer into buckets with size t+1. For example bucket with an index 0 consists of all numbers 0,1,...,t; bucket with an index 1 consists of all numbers t+1,...2 * t + 1 and so on. We will put all values in a respective bucket. The function returns True if and only if there are two values in the same bucket or there are two values in nearby by buckets with a difference smaller than t.\\nBecause we are looking for values with index difference at most k, we will use a [deque](https://docs.python.org/2/library/collections.html#collections.deque) bucket_cache with maximal size k to store all bucket indices of last k elements:\\n```\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n```\\nAnd a dictionary bucket_dict storing all pairs (bucket index, value):\\n```\\n        bucket_dict = {}\\n```\\nWe start a loop over all values of nums:\\n```\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n```\\nWe check our cache, if there are duplicates:\\n```\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n```\\nWe add new value to our cache:\\n```\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n```\\nIf there were no duplicates the function returns False:\\n```\\n        return False\\n```\\n**Complexity**\\nBecause we check it in one-pass, time complexity is equal to O(N). Because we remember only last k values, space complexity is equal to O(k).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n        bucket_dict = {}\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n            # Checking cache for duplicates\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            # Adding new bucket to cache\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n```\n```\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n```\n```\\n        bucket_dict = {}\\n```\n```\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n```\n```\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n```\n```\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n```\n```\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824735,
                "title": "java-treemap-sliding-window-o-n-log-k",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i - j > k) {\\n                if(contains(map, nums, j, t)) return true;\\n                j++;\\n            }\\n            long val = nums[i];\\n            map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n\\n        while(j < nums.length) {\\n            if(contains(map, nums, j, t)) return true;\\n            j++;\\n        }\\n        return false;\\n    }\\n\\n    private boolean contains(TreeMap<Long, Integer> map, int[] nums, int j, int t) {\\n        \\n        long val = nums[j];\\n        Integer count = map.get(val);\\n        Long diff;\\n        if(count != null && count > 1) {\\n            map.put(val, count - 1);\\n        } else {\\n            map.remove(val);\\n        }\\n        if((diff = map.floorKey(t + val)) != null && Math.abs(diff - nums[j]) <= t) return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i - j > k) {\\n                if(contains(map, nums, j, t)) return true;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 824613,
                "title": "c-simple-sorting-and-check-values-within-bound-o-n-log-n-nt",
                "content": "```csharp\\npublic bool ContainsNearbyAlmostDuplicate(int[] nums, int k, long t)\\n{\\n\\tvar sorted = nums.Select((value, index) => new { value, index }).OrderBy(x => x.value).ToArray();\\n\\n\\tfor(int i = 0; i < sorted.Length; i++)\\n\\t{\\n\\t\\tlong currentNum = sorted[i].value;\\n\\n\\t\\tfor(int j = i + 1; j < sorted.Length && (sorted[j].value - currentNum) <= t; j++)\\n\\t\\t{\\n\\t\\t\\tif(Math.Abs(sorted[i].index - sorted[j].index) <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic bool ContainsNearbyAlmostDuplicate(int[] nums, int k, long t)\\n{\\n\\tvar sorted = nums.Select((value, index) => new { value, index }).OrderBy(x => x.value).ToArray();\\n\\n\\tfor(int i = 0; i < sorted.Length; i++)\\n\\t{\\n\\t\\tlong currentNum = sorted[i].value;\\n\\n\\t\\tfor(int j = i + 1; j < sorted.Length && (sorted[j].value - currentNum) <= t; j++)\\n\\t\\t{\\n\\t\\t\\tif(Math.Abs(sorted[i].index - sorted[j].index) <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771756,
                "title": "swift-bucket-solution",
                "content": "**Overview**\\nI\\'ve updated this solution since the problem was used in the September daily challenge. The idea is based on \"bucket sort\". Map each number to a bucket based on the width `t` (we use `t + 1` to ensure no division by zero). If a number is already in the bucket, then we have a match and return true. We also have to check the neighboring buckets because a number at the upper range of bucket `i` may match with a number at the lower end of bucket `i+1`. The value `k` defines a sliding window. Whenever a number is longer in the window we must remove it from the bucket. \\n\\n\\n**Solution**\\n```swift\\nfunc containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n\\tguard t >= 0, k > 0 else { return false }\\n\\tvar buckets = [Int: Int]() \\n\\tvar window = k + 1 \\n\\tvar width = t + 1\\n\\n\\t/// Maps a number to its corresponding bucket \\n\\tfunc map(_ num: Int) -> Int {\\n\\t\\treturn (num / width) - ((num < 0) ? 1 : 0)\\n\\t}\\n\\n\\tfor (idx, num) in nums.enumerated() {\\n\\t\\tlet bucket = map(num)\\n\\n\\t\\t// Check exact bucket\\n\\t\\tif buckets[bucket] != nil {\\n\\t\\t\\treturn true \\n\\t\\t} else {\\n\\t\\t\\tbuckets[bucket] = num  \\n\\t\\t}\\n\\n\\t\\t// Check neighbor buckets\\n\\t\\tif let prev = buckets[bucket-1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\tif let prev = buckets[bucket+1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\t// Slide Window \\n\\t\\tif idx - k >= 0 {\\n\\t\\t\\tbuckets.removeValue(forKey: map(nums[idx-k]))\\n\\t\\t}\\n\\t}\\n\\n\\treturn false \\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n\\tguard t >= 0, k > 0 else { return false }\\n\\tvar buckets = [Int: Int]() \\n\\tvar window = k + 1 \\n\\tvar width = t + 1\\n\\n\\t/// Maps a number to its corresponding bucket \\n\\tfunc map(_ num: Int) -> Int {\\n\\t\\treturn (num / width) - ((num < 0) ? 1 : 0)\\n\\t}\\n\\n\\tfor (idx, num) in nums.enumerated() {\\n\\t\\tlet bucket = map(num)\\n\\n\\t\\t// Check exact bucket\\n\\t\\tif buckets[bucket] != nil {\\n\\t\\t\\treturn true \\n\\t\\t} else {\\n\\t\\t\\tbuckets[bucket] = num  \\n\\t\\t}\\n\\n\\t\\t// Check neighbor buckets\\n\\t\\tif let prev = buckets[bucket-1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\tif let prev = buckets[bucket+1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\t// Slide Window \\n\\t\\tif idx - k >= 0 {\\n\\t\\t\\tbuckets.removeValue(forKey: map(nums[idx-k]))\\n\\t\\t}\\n\\t}\\n\\n\\treturn false \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736563,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if k <= 0 || t < 0 {\\n            return false;\\n        }\\n        let t = t as i64;\\n        nums.iter()\\n            .map(|n| *n as i64)\\n            .enumerate()\\n            .try_fold(BTreeSet::new(), |mut s, (i, n)| {\\n                match s.range((n - t)..=(n + t)).next() {\\n                    Some(_) => None,\\n                    _ => {\\n                        if i >= k as usize {\\n                            s.remove(&(nums[i - k as usize] as i64));\\n                        }\\n                        s.insert(n);\\n                        Some(s)\\n                    }\\n                }\\n            })\\n            .is_none()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if k <= 0 || t < 0 {\\n            return false;\\n        }\\n        let t = t as i64;\\n        nums.iter()\\n            .map(|n| *n as i64)\\n            .enumerate()\\n            .try_fold(BTreeSet::new(), |mut s, (i, n)| {\\n                match s.range((n - t)..=(n + t)).next() {\\n                    Some(_) => None,\\n                    _ => {\\n                        if i >= k as usize {\\n                            s.remove(&(nums[i - k as usize] as i64));\\n                        }\\n                        s.insert(n);\\n                        Some(s)\\n                    }\\n                }\\n            })\\n            .is_none()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674158,
                "title": "python-o-n-in-7-simple-lines",
                "content": "It\\'s actually a lot less tricky than a lot of code I\\'ve seen makes it out to be.  Use a defaultdict to avoid so many ifs.\\n\\n```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tif t < 0: return False\\n\\td = collections.defaultdict(lambda:float(\\'inf\\'))\\n\\tfor i,n in enumerate(nums):\\n\\t\\tif i-k > 0: del d[nums[i-k-1] // (t+1)]\\n\\t\\tkey = n // (t+1)\\n\\t\\tif min(map(abs, [n-d[key-1], n-d[key], n-d[key+1]])) <= t: return True\\n\\t\\td[key] = nums[i]\\n```",
                "solutionTags": [],
                "code": "```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tif t < 0: return False\\n\\td = collections.defaultdict(lambda:float(\\'inf\\'))\\n\\tfor i,n in enumerate(nums):\\n\\t\\tif i-k > 0: del d[nums[i-k-1] // (t+1)]\\n\\t\\tkey = n // (t+1)\\n\\t\\tif min(map(abs, [n-d[key-1], n-d[key], n-d[key+1]])) <= t: return True\\n\\t\\td[key] = nums[i]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 608981,
                "title": "java-solution-step-by-step",
                "content": "Clarify:\\nreturn true if (nums[i] - nums[j]) <= t && j - i <= k\\n\\nMethod1: Sliding Window\\n\\nWindow size: k + 1\\n\\nif(max - min <= t) return ture;\\n\\nTC: O(k + (n-k)*k)\\nSC: O(k)\\n    \\nMethod2: Using Balanced Binary Search Tree to reduce time to find cloest number.\\n    \\n1. Build a size (k + 1) bbs tree\\n2. Traverse the rest (n - k - 1) elements\\n    Step1: remove the last element ==> remove(nums[i - k])\\n    Step2: find the cloest number to the new element ==> findCloestInTree(nums[i])\\n            if foundElement - nums[i] <= t ==> return true\\n    Step3: add new element into tree ==> add(nums[i])\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> bbsTree = new TreeSet<>();\\n        int output = 2147483647 - (-1);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > k) {\\n                bbsTree.remove(nums[i - k - 1]);\\n            }\\n            Integer ceil = bbsTree.ceiling(nums[i]);\\n            if(ceil != null && ceil <= t + nums[i]) {\\n                return true;\\n            }\\n            Integer floor = bbsTree.floor(nums[i]);\\n            if(floor != null && nums[i] <= t + floor) {\\n                return true;\\n            }\\n            bbsTree.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\nTC: O(k + (n - k)logk)\\nSC: O(k)\\n    \\nMethod3: Using Buckets to save the range numbers. Each bucket save range t numbers.\\nEach time, we find get save target into one bucket:\\n    1. if bucket is filled, return true;   \\n    2. if last bucket or next bucket is filled and difference between number in those bucket with current element is <= k, return true\\n    3. implement current bucket\\nImplementation: We use a map<Double, Integer> to save target Number and index\\nTC: O(n))\\nSC: O(buket_size) Worst Case: O(maximum number - minimum number)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> bbsTree = new TreeSet<>();\\n        int output = 2147483647 - (-1);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > k) {\\n                bbsTree.remove(nums[i - k - 1]);\\n            }\\n            Integer ceil = bbsTree.ceiling(nums[i]);\\n            if(ceil != null && ceil <= t + nums[i]) {\\n                return true;\\n            }\\n            Integer floor = bbsTree.floor(nums[i]);\\n            if(floor != null && nums[i] <= t + floor) {\\n                return true;\\n            }\\n            bbsTree.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599202,
                "title": "c-solutions-using-bst-or-buckets",
                "content": "SortedSet is actually BST.\\nIt has a method \\'GetViewBetween(lower, upper)\\', what can be used to check if we have already had an element in range \\'t\\'.\\nSo all we need is to run through the array once, adding new values to the BST and removing the least \\'k\\' value from it.\\nWhen ve find any item in \\'ViewBetween\\' -- that means we found Duplicate.\\n\\n```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.Length == 0 || k < 1 || t < 0) return false;\\n\\n        var sortedSet = new SortedSet<int>();\\n\\n        for (var i = 0; i < nums.Length; i++) {\\n            if (ContainsElementsInRange(sortedSet, nums[i], t)) return true;\\n\\n            if (sortedSet.Count == k) sortedSet.Remove(nums[i - k]);\\n            if (!sortedSet.Add(nums[i])) return true;\\n        }\\n        return false;\\n    }\\n\\n    private static bool ContainsElementsInRange(SortedSet<int> sortedSet, int center, int radius) {\\n\\n        var lower = (long) center - radius < int.MinValue ? int.MinValue : center - radius;\\n        var upper = (long) center + radius > int.MaxValue ? int.MaxValue : center + radius;\\n\\n        return sortedSet.GetViewBetween(lower, upper).Count > 0;\\n    }\\n```\\n\\nAnd here is another solution using Dictionary of buckets instead of BST.\\nI\\'ve outspokenly stolen buckets idea from [here](https://leetcode.com/problems/contains-duplicate-iii/discuss/61645/AC-O(N)-solution-in-Java-using-buckets-with-explanation) ).\\n\\n```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        var map = new Dictionary<long, long>();\\n        \\n        for (var i = 0; i < nums.Length; i++) {\\n            var (key, value) = GetBucket(nums[i], t);\\n            if (!map.TryAdd(key, value)\\n                || map.ContainsKey(key - 1) && value - map[key - 1] <= t\\n                || map.ContainsKey(key + 1) && map[key + 1] - value <= t) return true;\\n            if (map.Count > k) map.Remove(GetBucket(nums[i - k], t).Key);\\n        }\\n        return false;\\n    }\\n    \\n    private static KeyValuePair<long, long> GetBucket(int num, int t) {\\n        var value = (long) num - int.MinValue;\\n        var key = value / ((long) t + 1);\\n        return new KeyValuePair<long, long>(key, value);\\n    }\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.Length == 0 || k < 1 || t < 0) return false;\\n\\n        var sortedSet = new SortedSet<int>();\\n\\n        for (var i = 0; i < nums.Length; i++) {\\n            if (ContainsElementsInRange(sortedSet, nums[i], t)) return true;\\n\\n            if (sortedSet.Count == k) sortedSet.Remove(nums[i - k]);\\n            if (!sortedSet.Add(nums[i])) return true;\\n        }\\n        return false;\\n    }\\n\\n    private static bool ContainsElementsInRange(SortedSet<int> sortedSet, int center, int radius) {\\n\\n        var lower = (long) center - radius < int.MinValue ? int.MinValue : center - radius;\\n        var upper = (long) center + radius > int.MaxValue ? int.MaxValue : center + radius;\\n\\n        return sortedSet.GetViewBetween(lower, upper).Count > 0;\\n    }\\n```\n```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        var map = new Dictionary<long, long>();\\n        \\n        for (var i = 0; i < nums.Length; i++) {\\n            var (key, value) = GetBucket(nums[i], t);\\n            if (!map.TryAdd(key, value)\\n                || map.ContainsKey(key - 1) && value - map[key - 1] <= t\\n                || map.ContainsKey(key + 1) && map[key + 1] - value <= t) return true;\\n            if (map.Count > k) map.Remove(GetBucket(nums[i - k], t).Key);\\n        }\\n        return false;\\n    }\\n    \\n    private static KeyValuePair<long, long> GetBucket(int num, int t) {\\n        var value = (long) num - int.MinValue;\\n        var key = value / ((long) t + 1);\\n        return new KeyValuePair<long, long>(key, value);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512397,
                "title": "rust-4ms-solution-with-btreeset",
                "content": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if t < 0 {\\n            return false;\\n        }\\n        let k = k as usize;\\n        let t = t as i64;\\n        let mut bts: BTreeSet<i64> = BTreeSet::new();\\n        for i in 0..nums.len() {\\n            if i > k as usize {\\n                bts.remove(&(nums[i - 1 - k] as i64));\\n            }\\n            if bts\\n                .range(nums[i] as i64 - t..=nums[i] as i64 + t)\\n                .next()\\n                .is_some()\\n            {\\n                return true;\\n            }\\n            bts.insert(nums[i] as i64);\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Ordered Set"
                ],
                "code": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if t < 0 {\\n            return false;\\n        }\\n        let k = k as usize;\\n        let t = t as i64;\\n        let mut bts: BTreeSet<i64> = BTreeSet::new();\\n        for i in 0..nums.len() {\\n            if i > k as usize {\\n                bts.remove(&(nums[i - 1 - k] as i64));\\n            }\\n            if bts\\n                .range(nums[i] as i64 - t..=nums[i] as i64 + t)\\n                .next()\\n                .is_some()\\n            {\\n                return true;\\n            }\\n            bts.insert(nums[i] as i64);\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442478,
                "title": "a-simple-java-solution-using-treemap-14-ms",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        int len=nums.length;\\n        if(len<=1||k<=0||t<0) return false;\\n        TreeMap<Long,Integer> mp=new TreeMap<>();\\n        for(int i=0;i<len;++i){\\n            Map<Long,Integer> tmpMap=mp.subMap((long)nums[i]-t,(long)nums[i]+t+1);\\n            if(tmpMap.isEmpty()){\\n                mp.put((long)nums[i],i);\\n            }else{\\n                Map<Long,Integer> tmp=new TreeMap<>();\\n                for(long key:tmpMap.keySet()){\\n                    int tmpIndex=tmpMap.get(key);\\n                    if(i-tmpIndex<=k){\\n                        return true;\\n                    }else{\\n                        tmp.put((long)nums[i],i);\\n                    }\\n                }\\n                mp.putAll(tmp);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        int len=nums.length;\\n        if(len<=1||k<=0||t<0) return false;\\n        TreeMap<Long,Integer> mp=new TreeMap<>();\\n        for(int i=0;i<len;++i){\\n            Map<Long,Integer> tmpMap=mp.subMap((long)nums[i]-t,(long)nums[i]+t+1);\\n            if(tmpMap.isEmpty()){\\n                mp.put((long)nums[i],i);\\n            }else{\\n                Map<Long,Integer> tmp=new TreeMap<>();\\n                for(long key:tmpMap.keySet()){\\n                    int tmpIndex=tmpMap.get(key);\\n                    if(i-tmpIndex<=k){\\n                        return true;\\n                    }else{\\n                        tmp.put((long)nums[i],i);\\n                    }\\n                }\\n                mp.putAll(tmp);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365721,
                "title": "python-range-sum-using-bit-o-nlogn",
                "content": "```python\\nclass BIT(object):\\n    def __init__(self, N):\\n        self.vals = [0] * (N+1)\\n    def add(self, idx, val):\\n        while idx < len(self.vals):\\n            self.vals[idx] += val\\n            idx += idx & -idx\\n    def query(self, idx):\\n        res = 0\\n        while idx:\\n            res += self.vals[idx]\\n            idx -= idx & -idx\\n        return res\\n\\nclass Solution(object):\\n    def bin_search(self, arr, val):\\n        if arr[0] >= val:\\n            return -1\\n        if arr[-1] < val:\\n            return len(arr) - 1\\n        l, r = 0, len(arr) - 1\\n        while r - l > 1:\\n            m = (r + l) >> 1\\n            if arr[m] >= val:\\n                r = m\\n            else:\\n                l = m\\n        return l\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        ns = sorted(list(set(nums)))\\n        n2i = {ns[i]: i for i in range(len(ns))}\\n        \\n        off = 5\\n        bit = BIT(len(ns) + 15)\\n        \\n        N = len(nums)\\n        for i in range(N):\\n            if i - k - 1 >= 0:\\n                bit.add(n2i[nums[i-k-1]] + off, -1)\\n                \\n            n = nums[i]\\n            lower = self.bin_search(ns, n - t)\\n            upper = self.bin_search(ns, n + t + 1)\\n            cnt = bit.query(upper + off) - bit.query(lower + off)\\n            if cnt > 0:\\n                return True\\n            bit.add(n2i[n] + off, 1)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass BIT(object):\\n    def __init__(self, N):\\n        self.vals = [0] * (N+1)\\n    def add(self, idx, val):\\n        while idx < len(self.vals):\\n            self.vals[idx] += val\\n            idx += idx & -idx\\n    def query(self, idx):\\n        res = 0\\n        while idx:\\n            res += self.vals[idx]\\n            idx -= idx & -idx\\n        return res\\n\\nclass Solution(object):\\n    def bin_search(self, arr, val):\\n        if arr[0] >= val:\\n            return -1\\n        if arr[-1] < val:\\n            return len(arr) - 1\\n        l, r = 0, len(arr) - 1\\n        while r - l > 1:\\n            m = (r + l) >> 1\\n            if arr[m] >= val:\\n                r = m\\n            else:\\n                l = m\\n        return l\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        ns = sorted(list(set(nums)))\\n        n2i = {ns[i]: i for i in range(len(ns))}\\n        \\n        off = 5\\n        bit = BIT(len(ns) + 15)\\n        \\n        N = len(nums)\\n        for i in range(N):\\n            if i - k - 1 >= 0:\\n                bit.add(n2i[nums[i-k-1]] + off, -1)\\n                \\n            n = nums[i]\\n            lower = self.bin_search(ns, n - t)\\n            upper = self.bin_search(ns, n + t + 1)\\n            cnt = bit.query(upper + off) - bit.query(lower + off)\\n            if cnt > 0:\\n                return True\\n            bit.add(n2i[n] + off, 1)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359420,
                "title": "o-n-solution-using-buckets-and-a-detailed-simplified-explanation-of-how-it-works",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if( k < 1 || t < 0)\\n            return false;\\n            LinkedHashMap<Long, Long> map = new LinkedHashMap<>(k);\\n            for(int num : nums){\\n                // convert any negative into positive\\n                long remappedNum = (long)num - Integer.MIN_VALUE;\\n                long bucket;\\n                // this bucket concept is not clear out of the box, so I try to make it easier to understand.\\n                // suppose you have a num let\\'s say = 50, and t = 5\\n                // to achieve that we find a number X that Math.abs(50-X) == 5\\n                // we search or a number, that would have the same output, if we divide it by 5\\n                // given that we always round the output, as we use integers, not float\\n                // so 45/5=9 while 50/5=10, which means that 45 belongs to the bucket before 50\\n                // another example, 55/5 = 11, which means that 55 belongs to the same bucket as 50\\n                // which means, that the absolute difference between both = 5\\n                // if we consider 44 for ex, you find 44/5=8 which is less than 10-1 (50 bucket)\\n                // For the case for 56, so bucket is = 56/5=11, which is bucket(50)+1\\n                // in this case, we still need to validate manually that 56-50 <= 5\\n                if( t == 0)\\n                    bucket = remappedNum;\\n                else\\n                    bucket = remappedNum/((long)(t));\\n                if( map.containsKey(bucket)\\n                  || (map.containsKey(bucket-1) && Math.abs(map.get(bucket-1) - remappedNum) <= t)\\n                  || (map.containsKey(bucket+1) && Math.abs(map.get(bucket+1) - remappedNum) <= t)){\\n                    return true;\\n                }\\n                // to achieve the k goal which is the max diff between the positions\\n                // of the two numbers in the array, we maintain only max k numbers in the map\\n                // Since this is LinkedListMap which keeps track of the order of the elements\\n                // inserted, we can always remove the first element, whenever we reach the k size\\n                if( map.size() >= k){\\n                    map.remove(map.keySet().iterator().next());\\n                }\\n                map.put(bucket, remappedNum);\\n            }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if( k < 1 || t < 0)\\n            return false;\\n            LinkedHashMap<Long, Long> map = new LinkedHashMap<>(k);\\n            for(int num : nums){\\n                // convert any negative into positive\\n                long remappedNum = (long)num - Integer.MIN_VALUE;\\n                long bucket;\\n                // this bucket concept is not clear out of the box, so I try to make it easier to understand.\\n                // suppose you have a num let\\'s say = 50, and t = 5\\n                // to achieve that we find a number X that Math.abs(50-X) == 5\\n                // we search or a number, that would have the same output, if we divide it by 5\\n                // given that we always round the output, as we use integers, not float\\n                // so 45/5=9 while 50/5=10, which means that 45 belongs to the bucket before 50\\n                // another example, 55/5 = 11, which means that 55 belongs to the same bucket as 50\\n                // which means, that the absolute difference between both = 5\\n                // if we consider 44 for ex, you find 44/5=8 which is less than 10-1 (50 bucket)\\n                // For the case for 56, so bucket is = 56/5=11, which is bucket(50)+1\\n                // in this case, we still need to validate manually that 56-50 <= 5\\n                if( t == 0)\\n                    bucket = remappedNum;\\n                else\\n                    bucket = remappedNum/((long)(t));\\n                if( map.containsKey(bucket)\\n                  || (map.containsKey(bucket-1) && Math.abs(map.get(bucket-1) - remappedNum) <= t)\\n                  || (map.containsKey(bucket+1) && Math.abs(map.get(bucket+1) - remappedNum) <= t)){\\n                    return true;\\n                }\\n                // to achieve the k goal which is the max diff between the positions\\n                // of the two numbers in the array, we maintain only max k numbers in the map\\n                // Since this is LinkedListMap which keeps track of the order of the elements\\n                // inserted, we can always remove the first element, whenever we reach the k size\\n                if( map.size() >= k){\\n                    map.remove(map.keySet().iterator().next());\\n                }\\n                map.put(bucket, remappedNum);\\n            }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352950,
                "title": "c-beating-98-67-simple-program",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int, int>>dup;\\n        for(int i=0; i<nums.size();i++){\\n            dup.push_back(make_pair(nums[i],i));\\n        }\\n        \\n        sort(dup.begin(), dup.end());\\n        for(int i=0; i<nums.size();i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(dup[i].first+t>=dup[j].first){\\n                   if(abs(dup[i].second-dup[j].second)<=k){\\n                        return true;\\n               } \\n                }\\n                else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int, int>>dup;\\n        for(int i=0; i<nums.size();i++){\\n            dup.push_back(make_pair(nums[i],i));\\n        }\\n        \\n        sort(dup.begin(), dup.end());\\n        for(int i=0; i<nums.size();i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(dup[i].first+t>=dup[j].first){\\n                   if(abs(dup[i].second-dup[j].second)<=k){\\n                        return true;\\n               } \\n                }\\n                else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260610,
                "title": "javascript-95-o-nlogn",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    const sortedIndex = nums.map((num, i) => ({num, i})).sort((a,b) => a.num-b.num);\\n    let start = 0;\\n    let end = 1;\\n    \\n    while(end < sortedIndex.length) {\\n        if (start === end) {\\n            end++;\\n            continue;\\n        }\\n        \\n        const a = sortedIndex[start];\\n        const b = sortedIndex[end];\\n        \\n        if (b.num - a.num > t) {\\n            start++;\\n            continue;\\n        }\\n        \\n        if (Math.abs(b.i - a.i) > k) {\\n            end++;\\n            continue;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    const sortedIndex = nums.map((num, i) => ({num, i})).sort((a,b) => a.num-b.num);\\n    let start = 0;\\n    let end = 1;\\n    \\n    while(end < sortedIndex.length) {\\n        if (start === end) {\\n            end++;\\n            continue;\\n        }\\n        \\n        const a = sortedIndex[start];\\n        const b = sortedIndex[end];\\n        \\n        if (b.num - a.num > t) {\\n            start++;\\n            continue;\\n        }\\n        \\n        if (Math.abs(b.i - a.i) > k) {\\n            end++;\\n            continue;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 214078,
                "title": "java-solution-with-0-nk",
                "content": "Runtime: 6 ms, faster than 97.37% of Java online submissions for Contains Duplicate III.\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        if(nums.length<2){\\n            return false;\\n        }\\n\\t\\tHashSet<Integer> hs = new HashSet<Integer>();\\n\\t\\t\\n\\t\\tfor(int i=0; i<nums.length; i++)\\n\\t\\t{\\n\\t\\ths.add(nums[i]);\\n\\t\\t}\\n\\t\\tif(t==0 && nums.length == hs.size())\\n\\t\\t{\\n\\t\\treturn false;\\n\\t\\t}\\n        \\n        for(int i=0; i<nums.length; i++)\\n        {\\n          for(int j=i+1;j<=i+k &&j<nums.length;j++)\\n          {\\n            /*if((nums[j] ==  Integer.MAX_VALUE && start<0) || (nums[j] <0 && start==Integer.MAX_VALUE))\\n            {\\n                return false;\\n            }*/ // dont do this. tradoff with variable data size.\\n             \\n              if(Math.abs((long)nums[j]-(long)nums[i]) <= (long)t)  {\\n                return true;\\n            }\\n          }\\n        }\\n        \\n     return false;   \\n    }\\n}\\n\\nTwo important points for noting down;\\n\\n1) Convert to long in case of overflow.\\n2) The hashset is needed incase t==0, and the list contains duplicate elements.\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        if(nums.length<2){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 142040,
                "title": "naive-python-solution-beat-97",
                "content": "```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t==0 and len(nums)== len(set(nums)): \\n            return False\\n        for i in range(len(nums)):\\n            for j in range(1,k+1):\\n                if i+j >= len(nums):break\\n                if abs(nums[i+j]-nums[i])<=t:return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t==0 and len(nums)== len(set(nums)): \\n            return False\\n        for i in range(len(nums)):\\n            for j in range(1,k+1):\\n                if i+j >= len(nums):break\\n                if abs(nums[i+j]-nums[i])<=t:return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61674,
                "title": "my-c-solution-by-sortedset",
                "content": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        if(nums == null || nums.Count()<2 || k < 1 || t<0)\\n            return false;\\n        var ss = new SortedSet<long>();\\n        for(int i = 0; i<nums.Count(); i++)\\n        {\\n            if(i>k)\\n            {\\n                ss.Remove(nums[i-k-1]);\\n            }\\n            if(ss.GetViewBetween((long)nums[i]-t, (long)nums[i]+t).Count()>0)\\n                return true;\\n            ss.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        if(nums == null || nums.Count()<2 || k < 1 || t<0)\\n            return false;\\n        var ss = new SortedSet<long>();\\n        for(int i = 0; i<nums.Count(); i++)\\n        {\\n            if(i>k)\\n            {\\n                ss.Remove(nums[i-k-1]);\\n            }\\n            if(ss.GetViewBetween((long)nums[i]-t, (long)nums[i]+t).Count()>0)\\n                return true;\\n            ss.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61713,
                "title": "c-solution-using-bucket-beats-99-6",
                "content": "Inspired by @maruchan76 https://discuss.leetcode.com/topic/29477/why-no-one-posted-o-n-solution-in-c-using-bucket-sort,  but use a array (buckets) to store the indices of numbers in vector \"nums\" without using unordered_map. Use type long long to prevent overflow.\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        int min_num = INT_MAX;\\n        int max_num = INT_MIN;\\n        for (auto& num: nums) {\\n            min_num = std::min(min_num, num);\\n            max_num = std::max(max_num, num);\\n        }\\n        long long bucket_width = static_cast<long long>(t) + 1;\\n        int size = (static_cast<long long>(max_num) - static_cast<long long>(min_num)) / bucket_width + 1;\\n        int* bucket = new int[size];\\n        memset(bucket, -1, sizeof(int) * size);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int bucket_idx = (static_cast<long long>(nums[i])-min_num) / bucket_width;\\n            if (bucket[bucket_idx] >= 0)\\n                return true;\\n            bucket[bucket_idx] = i;\\n            if (bucket_idx >= 1) {\\n                int j = bucket[bucket_idx-1];\\n                if (j >= 0 && abs(static_cast<long long>(nums[i]) - nums[j]) <= t)\\n                    return true;\\n            }\\n            if (bucket_idx < size-1) {\\n                int l = bucket[bucket_idx+1];\\n                if (l >= 0 && abs(static_cast<long long>(nums[i]) - nums[l]) <= t)\\n                    return true;\\n            }\\n            if (i >= k) {\\n                bucket[(nums[i-k] - min_num) / bucket_width] = -1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        int min_num = INT_MAX;\\n        int max_num = INT_MIN;\\n        for (auto& num: nums) {\\n            min_num = std::min(min_num, num);\\n            max_num = std::max(max_num, num);\\n        }\\n        long long bucket_width = static_cast<long long>(t) + 1;\\n        int size = (static_cast<long long>(max_num) - static_cast<long long>(min_num)) / bucket_width + 1;\\n        int* bucket = new int[size];\\n        memset(bucket, -1, sizeof(int) * size);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int bucket_idx = (static_cast<long long>(nums[i])-min_num) / bucket_width;\\n            if (bucket[bucket_idx] >= 0)\\n                return true;\\n            bucket[bucket_idx] = i;\\n            if (bucket_idx >= 1) {\\n                int j = bucket[bucket_idx-1];\\n                if (j >= 0 && abs(static_cast<long long>(nums[i]) - nums[j]) <= t)\\n                    return true;\\n            }\\n            if (bucket_idx < size-1) {\\n                int l = bucket[bucket_idx+1];\\n                if (l >= 0 && abs(static_cast<long long>(nums[i]) - nums[l]) <= t)\\n                    return true;\\n            }\\n            if (i >= k) {\\n                bucket[(nums[i-k] - min_num) / bucket_width] = -1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61772,
                "title": "i-finally-got-ac-in-java-with-the-coherent-code",
                "content": "First,let's start with simple and instuitive method which is two loop ,one for enumerating the nums[i] ,the other one for enumerating the nums[j] ,j-i<=k;\\n\\n    Pseudo code:\\n                            for(int i=0;i<nums.length-1;i++)\\n                                     for(int j=1;j<=k;j++) //becaust the problem indicate the distinct i and j,so j start from 1\\n                                             see if there exist the difference bettween nums[i] and nums[j+i]\\n                                              is at most t;\\n\\n\\nthis method is timeout with no doubt,how can we improve it?.if we notice  in the second loop that everytime i++, we will take o(n) time make comparison,but the number used to compare  actually change one.so if we use a good data structure store it,everytime we will just take o(logN) to compare and O(logN) to change one number in this data structure.most People use set data structure to store it.you can choose the others.\\n\\n    Pseudo code:\\n                           for(int i=0;i<nums.length-1;i++)\\n                                     see if there exist the difference bettween nums[i] and the number\\n                                                      in the set is at most t.               \\n\\n                               \\nfinally ,if you want the AC,you must take care some boundary problems. the following is my AC code which is not perfect ,just for refer.\\n\\n     public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t){\\n\\t\\t TreeSet<Integer> set = new TreeSet<Integer>();\\n\\t\\t if(nums.length==0 || k==0)\\n\\t\\t\\t return false;\\n\\t\\t k=k<nums.length-1?k:nums.length-1;\\n\\t\\t for(int i=1;i<=k;i++)\\n\\t\\t\\t set.add(nums[i]);\\n\\t\\t for(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t if(nums[i]-t-1>=nums[i]+t)\\n\\t\\t\\t\\t return false;\\n\\t\\t\\t if(!set.subSet(nums[i]-t, nums[i]+t).isEmpty()||set.contains(nums[i]+t))\\t\\t \\n\\t\\t\\t\\t return true;\\t\\t\\t\\t \\n\\t\\t\\t else{\\n\\t\\t\\t\\t if(i!=nums.length-2)\\n\\t\\t\\t\\t\\t set.remove(nums[i+1]);\\n\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t break;\\n\\t\\t\\t\\t if(i+k+1 <nums.length)\\n\\t\\t\\t\\t\\t set.add(nums[i+k+1]);\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return false;\\n\\t }",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "First,let's start with simple and instuitive method which is two loop ,one for enumerating the nums[i] ,the other one for enumerating the nums[j] ,j-i<=k;\\n\\n    Pseudo code:\\n                            for(int i=0;i<nums.length-1;i++)\\n                                     for(int j=1;j<=k;j++) //becaust the problem indicate the distinct i and j,so j start from 1\\n                                             see if there exist the difference bettween nums[i] and nums[j+i]\\n                                              is at most t;\\n\\n\\nthis method is timeout with no doubt,how can we improve it?.if we notice  in the second loop that everytime i++, we will take o(n) time make comparison,but the number used to compare  actually change one.so if we use a good data structure store it,everytime we will just take o(logN) to compare and O(logN) to change one number in this data structure.most People use set data structure to store it.you can choose the others.\\n\\n    Pseudo code:\\n                           for(int i=0;i<nums.length-1;i++)\\n                                     see if there exist the difference bettween nums[i] and the number\\n                                                      in the set is at most t.               \\n\\n                               \\nfinally ,if you want the AC,you must take care some boundary problems. the following is my AC code which is not perfect ,just for refer.\\n\\n     public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t){\\n\\t\\t TreeSet<Integer> set = new TreeSet<Integer>();\\n\\t\\t if(nums.length==0 || k==0)\\n\\t\\t\\t return false;\\n\\t\\t k=k<nums.length-1?k:nums.length-1;\\n\\t\\t for(int i=1;i<=k;i++)\\n\\t\\t\\t set.add(nums[i]);\\n\\t\\t for(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t if(nums[i]-t-1>=nums[i]+t)\\n\\t\\t\\t\\t return false;\\n\\t\\t\\t if(!set.subSet(nums[i]-t, nums[i]+t).isEmpty()||set.contains(nums[i]+t))\\t\\t \\n\\t\\t\\t\\t return true;\\t\\t\\t\\t \\n\\t\\t\\t else{\\n\\t\\t\\t\\t if(i!=nums.length-2)\\n\\t\\t\\t\\t\\t set.remove(nums[i+1]);\\n\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t break;\\n\\t\\t\\t\\t if(i+k+1 <nums.length)\\n\\t\\t\\t\\t\\t set.add(nums[i+k+1]);\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return false;\\n\\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 3695012,
                "title": "simple-and-easier-way-to-solve-using-java",
                "content": "# Intuition\\nThe program asks us to check whether 2 elements has difference in their indices at most equal to indexDiff and a difference in their values at most equal to valueDiff..\\n\\n# Approach\\n 1.initial loop should cover each element\\'s position\\n  2.second loop should start from the following element of i and should work till i+IndexDiff,since we need to find the indices whose difference is equal to IndexDiff.\\nEvery time we have i and we have a fixed IndexDiff so to find the range of j we can just add i and indexdiff but to find exact which value of j works we start the j loop where we continue with the checkings and if succeded return true\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) \\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<=i+indexDiff;j++)\\n            {\\n                if(j<nums.length)\\n                {\\n                 if(Math.abs(i-j)<=indexDiff && Math.abs(nums[i]-nums[j])<=valueDiff)\\n                    {\\n                       return true;\\n                        \\n                    }\\n                }\\n                \\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) \\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<=i+indexDiff;j++)\\n            {\\n                if(j<nums.length)\\n                {\\n                 if(Math.abs(i-j)<=indexDiff && Math.abs(nums[i]-nums[j])<=valueDiff)\\n                    {\\n                       return true;\\n                        \\n                    }\\n                }\\n                \\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435588,
                "title": "simple-c-vector-of-pair-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        vector<pair<int,int>> v;    //val,pos\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=i+1;j<v.size();j++)\\n            {\\n                if(abs(v[i].first-v[j].first)<=valueDiff && abs(v[i].second-v[j].second)<=indexDiff)\\n                    return true;\\n                else if(abs(v[i].first-v[j].first)>valueDiff)\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        vector<pair<int,int>> v;    //val,pos\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=i+1;j<v.size();j++)\\n            {\\n                if(abs(v[i].first-v[j].first)<=valueDiff && abs(v[i].second-v[j].second)<=indexDiff)\\n                    return true;\\n                else if(abs(v[i].first-v[j].first)>valueDiff)\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773111,
                "title": "javascript-solution",
                "content": "1)Sliding Window\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n\\tlet first = 0\\n    let i = 0\\n    while (first < nums.length-1) {\\n        let diif1 = Math.abs(first - i++)\\n        let dif = Math.abs(nums[first] - nums[i])\\n        if (diif1 <= indexDiff && dif <= valueDiff)\\n            return true\\n        else if (i - first == indexDiff) {\\n            first++\\n            i = first\\n        }\\n    }\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "1)Sliding Window\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n\\tlet first = 0\\n    let i = 0\\n    while (first < nums.length-1) {\\n        let diif1 = Math.abs(first - i++)\\n        let dif = Math.abs(nums[first] - nums[i])\\n        if (diif1 <= indexDiff && dif <= valueDiff)\\n            return true\\n        else if (i - first == indexDiff) {\\n            first++\\n            i = first\\n        }\\n    }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2750238,
                "title": "java-ordered-set-using-treeset",
                "content": "# Intuition\\nVariable Length Sliding Window. \\n\\n\\n# Approach\\n1) Need a Data Structure to store the previously seen Elements (Some set is preferred). \\n2) Since we are given a condition to get abs(nums[l]-nums[r]) <= valueDiff 2.1) As we progress we begin to observe that at any point we need the closest min and max value to the current element that is being processed.\\n2.2) With these values we will be able to calculate if any of the valueDiff obtained from min or max values is less than or equal to given valueDiff\\n3) Data Structure which provides closest values of a given number effeciently is --- *TreeSet*\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n        if(n == 1){\\n            return false;\\n        }\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        int l = 0, r = 0, minLimit = Integer.MIN_VALUE, maxLimit = Integer.MAX_VALUE;\\n        while(r<n){\\n            if(r-l <= indexDiff){\\n                int mi = ts.floor(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.floor(nums[r]) - nums[r]), \\n                ma = ts.ceiling(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.ceiling(nums[r]) - nums[r]);\\n                if(mi <= valueDiff){\\n                    return true;\\n                }\\n                else if(ma <= valueDiff){\\n                    return true;\\n                }\\n                else{\\n                    ts.add(nums[r]);\\n                    r++;\\n                }\\n            }\\n            else{\\n                ts.remove(nums[l]);\\n                l++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n        if(n == 1){\\n            return false;\\n        }\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        int l = 0, r = 0, minLimit = Integer.MIN_VALUE, maxLimit = Integer.MAX_VALUE;\\n        while(r<n){\\n            if(r-l <= indexDiff){\\n                int mi = ts.floor(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.floor(nums[r]) - nums[r]), \\n                ma = ts.ceiling(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.ceiling(nums[r]) - nums[r]);\\n                if(mi <= valueDiff){\\n                    return true;\\n                }\\n                else if(ma <= valueDiff){\\n                    return true;\\n                }\\n                else{\\n                    ts.add(nums[r]);\\n                    r++;\\n                }\\n            }\\n            else{\\n                ts.remove(nums[l]);\\n                l++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567804,
                "title": "javascript-solution-two-approaches-bf-sliding-window",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n**1) Brute Force Approach**\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n   for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=t && (Math.abs(i-j)<=k)){\\n                return true;\\n            }\\n        }\\n   }\\n    return false;\\n};\\n```\\n\\n\\n**2) Sliding Window Approach**\\n\\n```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```\\n\\nPlease refer below link for detail explanation:\\nhttps://leet-codes.blogspot.com/2022/09/219-contains-duplicate-ii.html\\nhttps://leet-codes.blogspot.com/2022/09/220-contains-duplicate-iii.html",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n   for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=t && (Math.abs(i-j)<=k)){\\n                return true;\\n            }\\n        }\\n   }\\n    return false;\\n};\\n```\n```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541332,
                "title": "optimal-solution-c-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int> &nums, int k, int t)\\n    {\\n        vector<pair<long, long>> v;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            v.push_back({nums[i], i});\\n        }\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = i + 1; j < nums.size(); j++)\\n            {\\n                if (abs(v[i].first + t >= v[j].first))\\n                {\\n                    if (abs(v[i].second - v[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int> &nums, int k, int t)\\n    {\\n        vector<pair<long, long>> v;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            v.push_back({nums[i], i});\\n        }\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = i + 1; j < nums.size(); j++)\\n            {\\n                if (abs(v[i].first + t >= v[j].first))\\n                {\\n                    if (abs(v[i].second - v[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477569,
                "title": "python-simplest-one-pass-solution-with-buckets-in-8-lines",
                "content": "A sliding window of size `t+1` is used so that we don\\'t have to handle the case when `t=0`. Since Python 3.7, dictionaries are ordered, so we can implement LRU cache functionality using `buckets.pop(next(iter(buckets)))`.\\n\\n```python\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tbuckets = {}\\n\\tfor i, num in enumerate(nums):\\n\\t\\tv = num // (t + 1)\\n\\t\\tfor bucket in range(v - 1, v + 2):\\n\\t\\t\\tif bucket in buckets and abs(buckets[bucket] - num) <= t: return True\\n\\t\\tbuckets[v] = num\\n\\t\\tif(len(buckets) > k): buckets.pop(next(iter(buckets)))\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tbuckets = {}\\n\\tfor i, num in enumerate(nums):\\n\\t\\tv = num // (t + 1)\\n\\t\\tfor bucket in range(v - 1, v + 2):\\n\\t\\t\\tif bucket in buckets and abs(buckets[bucket] - num) <= t: return True\\n\\t\\tbuckets[v] = num\\n\\t\\tif(len(buckets) > k): buckets.pop(next(iter(buckets)))\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2256476,
                "title": "python-simple-bucket-approach",
                "content": "\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        dict1, width = {}, t + 1\\n        \\n        for i in range(len(nums)):\\n            bucket = nums[i]//width\\n            \\n            if bucket in dict1:\\n                return True\\n            \\n            if bucket - 1 in dict1 and abs(dict1[bucket - 1] - nums[i]) <= t:\\n                return True\\n            \\n            if bucket + 1 in dict1 and abs(dict1[bucket + 1] - nums[i]) <= t:\\n                return True\\n            \\n            dict1[bucket] = nums[i]\\n            \\n            if i >= k:\\n                del dict1[nums[i-k]//width]\\n            \\n        return False",
                "solutionTags": [],
                "code": "\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        dict1, width = {}, t + 1\\n        \\n        for i in range(len(nums)):\\n            bucket = nums[i]//width\\n            \\n            if bucket in dict1:\\n                return True\\n            \\n            if bucket - 1 in dict1 and abs(dict1[bucket - 1] - nums[i]) <= t:\\n                return True\\n            \\n            if bucket + 1 in dict1 and abs(dict1[bucket + 1] - nums[i]) <= t:\\n                return True\\n            \\n            dict1[bucket] = nums[i]\\n            \\n            if i >= k:\\n                del dict1[nums[i-k]//width]\\n            \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2238750,
                "title": "python-bucket-with-line-by-line-explanation",
                "content": "\\tclass Solution:\\n\\t\\tdef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tbucket= {}\\n\\t\\t\\t# We use t + 1 here to avoid dividing by 0\\n\\t\\t\\tw = t + 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t# We calculate the label of the value\\n\\t\\t\\t\\tlabel = nums[i] // w\\n\\n\\t\\t\\t\\tif label in bucket:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# We will check if there are value in the neighbor groups and if the distance is valid\\n\\t\\t\\t\\tif label - 1 in bucket and abs(nums[i] - bucket[label-1]) <= t:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif label + 1 in bucket and abs(nums[i] - bucket[label+1]) <= t:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# Replce the bucket with the new value\\n\\t\\t\\t\\tbucket[label] = nums[i]\\n\\t\\t\\t\\t# In the bucket, we will only save the value that is in the window of size k. When i larger than k, we will delete the the values that is not in the window\\n\\t\\t\\t\\t# We we delete this, we will need to add another checking step for the first if statement, if label in bucket, we need to check if the k window size constrain valid.\\n\\t\\t\\t\\tif i >= k:\\n\\t\\t\\t\\t\\tdel bucket[nums[i-k] // w]\\n\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tbucket= {}",
                "codeTag": "Java"
            },
            {
                "id": 2138742,
                "title": "bst-based-sol-in-java-o-n-log-k",
                "content": "- if we think about the brute force sol, in outer loop we are going through the array and in inner loop we are checking the diff between nums[i] and elements from i + 1 to k elements so essentially for each element we are doing k operations so it O(n * k)\\n- we can optimise the k operations runtime if we use a BST because in BST insertion, deletion, searching all operation are log n so here we can maintain a BST of size k that way we can do all operation in log(k) size , so we can use treeset here we can add k elements to tree and while adding the numbers we can check the range num - t or num + t + 1 in the set if any num exists between this range then we found the nearest duplicate \\nor alternatively you use floor and ceiling method of treeset to check if nearest duplicate exists\\ngive a thumbs up if you like the solution.\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            long from = (long) nums[i] - t;\\n            long to = (long) nums[i] + t + 1;\\n            SortedSet<Long> subSet = set.subSet(from, to);\\n\\n            if(subSet.size() > 0)\\n                return true;\\n\\n            set.add((long)nums[i]);\\n            if(set.size() > k)\\n                set.remove((long)nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            long from = (long) nums[i] - t;\\n            long to = (long) nums[i] + t + 1;\\n            SortedSet<Long> subSet = set.subSet(from, to);\\n\\n            if(subSet.size() > 0)\\n                return true;\\n\\n            set.add((long)nums[i]);\\n            if(set.size() > k)\\n                set.remove((long)nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115793,
                "title": "c-fast-25-ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> v;\\n        for(int i=0;i<nums.size();i++) {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            for(int j = i+1; j<nums.size(); j++){\\n                // cout<<\"abs(nums[i]-nums[j]): \"<<abs(nums[i]-nums[j]);\\n                long long int p = abs((v[i]).first-(v[j]).first);\\n                // cout<<\"Int p: \"<<(long long int)p<<endl;\\n                if(p<= t){\\n                    if(abs(v[i].second - v[j].second)<=k){\\n                        // cout<<\"True \"<<endl;\\n                        return true;                        \\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> v;\\n        for(int i=0;i<nums.size();i++) {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            for(int j = i+1; j<nums.size(); j++){\\n                // cout<<\"abs(nums[i]-nums[j]): \"<<abs(nums[i]-nums[j]);\\n                long long int p = abs((v[i]).first-(v[j]).first);\\n                // cout<<\"Int p: \"<<(long long int)p<<endl;\\n                if(p<= t){\\n                    if(abs(v[i].second - v[j].second)<=k){\\n                        // cout<<\"True \"<<endl;\\n                        return true;                        \\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2096834,
                "title": "java-solution",
                "content": "```\\n// Contains Duplicate III\\n// Leetcode: https://leetcode.com/problems/contains-duplicate-iii/\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0 || k <= 0 || t < 0) {\\n            return false;\\n        }\\n        TreeSet<Long> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long num = (long) nums[i];\\n            Long floor = set.floor(num);\\n            if (floor != null && num - floor <= t) {\\n                return true;\\n            }\\n            Long ceiling = set.ceiling(num);\\n            if (ceiling != null && ceiling - num <= t) {\\n                return true;\\n            }\\n            set.add(num);\\n            if (i >= k) {\\n                set.remove((long) nums[i - k]);\\n            }\\n        }\\n        return false;       \\n    }\\n}\\n```\\n\\n## Explanation -\\n1. The first line of code is to create a TreeSet<Long> set.\\n   This is because we are going to use this set to check if there are duplicates in the array.\\n   This set is sorted and can be used to find duplicates in the array.\\n2. Next, we loop through the array, nums.\\n   For each element in the array, we first create a long variable num, which is the current element in the array.\\n   Then, we create a long variable floor, which is the floor of the current element in the array.\\n   Then, we create a long variable ceiling, which is the ceiling of the current element in the array.\\n   Then, we check if the floor is not null, which means that the floor is not null.\\n   Then, we check if the difference between the floor and the current element in the array is less than or equal to t.\\n   If this is true, then we return true.\\n   If the ceiling is not null, which means that the ceiling is not null.\\n   Then, we check if the difference between the ceiling and the current element in the array is less than or equal to t.\\n   If this is true, then we return true.\\n   Then, we add the current element in the array to the set.\\n   Then, we check if the current element in the array is less than or equal to k.\\n   If this is true, we then remove the element in the set that is k away from the current element in the array.\\n   After that, we continue the loop.\\n3. If the loop finishes, which means that there are no duplicates in the array, then we return false.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Contains Duplicate III\\n// Leetcode: https://leetcode.com/problems/contains-duplicate-iii/\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0 || k <= 0 || t < 0) {\\n            return false;\\n        }\\n        TreeSet<Long> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long num = (long) nums[i];\\n            Long floor = set.floor(num);\\n            if (floor != null && num - floor <= t) {\\n                return true;\\n            }\\n            Long ceiling = set.ceiling(num);\\n            if (ceiling != null && ceiling - num <= t) {\\n                return true;\\n            }\\n            set.add(num);\\n            if (i >= k) {\\n                set.remove((long) nums[i - k]);\\n            }\\n        }\\n        return false;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974142,
                "title": "python-sliding-window-with-buckets-approach-3",
                "content": "The trick is to understand that each bucket will have at most one element at a time, and has an incremental range of t. The three if conditions check\\n1) We find an element that has the same hashkey (`num//t`) ==> within the current range. \\n2) We find an element in the previous bucket (subtract one from hashkey => the previous range) and the difference is less than or equal to `t`\\n3) We find an element in the next bucket (add one from hashkey => the next range) and the difference is less than or equal to `t`\\n\\nThe hashmap will never have more than k elements, which is handled with the sliding window technique.\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        buckets = {}\\n        # increment by one in case t is 0 (we need to divide by a non-zero number to find the key aka \"label\" in the article)\\n        w = t + 1\\n        for i, num in enumerate(nums):\\n            key = num//w\\n\\t\\t\\t\\n\\t\\t\\t# We found another element within t counts away that\\'s stored in this bucket range\\n            if key in buckets:\\n                return True\\n            \\n\\t\\t\\t# We found another element that is stored in the prevous bucket\\n            if key - 1 in buckets and abs(num - buckets[key-1]) < w:\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t\\t# We found another element that is stored in hte next bucket\\n            if key + 1 in buckets and abs(num - buckets[key + 1]) < w:\\n                return True\\n            \\n            buckets[key] = num\\n            \\n\\t\\t\\t# remove the left-most element of the sliding window\\n            if i >= k:\\n                bKey = nums[i - k]//w\\n                del buckets[bKey]\\n                \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        buckets = {}\\n        # increment by one in case t is 0 (we need to divide by a non-zero number to find the key aka \"label\" in the article)\\n        w = t + 1\\n        for i, num in enumerate(nums):\\n            key = num//w\\n\\t\\t\\t\\n\\t\\t\\t# We found another element within t counts away that\\'s stored in this bucket range\\n            if key in buckets:\\n                return True\\n            \\n\\t\\t\\t# We found another element that is stored in the prevous bucket\\n            if key - 1 in buckets and abs(num - buckets[key-1]) < w:\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t\\t# We found another element that is stored in hte next bucket\\n            if key + 1 in buckets and abs(num - buckets[key + 1]) < w:\\n                return True\\n            \\n            buckets[key] = num\\n            \\n\\t\\t\\t# remove the left-most element of the sliding window\\n            if i >= k:\\n                bKey = nums[i - k]//w\\n                del buckets[bKey]\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856757,
                "title": "c-binary-search",
                "content": "```\\n#define lln long long int\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n= nums.size();\\n        vector<pair<lln,int>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={nums[i],i};\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++){\\n            // |x-y| < =t      =>  x-y <=t => x<=t+y\\n            lln y=v[i].first;\\n            lln x=t+y;\\n            int idx=upper_bound(v.begin(),v.end(),pair<lln,int>{x,INT_MAX})-v.begin();\\n            for(int j=i+1;j<idx;j++){\\n                if((v[j].first-v[i].first <=t) && (abs(v[j].second-v[i].second) <= k))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n= nums.size();\\n        vector<pair<lln,int>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1755835,
                "title": "c-o-n-solution-using-buckets-with-comments",
                "content": "Approach:\\n1. We walk through the numbers left to right linearly keeping a sliding window of width `k`\\n2. We maintain the numbers that lie within this sliding window inside of \"buckets\". Each bucket has a `bucket-id` which is continguous and has width `t + 1`. This ensures that if two numbers `x` and `y` are such that they get placed in the same bucket i.e. have same `bucket-id`, then `|x - y| <= t`\\n3. So, as we slide our window of width `k` across the array, we\\'d have exactly `k` buckets maintained (Otherwise, by the pigeonhole principle, we\\'d have atleast two numbers that lie in the same bucket and we\\'ve found a solution)\\n4. Additionally, when adding a new element in our window, we also have to check neighbouring buckets to see if they have a number that lies within `t` distance of the newcomer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        // Impossible to have two distinct indices that are k apart\\n        if(size(nums) < 2 || k < 1)\\n            return false;\\n        \\n        // This is because we compute t+1 and given the bounds on t, that can overflow for int\\n        // So, we need a large type\\n        using val_t_ = long;\\n\\n        // id-of-bucket -> element\\n        // As we\\'ll see later we\\'d need to ever keep only a single element with a given bucket-id\\n        // even though the bucket_size is t + 1.\\n        unordered_map<val_t_, val_t_> bucket;\\n        \\n        //  ...   {-1 : -bucket_size, ...    , -2, -1},\\n        //        { 0 : 0, 1, 2, ..., bucket_size - 1},\\n        //        { 1 : bucket_size, bucket_size + 1, ..., 2*bucket_size - 1}, ...\\n        auto bucket_id = [](val_t_ num, val_t_ bucket_size) {\\n            if(num < 0)\\n                return ((num + 1) / bucket_size) - 1;  // ensure uniform bucket_size\\n            return num / bucket_size;\\n        };\\n        \\n        // +1 because t can be zero\\n        // The fact that any two elements in buckets of size t+1\\n        // are at most t apart (inclusive) still holds\\n        // In fact t+1 is the largest bucket size for which this holds.\\n        auto bucket_size = static_cast<val_t_>(t) + 1;\\n        \\n        for(int i = 0; i < size(nums); i++) {\\n            auto const &num = nums[i];\\n            auto id = bucket_id(num, bucket_size);\\n            \\n            // Already have something in this bucket, newcomer \\'num\\' is guaranteed to be at most \"t\" away from this old resident\\n            if(bucket.count(id))\\n                return true;\\n            \\n            // elements in immediate neighbouring buckets can also be within \"t\" of the newcomer\\n            // No other buckets would have any elements at most \"t\" closer.\\n            // This would not have been guaranteed if bucket_size were smaller than t+1\\n            for(auto neighbour : {id - 1, id + 1})\\n                if(auto it = bucket.find(neighbour); it != bucket.end() && abs(it->second - num) <= t)\\n                    return true;\\n            \\n            // Add current element to bucket (and the sliding window)\\n            bucket[id] = num;\\n            \\n            // If we go through k numbers without exiting early above, that means all of those\\n            // have landed in different buckets. So bucket size must be same as our sliding window size.\\n            // Here we remove the leftmost element from the bucket (and from the sliding window)\\n            // to keep the invariant that the indices are at most k apart.\\n            if(bucket.size() > k)\\n                bucket.erase(bucket_id(nums[i - k], bucket_size));\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        // Impossible to have two distinct indices that are k apart\\n        if(size(nums) < 2 || k < 1)\\n            return false;\\n        \\n        // This is because we compute t+1 and given the bounds on t, that can overflow for int\\n        // So, we need a large type\\n        using val_t_ = long;\\n\\n        // id-of-bucket -> element\\n        // As we\\'ll see later we\\'d need to ever keep only a single element with a given bucket-id\\n        // even though the bucket_size is t + 1.\\n        unordered_map<val_t_, val_t_> bucket;\\n        \\n        //  ...   {-1 : -bucket_size, ...    , -2, -1},\\n        //        { 0 : 0, 1, 2, ..., bucket_size - 1},\\n        //        { 1 : bucket_size, bucket_size + 1, ..., 2*bucket_size - 1}, ...\\n        auto bucket_id = [](val_t_ num, val_t_ bucket_size) {\\n            if(num < 0)\\n                return ((num + 1) / bucket_size) - 1;  // ensure uniform bucket_size\\n            return num / bucket_size;\\n        };\\n        \\n        // +1 because t can be zero\\n        // The fact that any two elements in buckets of size t+1\\n        // are at most t apart (inclusive) still holds\\n        // In fact t+1 is the largest bucket size for which this holds.\\n        auto bucket_size = static_cast<val_t_>(t) + 1;\\n        \\n        for(int i = 0; i < size(nums); i++) {\\n            auto const &num = nums[i];\\n            auto id = bucket_id(num, bucket_size);\\n            \\n            // Already have something in this bucket, newcomer \\'num\\' is guaranteed to be at most \"t\" away from this old resident\\n            if(bucket.count(id))\\n                return true;\\n            \\n            // elements in immediate neighbouring buckets can also be within \"t\" of the newcomer\\n            // No other buckets would have any elements at most \"t\" closer.\\n            // This would not have been guaranteed if bucket_size were smaller than t+1\\n            for(auto neighbour : {id - 1, id + 1})\\n                if(auto it = bucket.find(neighbour); it != bucket.end() && abs(it->second - num) <= t)\\n                    return true;\\n            \\n            // Add current element to bucket (and the sliding window)\\n            bucket[id] = num;\\n            \\n            // If we go through k numbers without exiting early above, that means all of those\\n            // have landed in different buckets. So bucket size must be same as our sliding window size.\\n            // Here we remove the leftmost element from the bucket (and from the sliding window)\\n            // to keep the invariant that the indices are at most k apart.\\n            if(bucket.size() > k)\\n                bucket.erase(bucket_id(nums[i - k], bucket_size));\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674554,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        set<int> values;\\n        \\n        //sliding window\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            auto upper = values.upper_bound(nums[i]); //find greater value\\n            if(upper != values.end() && abs((long)nums[i] - *(upper)) <= t)\\n                return true;\\n            \\n            auto lower = values.lower_bound(nums[i]); //find smaller or equal value\\n            if(lower != values.end() && nums[i] == *(lower)) //return true if found equal value\\n                return true;\\n            if(lower != values.begin() && abs((long)nums[i] - *(--lower)) <= t) \\n                return true;\\n            \\n            //Update sliding window\\n            if(i-k >= 0)\\n                values.erase(nums[i-k]); \\n            \\n            if(k >= 1)\\n                values.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        set<int> values;\\n        \\n        //sliding window\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            auto upper = values.upper_bound(nums[i]); //find greater value\\n            if(upper != values.end() && abs((long)nums[i] - *(upper)) <= t)\\n                return true;\\n            \\n            auto lower = values.lower_bound(nums[i]); //find smaller or equal value\\n            if(lower != values.end() && nums[i] == *(lower)) //return true if found equal value\\n                return true;\\n            if(lower != values.begin() && abs((long)nums[i] - *(--lower)) <= t) \\n                return true;\\n            \\n            //Update sliding window\\n            if(i-k >= 0)\\n                values.erase(nums[i-k]); \\n            \\n            if(k >= 1)\\n                values.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647131,
                "title": "javascript-with-buckets",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    if (t < 0) return false\\n    \\n    let getBucketId = function(i, t) {\\n        if (t == 0) return i\\n        return Math.floor( i / t )\\n    }\\n    \\n    let buckets = {}\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        //console.log(buckets)\\n\\n        \\n        let bucketId = getBucketId(nums[i], t)\\n        \\n        // there exists one in the bucket\\n        if (bucketId in buckets) return true \\n        \\n        // check one before and one after\\n        let bucketIdBack = (bucketId - 1) + \"\"\\n        if (bucketIdBack in buckets && Math.abs(nums[i] - buckets[bucketIdBack]) <= t) return true\\n        \\n        let bucketIdForward = (bucketId + 1) + \"\"\\n        if (bucketIdForward in buckets && Math.abs(nums[i] - buckets[bucketIdForward]) <= t) return true\\n        \\n        buckets[bucketId] = nums[i]\\n        \\n        // if i >= k delete trailing \\n        if (i >= k) {\\n            delete buckets[ getBucketId(nums[i - k], t) ]\\n        }\\n        \\n    }\\n    \\n    \\n    return false \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    if (t < 0) return false\\n    \\n    let getBucketId = function(i, t) {\\n        if (t == 0) return i\\n        return Math.floor( i / t )\\n    }\\n    \\n    let buckets = {}\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        //console.log(buckets)\\n\\n        \\n        let bucketId = getBucketId(nums[i], t)\\n        \\n        // there exists one in the bucket\\n        if (bucketId in buckets) return true \\n        \\n        // check one before and one after\\n        let bucketIdBack = (bucketId - 1) + \"\"\\n        if (bucketIdBack in buckets && Math.abs(nums[i] - buckets[bucketIdBack]) <= t) return true\\n        \\n        let bucketIdForward = (bucketId + 1) + \"\"\\n        if (bucketIdForward in buckets && Math.abs(nums[i] - buckets[bucketIdForward]) <= t) return true\\n        \\n        buckets[bucketId] = nums[i]\\n        \\n        // if i >= k delete trailing \\n        if (i >= k) {\\n            delete buckets[ getBucketId(nums[i - k], t) ]\\n        }\\n        \\n    }\\n    \\n    \\n    return false \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466518,
                "title": "java-easy-solution-explained",
                "content": "We will use treeset as a data structure because we need to find out the minimum and maximum in the structure, more precisely INFINIMUM and SUPREMUM of that number, that is, the highest minimum close to this number and the smaller one that is in the data set(infinimum)  and   the smallest maximum higher than that number located in the data set(supremum). Infinimum is located with the floor api(), and will be done the operation nums[i] - treeSet.floor((long)nums[i]) <= t that satisfies the condition. Analogous to supremum, it will be  with ceil api and will be done the operation treeSet.ceiling(((long)nums[i]) - nums[i] <= t to check the condition.  The size of the data structure must be maximum k and if it is exceeded we will remove the oldest element located at the i-k position in the nums array.\\n\\n\\n```\\n static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n\\n        for(int i = 0; i < nums.length; i++) {\\n\\n            if(treeSet.floor((long)nums[i]) != null && nums[i] - treeSet.floor((long)nums[i]) <= t) return true;\\n            if(treeSet.ceiling((long)nums[i]) != null && treeSet.ceiling((long)nums[i]) - nums[i] <= t) return true;\\n\\n            treeSet.add((long)nums[i]);\\n            if(treeSet.size() > k){\\n                treeSet.remove((long)nums[i - k]);\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n\\n        for(int i = 0; i < nums.length; i++) {\\n\\n            if(treeSet.floor((long)nums[i]) != null && nums[i] - treeSet.floor((long)nums[i]) <= t) return true;\\n            if(treeSet.ceiling((long)nums[i]) != null && treeSet.ceiling((long)nums[i]) - nums[i] <= t) return true;\\n\\n            treeSet.add((long)nums[i]);\\n            if(treeSet.size() > k){\\n                treeSet.remove((long)nums[i - k]);\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444564,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let buckets = {};\\n    \\n    for(let idx in nums) {\\n        const num = nums[idx];\\n        const b = Math.floor(num / (t+1));\\n        // console.log(num, b)\\n        if(buckets[b] !== undefined) return true;\\n        if(buckets[b-1] !== undefined && (num - buckets[b-1]) <= t) return true;\\n        if(buckets[b+1] !== undefined && (buckets[b+1] - num) <= t) return true;\\n        \\n        buckets[b] = num;\\n        if(idx >= k) delete buckets[Math.floor(nums[idx-k] / (t+1))];\\n    }\\n    return false;\\n}\\n```\\n\\nReference (explaination there): https://leetcode.com/problems/contains-duplicate-iii/discuss/824578/C%2B%2B-O(N)-time-complexity-or-Explained-or-Buckets-or-O(K)-space-complexity",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let buckets = {};\\n    \\n    for(let idx in nums) {\\n        const num = nums[idx];\\n        const b = Math.floor(num / (t+1));\\n        // console.log(num, b)\\n        if(buckets[b] !== undefined) return true;\\n        if(buckets[b-1] !== undefined && (num - buckets[b-1]) <= t) return true;\\n        if(buckets[b+1] !== undefined && (buckets[b+1] - num) <= t) return true;\\n        \\n        buckets[b] = num;\\n        if(idx >= k) delete buckets[Math.floor(nums[idx-k] / (t+1))];\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1418545,
                "title": "c-set-like-in-the-solution",
                "content": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int D, int t) {\\n\\n\\tconst int N = nums.size();\\n\\n\\t// num - t <= it <= num + t\\n\\n\\tset<int> s;\\n\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\n\\t\\tauto succ=s.lower_bound(nums[i]);\\n\\t\\tif (succ!=s.end() and (long)*succ - nums[i] <= t) \\n\\t\\t\\treturn true;\\n\\n\\t\\tauto pred=succ;\\n\\t\\tif (pred!=s.begin() and (long)nums[i]-*(--pred) <= t) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\ts.insert(nums[i]);\\n\\t\\tif (s.size()>D)\\n\\t\\t\\ts.erase(nums[i-D]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int D, int t) {\\n\\n\\tconst int N = nums.size();\\n\\n\\t// num - t <= it <= num + t\\n\\n\\tset<int> s;\\n\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\n\\t\\tauto succ=s.lower_bound(nums[i]);\\n\\t\\tif (succ!=s.end() and (long)*succ - nums[i] <= t) \\n\\t\\t\\treturn true;\\n\\n\\t\\tauto pred=succ;\\n\\t\\tif (pred!=s.begin() and (long)nums[i]-*(--pred) <= t) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\ts.insert(nums[i]);\\n\\t\\tif (s.size()>D)\\n\\t\\t\\ts.erase(nums[i-D]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575276,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569666,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1565204,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1572994,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1566768,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1575092,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567336,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567529,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1730331,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569030,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1575276,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569666,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1565204,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1572994,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1566768,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1575092,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567336,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567529,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1730331,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569030,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569031,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1568625,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 2006073,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1899500,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1574314,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1571450,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1574319,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 2036993,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 2013451,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1942615,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1926938,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1925736,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1910746,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1867465,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1835271,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1820747,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1817664,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1798218,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1797052,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757537,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    }
]