[
    {
        "title": "Prime In Diagonal",
        "question_content": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\n\tAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\n\tAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].\n&nbsp;\nExample 1:\n\nInput: nums = [[1,2,3],[5,6,7],[9,10,11]]\nOutput: 11\nExplanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.\n\nExample 2:\n\nInput: nums = [[1,2,3],[5,17,7],[9,11,10]]\nOutput: 17\nExplanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 300\n\tnums.length == numsi.length\n\t1 <= nums[i][j]&nbsp;<= 4*106",
        "solutions": [
            {
                "id": 3395752,
                "title": "sieve",
                "content": "We can do a simple primality check. It\\'s good enough since `n <= 300`.\\n\\nFor larger `n`, we can pre-compute Sieve of Eratosthenes.\\n\\n## Simple Primality Check\\n**C++**\\n```cpp\\nbool isPrime(int n){\\n    if (n <= 2 || n % 2 == 0) \\n        return n == 2;\\n    for (int i = 3; i * i <= n; i += 2)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}      \\nint diagonalPrime(vector<vector<int>>& n) {\\n    int p = 0;\\n    for (int i = 0; i < n.size(); ++i)\\n        p = max({p, isPrime(n[i][i]) * n[i][i], \\n            isPrime(n[i][n.size() - i - 1]) * n[i][n.size() - i - 1]});\\n    return p;\\n}\\n```\\n\\n## Sieve of Eratosthenes\\nNote that `sieve` is global, so we compute it only once. \\n\\n**C++**\\n```cpp\\nbool sieve[4000001] =  { true, true }; \\nclass Solution {\\npublic:\\nvoid buildSieve() {\\n    for (int p = 2; p * p < 400001; ++p)\\n        if (!sieve[p])\\n            for (int i = p * p; i < 400001; i += p)\\n                sieve[i] = true;\\n}    \\nint diagonalPrime(vector<vector<int>>& n) {\\n    if (!sieve[4])\\n        buildSieve();\\n    int p = 0;\\n    for (int i = 0; i < n.size(); ++i)\\n        p = max({p, !sieve[n[i][i]] * n[i][i], \\n            !sieve[n[i][n.size() - i - 1]] * n[i][n.size() - i - 1]});\\n    return p;\\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool isPrime(int n){\\n    if (n <= 2 || n % 2 == 0) \\n        return n == 2;\\n    for (int i = 3; i * i <= n; i += 2)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}      \\nint diagonalPrime(vector<vector<int>>& n) {\\n    int p = 0;\\n    for (int i = 0; i < n.size(); ++i)\\n        p = max({p, isPrime(n[i][i]) * n[i][i], \\n            isPrime(n[i][n.size() - i - 1]) * n[i][n.size() - i - 1]});\\n    return p;\\n}\\n```\n```cpp\\nbool sieve[4000001] =  { true, true }; \\nclass Solution {\\npublic:\\nvoid buildSieve() {\\n    for (int p = 2; p * p < 400001; ++p)\\n        if (!sieve[p])\\n            for (int i = p * p; i < 400001; i += p)\\n                sieve[i] = true;\\n}    \\nint diagonalPrime(vector<vector<int>>& n) {\\n    if (!sieve[4])\\n        buildSieve();\\n    int p = 0;\\n    for (int i = 0; i < n.size(); ++i)\\n        p = max({p, !sieve[n[i][i]] * n[i][i], \\n            !sieve[n[i][n.size() - i - 1]] * n[i][n.size() - i - 1]});\\n    return p;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395779,
                "title": "c-brute-force-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n      if(n <= 1) return false;\\n      for (int i = 2; i * i <= n; i++){\\n        if (n % i == 0)return false;\\n      }\\n      return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& v) {\\n      int n = v.size(), ans = INT_MIN;\\n      for(int i = 0; i < n; i++){\\n        if(isPrime(v[i][i])) ans = max(ans, v[i][i]);\\n        if(isPrime(v[i][n - i - 1])) ans = max(ans, v[i][n - i - 1]);\\n      }\\n      return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n      if(n <= 1) return false;\\n      for (int i = 2; i * i <= n; i++){\\n        if (n % i == 0)return false;\\n      }\\n      return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& v) {\\n      int n = v.size(), ans = INT_MIN;\\n      for(int i = 0; i < n; i++){\\n        if(isPrime(v[i][i])) ans = max(ans, v[i][i]);\\n        if(isPrime(v[i][n - i - 1])) ans = max(ans, v[i][n - i - 1]);\\n      }\\n      return ans == INT_MIN ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395778,
                "title": "explained-simple-and-clear-python-code",
                "content": "# Intuition\\nThe problem asks to find the largest prime number present on any of the diagonals of the given 2D integer array. We can iterate over the main and secondary diagonal of the matrix and check if the number is prime or not. If a prime number is found, we compare it with the largest prime found so far and update the largest prime accordingly.\\n\\n\\n# Approach\\nWe use a helper function is_prime() to check if a number is prime or not. We then iterate over the main and secondary diagonal of the matrix using a for loop and check if each element on the diagonal is prime or not. If it is prime, we compare it with the largest prime found so far and update the largest prime accordingly.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the algorithm is O(n^2) as we have to traverse the entire matrix to find the largest prime number on the diagonal.\\n\\n- Space complexity:\\n The space complexity of the algorithm is O(1) as we are using constant space for storing variables.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        largest_prime = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if is_prime(nums[i][i]):\\n                largest_prime = max(largest_prime, nums[i][i])\\n            if is_prime(nums[i][n-i-1]):\\n                largest_prime = max(largest_prime, nums[i][n-i-1])\\n        return largest_prime\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        largest_prime = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if is_prime(nums[i][i]):\\n                largest_prime = max(largest_prime, nums[i][i])\\n            if is_prime(nums[i][n-i-1]):\\n                largest_prime = max(largest_prime, nums[i][n-i-1])\\n        return largest_prime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395757,
                "title": "direct-simple-beginner-friendly-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        bool is_prime=true;\\n          if(n==0||n==1){\\n            is_prime=false;\\n          }\\n          // loop to check if n is prime\\n          for(int i=2;i<=n/2;++i){\\n            if(n%i==0){\\n              is_prime=false;\\n              break;\\n            }\\n          }\\n        return is_prime;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size(),maxi=0;\\n        for(int i=0;i<n;i++){//check isprime if it is strictly greater than maxi\\n            if(nums[i][i]>maxi && isprime(nums[i][i]))\\n                maxi=nums[i][i];\\n            if(nums[i][n-i-1]>maxi && isprime(nums[i][n-i-1]))\\n                maxi=nums[i][n-i-1];\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        bool is_prime=true;\\n          if(n==0||n==1){\\n            is_prime=false;\\n          }\\n          // loop to check if n is prime\\n          for(int i=2;i<=n/2;++i){\\n            if(n%i==0){\\n              is_prime=false;\\n              break;\\n            }\\n          }\\n        return is_prime;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size(),maxi=0;\\n        for(int i=0;i<n;i++){//check isprime if it is strictly greater than maxi\\n            if(nums[i][i]>maxi && isprime(nums[i][i]))\\n                maxi=nums[i][i];\\n            if(nums[i][n-i-1]>maxi && isprime(nums[i][n-i-1]))\\n                maxi=nums[i][n-i-1];\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395721,
                "title": "simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n * sqrt(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int maxi=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(prime(nums[i][i]))\\n            {\\n                maxi=Math.max(maxi,nums[i][i]);\\n            }\\n            if(prime(nums[nums.length-i-1][i]))\\n            {\\n                maxi=Math.max(maxi,nums[nums.length-i-1][i]);\\n            }\\n        }\\n        return maxi;\\n    }\\n    public boolean prime(int n)\\n    {\\n        if(n<2)\\n        {\\n            return false;\\n        }\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int maxi=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(prime(nums[i][i]))\\n            {\\n                maxi=Math.max(maxi,nums[i][i]);\\n            }\\n            if(prime(nums[nums.length-i-1][i]))\\n            {\\n                maxi=Math.max(maxi,nums[nums.length-i-1][i]);\\n            }\\n        }\\n        return maxi;\\n    }\\n    public boolean prime(int n)\\n    {\\n        if(n<2)\\n        {\\n            return false;\\n        }\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609482,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int prime(int n){\\n        if(n==1)\\n        return 0;\\n\\n    for (int p = 2; p * p <= n; p++) {\\n        if(n%p==0)\\n        return 0;\\n    }\\n    return 1;\\n  \\n    \\n}\\n\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int m=0,i,j,k,c=0;\\n        int n= nums.size();\\n\\n        for(i=0;i<nums.size();i++){\\n            if(prime(nums[i][i]))\\n            m=max(nums[i][i],m);\\n            if(prime(nums[i][n-i-1]))\\n            m=max(nums[i][n-i-1],m);\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int prime(int n){\\n        if(n==1)\\n        return 0;\\n\\n    for (int p = 2; p * p <= n; p++) {\\n        if(n%p==0)\\n        return 0;\\n    }\\n    return 1;\\n  \\n    \\n}\\n\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int m=0,i,j,k,c=0;\\n        int n= nums.size();\\n\\n        for(i=0;i<nums.size();i++){\\n            if(prime(nums[i][i]))\\n            m=max(nums[i][i],m);\\n            if(prime(nums[i][n-i-1]))\\n            m=max(nums[i][n-i-1],m);\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399742,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int isPrime(int n) {\\n        if (n <= 1) return 0;\\n        if (n <= 3) return 1;\\n        if (n % 2 == 0 || n % 3 == 0) return 0;\\n        for (int i = 5; i * i <= n; i = i + 6) {\\n          if (n % i == 0 || n % (i + 2) == 0) {\\n            return 0;\\n          }\\n        } \\n        return 1;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            // check if the number on main diagonal is prime\\n            if (isPrime(nums[i][i])) ans = max(ans, nums[i][i]);\\n            // check if the number on anti diagonal is prime\\n            if (isPrime(nums[i][n - i - 1])) ans = max(ans, nums[i][n - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int isPrime(int n) {\\n        if (n <= 1) return 0;\\n        if (n <= 3) return 1;\\n        if (n % 2 == 0 || n % 3 == 0) return 0;\\n        for (int i = 5; i * i <= n; i = i + 6) {\\n          if (n % i == 0 || n % (i + 2) == 0) {\\n            return 0;\\n          }\\n        } \\n        return 1;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            // check if the number on main diagonal is prime\\n            if (isPrime(nums[i][i])) ans = max(ans, nums[i][i]);\\n            // check if the number on anti diagonal is prime\\n            if (isPrime(nums[i][n - i - 1])) ans = max(ans, nums[i][n - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395792,
                "title": "short-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(isprime(nums[i][i])) max = Math.max(max,nums[i][i]);\\n            if(isprime(nums[nums.length-i-1][i]))    max = Math.max(max,nums[nums.length-i-1][i]);\\n        }\\n        return max;\\n    }\\n    boolean isprime(int n){\\n        if(n < 2)  return false;\\n        for(int i = 2; i <= Math.sqrt(n); i++){\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(isprime(nums[i][i])) max = Math.max(max,nums[i][i]);\\n            if(isprime(nums[nums.length-i-1][i]))    max = Math.max(max,nums[nums.length-i-1][i]);\\n        }\\n        return max;\\n    }\\n    boolean isprime(int n){\\n        if(n < 2)  return false;\\n        for(int i = 2; i <= Math.sqrt(n); i++){\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412821,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int isPrime(int n) {\\n        if (n <= 1) return 0;\\n        if (n <= 3) return 1;\\n        if (n % 2 == 0 || n % 3 == 0) return 0;\\n        for (int i = 5; i * i <= n; i = i + 6) {\\n          if (n % i == 0 || n % (i + 2) == 0) {\\n            return 0;\\n          }\\n        } \\n        return 1;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            // check if the number on main diagonal is prime\\n            if (isPrime(nums[i][i])) ans = max(ans, nums[i][i]);\\n            // check if the number on anti diagonal is prime\\n            if (isPrime(nums[i][n - i - 1])) ans = max(ans, nums[i][n - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int isPrime(int n) {\\n        if (n <= 1) return 0;\\n        if (n <= 3) return 1;\\n        if (n % 2 == 0 || n % 3 == 0) return 0;\\n        for (int i = 5; i * i <= n; i = i + 6) {\\n          if (n % i == 0 || n % (i + 2) == 0) {\\n            return 0;\\n          }\\n        } \\n        return 1;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            // check if the number on main diagonal is prime\\n            if (isPrime(nums[i][i])) ans = max(ans, nums[i][i]);\\n            // check if the number on anti diagonal is prime\\n            if (isPrime(nums[i][n - i - 1])) ans = max(ans, nums[i][n - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395755,
                "title": "easy-clean-solution-python3-java-kotlin",
                "content": "Java\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (isPrime(nums[i][i])) {\\n                ans = Math.max(ans, nums[i][i]);\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (isPrime(nums[n - i - 1][i])) {\\n                ans = Math.max(ans, nums[n - i - 1][i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        // Check if the number is less than or equal to 1, return false if it is\\n        if (n <= 1) {\\n            return false;\\n        }\\n        // Loop through all numbers from 2 to\\n        // the square root of n (rounded down to the nearest integer)\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            // If n is divisible by any of these numbers, return false\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        // If n is not divisible by any of these numbers, return true\\n        return true;\\n    }\\n}\\n\\n```\\n\\nPython3\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        ans = 0\\n        \\n        for i in range(len(nums)):\\n                    if (self.isPrime(nums[i][i])):\\n                        ans = max(ans, nums[i][i])\\n        for i in range(len(nums)-1,-1,-1):\\n             if (self.isPrime( nums[len(nums) - i -1][i])):\\n                        ans = max(ans, nums[len(nums) - i -1][i])\\n        return ans\\n    \\n    def isPrime(self,n):\\n        # Check if the number is less than or equal to 1, return False if it is\\n        if n <= 1:\\n            return False\\n        # Loop through all numbers from 2 to\\n        # the square root of n (rounded down to the nearest integer)\\n        for i in range(2, int(n**0.5)+1):\\n            # If n is divisible by any of these numbers, return False\\n            if n % i == 0:\\n                return False\\n        # If n is not divisible by any of these numbers, return True\\n        return True\\n``\\n\\nKotlin\\n``\\nclass Solution {\\n    fun diagonalPrime(nums: Array<IntArray>): Int {\\n        var ans = 0\\n        val n = nums.size\\n        for (i in 0 until n) {\\n            if (isPrime(nums[i][i])) {\\n                ans = maxOf(ans, nums[i][i])\\n            }\\n        }\\n        for (i in n - 1 downTo 0) {\\n            if (isPrime(nums[n - i - 1][i])) {\\n                ans = maxOf(ans, nums[n - i - 1][i])\\n            }\\n        }\\n        return ans\\n    }\\n\\t\\n   private fun isPrime(n: Int): Boolean {\\n        // Check if the number is less than or equal to 1, return false if it is\\n        if (n <= 1) {\\n            return false\\n        }\\n        // Loop through all numbers from 2 to\\n        // the square root of n (rounded down to the nearest integer)\\n        for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\\n            // If n is divisible by any of these numbers, return false\\n            if (n % i == 0) {\\n                return false\\n            }\\n        }\\n        // If n is not divisible by any of these numbers, return true\\n        return true\\n    }\\n}\\n\\n\\n\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (isPrime(nums[i][i])) {\\n                ans = Math.max(ans, nums[i][i]);\\n            }\\n        }\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (isPrime(nums[n - i - 1][i])) {\\n                ans = Math.max(ans, nums[n - i - 1][i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        // Check if the number is less than or equal to 1, return false if it is\\n        if (n <= 1) {\\n            return false;\\n        }\\n        // Loop through all numbers from 2 to\\n        // the square root of n (rounded down to the nearest integer)\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            // If n is divisible by any of these numbers, return false\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        // If n is not divisible by any of these numbers, return true\\n        return true;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        ans = 0\\n        \\n        for i in range(len(nums)):\\n                    if (self.isPrime(nums[i][i])):\\n                        ans = max(ans, nums[i][i])\\n        for i in range(len(nums)-1,-1,-1):\\n             if (self.isPrime( nums[len(nums) - i -1][i])):\\n                        ans = max(ans, nums[len(nums) - i -1][i])\\n        return ans\\n    \\n    def isPrime(self,n):\\n        # Check if the number is less than or equal to 1, return False if it is\\n        if n <= 1:\\n            return False\\n        # Loop through all numbers from 2 to\\n        # the square root of n (rounded down to the nearest integer)\\n        for i in range(2, int(n**0.5)+1):\\n            # If n is divisible by any of these numbers, return False\\n            if n % i == 0:\\n                return False\\n        # If n is not divisible by any of these numbers, return True\\n        return True\\n``\\n\\nKotlin\\n``\\nclass Solution {\\n    fun diagonalPrime(nums: Array<IntArray>): Int {\\n        var ans = 0\\n        val n = nums.size\\n        for (i in 0 until n) {\\n            if (isPrime(nums[i][i])) {\\n                ans = maxOf(ans, nums[i][i])\\n            }\\n        }\\n        for (i in n - 1 downTo 0) {\\n            if (isPrime(nums[n - i - 1][i])) {\\n                ans = maxOf(ans, nums[n - i - 1][i])\\n            }\\n        }\\n        return ans\\n    }\\n\\t\\n   private fun isPrime(n: Int): Boolean {\\n        // Check if the number is less than or equal to 1, return false if it is\\n        if (n <= 1) {\\n            return false\\n        }\\n        // Loop through all numbers from 2 to\\n        // the square root of n (rounded down to the nearest integer)\\n        for (i in 2..Math.sqrt(n.toDouble()).toInt()) {\\n            // If n is divisible by any of these numbers, return false\\n            if (n % i == 0) {\\n                return false\\n            }\\n        }\\n        // If n is not divisible by any of these numbers, return true\\n        return true\\n    }\\n}\\n\\n\\n\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518622,
                "title": "c-check-no-is-prime-or-not",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int x){\\n        if(x==1)return false;\\n        for(int i = 2; i*i<=x; i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i,ans=0,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(check(nums[i][i]) && nums[i][i]>ans){\\n                ans = nums[i][i];\\n            }\\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\\n                ans = nums[i][n-1-i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x){\\n        if(x==1)return false;\\n        for(int i = 2; i*i<=x; i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i,ans=0,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(check(nums[i][i]) && nums[i][i]>ans){\\n                ans = nums[i][i];\\n            }\\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\\n                ans = nums[i][n-1-i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429968,
                "title": "c-and-c-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code: C#\\n```\\npublic class Solution {\\n    public int DiagonalPrime(int[][] nums) {\\n        int max=0;\\n        int n=nums.Length;\\n       for(int i=0;i<n;i++){\\n          if(IsPrime(nums[i][i]))\\n          max=max>nums[i][i]? max:nums[i][i];\\n          if(IsPrime(nums[i][n-1-i]))\\n          max=max>nums[i][n-1-i]? max:nums[i][n-1-i];\\n       } \\n       return max;\\n    }\\n    public bool IsPrime(int x){\\n        if(x==1)\\n        return false;\\n        for(int i=2;i<=Math.Sqrt(x);i++){\\n            if(x%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Code: C++\\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int maxPrime = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(isPrime(nums[i][i]))\\n                maxPrime = max(maxPrime, nums[i][i]);\\n            if(i != n - 1 - i && isPrime(nums[i][n - 1 - i]))\\n                maxPrime = max(maxPrime, nums[i][n - 1 - i]);\\n        }\\n        return maxPrime;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if(x < 2)\\n            return false;\\n        if(x == 2 || x == 3)\\n            return true;\\n        if(x % 2 == 0 || x % 3 == 0)\\n            return false;\\n        int divisor = 5;\\n        while(divisor * divisor <= x) {\\n            if(x % divisor == 0 || x % (divisor + 2) == 0)\\n                return false;\\n            divisor += 6;\\n        }\\n        return true;\\n    }\\n};\\n```\\n# Code: JavaScript\\n```\\nvar diagonalPrime = function(nums) {\\n        let max=0;\\n        let n=nums.length;\\n       for(let i=0;i<n;i++){\\n          if(IsPrime(nums[i][i]))\\n          max=max>nums[i][i]? max:nums[i][i];\\n          if(IsPrime(nums[i][n-1-i]))\\n          max=max>nums[i][n-1-i]? max:nums[i][n-1-i];\\n       } \\n       return max;\\n};\\n    function IsPrime(x){\\n        if(x<=1)\\n        return false;\\n        for(let i=2;i<=Math.sqrt(x);i++){\\n            if(x%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n```\\n![Vote.png](https://assets.leetcode.com/users/images/e2bf5e0b-e86a-4876-9bec-4ee105101c38_1681802367.9742486.png)\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int DiagonalPrime(int[][] nums) {\\n        int max=0;\\n        int n=nums.Length;\\n       for(int i=0;i<n;i++){\\n          if(IsPrime(nums[i][i]))\\n          max=max>nums[i][i]? max:nums[i][i];\\n          if(IsPrime(nums[i][n-1-i]))\\n          max=max>nums[i][n-1-i]? max:nums[i][n-1-i];\\n       } \\n       return max;\\n    }\\n    public bool IsPrime(int x){\\n        if(x==1)\\n        return false;\\n        for(int i=2;i<=Math.Sqrt(x);i++){\\n            if(x%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int maxPrime = 0;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) {\\n            if(isPrime(nums[i][i]))\\n                maxPrime = max(maxPrime, nums[i][i]);\\n            if(i != n - 1 - i && isPrime(nums[i][n - 1 - i]))\\n                maxPrime = max(maxPrime, nums[i][n - 1 - i]);\\n        }\\n        return maxPrime;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if(x < 2)\\n            return false;\\n        if(x == 2 || x == 3)\\n            return true;\\n        if(x % 2 == 0 || x % 3 == 0)\\n            return false;\\n        int divisor = 5;\\n        while(divisor * divisor <= x) {\\n            if(x % divisor == 0 || x % (divisor + 2) == 0)\\n                return false;\\n            divisor += 6;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nvar diagonalPrime = function(nums) {\\n        let max=0;\\n        let n=nums.length;\\n       for(let i=0;i<n;i++){\\n          if(IsPrime(nums[i][i]))\\n          max=max>nums[i][i]? max:nums[i][i];\\n          if(IsPrime(nums[i][n-1-i]))\\n          max=max>nums[i][n-1-i]? max:nums[i][n-1-i];\\n       } \\n       return max;\\n};\\n    function IsPrime(x){\\n        if(x<=1)\\n        return false;\\n        for(let i=2;i<=Math.sqrt(x);i++){\\n            if(x%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398270,
                "title": "python-3-7-lines-w-explanation-t-m-716-ms-26-mb",
                "content": "In this code, we use this fact to prune the number of tests:\\n- A prime must be greater than 1, and either be i) in (2,3) or ii) equal to 6n-1 or 6n+1 for some positive integer n.\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n\\n        prune = lambda x: (x in (2,3) or x%6 in (1,5)) and x > 1  # prunes a list of possible primes\\n        isPrime = lambda x: all(x % posPrime for posPrime         # boolean function returns whether a prime\\n                             in filter(prune,range(isqrt(x)+1)))  \\n        \\n        n = len(nums)\\n\\n        cands = sorted(filter(prune,                              # collect the diagonal elements of the array,\\n                         {nums[i][i   ] for i in range(n)}|       # then prune and sort the list, and sort the  \\n                         {nums[i][-i-1] for i in range(n)})       # pruned list, reverse = True.\\n                      ,reverse = True)                          \\n\\n        for c in cands:                                           # determine the first element in the sorted list\\n            if isPrime(c): return c                               # that is prime\\n        return 0 \\n```\\n[https://leetcode.com/problems/prime-in-diagonal/submissions/930857223/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n\\n        prune = lambda x: (x in (2,3) or x%6 in (1,5)) and x > 1  # prunes a list of possible primes\\n        isPrime = lambda x: all(x % posPrime for posPrime         # boolean function returns whether a prime\\n                             in filter(prune,range(isqrt(x)+1)))  \\n        \\n        n = len(nums)\\n\\n        cands = sorted(filter(prune,                              # collect the diagonal elements of the array,\\n                         {nums[i][i   ] for i in range(n)}|       # then prune and sort the list, and sort the  \\n                         {nums[i][-i-1] for i in range(n)})       # pruned list, reverse = True.\\n                      ,reverse = True)                          \\n\\n        for c in cands:                                           # determine the first element in the sorted list\\n            if isPrime(c): return c                               # that is prime\\n        return 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681262,
                "title": "easy-python-solution-with-99-1",
                "content": "# Intuition\\nIterate through the given matrix, extract the diagonal elements (both main diagonal and anti-diagonal), and check if each element is prime. Finally, return the largest prime number found.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Define a helper function, isprime(n), to check if a number n is prime.Initialize an empty array arr to store the diagonal elements.\\n- Iterate through the elements in the first row of the given matrix.\\nAppend the element at the current index in both the main diagonal (nums[i][i]) and the anti-diagonal (nums[i][l-i-1]) to arr.\\n- Initialize result to 0, which will store the largest prime number found.\\n- Iterate through the elements in arr.If the current element is greater than result and it is prime (checked using the isprime function), update result to the current element.\\n- Return result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) - As we store the diagonal elements in the array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isprime(self,n):\\n        if n<=1:\\n            return False\\n        for i in range(2,math.floor(math.sqrt(n))+1):\\n            if n%i==0:\\n                return False\\n        return True\\n\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        l = len(nums[0])\\n        arr=[]\\n        for i in range(l):\\n            arr.append(nums[i][i])\\n            arr.append(nums[i][l-i-1])\\n        result=0\\n        for num in arr:\\n            if num>result:\\n                if self.isprime(num):\\n                    result=num\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isprime(self,n):\\n        if n<=1:\\n            return False\\n        for i in range(2,math.floor(math.sqrt(n))+1):\\n            if n%i==0:\\n                return False\\n        return True\\n\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        l = len(nums[0])\\n        arr=[]\\n        for i in range(l):\\n            arr.append(nums[i][i])\\n            arr.append(nums[i][l-i-1])\\n        result=0\\n        for num in arr:\\n            if num>result:\\n                if self.isprime(num):\\n                    result=num\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397620,
                "title": "c-easy-and-clean-code-well-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Fetch the diagonal elements in a vector\\n2. sort the vector in descending order\\n3. call the isPrime funtion \\n4. if isPrime is true return the number\\n5. else return 0 as no prime number is found\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //isPrime TC => sqrt(n);\\n    bool isPrime(int n){\\n        if (n <= 1)\\n            return false;\\n    \\n        for (int i = 2; i <= sqrt(n); i++)\\n            if (n % i == 0)\\n                return false;\\n    \\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        vector<int> v;\\n        int n = nums.size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                if(i==j or j==n-1-i)\\n                v.push_back(nums[i][j]);\\n            }\\n        }\\n        for(auto& it: nums) reverse(nums.begin(),nums.end());\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                if(i==j)\\n                v.push_back(nums[i][j]);\\n            }\\n        }\\n        sort(v.rbegin(),v.rend());\\n        for(auto it: v){\\n            if(it!=1 or it)\\n            if(isPrime(it))return it;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    //isPrime TC => sqrt(n);\\n    bool isPrime(int n){\\n        if (n <= 1)\\n            return false;\\n    \\n        for (int i = 2; i <= sqrt(n); i++)\\n            if (n % i == 0)\\n                return false;\\n    \\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        vector<int> v;\\n        int n = nums.size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                if(i==j or j==n-1-i)\\n                v.push_back(nums[i][j]);\\n            }\\n        }\\n        for(auto& it: nums) reverse(nums.begin(),nums.end());\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                if(i==j)\\n                v.push_back(nums[i][j]);\\n            }\\n        }\\n        sort(v.rbegin(),v.rend());\\n        for(auto it: v){\\n            if(it!=1 or it)\\n            if(isPrime(it))return it;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396125,
                "title": "c-easy-soluion",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(n * \\u221An)$$\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool prime(int n) {\\n        if(n < 2) return false;\\n        for(int i=2;i*i<=n;i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int max_prime = 0;\\n        for(int i=0;i<n;i++) {\\n            if(prime(nums[i][i])) {\\n                max_prime = max(max_prime, nums[i][i]);\\n            }\\n            if(prime(nums[i][n - i - 1])) {\\n                max_prime = max(max_prime, nums[i][n - i - 1]);\\n            }\\n        }\\n        return max_prime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool prime(int n) {\\n        if(n < 2) return false;\\n        for(int i=2;i*i<=n;i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int max_prime = 0;\\n        for(int i=0;i<n;i++) {\\n            if(prime(nums[i][i])) {\\n                max_prime = max(max_prime, nums[i][i]);\\n            }\\n            if(prime(nums[i][n - i - 1])) {\\n                max_prime = max(max_prime, nums[i][n - i - 1]);\\n            }\\n        }\\n        return max_prime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395785,
                "title": "java-clean-and-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public static boolean isPrime(int num) {\\n     if (num <= 1) return false;\\n     \\n     for (var i=2; i <= Math.sqrt(num); i++)\\n       if (num % i == 0) return false;\\n       \\n     return true;\\n  }\\n  \\n  public int diagonalPrime(int[][] nums) {\\n    var n = nums.length;\\n    var ans = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (isPrime(nums[i][i]))\\n        ans = Math.max(ans, nums[i][i]);\\n      \\n      if (isPrime(nums[i][n-1-i]))\\n        ans = Math.max(ans, nums[i][n-1-i]);\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public static boolean isPrime(int num) {\\n     if (num <= 1) return false;\\n     \\n     for (var i=2; i <= Math.sqrt(num); i++)\\n       if (num % i == 0) return false;\\n       \\n     return true;\\n  }\\n  \\n  public int diagonalPrime(int[][] nums) {\\n    var n = nums.length;\\n    var ans = 0;\\n    \\n    for (var i=0; i<n; i++) {\\n      if (isPrime(nums[i][i]))\\n        ans = Math.max(ans, nums[i][i]);\\n      \\n      if (isPrime(nums[i][n-1-i]))\\n        ans = Math.max(ans, nums[i][n-1-i]);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395701,
                "title": "c-prime-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        // Corner cases\\n        if (n <= 1)\\n            return false;\\n      //suppose n=7 that is prime and its pair are (1,7)\\n      //so if a no. is prime then it can be check by numbers smaller than square root\\n      // of the n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int curr_largest_prime = 0;\\n        \\n        \\n        for(int i = 0; i < n; i++) {\\n            if(isPrime(nums[i][i])) {\\n                curr_largest_prime = max(curr_largest_prime, nums[i][i]);\\n            }\\n            if(isPrime(nums[i][n-i-1])) {\\n                curr_largest_prime = max(curr_largest_prime, nums[i][n-i-1]);\\n            }\\n        }\\n        \\n        return curr_largest_prime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        // Corner cases\\n        if (n <= 1)\\n            return false;\\n      //suppose n=7 that is prime and its pair are (1,7)\\n      //so if a no. is prime then it can be check by numbers smaller than square root\\n      // of the n\\n        for (int i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int curr_largest_prime = 0;\\n        \\n        \\n        for(int i = 0; i < n; i++) {\\n            if(isPrime(nums[i][i])) {\\n                curr_largest_prime = max(curr_largest_prime, nums[i][i]);\\n            }\\n            if(isPrime(nums[i][n-i-1])) {\\n                curr_largest_prime = max(curr_largest_prime, nums[i][n-i-1]);\\n            }\\n        }\\n        \\n        return curr_largest_prime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844263,
                "title": "python-3-brute-force-beats-99-625ms",
                "content": "```python3 []\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def isPrime(n):\\n            for i in range(2, int(sqrt(n)) + 1):\\n                if n % i == 0: return False\\n            return n > 1\\n        \\n        res, L = 0, len(nums)\\n        for i in range(L):\\n            n1, n2 = nums[i][i], nums[i][~i]\\n            if n1 > res and isPrime(n1): res = n1\\n            if n2 > res and isPrime(n2): res = n2\\n\\n        return res \\n```\\n![Screenshot 2023-07-31 at 21.00.57.png](https://assets.leetcode.com/users/images/351fbb88-e34e-4097-bff2-1393991dbd39_1690826590.9250824.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Matrix"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def isPrime(n):\\n            for i in range(2, int(sqrt(n)) + 1):\\n                if n % i == 0: return False\\n            return n > 1\\n        \\n        res, L = 0, len(nums)\\n        for i in range(L):\\n            n1, n2 = nums[i][i], nums[i][~i]\\n            if n1 > res and isPrime(n1): res = n1\\n            if n2 > res and isPrime(n2): res = n2\\n\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834710,
                "title": "simplest-solution-without-using-any-other-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        size=len(nums)\\n        max=0\\n        for i in range(size):\\n            if self.isPrime(nums[i][i]) and max<nums[i][i]:\\n                max=nums[i][i]\\n            if self.isPrime(nums[i][size- i - 1]) and max<nums[i][size- i - 1]:\\n                max=nums[i][size- i - 1]\\n        return max\\n\\n    def isPrime(self,n:int) -> bool:\\n        if n<2:\\n            return False\\n        i=2\\n        while i*i<=n:\\n            if n%i==0:\\n                return False\\n            i=i+1\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        size=len(nums)\\n        max=0\\n        for i in range(size):\\n            if self.isPrime(nums[i][i]) and max<nums[i][i]:\\n                max=nums[i][i]\\n            if self.isPrime(nums[i][size- i - 1]) and max<nums[i][size- i - 1]:\\n                max=nums[i][size- i - 1]\\n        return max\\n\\n    def isPrime(self,n:int) -> bool:\\n        if n<2:\\n            return False\\n        i=2\\n        while i*i<=n:\\n            if n%i==0:\\n                return False\\n            i=i+1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510281,
                "title": "naive-approach-beginner-friendly-6ms-runtime-optimized-easy-to-understand-for-beginners",
                "content": "**Must read if there is any doubt feel free to ask in comments**\\n\\nSomehow beginners face difficulty to understand the concept at first, but i will try my best to breakdown the question into simpler parts so that there would be ease to understand for beginners.\\n\\n\\n\\n**first we have to check prime number on the diagnol of the matrix.**\\n\\n**Step 1** -> so we make a function to check wether the given number is prime or not\\n\\n**Note** -> there are several functions to checkPrime as a naive/beginner you apply what you have learnt in fundamentals programming but it would not work\\n\\nBut here we have to create a checkPrime no. function that would be  optimized otherwise you will get **TLE** which is **Time Limit Exceeded** error.\\n\\n\\nTo find a prime number what we do firstly? -> find factors\\n\\ne.g\\n Num - > 12\\nfactors -> \\n\\n    **i** -------- **k**\\n    1 * 12 = 12\\n    2 * 6 = 12\\n    3 * 4 = 12\\n    4 * 3 = 12\\n    6 * 2 = 12\\n    12 * 1 = 12\\n\\nwe have total 6 factors \\n\\n**Trivial method: TLE occurs for this coz it isn\\'t optimized.**\\n\\nint count = 0;\\nif (k < 2) {\\n    return false;\\n}\\nfor (int i = 1; i < k; i++) {\\n    if (k % i == 0) {\\n        count++;        \\n    }\\n}\\nif (count == 2) {\\n    return true;\\n} else {\\n    return false;\\n}\\n\\nNow what if I say we do not need to iterate till k if we focus on the pattern we see that after i = 3 same numbers are repeating such as (4,3) despite (3,4) was there already , similarly (6,2) despite (2,6) is there etc...\\n\\nnow what we do is we would iterate our loop from **i to \\u221Ak** or we can write it as **i * i to k** also **so that our i iterate in the range between [1 - 3] so we have to take the square root of k. \\ni.e \\n1 * 12, 2 * 6, 3 * 4 and we get all the 6 factors till i = 3.**\\n\\n\\ne.g\\n Num - > 12\\nfactors -> 1, 2, 3, 4, 6, 12\\n**i ------- k**\\n1 * 12 = 12\\n2 * 6 = 12\\n3 * 4 = 12\\n\\n 4 * 3 = 12\\n 6 * 2 = 12\\n12 * 1 = 12\\n\\nfor (int i = 1; i * i <= k; i++) {\\n    if (k < 2) {\\n    return false;\\n    }\\n    if (k % i == 0) {\\n        count +=2; \\n//count + 2 because 1 * 12 we grab two factors from herethen why we need to go till 12.\\n\\n}\\nif (count == 2) {\\nreturn true\\n} else {\\nreturn false;\\n}\\n}\\n\\n**Now we have converted our problem in \\u221An time complexity.**\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        int maxim = 0;\\n        for (int i = 0; i < n; i++) {\\n                if (checkPrime(nums[i][i])) {\\n                    maxim = Math.max(maxim, nums[i][i]);\\n                } \\n                if (checkPrime(nums[n-1-i][i])) {\\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\\n\\n                }\\n            \\n        }\\n        return maxim;\\n    }\\n    public boolean checkPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        int maxim = 0;\\n        for (int i = 0; i < n; i++) {\\n                if (checkPrime(nums[i][i])) {\\n                    maxim = Math.max(maxim, nums[i][i]);\\n                } \\n                if (checkPrime(nums[n-1-i][i])) {\\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\\n\\n                }\\n            \\n        }\\n        return maxim;\\n    }\\n    public boolean checkPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405310,
                "title": "brute-force-short-sweet-easy-to-understand-c-code",
                "content": "````\\nclass Solution {\\npublic:\\n    bool check(int a){\\n        if(a<=1)return false;\\n        for(int i = 2; i <= sqrt(a); i++){\\n            if(a%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(check(nums[i][i])){//CHECK NUMS[I][I] IS PRIME OR NOT\\n                ans = max(ans,nums[i][i]);\\n            }\\n            if(check(nums[i][n-1-i])){//CHECK NUMS[I][N-1-I] IS PRIME OR NOT\\n                ans = max(ans,nums[i][n-1-i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    bool check(int a){\\n        if(a<=1)return false;\\n        for(int i = 2; i <= sqrt(a); i++){\\n            if(a%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0,i,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(check(nums[i][i])){//CHECK NUMS[I][I] IS PRIME OR NOT\\n                ans = max(ans,nums[i][i]);\\n            }\\n            if(check(nums[i][n-1-i])){//CHECK NUMS[I][N-1-I] IS PRIME OR NOT\\n                ans = max(ans,nums[i][n-1-i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397739,
                "title": "simple-c-solution-in-o-n-n-time-complexity",
                "content": "class Solution {\\n    bool CheckPrime(int n)\\n{\\n    if (n == 2)\\n        return true;\\n    if (n < 2)\\n        return false;\\n    if (n % 2 == 0)\\n        return false;\\n    for (int i = 3; i <= n / i; i += 2)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size(), ans = 0;\\n        for(int i=0; i<n; i++){\\n                if(CheckPrime(nums[i][i])){\\n                    ans = max(ans,nums[i][i]);\\n                }\\n                if(CheckPrime(nums[i][n-i-1])){\\n                    ans = max(ans,nums[i][n-i-1]);\\n                }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    bool CheckPrime(int n)\\n{\\n    if (n == 2)\\n        return true;\\n    if (n < 2)\\n        return false;\\n    if (n % 2 == 0)\\n        return false;\\n    for (int i = 3; i <= n / i; i += 2)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3397529,
                "title": "java-single-loop-self-explanatory-solution-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    \\n    public static boolean isPrime(int num){\\n        if(num <= 1){\\n            return false;\\n        }\\n        for(int i = 2; i <= Math.sqrt(num); i++){\\n            if(num % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int j = 0;\\n        int i = 0;\\n        int k = nums.length -1;\\n        while(j < nums.length){\\n            // System.out.println(nums[j][k]);\\n            if(isPrime(nums[j][k])){\\n                max = Math.max(max, nums[j][k]);\\n            }\\n            if(isPrime(nums[i][i])){\\n                max = Math.max(max, nums[i][i]);\\n            }\\n            i++;\\n            k--;\\n            j++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static boolean isPrime(int num){\\n        if(num <= 1){\\n            return false;\\n        }\\n        for(int i = 2; i <= Math.sqrt(num); i++){\\n            if(num % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int j = 0;\\n        int i = 0;\\n        int k = nums.length -1;\\n        while(j < nums.length){\\n            // System.out.println(nums[j][k]);\\n            if(isPrime(nums[j][k])){\\n                max = Math.max(max, nums[j][k]);\\n            }\\n            if(isPrime(nums[i][i])){\\n                max = Math.max(max, nums[i][i]);\\n            }\\n            i++;\\n            k--;\\n            j++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395936,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        largest_prime = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if is_prime(nums[i][i]):\\n                largest_prime = max(largest_prime, nums[i][i])\\n\\n            if is_prime(nums[i][n-i-1]):\\n                largest_prime = max(largest_prime, nums[i][n-i-1])\\n                \\n        return largest_prime\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        largest_prime = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if is_prime(nums[i][i]):\\n                largest_prime = max(largest_prime, nums[i][i])\\n\\n            if is_prime(nums[i][n-i-1]):\\n                largest_prime = max(largest_prime, nums[i][n-i-1])\\n                \\n        return largest_prime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395896,
                "title": "sieve-not-required",
                "content": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        auto isPrime=[](int &n){\\n            if (n <= 1)\\n                return false;\\n            for (int i = 2; i * i <= n; i++) {\\n                if (n % i == 0)\\n                    return false;\\n            }\\n            return true;\\n        };\\n        int n = nums.size();\\n        vector<int> v;\\n        for(int i=0;i<n;++i){\\n        v.push_back(nums[i][i]);\\n        v.push_back(nums[i][n-i-1]);\\n        }\\n        \\n        sort(begin(v),end(v));\\n        for(int i=v.size()-1;i>=0;--i)\\n        {\\n            if(isPrime(v[i]))\\n                return v[i];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        auto isPrime=[](int &n){\\n            if (n <= 1)\\n                return false;\\n            for (int i = 2; i * i <= n; i++) {\\n                if (n % i == 0)\\n                    return false;\\n            }\\n            return true;\\n        };\\n        int n = nums.size();\\n        vector<int> v;\\n        for(int i=0;i<n;++i){\\n        v.push_back(nums[i][i]);\\n        v.push_back(nums[i][n-i-1]);\\n        }\\n        \\n        sort(begin(v),end(v));\\n        for(int i=v.size()-1;i>=0;--i)\\n        {\\n            if(isPrime(v[i]))\\n                return v[i];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923133,
                "title": "c-javascript-easy-solution",
                "content": "# Approach\\nlook at each element of a square matrix and checks if it\\'s on the main diagonal or the opposite diagonal. If the element is a prime number, it keeps track of the largest prime number found. After checking all relevant elements, it returns the largest prime number found on the diagonals of the matrix.\\n\\n# Complexity\\n- Time complexity: O(n^2 * sqrt(max(nums[i][j])))\\n\\n- Space complexity: Depends on the number of prime numbers stored, but it\\'s not directly related to the input size.\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    bool isprime(int n){\\n        if(n==1) return 0;\\n        for(int i=2;i*i<=n; i++){\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size(),mx=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j && isprime(nums[i][j])) mx=max(mx,nums[i][j]);\\n                if(j==n-i-1 &&  isprime(nums[i][j])) mx=max(mx,nums[i][j]);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n\\n---\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\n\\nvar isprime=(n)=>{\\n    if(n===1) return 0;\\n    for(var i=2;i*i<=n; i++){\\n        if(n%i===0) return 0;\\n    }\\n    return 1;\\n}\\n    \\n   \\nvar diagonalPrime = function(nums) {\\n    var n=nums.length,mx=0;\\n    for(var i=0;i<n;i++){\\n        for(var j=0;j<n;j++){\\n            if(i==j && isprime(nums[i][j])) mx=Math.max(mx,nums[i][j]);\\n            if(j==n-i-1 &&  isprime(nums[i][j])) mx=Math.max(mx,nums[i][j]);\\n        }\\n    }\\n    return mx;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Array",
                    "Math",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    bool isprime(int n){\\n        if(n==1) return 0;\\n        for(int i=2;i*i<=n; i++){\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size(),mx=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j && isprime(nums[i][j])) mx=max(mx,nums[i][j]);\\n                if(j==n-i-1 &&  isprime(nums[i][j])) mx=max(mx,nums[i][j]);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\n\\nvar isprime=(n)=>{\\n    if(n===1) return 0;\\n    for(var i=2;i*i<=n; i++){\\n        if(n%i===0) return 0;\\n    }\\n    return 1;\\n}\\n    \\n   \\nvar diagonalPrime = function(nums) {\\n    var n=nums.length,mx=0;\\n    for(var i=0;i<n;i++){\\n        for(var j=0;j<n;j++){\\n            if(i==j && isprime(nums[i][j])) mx=Math.max(mx,nums[i][j]);\\n            if(j==n-i-1 &&  isprime(nums[i][j])) mx=Math.max(mx,nums[i][j]);\\n        }\\n    }\\n    return mx;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645648,
                "title": "easy-detail-explaination-java",
                "content": "# Approach\\n1. We create a arraylist for storing digonals.\\n2. We create for loop for storing diagonals in list.\\n3. Then we sort the array list of diagonals in reverse order, with help of this we got a greater diagonal at first location.\\n4. Then we create another loop and check for every digonal if it is prime or not.\\n5. If a digonal is prime then we will return that diagonal as ans.\\n6. We check for every diagonal, if there is no any prime diagonal we return 0.\\n7. Prime function to check number is prime or not.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            list.add(nums[i][i]);\\n            list.add(nums[i][nums.length-i-1]);\\n        }\\n        Collections.sort(list,Collections.reverseOrder());\\n\\n\\n        for(int i=0;i<list.size();i++)\\n        {\\n            if(isprime(list.get(i)))return list.get(i);\\n        }\\n        return 0;\\n    }\\n\\n    public static boolean isprime(int num)\\n    {\\n        if(num<2)return false;\\n        for(int i=2;i*i<=num;i++)\\n        {\\n            if(num%i==0)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            list.add(nums[i][i]);\\n            list.add(nums[i][nums.length-i-1]);\\n        }\\n        Collections.sort(list,Collections.reverseOrder());\\n\\n\\n        for(int i=0;i<list.size();i++)\\n        {\\n            if(isprime(list.get(i)))return list.get(i);\\n        }\\n        return 0;\\n    }\\n\\n    public static boolean isprime(int num)\\n    {\\n        if(num<2)return false;\\n        for(int i=2;i*i<=num;i++)\\n        {\\n            if(num%i==0)return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498917,
                "title": "o-n-2-prime-in-diagonal-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i, j, max=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if((nums[i][i]==2 || nums[i][nums.size()-i-1]==2) && max<2)\\n            {\\n                max = 2;\\n            }\\n            else\\n            {\\n                for(j=2 ; j<=sqrt(nums[i][i]) ; j++)\\n                {\\n                    if(nums[i][i]%j==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(j>sqrt(nums[i][i]) && max<nums[i][i] && nums[i][i]>2)\\n                {\\n                    max = nums[i][i];\\n                }\\n\\n                for(j=2 ; j<=sqrt(nums[i][nums.size()-i-1]) ; j++)\\n                {\\n                    if(nums[i][nums.size()-i-1]%j==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(j>sqrt(nums[i][nums.size()-i-1]) && max<nums[i][nums.size()-i-1] && nums[i][nums.size()-i-1]>2)\\n                {\\n                    max = nums[i][nums.size()-i-1];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/46692ca3-d79a-40c5-94d7-0428fe36bf2b_1683520624.320548.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i, j, max=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if((nums[i][i]==2 || nums[i][nums.size()-i-1]==2) && max<2)\\n            {\\n                max = 2;\\n            }\\n            else\\n            {\\n                for(j=2 ; j<=sqrt(nums[i][i]) ; j++)\\n                {\\n                    if(nums[i][i]%j==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(j>sqrt(nums[i][i]) && max<nums[i][i] && nums[i][i]>2)\\n                {\\n                    max = nums[i][i];\\n                }\\n\\n                for(j=2 ; j<=sqrt(nums[i][nums.size()-i-1]) ; j++)\\n                {\\n                    if(nums[i][nums.size()-i-1]%j==0)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(j>sqrt(nums[i][nums.size()-i-1]) && max<nums[i][nums.size()-i-1] && nums[i][nums.size()-i-1]>2)\\n                {\\n                    max = nums[i][nums.size()-i-1];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463626,
                "title": "beginners-solution-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n        step1: store the all diagonal element to arraylist\\n        step2: sort the arraylist in reverse order as the maxm \\n                no. will present in start \\n        step3: check the list from starting and return the no.      \\n                which is prime as it will be the maxm of all\\n\\n# Complexity\\n- Time complexity:O(N^2logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n\\n    public int diagonalPrime(int[][] nums) {\\n\\n        // get the diagonal element and store in list\\n\\n        ArrayList<Integer> ls= new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            ls.add(nums[i][i]);\\n            ls.add(nums[i][nums.length-i-1]);\\n        } \\n\\n        Collections.sort(ls, Collections.reverseOrder());\\n\\n        \\n      \\n\\n        for(int i=0;i<ls.size();i++){\\n            if(prime(ls.get(i))==true) return ls.get(i);\\n        }\\n\\n\\n        return 0;\\n    }\\n\\n      public boolean prime( int n){\\n          if(n==1) return false;\\n            if (n==2) return true;\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0) return false;\\n            }\\n            return true;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n\\n    public int diagonalPrime(int[][] nums) {\\n\\n        // get the diagonal element and store in list\\n\\n        ArrayList<Integer> ls= new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            ls.add(nums[i][i]);\\n            ls.add(nums[i][nums.length-i-1]);\\n        } \\n\\n        Collections.sort(ls, Collections.reverseOrder());\\n\\n        \\n      \\n\\n        for(int i=0;i<ls.size();i++){\\n            if(prime(ls.get(i))==true) return ls.get(i);\\n        }\\n\\n\\n        return 0;\\n    }\\n\\n      public boolean prime( int n){\\n          if(n==1) return false;\\n            if (n==2) return true;\\n            for(int i=2;i*i<=n;i++){\\n                if(n%i==0) return false;\\n            }\\n            return true;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456680,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n  //Seprate function for checkiing prime number\\n    function isPrime(num) {\\n      if (num < 2) {\\n      return false;\\n    }\\n      for (let i = 2; i <= (num**0.5); i++) {\\n        if (num % i === 0) {\\n          return false;\\n        }\\n    }\\n      return true;\\n    }\\n\\n  let n = nums.length;\\n  let largestPrime = 0;\\n\\n  // Check the main diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][i]) && nums[i][i] > largestPrime) {\\n      largestPrime = nums[i][i];\\n    }\\n  }\\n\\n  // Check the secondary diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][n - 1 - i]) && nums[i][n - 1 - i] > largestPrime) {\\n      largestPrime = nums[i][n - 1 - i];\\n    }\\n  }\\n\\n  return largestPrime;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n  //Seprate function for checkiing prime number\\n    function isPrime(num) {\\n      if (num < 2) {\\n      return false;\\n    }\\n      for (let i = 2; i <= (num**0.5); i++) {\\n        if (num % i === 0) {\\n          return false;\\n        }\\n    }\\n      return true;\\n    }\\n\\n  let n = nums.length;\\n  let largestPrime = 0;\\n\\n  // Check the main diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][i]) && nums[i][i] > largestPrime) {\\n      largestPrime = nums[i][i];\\n    }\\n  }\\n\\n  // Check the secondary diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][n - 1 - i]) && nums[i][n - 1 - i] > largestPrime) {\\n      largestPrime = nums[i][n - 1 - i];\\n    }\\n  }\\n\\n  return largestPrime;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433690,
                "title": "c-user-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n check if the number on main diagonal is prime using simple logic\\n check if the number on anti diagonal is prime using simple logic\\nand return max\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool check(int n){\\n       if(n<=1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            // check if the number on main diagonal is prime\\n            if (check(nums[i][i])) ans = max(ans, nums[i][i]);\\n            // check if the number on anti diagonal is prime\\n            if (check(nums[i][n - i - 1])) ans = max(ans, nums[i][n - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool check(int n){\\n       if(n<=1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0, n = nums.size();\\n        for (int i = 0; i < n; i++) {\\n            // check if the number on main diagonal is prime\\n            if (check(nums[i][i])) ans = max(ans, nums[i][i]);\\n            // check if the number on anti diagonal is prime\\n            if (check(nums[i][n - i - 1])) ans = max(ans, nums[i][n - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432399,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) \\n    {\\n         int row = 0;\\n         int col = 0;\\n\\n         int midrow = nums.size()/2;\\n         int midcol = nums[0].size()/2;\\n          \\n         int ans = 0;\\n         while(row < nums.size() and col < nums[0].size())\\n         {\\n             if(row == midrow and col == midcol)\\n             {\\n                 ;\\n             }\\n             else\\n             {\\n                bool flag = fun(nums[row][col]);\\n                if(flag == true and nums[row][col] > ans)\\n                ans = nums[row][col];\\n             }\\n             row++;\\n             col++;\\n         }\\n         row = 0;\\n         col = nums[0].size()-1;\\n         \\n\\n         while(row < nums.size() and col >= 0)\\n         {\\n             if(row == midrow and col == midcol)\\n             {\\n                ;\\n             }\\n             else\\n             {\\n                 bool flag = fun(nums[row][col]);\\n                 if(flag == true and nums[row][col] > ans)\\n                 ans = nums[row][col];\\n             }\\n             row++;\\n             col--;\\n         }\\n         bool temp = fun(nums[midrow][midcol]);\\n\\n         if(temp == true) \\n         if(nums[midrow][midcol] > ans) \\n         ans = nums[midrow][midcol];\\n         \\n         return ans;\\n    }\\n    bool fun(int num)\\n    {\\n        if(num == 1) return false;\\n        \\n        for(int i=2;i*i<=num;i++)\\n        {\\n            if(num%i == 0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) \\n    {\\n         int row = 0;\\n         int col = 0;\\n\\n         int midrow = nums.size()/2;\\n         int midcol = nums[0].size()/2;\\n          \\n         int ans = 0;\\n         while(row < nums.size() and col < nums[0].size())\\n         {\\n             if(row == midrow and col == midcol)\\n             {\\n                 ;\\n             }\\n             else\\n             {\\n                bool flag = fun(nums[row][col]);\\n                if(flag == true and nums[row][col] > ans)\\n                ans = nums[row][col];\\n             }\\n             row++;\\n             col++;\\n         }\\n         row = 0;\\n         col = nums[0].size()-1;\\n         \\n\\n         while(row < nums.size() and col >= 0)\\n         {\\n             if(row == midrow and col == midcol)\\n             {\\n                ;\\n             }\\n             else\\n             {\\n                 bool flag = fun(nums[row][col]);\\n                 if(flag == true and nums[row][col] > ans)\\n                 ans = nums[row][col];\\n             }\\n             row++;\\n             col--;\\n         }\\n         bool temp = fun(nums[midrow][midcol]);\\n\\n         if(temp == true) \\n         if(nums[midrow][midcol] > ans) \\n         ans = nums[midrow][midcol];\\n         \\n         return ans;\\n    }\\n    bool fun(int num)\\n    {\\n        if(num == 1) return false;\\n        \\n        for(int i=2;i*i<=num;i++)\\n        {\\n            if(num%i == 0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407929,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool isPrime(int n){\\n         if(n<2){\\n             return false;\\n         }\\n         for(int i=2; i*i<=n ;i++){\\n             if(n%i==0){\\n                 return false;\\n             }\\n         }\\n             return true;\\n     }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        vector<int> temp;\\n        for(int i=0; i<nums.size(); i++){\\n            if(isPrime(nums[i][i]))\\n             temp.push_back(nums[i][i]);\\n        }\\n        int i=0;\\n        for(int j=nums[0].size()-1; j>=0; j--){\\n            if(isPrime(nums[i][j]))\\n            temp.push_back(nums[i][j]);\\n            i++;\\n        }\\n        \\n        sort(temp.begin(),temp.end(),greater<int>());\\n        if(temp.size()==0){\\n            return 0;\\n        }\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isPrime(int n){\\n         if(n<2){\\n             return false;\\n         }\\n         for(int i=2; i*i<=n ;i++){\\n             if(n%i==0){\\n                 return false;\\n             }\\n         }\\n             return true;\\n     }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        vector<int> temp;\\n        for(int i=0; i<nums.size(); i++){\\n            if(isPrime(nums[i][i]))\\n             temp.push_back(nums[i][i]);\\n        }\\n        int i=0;\\n        for(int j=nums[0].size()-1; j>=0; j--){\\n            if(isPrime(nums[i][j]))\\n            temp.push_back(nums[i][j]);\\n            i++;\\n        }\\n        \\n        sort(temp.begin(),temp.end(),greater<int>());\\n        if(temp.size()==0){\\n            return 0;\\n        }\\n        return temp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407557,
                "title": "in-c",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:No space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint prime(int a)\\n{\\n    int i=2;\\n    for(i;i<a/2;i++)\\n    {\\n        if(a%i==0)\\n        return 0;//not prime\\n    }\\n    return 1;\\n}\\nint diagonalPrime(int** nums, int numsSize, int* numsColSize)\\n{\\n    int temp=0;\\n    int a,b;\\n    int i=0,k=numsSize-1;\\n    while(i<numsSize && k>-1)\\n    {\\n        a=nums[i][i];\\n        b=nums[i][k];\\n        if(a>temp)\\n        if(prime(a)==1)\\n        temp=a;\\n        if(b>temp)\\n        if(prime(b)==1 )\\n        temp=b;\\n        i++;\\n        k--;\\n    }\\n    printf(\"%d\",temp);\\n    if(temp==1)\\n    return 0;\\n    return temp;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint prime(int a)\\n{\\n    int i=2;\\n    for(i;i<a/2;i++)\\n    {\\n        if(a%i==0)\\n        return 0;//not prime\\n    }\\n    return 1;\\n}\\nint diagonalPrime(int** nums, int numsSize, int* numsColSize)\\n{\\n    int temp=0;\\n    int a,b;\\n    int i=0,k=numsSize-1;\\n    while(i<numsSize && k>-1)\\n    {\\n        a=nums[i][i];\\n        b=nums[i][k];\\n        if(a>temp)\\n        if(prime(a)==1)\\n        temp=a;\\n        if(b>temp)\\n        if(prime(b)==1 )\\n        temp=b;\\n        i++;\\n        k--;\\n    }\\n    printf(\"%d\",temp);\\n    if(temp==1)\\n    return 0;\\n    return temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3401478,
                "title": "c-easy-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int n){\\n       if(n<=1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<int> d;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    d.push_back(nums[i][j]);\\n                }\\n            }\\n        }\\n        sort(d.begin(),d.end());\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<d.size();i++){\\n            if(check(d[i])) \\n                maxi=max(maxi,d[i]);\\n        }\\n        if(maxi==INT_MIN) return 0;\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n){\\n       if(n<=1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<int> d;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==j||i+j==n-1){\\n                    d.push_back(nums[i][j]);\\n                }\\n            }\\n        }\\n        sort(d.begin(),d.end());\\n        vector<int> ans;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<d.size();i++){\\n            if(check(d[i])) \\n                maxi=max(maxi,d[i]);\\n        }\\n        if(maxi==INT_MIN) return 0;\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399577,
                "title": "simple-to-understand-approach",
                "content": "\\n\\n# Python Solution\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        list1=[]\\n        for i in range(len(nums)):\\n            for j in range(len(nums[0])):\\n                if i==j:\\n                    list1.append(nums[i][j])\\n                    list1.append(nums[i][len(nums)-1-i])\\n        answer=0\\n        for i in range(len(list1)):\\n                for j in range(2,int(sqrt(list1[i]))+1):\\n                    if list1[i]%j==0:\\n                        break\\n                else:\\n                    if list1[i]>answer:\\n                        answer=list1[i]\\n        if answer==1:\\n            return 0\\n        return answer\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        list1=[]\\n        for i in range(len(nums)):\\n            for j in range(len(nums[0])):\\n                if i==j:\\n                    list1.append(nums[i][j])\\n                    list1.append(nums[i][len(nums)-1-i])\\n        answer=0\\n        for i in range(len(list1)):\\n                for j in range(2,int(sqrt(list1[i]))+1):\\n                    if list1[i]%j==0:\\n                        break\\n                else:\\n                    if list1[i]>answer:\\n                        answer=list1[i]\\n        if answer==1:\\n            return 0\\n        return answer\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397851,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean prime(int n){\\n    if (n<=1){\\n        return false;\\n    }\\n    for (int i=2; i<=Math.sqrt(n); i++){\\n        if (n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n    public int diagonalPrime(int[][] nums) {\\n         int result =0; \\n         int m= nums[0].length;\\n         for(int i=0; i<nums.length; i++){\\n             if(prime(nums[i][i])){\\n                 result=Math.max(result, nums[i][i]);\\n             }\\n             if(prime(nums[i][m-1-i])){\\n                 result=Math.max(result, nums[i][m-1-i]);\\n             }\\n         }\\n         return result;\\n    } \\n     \\n    \\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean prime(int n){\\n    if (n<=1){\\n        return false;\\n    }\\n    for (int i=2; i<=Math.sqrt(n); i++){\\n        if (n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n    public int diagonalPrime(int[][] nums) {\\n         int result =0; \\n         int m= nums[0].length;\\n         for(int i=0; i<nums.length; i++){\\n             if(prime(nums[i][i])){\\n                 result=Math.max(result, nums[i][i]);\\n             }\\n             if(prime(nums[i][m-1-i])){\\n                 result=Math.max(result, nums[i][m-1-i]);\\n             }\\n         }\\n         return result;\\n    } \\n     \\n    \\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396895,
                "title": "simplest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool prime(int n) {\\n        if(n < 2) return false;\\n        for(int i=2;i*i<=n;i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int maxi = 0;\\n        for(int i=0;i<n;i++) {\\n            if(prime(nums[i][i])) {\\n                maxi = max(maxi, nums[i][i]);\\n            }\\n            if(prime(nums[i][n - i - 1])) {\\n                maxi = max(maxi, nums[i][n - i - 1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool prime(int n) {\\n        if(n < 2) return false;\\n        for(int i=2;i*i<=n;i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int maxi = 0;\\n        for(int i=0;i<n;i++) {\\n            if(prime(nums[i][i])) {\\n                maxi = max(maxi, nums[i][i]);\\n            }\\n            if(prime(nums[i][n - i - 1])) {\\n                maxi = max(maxi, nums[i][n - i - 1]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396510,
                "title": "sieve-python-3-clean-simple",
                "content": "Approach -\\n1. Find the prime elements within the max element in nums.\\n2. Traverse the diagonal elements and update the max prime element after checking if it\\'s prime or not.\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        maxi2=maxi=0\\n        for i in range(len(nums)): maxi2=max(maxi2,max(nums[i]))\\n        res=[0 if (i&1==0 and i!=2) or i==1 else 1 for i in range(maxi2+1) ]\\n        for i in range(3,maxi2+1,2):\\n            for j in range(i*i,maxi2+1,i): res[j]=0\\n            \\n        for i in [r[i] for i, r in enumerate(nums)]:\\n            if res[i]==1: maxi=max(maxi,i)\\n        for i in [r[~i] for i, r in enumerate(nums)]:\\n            if res[i]==1: maxi=max(maxi,i)\\n        return maxi\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        maxi2=maxi=0\\n        for i in range(len(nums)): maxi2=max(maxi2,max(nums[i]))\\n        res=[0 if (i&1==0 and i!=2) or i==1 else 1 for i in range(maxi2+1) ]\\n        for i in range(3,maxi2+1,2):\\n            for j in range(i*i,maxi2+1,i): res[j]=0\\n            \\n        for i in [r[i] for i, r in enumerate(nums)]:\\n            if res[i]==1: maxi=max(maxi,i)\\n        for i in [r[~i] for i, r in enumerate(nums)]:\\n            if res[i]==1: maxi=max(maxi,i)\\n        return maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396272,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n      if(n <= 1) return false;\\n      for (int i = 2; i * i <= n; i++){\\n        if (n % i == 0)return false;\\n      }\\n      return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            if(isPrime(nums[i][i]))\\n                maxi=max(maxi,nums[i][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(isPrime(nums[i][n-i-1]))\\n                maxi=max(maxi,nums[i][n-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n      if(n <= 1) return false;\\n      for (int i = 2; i * i <= n; i++){\\n        if (n % i == 0)return false;\\n      }\\n      return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            if(isPrime(nums[i][i]))\\n                maxi=max(maxi,nums[i][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(isPrime(nums[i][n-i-1]))\\n                maxi=max(maxi,nums[i][n-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396004,
                "title": "java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.length;\\n        for(int i = 0 ; i < n; i++){\\n            if(nums[i][i] > max && isPrime(nums[i][i])){\\n                max = nums[i][i];\\n            }\\n            if(nums[i][n-1-i] > max && isPrime(nums[i][n-1-i])){\\n                max = nums[i][n-1-i];\\n            }\\n        }\\n        return max;\\n    }\\n    private boolean isPrime(int n)\\n    {\\n        if(n < 2)  return false;\\n        for(int i = 2; i <= Math.sqrt(n); i++){\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.length;\\n        for(int i = 0 ; i < n; i++){\\n            if(nums[i][i] > max && isPrime(nums[i][i])){\\n                max = nums[i][i];\\n            }\\n            if(nums[i][n-1-i] > max && isPrime(nums[i][n-1-i])){\\n                max = nums[i][n-1-i];\\n            }\\n        }\\n        return max;\\n    }\\n    private boolean isPrime(int n)\\n    {\\n        if(n < 2)  return false;\\n        for(int i = 2; i <= Math.sqrt(n); i++){\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395942,
                "title": "sieve-of-eratosthenes-c-simple-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply go through all the diagonal elements for both the diagonal, and get the largest prime number among them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force:\\nEach prime number check= O(n), if the number is n\\nnums.length <= 300, nums[i]<= 4*(10^6)\\n300* 4* (10^6)= 1.2* (10^9)..This will give TLE\\n\\nUsing Sieve algorithm, reduces the time complexity.\\nRefer any article to know more about Sieve algorithm.\\nOnce you do sieve, each prime number check takes O(1) time\\n# Complexity\\n- Time complexity: \\nSieve time+ (2*n diagonal element prime check)\\n= O(m log(log m))+ O(2*n)  , where m= maximum element in nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m), where m= maximum element in nums\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sieve(vector<int>& isPrime){\\n        int n= isPrime.size()-1;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(isPrime[i]==1){\\n                for(int j= i*i;j<=n;j+=i){\\n                    isPrime[j]= 0;\\n                }\\n            }\\n        }\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int maxi= 0;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto &x:nums[i])    maxi= max(maxi, x);\\n        }\\n        maxi++;\\n        vector<int> isPrime(maxi, 1);\\n        isPrime[0]= 0, isPrime[1]= 0;\\n        sieve(isPrime);\\n        int i=0, j=0; int maxPrime= 0, n= nums.size();\\n        while(i<n){\\n            if(isPrime[nums[i][j]]==1)  maxPrime= max(maxPrime, nums[i][j]);\\n            i++;j++;\\n        }\\n\\n        i=0; j=n-1;\\n        while(i<n){\\n            if(isPrime[nums[i][j]]==1)  maxPrime= max(maxPrime, nums[i][j]);\\n            i++;j--;\\n        }\\n        return maxPrime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sieve(vector<int>& isPrime){\\n        int n= isPrime.size()-1;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(isPrime[i]==1){\\n                for(int j= i*i;j<=n;j+=i){\\n                    isPrime[j]= 0;\\n                }\\n            }\\n        }\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int maxi= 0;\\n        for(int i=0;i<nums.size();i++){\\n            for(auto &x:nums[i])    maxi= max(maxi, x);\\n        }\\n        maxi++;\\n        vector<int> isPrime(maxi, 1);\\n        isPrime[0]= 0, isPrime[1]= 0;\\n        sieve(isPrime);\\n        int i=0, j=0; int maxPrime= 0, n= nums.size();\\n        while(i<n){\\n            if(isPrime[nums[i][j]]==1)  maxPrime= max(maxPrime, nums[i][j]);\\n            i++;j++;\\n        }\\n\\n        i=0; j=n-1;\\n        while(i<n){\\n            if(isPrime[nums[i][j]]==1)  maxPrime= max(maxPrime, nums[i][j]);\\n            i++;j--;\\n        }\\n        return maxPrime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395874,
                "title": "step-by-step-code-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrime(self, num):\\n        a = []\\n        if num <= 1: return False\\n        for i in range(2, isqrt(num) + 1):\\n            if not num % i:\\n                a.append(i)\\n        return not a\\n    \\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i == j or i + j == len(nums) - 1:\\n                    print(nums[i][j])\\n                    a.append(nums[i][j])\\n                    print(a)\\n        b = []\\n        for ele in a:\\n            if self.isPrime(ele):\\n                b.append(ele)\\n        print(b)\\n        return max(b) if b else 0\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        a = []\\n        if num <= 1: return False\\n        for i in range(2, isqrt(num) + 1):\\n            if not num % i:\\n                a.append(i)\\n        return not a\\n    \\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i == j or i + j == len(nums) - 1:\\n                    print(nums[i][j])\\n                    a.append(nums[i][j])\\n                    print(a)\\n        b = []\\n        for ele in a:\\n            if self.isPrime(ele):\\n                b.append(ele)\\n        print(b)\\n        return max(b) if b else 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395840,
                "title": "great-contest-on-my-birthday",
                "content": "# Approach:\\n\\nFirst create a sieve of all the prime number from $$0$$ to $$4 * 10^6$$.\\n\\nThen iterate on the diagonals and get the maximum prime out of it.\\n\\nThe reason to use a sieve is to avoid getting a TLE by using the naive prime check on every number.\\n\\n---\\n\\n# Code:\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        fill();\\n        int n = nums.length;\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (p[nums[i][i]]) {\\n                max = Math.max(max, nums[i][i]);\\n            }\\n            if (p[nums[i][n - i - 1]]) {\\n                max = Math.max(max, nums[i][n - i - 1]);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    boolean[] p = new boolean[4 * 1000000 + 1];\\n    private void fill() {\\n        Arrays.fill(p, true);\\n        int n = 4 * 1000000;\\n        for (int i = 2; i * i <= n; i++) {\\n            if (!p[i]) continue;\\n            for (int j = 2 * i; j <= n; j += i) {\\n                p[j] = false;\\n            }\\n        }\\n        p[0] = p[1] = false;\\n    }\\n}\\n```\\nLet $$n = 4 * 10^6$$ and $$m$$ = length of nums.\\n### Time complexity: $$O(n.log(logn)) + O(m * sqrt(2))$$",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        fill();\\n        int n = nums.length;\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (p[nums[i][i]]) {\\n                max = Math.max(max, nums[i][i]);\\n            }\\n            if (p[nums[i][n - i - 1]]) {\\n                max = Math.max(max, nums[i][n - i - 1]);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    boolean[] p = new boolean[4 * 1000000 + 1];\\n    private void fill() {\\n        Arrays.fill(p, true);\\n        int n = 4 * 1000000;\\n        for (int i = 2; i * i <= n; i++) {\\n            if (!p[i]) continue;\\n            for (int j = 2 * i; j <= n; j += i) {\\n                p[j] = false;\\n            }\\n        }\\n        p[0] = p[1] = false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395819,
                "title": "very-easy-c-solution-check-for-2-diagonal-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n\\u2217sqrt(n))\\n\\n- Space complexity:\\nO(1)<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool prime(int n)\\n{\\n\\n    if (n <= 1)\\n        return false;\\n \\n    for (int i = 2; i * i <= n; i++) {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n} int diagonalPrime(vector<vector<int>>& nums) {\\n        long long maxi=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums[i].size();j++)\\n            {\\n                if(i==j and prime(nums[i][j]))\\n                {\\n                   \\n                    if(nums[i][j]>maxi)\\n                        maxi=nums[i][j];\\n                }\\n                if(i+j==nums.size()-1 and prime(nums[i][j]))\\n                {\\n                         if(nums[i][j]>maxi)\\n                        maxi=nums[i][j];\\n                }\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool prime(int n)\\n{\\n\\n    if (n <= 1)\\n        return false;\\n \\n    for (int i = 2; i * i <= n; i++) {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n} int diagonalPrime(vector<vector<int>>& nums) {\\n        long long maxi=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums[i].size();j++)\\n            {\\n                if(i==j and prime(nums[i][j]))\\n                {\\n                   \\n                    if(nums[i][j]>maxi)\\n                        maxi=nums[i][j];\\n                }\\n                if(i+j==nums.size()-1 and prime(nums[i][j]))\\n                {\\n                         if(nums[i][j]>maxi)\\n                        maxi=nums[i][j];\\n                }\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395815,
                "title": "greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    int findPrimes(vector<int> &p){\\n        p.push_back(2);\\n        for(int i = 3; i<2000; ++i){\\n            int f= 1;\\n            for(auto j: p){\\n                if(i % j == 0) { f = 0; break; }\\n            }\\n            if(f) p.push_back(i);\\n        }\\n        return 0;\\n    }\\n    bool checkPrime(int n){\\n        int t = sqrt(n);\\n        if(n <= 2) return n-1;\\n        for(auto i: primes){ \\n            if(n % i == 0 ) return false;  \\n            if(i > t) return true;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        if(primes.size() == 0) findPrimes(primes);\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(checkPrime(nums[i][i])) ans = max(ans, nums[i][i]);\\n            if(checkPrime(nums[i][nums.size() - i - 1])) ans = max(ans, nums[i][nums.size() - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> primes;\\n    int findPrimes(vector<int> &p){\\n        p.push_back(2);\\n        for(int i = 3; i<2000; ++i){\\n            int f= 1;\\n            for(auto j: p){\\n                if(i % j == 0) { f = 0; break; }\\n            }\\n            if(f) p.push_back(i);\\n        }\\n        return 0;\\n    }\\n    bool checkPrime(int n){\\n        int t = sqrt(n);\\n        if(n <= 2) return n-1;\\n        for(auto i: primes){ \\n            if(n % i == 0 ) return false;  \\n            if(i > t) return true;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        if(primes.size() == 0) findPrimes(primes);\\n        for(int i = 0; i < nums.size(); ++i){\\n            if(checkPrime(nums[i][i])) ans = max(ans, nums[i][i]);\\n            if(checkPrime(nums[i][nums.size() - i - 1])) ans = max(ans, nums[i][nums.size() - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395791,
                "title": "java-easy-solution",
                "content": "# class Solution {\\n    public int isprime(int n)\\n    {\\n        if(n==1 || n==0)\\n        {\\n            return 0;\\n        }\\n        for(int i=2;i<=(n/2);i++)\\n        {\\n            if(n%i==0)\\n            {\\n               return 0; \\n            }\\n        }\\n        return 1;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        int n=nums.length;\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!a.contains(nums[i][i]))\\n            {\\n                a.add(nums[i][i]);\\n            }\\n        }\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n           if(!a.contains(nums[i][c]))\\n           {\\n               a.add(nums[i][c]);\\n           }\\n            c++;\\n        }\\n        Collections.sort(a);\\n        System.out.println(a+\" \"+a.size());\\n        for(int i=a.size()-1;i>=0;i--)\\n        {\\n            //System.out.println(a.get(i)+\" \"+i);\\n            int x=isprime(a.get(i));\\n            if(x==1)\\n            {\\n               return a.get(i); \\n            }else{\\n                continue;\\n            }\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int isprime(int n)\\n    {\\n        if(n==1 || n==0)\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3395764,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        \\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            boolean bool=true;\\n            if(nums[i][i]==0 || nums[i][i]==1 )\\n                bool=false;\\n            for(int k=2;k<=Math.sqrt(nums[i][i]);k++){\\n                if(nums[i][i]%k==0){\\n                    bool=false;\\n                    break;\\n                }\\n            }\\n            if(bool==true)\\n                ans=Math.max(ans,nums[i][i]);\\n\\n            \\n            boolean bool2=true;\\n            int b=nums[i][nums.length - i - 1];\\n            if(nums[i][nums.length - i - 1]==0 || nums[i][nums.length - i - 1]==1)\\n            bool2=false;\\n            for(int k=2;k<=Math.sqrt(b);k++){\\n                if(b%k==0){\\n                    bool2=false;\\n                    break;\\n                }\\n            }\\n            if(bool2==true){\\n                ans=Math.max(ans,b);\\n            }\\n        }\\n        return ans==Integer.MIN_VALUE?0:ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        \\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            boolean bool=true;\\n            if(nums[i][i]==0 || nums[i][i]==1 )\\n                bool=false;\\n            for(int k=2;k<=Math.sqrt(nums[i][i]);k++){\\n                if(nums[i][i]%k==0){\\n                    bool=false;\\n                    break;\\n                }\\n            }\\n            if(bool==true)\\n                ans=Math.max(ans,nums[i][i]);\\n\\n            \\n            boolean bool2=true;\\n            int b=nums[i][nums.length - i - 1];\\n            if(nums[i][nums.length - i - 1]==0 || nums[i][nums.length - i - 1]==1)\\n            bool2=false;\\n            for(int k=2;k<=Math.sqrt(b);k++){\\n                if(b%k==0){\\n                    bool2=false;\\n                    break;\\n                }\\n            }\\n            if(bool2==true){\\n                ans=Math.max(ans,b);\\n            }\\n        }\\n        return ans==Integer.MIN_VALUE?0:ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395739,
                "title": "java-solution-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^3/2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(isPrime(nums[i][i]))\\n                max = Math.max(max,nums[i][i]);\\n            if(isPrime(nums[i][nums.length-i-1]))\\n                max = Math.max(max,nums[i][nums.length-i-1]);\\n        }\\n        return max;\\n    }\\n    \\n    boolean isPrime(int v){\\n        if(v<2) return false;\\n        for(int i=2;i<=Math.sqrt(v);i++){\\n            if(v%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(isPrime(nums[i][i]))\\n                max = Math.max(max,nums[i][i]);\\n            if(isPrime(nums[i][nums.length-i-1]))\\n                max = Math.max(max,nums[i][nums.length-i-1]);\\n        }\\n        return max;\\n    }\\n    \\n    boolean isPrime(int v){\\n        if(v<2) return false;\\n        for(int i=2;i<=Math.sqrt(v);i++){\\n            if(v%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395707,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 860 ms, faster than 46.67% of Python3 online submissions for Prime In Diagonal.\\n# Memory Usage: 26.1 MB, less than 100.00% of Python3 online submissions for Prime In Diagonal.\\n# \\n\\timport math\\n\\n\\tclass Solution:\\n\\t\\tdef diagonalPrime(self, nums: List[List[int]]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\t\\t\\tlength = len(nums)\\n\\n\\t\\t\\tdef prime(n):\\n\\n\\t\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tfor i in range(2, math.floor(math.sqrt(n)) + 1):\\n\\t\\t\\t\\t\\tif n % i == 0:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor i in range(length):\\n\\n\\t\\t\\t\\tif prime(nums[i][i]) == True:\\n\\t\\t\\t\\t\\tresult = max(result, nums[i][i])\\n\\n\\t\\t\\t\\tif prime(nums[i][length - i - 1]) == True:\\n\\t\\t\\t\\t\\tresult = max(result, nums[i][length - i - 1])\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 860 ms, faster than 46.67% of Python3 online submissions for Prime In Diagonal.\\n# Memory Usage: 26.1 MB, less than 100.00% of Python3 online submissions for Prime In Diagonal.\\n# \\n\\timport math\\n\\n\\tclass Solution:\\n\\t\\tdef diagonalPrime(self, nums: List[List[int]]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\t\\t\\tlength = len(nums)\\n\\n\\t\\t\\tdef prime(n):\\n\\n\\t\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tfor i in range(2, math.floor(math.sqrt(n)) + 1):\\n\\t\\t\\t\\t\\tif n % i == 0:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor i in range(length):\\n\\n\\t\\t\\t\\tif prime(nums[i][i]) == True:\\n\\t\\t\\t\\t\\tresult = max(result, nums[i][i])\\n\\n\\t\\t\\t\\tif prime(nums[i][length - i - 1]) == True:\\n\\t\\t\\t\\t\\tresult = max(result, nums[i][length - i - 1])\\n\\n\\t\\t\\treturn result\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3395686,
                "title": "c-simple-iteration",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isprime(long long n){\\n        if(n==1) return false;\\n        n = 1L*n;\\n        for(long long i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        long long ans=0;\\n        for(long long i=0,j=nums[0].size()-1;i<nums.size();i++,j--){\\n            if(isprime(nums[i][i])) ans = max((long long)nums[i][i]*1L,ans);\\n            if(isprime(nums[i][nums.size()-1-i])) ans = max((long long)nums[i][j]*1L,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(long long n){\\n        if(n==1) return false;\\n        n = 1L*n;\\n        for(long long i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        long long ans=0;\\n        for(long long i=0,j=nums[0].size()-1;i<nums.size();i++,j--){\\n            if(isprime(nums[i][i])) ans = max((long long)nums[i][i]*1L,ans);\\n            if(isprime(nums[i][nums.size()-1-i])) ans = max((long long)nums[i][j]*1L,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088858,
                "title": "nothing-special-here",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool prime(int a){\\n        if(a==1) return false;\\n        for(int i=2;i<=Math.Sqrt(a);i++)\\n        {\\n            if(a%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int DiagonalPrime(int[][] nums) {\\n        int maxPrime = 0;\\n            for(int i= 0; i<nums.Length; i++) \\n            {\\n                if (prime(nums[i][i]))\\n                {\\n                    if(nums[i][i] > maxPrime){\\n                        maxPrime = nums[i][i];\\n                    }\\n                    \\n                }\\n                if (prime(nums[i][nums.GetLength(0)-i-1]))\\n                {\\n                    if(nums[i][nums.GetLength(0) - i - 1] > maxPrime){\\n                        maxPrime = nums[i][nums.GetLength(0) - i - 1];\\n                    }\\n                }\\n            }\\n            return maxPrime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool prime(int a){\\n        if(a==1) return false;\\n        for(int i=2;i<=Math.Sqrt(a);i++)\\n        {\\n            if(a%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int DiagonalPrime(int[][] nums) {\\n        int maxPrime = 0;\\n            for(int i= 0; i<nums.Length; i++) \\n            {\\n                if (prime(nums[i][i]))\\n                {\\n                    if(nums[i][i] > maxPrime){\\n                        maxPrime = nums[i][i];\\n                    }\\n                    \\n                }\\n                if (prime(nums[i][nums.GetLength(0)-i-1]))\\n                {\\n                    if(nums[i][nums.GetLength(0) - i - 1] > maxPrime){\\n                        maxPrime = nums[i][nums.GetLength(0) - i - 1];\\n                    }\\n                }\\n            }\\n            return maxPrime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080666,
                "title": "rust-python-solution",
                "content": "# Code\\n```python []\\nclass Solution:\\n    @staticmethod\\n    def is_prime(num: int) -> bool:\\n        if num <= 1:\\n            return False\\n        elif num <= 3:\\n            return True\\n        elif num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i * i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n\\n        return True\\n\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        length = len(nums)\\n\\n        result = [\\n            nums[i][j]\\n            for i in range(length)\\n            for j in range(length)\\n            if (i == j or j == length - i - 1) and Solution.is_prime(nums[i][j])\\n        ]\\n\\n        try:\\n            return max(result)\\n        except ValueError:\\n            return 0\\n```\\n```rust []\\nimpl Solution {\\n    fn is_prime(num: i32) -> bool {\\n        if num <= 1 {\\n            return false;\\n        }\\n        if num <= 3 {\\n            return true;\\n        }\\n        if num % 2 == 0 || num % 3 == 0 {\\n            return false;\\n        }\\n        let mut i = 5;\\n        while i * i <= num {\\n            if num % i == 0 || num % (i + 2) == 0 {\\n                return false;\\n            }\\n            i += 6;\\n        }\\n        true\\n    }\\n    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {\\n        let len = nums.len();\\n        let mut result = 0;\\n        for i in 0..len {\\n            for j in 0..len {\\n                if i != j && j != len - i - 1 {\\n                    continue;\\n                }\\n                if Self::is_prime(nums[i][j]) {\\n                    result = result.max(nums[i][j]);\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    @staticmethod\\n    def is_prime(num: int) -> bool:\\n        if num <= 1:\\n            return False\\n        elif num <= 3:\\n            return True\\n        elif num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i * i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n\\n        return True\\n\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        length = len(nums)\\n\\n        result = [\\n            nums[i][j]\\n            for i in range(length)\\n            for j in range(length)\\n            if (i == j or j == length - i - 1) and Solution.is_prime(nums[i][j])\\n        ]\\n\\n        try:\\n            return max(result)\\n        except ValueError:\\n            return 0\\n```\n```rust []\\nimpl Solution {\\n    fn is_prime(num: i32) -> bool {\\n        if num <= 1 {\\n            return false;\\n        }\\n        if num <= 3 {\\n            return true;\\n        }\\n        if num % 2 == 0 || num % 3 == 0 {\\n            return false;\\n        }\\n        let mut i = 5;\\n        while i * i <= num {\\n            if num % i == 0 || num % (i + 2) == 0 {\\n                return false;\\n            }\\n            i += 6;\\n        }\\n        true\\n    }\\n    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {\\n        let len = nums.len();\\n        let mut result = 0;\\n        for i in 0..len {\\n            for j in 0..len {\\n                if i != j && j != len - i - 1 {\\n                    continue;\\n                }\\n                if Self::is_prime(nums[i][j]) {\\n                    result = result.max(nums[i][j]);\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079315,
                "title": "beats-99-11-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let len = nums.length;\\n    let max = 0;\\n    for(let i=0; i<len; i++){\\n        if(isPrime(nums[i][i]) && nums[i][i] > max){\\n            max = nums[i][i];\\n        }\\n    }\\n    for(let i=0; i<len; i++){\\n        if(isPrime(nums[i][len-1-i]) && nums[i][len-1-i] > max){\\n            max = nums[i][len-1-i]\\n        }\\n    }\\n    return max\\n};\\n\\nvar isPrime = (num) => {\\n    if(num === 1){\\n        return false\\n    }\\n    for(let i=2; i<=Math.sqrt(num); i++){\\n        if(num % i ===0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let len = nums.length;\\n    let max = 0;\\n    for(let i=0; i<len; i++){\\n        if(isPrime(nums[i][i]) && nums[i][i] > max){\\n            max = nums[i][i];\\n        }\\n    }\\n    for(let i=0; i<len; i++){\\n        if(isPrime(nums[i][len-1-i]) && nums[i][len-1-i] > max){\\n            max = nums[i][len-1-i]\\n        }\\n    }\\n    return max\\n};\\n\\nvar isPrime = (num) => {\\n    if(num === 1){\\n        return false\\n    }\\n    for(let i=2; i<=Math.sqrt(num); i++){\\n        if(num % i ===0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077813,
                "title": "basic-approach-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkForPrime(int n)\\n    {\\n        if (n <= 1)\\n        return false;\\n        for (int i = 2; i <= n / 2; i++)\\n        if (n % i == 0)\\n            return false;\\n \\n    return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int max=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if( (i==j) || (i==0 && j==nums.size()) || (j==0 && i==nums.size()) || i+j==nums.size()-1 )\\n                {\\n                    if(max<nums[i][j])\\n                    {\\n                        if(checkForPrime(nums[i][j]))\\n                        max=nums[i][j];\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        if(max==-1)\\n        {\\n            return 0;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkForPrime(int n)\\n    {\\n        if (n <= 1)\\n        return false;\\n        for (int i = 2; i <= n / 2; i++)\\n        if (n % i == 0)\\n            return false;\\n \\n    return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int max=-1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if( (i==j) || (i==0 && j==nums.size()) || (j==0 && i==nums.size()) || i+j==nums.size()-1 )\\n                {\\n                    if(max<nums[i][j])\\n                    {\\n                        if(checkForPrime(nums[i][j]))\\n                        max=nums[i][j];\\n                    }\\n                    \\n                } \\n            }\\n        }\\n        if(max==-1)\\n        {\\n            return 0;\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066909,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        int maxim = 0;\\n        for (int i = 0; i < n; i++) {\\n                if (checkPrime(nums[i][i])) {\\n                    maxim = Math.max(maxim, nums[i][i]);\\n                } \\n                if (checkPrime(nums[n-1-i][i])) {\\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\\n\\n                }\\n            \\n        }\\n        return maxim;\\n    }\\n    public boolean checkPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        int maxim = 0;\\n        for (int i = 0; i < n; i++) {\\n                if (checkPrime(nums[i][i])) {\\n                    maxim = Math.max(maxim, nums[i][i]);\\n                } \\n                if (checkPrime(nums[n-1-i][i])) {\\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\\n\\n                }\\n            \\n        }\\n        return maxim;\\n    }\\n    public boolean checkPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058456,
                "title": "c-two-way-solutions-trial-division-or-erastosthenes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are some ways to check whether the number is prime or not.As you know, trial division or sieve of erastosthenes are famous.I will explain the methods with caliculation comlexity.\\n\\nn=nums.size();\\nnum=max(diagonal numbers);\\n\\n# Approach1 : Trial Division\\n<!-- Describe your approach to solving the problem. -->\\nThis method is to check a number is prime or not.As a simple way,we check whether the number is divised by number from one to sqrt(num) or not.So,it takes O(sqrt(n)).If the number is divised by one number,the number is not prime. \\nFor this question,we use Trial Division n times.So,if the n become bigger, the caliculation time become bigger linely.\\n\\n# Complexity\\n- Time complexity:O(nums.size()*sqrt(num))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(num)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code (Trial Division)\\n```\\nclass Solution {\\npublic:\\n    bool check(int num){\\n        if(num<=1)return false;\\n        for(int i = 2; i*i <= num; i++){\\n            if(num%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(check(nums[i][i])){\\n                ans = max(ans,nums[i][i]);\\n            }\\n            if(check(nums[i][n-1-i])){\\n                ans = max(ans,nums[i][n-1-i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Approach2 : Sieve of erastosthenes\\n<!-- Describe your approach to solving the problem. -->\\nwe can get the checking array by sieve of erastosthenes.So,If we get this array once,we just check index of array and it is prime or not.How can we get this array. we check number from 2 to num. For example, when we check 2,then all multiple of 2 index become false that is not prime! time complexity is difficult to estimate,but checking number become bigger , then a number of multiple of the number become smaller.So, time complexity is almost num;\\n\\n# Complexity\\n- Time complexity:O(num*log(log(num))+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(num)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code (Sieve of erastosthenes)\\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime0(vector<vector<int>>& nums) {\\n        int max_value=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            max_value=max(max_value,nums[i][i]);\\n            max_value=max(max_value,nums[i][n-1-i]);\\n        }\\n        vector<bool> check=erastosthenes(max_value);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[nums[i][i]]){\\n                ans=max(ans,nums[i][i]);\\n            }\\n            if(check[nums[i][n-1-i]]){\\n                ans=max(ans,nums[i][n-1-i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n     vector<bool> erastosthenes(int num){\\n         vector<bool> er(num+1,true);\\n         er[0]=false;\\n         er[1]=false;\\n         for(int i=2;i<num+1;i++){\\n             if(er[i]){\\n                 for(int j=2*i;j<num+1;j+=i){\\n                     er[j]=false;\\n                 }\\n             }\\n         }\\n         return er;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int num){\\n        if(num<=1)return false;\\n        for(int i = 2; i*i <= num; i++){\\n            if(num%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans = 0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(check(nums[i][i])){\\n                ans = max(ans,nums[i][i]);\\n            }\\n            if(check(nums[i][n-1-i])){\\n                ans = max(ans,nums[i][n-1-i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime0(vector<vector<int>>& nums) {\\n        int max_value=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            max_value=max(max_value,nums[i][i]);\\n            max_value=max(max_value,nums[i][n-1-i]);\\n        }\\n        vector<bool> check=erastosthenes(max_value);\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(check[nums[i][i]]){\\n                ans=max(ans,nums[i][i]);\\n            }\\n            if(check[nums[i][n-1-i]]){\\n                ans=max(ans,nums[i][n-1-i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n     vector<bool> erastosthenes(int num){\\n         vector<bool> er(num+1,true);\\n         er[0]=false;\\n         er[1]=false;\\n         for(int i=2;i<num+1;i++){\\n             if(er[i]){\\n                 for(int j=2*i;j<num+1;j+=i){\\n                     er[j]=false;\\n                 }\\n             }\\n         }\\n         return er;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051118,
                "title": "c-easy-check-all-diagonal-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      bool checkPrime(int n)\\n      {\\n        if(n==1)\\n        return false;\\n          for(int i=2;i<=sqrt(n);i++)\\n           {\\n             if(n%i==0)\\n                return false;\\n           }\\n\\n           return true;\\n                \\n      }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i=0,j=0;\\n        int n=nums.size(),m=nums[0].size(),ma=0;\\n  \\n        //left diagonal\\n         while(i<n)\\n           {\\n               if(checkPrime(nums[i][j])==true)\\n                ma=max(ma,nums[i][j]);\\n              i++,j++;\\n           }\\n           //right diagonal\\n          j=m-1,i=0;\\n          while(i<n)\\n            {\\n               if(checkPrime(nums[i][j])==true)\\n                ma=max(ma,nums[i][j]);\\n              j--,i++;\\n            }\\n            return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      bool checkPrime(int n)\\n      {\\n        if(n==1)\\n        return false;\\n          for(int i=2;i<=sqrt(n);i++)\\n           {\\n             if(n%i==0)\\n                return false;\\n           }\\n\\n           return true;\\n                \\n      }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i=0,j=0;\\n        int n=nums.size(),m=nums[0].size(),ma=0;\\n  \\n        //left diagonal\\n         while(i<n)\\n           {\\n               if(checkPrime(nums[i][j])==true)\\n                ma=max(ma,nums[i][j]);\\n              i++,j++;\\n           }\\n           //right diagonal\\n          j=m-1,i=0;\\n          while(i<n)\\n            {\\n               if(checkPrime(nums[i][j])==true)\\n                ma=max(ma,nums[i][j]);\\n              j--,i++;\\n            }\\n            return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047327,
                "title": "prime-number-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isPrime(int x){\\n        if (x==1 || x==0)\\n            return false;\\n        if (x==2)\\n            return true;\\n        for (int i = 2;i<=sqrt(x);i++){\\n            if (x%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int max = 0;\\n        int size = nums.size() - 1;\\n        for (int i=0;i<nums.size();i++){\\n            if (isPrime(nums[i][i]) && nums[i][i] > max){\\n                max = nums[i][i];\\n            }\\n            if (isPrime(nums[i][size - i]) && nums[i][size - i] > max){\\n                max = nums[i][size - i];\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPrime(int x){\\n        if (x==1 || x==0)\\n            return false;\\n        if (x==2)\\n            return true;\\n        for (int i = 2;i<=sqrt(x);i++){\\n            if (x%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int max = 0;\\n        int size = nums.size() - 1;\\n        for (int i=0;i<nums.size();i++){\\n            if (isPrime(nums[i][i]) && nums[i][i] > max){\\n                max = nums[i][i];\\n            }\\n            if (isPrime(nums[i][size - i]) && nums[i][size - i] > max){\\n                max = nums[i][size - i];\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046006,
                "title": "2614-prime-in-diagonal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        max_prime = row = 0\\n        nums_len = len(nums)\\n        left_diagonal = range(nums_len)\\n        right_diagonal = range(nums_len - 1, -1, -1)\\n        def is_prime(n) -> bool:\\n            \"\"\"a prime helper function\"\"\"\\n            for i in range(2, int(n ** 0.5) + 1):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        \\n        def validate_conditions(left_num, right_num, row):\\n            \"\"\" helper function to find max from diagonal patterns\"\"\"\\n            max_num = 0\\n            if nums[row][left_num] > 1 and is_prime(nums[row][left_num]):\\n                max_num = max(max_num, nums[row][left_num])\\n            if nums[row][right_num] > 1 and is_prime(nums[row][right_num]):\\n                max_num = max(max_num, nums[row][right_num])\\n            return max_num\\n    \\n        for left_num, right_num in zip(left_diagonal, right_diagonal):\\n            max_prime = max(max_prime, validate_conditions(left_num, right_num, row=row))\\n            row = row + 1\\n        return max_prime\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        max_prime = row = 0\\n        nums_len = len(nums)\\n        left_diagonal = range(nums_len)\\n        right_diagonal = range(nums_len - 1, -1, -1)\\n        def is_prime(n) -> bool:\\n            \"\"\"a prime helper function\"\"\"\\n            for i in range(2, int(n ** 0.5) + 1):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        \\n        def validate_conditions(left_num, right_num, row):\\n            \"\"\" helper function to find max from diagonal patterns\"\"\"\\n            max_num = 0\\n            if nums[row][left_num] > 1 and is_prime(nums[row][left_num]):\\n                max_num = max(max_num, nums[row][left_num])\\n            if nums[row][right_num] > 1 and is_prime(nums[row][right_num]):\\n                max_num = max(max_num, nums[row][right_num])\\n            return max_num\\n    \\n        for left_num, right_num in zip(left_diagonal, right_diagonal):\\n            max_prime = max(max_prime, validate_conditions(left_num, right_num, row=row))\\n            row = row + 1\\n        return max_prime\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040196,
                "title": "beginner-friendly-solution-5ms-beats-75",
                "content": "# Intuition\\nyou might be getting TLE error \\nthats because your prime checking function is not good\\nelse is ok\\ncheck the code below to understand\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2/2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n    public int diagonalPrime(int[][] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(i<nums.length && j<nums.length){\\n            if(isPrime(nums[i][j])){\\n                count = Math.max(count, nums[i][j]);\\n            }\\n            i++;\\n            j++;\\n        }\\n        i=nums.length-1;\\n        j=0;\\n    \\n        while(i>=0 && j<nums.length){\\n            if(isPrime(nums[i][j])){\\n                count = Math.max(count, nums[i][j]);\\n            }\\n            i--;\\n            j++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n![upvote2.jpeg](https://assets.leetcode.com/users/images/0479e715-488d-4a0b-8ddb-4963adcc7d9a_1694615131.4118042.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n    public int diagonalPrime(int[][] nums) {\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(i<nums.length && j<nums.length){\\n            if(isPrime(nums[i][j])){\\n                count = Math.max(count, nums[i][j]);\\n            }\\n            i++;\\n            j++;\\n        }\\n        i=nums.length-1;\\n        j=0;\\n    \\n        while(i>=0 && j<nums.length){\\n            if(isPrime(nums[i][j])){\\n                count = Math.max(count, nums[i][j]);\\n            }\\n            i--;\\n            j++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026594,
                "title": "60-beats-in-tc-o-n-80-beats-in-memory",
                "content": "Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     boolean isprime(int n){\\n         if(n==1 || n==0)\\n         return false;         \\n            for(int i=2;i<=Math.sqrt(n);i++){\\n                if(n%i==0)\\n                return false;\\n            }\\n            return true;\\n        }\\n    public int diagonalPrime(int[][] nums) {\\n       int max= 0;\\n        for(int i =0;i<nums.length;i++){        \\n        if(isprime(nums[i][i]) )\\n         max = Math.max(nums[i][i],max);\\n         if( isprime(nums[i][nums.length-i-1]))\\n        max  = Math.max(nums[i][nums.length-i-1],max);\\n    }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     boolean isprime(int n){\\n         if(n==1 || n==0)\\n         return false;         \\n            for(int i=2;i<=Math.sqrt(n);i++){\\n                if(n%i==0)\\n                return false;\\n            }\\n            return true;\\n        }\\n    public int diagonalPrime(int[][] nums) {\\n       int max= 0;\\n        for(int i =0;i<nums.length;i++){        \\n        if(isprime(nums[i][i]) )\\n         max = Math.max(nums[i][i],max);\\n         if( isprime(nums[i][nums.length-i-1]))\\n        max  = Math.max(nums[i][nums.length-i-1],max);\\n    }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017810,
                "title": "single-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSingle Loop Solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isPrime(int n){\\n        if(n == 2 || n ==3 )\\n            return true;\\n        if(n==1 ||n%2 == 0 || n%3 == 0)\\n            return false;\\n        for(int i=5;i*i<=n;i++){\\n            if(n%i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(isPrime(nums[i][i]))\\n                max = Math.max(nums[i][i],max);\\n            if(isPrime(nums[i][nums.length-i-1]))\\n                max = Math.max(nums[i][nums.length-i-1],max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean isPrime(int n){\\n        if(n == 2 || n ==3 )\\n            return true;\\n        if(n==1 ||n%2 == 0 || n%3 == 0)\\n            return false;\\n        for(int i=5;i*i<=n;i++){\\n            if(n%i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(isPrime(nums[i][i]))\\n                max = Math.max(nums[i][i],max);\\n            if(isPrime(nums[i][nums.length-i-1]))\\n                max = Math.max(nums[i][nums.length-i-1],max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016603,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.length;\\n        //top-left to bottom-right diagonals\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tint val = nums[i][i];\\n            if (isPrime(val)) {\\n                max = Math.max(max,val);\\n            }\\n        }\\n        //bottom-left to top-right diagonals\\n        for (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tint val2 = nums[n - i - 1][i];\\n            if (isPrime(val2)) {\\n                max = Math.max(max, val2);\\n            }\\n        }\\n        return max;\\n    }\\n    // check element is prime or not\\n    private boolean isPrime(int n) {\\n        if(n<=1){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.length;\\n        //top-left to bottom-right diagonals\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\tint val = nums[i][i];\\n            if (isPrime(val)) {\\n                max = Math.max(max,val);\\n            }\\n        }\\n        //bottom-left to top-right diagonals\\n        for (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tint val2 = nums[n - i - 1][i];\\n            if (isPrime(val2)) {\\n                max = Math.max(max, val2);\\n            }\\n        }\\n        return max;\\n    }\\n    // check element is prime or not\\n    private boolean isPrime(int n) {\\n        if(n<=1){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011652,
                "title": "0ms-o-n-time-o-1-space-begginer-freindly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int maxPrime = 0, temp;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            temp = nums[i][i];\\n            if (temp > maxPrime && isPrime(temp)) {\\n                maxPrime = nums[i][i];\\n            }\\n            temp = nums[i][nums.length - i - 1];\\n            if (temp > maxPrime && isPrime(temp)) {\\n                maxPrime = temp;\\n            }\\n        }\\n\\n        return maxPrime;\\n    }\\n\\n    static boolean isPrime(int num) {\\n        if (num == 2)\\n            return true;\\n        if (num % 2 == 0 || num == 1)\\n            return false;\\n\\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int maxPrime = 0, temp;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            temp = nums[i][i];\\n            if (temp > maxPrime && isPrime(temp)) {\\n                maxPrime = nums[i][i];\\n            }\\n            temp = nums[i][nums.length - i - 1];\\n            if (temp > maxPrime && isPrime(temp)) {\\n                maxPrime = temp;\\n            }\\n        }\\n\\n        return maxPrime;\\n    }\\n\\n    static boolean isPrime(int num) {\\n        if (num == 2)\\n            return true;\\n        if (num % 2 == 0 || num == 1)\\n            return false;\\n\\n        for (int i = 3; i <= Math.sqrt(num); i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003054,
                "title": "easy-peasy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let primes = []\\n\\n    const isPrime = (num) => {\\n        if(num < 2) return false\\n\\n        if (num % 2 == 0) return num == 2\\n        let root = Math.sqrt(num)\\n\\n        for(let i = 3; i <= root; ++i) {\\n            if(num % i == 0) return false\\n        }\\n\\n        return true\\n    }\\n\\n    for(let i = 0; i < nums.length; ++i) {\\n        let diag1 = nums[i][i]\\n        let diag2 = nums[i][nums.length - 1 - i]\\n\\n        if(isPrime(diag1)) primes.push(diag1)\\n        if(isPrime(diag2)) primes.push(diag2)\\n    }\\n\\n    return primes.length ? Math.max(...primes) : 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let primes = []\\n\\n    const isPrime = (num) => {\\n        if(num < 2) return false\\n\\n        if (num % 2 == 0) return num == 2\\n        let root = Math.sqrt(num)\\n\\n        for(let i = 3; i <= root; ++i) {\\n            if(num % i == 0) return false\\n        }\\n\\n        return true\\n    }\\n\\n    for(let i = 0; i < nums.length; ++i) {\\n        let diag1 = nums[i][i]\\n        let diag2 = nums[i][nums.length - 1 - i]\\n\\n        if(isPrime(diag1)) primes.push(diag1)\\n        if(isPrime(diag2)) primes.push(diag2)\\n    }\\n\\n    return primes.length ? Math.max(...primes) : 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3995338,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int x){\\n        if(x==1)return false;\\n        for(int i = 2; i*i<=x; i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            int x = nums[i][i];\\n            \\n            if(check(x)){\\n                ans = max(ans, x);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            int x = nums[i][n-i-1];\\n            \\n            if(check(x)){\\n                ans = max(ans, x);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x){\\n        if(x==1)return false;\\n        for(int i = 2; i*i<=x; i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            int x = nums[i][i];\\n            \\n            if(check(x)){\\n                ans = max(ans, x);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            int x = nums[i][n-i-1];\\n            \\n            if(check(x)){\\n                ans = max(ans, x);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984723,
                "title": "easy-approach-c-solution-linear-solution-o-n-time-82-66-c-of-c-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind the both diagonal d1 and d2 ..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst declare ans vector and the find the diagonal emlements ans push the element into ans .\\nthen we find the prime number using prime funtion and use the loop till ans.size().\\nand comapare the ans with max.\\nand print the  m . \\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool prime(int a){\\n        if(a==1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=a;i++){\\n            if(a%i==0){\\n                return false;\\n               // break;\\n            }\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int max=0;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i][i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i][nums.size()-i-1]);\\n        }\\n    for(int i=0;i<ans.size();i++){\\n        if(prime(ans[i]) && ans[i]>max){\\n            max=ans[i];\\n        }\\n    }\\n        if(max!=0){\\n            return  max;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(int a){\\n        if(a==1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=a;i++){\\n            if(a%i==0){\\n                return false;\\n               // break;\\n            }\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int max=0;\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i][i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i][nums.size()-i-1]);\\n        }\\n    for(int i=0;i<ans.size();i++){\\n        if(prime(ans[i]) && ans[i]>max){\\n            max=ans[i];\\n        }\\n    }\\n        if(max!=0){\\n            return  max;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975490,
                "title": "easy-with-approach-and-dry-run",
                "content": "\\n\\n# Approach\\n**Helper Function prime:**\\n - This function checks whether a given number is prime or not. It uses a simple approach by iterating from 1 up to the square root of the number and checking if the number is divisible by any of those values. If it\\'s divisible by exactly two values (1 and itself), then it\\'s a prime number. The function returns True if the number is prime, otherwise False.\\n\\n**Main Function:**\\n\\n- n is the size of the input matrix nums.\\nleft_diag and right_diag are two lists containing the elements of the left and right diagonals of the matrix, respectively.\\nd_elements is a set that contains all the distinct diagonal elements. Since both the diagonals are of equal length in a square matrix, we can calculate the elements of both diagonals separately and merge them into this set.\\nans is used to store the largest prime element found among the diagonal elements.\\n\\n**Loop Over Diagonal Elements:**\\n\\n- The loop iterates over each element in the d_elements set.\\nFor each element, the prime function is called to check if it\\'s a prime number. If it is, then we update the ans variable to store the maximum of the current value of ans and the current diagonal element. This ensures that we keep track of the largest prime element found so far.\\n\\n**Return Result:**\\n\\n- After looping through all the diagonal elements, the value of ans will hold the largest prime among them.\\nThe function returns the value of ans as the result.\\n\\n**Example:**\\n- Let\\'s take the example matrix nums = [[1,2,3],[5,6,7],[9,10,11]].\\n\\n- The left diagonal elements are [1, 6, 11].\\nThe right diagonal elements are [3, 6, 9].\\nCombining both diagonals gives d_elements = {1, 3, 6, 9, 11}.\\nThe prime elements among these are 3 and 11.\\nThe function returns the maximum of these prime elements, which is 11.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        # helper fn\\n        def prime(num):\\n            s = set()\\n            for i in range(1, int(math.sqrt(num))+1):\\n                if num % i == 0:\\n                    s.add(i)\\n                    s.add(num//i)\\n            if len(s) == 2:\\n                return True\\n            return False\\n        # main fn\\n        n = len(nums)\\n        left_diag = [nums[i][i] for i in range(n) ]\\n        right_diag = [nums[i][n-1-i] for i in range(n)]\\n        d_elements = set(left_diag + right_diag)\\n        ans = 0\\n        for ele in d_elements:\\n            # using helper fn to find out whether the current \\n            # element is prime or not\\n            # if prime then maintain maximum\\n            if prime(ele):\\n                ans = max(ans, ele)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        # helper fn\\n        def prime(num):\\n            s = set()\\n            for i in range(1, int(math.sqrt(num))+1):\\n                if num % i == 0:\\n                    s.add(i)\\n                    s.add(num//i)\\n            if len(s) == 2:\\n                return True\\n            return False\\n        # main fn\\n        n = len(nums)\\n        left_diag = [nums[i][i] for i in range(n) ]\\n        right_diag = [nums[i][n-1-i] for i in range(n)]\\n        d_elements = set(left_diag + right_diag)\\n        ans = 0\\n        for ele in d_elements:\\n            # using helper fn to find out whether the current \\n            # element is prime or not\\n            # if prime then maintain maximum\\n            if prime(ele):\\n                ans = max(ans, ele)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973193,
                "title": "easy-c-solution-beginner-s-friendly-full-explanation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    bool isPrime(int num) {\\n    if (num <= 1)\\n        return false;\\n    \\n    for (int i = 2; i * i <= num; ++i) {\\n        if (num % i == 0)\\n            return false;\\n    }\\n    \\n    return true;\\n}\\npublic:\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        vector<int> ans;\\n        int row=nums.size();\\n        int col=nums[0].size();\\n\\n        //for primary diagonal elements..\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(i==j){\\n                    if(isPrime(nums[i][j])){ //check if number is prime,\\n                                        //if yes then add to the vector.\\n                        ans.push_back(nums[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        //for second diagonal element\\n        for(int i=0,j=col-1;i<row,j>=0;i++,j--){\\n            if(isPrime(nums[i][j])){\\n                ans.push_back(nums[i][j]);\\n            }\\n        }\\n        if(ans.size()==0) return 0;\\n\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool isPrime(int num) {\\n    if (num <= 1)\\n        return false;\\n    \\n    for (int i = 2; i * i <= num; ++i) {\\n        if (num % i == 0)\\n            return false;\\n    }\\n    \\n    return true;\\n}\\npublic:\\n    \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        vector<int> ans;\\n        int row=nums.size();\\n        int col=nums[0].size();\\n\\n        //for primary diagonal elements..\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(i==j){\\n                    if(isPrime(nums[i][j])){ //check if number is prime,\\n                                        //if yes then add to the vector.\\n                        ans.push_back(nums[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        //for second diagonal element\\n        for(int i=0,j=col-1;i<row,j>=0;i++,j--){\\n            if(isPrime(nums[i][j])){\\n                ans.push_back(nums[i][j]);\\n            }\\n        }\\n        if(ans.size()==0) return 0;\\n\\n        sort(ans.begin(),ans.end());\\n        reverse(ans.begin(),ans.end());\\n\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973028,
                "title": "java-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int num = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int dag1 = nums[i][i];\\n            int dag2 = nums[i][nums.length - i - 1];\\n            int val = Math.max(primeChecker(dag1),primeChecker(dag2));\\n            if (num<val){\\n                num=val;\\n            }\\n            \\n            \\n        }\\n        return num;\\n    }\\n    public int primeChecker(int num){\\n        if(num<=1){\\n            return 0;\\n        }\\n        for (int i = 2; i <=Math.sqrt(num); i++) {\\n            if (num%i==0){\\n                return 0;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int num = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int dag1 = nums[i][i];\\n            int dag2 = nums[i][nums.length - i - 1];\\n            int val = Math.max(primeChecker(dag1),primeChecker(dag2));\\n            if (num<val){\\n                num=val;\\n            }\\n            \\n            \\n        }\\n        return num;\\n    }\\n    public int primeChecker(int num){\\n        if(num<=1){\\n            return 0;\\n        }\\n        for (int i = 2; i <=Math.sqrt(num); i++) {\\n            if (num%i==0){\\n                return 0;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966235,
                "title": "no-tle-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    // bool isprime(long long int i){\\n    //     if(i<2) return false;\\n    //     for(int j=2 ;j<i/2;j++){\\n    //         if(i%j==0 ) return false;\\n    //     }\\n    //     return true;\\n    // }\\n    int isprime(int n) {\\n        if (n <= 1) return 0;\\n        if (n <= 3) return 1;\\n        if (n % 2 == 0 || n % 3 == 0) return 0;\\n        for (int i = 5; i * i <= n; i = i + 6) {\\n          if (n % i == 0 || n % (i + 2) == 0) {\\n            return 0;\\n          }\\n        } \\n        return 1;\\n    }\\n   \\n    int diagonalPrime(vector<vector<int>>& nums){\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(isprime(nums[i][i])  ) {\\n                ans= max(ans, nums[i][i]);\\n            } \\n            if(isprime(nums[i][n-i-1])  ) {\\n                ans= max(ans, nums[i][n-i-1]);              \\n            \\n            } \\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    // bool isprime(long long int i){\\n    //     if(i<2) return false;\\n    //     for(int j=2 ;j<i/2;j++){\\n    //         if(i%j==0 ) return false;\\n    //     }\\n    //     return true;\\n    // }\\n    int isprime(int n) {\\n        if (n <= 1) return 0;\\n        if (n <= 3) return 1;\\n        if (n % 2 == 0 || n % 3 == 0) return 0;\\n        for (int i = 5; i * i <= n; i = i + 6) {\\n          if (n % i == 0 || n % (i + 2) == 0) {\\n            return 0;\\n          }\\n        } \\n        return 1;\\n    }\\n   \\n    int diagonalPrime(vector<vector<int>>& nums){\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(isprime(nums[i][i])  ) {\\n                ans= max(ans, nums[i][i]);\\n            } \\n            if(isprime(nums[i][n-i-1])  ) {\\n                ans= max(ans, nums[i][n-i-1]);              \\n            \\n            } \\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963961,
                "title": "smallest-easiest-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        if(n==1)return false;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            if(isprime(nums[i][i])) mx = max(mx,nums[i][i]);\\n            if(isprime(nums[i][n-i-1])) mx = max(mx,nums[i][n-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int n){\\n        if(n==1)return false;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int mx = 0;\\n        for(int i=0;i<n;i++){\\n            if(isprime(nums[i][i])) mx = max(mx,nums[i][i]);\\n            if(isprime(nums[i][n-i-1])) mx = max(mx,nums[i][n-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962888,
                "title": "best-solution-c-in-o-sqrt-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool fn( int n )\\n  {    if(n==1) return false;\\n      for( int i = 2; i*i<=n; i++)\\n      {\\n          if(n%i==0)return false;\\n          \\n      }\\n      return true;\\n  }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n             int maxi = 0;\\n             int n = nums.size();\\n             for( int i = 0; i<n; i++)\\n             {\\n                 if(fn(nums[i][i]))maxi = max(maxi, nums[i][i]);\\n                 if(fn(nums[i][n-1-i]))maxi = max(maxi, nums[i][n-1-i]);\\n             }\\n             return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool fn( int n )\\n  {    if(n==1) return false;\\n      for( int i = 2; i*i<=n; i++)\\n      {\\n          if(n%i==0)return false;\\n          \\n      }\\n      return true;\\n  }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n             int maxi = 0;\\n             int n = nums.size();\\n             for( int i = 0; i<n; i++)\\n             {\\n                 if(fn(nums[i][i]))maxi = max(maxi, nums[i][i]);\\n                 if(fn(nums[i][n-1-i]))maxi = max(maxi, nums[i][n-1-i]);\\n             }\\n             return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955060,
                "title": "90-beats-with-o-n-time-complexity-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst thought was to iterate the array on diagonals only\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn code the array is first iterated on (0,0) to (last row,last coloumn) and then from (0,last coloumn) to (last row,0) and in between the function isPrime is called to check that given num is prime or not which has time complexity of O(sqrt(n)).\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isPrime(int num){\\n         if (num <= 1)\\n            return 0;\\n        if(num ==2 || num == 3){\\n            return 1;\\n        }\\n        if(num%2 ==0 || num%3 == 0){\\n            return 0;\\n        }\\n        for(int i=5;i<=Math.sqrt(num);i=i+6){\\n            if(num%i==0 || num%(i+2)==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int max=0;\\n        for(int i=0,j=0;i<nums.length;i++,j++){\\n            if(isPrime(nums[i][j])==1){\\n                if(nums[i][j]>max){\\n                    max = nums[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0,j=nums.length-1;j>=0;i++,j--){\\n            if(isPrime(nums[i][j])==1){\\n                if(nums[i][j]>max){\\n                    max = nums[i][j];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int isPrime(int num){\\n         if (num <= 1)\\n            return 0;\\n        if(num ==2 || num == 3){\\n            return 1;\\n        }\\n        if(num%2 ==0 || num%3 == 0){\\n            return 0;\\n        }\\n        for(int i=5;i<=Math.sqrt(num);i=i+6){\\n            if(num%i==0 || num%(i+2)==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int max=0;\\n        for(int i=0,j=0;i<nums.length;i++,j++){\\n            if(isPrime(nums[i][j])==1){\\n                if(nums[i][j]>max){\\n                    max = nums[i][j];\\n                }\\n            }\\n        }\\n        for(int i=0,j=nums.length-1;j>=0;i++,j--){\\n            if(isPrime(nums[i][j])==1){\\n                if(nums[i][j]>max){\\n                    max = nums[i][j];\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950244,
                "title": "prime-in-diagonal-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n\\tpublic int diagonalPrime(int[][] nums) {\\n\\t\\tint prime = 0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tfor(int j=0;j<nums[i].length;j++) {\\n\\t\\t\\t\\tif(i==j || i+j==nums.length-1) {\\n\\t\\t\\t\\t\\tint n = nums[i][j];\\n\\t\\t\\t\\t\\tif(isPrime(n)) {\\n\\t\\t\\t\\t\\t\\tprime = Math.max(prime, n);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn prime; \\n\\t}\\n\\tpublic boolean isPrime(int n) {\\n\\t\\tif(n<2) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int i=2;i<=Math.sqrt(n);i++) {\\n\\t\\t\\tif(n%i==0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution primeindiagonal = new Solution();\\n\\t\\tint[][] nums1 = {{1,2,3},{5,6,7},{9,10,11}};\\n\\t\\tint[][] nums2 = {{1,2,3},{5,17,7},{9,11,10}};\\n\\t\\tSystem.out.println(\"Prime In Diagonal : \" + primeindiagonal.diagonalPrime(nums1));\\n\\t\\tSystem.out.println(\"Prime In Diagonal : \" + primeindiagonal.diagonalPrime(nums2));\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n\\tpublic int diagonalPrime(int[][] nums) {\\n\\t\\tint prime = 0;\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tfor(int j=0;j<nums[i].length;j++) {\\n\\t\\t\\t\\tif(i==j || i+j==nums.length-1) {\\n\\t\\t\\t\\t\\tint n = nums[i][j];\\n\\t\\t\\t\\t\\tif(isPrime(n)) {\\n\\t\\t\\t\\t\\t\\tprime = Math.max(prime, n);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn prime; \\n\\t}\\n\\tpublic boolean isPrime(int n) {\\n\\t\\tif(n<2) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor(int i=2;i<=Math.sqrt(n);i++) {\\n\\t\\t\\tif(n%i==0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tpublic static void main(String[] args) {\\n\\t\\tSolution primeindiagonal = new Solution();\\n\\t\\tint[][] nums1 = {{1,2,3},{5,6,7},{9,10,11}};\\n\\t\\tint[][] nums2 = {{1,2,3},{5,17,7},{9,11,10}};\\n\\t\\tSystem.out.println(\"Prime In Diagonal : \" + primeindiagonal.diagonalPrime(nums1));\\n\\t\\tSystem.out.println(\"Prime In Diagonal : \" + primeindiagonal.diagonalPrime(nums2));\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939580,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isPrime(int n) {\\n    if (n <= 1) {\\n        return false;  // 0 and 1 are not prime numbers\\n    }\\n\\n    // Check from 2 to the square root of n\\n    for (int i = 2; i <= sqrt(n); i++) {\\n        if (n % i == 0) {\\n            return false;  // n is divisible by some number other than 1 and itself\\n        }\\n    }\\n\\n    return true;\\n}\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i==j or (i+j==n-1)) and isPrime(nums[i][j]))\\n                {\\n                    ma=max(ma,nums[i][j]);\\n                }\\n            }\\n        }\\n        if(ma==INT_MIN)\\n        return 0;\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isPrime(int n) {\\n    if (n <= 1) {\\n        return false;  // 0 and 1 are not prime numbers\\n    }\\n\\n    // Check from 2 to the square root of n\\n    for (int i = 2; i <= sqrt(n); i++) {\\n        if (n % i == 0) {\\n            return false;  // n is divisible by some number other than 1 and itself\\n        }\\n    }\\n\\n    return true;\\n}\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((i==j or (i+j==n-1)) and isPrime(nums[i][j]))\\n                {\\n                    ma=max(ma,nums[i][j]);\\n                }\\n            }\\n        }\\n        if(ma==INT_MIN)\\n        return 0;\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913318,
                "title": "java-solution-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrime(int n){\\n        int count = 0;\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i = 1;i*i <=n;i++){\\n            if(n % i == 0){\\n                count++;\\n            }\\n        }\\n        return (count == 1);\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(isPrime(nums[i][i])){\\n                res.add(nums[i][i]);\\n            }\\n            if(isPrime(nums[i][n - i - 1])){\\n                res.add(nums[i][n - i - 1]);\\n            }\\n        }\\n        Collections.sort(res);\\n        if (res.isEmpty()) {\\n            return 0; \\n        }\\n        return res.get(res.size() - 1);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrime(int n){\\n        int count = 0;\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i = 1;i*i <=n;i++){\\n            if(n % i == 0){\\n                count++;\\n            }\\n        }\\n        return (count == 1);\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int n = nums.length;\\n        for(int i = 0;i < n;i++){\\n            if(isPrime(nums[i][i])){\\n                res.add(nums[i][i]);\\n            }\\n            if(isPrime(nums[i][n - i - 1])){\\n                res.add(nums[i][n - i - 1]);\\n            }\\n        }\\n        Collections.sort(res);\\n        if (res.isEmpty()) {\\n            return 0; \\n        }\\n        return res.get(res.size() - 1);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910147,
                "title": "easy-solution-86ms-and-35mb",
                "content": "*****Italic*****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool prime(int n){\\n        if(n==1 || n==0)\\n            return 0;\\n        for(int i=2; i*i<=n; i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int diagonalPrime(vector<vector<int>>& a) {\\n        int r = 0,c=0;\\n        int m1 = 0;\\n        while(r<a.size()){\\n            if(m1<a[r][c] && prime(a[r][c])){\\n                m1 = a[r][c];\\n            }\\n            r++,c++;\\n        }\\n        c--;\\n        r=0;\\n        while(r<a.size()){\\n            if(m1<a[r][c] && prime(a[r][c])){\\n                m1 = a[r][c];\\n            }\\n            r++,c--;\\n        }\\n        return m1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(int n){\\n        if(n==1 || n==0)\\n            return 0;\\n        for(int i=2; i*i<=n; i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int diagonalPrime(vector<vector<int>>& a) {\\n        int r = 0,c=0;\\n        int m1 = 0;\\n        while(r<a.size()){\\n            if(m1<a[r][c] && prime(a[r][c])){\\n                m1 = a[r][c];\\n            }\\n            r++,c++;\\n        }\\n        c--;\\n        r=0;\\n        while(r<a.size()){\\n            if(m1<a[r][c] && prime(a[r][c])){\\n                m1 = a[r][c];\\n            }\\n            r++,c--;\\n        }\\n        return m1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899191,
                "title": "easy-solution-javascript-python-kotlin",
                "content": "# Code\\n```\\n\\n```\\n\\n```javascript []\\nvar diagonalPrime = function(nums) {\\n    const n = nums.length;\\n    let maxPrime = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        const num1 = nums[i][i];\\n        const num2 = nums[i][n - i - 1];\\n\\n        if (num1 > maxPrime && isPrime(num1)) maxPrime = num1;\\n        if (num2 > maxPrime && isPrime(num2)) maxPrime = num2;\\n    }\\n    \\n    return maxPrime;\\n};\\n\\nfunction isPrime(num) {\\n    if (num === 2 || num === 3) return true;\\n    if (num <= 1 || num % 2 === 0 || num % 3 === 0) return false;\\n\\n    let i = 5;\\n    while (i * i <= num) {\\n        if (num % i === 0 || num % (i + 2) === 0) return false;\\n        i += 6;\\n    }\\n\\n    return true;\\n}\\n```\\n```python []\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num: int) -> bool:\\n            if num == 2 or num == 3:\\n                return True\\n            if num <= 1 or num % 2 == 0 or num % 3 == 0:\\n                return False\\n\\n            for i in range(5, int(num ** 0.5) + 1, 6):\\n                if num % i == 0 or num % (i + 2) == 0:\\n                    return False\\n\\n            return True\\n            \\n        max_prime = 0\\n        n = len(nums)\\n\\n        for i in range(n):\\n            num1, num2 = nums[i][i], nums[i][n-i-1]\\n\\n            if num1 > max_prime and is_prime(num1):\\n                max_prime = num1\\n            if num2 > max_prime and is_prime(num2):\\n                max_prime = num2\\n\\n        return max_prime\\n```\\n\\n```kotlin []\\nclass Solution {\\n    fun diagonalPrime(nums: Array<IntArray>): Int {\\n        fun isPrime(num: Int): Boolean {\\n            if (num == 2 || num == 3) return true\\n            if (num <= 1 || num % 2 == 0 || num % 3 == 0) return false\\n\\n            var i = 5\\n            while (i * i <= num) {\\n                if (num % i == 0 || num % (i + 2) == 0) return false\\n                i += 6\\n            }\\n            return true\\n        }\\n\\n        var maxPrime = 0\\n        val n = nums.size\\n\\n        for (i in 0 until n) {\\n            val num1 = nums[i][i]\\n            val num2 = nums[i][n - i - 1]\\n\\n            if (num1 > maxPrime && isPrime(num1)) maxPrime = num1\\n            if (num2 > maxPrime && isPrime(num2)) maxPrime = num2\\n        }\\n\\n        return maxPrime\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```\\n\\n```\n```javascript []\\nvar diagonalPrime = function(nums) {\\n    const n = nums.length;\\n    let maxPrime = 0;\\n    \\n    for (let i = 0; i < n; i++) {\\n        const num1 = nums[i][i];\\n        const num2 = nums[i][n - i - 1];\\n\\n        if (num1 > maxPrime && isPrime(num1)) maxPrime = num1;\\n        if (num2 > maxPrime && isPrime(num2)) maxPrime = num2;\\n    }\\n    \\n    return maxPrime;\\n};\\n\\nfunction isPrime(num) {\\n    if (num === 2 || num === 3) return true;\\n    if (num <= 1 || num % 2 === 0 || num % 3 === 0) return false;\\n\\n    let i = 5;\\n    while (i * i <= num) {\\n        if (num % i === 0 || num % (i + 2) === 0) return false;\\n        i += 6;\\n    }\\n\\n    return true;\\n}\\n```\n```python []\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num: int) -> bool:\\n            if num == 2 or num == 3:\\n                return True\\n            if num <= 1 or num % 2 == 0 or num % 3 == 0:\\n                return False\\n\\n            for i in range(5, int(num ** 0.5) + 1, 6):\\n                if num % i == 0 or num % (i + 2) == 0:\\n                    return False\\n\\n            return True\\n            \\n        max_prime = 0\\n        n = len(nums)\\n\\n        for i in range(n):\\n            num1, num2 = nums[i][i], nums[i][n-i-1]\\n\\n            if num1 > max_prime and is_prime(num1):\\n                max_prime = num1\\n            if num2 > max_prime and is_prime(num2):\\n                max_prime = num2\\n\\n        return max_prime\\n```\n```kotlin []\\nclass Solution {\\n    fun diagonalPrime(nums: Array<IntArray>): Int {\\n        fun isPrime(num: Int): Boolean {\\n            if (num == 2 || num == 3) return true\\n            if (num <= 1 || num % 2 == 0 || num % 3 == 0) return false\\n\\n            var i = 5\\n            while (i * i <= num) {\\n                if (num % i == 0 || num % (i + 2) == 0) return false\\n                i += 6\\n            }\\n            return true\\n        }\\n\\n        var maxPrime = 0\\n        val n = nums.size\\n\\n        for (i in 0 until n) {\\n            val num1 = nums[i][i]\\n            val num2 = nums[i][n - i - 1]\\n\\n            if (num1 > maxPrime && isPrime(num1)) maxPrime = num1\\n            if (num2 > maxPrime && isPrime(num2)) maxPrime = num2\\n        }\\n\\n        return maxPrime\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896702,
                "title": "java-1ms-beats-90-56",
                "content": "# Intuition & Approach\\n- iterate both diagonals at the same time\\n- check for primality\\n- maintain a memo of past primality checks\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) due to memoization\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    Map<Integer, Boolean> memo = new HashMap<>();\\n\\n    public int diagonalPrime(int[][] nums) {\\n\\n        int n = nums.length;\\n        int greatestPrime = 0;  // what we\\'ll return\\n\\n        for (int i = 0; i < n; ++i) {\\n            // check NW-SE diagonal\\n            int curNum = nums[i][i];\\n            if (curNum >= greatestPrime) {\\n                if (isPrime(curNum)) {\\n                    greatestPrime = curNum;\\n                }\\n            }\\n\\n            // check SW-NE diagonal\\n            curNum = nums[i][n - i - 1];\\n            if (curNum >= greatestPrime) {\\n                if (isPrime(curNum)) {\\n                    greatestPrime = curNum;\\n                }\\n            }\\n        }\\n\\n        return greatestPrime;\\n    }\\n\\n    private boolean isPrime(int number) {\\n        if (memo.containsKey(number)) {\\n            return memo.get(number);\\n        }\\n\\n        boolean res = false;\\n\\n        if (number > 1) {  // only numbers 2 and above can be prime\\n            if (number <= 3) { // 2 and 3 are prime\\n                res = true;\\n            } else {\\n                if (number % 2 == 0 || number % 3 == 0) {  // multiples of 2 and 3 are not prime\\n                    res = false;\\n                } else {\\n                    res = true;\\n                    for (int i = 5; i * i <= number; i += 6) {\\n                        if (number % i == 0 || number % (i + 2) == 0) {\\n                            res = false; // number is divisible by some other number\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        memo.put(number, res);\\n        return res;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Integer, Boolean> memo = new HashMap<>();\\n\\n    public int diagonalPrime(int[][] nums) {\\n\\n        int n = nums.length;\\n        int greatestPrime = 0;  // what we\\'ll return\\n\\n        for (int i = 0; i < n; ++i) {\\n            // check NW-SE diagonal\\n            int curNum = nums[i][i];\\n            if (curNum >= greatestPrime) {\\n                if (isPrime(curNum)) {\\n                    greatestPrime = curNum;\\n                }\\n            }\\n\\n            // check SW-NE diagonal\\n            curNum = nums[i][n - i - 1];\\n            if (curNum >= greatestPrime) {\\n                if (isPrime(curNum)) {\\n                    greatestPrime = curNum;\\n                }\\n            }\\n        }\\n\\n        return greatestPrime;\\n    }\\n\\n    private boolean isPrime(int number) {\\n        if (memo.containsKey(number)) {\\n            return memo.get(number);\\n        }\\n\\n        boolean res = false;\\n\\n        if (number > 1) {  // only numbers 2 and above can be prime\\n            if (number <= 3) { // 2 and 3 are prime\\n                res = true;\\n            } else {\\n                if (number % 2 == 0 || number % 3 == 0) {  // multiples of 2 and 3 are not prime\\n                    res = false;\\n                } else {\\n                    res = true;\\n                    for (int i = 5; i * i <= number; i += 6) {\\n                        if (number % i == 0 || number % (i + 2) == 0) {\\n                            res = false; // number is divisible by some other number\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        memo.put(number, res);\\n        return res;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894977,
                "title": "c-easy-to-understand-intuitive-for-loop",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)return false;\\n        for (int i = 2; i*i <= n; i++){\\n            if (n % i == 0)return false;\\n        }\\n        return true;\\n    }   \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans=INT_MIN;\\n        //first diagonal\\n        for(int i=0,j=0;i<nums.size()&&j<nums[0].size();i++,j++){\\n            if(isPrime(nums[i][j]))ans=max(ans,nums[i][j]);\\n        }\\n        //second diagonal\\n        for(int i=0,j=nums[0].size()-1;i<nums.size()&&j>=0;i++,j--){\\n            if(i==j)continue;\\n            if(isPrime(nums[i][j]))ans=max(ans,nums[i][j]);\\n        }\\n        //if no prime number exist.\\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n)\\n    {\\n        if (n <= 1)return false;\\n        for (int i = 2; i*i <= n; i++){\\n            if (n % i == 0)return false;\\n        }\\n        return true;\\n    }   \\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans=INT_MIN;\\n        //first diagonal\\n        for(int i=0,j=0;i<nums.size()&&j<nums[0].size();i++,j++){\\n            if(isPrime(nums[i][j]))ans=max(ans,nums[i][j]);\\n        }\\n        //second diagonal\\n        for(int i=0,j=nums[0].size()-1;i<nums.size()&&j>=0;i++,j--){\\n            if(i==j)continue;\\n            if(isPrime(nums[i][j]))ans=max(ans,nums[i][j]);\\n        }\\n        //if no prime number exist.\\n        return ans==INT_MIN?0:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894350,
                "title": "simple-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int r=0;\\n        int col1=0;\\n        int col2=nums[0].length-1;\\n        int max=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int num1=nums[r][col1];\\n            int num2=nums[r][col2];\\n            \\n            if(isPrime(num1))\\n            max=Math.max(max,num1);\\n\\n            if(isPrime(num2))\\n            max=Math.max(max,num2);\\n\\n            r++;\\n            col1++;\\n            col2--;\\n\\n        }\\n        return max;\\n        \\n    }\\n\\n\\n    public static boolean isPrime(int n)\\n    {\\n       \\n       if(n<=1)\\n       return false;\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            return false;   \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int r=0;\\n        int col1=0;\\n        int col2=nums[0].length-1;\\n        int max=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int num1=nums[r][col1];\\n            int num2=nums[r][col2];\\n            \\n            if(isPrime(num1))\\n            max=Math.max(max,num1);\\n\\n            if(isPrime(num2))\\n            max=Math.max(max,num2);\\n\\n            r++;\\n            col1++;\\n            col2--;\\n\\n        }\\n        return max;\\n        \\n    }\\n\\n\\n    public static boolean isPrime(int n)\\n    {\\n       \\n       if(n<=1)\\n       return false;\\n        for(int i=2;i<=Math.sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            return false;   \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891199,
                "title": "java-store-all-diagonal-element-in-list-and-sort-in-descending-order",
                "content": "# Approach\\n\\nFirst take all the diagonal element in List and sort that list in descending order. In this Approach you don\\u2019t have to check a number is Prime or not for all diagonal element.\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++) {\\n            list.add(nums[i][i]);\\n            list.add(nums[nums.length-i-1][i]);\\n        }\\n        Collections.sort(list,Collections.reverseOrder());\\n        for(int i=0;i<list.size();i++) {\\n            if(prime(list.get(i)))\\n                return list.get(i);\\n        }\\n        return 0;\\n    }\\n    public boolean prime(int n) {\\n        if(n<2) {\\n            return false;\\n        }\\n        for(int i=2;i<=Math.sqrt(n);i++) {\\n            if(n%i==0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++) {\\n            list.add(nums[i][i]);\\n            list.add(nums[nums.length-i-1][i]);\\n        }\\n        Collections.sort(list,Collections.reverseOrder());\\n        for(int i=0;i<list.size();i++) {\\n            if(prime(list.get(i)))\\n                return list.get(i);\\n        }\\n        return 0;\\n    }\\n    public boolean prime(int n) {\\n        if(n<2) {\\n            return false;\\n        }\\n        for(int i=2;i<=Math.sqrt(n);i++) {\\n            if(n%i==0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890471,
                "title": "prime-in-diogonal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        lst=[]\\n        j=len(nums)-1\\n        for i in range(len(nums)):\\n            for k in [nums[i][i],nums[i][j]]:\\n                if k==2 or k==3:\\n                    lst.append(k)\\n                    continue\\n                elif k==1:\\n                    continue\\n                an=True\\n                for l in range(2,int(k**0.5)+1):\\n                    if k%l==0:\\n                        an=False\\n                        break\\n                if an:\\n                    lst.append(k)\\n            j-=1\\n        return 0 if len(lst)==0 else max(lst)    \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        lst=[]\\n        j=len(nums)-1\\n        for i in range(len(nums)):\\n            for k in [nums[i][i],nums[i][j]]:\\n                if k==2 or k==3:\\n                    lst.append(k)\\n                    continue\\n                elif k==1:\\n                    continue\\n                an=True\\n                for l in range(2,int(k**0.5)+1):\\n                    if k%l==0:\\n                        an=False\\n                        break\\n                if an:\\n                    lst.append(k)\\n            j-=1\\n        return 0 if len(lst)==0 else max(lst)    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887008,
                "title": "python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n\\n        n = len(nums)\\n        heap = []\\n\\n        for i in range(n):\\n            heapq.heappush(heap, -nums[i][i])\\n            heapq.heappush(heap, -nums[n-i-1][i])\\n\\n\\n        def is_prime(x):\\n            if x < 2: return False\\n            if x == 2: return True\\n            if x % 2 == 0: return False\\n            for i in range(3, int(x**0.5)+1, 2):\\n                if x % i == 0:\\n                    return False\\n\\n            return True\\n\\n\\n        while heap:\\n            x = heapq.heappop(heap) * -1\\n            if is_prime(x):\\n                return x\\n\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n\\n        n = len(nums)\\n        heap = []\\n\\n        for i in range(n):\\n            heapq.heappush(heap, -nums[i][i])\\n            heapq.heappush(heap, -nums[n-i-1][i])\\n\\n\\n        def is_prime(x):\\n            if x < 2: return False\\n            if x == 2: return True\\n            if x % 2 == 0: return False\\n            for i in range(3, int(x**0.5)+1, 2):\\n                if x % i == 0:\\n                    return False\\n\\n            return True\\n\\n\\n        while heap:\\n            x = heapq.heappop(heap) * -1\\n            if is_prime(x):\\n                return x\\n\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882764,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n==1){\\n            return false;\\n        }if(n==2){\\n            return true;\\n        }\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ma = 0;\\n        // cout<<nums.size()<<endl;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(isPrime(nums[i][i])){\\n                ma = max(ma,nums[i][i]);\\n                // cout<<i<<\" \"<<ma<<endl;\\n            }if(isPrime(nums[i][nums.size()-i-1])){\\n                ma = max(ma,nums[i][nums.size()-i-1]);\\n                // cout<<i<<\" \"<<nums.size()-i-1<<\" \"<<ma<<endl;            \\n            }\\n        }return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n==1){\\n            return false;\\n        }if(n==2){\\n            return true;\\n        }\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ma = 0;\\n        // cout<<nums.size()<<endl;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(isPrime(nums[i][i])){\\n                ma = max(ma,nums[i][i]);\\n                // cout<<i<<\" \"<<ma<<endl;\\n            }if(isPrime(nums[i][nums.size()-i-1])){\\n                ma = max(ma,nums[i][nums.size()-i-1]);\\n                // cout<<i<<\" \"<<nums.size()-i-1<<\" \"<<ma<<endl;            \\n            }\\n        }return ma;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3882282,
                "title": "python3-the-best-uzbekistan",
                "content": "# Intuition\\n![Screenshot from 2023-08-08 20-04-53.png](https://assets.leetcode.com/users/images/cc64846b-b7f3-439b-9497-42eb2e6b94a3_1691507144.620617.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        largest_prime = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if is_prime(nums[i][i]):\\n                largest_prime = max(largest_prime, nums[i][i])\\n            if is_prime(nums[i][n-i-1]):\\n                largest_prime = max(largest_prime, nums[i][n-i-1])\\n        return largest_prime\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(num):\\n            if num <= 1:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        largest_prime = 0\\n        n = len(nums)\\n        for i in range(n):\\n            if is_prime(nums[i][i]):\\n                largest_prime = max(largest_prime, nums[i][i])\\n            if is_prime(nums[i][n-i-1]):\\n                largest_prime = max(largest_prime, nums[i][n-i-1])\\n        return largest_prime\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880458,
                "title": "simple-rust-with-iterators-and-sieve-of-eratostheness-for-prime-checking",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {\\n        //Sieve of Eratostheness\\n        fn is_prime(n: i32) -> bool {\\n            if n <= 1 {\\n                return false;\\n            }\\n\\n            if n <= 3 {\\n                return true;\\n            }\\n\\n            if n % 2 == 0 || n % 3 == 0 {\\n                return false;\\n            }\\n\\n            let mut i = 5;\\n            while i * i <= n {\\n                if n % i == 0 || n % (i + 2) == 0 {\\n                    return false;\\n                }\\n                i += 6;\\n            }\\n\\n            true\\n        }\\n\\n        let n = nums[0].len();\\n        nums\\n            .iter()\\n            .enumerate()\\n            .map(|(row_index, row)| {\\n                row[row_index]\\n            })\\n            .chain(\\n                nums\\n                .iter()\\n                .enumerate()\\n                .map(|(row_index, row)| {\\n                    row[n - 1 - row_index]\\n                })\\n            )\\n            .filter(|&val| {\\n                is_prime(val)\\n            })\\n            .max()\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {\\n        //Sieve of Eratostheness\\n        fn is_prime(n: i32) -> bool {\\n            if n <= 1 {\\n                return false;\\n            }\\n\\n            if n <= 3 {\\n                return true;\\n            }\\n\\n            if n % 2 == 0 || n % 3 == 0 {\\n                return false;\\n            }\\n\\n            let mut i = 5;\\n            while i * i <= n {\\n                if n % i == 0 || n % (i + 2) == 0 {\\n                    return false;\\n                }\\n                i += 6;\\n            }\\n\\n            true\\n        }\\n\\n        let n = nums[0].len();\\n        nums\\n            .iter()\\n            .enumerate()\\n            .map(|(row_index, row)| {\\n                row[row_index]\\n            })\\n            .chain(\\n                nums\\n                .iter()\\n                .enumerate()\\n                .map(|(row_index, row)| {\\n                    row[n - 1 - row_index]\\n                })\\n            )\\n            .filter(|&val| {\\n                is_prime(val)\\n            })\\n            .max()\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872790,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        a=[]\\n        for i in range(0,len(nums)) :\\n            a.append(nums[i][i])\\n            a.append(nums[i][len(nums)-1-i])\\n        # print(a)\\n        b=[]\\n        for i in a :\\n            if i not in b :\\n                b.append(i)\\n        c=[]\\n        b.sort()\\n        b.reverse()\\n        # print(b)\\n        d=0\\n        for i in b :\\n            f=0\\n            for j in range(1,i+1) :\\n                if i%j==0 :\\n                    f+=1\\n            if f==2 :\\n                d=i\\n                break\\n        return d\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        a=[]\\n        for i in range(0,len(nums)) :\\n            a.append(nums[i][i])\\n            a.append(nums[i][len(nums)-1-i])\\n        # print(a)\\n        b=[]\\n        for i in a :\\n            if i not in b :\\n                b.append(i)\\n        c=[]\\n        b.sort()\\n        b.reverse()\\n        # print(b)\\n        d=0\\n        for i in b :\\n            f=0\\n            for j in range(1,i+1) :\\n                if i%j==0 :\\n                    f+=1\\n            if f==2 :\\n                d=i\\n                break\\n        return d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865999,
                "title": "prime-in-diagonal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<nums.length)\\n        {\\n            if(isPrime(nums[i][i]))\\n            max = Math.max(max,nums[i][i]);\\n            if(isPrime(nums[i][nums.length - i - 1]))\\n            max = Math.max(max,nums[i][nums.length - i - 1]);\\n            i++;\\n        }\\n        return max;\\n    }\\n    public boolean isPrime(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        if(n==2||n==3)\\n        return true;\\n        if(n%2==0||n%3==0)\\n        return false;\\n        for(int i=5;i*i<=n;i=i+6)\\n        {\\n            if(n%i==0||n%(i+2)==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int i=0;\\n        int j=nums.length-1;\\n        while(i<nums.length)\\n        {\\n            if(isPrime(nums[i][i]))\\n            max = Math.max(max,nums[i][i]);\\n            if(isPrime(nums[i][nums.length - i - 1]))\\n            max = Math.max(max,nums[i][nums.length - i - 1]);\\n            i++;\\n        }\\n        return max;\\n    }\\n    public boolean isPrime(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        if(n==2||n==3)\\n        return true;\\n        if(n%2==0||n%3==0)\\n        return false;\\n        for(int i=5;i*i<=n;i=i+6)\\n        {\\n            if(n%i==0||n%(i+2)==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865855,
                "title": "sorted-unique-diagonal-values-and-fast-helper-function",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/2f7a9c89-10d4-42d8-b520-27cfe825c03c_1691218785.0900705.png)\\n\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(n: int) -> bool:\\n            if n <= 1:\\n                return False\\n            if n <= 3:\\n                return True\\n            if n % 2 == 0 or n % 3 == 0:\\n                return False\\n            i = 5\\n            while i * i <= n:\\n                if n % i == 0 or n % (i + 2) == 0 :\\n                    return False\\n                i = i + 6\\n            return True \\n        \\n        diagonals = sorted(\\n            set((nums[i][i] for i in range(len(nums))))\\n            | set((nums[i][len(nums) - i - 1] for i in range(len(nums)))),\\n            reverse=True\\n        )\\n\\n        for n in diagonals:\\n            if is_prime(n):\\n                return n\\n        \\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(n: int) -> bool:\\n            if n <= 1:\\n                return False\\n            if n <= 3:\\n                return True\\n            if n % 2 == 0 or n % 3 == 0:\\n                return False\\n            i = 5\\n            while i * i <= n:\\n                if n % i == 0 or n % (i + 2) == 0 :\\n                    return False\\n                i = i + 6\\n            return True \\n        \\n        diagonals = sorted(\\n            set((nums[i][i] for i in range(len(nums))))\\n            | set((nums[i][len(nums) - i - 1] for i in range(len(nums)))),\\n            reverse=True\\n        )\\n\\n        for n in diagonals:\\n            if is_prime(n):\\n                return n\\n        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846977,
                "title": "98-faster-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPrime(int num) {\\n    if (num <= 1)\\n        return false;\\n\\n    if (num <= 3)\\n        return true;\\n\\n    if (num % 2 == 0 || num % 3 == 0)\\n        return false;\\n\\n    for (int i = 5; i * i <= num; i += 6) {\\n        if (num % i == 0 || num % (i + 2) == 0)\\n            return false;\\n    }\\n\\n    return true;\\n}\\n\\nint diagonalPrime(vector<vector<int>>& nums) {\\n    int r = nums.size();\\n    int c = nums[0].size();\\n    int largestPrime = 0;\\n\\n    for (int i = 0; i < r; i++) {\\n        if (isPrime(nums[i][i])) {\\n            largestPrime = max(largestPrime, nums[i][i]);\\n        }\\n\\n        int j = r - 1 - i;\\n        if (isPrime(nums[i][j])) {\\n            largestPrime = max(largestPrime, nums[i][j]);\\n        }\\n    }\\n\\n    return largestPrime;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPrime(int num) {\\n    if (num <= 1)\\n        return false;\\n\\n    if (num <= 3)\\n        return true;\\n\\n    if (num % 2 == 0 || num % 3 == 0)\\n        return false;\\n\\n    for (int i = 5; i * i <= num; i += 6) {\\n        if (num % i == 0 || num % (i + 2) == 0)\\n            return false;\\n    }\\n\\n    return true;\\n}\\n\\nint diagonalPrime(vector<vector<int>>& nums) {\\n    int r = nums.size();\\n    int c = nums[0].size();\\n    int largestPrime = 0;\\n\\n    for (int i = 0; i < r; i++) {\\n        if (isPrime(nums[i][i])) {\\n            largestPrime = max(largestPrime, nums[i][i]);\\n        }\\n\\n        int j = r - 1 - i;\\n        if (isPrime(nums[i][j])) {\\n            largestPrime = max(largestPrime, nums[i][j]);\\n        }\\n    }\\n\\n    return largestPrime;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845821,
                "title": "number-theory",
                "content": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n vector<int>h;vector<int>v;int x=0;vector<int>g;\\n     for(int i=0;i<nums.size();i++){\\n        h.push_back(nums[i][i]);   //taking inputs from diagonal\\n       }  \\n       int y = nums.size()-1; int r=0;\\n       while(y>=0){\\n          h.push_back(nums[r][y]);    //taking input in our vector from diagonal \\n          r++;\\n          y--; \\n       } \\n      for(int i=0;i<h.size();i++){   // elimenating the even number except 2;\\n        if(h[i]==2)g.push_back(h[i]);  \\n       if(h[i]>2 && h[i]%2!=0)g.push_back(h[i]);   \\n      }  \\n        if(g.size()==0)return 0; //if size of g is 0 return 0;\\n      for(int i=0;i<g.size();i++){\\n          int count =0;            // checking for prime \\n      for(int j=1;j<sqrt(g[i])+1;j=j+2){\\n           if(g[i]%j==0)count=count+1; \\n        \\n      }        // return x; \\n            if(count==1)v.push_back(g[i]);   // taking all prime in a diffrent vector\\n\\n         }\\nif(v.size()==0)return 0;\\nsort(v.begin(),v.end());//for finding the largest prime, one can use the max element algo too;\\nint a= v[v.size()-1];\\nreturn a;\\n     }\\n};   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n vector<int>h;vector<int>v;int x=0;vector<int>g;\\n     for(int i=0;i<nums.size();i++){\\n        h.push_back(nums[i][i]);   //taking inputs from diagonal\\n       }  \\n       int y = nums.size()-1; int r=0;\\n       while(y>=0){\\n          h.push_back(nums[r][y]);    //taking input in our vector from diagonal \\n          r++;\\n          y--; \\n       } \\n      for(int i=0;i<h.size();i++){   // elimenating the even number except 2;\\n        if(h[i]==2)g.push_back(h[i]);  \\n       if(h[i]>2 && h[i]%2!=0)g.push_back(h[i]);   \\n      }  \\n        if(g.size()==0)return 0; //if size of g is 0 return 0;\\n      for(int i=0;i<g.size();i++){\\n          int count =0;            // checking for prime \\n      for(int j=1;j<sqrt(g[i])+1;j=j+2){\\n           if(g[i]%j==0)count=count+1; \\n        \\n      }        // return x; \\n            if(count==1)v.push_back(g[i]);   // taking all prime in a diffrent vector\\n\\n         }\\nif(v.size()==0)return 0;\\nsort(v.begin(),v.end());//for finding the largest prime, one can use the max element algo too;\\nint a= v[v.size()-1];\\nreturn a;\\n     }\\n};   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843432,
                "title": "easy-solution-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int size=nums.size();\\n        int max=0;\\n        for(int i=0;i<size;i++){\\n            if (isPrime(nums[i][i]) && max<nums[i][i])\\n                max=nums[i][i];\\n            if (isPrime(nums[i][size- i - 1]) && max<nums[i][size- i - 1])\\n                max=nums[i][size- i - 1];\\n        }\\n        return max;\\n    }\\n\\n    int isPrime(int n){\\n        if (n<2)\\n            return 0;\\n        int i=2;\\n        while (i*i<=n){\\n            if (n%i==0)\\n                return 0;\\n            i=i+1;\\n        }\\n        return 1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int size=nums.size();\\n        int max=0;\\n        for(int i=0;i<size;i++){\\n            if (isPrime(nums[i][i]) && max<nums[i][i])\\n                max=nums[i][i];\\n            if (isPrime(nums[i][size- i - 1]) && max<nums[i][size- i - 1])\\n                max=nums[i][size- i - 1];\\n        }\\n        return max;\\n    }\\n\\n    int isPrime(int n){\\n        if (n<2)\\n            return 0;\\n        int i=2;\\n        while (i*i<=n){\\n            if (n%i==0)\\n                return 0;\\n            i=i+1;\\n        }\\n        return 1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841280,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(\\u221An)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrime(int n){\\n        if(n==1)\\n            return false;\\n        else{\\n            for(int i=2;i<=Math.sqrt(n);i++){\\n                if(n%i==0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int m = 0;\\n        for(int i=0;i<nums[0].length;i++){\\n            for(int j=0;j<nums[0].length;j++){\\n                if(i==j){\\n                    if(isPrime(nums[i][j])){\\n                        if(nums[i][j]>m)\\n                            m=nums[i][j];\\n                    }\\n                }\\n                if((i+j)==nums[0].length-1){\\n                    if(isPrime(nums[i][j])){\\n                        if(nums[i][j]>m)\\n                            m=nums[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrime(int n){\\n        if(n==1)\\n            return false;\\n        else{\\n            for(int i=2;i<=Math.sqrt(n);i++){\\n                if(n%i==0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int m = 0;\\n        for(int i=0;i<nums[0].length;i++){\\n            for(int j=0;j<nums[0].length;j++){\\n                if(i==j){\\n                    if(isPrime(nums[i][j])){\\n                        if(nums[i][j]>m)\\n                            m=nums[i][j];\\n                    }\\n                }\\n                if((i+j)==nums[0].length-1){\\n                    if(isPrime(nums[i][j])){\\n                        if(nums[i][j]>m)\\n                            m=nums[i][j];\\n                    }\\n                }\\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835526,
                "title": "fast-solution-code-only",
                "content": "# Intuition\\nWithout Math.Sqrt method solution works faster :)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DiagonalPrime(int[][] nums) {\\n        int n = nums.Length, ans = 0;\\n        for (int i=0; i<n; i++) {\\n            if ( IsPrime(nums[i][i]) )\\n                ans = Math.Max(ans, nums[i][i]);\\n            if ( IsPrime(nums[i][n-i-1]) )\\n                ans = Math.Max(ans, nums[i][n-i-1]);\\n        }\\n        return ans;\\n    }\\n\\n    public bool IsPrime(int n) {\\n        if (n==1) return false;\\n        for (int k=2; k*k<n+1; k++)\\n            if (n%k==0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DiagonalPrime(int[][] nums) {\\n        int n = nums.Length, ans = 0;\\n        for (int i=0; i<n; i++) {\\n            if ( IsPrime(nums[i][i]) )\\n                ans = Math.Max(ans, nums[i][i]);\\n            if ( IsPrime(nums[i][n-i-1]) )\\n                ans = Math.Max(ans, nums[i][n-i-1]);\\n        }\\n        return ans;\\n    }\\n\\n    public bool IsPrime(int n) {\\n        if (n==1) return false;\\n        for (int k=2; k*k<n+1; k++)\\n            if (n%k==0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834752,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int num=0,n=nums.length;\\n       for(int i=0;i<n;i++){\\n           if(check(nums[i][i]) && num<nums[i][i]){\\n               num=nums[i][i];\\n           }\\n           if(check(nums[n-1-i][i]) && num<nums[n-1-i][i]){\\n               num=nums[n-1-i][i];\\n           }\\n       }\\n       return num;\\n    }\\n    public boolean check(int n){\\n        if(n==1) return false;\\n        if(n==2) return true;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int num=0,n=nums.length;\\n       for(int i=0;i<n;i++){\\n           if(check(nums[i][i]) && num<nums[i][i]){\\n               num=nums[i][i];\\n           }\\n           if(check(nums[n-1-i][i]) && num<nums[n-1-i][i]){\\n               num=nums[n-1-i][i];\\n           }\\n       }\\n       return num;\\n    }\\n    public boolean check(int n){\\n        if(n==1) return false;\\n        if(n==2) return true;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834707,
                "title": "simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        diagonals=[]\\n        for i in range(len(nums[0])):\\n            diagonals.append(nums[i][i])\\n            diagonals.append(nums[i][len(nums)- i - 1])\\n        \\n        max=0\\n        \\n        for ele in diagonals:\\n            if self.isPrime(ele) and max<ele:\\n                max=ele\\n        return max\\n\\n    def isPrime(self,n:int) -> bool:\\n        if n<2:\\n            return False\\n        i=2\\n        while i*i<=n:\\n            if n%i==0:\\n                return False\\n            i=i+1\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        diagonals=[]\\n        for i in range(len(nums[0])):\\n            diagonals.append(nums[i][i])\\n            diagonals.append(nums[i][len(nums)- i - 1])\\n        \\n        max=0\\n        \\n        for ele in diagonals:\\n            if self.isPrime(ele) and max<ele:\\n                max=ele\\n        return max\\n\\n    def isPrime(self,n:int) -> bool:\\n        if n<2:\\n            return False\\n        i=2\\n        while i*i<=n:\\n            if n%i==0:\\n                return False\\n            i=i+1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830976,
                "title": "beats-100-single-for-loop-easy-solution",
                "content": "# Intuition\\nUsing a single for loop to iterate over the rows , we can grab the elements for both diagonals. Check if any of diagonal element is prime then push it into a new array.\\n\\nAfter the loop ends , find max number from the new Array and return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let diag = [];\\n    let nums_len = nums.length;\\n    for(let i=0; i<nums.length; i++){\\n        if(isPrime(nums[i][i])) diag.push(nums[i][i])\\n        if(isPrime(nums[i][nums_len-i-1])) diag.push(nums[i][nums_len-i-1])\\n    }\\n    var max = 0;\\n    for(let k=0; k<diag.length;k++){\\n        if(diag[k]>max) max=diag[k]\\n    }\\n    return max;\\n};\\n\\nconst isPrime = num => {\\n    for(let i = 2, s = Math.sqrt(num); i <= s; i++) {\\n        if(num % i === 0) return false;\\n    }\\n    return num > 1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let diag = [];\\n    let nums_len = nums.length;\\n    for(let i=0; i<nums.length; i++){\\n        if(isPrime(nums[i][i])) diag.push(nums[i][i])\\n        if(isPrime(nums[i][nums_len-i-1])) diag.push(nums[i][nums_len-i-1])\\n    }\\n    var max = 0;\\n    for(let k=0; k<diag.length;k++){\\n        if(diag[k]>max) max=diag[k]\\n    }\\n    return max;\\n};\\n\\nconst isPrime = num => {\\n    for(let i = 2, s = Math.sqrt(num); i <= s; i++) {\\n        if(num % i === 0) return false;\\n    }\\n    return num > 1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829381,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    static boolean isprime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        for (int i = 2; i <= Math.sqrt(n); i++)\\n            if (n % i == 0)\\n                return false;\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int len=nums.length-1;\\n        int i,max=0;\\n        for(i=0;i<=len;i++){\\n            if(nums[i][i]>max){\\n                if(isprime(nums[i][i]))\\n                    max=nums[i][i];\\n            }\\n            if(isprime(nums[i][len-i]) && nums[i][len-i]>max){\\n                if(isprime(nums[i][len-i]))\\n                    max=nums[i][len-i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static boolean isprime(int n)\\n    {\\n        if (n <= 1)\\n            return false;\\n        for (int i = 2; i <= Math.sqrt(n); i++)\\n            if (n % i == 0)\\n                return false;\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int len=nums.length-1;\\n        int i,max=0;\\n        for(i=0;i<=len;i++){\\n            if(nums[i][i]>max){\\n                if(isprime(nums[i][i]))\\n                    max=nums[i][i];\\n            }\\n            if(isprime(nums[i][len-i]) && nums[i][len-i]>max){\\n                if(isprime(nums[i][len-i]))\\n                    max=nums[i][len-i];\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826675,
                "title": "simple-python3-solution-using-helper-function",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def isPrime(number) -> bool:\\n            if number == 1:\\n                return False\\n            for i in range(2, int(number**0.5)+1):\\n                if number % i == 0:\\n                    return False\\n            return True\\n\\n        largest = 0\\n        for i in range(len(nums)):\\n            if isPrime(nums[i][i]):\\n                if nums[i][i] > largest:\\n                    largest = nums[i][i]\\n            \\n            if isPrime(nums[i][len(nums) - i - 1]):\\n                if nums[i][len(nums) - i - 1] > largest:\\n                    largest = nums[i][len(nums) - i - 1]\\n\\n        return largest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def isPrime(number) -> bool:\\n            if number == 1:\\n                return False\\n            for i in range(2, int(number**0.5)+1):\\n                if number % i == 0:\\n                    return False\\n            return True\\n\\n        largest = 0\\n        for i in range(len(nums)):\\n            if isPrime(nums[i][i]):\\n                if nums[i][i] > largest:\\n                    largest = nums[i][i]\\n            \\n            if isPrime(nums[i][len(nums) - i - 1]):\\n                if nums[i][len(nums) - i - 1] > largest:\\n                    largest = nums[i][len(nums) - i - 1]\\n\\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826657,
                "title": "python-linear-sieve-o-n-time-o-n-space",
                "content": "# Intuition\\nWe iterate diagonal elements and find the biggest prime.\\n\\n# Approach\\nWe calculate all prime nubmers in the range `[0; max(nums)]` using linear sieve in O(N) time.\\nThen we iterate all diagonal elements and check in O(N) time.\\n\\n# Complexity\\n\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        MAX = max(max(r) for r in nums) + 1\\n        prime = [True] * MAX\\n        prime[1] = False\\n        for i in range(2, MAX):\\n            if prime[i]:\\n                for j in range(2, MAX):\\n                    if i * j >= MAX:\\n                        break\\n                    prime[i * j] = False\\n        n, res = len(nums), 0\\n        for i in range(n):\\n            e = nums[i][i]\\n            if e > res and prime[e]:\\n                res = e\\n            e = nums[i][n - 1 - i]\\n            if e > res and prime[e]:\\n                res = e\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        MAX = max(max(r) for r in nums) + 1\\n        prime = [True] * MAX\\n        prime[1] = False\\n        for i in range(2, MAX):\\n            if prime[i]:\\n                for j in range(2, MAX):\\n                    if i * j >= MAX:\\n                        break\\n                    prime[i * j] = False\\n        n, res = len(nums), 0\\n        for i in range(n):\\n            e = nums[i][i]\\n            if e > res and prime[e]:\\n                res = e\\n            e = nums[i][n - 1 - i]\\n            if e > res and prime[e]:\\n                res = e\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825757,
                "title": "one-of-the-best-approach-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst diagonal is include elements at index (0,0),(1,1),(2,2)....\\nsecond diagonal can be easily find by reverse all the rows then it is same as first digonal....\\nthen check the number that it is prime or not..\\nelse you can see the code ..  \\n\\nIt Beats 100% in Time \\nThank You\\n**********Please Upvote**********\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def diagonalPrime(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def isprime(num):\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num**0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        diag = []\\n        for i in range(len(nums)):\\n            if isprime(nums[i][i]):\\n                diag.append(nums[i][i])\\n            p = nums[i]\\n            p.reverse()\\n            nums[i] = p\\n\\n        for i in range(len(nums)):\\n            if isprime(nums[i][i]):\\n                diag.append(nums[i][i])\\n\\n        if not diag:\\n            return 0 \\n        return max(diag)\\n\\n```\\n\\n**PLEASE UPVOTE IF YOU LIKE THE APPROACH....**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def diagonalPrime(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def isprime(num):\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num**0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n\\n        diag = []\\n        for i in range(len(nums)):\\n            if isprime(nums[i][i]):\\n                diag.append(nums[i][i])\\n            p = nums[i]\\n            p.reverse()\\n            nums[i] = p\\n\\n        for i in range(len(nums)):\\n            if isprime(nums[i][i]):\\n                diag.append(nums[i][i])\\n\\n        if not diag:\\n            return 0 \\n        return max(diag)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812350,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool prm(int n){\\n        if(n<=1){\\n            return false;\\n        }\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>&n){\\n        vector<int>v;\\n        for(int i=0; i<n.size(); i++){\\n            for(int j=0; j<n[i].size(); j++){\\n                if(i==j || j==n.size()-i-1){\\n                    if(prm(n[i][j])){\\n                        v.push_back(n[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        if(v.size()==0){\\n            return 0;\\n        }\\n        sort(v.begin(),v.end(),greater<>());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prm(int n){\\n        if(n<=1){\\n            return false;\\n        }\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>&n){\\n        vector<int>v;\\n        for(int i=0; i<n.size(); i++){\\n            for(int j=0; j<n[i].size(); j++){\\n                if(i==j || j==n.size()-i-1){\\n                    if(prm(n[i][j])){\\n                        v.push_back(n[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        if(v.size()==0){\\n            return 0;\\n        }\\n        sort(v.begin(),v.end(),greater<>());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805993,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun diagonalPrime(nums: Array<IntArray>): Int {\\n        var row = 0\\n        var maxPrime = 0\\n\\n        while (row < nums.size) {\\n            val num1 = nums[row][row]\\n            val num2 = nums[row][nums.size-1-row]\\n\\n            if (num1 > maxPrime && isPrime(num1))\\n                maxPrime = Math.max(maxPrime, num1)\\n\\n            if (num2 > maxPrime && isPrime(num2))\\n                maxPrime = Math.max(maxPrime, num2)\\n\\n            row++\\n        }\\n\\n        return maxPrime\\n    }\\n\\n    private fun isPrime(n: Int): Boolean {\\n        if (n == 2) return true\\n        if (n < 2 || n % 2 == 0) return false\\n\\n        val limit = Math.sqrt(n.toDouble()).toInt()\\n        var divisor = 3\\n\\n        while (divisor <= limit) {\\n            if (n % divisor == 0)\\n                return false\\n            divisor += 2\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun diagonalPrime(nums: Array<IntArray>): Int {\\n        var row = 0\\n        var maxPrime = 0\\n\\n        while (row < nums.size) {\\n            val num1 = nums[row][row]\\n            val num2 = nums[row][nums.size-1-row]\\n\\n            if (num1 > maxPrime && isPrime(num1))\\n                maxPrime = Math.max(maxPrime, num1)\\n\\n            if (num2 > maxPrime && isPrime(num2))\\n                maxPrime = Math.max(maxPrime, num2)\\n\\n            row++\\n        }\\n\\n        return maxPrime\\n    }\\n\\n    private fun isPrime(n: Int): Boolean {\\n        if (n == 2) return true\\n        if (n < 2 || n % 2 == 0) return false\\n\\n        val limit = Math.sqrt(n.toDouble()).toInt()\\n        var divisor = 3\\n\\n        while (divisor <= limit) {\\n            if (n % divisor == 0)\\n                return false\\n            divisor += 2\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781726,
                "title": "check-if-diagonal-element-is-prime-and-take-the-biggest-prime-diagonal-element",
                "content": "# Intuition\\nStraightforward. We want to loop through the diagonal elements of the table, i.e. nums[i][len(nums) - i - 1] and nums[i][i], and we want to check if each of these elements is prime or not. If it is a prime, we would like to take the maximum between it and the previous maximum prime.\\n\\n# Approach\\nI started coding my intuition normally. As soon as I got my first TLE, I knew I should loop to the square of the number instead of the half of the number, and then I treated the small trivial cases after making few wrong submissions.\\n\\n# Complexity\\n- Time complexity:\\nO(n*sqrt(n))\\n\\n- Space complexity:\\nO(n*sqrt(n))\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        prime = True\\n        if num == 1:\\n            return False\\n        if num == 2:\\n            return True\\n        if num % 2 == 0 or num % 3 == 0: \\n            prime = False\\n        for i in range(3, int(sqrt(num)+1)):\\n            if num%i == 0:\\n                prime = False\\n        return prime\\n\\n    def diagonalPrime(self, nums):\\n        result = 0\\n        for i in range(0, len(nums)):\\n            if self.isPrime(nums[i][i]):\\n                result = max(result, nums[i][i])\\n            if self.isPrime(nums[i][len(nums) - i - 1]):\\n                result = max(result, nums[i][len(nums) - i - 1])\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        prime = True\\n        if num == 1:\\n            return False\\n        if num == 2:\\n            return True\\n        if num % 2 == 0 or num % 3 == 0: \\n            prime = False\\n        for i in range(3, int(sqrt(num)+1)):\\n            if num%i == 0:\\n                prime = False\\n        return prime\\n\\n    def diagonalPrime(self, nums):\\n        result = 0\\n        for i in range(0, len(nums)):\\n            if self.isPrime(nums[i][i]):\\n                result = max(result, nums[i][i])\\n            if self.isPrime(nums[i][len(nums) - i - 1]):\\n                result = max(result, nums[i][len(nums) - i - 1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781069,
                "title": "javascript-best-method-beats-100-faster-beginner-s-friendly",
                "content": "```\\nconst diagonalPrime = function(nums) {\\n    function isPrime(num) {\\n      if (num < 2) return false;\\n      for (let i = 2; i <= (num**0.5); i++) if (num % i === 0) return false;\\n      return true;\\n    }\\n\\n  let n = nums.length, maxPrime = 0;\\n\\n  // Check the main diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][i]) && nums[i][i] > maxPrime) maxPrime = nums[i][i];\\n  }\\n\\n  // Check the secondary diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][n - 1 - i]) && nums[i][n - 1 - i] > maxPrime) maxPrime = nums[i][n - 1 - i];\\n  }\\n\\n  return maxPrime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nconst diagonalPrime = function(nums) {\\n    function isPrime(num) {\\n      if (num < 2) return false;\\n      for (let i = 2; i <= (num**0.5); i++) if (num % i === 0) return false;\\n      return true;\\n    }\\n\\n  let n = nums.length, maxPrime = 0;\\n\\n  // Check the main diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][i]) && nums[i][i] > maxPrime) maxPrime = nums[i][i];\\n  }\\n\\n  // Check the secondary diagonal\\n  for (let i = 0; i < n; i++) {\\n    if (isPrime(nums[i][n - 1 - i]) && nums[i][n - 1 - i] > maxPrime) maxPrime = nums[i][n - 1 - i];\\n  }\\n\\n  return maxPrime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3774120,
                "title": "100-0ms-easy-solution",
                "content": "# Approach\\n- Since every number is greater than 0 => initialize **max = 1**\\n- Check for Prime only if number is greater than max.\\n- else Time limit will exceed.\\n\\n# Complexity\\n- Time complexity: $$O(\\u2713n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.length;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>max && checkPrime(nums[i][i]))\\n                max = Math.max(max,nums[i][i]);\\n            if(nums[i][n-i-1]>max && checkPrime(nums[i][n-i-1]))\\n                max = Math.max(max,nums[i][n-i-1]);\\n        }\\n        return max;\\n    }\\n    private boolean checkPrime(int x){\\n        if(x<=1)\\n            return false;\\n        for(int i=2;i<=Math.sqrt(x);i++)\\n            if(x%i==0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.length;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>max && checkPrime(nums[i][i]))\\n                max = Math.max(max,nums[i][i]);\\n            if(nums[i][n-i-1]>max && checkPrime(nums[i][n-i-1]))\\n                max = Math.max(max,nums[i][n-i-1]);\\n        }\\n        return max;\\n    }\\n    private boolean checkPrime(int x){\\n        if(x<=1)\\n            return false;\\n        for(int i=2;i<=Math.sqrt(x);i++)\\n            if(x%i==0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770275,
                "title": "python3-beats-97-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave all diagonal numbers.\\nSort them.\\nStart checking from the end if number is prime.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2n)\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(number):\\n            if number <= 1:\\n                return False\\n            for i in range(2, int(number**0.5) + 1):\\n                if number % i == 0:\\n                    return False\\n            return True\\n\\n        arr = []\\n        r = len(nums)-1\\n        for i in range(len(nums)):\\n            arr.append(nums[i][i])\\n            arr.append(nums[i][r-i])\\n        arr.sort()\\n        for i in range(len(arr)-1,-1,-1):\\n            if is_prime(arr[i]):\\n                return arr[i]\\n        return 0 \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def is_prime(number):\\n            if number <= 1:\\n                return False\\n            for i in range(2, int(number**0.5) + 1):\\n                if number % i == 0:\\n                    return False\\n            return True\\n\\n        arr = []\\n        r = len(nums)-1\\n        for i in range(len(nums)):\\n            arr.append(nums[i][i])\\n            arr.append(nums[i][r-i])\\n        arr.sort()\\n        for i in range(len(arr)-1,-1,-1):\\n            if is_prime(arr[i]):\\n                return arr[i]\\n        return 0 \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765061,
                "title": "simple-undertandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int largestPrime = -1;\\n\\n        // Check main diagonal values\\n        for (int i = 0; i < n; i++) {\\n            if (isPrime(nums[i][i]) && nums[i][i] > largestPrime) {\\n                largestPrime = nums[i][i];\\n            }\\n        }\\n\\n        // Check anti-diagonal values\\n        for (int i = 0; i < n; i++) {\\n            if (isPrime(nums[n - 1 - i][i]) && nums[n - 1 - i][i] > largestPrime) {\\n                largestPrime = nums[n - 1 - i][i];\\n            }\\n        }\\n\\n        return largestPrime==-1? 0 : largestPrime;\\n    }\\n\\n    public static boolean isPrime(int number) {\\n        if (number <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(number); i++) {\\n            if (number % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int largestPrime = -1;\\n\\n        // Check main diagonal values\\n        for (int i = 0; i < n; i++) {\\n            if (isPrime(nums[i][i]) && nums[i][i] > largestPrime) {\\n                largestPrime = nums[i][i];\\n            }\\n        }\\n\\n        // Check anti-diagonal values\\n        for (int i = 0; i < n; i++) {\\n            if (isPrime(nums[n - 1 - i][i]) && nums[n - 1 - i][i] > largestPrime) {\\n                largestPrime = nums[n - 1 - i][i];\\n            }\\n        }\\n\\n        return largestPrime==-1? 0 : largestPrime;\\n    }\\n\\n    public static boolean isPrime(int number) {\\n        if (number <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(number); i++) {\\n            if (number % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758198,
                "title": "simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n + n * m**0.5)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        prime = []\\n        mx = 0\\n        m = len(nums)\\n        for i in range(m):\\n            prime.append(nums[i][i])\\n            prime.append(nums[i][m - 1 - i])\\n        for i in prime:\\n            c = 1\\n            if i == 1:\\n                continue\\n            for j in range(2,int(sqrt(i)) + 1):\\n                if i % j == 0 :\\n                    c = 0\\n                    continue\\n            if c:\\n                mx = max(mx,i)\\n        return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        prime = []\\n        mx = 0\\n        m = len(nums)\\n        for i in range(m):\\n            prime.append(nums[i][i])\\n            prime.append(nums[i][m - 1 - i])\\n        for i in prime:\\n            c = 1\\n            if i == 1:\\n                continue\\n            for j in range(2,int(sqrt(i)) + 1):\\n                if i % j == 0 :\\n                    c = 0\\n                    continue\\n            if c:\\n                mx = max(mx,i)\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757121,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    const n = nums.length - 1;\\n    let result = 0;\\n    function isPrime(num) {\\n        for(let i = 2; i <= Math.sqrt(num); i++) {\\n            if(num % i === 0) return false;\\n        }\\n        return num > 1;\\n    }\\n    for (let i = 0; i <= n; i++) {\\n        const v1 = nums[i][i];\\n        const v2 = nums[i][n - i];\\n        if (v1 > result && isPrime(v1)) result = v1;\\n        if (v2 > result && isPrime(v2)) result = v2;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    const n = nums.length - 1;\\n    let result = 0;\\n    function isPrime(num) {\\n        for(let i = 2; i <= Math.sqrt(num); i++) {\\n            if(num % i === 0) return false;\\n        }\\n        return num > 1;\\n    }\\n    for (let i = 0; i <= n; i++) {\\n        const v1 = nums[i][i];\\n        const v2 = nums[i][n - i];\\n        if (v1 > result && isPrime(v1)) result = v1;\\n        if (v2 > result && isPrime(v2)) result = v2;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749902,
                "title": "java-easy-solution-in-1-single-for-loop-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n=nums.length;\\n        int maxPrime=0; //let the max prime number be 0 as of now\\n        for(int i=0; i<nums.length;i++){\\n            if(isPrime(nums[i][i])){// left diagonal\\n                maxPrime=Math.max(maxPrime,nums[i][i]);\\n                //if the diagonal number is prime then replace it\\n            }\\n            if(isPrime(nums[i][n-i-1])){// right diagonal\\n                maxPrime=Math.max(maxPrime,nums[i][n-i-1]);\\n            }\\n        }\\n        if(maxPrime==1){\\n            // since 1 is not prime hence returning 0\\n            return 0;\\n        }\\n        return maxPrime;\\n    }\\n    // function to check wether number is prime or not\\n    public boolean isPrime(int n){\\n        for(int i=2;i<=Math.sqrt(n);i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n=nums.length;\\n        int maxPrime=0; //let the max prime number be 0 as of now\\n        for(int i=0; i<nums.length;i++){\\n            if(isPrime(nums[i][i])){// left diagonal\\n                maxPrime=Math.max(maxPrime,nums[i][i]);\\n                //if the diagonal number is prime then replace it\\n            }\\n            if(isPrime(nums[i][n-i-1])){// right diagonal\\n                maxPrime=Math.max(maxPrime,nums[i][n-i-1]);\\n            }\\n        }\\n        if(maxPrime==1){\\n            // since 1 is not prime hence returning 0\\n            return 0;\\n        }\\n        return maxPrime;\\n    }\\n    // function to check wether number is prime or not\\n    public boolean isPrime(int n){\\n        for(int i=2;i<=Math.sqrt(n);i++){\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748665,
                "title": "java-solution-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    boolean isPrime(int val) {\\n        if (val <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(val); i++) {\\n            if (val % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int leftMaxDia = 0, rightMaxDia = 0;\\n        for (int i = 0; i < n; i++) {\\n            // left Diagonal\\n            if (isPrime(nums[i][i])) {\\n                leftMaxDia = Math.max(leftMaxDia, nums[i][i]);\\n            }\\n            //Right Diagonal\\n            if (isPrime(nums[i][n - i - 1])) {\\n                rightMaxDia = Math.max(rightMaxDia, nums[i][n - i - 1]);\\n            }\\n        }\\n        int ans = Math.max(rightMaxDia, leftMaxDia);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    boolean isPrime(int val) {\\n        if (val <= 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(val); i++) {\\n            if (val % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int leftMaxDia = 0, rightMaxDia = 0;\\n        for (int i = 0; i < n; i++) {\\n            // left Diagonal\\n            if (isPrime(nums[i][i])) {\\n                leftMaxDia = Math.max(leftMaxDia, nums[i][i]);\\n            }\\n            //Right Diagonal\\n            if (isPrime(nums[i][n - i - 1])) {\\n                rightMaxDia = Math.max(rightMaxDia, nums[i][n - i - 1]);\\n            }\\n        }\\n        int ans = Math.max(rightMaxDia, leftMaxDia);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742541,
                "title": "the-best-solution-on-leetcode-yet-i-bet-on-it",
                "content": "# Intuition\\n![271-2719747_like-thumb-up-vote-thumb-up-icon-free.png](https://assets.leetcode.com/users/images/32a6e528-ac56-4089-bf92-206cfd458728_1688931432.1382048.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check_prime(int n) {\\n\\n  // 0 and 1 are not prime numbers\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        }\\n\\n        for (int i = 2; i*i<=n;i++) {\\n            if (n % i == 0) {\\n            return 0;\\n            break;\\n            }\\n        }\\n        return 1;\\n\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++){\\n            if(check_prime(nums[i][i])){\\n                ans=max(ans,nums[i][i]);\\n                \\n                \\n            }\\n            if(check_prime(nums[i][size-1-i])){\\n                ans=max(ans,nums[i][size-1-i]);\\n                \\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "MySQL"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check_prime(int n) {\\n\\n  // 0 and 1 are not prime numbers\\n        if (n == 0 || n == 1) {\\n            return 0;\\n        }\\n\\n        for (int i = 2; i*i<=n;i++) {\\n            if (n % i == 0) {\\n            return 0;\\n            break;\\n            }\\n        }\\n        return 1;\\n\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++){\\n            if(check_prime(nums[i][i])){\\n                ans=max(ans,nums[i][i]);\\n                \\n                \\n            }\\n            if(check_prime(nums[i][size-1-i])){\\n                ans=max(ans,nums[i][size-1-i]);\\n                \\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740960,
                "title": "very-efficient-complexity",
                "content": "# Complexity\\n- Time complexity:\\n-       O(N * sqrt(n))\\n- Space complexity:\\n-       O(1)\\n# Code\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        # Time O(N*N*(N/2)), Space O(1)\\n        ###############################\\n        max_num = 0\\n\\n        for i in range(len(nums)):\\n        #     for j in range(len(nums)):\\n        #         if i == j or i + j == len(nums[i]) - 1:\\n        #             if self.is_prime(nums[i][j]):\\n        #                 max_num = max(max_num, nums[i][j])\\n\\n        # Time O(N*(N/2)), Space O(1)\\n        ###############################\\n            # For Primary-diagonal\\n            if self.is_prime(nums[i][i]):\\n                max_num = max(max_num, nums[i][i])\\n            # For Secondary-Diagonal\\n            if self.is_prime(nums[i][len(nums) - i - 1]):\\n                max_num = max(max_num, nums[i][len(nums) - i - 1])\\n\\n        \\n        return max_num\\n    \\n    def is_prime(self, number):\\n        if number < 2:\\n            return False\\n        \\n        for k in range(2, int(number ** 0.5) + 1):\\n            if number % k == 0:\\n                return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        # Time O(N*N*(N/2)), Space O(1)\\n        ###############################\\n        max_num = 0\\n\\n        for i in range(len(nums)):\\n        #     for j in range(len(nums)):\\n        #         if i == j or i + j == len(nums[i]) - 1:\\n        #             if self.is_prime(nums[i][j]):\\n        #                 max_num = max(max_num, nums[i][j])\\n\\n        # Time O(N*(N/2)), Space O(1)\\n        ###############################\\n            # For Primary-diagonal\\n            if self.is_prime(nums[i][i]):\\n                max_num = max(max_num, nums[i][i])\\n            # For Secondary-Diagonal\\n            if self.is_prime(nums[i][len(nums) - i - 1]):\\n                max_num = max(max_num, nums[i][len(nums) - i - 1])\\n\\n        \\n        return max_num\\n    \\n    def is_prime(self, number):\\n        if number < 2:\\n            return False\\n        \\n        for k in range(2, int(number ** 0.5) + 1):\\n            if number % k == 0:\\n                return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740774,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int i = 0;\\n        int j = nums[0].length - 1;\\n        int lp = 0;\\n\\n        while (i < nums.length) {\\n            int n1 = nums[i][i];\\n\\n            if (n1 > lp && isPrime(n1)) {\\n                lp = n1;\\n            }\\n\\n            int n2 = nums[i][j];\\n\\n            if (n2 > lp && isPrime(n2)) {\\n                lp = n2;\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n\\n        return lp;\\n    }\\n\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n\\n        if (n == 2 || n == 3) {\\n            return true;\\n        }\\n\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int i = 0;\\n        int j = nums[0].length - 1;\\n        int lp = 0;\\n\\n        while (i < nums.length) {\\n            int n1 = nums[i][i];\\n\\n            if (n1 > lp && isPrime(n1)) {\\n                lp = n1;\\n            }\\n\\n            int n2 = nums[i][j];\\n\\n            if (n2 > lp && isPrime(n2)) {\\n                lp = n2;\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n\\n        return lp;\\n    }\\n\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n\\n        if (n == 2 || n == 3) {\\n            return true;\\n        }\\n\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740241,
                "title": "c-brute-force-easy-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n        \\n        bool Isprime(int n){\\n                if(n<=1)return false;\\n                 for (int i = 2; i * i <= n; i++){\\n                         if (n % i == 0)return false;\\n                 }\\n                 return true;\\n        }\\n    \\n        int diagonalPrime(vector<vector<int>>& mat) {\\n        \\n            \\n            int row = mat.size();\\n            int i=0;\\n            int ans = INT_MIN;\\n            while(i<=row-1){\\n                    if(Isprime(mat[i][i])){\\n                            ans = max(ans,mat[i][i]);\\n                    }\\n                    if(Isprime(mat[i][row-i-1])){\\n                            ans = max(ans,mat[i][row-i-1]);\\n                    }\\n                    i++;\\n            }\\n                return ans == INT_MIN?0:ans;\\n        }   \\n         \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n        \\n        bool Isprime(int n){\\n                if(n<=1)return false;\\n                 for (int i = 2; i * i <= n; i++){\\n                         if (n % i == 0)return false;\\n                 }\\n                 return true;\\n        }\\n    \\n        int diagonalPrime(vector<vector<int>>& mat) {\\n        \\n            \\n            int row = mat.size();\\n            int i=0;\\n            int ans = INT_MIN;\\n            while(i<=row-1){\\n                    if(Isprime(mat[i][i])){\\n                            ans = max(ans,mat[i][i]);\\n                    }\\n                    if(Isprime(mat[i][row-i-1])){\\n                            ans = max(ans,mat[i][row-i-1]);\\n                    }\\n                    i++;\\n            }\\n                return ans == INT_MIN?0:ans;\\n        }   \\n         \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738338,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result = INT_MIN;\\n\\n        int row = 0, col = nums.size() - 1;\\n\\n        while(row <= col) {\\n            if(nums[row][row] > result && isPrime(nums[row][row])) {\\n                result = nums[row][row];\\n            }\\n\\n            row++;\\n        }\\n\\n        row = 0;\\n        while(col >= 0) {\\n            if(nums[row][col] > result && isPrime(nums[row][col])) {\\n                result = nums[row][col];\\n            }\\n\\n            col--;\\n            row++;\\n        }\\n\\n        return result == INT_MIN ? 0 : result;\\n    }\\n\\nprivate:\\n    bool isPrime(int n) {\\n        if(n <= 1) return false;\\n\\n        for(int i = 2; i * i <= n; i++) {\\n            if(n % i == 0) return false;\\n        }\\n\\n        return true;\\n    }    \\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result = INT_MIN;\\n\\n        int row = 0, col = nums.size() - 1;\\n\\n        while(row <= col) {\\n            if(nums[row][row] > result && isPrime(nums[row][row])) {\\n                result = nums[row][row];\\n            }\\n\\n            row++;\\n        }\\n\\n        row = 0;\\n        while(col >= 0) {\\n            if(nums[row][col] > result && isPrime(nums[row][col])) {\\n                result = nums[row][col];\\n            }\\n\\n            col--;\\n            row++;\\n        }\\n\\n        return result == INT_MIN ? 0 : result;\\n    }\\n\\nprivate:\\n    bool isPrime(int n) {\\n        if(n <= 1) return false;\\n\\n        for(int i = 2; i * i <= n; i++) {\\n            if(n % i == 0) return false;\\n        }\\n\\n        return true;\\n    }    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736697,
                "title": "brute-force-java-solution-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int[] findDiagnoalElements(int[][] nums){\\n        int[] res = new int[nums.length*2];\\n        int sum = nums.length-1;\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums[i].length;j++){\\n                if(i+j==(sum) || i==j){\\n                    res[count++] = nums[i][j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public static boolean isPrimeNumber(int nums){\\n        if(nums<=1)\\n            return false;\\n        for(int i=2;i<=Math.sqrt(nums);i++)\\n            if(nums%i == 0)\\n                return false;\\n            \\n        return true;\\n    }\\n\\n    public static int findMaxPrime(int[] diagnoalElements){\\n        int max_prime = 0;\\n        for(int i=0;i<diagnoalElements.length;i++){\\n            boolean isPrime = isPrimeNumber(diagnoalElements[i]);\\n            if(isPrime)\\n                max_prime = Math.max(max_prime,diagnoalElements[i]);\\n        }\\n        return max_prime;\\n    }\\n\\n    public static int largestPrimeInDiagnoal(int[][] nums){\\n        int[] diagnoalElements = findDiagnoalElements(nums);\\n        return findMaxPrime(diagnoalElements);\\n    }\\n\\n    public int diagonalPrime(int[][] nums) {\\n        return largestPrimeInDiagnoal(nums);\\n    }\\n\\n}\\n\\n/*\\n1 2 3\\n5 6 7 \\n8 10 11\\n\\n00 01 02\\n10 11 12\\n20 21 22\\n\\n00 01 02 03\\n10 11 12 13\\n20 21 22 23\\n30 31 32 33\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int[] findDiagnoalElements(int[][] nums){\\n        int[] res = new int[nums.length*2];\\n        int sum = nums.length-1;\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums[i].length;j++){\\n                if(i+j==(sum) || i==j){\\n                    res[count++] = nums[i][j];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public static boolean isPrimeNumber(int nums){\\n        if(nums<=1)\\n            return false;\\n        for(int i=2;i<=Math.sqrt(nums);i++)\\n            if(nums%i == 0)\\n                return false;\\n            \\n        return true;\\n    }\\n\\n    public static int findMaxPrime(int[] diagnoalElements){\\n        int max_prime = 0;\\n        for(int i=0;i<diagnoalElements.length;i++){\\n            boolean isPrime = isPrimeNumber(diagnoalElements[i]);\\n            if(isPrime)\\n                max_prime = Math.max(max_prime,diagnoalElements[i]);\\n        }\\n        return max_prime;\\n    }\\n\\n    public static int largestPrimeInDiagnoal(int[][] nums){\\n        int[] diagnoalElements = findDiagnoalElements(nums);\\n        return findMaxPrime(diagnoalElements);\\n    }\\n\\n    public int diagonalPrime(int[][] nums) {\\n        return largestPrimeInDiagnoal(nums);\\n    }\\n\\n}\\n\\n/*\\n1 2 3\\n5 6 7 \\n8 10 11\\n\\n00 01 02\\n10 11 12\\n20 21 22\\n\\n00 01 02 03\\n10 11 12 13\\n20 21 22 23\\n30 31 32 33\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736506,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * sqrt(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int i, j, ans=0;\\n        for (i = 0; i < nums.length; i++)\\n            if(isPrime(nums[i][i]))\\n                ans= nums[i][i] > ans ? nums[i][i] : ans;\\n\\n        for (i=0, j = nums.length - 1; i < nums.length; i++, j--)\\n            if(isPrime(nums[i][j]))\\n                ans = nums[i][j] > ans ? nums[i][j] : ans;\\n        return ans;\\n    }\\n    private boolean isPrime(int num)\\n    {\\n        if(num < 2) return false;\\n        int max=(int)Math.sqrt(num);\\n        for (int i= 2; i <= max; i++)\\n            if(num % i == 0 )\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int i, j, ans=0;\\n        for (i = 0; i < nums.length; i++)\\n            if(isPrime(nums[i][i]))\\n                ans= nums[i][i] > ans ? nums[i][i] : ans;\\n\\n        for (i=0, j = nums.length - 1; i < nums.length; i++, j--)\\n            if(isPrime(nums[i][j]))\\n                ans = nums[i][j] > ans ? nums[i][j] : ans;\\n        return ans;\\n    }\\n    private boolean isPrime(int num)\\n    {\\n        if(num < 2) return false;\\n        int max=(int)Math.sqrt(num);\\n        for (int i= 2; i <= max; i++)\\n            if(num % i == 0 )\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734385,
                "title": "simple-cek-prime-c",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int isPrime(int n) {\\n        if(n <= 2 || n % 2 == 0)\\n            return n == 2 ? n : 0;\\n        for(int i = 3; i * i <= n; i += 2)\\n            if(n % i == 0) return 0;\\n        return n;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int res = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) \\n            res = max({isPrime(nums[i][i]), isPrime(nums[i][n - 1 - i]), res});\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrime(int n) {\\n        if(n <= 2 || n % 2 == 0)\\n            return n == 2 ? n : 0;\\n        for(int i = 3; i * i <= n; i += 2)\\n            if(n % i == 0) return 0;\\n        return n;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int res = 0, n = nums.size();\\n        for(int i = 0; i < n; i++) \\n            res = max({isPrime(nums[i][i]), isPrime(nums[i][n - 1 - i]), res});\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720832,
                "title": "simple-dart-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  int diagonalPrime(List<List<int>> nums) {\\n    int n = nums.length;\\n    int m = nums[0].length;\\n    int maxim = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n      if (checkPrime(nums[i][i])) {\\n        maxim = maxim < nums[i][i] ? nums[i][i] : maxim;\\n      }\\n\\n      if (checkPrime(nums[n - 1 - i][i])) {\\n        maxim = maxim < nums[n - 1 - i][i] ? nums[n - 1 - i][i] : maxim;\\n      }\\n    }\\n\\n    return maxim;\\n  }\\n\\n  bool checkPrime(int k) {\\n    int count = 0;\\n\\n    if (k == 1) {\\n      return false;\\n    }\\n\\n    for (int i = 1; i * i <= k; i++) {\\n      if (k % i == 0) {\\n        count += 2;\\n      }\\n    }\\n\\n    return count == 2;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int diagonalPrime(List<List<int>> nums) {\\n    int n = nums.length;\\n    int m = nums[0].length;\\n    int maxim = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n      if (checkPrime(nums[i][i])) {\\n        maxim = maxim < nums[i][i] ? nums[i][i] : maxim;\\n      }\\n\\n      if (checkPrime(nums[n - 1 - i][i])) {\\n        maxim = maxim < nums[n - 1 - i][i] ? nums[n - 1 - i][i] : maxim;\\n      }\\n    }\\n\\n    return maxim;\\n  }\\n\\n  bool checkPrime(int k) {\\n    int count = 0;\\n\\n    if (k == 1) {\\n      return false;\\n    }\\n\\n    for (int i = 1; i * i <= k; i++) {\\n      if (k % i == 0) {\\n        count += 2;\\n      }\\n    }\\n\\n    return count == 2;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718367,
                "title": "golang-simple-solution",
                "content": "```go\\nfunc diagonalPrime(nums [][]int) int {\\n\\tvalues := make(map[int]struct{}, len(nums)*2-1)\\n\\tfor i := range nums {\\n\\t\\tvalues[nums[i][i]] = struct{}{}\\n\\t\\tvalues[nums[len(nums)-1-i][i]] = struct{}{}\\n\\t}\\n\\tsorted := make([]int, 0, len(values))\\n\\tfor v := range values {\\n\\t\\tsorted = append(sorted, v)\\n\\t}\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(sorted)))\\n\\n\\tfor _, v := range sorted {\\n\\t\\tif isPrime(v) {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v % 2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i * i <= v; i += 2 {\\n\\t\\tif v % i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc diagonalPrime(nums [][]int) int {\\n\\tvalues := make(map[int]struct{}, len(nums)*2-1)\\n\\tfor i := range nums {\\n\\t\\tvalues[nums[i][i]] = struct{}{}\\n\\t\\tvalues[nums[len(nums)-1-i][i]] = struct{}{}\\n\\t}\\n\\tsorted := make([]int, 0, len(values))\\n\\tfor v := range values {\\n\\t\\tsorted = append(sorted, v)\\n\\t}\\n\\tsort.Sort(sort.Reverse(sort.IntSlice(sorted)))\\n\\n\\tfor _, v := range sorted {\\n\\t\\tif isPrime(v) {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc isPrime(v int) bool {\\n\\tswitch {\\n\\tcase v == 1:\\n\\t\\treturn false\\n\\tcase v <= 3:\\n\\t\\treturn true\\n\\tcase v % 2 == 0:\\n\\t\\treturn false\\n\\tdefault:\\n\\t}\\n\\tfor i := 3; i * i <= v; i += 2 {\\n\\t\\tif v % i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3713536,
                "title": "primes-in-diagonal-in-c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool isPrime(int num){\\n    if(num==1){\\n        return false;\\n    }\\n    if(num==2){\\n        return true;\\n    }\\n    for(int i=2;i<num/2;i++){\\n        if(num%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nint diagonalPrime(int** nums, int numsSize, int* numsColSize){\\n    int prime=0;\\n    for(int i=0;i<numsSize;i++){\\n        int sam=nums[i][i];\\n        if(sam>prime&&isPrime(sam)){\\n                prime=sam;\\n        }\\n    }\\n    for(int i=0;i<numsSize;i++){\\n        int sam=nums[i][numsSize-i-1];\\n        if(sam>prime&&isPrime(sam)){\\n            prime=sam;\\n        }\\n    }\\n    return prime;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isPrime(int num){\\n    if(num==1){\\n        return false;\\n    }\\n    if(num==2){\\n        return true;\\n    }\\n    for(int i=2;i<num/2;i++){\\n        if(num%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nint diagonalPrime(int** nums, int numsSize, int* numsColSize){\\n    int prime=0;\\n    for(int i=0;i<numsSize;i++){\\n        int sam=nums[i][i];\\n        if(sam>prime&&isPrime(sam)){\\n                prime=sam;\\n        }\\n    }\\n    for(int i=0;i<numsSize;i++){\\n        int sam=nums[i][numsSize-i-1];\\n        if(sam>prime&&isPrime(sam)){\\n            prime=sam;\\n        }\\n    }\\n    return prime;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3712258,
                "title": "javascript-very-fast-checker-for-prime-number",
                "content": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    prime = -Infinity;\\n\\n    for (let i=0; i<nums[0].length; i++) {\\n        p = nums[i][i]\\n\\n        if (isPrime(p)) {\\n            prime = Math.max(p,prime)\\n        }\\n\\n        p = nums[i][nums[0].length-1-i];\\n\\n        if (isPrime(p)) {\\n            prime = Math.max(p,prime) \\n        }\\n    }\\n\\n    return isFinite(prime) ? prime : 0;\\n};\\n\\nvar isPrime = function(n) {\\n    if (isNaN(n) || !isFinite(n) || n % 1 || n < 2) return false;\\n    if (n == leastFactor(n)) return true;\\n    return false;\\n}\\n\\nvar leastFactor = function(n) {\\n    if (isNaN(n) || !isFinite(n)) return NaN;\\n    if (n == 0) return 0;\\n    if (n % 1 || n * n < 2) return 1;\\n    if (n % 2 == 0) return 2;\\n    if (n % 3 == 0) return 3;\\n    if (n % 5 == 0) return 5;\\n    let m = Math.sqrt(n);\\n    for (let i = 7; i <= m; i += 30) {\\n        if (n % i == 0) return i;\\n        if (n % (i + 4) == 0) return i + 4;\\n        if (n % (i + 6) == 0) return i + 6;\\n        if (n % (i + 10) == 0) return i + 10;\\n        if (n % (i + 12) == 0) return i + 12;\\n        if (n % (i + 16) == 0) return i + 16;\\n        if (n % (i + 22) == 0) return i + 22;\\n        if (n % (i + 24) == 0) return i + 24;\\n    }\\n    return n;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    prime = -Infinity;\\n\\n    for (let i=0; i<nums[0].length; i++) {\\n        p = nums[i][i]\\n\\n        if (isPrime(p)) {\\n            prime = Math.max(p,prime)\\n        }\\n\\n        p = nums[i][nums[0].length-1-i];\\n\\n        if (isPrime(p)) {\\n            prime = Math.max(p,prime) \\n        }\\n    }\\n\\n    return isFinite(prime) ? prime : 0;\\n};\\n\\nvar isPrime = function(n) {\\n    if (isNaN(n) || !isFinite(n) || n % 1 || n < 2) return false;\\n    if (n == leastFactor(n)) return true;\\n    return false;\\n}\\n\\nvar leastFactor = function(n) {\\n    if (isNaN(n) || !isFinite(n)) return NaN;\\n    if (n == 0) return 0;\\n    if (n % 1 || n * n < 2) return 1;\\n    if (n % 2 == 0) return 2;\\n    if (n % 3 == 0) return 3;\\n    if (n % 5 == 0) return 5;\\n    let m = Math.sqrt(n);\\n    for (let i = 7; i <= m; i += 30) {\\n        if (n % i == 0) return i;\\n        if (n % (i + 4) == 0) return i + 4;\\n        if (n % (i + 6) == 0) return i + 6;\\n        if (n % (i + 10) == 0) return i + 10;\\n        if (n % (i + 12) == 0) return i + 12;\\n        if (n % (i + 16) == 0) return i + 16;\\n        if (n % (i + 22) == 0) return i + 22;\\n        if (n % (i + 24) == 0) return i + 24;\\n    }\\n    return n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702619,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n < 2) return false;\\n        for(int i=2;i*i<=n;i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n         int maxi=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            if(isPrime(nums[i][i])){\\n                maxi=max(maxi,nums[i][i]);\\n            }\\n        if(isPrime(nums[i][nums.size()-1-i])){\\n            maxi=max(nums[i][nums.size()-1-i],maxi);\\n        }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n){\\n        if(n < 2) return false;\\n        for(int i=2;i*i<=n;i++) {\\n            if(n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n         int maxi=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            if(isPrime(nums[i][i])){\\n                maxi=max(maxi,nums[i][i]);\\n            }\\n        if(isPrime(nums[i][nums.size()-1-i])){\\n            maxi=max(nums[i][nums.size()-1-i],maxi);\\n        }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700345,
                "title": "simple-c-solution-using-isprime-int-n-function",
                "content": "\\n\\n# Code\\n```\\nbool isprime(int n) \\n{ \\n    if (n <= 1) \\n        return false; \\n    for (int i = 2; i <=sqrt(n); i++) \\n        if (n % i == 0) \\n            return false; \\n\\n    return true; \\n} \\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int prime=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(isprime(nums[i][i]))\\n            {\\n                prime=max(prime,nums[i][i]);\\n            }\\n            if(isprime(nums[i][nums.size()-i-1]))\\n            {\\n                prime=max(prime,nums[i][nums.size()-i-1]);\\n            }\\n        }\\n        return prime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isprime(int n) \\n{ \\n    if (n <= 1) \\n        return false; \\n    for (int i = 2; i <=sqrt(n); i++) \\n        if (n % i == 0) \\n            return false; \\n\\n    return true; \\n} \\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int prime=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(isprime(nums[i][i]))\\n            {\\n                prime=max(prime,nums[i][i]);\\n            }\\n            if(isprime(nums[i][nums.size()-i-1]))\\n            {\\n                prime=max(prime,nums[i][nums.size()-i-1]);\\n            }\\n        }\\n        return prime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693849,
                "title": "decent-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(prime(nums[i][i]))\\n            {\\n                ans=Math.max(ans,nums[i][i]);\\n            }\\n           \\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n             if(prime(nums[i][nums.length-1-i]))\\n            {\\n                ans=Math.max(ans,nums[i][nums.length-1-i]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    public boolean prime(int n)\\n    {\\n        if(n<=1)\\n        {\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(prime(nums[i][i]))\\n            {\\n                ans=Math.max(ans,nums[i][i]);\\n            }\\n           \\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n             if(prime(nums[i][nums.length-1-i]))\\n            {\\n                ans=Math.max(ans,nums[i][nums.length-1-i]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    public boolean prime(int n)\\n    {\\n        if(n<=1)\\n        {\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693231,
                "title": "using-js-helper-function-runtime-85-ms-beats-81-76",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let maxPrime = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        if(isPrime(nums[i][i])){\\n            maxPrime = Math.max(maxPrime, nums[i][i]);\\n        }\\n        \\n        if(isPrime(nums[i][nums.length - 1 - i])){\\n            maxPrime = Math.max(maxPrime, nums[i][nums.length - 1 - i]);\\n        }\\n    }\\n    return maxPrime;\\n};\\n\\nfunction isPrime(num){\\n    if (num <= 1) {\\n        return false;\\n    }\\n    for (let i = 2; i * i <= num; i++) {\\n        if (num % i === 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar diagonalPrime = function(nums) {\\n    let maxPrime = 0;\\n    for(let i = 0; i < nums.length; i++){\\n        if(isPrime(nums[i][i])){\\n            maxPrime = Math.max(maxPrime, nums[i][i]);\\n        }\\n        \\n        if(isPrime(nums[i][nums.length - 1 - i])){\\n            maxPrime = Math.max(maxPrime, nums[i][nums.length - 1 - i]);\\n        }\\n    }\\n    return maxPrime;\\n};\\n\\nfunction isPrime(num){\\n    if (num <= 1) {\\n        return false;\\n    }\\n    for (let i = 2; i * i <= num; i++) {\\n        if (num % i === 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3692352,
                "title": "just-solution",
                "content": "\\n# Code\\n```\\nimpl Solution {\\n    fn is_prime(n: u32) -> bool {\\n    if n <= 1 {\\n        return false;\\n    }\\n    let limit = (n as f64).sqrt() as u32;\\n\\n    for i in 2..=limit {\\n        if n % i == 0 {\\n            return false;\\n        }\\n    }\\n\\n    true\\n    }\\n\\n    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {\\n        let mut primes: Vec<i32> = Vec::new();\\n        for i in 0..nums.len() {\\n\\n            if Solution::is_prime(nums[i][i] as u32) {\\n                primes.push(nums[i][i]);\\n            }\\n            if Solution::is_prime(nums[nums.len()-i-1][i] as u32) {\\n                primes.push(nums[nums.len()-i-1][i]);\\n            }\\n        }\\n\\n        println!(\"{:?}\", primes);\\n        return *primes.iter().max().unwrap_or(&0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    fn is_prime(n: u32) -> bool {\\n    if n <= 1 {\\n        return false;\\n    }\\n    let limit = (n as f64).sqrt() as u32;\\n\\n    for i in 2..=limit {\\n        if n % i == 0 {\\n            return false;\\n        }\\n    }\\n\\n    true\\n    }\\n\\n    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {\\n        let mut primes: Vec<i32> = Vec::new();\\n        for i in 0..nums.len() {\\n\\n            if Solution::is_prime(nums[i][i] as u32) {\\n                primes.push(nums[i][i]);\\n            }\\n            if Solution::is_prime(nums[nums.len()-i-1][i] as u32) {\\n                primes.push(nums[nums.len()-i-1][i]);\\n            }\\n        }\\n\\n        println!(\"{:?}\", primes);\\n        return *primes.iter().max().unwrap_or(&0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691939,
                "title": "java-solution-o-n-n-0-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n^0.5)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean prime(int n){\\n        for(int i = 2 ; i <= Math.sqrt(n) ; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        if(n == 1){\\n            return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        //diagonal 1\\n        for(int i = 0 ; i < n  ; i++){\\n            if(prime(nums[i][i])){\\n                ans = Math.max(ans , nums[i][i]);\\n            }\\n        }\\n\\n        //diagonal 2\\n        for(int i = 0 ; i < n ; i++){\\n            if(prime(nums[i][n - i - 1])){\\n                ans = Math.max(ans , nums[i][n - i - 1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean prime(int n){\\n        for(int i = 2 ; i <= Math.sqrt(n) ; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        if(n == 1){\\n            return false;\\n        }else{\\n            return true;\\n        }\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        //diagonal 1\\n        for(int i = 0 ; i < n  ; i++){\\n            if(prime(nums[i][i])){\\n                ans = Math.max(ans , nums[i][i]);\\n            }\\n        }\\n\\n        //diagonal 2\\n        for(int i = 0 ; i < n ; i++){\\n            if(prime(nums[i][n - i - 1])){\\n                ans = Math.max(ans , nums[i][n - i - 1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691722,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] a) {\\n        int n = a.length;\\n        int r[] = new int[n*2];\\n        int k=0;\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<a.length;j++){\\n            if(i==j){\\n                r[k] = a[i][j];\\n                k++;\\n            }\\n            if(i+j==a.length-1){\\n                r[k] = a[i][j];\\n                k++;\\n            }\\n        }\\n    }\\n        Arrays.sort(r);\\n\\n        \\n        System.out.println(Arrays.toString(r));\\n        for(int i=r.length-1;i>=0;i--){\\n            if(isPrime(r[i])){\\n                return r[i];\\n            }\\n        }\\n        return 0;\\n    }\\n    private boolean isPrime(int n){\\n        if(n==1){\\n            return false;\\n        }\\n        if(n==2){\\n            return true;\\n        }\\n        else{\\n            for(int i=2;i<n/2;i++){\\n                if(n%i == 0){\\n                    return false;\\n                    //break;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] a) {\\n        int n = a.length;\\n        int r[] = new int[n*2];\\n        int k=0;\\n        for(int i=0;i<a.length;i++){\\n            for(int j=0;j<a.length;j++){\\n            if(i==j){\\n                r[k] = a[i][j];\\n                k++;\\n            }\\n            if(i+j==a.length-1){\\n                r[k] = a[i][j];\\n                k++;\\n            }\\n        }\\n    }\\n        Arrays.sort(r);\\n\\n        \\n        System.out.println(Arrays.toString(r));\\n        for(int i=r.length-1;i>=0;i--){\\n            if(isPrime(r[i])){\\n                return r[i];\\n            }\\n        }\\n        return 0;\\n    }\\n    private boolean isPrime(int n){\\n        if(n==1){\\n            return false;\\n        }\\n        if(n==2){\\n            return true;\\n        }\\n        else{\\n            for(int i=2;i<n/2;i++){\\n                if(n%i == 0){\\n                    return false;\\n                    //break;\\n                }\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690208,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int c=0;\\n        int p=0,res=0,k;\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j || i+j==n-1)\\n                {\\n                    for(k=2;k*k<=nums[i][j];k++)\\n                    {\\n                        if((nums[i][j])%k==0)\\n                        {\\n                            p++;\\n                        }\\n                    }\\n                    if(p==0 && nums[i][j]>res && nums[i][j]>=2)\\n                    {\\n                        res=nums[i][j];\\n                    }\\n                    p=0;\\n                }\\n            }\\n        }\\n        return res;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int c=0;\\n        int p=0,res=0,k;\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j || i+j==n-1)\\n                {\\n                    for(k=2;k*k<=nums[i][j];k++)\\n                    {\\n                        if((nums[i][j])%k==0)\\n                        {\\n                            p++;\\n                        }\\n                    }\\n                    if(p==0 && nums[i][j]>res && nums[i][j]>=2)\\n                    {\\n                        res=nums[i][j];\\n                    }\\n                    p=0;\\n                }\\n            }\\n        }\\n        return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686048,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    if(n==1)\\n    return false;\\n   for(int i=2;i*i<=n;++i)\\n   {\\n       if(n%i==0) \\n       return false;\\n   }\\n   return true;\\n}\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v;\\n        for(int i=0;i<n;++i)\\n        {\\n            \\n                if( isPrime(nums[i][i]) and nums[i][i]>ans)\\n                ans=(nums[i][i]);\\n                if(isPrime(nums[i][n-i-1])and nums[i][n-i-1]>ans)\\n                ans=(nums[i][n-i-1]);\\n            \\n        }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    if(n==1)\\n    return false;\\n   for(int i=2;i*i<=n;++i)\\n   {\\n       if(n%i==0) \\n       return false;\\n   }\\n   return true;\\n}\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        vector<int>v;\\n        for(int i=0;i<n;++i)\\n        {\\n            \\n                if( isPrime(nums[i][i]) and nums[i][i]>ans)\\n                ans=(nums[i][i]);\\n                if(isPrime(nums[i][n-i-1])and nums[i][n-i-1]>ans)\\n                ans=(nums[i][n-i-1]);\\n            \\n        }\\n       return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679257,
                "title": "c-solution-in-o-nlogn-time-and-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isprime(int n)\\n    {\\n        if(n<2)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(isprime(nums[i][i]))\\n                ans=max(ans,nums[i][i]);\\n            if(isprime(nums[i][nums.size()-i-1]))\\n                ans=max(ans,nums[i][nums.size()-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHope you understand the solution.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isprime(int n)\\n    {\\n        if(n<2)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(isprime(nums[i][i]))\\n                ans=max(ans,nums[i][i]);\\n            if(isprime(nums[i][nums.size()-i-1]))\\n                ans=max(ans,nums[i][nums.size()-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662915,
                "title": "c-easy-and-readable-solution-faster-than-78-less-than-55",
                "content": "![image.png](https://assets.leetcode.com/users/images/78931eed-42eb-4dae-bc32-8f9f4a55f79c_1687286604.1868863.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int DiagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.Length;\\n        for (int i = 0, j = n - 1; i < n; i++, j--)\\n        {\\n            if (nums[i][i] > 1 && IsPrime(nums[i][i]))\\n                max = Math.Max(max, nums[i][i]);\\n            if (nums[i][j] > 1 && IsPrime(nums[i][j]))\\n                max = Math.Max(max, nums[i][j]);\\n        }\\n        return max;\\n    }\\n\\n    private bool IsPrime(int n)\\n    {\\n        for (int i = (int)Math.Sqrt(n); i > 1; i--)\\n            if (n % i == 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DiagonalPrime(int[][] nums) {\\n        int max = 0;\\n        int n = nums.Length;\\n        for (int i = 0, j = n - 1; i < n; i++, j--)\\n        {\\n            if (nums[i][i] > 1 && IsPrime(nums[i][i]))\\n                max = Math.Max(max, nums[i][i]);\\n            if (nums[i][j] > 1 && IsPrime(nums[i][j]))\\n                max = Math.Max(max, nums[i][j]);\\n        }\\n        return max;\\n    }\\n\\n    private bool IsPrime(int n)\\n    {\\n        for (int i = (int)Math.Sqrt(n); i > 1; i--)\\n            if (n % i == 0)\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656264,
                "title": "java-easiest-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        Set<Integer> a = new HashSet<>();\\n        for(int i=0 ;i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==j || (i+j+1) == n) a.add(nums[i][j]);\\n            }\\n        }\\n        int max = 0;\\n        for(int b : a){\\n            if(isPrime(b) && b>max) max = b;\\n        }\\n        return max;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n\\n        // Check if n is divisible by any number from 2 to the square root of n\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        Set<Integer> a = new HashSet<>();\\n        for(int i=0 ;i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i==j || (i+j+1) == n) a.add(nums[i][j]);\\n            }\\n        }\\n        int max = 0;\\n        for(int b : a){\\n            if(isPrime(b) && b>max) max = b;\\n        }\\n        return max;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n\\n        // Check if n is divisible by any number from 2 to the square root of n\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648749,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isprime(self, num:int) -> int:\\n        f=True\\n        if num < 2 :\\n            return False\\n        for i in range(2,(num//2)+1):\\n            if num % i == 0:\\n                f=False\\n                break\\n        return f\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        r=[]\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i == j :\\n                    r+=[nums[i][i]]\\n                elif i+j == len(nums)-1:\\n                    r+=[nums[i][j]]\\n        r.sort(reverse=True)\\n        for i in r:\\n            if self.isprime(i):\\n                return i\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Matrix",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def isprime(self, num:int) -> int:\\n        f=True\\n        if num < 2 :\\n            return False\\n        for i in range(2,(num//2)+1):\\n            if num % i == 0:\\n                f=False\\n                break\\n        return f\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        r=[]\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i == j :\\n                    r+=[nums[i][i]]\\n                elif i+j == len(nums)-1:\\n                    r+=[nums[i][j]]\\n        r.sort(reverse=True)\\n        for i in r:\\n            if self.isprime(i):\\n                return i\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647256,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int ans = 0;\\n        int n = nums[0].length;\\n        for(int i=0;i<n;i++){\\n           if(nums[i][i]>ans && check(nums[i][i])) {\\n               ans=nums[i][i];\\n           }\\n           if(nums[i][n-i-1]>ans && check(nums[i][n-i-1])){\\n               ans=nums[i][n-i-1];\\n           }\\n        }\\n        return ans;\\n    }\\n    public boolean check(int n){\\n        if(n==1) return false;\\n        for(int i=2;i<=Math.sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int ans = 0;\\n        int n = nums[0].length;\\n        for(int i=0;i<n;i++){\\n           if(nums[i][i]>ans && check(nums[i][i])) {\\n               ans=nums[i][i];\\n           }\\n           if(nums[i][n-i-1]>ans && check(nums[i][n-i-1])){\\n               ans=nums[i][n-i-1];\\n           }\\n        }\\n        return ans;\\n    }\\n    public boolean check(int n){\\n        if(n==1) return false;\\n        for(int i=2;i<=Math.sqrt(n);i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642197,
                "title": "ts-solution",
                "content": "# Code\\n```\\n\\n\\n\\nfunction diagonalPrime(nums: number[][]): number {\\n    let maxPrime = 0;\\n    const len = nums.length;\\n\\n    const isPrime = (num: number) => {\\n        if (num < 2) return;\\n        for(let i = 2; i * i <= num; i++) {\\n            if (num % i === 0) return;\\n        }\\n        maxPrime = Math.max(num, maxPrime)\\n    }\\n\\n    for(let i = 0; i < len; i++) {\\n        isPrime(nums[i][i]);\\n        isPrime(nums[i][len - i - 1]);\\n    }\\n\\n    return maxPrime;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n\\n\\n\\nfunction diagonalPrime(nums: number[][]): number {\\n    let maxPrime = 0;\\n    const len = nums.length;\\n\\n    const isPrime = (num: number) => {\\n        if (num < 2) return;\\n        for(let i = 2; i * i <= num; i++) {\\n            if (num % i === 0) return;\\n        }\\n        maxPrime = Math.max(num, maxPrime)\\n    }\\n\\n    for(let i = 0; i < len; i++) {\\n        isPrime(nums[i][i]);\\n        isPrime(nums[i][len - i - 1]);\\n    }\\n\\n    return maxPrime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638554,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) \\n    {\\n        int i=0; int j=0; long count=0;\\n        List<Integer> list=new ArrayList<>();\\n    while(count<nums.length)\\n    {\\n        if(prime(nums[i][j])){\\n        list.add(nums[i][j]);\\n        }\\n        i++;\\n        j++;\\n        count++;\\n    }\\n    i=0; j=nums.length-1; count=0;\\n    while(count<nums.length)\\n    {\\n        if(prime(nums[i][j])){\\n        list.add(nums[i][j]);\\n        }\\n        i++;\\n        j--;\\n        count++;\\n    }\\n\\n    Collections.sort(list);\\n    if(list.size()>=1){\\n        return list.get(list.size()-1);\\n    }\\n    return 0;\\n    }\\n    public boolean prime(int n){\\n        if(n==1)return false;\\n        for(int i=2; i*i<=n; i++){\\n            if((n%i)==0)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) \\n    {\\n        int i=0; int j=0; long count=0;\\n        List<Integer> list=new ArrayList<>();\\n    while(count<nums.length)\\n    {\\n        if(prime(nums[i][j])){\\n        list.add(nums[i][j]);\\n        }\\n        i++;\\n        j++;\\n        count++;\\n    }\\n    i=0; j=nums.length-1; count=0;\\n    while(count<nums.length)\\n    {\\n        if(prime(nums[i][j])){\\n        list.add(nums[i][j]);\\n        }\\n        i++;\\n        j--;\\n        count++;\\n    }\\n\\n    Collections.sort(list);\\n    if(list.size()>=1){\\n        return list.get(list.size()-1);\\n    }\\n    return 0;\\n    }\\n    public boolean prime(int n){\\n        if(n==1)return false;\\n        for(int i=2; i*i<=n; i++){\\n            if((n%i)==0)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637885,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a self-comprehensive easy to understand solution. Please upvote.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrime(int n)\\n    {\\n        if(n<=1){\\n            return false;\\n        }\\n        for(int i=2; i<=Math.sqrt(n); i++)\\n        {\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int len = nums.length;\\n        int max = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            if(isPrime(nums[i][i])==true && nums[i][i]>max)\\n            {\\n                max = nums[i][i];\\n            }\\n        }\\n        int ind = 0;\\n        for(int i=nums.length-1; i>=0; i--)\\n        {\\n            int number = nums[ind][i];\\n            if(isPrime(number)==true && number>max){\\n                max = number;\\n            }\\n            ind += 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrime(int n)\\n    {\\n        if(n<=1){\\n            return false;\\n        }\\n        for(int i=2; i<=Math.sqrt(n); i++)\\n        {\\n            if(n%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int len = nums.length;\\n        int max = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            if(isPrime(nums[i][i])==true && nums[i][i]>max)\\n            {\\n                max = nums[i][i];\\n            }\\n        }\\n        int ind = 0;\\n        for(int i=nums.length-1; i>=0; i--)\\n        {\\n            int number = nums[ind][i];\\n            if(isPrime(number)==true && number>max){\\n                max = number;\\n            }\\n            ind += 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635103,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        static bool sieve[4000000] = {};\\n        if (!sieve[0]) {\\n            sieve[0] = true;\\n            for (auto i = 2; i * i < 4000000; ++i)\\n                if (!sieve[i - 1])\\n                    for (auto j = i * i; j < 4000000; j += i)\\n                        sieve[j - 1] = true;\\n        }\\n        auto result = 0;\\n        const auto size = nums.size();\\n        for (auto i = 0; i < size; ++i)\\n            result = max({result,\\n                        !sieve[nums[i][i] - 1] * nums[i][i],\\n                        !sieve[nums[i][size - 1 - i] - 1] * nums[i][size - 1 - i]});\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        static bool sieve[4000000] = {};\\n        if (!sieve[0]) {\\n            sieve[0] = true;\\n            for (auto i = 2; i * i < 4000000; ++i)\\n                if (!sieve[i - 1])\\n                    for (auto j = i * i; j < 4000000; j += i)\\n                        sieve[j - 1] = true;\\n        }\\n        auto result = 0;\\n        const auto size = nums.size();\\n        for (auto i = 0; i < size; ++i)\\n            result = max({result,\\n                        !sieve[nums[i][i] - 1] * nums[i][i],\\n                        !sieve[nums[i][size - 1 - i] - 1] * nums[i][size - 1 - i]});\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625701,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code focuses on the diagonal elements of the 2D array and checks if they are prime. It iterates through the diagonal elements and checks each one individually. By utilizing the checkPrime function, it determines whether a number is prime or not. The maximum prime number found is returned as the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe diagonalPrime function iterates through the diagonal elements of the given 2D array nums. For each diagonal element, it checks if it is greater than or equal to 2. If so, it calls the checkPrime function to determine if the number is prime. If the number is prime and greater than the current maximum prime (mm), it updates the mm variable. Finally, it returns the maximum prime number found.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*sqrt(num))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkPrime(int num){\\n        for(int i=2;i<=Math.sqrt(num);i++){\\n            if(num%i==0) return false;\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int mm=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i][i]>=2){\\n                if(checkPrime(nums[i][i])){\\n                    if(nums[i][i]>mm) mm=nums[i][i];\\n                }\\n            }\\n            if(nums[i][nums.length-i-1]>=2){\\n                if(checkPrime(nums[i][nums.length-i-1])){\\n                    if(nums[i][nums.length-i-1]>mm) mm=nums[i][nums.length-i-1];\\n                }\\n            }\\n        }\\n        return mm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkPrime(int num){\\n        for(int i=2;i<=Math.sqrt(num);i++){\\n            if(num%i==0) return false;\\n        }\\n        return true;\\n    }\\n    public int diagonalPrime(int[][] nums) {\\n        int mm=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i][i]>=2){\\n                if(checkPrime(nums[i][i])){\\n                    if(nums[i][i]>mm) mm=nums[i][i];\\n                }\\n            }\\n            if(nums[i][nums.length-i-1]>=2){\\n                if(checkPrime(nums[i][nums.length-i-1])){\\n                    if(nums[i][nums.length-i-1]>mm) mm=nums[i][nums.length-i-1];\\n                }\\n            }\\n        }\\n        return mm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621325,
                "title": "easy-solution-c-check-prime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool isPrime(int n){\\n    if(n<=1)\\n        return false;\\n    if(n<=3)\\n        return true;\\n    if (n % 2 == 0 || n % 3 == 0)\\n        return false;\\n    for (int i = 5; i * i <= n; i = i + 6)\\n        if (n % i == 0 || n % (i + 2) == 0)\\n            return false;\\n\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int m = nums.size();\\n        int n = nums[0].size();\\n        int res =0;\\n        for(int i=0;i<m;i++){\\n            if(isPrime(nums[i][i])){\\n                res = max(res,nums[i][i]);\\n            }\\n        }\\n        int j=n-1;\\n        for(int i=0;i<m;i++){\\n            if(isPrime(nums[i][j])){\\n                res = max(res,nums[i][j]);\\n            }\\n            j--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isPrime(int n){\\n    if(n<=1)\\n        return false;\\n    if(n<=3)\\n        return true;\\n    if (n % 2 == 0 || n % 3 == 0)\\n        return false;\\n    for (int i = 5; i * i <= n; i = i + 6)\\n        if (n % i == 0 || n % (i + 2) == 0)\\n            return false;\\n\\n    return true;\\n}\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int m = nums.size();\\n        int n = nums[0].size();\\n        int res =0;\\n        for(int i=0;i<m;i++){\\n            if(isPrime(nums[i][i])){\\n                res = max(res,nums[i][i]);\\n            }\\n        }\\n        int j=n-1;\\n        for(int i=0;i<m;i++){\\n            if(isPrime(nums[i][j])){\\n                res = max(res,nums[i][j]);\\n            }\\n            j--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618892,
                "title": "beats-100-easiest-approach-must-vote",
                "content": "# Intuition\\n    Basic Prime Condition\\n# Approach\\n    run the loop for square root times\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n- Space complexity:\\n$$O(n^2)$$\\n# Code\\n```\\nint diagonalPrime(int** nums, int numsSize, int* numsColSize){\\n    int prime=0,flag,temp;\\n    for(int row=0;row<numsSize;row++){\\n        temp=nums[row][row];\\n        if(temp==1) continue;\\n        flag=1;\\n        for(int ind=2;ind<=sqrt(temp);ind++){\\n            if(temp%ind==0){\\n                flag=0;\\n            }\\n        }\\n        if(flag==1){\\n            if(temp>prime){\\n                prime=temp;\\n            }\\n        }\\n    }\\n    for(int row=0;row<numsSize;row++){\\n        temp=nums[row][numsSize-row-1];\\n        if(temp==1) continue;\\n        flag=1;\\n        for(int ind=2;ind<=sqrt(temp);ind++){\\n            if(temp%ind==0){\\n                flag=0;\\n            }\\n        }\\n        if(flag==1){\\n            if(temp>prime){\\n                prime=temp;\\n            }\\n        }\\n    }\\n    return prime;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nint diagonalPrime(int** nums, int numsSize, int* numsColSize){\\n    int prime=0,flag,temp;\\n    for(int row=0;row<numsSize;row++){\\n        temp=nums[row][row];\\n        if(temp==1) continue;\\n        flag=1;\\n        for(int ind=2;ind<=sqrt(temp);ind++){\\n            if(temp%ind==0){\\n                flag=0;\\n            }\\n        }\\n        if(flag==1){\\n            if(temp>prime){\\n                prime=temp;\\n            }\\n        }\\n    }\\n    for(int row=0;row<numsSize;row++){\\n        temp=nums[row][numsSize-row-1];\\n        if(temp==1) continue;\\n        flag=1;\\n        for(int ind=2;ind<=sqrt(temp);ind++){\\n            if(temp%ind==0){\\n                flag=0;\\n            }\\n        }\\n        if(flag==1){\\n            if(temp>prime){\\n                prime=temp;\\n            }\\n        }\\n    }\\n    return prime;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616202,
                "title": "very-easy-to-understand-c-sol",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n  bool isPrime(int n) {\\n    if (n <= 1) {\\n      return false;\\n    }\\n\\n    for (int i = 2; i * i <= n; i++) {\\n      if (n % i == 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int diagonalPrime(vector<vector<int>>& nums) {\\n    vector<int> primes;\\n    for (int i = 0; i < nums.size(); i++) {\\n      for (int j = 0; j < nums[i].size(); j++) {\\n        if (i == j || i == nums.size() - 1 - j) {\\n          if (isPrime(nums[i][j])) {\\n            primes.push_back(nums[i][j]);\\n          }\\n        }\\n      }\\n    }\\n\\n    if (primes.size() == 0) {\\n      return 0;\\n    }\\n\\n    sort(primes.begin(), primes.end());\\n    return primes[primes.size() - 1];\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isPrime(int n) {\\n    if (n <= 1) {\\n      return false;\\n    }\\n\\n    for (int i = 2; i * i <= n; i++) {\\n      if (n % i == 0) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int diagonalPrime(vector<vector<int>>& nums) {\\n    vector<int> primes;\\n    for (int i = 0; i < nums.size(); i++) {\\n      for (int j = 0; j < nums[i].size(); j++) {\\n        if (i == j || i == nums.size() - 1 - j) {\\n          if (isPrime(nums[i][j])) {\\n            primes.push_back(nums[i][j]);\\n          }\\n        }\\n      }\\n    }\\n\\n    if (primes.size() == 0) {\\n      return 0;\\n    }\\n\\n    sort(primes.begin(), primes.end());\\n    return primes[primes.size() - 1];\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1857917,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1963477,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1867169,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1858186,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 2058174,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1979462,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1944926,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1891504,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1858578,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1858547,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1857917,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1963477,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1867169,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1858186,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 2058174,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1979462,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1944926,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1891504,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1858578,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            },
            {
                "id": 1858547,
                "content": [
                    {
                        "username": "satyam47",
                        "content": "Avoid TLE \\nif `number `> `present_maximum_prime_number ` then only go for checking if `number ` is prime or not\\n\\nby this you will not have to check every number if it is prime or no \\nyou will only check for greater number than present maximum prime number  \\n"
                    },
                    {
                        "username": "hp01",
                        "content": "Thanks, it worked..."
                    },
                    {
                        "username": "yuvrajjohari052",
                        "content": "It is always give TLE in O(n) . so to handle that \\n\\nuse prime function with this more efficient way=\\n                 for (int i = 2  ;    i*i<=n   ;   i++){\\n                                       }.\\n\\n\\nplease upvote if you like\\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "i agree as you don\\'t need to call a function however the following code is more efficent as you dont need to check the even numbers (you could check the even numbers with a simple if in the begining ):\\n\\n   for (int i = 3; i <= i*i; i += 2) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }"
                    },
                    {
                        "username": "almostmonday",
                        "content": "Are you looking for something faster than Eratosthenes? It's a [square root of Eratosthenes](https://leetcode.com/problems/prime-in-diagonal/solutions/3428921/square-root-of-eratosthenes-beats-100-runtime/). If you like math, have a look at it (beats 100% runtime)."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem is mainly testing whether you can identify a prime number in $$O(sqrt(N))$$ time.\n\nIf you're doing it in $$O(N)$$ time, then you will most likely encounter TLE. (Unless you're doing it globally...)"
                    },
                    {
                        "username": "salahuddin975",
                        "content": "Python3 implementation,\\n```\\nclass Solution:\\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\\n        def check_prime(number):\\n            if number <= 1:\\n                return False \\n            if number <= 3:\\n                return True  \\n            if number % 2 == 0:\\n                return False \\n\\n            for divisor in range(3, int(math.sqrt(number)) + 1, 2):\\n                if number % divisor == 0:\\n                    return False\\n            return True\\n\\n        res = 0\\n        for i in range(len(nums)):\\n            diag = nums[i][i]\\n            anti = nums[i][len(nums) - i - 1]\\n\\n            if check_prime(diag):\\n                res = max(res, diag)\\n            if check_prime(anti):\\n                res = max(res, anti)\\n        return res\\n```"
                    },
                    {
                        "username": "sanatpawar23",
                        "content": "Very Weird Error\\n\\nclass Solution {\\npublic:\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int result=0;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i][i]>result){\\n                result = nums[i][i];\\n            }\\n\\n            if(nums[n-i][i]>result){\\n                result = nums[n-i][n-i];\\n            }\\n        }\\n        return result;\\n        \\n    }\\n};\\n\\ncan anyone tell me why is this code wrong\\n"
                    },
                    {
                        "username": "BlakeE",
                        "content": "Define n as nums.size() - 1;\\n\\nThe size is always one unit larger than the maximum index of an array"
                    },
                    {
                        "username": "rastogi31",
                        "content": "pls check my c++ code its giving runtime error->reference binding\\n `class Solution {\\npublic:\\nbool isPrime(int n)\\n{\\n    // Corner cases\\n    if (n <= 1)\\n        return false;\\n  \\n  // Suppose n=7 that is prime and its \\n  // pair are (1,7) so if a no. is prime \\n  // then it can be check by numbers smaller \\n  // than square root of the n\\n    for (int i = 2; i * i <= n; i++) \\n    {\\n        if (n % i == 0)\\n            return false;\\n    }\\n    return true;\\n}\\n\\n    int diagonalPrime(vector<vector<int>>& mat) {\\n        vector<int> arr;\\n        // first diagonal i==j ex 00 11 22\\n       \\n        int n=mat.size();\\n        for(int i=0;i<n;i++)\\n        { if(isPrime(mat[i][n-i-1]))\\n            arr.push_back(mat[i][n-i-1]);\\n\\n            if(isPrime(mat[i][i]))\\n            arr.push_back(mat[i][i]);\\n        }\\n      //  sort(arr.rbegin(),arr.rend());\\n        return arr[0];\\n        return *max_element(arr.begin(),arr.end());\\n\\n        \\n    }\\n};`"
                    },
                    {
                        "username": "Wajih_Ul_Hasan_0104",
                        "content": "class Solution(object):\\n    def diagonalPrime(self , nums):\\n        col = len(nums)\\n        primes = []\\n        temp = 1\\n        Max = -1\\n        \\n        for row in range(len(nums)):\\n            i = 1\\n            left_diagonal = nums[row][row]\\n            col = col - i\\n            right_diagonal = nums[row][col]\\n            primes.append(left_diagonal)\\n            primes.append(right_diagonal)\\n            i+=1\\n        \\n        for prime in primes:\\n            temp = (prime / 2)\\n            num = int(temp * temp)\\n            if num > 0 and num % 2 == 0:\\n                if Max < prime:\\n                    Max = prime\\n        return Max\\n\\nCan anyone tell me why I\\'m getting output 9 while running on leetcode , because when I run the same code on my local machine I get the right output.\\n\\nInput = [[1,2,3],[5,6,7],[9,10,11]]\\n\\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "santhukp19cp",
                        "content": "Sieve or segmented sieve (maybe overkill)"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "You need to use math tricks so you won\\'t get a TLE"
                    }
                ]
            }
        ]
    }
]