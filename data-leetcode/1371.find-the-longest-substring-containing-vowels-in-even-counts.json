[
    {
        "title": "Knight Dialer",
        "question_content": "The chess knight has a unique movement,&nbsp;it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\nA chess knight can move as indicated in the chess diagram below:\nWe have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell&nbsp;(i.e. blue cell).\nGiven an integer n, return how many distinct phone numbers of length n we can dial.\nYou are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\nAs the answer may be very large, return the answer modulo 109 + 7.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: 10\nExplanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\nExample 2:\n\nInput: n = 2\nOutput: 20\nExplanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n\nExample 3:\n\nInput: n = 3131\nOutput: 136006598\nExplanation: Please take care of the mod.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 5000",
        "solutions": [
            {
                "id": 190787,
                "title": "how-to-solve-this-problem-explained-for-noobs",
                "content": "We can think of this problem as the total number of unique paths the knight can travel making n hops because to dial distinct numbers, the path taken by the knight must be unique.\\n\\nIn this post I want to explain how I came up with a solution to this problem. This approach can be used to solve other similar problems such as Unique Paths, Minimum Path Sum etc.\\n\\nImagine an 8 x 8 chess board with Knight (k) sitting at some index `(i, j)`. The board would look as follows,\\n\\n```\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\n```\\n\\n\\n**[0]** If k is at index `(i, j)`, then in a single hop, k can move to 8 possible positions which are below. \\n\\n\\n```\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n```\\n\\n**[1]** Conversely, you can also say that in a single hop, there are 8 possible places (a,b,c,d,e,f,g,h) from which you can move to k.\\n\\n**Math behind the solution:**\\n\\nConsider a function paths(i, j, n) which calculates the total number of unique paths to reach index (i, j) for a given n, where n is the number of hops. From [0] or [1], we can recusively define paths(i, j, n) for all non-trivial (n > 1, that is, more than one hop) cases as follows,\\n\\n```\\npaths(i, j, n) = paths(i - 1, j - 2, n - 1) + \\n                 paths (i - 2, j - 1, n - 1) +\\n                 paths (i - 2, j + 1, n - 1) +\\n                 paths (i - 1, j + 2, n - 1) +\\n                 paths (i + 1, j + 2, n - 1) +\\n                 paths  (i + 2, j + 1, n - 1) +\\n                 paths (i + 2, j - 1, n - 1) +\\n                 paths (i + 1, j - 2, n - 1)\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nIf we translate this to plain english, all we are saying is \"the total number of unique paths to (i, j) for certain hops n is equal to the sum of total number of unique paths to each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nIf you are confused why it is n - 1 hops, note that when we are at (i, j), we already made one hop and we have n - 1 hops more to take.\\n\\nFor the trivial case (n = 1, that is no hops), the problem states that this must be considered as one path. Therefore, paths(i, j, n) = 1, for n = 1.\\n\\n**A Sample Trace**\\n\\nIf the above recursive equation or it\\'s translation is not very enlightening, you can follow this sample trace to get a better understanding of the logic.\\n\\nOur keypad is a 4 x 3 matrix which looks like below.\\n\\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\n```\\n\\nNote that in the code there is no need to use a matrix like this. This is just for explanation purpose.\\n\\nWe shall trace the recursion tree of paths(0, 0, 3) in this section, that is, all the possible unique paths from 1 (0, 0) in 3 hops. From 1 (0, 0), in a single hop, we have two possible places to jump to - 6 and 8.\\n\\nWait! Didn\\'t I say that a knight can jump to 8 possible places in a single hop some where in this post?\\n\\n*...\"in a single hop, k can move to 8 possible positions\"...*\\n\\nYes, a knight can jump to 8 possible places in a single hop and this is still true. However, 6 of the other hops will take you outside of the matrix. You will see later in the code how this is being handled as a part of base case.\\n\\n*A brief on notation*: \\n\\nI am representing each node in the recursion tree something like X (i, j, n). This means that we are at the call paths(0, 0, 3) and the knight is currently sitting on the number X with n - 1 hops remaining.\\n\\nBelow is the recursion tree for paths(0, 0, 3).\\n\\nNote: The following tree diagram is not visually appealing with the old UI. I recommend to view this in the new UI for a proper visual representation.\\n\\n                                  1 (0,0,3)\\n\\t\\t\\t\\t               /\\t\\t     \\\\\\n\\t\\t\\t\\t\\t          /               \\\\\\n\\t\\t\\t\\t  \\t  6 (1,2,2)             8 (2,1,2)\\t\\n\\t\\t\\t\\t   \\t/   |    \\\\                |   \\t\\\\\\n\\t\\t\\t\\t   /\\t|\\t  \\\\\\t\\t          |  \\t \\\\\\n\\t\\t1 (0,0,1)  0 (3,1,1)  7 (2,0,1)   1 (0,0,1)  3 (0,2,1)\\n\\n\\nSince, 6 jumps are invalid, that leaves us with only two valid jumps `e (i + 1, j + 2)` and  `f  (i + 2, j + 1)` from 1 (0, 0). In other words, from 1 the knight can jump only to 8 and 6. \\n\\nIn fact, in this matrix, the maximum number of valid jumps you can make is 3 which is from 4, 6.\\n\\nExplanation of this recursion tree is below,\\n\\nFrom 1 (0, 0, 3), the knight can go to 6 (1, 2, 2) and 8 (2, 1, 2) in a single hop. As we go down the recursion tree, we pass the number of hops to make as 1 less than the current.\\n\\nFrom 6 (1, 2, 2), it can go to 1 (0, 0, 1) , 0 (3, 1, 1) and 7 (2, 0, 1). We pass n as 1 as we are going down in the recursion. At this point, each of these calls return 1 (since n = 1 which is the trivial case). \\n\\nTherefore, **[2]** 6 (1, 2, 2) = 1 + 1 + 1 = 3, which means that there are 3 unique paths from 6 when n = 2 and they are 61, 60, 67.\\n\\nFrom 8 (2,1,2), it can go to 1 (0, 0, 1) and 3 (0, 2, 1). At this point, each of these calls return 1 (since n = 1).\\n\\nTherefore, **[3]** 8 (2, 1, 2) = 1 + 1 = 2, which means that there are 2 unique paths from 8 when n = 2 and they are 81, 83.\\n\\nFinally, 1 (0, 0, 3) = 6 (1, 2, 2) + 8 (2, 1, 2)\\n\\nFrom [2], [3], we can write this as,\\n\\n1 (0, 0, 3) = 3 + 2 = 5, which means that there are 5 unique paths from 1 when n = 3 and they are 161, 160, 167, 181, 183.\\n\\n**Naive Recursive Code**\\n```\\n\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   //trivial case\\n   if(n == 1) return 1;\\n   //non trivial case\\n   long s = paths(i - 1, j - 2, n - 1) % max + // jump to a\\n            paths(i - 2, j - 1, n - 1) % max + // jump to b\\n            paths(i - 2, j + 1, n - 1) % max + // jump to c\\n            paths(i - 1, j + 2, n - 1) % max + // jump to d\\n            paths(i + 1, j + 2, n - 1) % max + // jump to e\\n            paths(i + 2, j + 1, n - 1) % max + // jump to f\\n            paths(i + 2, j - 1, n - 1) % max + // jump to g\\n            paths(i + 1, j - 2, n - 1) % max; // jump to h\\n   return s;\\n}\\n```\\n\\nIf you run this code for n = 50 in your favorite programming language, you will realize that it takes at least an hour to get the answer. \\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems. What does this mean? Let me explain with an example.\\n\\nAs seen in the above trace, a subproblem of 1 (0, 0, 3) is 8 (2, 1, 2). \\n\\nA subproblem of 3 (0, 2, 3) is also 8 (2, 1, 2) because you can get from 3 to 8 in a single hop.\\n\\nWe have already computed the solution to 8 (2, 1, 2) while computing the solution to 1 (0, 0, 3) and there is no need to re-compute this solution if were to store the solution somewhere in memory. The above recursive solution re-computes the solutions to overlapping subproblems and therefore is highly inefficient (runs in the order of O(3 ^ n) I believe).\\n\\n**Top down Dynamic programming solution**\\n\\nWe use dynamic programming and store the solution of each subproblem in M. M is a 3D array and each index of M corresponds to a solution of n. Each n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\nBelow is the code.\\n\\n```\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   // A 3D array to store the solutions to the subproblems\\n   long M[][][] = new long[n + 1][4][3];\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(M, i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(long[][][] M, int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   if(n == 1) return 1;\\n   //if the subproblem\\'s solution is already computed, then return it\\n   if(M[n][i][j] > 0) return M[n][i][j];\\n   //else compute the subproblem\\'s solution and save it in memory\\n   M[n][i][j] = paths(M, i - 1, j - 2, n - 1) % max + // jump to a\\n                paths(M, i - 2, j - 1, n - 1) % max + // jump to b\\n                paths(M, i - 2, j + 1, n - 1) % max + // jump to c\\n                paths(M, i - 1, j + 2, n - 1) % max + // jump to d\\n                paths(M, i + 1, j + 2, n - 1) % max + // jump to e\\n                paths(M, i + 2, j + 1, n - 1) % max + // jump to f\\n                paths(M, i + 2, j - 1, n - 1) % max + // jump to g\\n                paths(M, i + 1, j - 2, n - 1) % max; // jump to h\\n   return M[n][i][j];\\n}\\n```\\n\\nAny questions or feedback is welcome!\\n\\n**P.S: The wysiwyg editor of leetcode sucks! :P**\\n",
                "solutionTags": [],
                "code": "```\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\n```\n```\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n```\n```\\npaths(i, j, n) = paths(i - 1, j - 2, n - 1) + \\n                 paths (i - 2, j - 1, n - 1) +\\n                 paths (i - 2, j + 1, n - 1) +\\n                 paths (i - 1, j + 2, n - 1) +\\n                 paths (i + 1, j + 2, n - 1) +\\n                 paths  (i + 2, j + 1, n - 1) +\\n                 paths (i + 2, j - 1, n - 1) +\\n                 paths (i + 1, j - 2, n - 1)\\n```\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\n```\n```\\n\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   //trivial case\\n   if(n == 1) return 1;\\n   //non trivial case\\n   long s = paths(i - 1, j - 2, n - 1) % max + // jump to a\\n            paths(i - 2, j - 1, n - 1) % max + // jump to b\\n            paths(i - 2, j + 1, n - 1) % max + // jump to c\\n            paths(i - 1, j + 2, n - 1) % max + // jump to d\\n            paths(i + 1, j + 2, n - 1) % max + // jump to e\\n            paths(i + 2, j + 1, n - 1) % max + // jump to f\\n            paths(i + 2, j - 1, n - 1) % max + // jump to g\\n            paths(i + 1, j - 2, n - 1) % max; // jump to h\\n   return s;\\n}\\n```\n```\\npublic static final int max = (int) Math.pow(10, 9) + 7;\\n\\t\\npublic int knightDialer(int n) {\\n   // A 3D array to store the solutions to the subproblems\\n   long M[][][] = new long[n + 1][4][3];\\n   long s = 0;\\n   //do n hops from every i, j index (the very requirement of the problem)\\n   for(int i = 0; i < 4; i++) {\\n      for(int j = 0; j < 3; j++) {\\n         s = (s + paths(M, i, j, n)) % max;\\n      }\\n   }\\n   return (int) s;\\n}\\n\\nprivate long paths(long[][][] M, int i, int j, int n) {\\n   // if the knight hops outside of the matrix or to * return 0 \\n   //as there are no unique paths from here\\n   if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n   if(n == 1) return 1;\\n   //if the subproblem\\'s solution is already computed, then return it\\n   if(M[n][i][j] > 0) return M[n][i][j];\\n   //else compute the subproblem\\'s solution and save it in memory\\n   M[n][i][j] = paths(M, i - 1, j - 2, n - 1) % max + // jump to a\\n                paths(M, i - 2, j - 1, n - 1) % max + // jump to b\\n                paths(M, i - 2, j + 1, n - 1) % max + // jump to c\\n                paths(M, i - 1, j + 2, n - 1) % max + // jump to d\\n                paths(M, i + 1, j + 2, n - 1) % max + // jump to e\\n                paths(M, i + 2, j + 1, n - 1) % max + // jump to f\\n                paths(M, i + 2, j - 1, n - 1) % max + // jump to g\\n                paths(M, i + 1, j - 2, n - 1) % max; // jump to h\\n   return M[n][i][j];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189252,
                "title": "o-logn",
                "content": "<img src=\"https://assets.leetcode.com/users/lee215/image_1541301837.png\" style=\"width:200px;\"/>\\n\\n**Naive recursion:**\\n`O(N)` time and `O(1)` space, good enough.\\n\\n```\\n    def knightDialer(self, N):\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(N - 1):\\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \\\\\\n                x6 + x8, x7 + x9, x4 + x8, \\\\\\n                x3 + x9 + x0, 0, x1 + x7 + x0, \\\\\\n                x2 + x6, x1 + x3, x2 + x4, \\\\\\n                x4 + x6\\n        return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10**9 + 7)\\n```\\n\\n\\nIn fact, we recursively did pow operation.\\nThis can be optimised to `O(log)` time.\\n\\nConstruct a 10 * 10 transformation matrix M.\\n`M[i][j] = 1` if i and j is connnected.\\n\\nif N = 1, return 10.\\nif N > 1, return sum of `[1,1,1,1,1,1,1,1,1,1] * M ^ (N - 1)`\\n\\nThe power of matrix reveals the number of walks in an undirected graph.\\nFind more details on this link provide by @shankark:\\nhttps://math.stackexchange.com/questions/1890620/finding-path-lengths-by-the-power-of-adjacency-matrix-of-an-undirected-graph\\n\\n\\n```\\n    def knightDialer(self, N):\\n        mod = 10**9 + 7\\n        if N == 1: return 10\\n        M = np.matrix([[0, 0, 0, 0, 1, 0, 1, 0, 0, 0],\\n                       [0, 0, 0, 0, 0, 0, 1, 0, 1, 0],\\n                       [0, 0, 0, 0, 0, 0, 0, 1, 0, 1],\\n                       [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\\n                       [1, 0, 0, 1, 0, 0, 0, 0, 0, 1],\\n                       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n                       [1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\\n                       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\\n                       [0, 1, 0, 1, 0, 0, 0, 0, 0, 0],\\n                       [0, 0, 1, 0, 1, 0, 0, 0, 0, 0]])\\n        res, N = 1, N - 1\\n        while N:\\n            if N % 2: res = res * M % mod\\n            M = M * M % mod\\n            N /= 2\\n        return int(np.sum(res)) % mod",
                "solutionTags": [],
                "code": "```\\n    def knightDialer(self, N):\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(N - 1):\\n            x1, x2, x3, x4, x5, x6, x7, x8, x9, x0 = \\\\\\n                x6 + x8, x7 + x9, x4 + x8, \\\\\\n                x3 + x9 + x0, 0, x1 + x7 + x0, \\\\\\n                x2 + x6, x1 + x3, x2 + x4, \\\\\\n                x4 + x6\\n        return (x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x0) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189287,
                "title": "o-n-time-o-1-space-dp-solution-google-interview-question-writeup",
                "content": "This is former Google interview question. It was leaked over a year ago and was soon after blacklisted. Because of this, a former Google interviewer decided to write an excellent blog post breaking down how he asked this question and what he expected from candidates who attempt it. This blog post explains the background of this question, common pitfalls candidates encounter, four different ways to solve it, and how a Google interviewer will evaluate your solution. This article is a gold mine for anyone considering interviewing at Google.\\nhttps://medium.com/@alexgolec/google-interview-questions-deconstructed-the-knights-dialer-f780d516f029\\n\\nAccording to the article, four possible solutions are (1) naive recursive number generation, (2) naive recursive counting, (3) recursion + memoization, and (4) dynamic programming. A candidate who coded either the memoization or DP solution is likely to receive a \"strong hire\" recommendation.\\n\\nI encourage everyone to check out the article. If you\\'re just here for the solution, below is an accepted leetcode solution based on the ideas from the article.\\n```\\ndef knightDialer(self, N):\\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\\n    neighbors = {\\n        0:(4,6),\\n        1:(6,8),\\n        2:(7,9),\\n        3:(4,8),\\n        4:(0,3,9),\\n        5:(),\\n        6:(0,1,7),\\n        7:(2,6),\\n        8:(1,3),\\n        9:(2,4)\\n    }\\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n    for _ in range(N-1):\\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n        for src_key in range(10):\\n            for dst_key in neighbors[src_key]:\\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\\n        current_counts = next_counts\\n    return sum(current_counts) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef knightDialer(self, N):\\n    # Neighbors maps K: starting_key -> V: list of possible destination_keys\\n    neighbors = {\\n        0:(4,6),\\n        1:(6,8),\\n        2:(7,9),\\n        3:(4,8),\\n        4:(0,3,9),\\n        5:(),\\n        6:(0,1,7),\\n        7:(2,6),\\n        8:(1,3),\\n        9:(2,4)\\n    }\\n    current_counts = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n    for _ in range(N-1):\\n        next_counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n        for src_key in range(10):\\n            for dst_key in neighbors[src_key]:\\n                next_counts[dst_key] = (next_counts[dst_key] + current_counts[src_key]) % (10**9 + 7)\\n        current_counts = next_counts\\n    return sum(current_counts) % (10**9 + 7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 189271,
                "title": "java-top-down-memo-dp-o-n",
                "content": "The problem can be transformed into:\\nTraverse a directed graph (each node with a number as label and edges are defined by Knight\\'s moving rule)\\nStart from `0 to 9`\\nMove `N - 1` step\\nReturn `how many ways to reach the end`\\n\\nEasy to come up with a DFS solution to start traversal from 0 to 9\\nIn each recursion, move to one of the current node\\'s neighbors and the remain step becomes `N-1`\\nStop recursion when `N == 0`\\n\\n**Optimization:**\\nObserve the recursive problem. The variances are:\\n1. Current Node\\n2. Remain Steps\\n\\nTherefore, we can store these two variables as the memo to speed up DFS (then it\\'s a Top Down DP)\\n```\\n    public static final int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        int[][] graph = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        int cnt = 0;\\n        Integer[][] memo = new Integer[N+1][10];\\n        for (int i = 0; i <= 9; i++)\\n            cnt = (cnt + helper(N-1, i, graph, memo)) % MOD;\\n        return cnt;\\n    }\\n    private int helper(int N, int cur, int[][] graph, Integer[][] memo) {\\n        if (N == 0)\\n            return 1;\\n        if (memo[N][cur] != null)\\n            return memo[N][cur];\\n        int cnt = 0;\\n        for (int nei : graph[cur])\\n            cnt = (cnt + helper(N-1, nei, graph, memo)) % MOD;\\n        memo[N][cur] = cnt;\\n        return cnt;\\n    }\\n```\\n**Time Complexity:** `O(10*N) = O(N)` fill the memo\\n**Space Complexity:** `O(N)` depth of the recursion ",
                "solutionTags": [],
                "code": "```\\n    public static final int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        int[][] graph = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        int cnt = 0;\\n        Integer[][] memo = new Integer[N+1][10];\\n        for (int i = 0; i <= 9; i++)\\n            cnt = (cnt + helper(N-1, i, graph, memo)) % MOD;\\n        return cnt;\\n    }\\n    private int helper(int N, int cur, int[][] graph, Integer[][] memo) {\\n        if (N == 0)\\n            return 1;\\n        if (memo[N][cur] != null)\\n            return memo[N][cur];\\n        int cnt = 0;\\n        for (int nei : graph[cur])\\n            cnt = (cnt + helper(N-1, nei, graph, memo)) % MOD;\\n        memo[N][cur] = cnt;\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 655853,
                "title": "if-you-want-to-laugh-check-out-this-stupid-solution-guarantee-you-could-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tlong kMod=1e9+7;\\n\\t\\t\\tlong hop1=1; // number of ways to form a distinct number ending with key 1\\n\\t\\t\\tlong hop2=1;\\n\\t\\t\\tlong hop3=1;\\n\\t\\t\\tlong hop4=1;\\n\\t\\t\\tlong hop5=1;\\n\\t\\t\\tlong hop6=1;\\n\\t\\t\\tlong hop7=1;\\n\\t\\t\\tlong hop8=1;\\n\\t\\t\\tlong hop9=1;\\n\\t\\t\\tlong hop0=1;\\n\\n\\t\\t\\tif(N==1) return 10;\\n\\t\\t\\tfor(int i=2;i<=N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong old_1=hop1;\\n\\t\\t\\t\\tlong old_2=hop2;\\n\\t\\t\\t\\tlong old_3=hop3;\\n\\t\\t\\t\\tlong old_4=hop4;\\n\\t\\t\\t\\tlong old_5=hop5;\\n\\t\\t\\t\\tlong old_6=hop6;\\n\\t\\t\\t\\tlong old_7=hop7;\\n\\t\\t\\t\\tlong old_8=hop8;\\n\\t\\t\\t\\tlong old_9=hop9;\\n\\t\\t\\t\\tlong old_0=hop0;\\n\\n\\t\\t\\t\\thop1=(old_6+old_8)%kMod;\\n\\t\\t\\t\\thop2=(old_7+old_9)%kMod;\\n\\t\\t\\t\\thop3=(old_4+old_8)%kMod;\\n\\t\\t\\t\\thop4=(old_3+old_9+old_0)%kMod;\\n\\t\\t\\t\\thop5=0;\\n\\t\\t\\t\\thop6=(old_1+old_7+old_0)%kMod;\\n\\t\\t\\t\\thop7=(old_2+old_6)%kMod;\\n\\t\\t\\t\\thop8=(old_1+old_3)%kMod;\\n\\t\\t\\t\\thop9=(old_2+old_4)%kMod;\\n\\t\\t\\t\\thop0=(old_4+old_6)%kMod;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn (hop1+hop2+hop3+hop4+hop6+hop7+hop8+hop9+hop0)%kMod;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tlong kMod=1e9+7;\\n\\t\\t\\tlong hop1=1; // number of ways to form a distinct number ending with key 1\\n\\t\\t\\tlong hop2=1;\\n\\t\\t\\tlong hop3=1;\\n\\t\\t\\tlong hop4=1;\\n\\t\\t\\tlong hop5=1;\\n\\t\\t\\tlong hop6=1;\\n\\t\\t\\tlong hop7=1;\\n\\t\\t\\tlong hop8=1;\\n\\t\\t\\tlong hop9=1;\\n\\t\\t\\tlong hop0=1;\\n\\n\\t\\t\\tif(N==1) return 10;\\n\\t\\t\\tfor(int i=2;i<=N;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong old_1=hop1;\\n\\t\\t\\t\\tlong old_2=hop2;\\n\\t\\t\\t\\tlong old_3=hop3;\\n\\t\\t\\t\\tlong old_4=hop4;\\n\\t\\t\\t\\tlong old_5=hop5;\\n\\t\\t\\t\\tlong old_6=hop6;\\n\\t\\t\\t\\tlong old_7=hop7;\\n\\t\\t\\t\\tlong old_8=hop8;\\n\\t\\t\\t\\tlong old_9=hop9;\\n\\t\\t\\t\\tlong old_0=hop0;\\n\\n\\t\\t\\t\\thop1=(old_6+old_8)%kMod;\\n\\t\\t\\t\\thop2=(old_7+old_9)%kMod;\\n\\t\\t\\t\\thop3=(old_4+old_8)%kMod;\\n\\t\\t\\t\\thop4=(old_3+old_9+old_0)%kMod;\\n\\t\\t\\t\\thop5=0;\\n\\t\\t\\t\\thop6=(old_1+old_7+old_0)%kMod;\\n\\t\\t\\t\\thop7=(old_2+old_6)%kMod;\\n\\t\\t\\t\\thop8=(old_1+old_3)%kMod;\\n\\t\\t\\t\\thop9=(old_2+old_4)%kMod;\\n\\t\\t\\t\\thop0=(old_4+old_6)%kMod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 189251,
                "title": "c-5-lines-dp",
                "content": "The ```moves``` show the possible hoops from a given number. Each digit in ```dial[i]``` contains numbers that end with this digit. For each hoop, we add numbers from other digits that we can hop out from. For example, for digit 4 we add numbers from digits 3, 9 and 0:\\n```\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n1 | 1 | 1 -> 3 | 0 | 3 -> 6 | 0 | 6\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n  | 1 |        | 2 |        | 6 |\\n```\\n```\\nvector<vector<int>> ms = { {4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {4, 2}};\\nint knightDialer(int N) {\\n  vector<int> d1(10, 1), d2(10);\\n  for (; --N > 0; swap(d1, d2))\\n    for (auto i = 0; i < 10; ++i) \\n        d2[i] = accumulate(begin(ms[i]), end(ms[i]), 0, [&](int s, int i) {return (s + d1[i]) % 1000000007;});\\n  return accumulate(begin(d1), end(d1), 0, [](int s, int n) {return (s + n) % 1000000007;});\\n}\\n```",
                "solutionTags": [],
                "code": "```moves```\n```dial[i]```\n```\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n1 | 1 | 1 -> 3 | 0 | 3 -> 6 | 0 | 6\\n1 | 1 | 1    2 | 2 | 2    5 | 4 | 5\\n  | 1 |        | 2 |        | 6 |\\n```\n```\\nvector<vector<int>> ms = { {4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0}, {}, {1, 7, 0}, {2, 6}, {1, 3}, {4, 2}};\\nint knightDialer(int N) {\\n  vector<int> d1(10, 1), d2(10);\\n  for (; --N > 0; swap(d1, d2))\\n    for (auto i = 0; i < 10; ++i) \\n        d2[i] = accumulate(begin(ms[i]), end(ms[i]), 0, [&](int s, int i) {return (s + d1[i]) % 1000000007;});\\n  return accumulate(begin(d1), end(d1), 0, [](int s, int n) {return (s + n) % 1000000007;});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189322,
                "title": "java-dfs-with-memo",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int[][] map = new int[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        int[][] memo = new int[N + 1][10];\\n        for (int i = 1; i <= N; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < 10; i++) {\\n            result += helper(N, i, map, memo);\\n            result %= (int)1e9 + 7;\\n        }\\n        return result;\\n    }\\n    private int helper(int N, int start, int[][] map, int[][] memo) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n        if (memo[N][start] > -1) {\\n            return memo[N][start];\\n        }\\n        memo[N][start] = 0;\\n        for (int next : map[start]) {\\n            memo[N][start] += helper(N - 1, next, map, memo);\\n            memo[N][start] %= (int)1e9 + 7;\\n        }\\n        return memo[N][start];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int[][] map = new int[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        int[][] memo = new int[N + 1][10];\\n        for (int i = 1; i <= N; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        int result = 0;\\n        for (int i = 0; i < 10; i++) {\\n            result += helper(N, i, map, memo);\\n            result %= (int)1e9 + 7;\\n        }\\n        return result;\\n    }\\n    private int helper(int N, int start, int[][] map, int[][] memo) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n        if (memo[N][start] > -1) {\\n            return memo[N][start];\\n        }\\n        memo[N][start] = 0;\\n        for (int next : map[start]) {\\n            memo[N][start] += helper(N - 1, next, map, memo);\\n            memo[N][start] %= (int)1e9 + 7;\\n        }\\n        return memo[N][start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189265,
                "title": "concise-java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N){\\n        int[][] dirs = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[ N + 1][10];\\n        for(int j = 0; j < dp[0].length; j ++){\\n            dp[1][j] = 1;\\n        }\\n        int mod = (int)1e9 + 7;\\n        for(int i = 2; i < dp.length;i ++)\\n            for(int j = 0; j < dp[0].length; j ++){\\n\\t\\t\\t\\t\\t\\n                int[] dir = dirs[j]; \\t//Where j comes from\\n                for(int num : dir){\\n                    dp[i][j] += dp[i - 1][num]; \\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        int count = 0;\\n        for(int i = 0; i < dp[0].length; i ++){\\n            count += dp[N][i];\\n            count %= mod;\\n        }\\n       return count;\\n       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N){\\n        int[][] dirs = new int[][]{{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[ N + 1][10];\\n        for(int j = 0; j < dp[0].length; j ++){\\n            dp[1][j] = 1;\\n        }\\n        int mod = (int)1e9 + 7;\\n        for(int i = 2; i < dp.length;i ++)\\n            for(int j = 0; j < dp[0].length; j ++){\\n\\t\\t\\t\\t\\t\\n                int[] dir = dirs[j]; \\t//Where j comes from\\n                for(int num : dir){\\n                    dp[i][j] += dp[i - 1][num]; \\n                    dp[i][j] %= mod;\\n                }\\n            }\\n        int count = 0;\\n        for(int i = 0; i < dp[0].length; i ++){\\n            count += dp[N][i];\\n            count %= mod;\\n        }\\n       return count;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824317,
                "title": "simple-c-solution-dp-92-time-efficient",
                "content": "**Think of it as for the current postion how many times we can fix it with 0,1...**\\nconsider -->if previous place is 0 then current place can be fixed with 4 and 6 so if v[0] is the count of 0 in previous place and tmp is for current postion then at current postion we will get 4 due to 0 as previous ,is v[0] times and similarly for current 6 due to previous 0 is v[0] times.\\n**so considering tmp as current and v as previous counts\\ntmp[x]=sum of all the previous values from which we can reach x;**\\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod=1000000007;\\n        if(n==1)return 10;\\n        vector<long long int>v(10,1);\\n        vector<long long int>tmp(10);\\n        v[5]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            tmp[0]=(v[4]+v[6])%mod;\\n            tmp[1]=(v[6]+v[8])%mod;\\n            tmp[2]=(v[7]+v[9])%mod;\\n            tmp[3]=(v[4]+v[8])%mod;\\n            tmp[4]=(v[0]+v[3]+v[9])%mod;\\n            tmp[6]=(v[0]+v[1]+v[7])%mod;\\n            tmp[7]=(v[2]+v[6])%mod;\\n            tmp[8]=(v[1]+v[3])%mod;\\n            tmp[9]=(v[2]+v[4])%mod;\\n            for(int i=0;i<10;i++)\\n                v[i]=tmp[i];\\n        }\\n        int sum=0;\\n        for(int i=0;i<10;i++)\\n            sum=(sum+v[i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod=1000000007;\\n        if(n==1)return 10;\\n        vector<long long int>v(10,1);\\n        vector<long long int>tmp(10);\\n        v[5]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            tmp[0]=(v[4]+v[6])%mod;\\n            tmp[1]=(v[6]+v[8])%mod;\\n            tmp[2]=(v[7]+v[9])%mod;\\n            tmp[3]=(v[4]+v[8])%mod;\\n            tmp[4]=(v[0]+v[3]+v[9])%mod;\\n            tmp[6]=(v[0]+v[1]+v[7])%mod;\\n            tmp[7]=(v[2]+v[6])%mod;\\n            tmp[8]=(v[1]+v[3])%mod;\\n            tmp[9]=(v[2]+v[4])%mod;\\n            for(int i=0;i<10;i++)\\n                v[i]=tmp[i];\\n        }\\n        int sum=0;\\n        for(int i=0;i<10;i++)\\n            sum=(sum+v[i])%mod;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189273,
                "title": "9-line-python-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\" \\n        dct = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\\n        \\n        dp = [1] * 10\\n        for _ in range(N - 1):\\n            nxt = [0] * 10\\n            for i in range(10):\\n                for j in dct[i]:\\n                    nxt[j] += dp[i]\\n            dp = nxt\\n        \\n        return sum(dp) % (10 ** 9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\" \\n        dct = {1:[6, 8], 2:[7, 9], 3:[4, 8], 4:[0, 3, 9], 5:[], 6:[0, 1, 7], 7:[2, 6], 8:[1, 3], 9:[2, 4], 0:[4, 6]}\\n        \\n        dp = [1] * 10\\n        for _ in range(N - 1):\\n            nxt = [0] * 10\\n            for i in range(10):\\n                for j in dct[i]:\\n                    nxt[j] += dp[i]\\n            dp = nxt\\n        \\n        return sum(dp) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189229,
                "title": "concise-c-using-dp-with-explanation",
                "content": "**Explanation:**  The row of the DP vector represent the N number of hops.  The column of the DP vector represent\nthe numeric phone pad keys [0:9] ( zero to nine, inclusive ).  Then the DP formula is as follows:\n \n**Base case:** when N is 1, the knight will take zero hops from its current digit\n \n```dp[1][0:9] = 1```\n \n**Recursive case:** observe the overlapping subproblems and optimal substructure.  The current i-th hop for each keypad digit can be found from the previous i-th-minus-1 hop for each keypad digit which can reach the current keypad digit from a single hop.  Therefore calculate the current i-th hop for each keypad destination digit (dst) as the sum of all keypad source digits (src) i-th-minus-1 hop solutions.\n \n```dp[ i ][ dst ] = sum( dp[ i-1 ][ src ] )```\n\n**verbose DP solution #1:**  \n```\nusing VL = vector< long >;\nusing VVL = vector< VL >;\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        VVL dp( N+1, VL( 10, 1 ));\n        for( int i{ 2 };  i <= N;  ++i ){\n            dp[ i ][ 0 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 1 ] = (  dp[ i-1 ][ 6 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 2 ] = (  dp[ i-1 ][ 7 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 3 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 4 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 3 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 5 ] = (  0  );\n            dp[ i ][ 6 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 1 ] + dp[ i-1 ][ 7 ]  ) % MOD;\n            dp[ i ][ 7 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 8 ] = (  dp[ i-1 ][ 1 ] + dp[ i-1 ][ 3 ]  ) % MOD;\n            dp[ i ][ 9 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 4 ]  ) % MOD;\n        }\n        return accumulate( dp[ N ].begin(), dp[ N ].end(), 0L ) % MOD;\n    }\n};\n```\n\n**verbose DP solution #2:** same concept as above, but optimized for memory use as we only need to keep track of the previous i-th-minus-1 hop values ( i.e. use a \"sliding window\" of size 2 ).\n\n```\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        vector<long> cur( 10, 1 ), next( cur );\n        for( int i{ 2 };  i <= N;  ++i ){\n            next[ 0 ] = (  cur[ 4 ] + cur[ 6 ]  ) % MOD;\n            next[ 1 ] = (  cur[ 6 ] + cur[ 8 ]  ) % MOD;\n            next[ 2 ] = (  cur[ 7 ] + cur[ 9 ]  ) % MOD;\n            next[ 3 ] = (  cur[ 4 ] + cur[ 8 ]  ) % MOD;\n            next[ 4 ] = (  cur[ 0 ] + cur[ 3 ] + cur[ 9 ]  ) % MOD;\n            next[ 5 ] = (  0  );\n            next[ 6 ] = (  cur[ 0 ] + cur[ 1 ] + cur[ 7 ]  ) % MOD;\n            next[ 7 ] = (  cur[ 2 ] + cur[ 6 ]  ) % MOD;\n            next[ 8 ] = (  cur[ 1 ] + cur[ 3 ]  ) % MOD;\n            next[ 9 ] = (  cur[ 2 ] + cur[ 4 ]  ) % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**Concise DP solution #3:** same concepts as above, using \"hops\" to track the next hops from each current digit.  (The current digit's value is the index of the vector of vectors \"hops\".)\n\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{\n        { 4, 6 },  { 6, 8 },  { 7, 9 },  { 4, 8 },  { 0, 3, 9 },  { },  { 0, 1, 7 },  { 2, 6 },  { 1, 3 },  { 2, 4 }\n    };\npublic:\n    int knightDialer( int N ){\n        VL cur( 10, 1 );\n        for(  VL next( 10, 0 );  --N > 0;  next=VL( 10, 0 )  ){\n            for( int i=0;  i <= 9;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**More concise DP solution #4:** same concepts as above, just remove a handful of lines\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\npublic:\n    int knightDialer( int N, VL cur=VL( 10, 1 ) ){\n        for(  VL next( 10, 0 );  --N > 0;  cur.swap( next ), next=VL( 10, 0 )  )\n            for( int i=0;  i < 10;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n\n**Recursive top-down DFS solution:** same concept as above, recursively top-down with memoization\n```\nstatic const int MOD = 1000000007;\nusing VI = vector< int >;\nusing VVI = vector< VI >;\nVVI memo=VVI( 5001, VI(10,1L) );\nclass Solution {\n    VVI hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\n    long go( int N, int digit, long result = 0L ){\n        if( N-1 == 0 || memo[ N ][ digit ] > 1L )\n            return memo[ N ][ digit ];\n        for( auto hop: hops[ digit ] )\n            result += go( N-1, hop ) % MOD;\n        return memo[ N ][ digit ] = result % MOD;\n    }\npublic:\n    int knightDialer( int N, long result=0L ){\n        for( int digit = 0;  digit < 10;  ++digit )\n            result += go( N, digit ) % MOD;\n        return static_cast<int>( result % MOD );\n    }\n};\n```",
                "solutionTags": [],
                "code": "```dp[1][0:9] = 1```\n```dp[ i ][ dst ] = sum( dp[ i-1 ][ src ] )```\n```\nusing VL = vector< long >;\nusing VVL = vector< VL >;\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        VVL dp( N+1, VL( 10, 1 ));\n        for( int i{ 2 };  i <= N;  ++i ){\n            dp[ i ][ 0 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 1 ] = (  dp[ i-1 ][ 6 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 2 ] = (  dp[ i-1 ][ 7 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 3 ] = (  dp[ i-1 ][ 4 ] + dp[ i-1 ][ 8 ]  ) % MOD;\n            dp[ i ][ 4 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 3 ] + dp[ i-1 ][ 9 ]  ) % MOD;\n            dp[ i ][ 5 ] = (  0  );\n            dp[ i ][ 6 ] = (  dp[ i-1 ][ 0 ] + dp[ i-1 ][ 1 ] + dp[ i-1 ][ 7 ]  ) % MOD;\n            dp[ i ][ 7 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 6 ]  ) % MOD;\n            dp[ i ][ 8 ] = (  dp[ i-1 ][ 1 ] + dp[ i-1 ][ 3 ]  ) % MOD;\n            dp[ i ][ 9 ] = (  dp[ i-1 ][ 2 ] + dp[ i-1 ][ 4 ]  ) % MOD;\n        }\n        return accumulate( dp[ N ].begin(), dp[ N ].end(), 0L ) % MOD;\n    }\n};\n```\n```\nclass Solution {\n    static const int MOD = 1000000007;\npublic:\n    int knightDialer( int N ){\n        vector<long> cur( 10, 1 ), next( cur );\n        for( int i{ 2 };  i <= N;  ++i ){\n            next[ 0 ] = (  cur[ 4 ] + cur[ 6 ]  ) % MOD;\n            next[ 1 ] = (  cur[ 6 ] + cur[ 8 ]  ) % MOD;\n            next[ 2 ] = (  cur[ 7 ] + cur[ 9 ]  ) % MOD;\n            next[ 3 ] = (  cur[ 4 ] + cur[ 8 ]  ) % MOD;\n            next[ 4 ] = (  cur[ 0 ] + cur[ 3 ] + cur[ 9 ]  ) % MOD;\n            next[ 5 ] = (  0  );\n            next[ 6 ] = (  cur[ 0 ] + cur[ 1 ] + cur[ 7 ]  ) % MOD;\n            next[ 7 ] = (  cur[ 2 ] + cur[ 6 ]  ) % MOD;\n            next[ 8 ] = (  cur[ 1 ] + cur[ 3 ]  ) % MOD;\n            next[ 9 ] = (  cur[ 2 ] + cur[ 4 ]  ) % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{\n        { 4, 6 },  { 6, 8 },  { 7, 9 },  { 4, 8 },  { 0, 3, 9 },  { },  { 0, 1, 7 },  { 2, 6 },  { 1, 3 },  { 2, 4 }\n    };\npublic:\n    int knightDialer( int N ){\n        VL cur( 10, 1 );\n        for(  VL next( 10, 0 );  --N > 0;  next=VL( 10, 0 )  ){\n            for( int i=0;  i <= 9;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n            cur.swap( next );\n        }\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nusing VL = vector< long >;\nclass Solution {\n    static const int MOD = 1000000007;\n    vector<VL> hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\npublic:\n    int knightDialer( int N, VL cur=VL( 10, 1 ) ){\n        for(  VL next( 10, 0 );  --N > 0;  cur.swap( next ), next=VL( 10, 0 )  )\n            for( int i=0;  i < 10;  ++i )\n                for( auto hop: hops[ i ] )\n                    next[ i ] += cur[ hop ] % MOD;\n        return accumulate( cur.begin(), cur.end(), 0L ) % MOD;\n    }\n};\n```\n```\nstatic const int MOD = 1000000007;\nusing VI = vector< int >;\nusing VVI = vector< VI >;\nVVI memo=VVI( 5001, VI(10,1L) );\nclass Solution {\n    VVI hops{ {4,6}, {6,8}, {7,9}, {4,8}, {0,3,9}, {}, {0,1,7}, {2,6}, {1,3}, {2,4} };\n    long go( int N, int digit, long result = 0L ){\n        if( N-1 == 0 || memo[ N ][ digit ] > 1L )\n            return memo[ N ][ digit ];\n        for( auto hop: hops[ digit ] )\n            result += go( N-1, hop ) % MOD;\n        return memo[ N ][ digit ] = result % MOD;\n    }\npublic:\n    int knightDialer( int N, long result=0L ){\n        for( int digit = 0;  digit < 10;  ++digit )\n            result += go( N, digit ) % MOD;\n        return static_cast<int>( result % MOD );\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 189230,
                "title": "java-straightforward-simulation-dp-whatever",
                "content": "I don\\'t want to call it dp, because I just simply simulate the process.\\n```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        if (N==1) return 10;\\n        long[] cur= new long[10];\\n        Arrays.fill(cur, 1);\\n        cur[5]=0;\\n        long res=0, M=(int)1e9+7;;\\n        while (N-->1){\\n            long[] next= Arrays.copyOf(cur, 10);\\n            next[0]=(cur[4]+cur[6])%M;\\n            next[1]=(cur[6]+cur[8])%M;\\n            next[2]=(cur[7]+cur[9])%M;\\n            next[3]=(cur[4]+cur[8])%M;\\n            next[4]=(cur[3]+cur[9]+cur[0])%M;\\n            next[6]=(cur[1]+cur[7]+cur[0])%M;\\n            next[7]=(cur[2]+cur[6])%M;\\n            next[8]=(cur[1]+cur[3])%M;\\n            next[9]=(cur[2]+cur[4])%M;\\n            cur=next;\\n        }\\n        for (long n: cur) res=(res+n)%M;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        if (N==1) return 10;\\n        long[] cur= new long[10];\\n        Arrays.fill(cur, 1);\\n        cur[5]=0;\\n        long res=0, M=(int)1e9+7;;\\n        while (N-->1){\\n            long[] next= Arrays.copyOf(cur, 10);\\n            next[0]=(cur[4]+cur[6])%M;\\n            next[1]=(cur[6]+cur[8])%M;\\n            next[2]=(cur[7]+cur[9])%M;\\n            next[3]=(cur[4]+cur[8])%M;\\n            next[4]=(cur[3]+cur[9]+cur[0])%M;\\n            next[6]=(cur[1]+cur[7]+cur[0])%M;\\n            next[7]=(cur[2]+cur[6])%M;\\n            next[8]=(cur[1]+cur[3])%M;\\n            next[9]=(cur[2]+cur[4])%M;\\n            cur=next;\\n        }\\n        for (long n: cur) res=(res+n)%M;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540675,
                "title": "c-simple-clean-and-concise-solution-with-detailed-explanation-o-n-tc-o-1-sc",
                "content": "**Idea:**\\nFirst, we set a map from each number to its neighbors to easily know where we can go, using a vector and its indices.\\nThe `count` vector keeps the number of phone numbers we can dial starting from each index.\\nWe initialize `count` with `1`s, because we can place the knight in any cell initially, and need no steps to make numbers with 1 digit.\\nNow, we loop `n` times.\\nEach time, we go through all the numbers - `0` to `9` - and try to continue another step from that number.\\nWe count the new ways in a temporary vector `curr_count` to keep track of the old and new counts.\\nAt the end, we sum up `count` to get the total numbers we can dial.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1) (All vectors have constant sizes)\\n\\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<int>> v = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        \\n        vector<long> count(10, 1), curr_count(10, 0);\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            fill(curr_count.begin(), curr_count.end(), 0);\\n            \\n            for (int j = 0; j < 10; j++) {\\n                \\n                for (auto next : v[j]) {\\n                    curr_count[next] += count[j] % mod;\\n                }\\n                \\n            }\\n            \\n            count = curr_count;\\n        }\\n\\n        long total = 0;\\n        for (auto c : count) total += c % mod;\\n        return total % mod;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<int>> v = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        \\n        vector<long> count(10, 1), curr_count(10, 0);\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            fill(curr_count.begin(), curr_count.end(), 0);\\n            \\n            for (int j = 0; j < 10; j++) {\\n                \\n                for (auto next : v[j]) {\\n                    curr_count[next] += count[j] % mod;\\n                }\\n                \\n            }\\n            \\n            count = curr_count;\\n        }\\n\\n        long total = 0;\\n        for (auto c : count) total += c % mod;\\n        return total % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469930,
                "title": "1-for-loop-4-ints-that-s-it",
                "content": "Python, 5 lines, 97% time efficient, 96% memory efficient, no DP. \\n\\nI came up with a pretty elegant solution by thinking about this problem in terms of board-states. Each square the knight can stand on has certain properties. I classified all the squares on the keypad into 5 types of board-states.\\n\\n- A\\n\\t- Squares: 0\\n\\t- Moves: B, B\\n- B\\n\\t- Squares: 4, 6\\n\\t- Moves: A, C, C\\n- C\\n\\t- Squares: 1, 3, 7, 9\\n\\t- Moves: B, D\\n- D\\n\\t- Squares: 2, 8\\n\\t- Moves: C, C\\n- E\\n\\t- Squares: 5\\n\\t- Moves: none\\n\\nTo translate these classifications: every time you arrive at a C-square, one B-square and one D-square are available for your next move. I counted how many of each of the board-states we started with, and wrote down the formulas for how many of each board-state would be created for the next round by our existing board-states. Here\\'s my code:\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        A, B, C, D = 1, 2, 4, 2\\n        if n == 1:\\n            return(A+B+C+D+1)\\n        for i in range(n-1):\\n            A, B, C, D = B, (2*A + C), (2*B + 2*D), C\\n        return((A+B+C+D) % (10**9 + 7)) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        A, B, C, D = 1, 2, 4, 2\\n        if n == 1:\\n            return(A+B+C+D+1)\\n        for i in range(n-1):\\n            A, B, C, D = B, (2*A + C), (2*B + 2*D), C\\n        return((A+B+C+D) % (10**9 + 7)) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278584,
                "title": "easy-c-solution-3-approaches",
                "content": "# Approach 1 : Recursion - TLE\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    int func(int i, int j, int hops){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        long ans = func(i-2, j-1, hops-1)%mod+func(i-2, j+1, hops-1)%mod+\\n                   func(i-1, j-2, hops-1)%mod+func(i+1, j-2, hops-1)%mod+\\n                   func(i-1, j+2, hops-1)%mod+func(i+1, j+2, hops-1)%mod+\\n                   func(i+2, j-1, hops-1)%mod+func(i+2, j+1, hops-1)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach2 : DP Top Down - Accepted\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        vector<vector<vector<long>>> dp (4, vector<vector<long>> (3, vector<long> (n+1, -1)));\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n, dp))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    long func(int i, int j, int hops, vector<vector<vector<long>>> &dp){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        if(dp[i][j][hops] != -1)\\n            return dp[i][j][hops];\\n        \\n        dp[i][j][hops] = func(i-2, j-1, hops-1, dp)%mod+func(i-2, j+1, hops-1, dp)%mod+\\n                       func(i-1, j-2, hops-1, dp)%mod+func(i+1, j-2, hops-1, dp)%mod+\\n                       func(i-1, j+2, hops-1, dp)%mod+func(i+1, j+2, hops-1, dp)%mod+\\n                       func(i+2, j-1, hops-1, dp)%mod+func(i+2, j+1, hops-1, dp)%mod;\\n        \\n        return dp[i][j][hops];\\n    }\\n};\\n```\\n\\n# Approach 3 : DP Bottom Up - Accepted\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> a = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1e9+7;\\n    int knightDialer(int n){\\n        long long int ans = 0;\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(10,0));\\n        for(int i = 0;i<10;i++) \\n            dp[1][i] = 1;\\n        \\n        for(int i=2;i<n+1;i++)\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<a[j].size();k++)\\n                    dp[i][j]+=dp[i-1][a[j][k]];\\n                dp[i][j]%=mod;\\n            }\\n        \\n        for(auto x:dp[n])\\n            ans += x;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    int func(int i, int j, int hops){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        long ans = func(i-2, j-1, hops-1)%mod+func(i-2, j+1, hops-1)%mod+\\n                   func(i-1, j-2, hops-1)%mod+func(i+1, j-2, hops-1)%mod+\\n                   func(i-1, j+2, hops-1)%mod+func(i+1, j+2, hops-1)%mod+\\n                   func(i+2, j-1, hops-1)%mod+func(i+2, j+1, hops-1)%mod;\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int knightDialer(int n) {\\n        vector<vector<vector<long>>> dp (4, vector<vector<long>> (3, vector<long> (n+1, -1)));\\n        long ans=0;\\n        for(int i=0; i<4; i++)\\n            for(int j=0; j<3; j++)\\n                ans = (ans+func(i, j, n, dp))%mod;\\n        \\n        return (int)ans;\\n    }\\n    \\n    long func(int i, int j, int hops, vector<vector<vector<long>>> &dp){\\n        if(i<0 || i>=4 || j<0 || j>=3 || (i==3 && j!=1))  return 0;\\n        if(hops == 1)   return 1;\\n        \\n        if(dp[i][j][hops] != -1)\\n            return dp[i][j][hops];\\n        \\n        dp[i][j][hops] = func(i-2, j-1, hops-1, dp)%mod+func(i-2, j+1, hops-1, dp)%mod+\\n                       func(i-1, j-2, hops-1, dp)%mod+func(i+1, j-2, hops-1, dp)%mod+\\n                       func(i-1, j+2, hops-1, dp)%mod+func(i+1, j+2, hops-1, dp)%mod+\\n                       func(i+2, j-1, hops-1, dp)%mod+func(i+2, j+1, hops-1, dp)%mod;\\n        \\n        return dp[i][j][hops];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> a = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1e9+7;\\n    int knightDialer(int n){\\n        long long int ans = 0;\\n        vector<vector<long long int>> dp(n+1,vector<long long int>(10,0));\\n        for(int i = 0;i<10;i++) \\n            dp[1][i] = 1;\\n        \\n        for(int i=2;i<n+1;i++)\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<a[j].size();k++)\\n                    dp[i][j]+=dp[i-1][a[j][k]];\\n                dp[i][j]%=mod;\\n            }\\n        \\n        for(auto x:dp[n])\\n            ans += x;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476546,
                "title": "python-simple-recursion-memoization",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t# paths represents every key we can go to from given key\\n\\t# -1 is starting condition, we can start from any key\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t# paths represents every key we can go to from given key\\n\\t# -1 is starting condition, we can start from any key\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191495,
                "title": "java-dp-talk-about-patience",
                "content": "Patience for manually doing the mapping :)\\n\\n```\\nclass Solution {\\n    \\n    public int knightDialer(int N) {\\n        long[][] dp = new long[N][10];\\n        int[][] reach = new int[][]{\\n            { 4, 6 }, { 6, 8 }, { 7, 9 }, { 4, 8 }, { 0, 3, 9 }, \\n            { }, { 0, 1, 7 }, { 2, 6 }, { 1, 3 }, { 2, 4 }\\n        };\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        for (int i = 0; i < 10; i++) dp[0][i] = 1;\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                int[] prev = reach[j];\\n                for (int key : prev) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][key]) % mod;\\n                }\\n            }\\n        }\\n        long total = 0L;\\n        for (int i = 0; i < 10; i++) {\\n            total += dp[N - 1][i];\\n            total %= mod;\\n        }\\n        return (int) total;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int knightDialer(int N) {\\n        long[][] dp = new long[N][10];\\n        int[][] reach = new int[][]{\\n            { 4, 6 }, { 6, 8 }, { 7, 9 }, { 4, 8 }, { 0, 3, 9 }, \\n            { }, { 0, 1, 7 }, { 2, 6 }, { 1, 3 }, { 2, 4 }\\n        };\\n        int mod = (int) Math.pow(10, 9) + 7;\\n        for (int i = 0; i < 10; i++) dp[0][i] = 1;\\n        for (int i = 1; i < N; i++) {\\n            for (int j = 0; j < 10; j++) {\\n                int[] prev = reach[j];\\n                for (int key : prev) {\\n                    dp[i][j] = (dp[i][j] + dp[i - 1][key]) % mod;\\n                }\\n            }\\n        }\\n        long total = 0L;\\n        for (int i = 0; i < 10; i++) {\\n            total += dp[N - 1][i];\\n            total %= mod;\\n        }\\n        return (int) total;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 317319,
                "title": "fully-commented-easy-dp-java-solution",
                "content": "```\\n//index -> its neighbor mapping, like a bidirectional graph\\n    Integer[][] graph = new Integer[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0},\\n                                        {},{1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\\n\\n    int MOD = (int)1e9 + 7;\\n    public int knightDialer(int N) {\\n        //dp[i][j] stores\\uFF1Awhen there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have\\n        int[][] dp = new int[N + 1][10];\\n        //base case, defined by question as: \\n        //when it has 1 hop left on the current number, it should just return 1 (dp[0][j] IS NOT CORRECT)\\n        for(int j = 0; j < 10; j++) dp[1][j] = 1;\\n        //iterate sub-problem\\n        //be careful. i start on 2 because 2 ~ N is N - 1, and i - 1 could get our basecase\\n        for(int i = 2; i <= N; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int neighbor : graph[j]){//current number\\'s neighbor\\n                    dp[i][j] += dp[i - 1][neighbor];\\n                    //MOD should be seperated because it may alter our state transfer when number gets big\\n                    dp[i][j] %= MOD; \\n                } \\n            \\n            }\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < 10;j++){\\n            cnt += dp[N][j];\\n            cnt %= MOD; //MOD should be seperated \\n        }\\n        return cnt;\\n    }\\n```\\ndp[i][j] represents\\uFF1A<b>when there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have</b>\\nThus, we can use our graph to trace back to each of j\\'s (j is the current number) neighbors as we keep deducting steps number i.\\nThus the state transfer equation is defined as: \\n\\t<b>dp[i][j] += dp[i - 1][neighbor];</b>\\nFor example, if our current number is 0 and have 2 hops left, it would be <b>dp[2][0]</b>, \\nthen our dp array will try to get the value stored in <b>dp[1][4]</b> and <b>dp[1][6]</b>, which will both return 1. Then our  <b>dp[2][0]</b> will be store the value 2, which is equavalent to try out the number combination \"04\" and \"06\"",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//index -> its neighbor mapping, like a bidirectional graph\\n    Integer[][] graph = new Integer[][]{{4, 6}, {6, 8}, {7, 9}, {4, 8}, {3, 9, 0},\\n                                        {},{1, 7, 0}, {2, 6}, {1, 3}, {2, 4}};\\n\\n    int MOD = (int)1e9 + 7;\\n    public int knightDialer(int N) {\\n        //dp[i][j] stores\\uFF1Awhen there are \\'i\\' hops left and the current number is \\'j\\', how many combination we have\\n        int[][] dp = new int[N + 1][10];\\n        //base case, defined by question as: \\n        //when it has 1 hop left on the current number, it should just return 1 (dp[0][j] IS NOT CORRECT)\\n        for(int j = 0; j < 10; j++) dp[1][j] = 1;\\n        //iterate sub-problem\\n        //be careful. i start on 2 because 2 ~ N is N - 1, and i - 1 could get our basecase\\n        for(int i = 2; i <= N; i++){\\n            for(int j = 0; j < 10; j++){\\n                for(int neighbor : graph[j]){//current number\\'s neighbor\\n                    dp[i][j] += dp[i - 1][neighbor];\\n                    //MOD should be seperated because it may alter our state transfer when number gets big\\n                    dp[i][j] %= MOD; \\n                } \\n            \\n            }\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < 10;j++){\\n            cnt += dp[N][j];\\n            cnt %= MOD; //MOD should be seperated \\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189249,
                "title": "don-t-know-why-tle-by-python",
                "content": "       **It doesn't cost much time in my Jupyter**\n\t\t\t\t\n\t\t\t\tif N==0:\n            return None\n        if N==1:\n            return 10\n        phone={}\n        num=[0,1,2,3,4,5,6,7,8,9]\n        phone[num[0]]=[4,6]\n        phone[num[1]]=[6,8]\n        phone[num[2]]=[7,9]\n        phone[num[3]]=[4,8]\n        phone[num[4]]=[3,9,0]\n        phone[num[5]]=[]\n        phone[num[6]]=[1,7,0]\n        phone[num[7]]=[2,6]\n        phone[num[8]]=[1,3]\n        phone[num[9]]=[2,4]\n\n        res=collections.Counter(num)\n\n        for i in range(N-1):\n            ans=0\n            new=collections.Counter()\n            for number in res:\n                for j in phone[number]:\n                    new[j]+=res[number]\n                ans+=res[number]*len(phone[number])\n            res=new\n\n        return(ans%(10**9+7))",
                "solutionTags": [],
                "code": "\t\t\t\tif N==0:\n        if N==1:\n        phone={}\n        num=[0,1,2,3,4,5,6,7,8,9]\n        phone[num[0]]=[4,6]\n        phone[num[1]]=[6,8]\n        phone[num[2]]=[7,9]\n        phone[num[3]]=[4,8]\n        phone[num[4]]=[3,9,0]\n        phone[num[5]]=[]\n        phone[num[6]]=[1,7,0]\n        phone[num[7]]=[2,6]\n        phone[num[8]]=[1,3]\n        phone[num[9]]=[2,4]\n        res=collections.Counter(num)\n        for i in range(N-1):\n            ans=0\n            new=collections.Counter()\n                    new[j]+=res[number]\n                ans+=res[number]*len(phone[number])\n            res=new\n        return(ans%(10**9+7))",
                "codeTag": "Unknown"
            },
            {
                "id": 1806575,
                "title": "easy-memoization-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7; \\n    \\n    int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}; \\n    int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1}; \\n    \\n    bool safe(int x, int y) {\\n        if(x == 3 and (y == 0 or y == 2)) return false; \\n        if(x < 0 or x > 3) return false; \\n        if(y < 0 or y > 2) return false; \\n        return true; \\n    }\\n    \\n    int f(int x, int y, int n, vector<vector<vector<int>>>& dp) {\\n        if(!safe(x, y)) return 0;\\n        if(n == 1) return 1;\\n        if(n < 0) return 0; \\n        \\n        if(dp[x][y][n] != -1) return dp[x][y][n]; \\n        \\n        int cnt = 0;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int i = x + dx[k]; \\n            int j = y + dy[k]; \\n            if(safe(i, j)) {\\n                cnt = (cnt % mod + f(i, j, n - 1, dp) % mod) % mod; \\n            }\\n        }\\n        return dp[x][y][n] = cnt % mod; \\n    }\\n    \\n    int knightDialer(int n) {\\n        int cnt = 0; \\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(3, vector<int>(n + 1,-1))); \\n        \\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                cnt = (cnt % mod + f(i, j, n, dp) % mod) % mod; \\n            }\\n        }\\n        return cnt % mod; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = (int) 1e9 + 7; \\n    \\n    int dx[8] = {1, 1, -1, -1, 2, 2, -2, -2}; \\n    int dy[8] = {2, -2, 2, -2, 1, -1, 1, -1}; \\n    \\n    bool safe(int x, int y) {\\n        if(x == 3 and (y == 0 or y == 2)) return false; \\n        if(x < 0 or x > 3) return false; \\n        if(y < 0 or y > 2) return false; \\n        return true; \\n    }\\n    \\n    int f(int x, int y, int n, vector<vector<vector<int>>>& dp) {\\n        if(!safe(x, y)) return 0;\\n        if(n == 1) return 1;\\n        if(n < 0) return 0; \\n        \\n        if(dp[x][y][n] != -1) return dp[x][y][n]; \\n        \\n        int cnt = 0;\\n        \\n        for(int k = 0; k < 8; k++) {\\n            int i = x + dx[k]; \\n            int j = y + dy[k]; \\n            if(safe(i, j)) {\\n                cnt = (cnt % mod + f(i, j, n - 1, dp) % mod) % mod; \\n            }\\n        }\\n        return dp[x][y][n] = cnt % mod; \\n    }\\n    \\n    int knightDialer(int n) {\\n        int cnt = 0; \\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(3, vector<int>(n + 1,-1))); \\n        \\n        for(int i = 0; i < 4; i++) {\\n            for(int j = 0; j < 3; j++) {\\n                cnt = (cnt % mod + f(i, j, n, dp) % mod) % mod; \\n            }\\n        }\\n        return cnt % mod; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893523,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "The problem can be solved by matrix power. Similar problems are\\n[70. Climbing Stairs ](https://leetcode.com/problems/climbing-stairs/discuss/929659/Evolve-from-brute-force-to-optimal)\\n[509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/discuss/989672/Evolve-from-intuition)\\n[552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/discuss/650804/Evolve-from-brute-force-to-optimal).\\n1. Brute force O(3^n), may be larger than O(2^n) since 4 and 6 have three next states. The last array is the start locations\\n```\\n\\tint[][] nxt={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4},{0,1,2,3,4,5,6,7,8,9}};\\n    public int knightDialer(int n) {\\n        return dfs(n,10);\\n    }\\n    private int dfs(int n, int num) {\\n        if(n==0) return 1;\\n        int tot=0;\\n        for(int next:nxt[num])\\n            tot+=dfs(n-1,next);\\n        return tot;\\n    }\\n```\\n2. Memoization O(n), mem[i][j] caches dfs(i,j). It means the number of ways starting at number j with i jumps to go.\\n```\\n\\tpublic int knightDialer(int n) {\\n        return dfs(n,10,new Integer[n+1][11])%1000000007;\\n    }\\n    private int dfs(int n, int num,Integer[][] mem) {\\n        if(n==0) return 1;\\n        if(mem[n][num]!=null) return mem[n][num];\\n        int tot=0;\\n        for(int next:nxt[num]) {\\n            tot=(tot+dfs(n-1,next,mem))%1000000007;\\n        }\\n        return mem[n][num]=tot;\\n    }\\n```\\n3. dp O(n) Time, O(n) Space. From #1 and #2, it is clear that dp[i][j] = sum(dp[i-1][k]), k=next[j].\\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] dp=new int[n+1][11];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<=n;i++)\\n            for(int j=0;j<=10;j++) \\n                for(int next:nxt[j]) \\n                    dp[i][j]=(dp[i][j]+dp[i-1][next])%1000000007;\\n        return dp[n][10];\\n    }\\n```\\n4. dp O(n) Time, constant space. In #3, dp[i] is computed from dp[i-1] only, so we only need to cache two rows.\\n```\\n\\tpublic int knightDialer(int n) {\\n        int[] pre=new int[11];\\n        Arrays.fill(pre,1);\\n        for(int i=1;i<=n;i++) {\\n            int[] cur=new int[11];\\n            for(int j=0;j<=10;j++)\\n                for(int nxt:next[j])\\n                    cur[j] = (cur[j]+pre[nxt])%1000000007;\\n            pre=cur;\\n        }\\n        return pre[10];\\n    }\\n```\\n5. State transition O(logn). There are only 10 numbers/states. Similar as above, the next state look up matrix can be represented as a 10x10 binary matrix. The matrix is extended to 10x10 because I want to use matrix multiplication to solve the problem. The ith row is the next states of i. The ith column is the states that jumps to i. Current state s={s0,s1,..s9} 1x10 times the 10x10 matrix gives the next state 1x10 s\\'={s0\\',s1\\'..s9\\'}. An entry s[i] in state vector means the number of ways that end at i. When it multiplies the matrix, it extracts the ith row and update the 1s to s\\'. Ex, the knight starts from 0 and takes 1 jump. We multiply {1,0...0} with the transition matrix and get {0,0,0,0,1,0,1,0,0,0} which is the first row of the matrix. Sum the vector is the total number of ways to take 1 jump from 0. In general, \\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] M = {{0,0,0,0,1,0,1,0,0,0},\\n                     {0,0,0,0,0,0,1,0,1,0},\\n                     {0,0,0,0,0,0,0,1,0,1},\\n                     {0,0,0,0,1,0,0,0,1,0},\\n                     {1,0,0,1,0,0,0,0,0,1},\\n                     {0,0,0,0,0,0,0,0,0,0},\\n                     {1,1,0,0,0,0,0,1,0,0},\\n                     {0,0,1,0,0,0,1,0,0,0},\\n                     {0,1,0,1,0,0,0,0,0,0},\\n                     {0,0,1,0,1,0,0,0,0,0}};\\n        M=pow(M,n-1);\\n        int sum=0;\\n        for(int i=0;i<N;i++)  \\n            for(int s:M[i])\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    int N=10, MOD=1000000007;\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint[][] nxt={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4},{0,1,2,3,4,5,6,7,8,9}};\\n    public int knightDialer(int n) {\\n        return dfs(n,10);\\n    }\\n    private int dfs(int n, int num) {\\n        if(n==0) return 1;\\n        int tot=0;\\n        for(int next:nxt[num])\\n            tot+=dfs(n-1,next);\\n        return tot;\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        return dfs(n,10,new Integer[n+1][11])%1000000007;\\n    }\\n    private int dfs(int n, int num,Integer[][] mem) {\\n        if(n==0) return 1;\\n        if(mem[n][num]!=null) return mem[n][num];\\n        int tot=0;\\n        for(int next:nxt[num]) {\\n            tot=(tot+dfs(n-1,next,mem))%1000000007;\\n        }\\n        return mem[n][num]=tot;\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] dp=new int[n+1][11];\\n        Arrays.fill(dp[0],1);\\n        for(int i=1;i<=n;i++)\\n            for(int j=0;j<=10;j++) \\n                for(int next:nxt[j]) \\n                    dp[i][j]=(dp[i][j]+dp[i-1][next])%1000000007;\\n        return dp[n][10];\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[] pre=new int[11];\\n        Arrays.fill(pre,1);\\n        for(int i=1;i<=n;i++) {\\n            int[] cur=new int[11];\\n            for(int j=0;j<=10;j++)\\n                for(int nxt:next[j])\\n                    cur[j] = (cur[j]+pre[nxt])%1000000007;\\n            pre=cur;\\n        }\\n        return pre[10];\\n    }\\n```\n```\\n\\tpublic int knightDialer(int n) {\\n        int[][] M = {{0,0,0,0,1,0,1,0,0,0},\\n                     {0,0,0,0,0,0,1,0,1,0},\\n                     {0,0,0,0,0,0,0,1,0,1},\\n                     {0,0,0,0,1,0,0,0,1,0},\\n                     {1,0,0,1,0,0,0,0,0,1},\\n                     {0,0,0,0,0,0,0,0,0,0},\\n                     {1,1,0,0,0,0,0,1,0,0},\\n                     {0,0,1,0,0,0,1,0,0,0},\\n                     {0,1,0,1,0,0,0,0,0,0},\\n                     {0,0,1,0,1,0,0,0,0,0}};\\n        M=pow(M,n-1);\\n        int sum=0;\\n        for(int i=0;i<N;i++)  \\n            for(int s:M[i])\\n                sum=(sum+s)%MOD;\\n        return sum;\\n    }\\n    int N=10, MOD=1000000007;\\n    private int[][] pow(int[][] M, int n) {\\n        int[][] A = new int[N][N];\\n        for(int i=0;i<N;i++) A[i][i]=1;\\n        while(n>0) {\\n            if((n&1)==1) A=mult(M,A);\\n            M=mult(M,M);\\n            n>>=1;\\n        }\\n        return A;\\n    }\\n    private int[][] mult(int[][] A, int[][] B) {\\n        int[][] C=new int[N][N];\\n        for(int i=0;i<N;i++) \\n            for(int j=0;j<N;j++)\\n                for(int k=0;k<N;k++)\\n                    C[i][j]=(int)((C[i][j]+(long)A[i][k]*B[k][j])%MOD);    \\n        return C;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526276,
                "title": "java-use-dfs",
                "content": "```\\n    private final static long mod = (long) Math.pow(10, 9) + 7;\\n    long[][][] res;\\n    public int knightDialer(int N) {\\n        res = new long[N+1][4][3];\\n        long s = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                s = (s + dfs(i, j, N)) % mod;\\n            }\\n        }\\n        return (int) s;\\n    }\\n    \\n    private long dfs(int i, int j, int cnt) {\\n        if (i < 0 || j < 0 || j > 2 || i > 3 || (i == 3 && j != 1)) return 0;\\n        if (res[cnt][i][j] > 0) return res[cnt][i][j];\\n        if (cnt == 1) return 1;\\n        res[cnt][i][j] = (dfs(i + 2, j + 1, cnt - 1)\\n            + dfs(i - 2, j + 1, cnt - 1)\\n            + dfs(i + 2, j - 1, cnt - 1)\\n            + dfs(i - 2, j - 1, cnt - 1)\\n            + dfs(i + 1, j + 2, cnt - 1)\\n            + dfs(i - 1, j + 2, cnt - 1)\\n            + dfs(i + 1, j - 2, cnt - 1)\\n            + dfs(i - 1, j - 2, cnt - 1)) % mod;\\n        return res[cnt][i][j];        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private final static long mod = (long) Math.pow(10, 9) + 7;\\n    long[][][] res;\\n    public int knightDialer(int N) {\\n        res = new long[N+1][4][3];\\n        long s = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                s = (s + dfs(i, j, N)) % mod;\\n            }\\n        }\\n        return (int) s;\\n    }\\n    \\n    private long dfs(int i, int j, int cnt) {\\n        if (i < 0 || j < 0 || j > 2 || i > 3 || (i == 3 && j != 1)) return 0;\\n        if (res[cnt][i][j] > 0) return res[cnt][i][j];\\n        if (cnt == 1) return 1;\\n        res[cnt][i][j] = (dfs(i + 2, j + 1, cnt - 1)\\n            + dfs(i - 2, j + 1, cnt - 1)\\n            + dfs(i + 2, j - 1, cnt - 1)\\n            + dfs(i - 2, j - 1, cnt - 1)\\n            + dfs(i + 1, j + 2, cnt - 1)\\n            + dfs(i - 1, j + 2, cnt - 1)\\n            + dfs(i + 1, j - 2, cnt - 1)\\n            + dfs(i - 1, j - 2, cnt - 1)) % mod;\\n        return res[cnt][i][j];        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1456762,
                "title": "c-dp-easy-solution-with-explanation",
                "content": "```\\nDiagram to show moves of a knight\\n\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\nFrom \\u2018k\\u2019 a knight can move to all positions marked with alphabet,\\nMore precisely from pos(i,j)=k all valid moves of knight are\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n\\n\\nWe can think of this problem as the total number of unique paths\\nthe knight can travel making n hops because to dial distinct numbers,\\nthe path taken by the knight must be unique.\\n\\nIn simple words\\n\"the total number of unique paths to (i, j) \\nfor certain hops n is equal to the sum of total number of unique paths\\nto each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nLet keypad be like \\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\na knight can jump to 8 possible places in a single hop .\\nHowever, 6 of the other hops will take you outside of the matrix.\\nYou will see later in the code how this is being handled as a part of base case.\\n\\nNaive Recursive Code:\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    long solve(int i,int j,int n)\\n    {\\n\\t\\t//Conditions to prevent edge cases of going out of matrix and preventing to move on ladt row\\'s 0th and 2nd column\\n\\t\\tif(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1)) \\n\\t\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        \\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n\\nIf you run this code for n = 50 you will realize that it takes at least an hour to get the answer.\\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems.\\nAnd answer for these overlapping subproblems \\nwe have calculated earlier so again and again we are doing same calculation and this is time consuming \\nA better way is to store the answer of the subproblem in an additional space ad before calculating\\nthe ans further first check if the ans for that subproblem is already present if yes,\\nuse that answer, this will prevent us from calculating  the same answer and if no\\ncalculate the answer and store it .This approach is called TOP DOWN DP\\n\\nWe use dynamic programming and store the solution of each subproblem in M.\\nM is a 3D array and each index of M corresponds to a solution of n. \\nEach n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    int dp[5001][4][3];\\n    long solve(int i,int j,int n)\\n    {\\n        if(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1))\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[n][i][j]!=-1)\\n            return dp[n][i][j];\\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return dp[n][i][j]=res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nDiagram to show moves of a knight\\n\\n*   *   *   *   *   *   *   *\\n*   *   *   *   *   *   *   *\\n*   *   b   *   c   *   *   *\\n*   a   *   *   *   d   *   *\\n*   *   *   k   *   *   *   *\\n*   h   *   *   *   e   *   *\\n*   *   g   *   f   *   *   *\\n*   *   *   *   *   *   *   *\\nFrom \\u2018k\\u2019 a knight can move to all positions marked with alphabet,\\nMore precisely from pos(i,j)=k all valid moves of knight are\\na (i - 1, j - 2)\\nb (i - 2, j - 1)\\nc (i - 2, j + 1)\\nd (i - 1, j + 2)\\ne (i + 1, j + 2)\\nf  (i + 2, j + 1)\\ng (i + 2, j - 1)\\nh (i + 1, j - 2)\\n\\n\\nWe can think of this problem as the total number of unique paths\\nthe knight can travel making n hops because to dial distinct numbers,\\nthe path taken by the knight must be unique.\\n\\nIn simple words\\n\"the total number of unique paths to (i, j) \\nfor certain hops n is equal to the sum of total number of unique paths\\nto each valid position from which (i, j) can be reached using n - 1 hops\".\\n\\nLet keypad be like \\n1   2   3\\n4   5   6\\n7   8   9\\n*   0   *\\na knight can jump to 8 possible places in a single hop .\\nHowever, 6 of the other hops will take you outside of the matrix.\\nYou will see later in the code how this is being handled as a part of base case.\\n\\nNaive Recursive Code:\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    long solve(int i,int j,int n)\\n    {\\n\\t\\t//Conditions to prevent edge cases of going out of matrix and preventing to move on ladt row\\'s 0th and 2nd column\\n\\t\\tif(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1)) \\n\\t\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        \\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n\\nIf you run this code for n = 50 you will realize that it takes at least an hour to get the answer.\\n\\nThis is because this problem not only has similar subproblems but each of those similar subproblems have overlapping subproblems.\\nAnd answer for these overlapping subproblems \\nwe have calculated earlier so again and again we are doing same calculation and this is time consuming \\nA better way is to store the answer of the subproblem in an additional space ad before calculating\\nthe ans further first check if the ans for that subproblem is already present if yes,\\nuse that answer, this will prevent us from calculating  the same answer and if no\\ncalculate the answer and store it .This approach is called TOP DOWN DP\\n\\nWe use dynamic programming and store the solution of each subproblem in M.\\nM is a 3D array and each index of M corresponds to a solution of n. \\nEach n is again stored as a 2D array for (i, j) values.\\n\\nAll this combined, M will store the solution of each paths(i, j, n) call.\\n\\n\\nclass Solution {\\npublic:\\n    int mod=pow(10,9)+7;\\n    int dp[5001][4][3];\\n    long solve(int i,int j,int n)\\n    {\\n        if(i>=4 or i<0 or j>=3 or j<0 or (i==3 and j!=1))\\n            return 0;\\n        \\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[n][i][j]!=-1)\\n            return dp[n][i][j];\\n        int res=   ( solve(i - 1, j - 2,n-1)%mod+\\n                    solve(i - 2, j - 1,n-1)%mod+\\n                    solve(i - 2, j + 1,n-1)%mod+\\n                    solve(i - 1, j + 2,n-1)%mod+\\n                    solve(i + 1, j + 2,n-1)%mod+\\n                    solve(i + 2, j + 1,n-1)%mod+\\n                    solve(i + 2, j - 1,n-1)%mod+\\n                    solve(i + 1, j - 2,n-1)%mod)%mod;\\n            \\n            return dp[n][i][j]=res;\\n    }\\n    int knightDialer(int n) {\\n        long count=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(i==3 and j!=1)\\n                    continue;\\n                count=(count+solve(i,j,n))%mod;\\n            }\\n        }\\n        return   int(count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289217,
                "title": "c-with-explanation-2-approaches-dp-and-memoization-o-n",
                "content": "*Idea for both Approaches (Memoization and DP)*\\nSay we have to find the number of possible combinations of length n starting from 0. Then this is the same as the sum of number of combinations of length n-1 from 4 +6 as from 0 , the knight can hop to 4 and 6. Create a vector of possible hops where the index represents soucre and the vector represents possible hops and apply this logic.\\nTime Complexity: O(10n)=O(n) for both Approaches\\nSpace Compelxity->O(10n)=O(n) for both Approaches\\n\\n**Approach-1** (Memoization)\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int helper(int x, int n,vector<vector<int>>&dp)\\n    {\\n        if(n==1)\\n        {\\n            return dp[n][x]=1;\\n        }\\n        if(dp[n][x]!=-1)\\n        {\\n            return dp[n][x];\\n        }\\n        dp[n][x]=0;\\n        for(auto nextSquare:v[x])\\n        {\\n            dp[n][x]=(dp[n][x]+helper(nextSquare,n-1,dp))%mod;\\n        }\\n        return dp[n][x];\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            ans=(ans+helper(i,n,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach-2** (DP)\\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,0));\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                for(auto nextSquare:v[j])\\n                {\\n                    dp[i][j]=(dp[i][j]+dp[i-1][nextSquare])%mod;\\n                }\\n            }\\n        }\\n        for(int j=0;j<10;j++)\\n        {\\n            ans=(ans+dp[n][j])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int helper(int x, int n,vector<vector<int>>&dp)\\n    {\\n        if(n==1)\\n        {\\n            return dp[n][x]=1;\\n        }\\n        if(dp[n][x]!=-1)\\n        {\\n            return dp[n][x];\\n        }\\n        dp[n][x]=0;\\n        for(auto nextSquare:v[x])\\n        {\\n            dp[n][x]=(dp[n][x]+helper(nextSquare,n-1,dp))%mod;\\n        }\\n        return dp[n][x];\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        int ans=0;\\n        for(int i=0;i<10;i++)\\n        {\\n            ans=(ans+helper(i,n,dp))%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<vector<int>>v={{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>>dp(n+1,vector<int>(10,0));\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=0;j<10;j++)\\n            {\\n                if(i==1)\\n                {\\n                    dp[i][j]=1;\\n                    continue;\\n                }\\n                for(auto nextSquare:v[j])\\n                {\\n                    dp[i][j]=(dp[i][j]+dp[i-1][nextSquare])%mod;\\n                }\\n            }\\n        }\\n        for(int j=0;j<10;j++)\\n        {\\n            ans=(ans+dp[n][j])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985146,
                "title": "using-recursion-top-down-dp-cpp",
                "content": "# Intuition\\nrecursive and dp\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n```\\n// recursive code\\n```\\nll solve(int val, int n, vector<vector<int>> &arr)\\n{\\n    if (n == 0)\\n    {\\n        return 0;\\n    }\\n\\n    if (n == 1)\\n    {\\n        return 1;\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[val].size(); i++)\\n    {\\n        ans += solve(arr[val][i], n - 1, arr);\\n    }\\n    return ans;\\n}\\n\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> arr(10);\\n    arr[0] = {4, 6};\\n    arr[1] = {6, 8};\\n    arr[2] = {7, 9};\\n    arr[3] = {4, 8};\\n    arr[4] = {0, 3, 9};\\n    arr[5] = {};\\n    arr[6] = {0, 1, 7};\\n\\n    arr[7] = {2, 6};\\n    arr[8] = {1, 3};\\n    arr[9] = {2, 4};\\n\\n    ll ans = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n\\n        ans += solve(i, n, arr);\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n\\n```\\n// top down dp\\n\\n```\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> a = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n    int mod = 1e9 + 7;\\n    long long int ans = 0;\\n    vector<vector<long long int>> dp(n + 1, vector<long long int>(10, 0));\\n    for (int i = 0; i < 10; i++)\\n        dp[1][i] = 1;\\n\\n    for (int i = 2; i < n + 1; i++)\\n        for (int j = 0; j < 10; j++)\\n        {\\n            for (int k = 0; k < a[j].size(); k++)\\n                dp[i][j] += dp[i - 1][a[j][k]];\\n            dp[i][j] %= mod;\\n        }\\n\\n    for (auto x : dp[n])\\n        ans += x;\\n\\n    return ans % mod;\\n}\\n\\n```\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n```\n```\\nll solve(int val, int n, vector<vector<int>> &arr)\\n{\\n    if (n == 0)\\n    {\\n        return 0;\\n    }\\n\\n    if (n == 1)\\n    {\\n        return 1;\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[val].size(); i++)\\n    {\\n        ans += solve(arr[val][i], n - 1, arr);\\n    }\\n    return ans;\\n}\\n\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> arr(10);\\n    arr[0] = {4, 6};\\n    arr[1] = {6, 8};\\n    arr[2] = {7, 9};\\n    arr[3] = {4, 8};\\n    arr[4] = {0, 3, 9};\\n    arr[5] = {};\\n    arr[6] = {0, 1, 7};\\n\\n    arr[7] = {2, 6};\\n    arr[8] = {1, 3};\\n    arr[9] = {2, 4};\\n\\n    ll ans = 0;\\n    for (int i = 0; i < 10; i++)\\n    {\\n\\n        ans += solve(i, n, arr);\\n        ans %= mod;\\n    }\\n    return ans;\\n}\\n\\n```\n```\\nint knightDialer(int n)\\n{\\n    vector<vector<int>> a = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n    int mod = 1e9 + 7;\\n    long long int ans = 0;\\n    vector<vector<long long int>> dp(n + 1, vector<long long int>(10, 0));\\n    for (int i = 0; i < 10; i++)\\n        dp[1][i] = 1;\\n\\n    for (int i = 2; i < n + 1; i++)\\n        for (int j = 0; j < 10; j++)\\n        {\\n            for (int k = 0; k < a[j].size(); k++)\\n                dp[i][j] += dp[i - 1][a[j][k]];\\n            dp[i][j] %= mod;\\n        }\\n\\n    for (auto x : dp[n])\\n        ans += x;\\n\\n    return ans % mod;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1544986,
                "title": "python-simple-dp-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n        \\n        \\n        for _ in range(n-1):\\n            dp = [0 for _ in range(10)]\\n            dp[0] = arr[5] + arr[7]\\n            dp[1] = arr[6] + arr[8]\\n            dp[2] = arr[3] + arr[7]\\n            dp[3] = arr[2] + arr[8] + arr[9]\\n            dp[4] = 0\\n            dp[5] = arr[0] + arr[6] + arr[9]\\n            dp[6] = arr[1] + arr[5]\\n            dp[7] = arr[0] + arr[2]\\n            dp[8] = arr[1] + arr[3]\\n            dp[9] = arr[3] + arr[5]\\n            arr = dp\\n        return sum(arr) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n        \\n        \\n        for _ in range(n-1):\\n            dp = [0 for _ in range(10)]\\n            dp[0] = arr[5] + arr[7]\\n            dp[1] = arr[6] + arr[8]\\n            dp[2] = arr[3] + arr[7]\\n            dp[3] = arr[2] + arr[8] + arr[9]\\n            dp[4] = 0\\n            dp[5] = arr[0] + arr[6] + arr[9]\\n            dp[6] = arr[1] + arr[5]\\n            dp[7] = arr[0] + arr[2]\\n            dp[8] = arr[1] + arr[3]\\n            dp[9] = arr[3] + arr[5]\\n            arr = dp\\n        return sum(arr) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292870,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {   \\n    int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        long dp[] = new long[10];\\n        Arrays.fill(dp , 1);\\n        long ans = 0;\\n        for(int i = 1 ; i < N ; i++) {\\n            long temp[] = new long[10];\\n            temp[0] = (dp[4]+dp[6]) % MOD;\\n            temp[1] = (dp[6]+dp[8]) % MOD;\\n            temp[2] = (dp[7]+dp[9]) % MOD;\\n            temp[3] = (dp[4]+dp[8]) % MOD;\\n            temp[4] = (((dp[0]+dp[3]) % MOD)+dp[9])%MOD;\\n            temp[6] = (((dp[0]+dp[1]) % MOD)+dp[7])%MOD;\\n            temp[7] = (dp[2]+dp[6])%MOD;\\n            temp[8] = (dp[1]+dp[3])%MOD;\\n            temp[9] = (dp[4]+dp[2])%MOD;\\n            dp = temp;\\n        }\\n        for(long val : dp) \\n            ans = (ans + val) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {   \\n    int MOD = 1000000007;\\n    public int knightDialer(int N) {\\n        long dp[] = new long[10];\\n        Arrays.fill(dp , 1);\\n        long ans = 0;\\n        for(int i = 1 ; i < N ; i++) {\\n            long temp[] = new long[10];\\n            temp[0] = (dp[4]+dp[6]) % MOD;\\n            temp[1] = (dp[6]+dp[8]) % MOD;\\n            temp[2] = (dp[7]+dp[9]) % MOD;\\n            temp[3] = (dp[4]+dp[8]) % MOD;\\n            temp[4] = (((dp[0]+dp[3]) % MOD)+dp[9])%MOD;\\n            temp[6] = (((dp[0]+dp[1]) % MOD)+dp[7])%MOD;\\n            temp[7] = (dp[2]+dp[6])%MOD;\\n            temp[8] = (dp[1]+dp[3])%MOD;\\n            temp[9] = (dp[4]+dp[2])%MOD;\\n            dp = temp;\\n        }\\n        for(long val : dp) \\n            ans = (ans + val) % MOD;\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241911,
                "title": "js-dp-based-solution-o-n-with-explanation-78",
                "content": "```\\nvar knightDialer = function(n) {\\n\\n\\t// if n equals 1, 10 number can be formed, that is with each digit\\n    if(n === 1) {\\n        return 10;\\n    }\\n    const mod = 1000000007;\\n\\t\\n\\t// since knight can move in 8 directions, in the dialpad, we know what positions the knight can move when we start from a digit\\n\\t// created the map of those positions that can be moved from key `num`\\n    const map = {1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9],\\n                 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4], 0: [4,6]};\\n    \\n\\t// create a dp array of size - 10 * (n + 1), initialize with 0\\n    const dp = Array(10).fill(null).map(() => Array(n + 1).fill(0));\\n\\t\\n\\t//initialize the dp array for each num and n = 1 and n = 2 \\n    let total = 0;\\n    for(let num = 0; num <= 9; ++num) {\\n        dp[num][1] = 1;\\n        dp[num][2] = map[num].length;\\n        if(n === 2) {\\n            total += dp[num][2];\\n        }\\n    }\\n\\t\\n\\t// if n > 2, we calculate the total numbers that can be formed from each digit when we start from it\\n\\t// `total` will be summation of all the numbers which we will return\\n    for(let i = 3; i <= n; ++i) {\\n        for(let num = 0; num <= 9; ++num) {\\n\\t\\t\\n\\t\\t\\t/* the number of digits that can be formed starting with `num` equals the sum of the number of digits that can be formed by the digits which are reachable from `num`\\n\\t\\t\\tfor instance, for n = 3 and num = 1, `16` and `18` are two 2 digit number. \\n\\t\\t\\tin order to get the 3 digit numbers starting with `1`, we need to check the digits reachable from 6 and 8\\n\\t\\t\\tfor `6` we check all the 2 digit numbers - 3 (0,1,7), and for `8` = 2 (1,3)\\n\\t\\t\\tthat is,\\n\\t\\t\\tdp[1][3] = dp[6][2] + dp[8][2]\\n\\t\\t\\tdp[6][2] = 3\\n\\t\\t\\tdp[8][2] = 2\\n\\t\\t\\t=> dp[1][3] = 5 (phone numbers - 160, 161, 167, 181, 183)\\n\\t\\t\\t*/\\n            map[num].forEach(d => dp[num][i] = (dp[num][i] + dp[d][i - 1]) % mod);\\n            if(i === n) {\\n                total = (total + dp[num][i]) % mod;\\n            }\\n        }    \\n    }\\n    return total;\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(n)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar knightDialer = function(n) {\\n\\n\\t// if n equals 1, 10 number can be formed, that is with each digit\\n    if(n === 1) {\\n        return 10;\\n    }\\n    const mod = 1000000007;\\n\\t\\n\\t// since knight can move in 8 directions, in the dialpad, we know what positions the knight can move when we start from a digit\\n\\t// created the map of those positions that can be moved from key `num`\\n    const map = {1: [6,8], 2: [7,9], 3: [4,8], 4: [0,3,9],\\n                 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4], 0: [4,6]};\\n    \\n\\t// create a dp array of size - 10 * (n + 1), initialize with 0\\n    const dp = Array(10).fill(null).map(() => Array(n + 1).fill(0));\\n\\t\\n\\t//initialize the dp array for each num and n = 1 and n = 2 \\n    let total = 0;\\n    for(let num = 0; num <= 9; ++num) {\\n        dp[num][1] = 1;\\n        dp[num][2] = map[num].length;\\n        if(n === 2) {\\n            total += dp[num][2];\\n        }\\n    }\\n\\t\\n\\t// if n > 2, we calculate the total numbers that can be formed from each digit when we start from it\\n\\t// `total` will be summation of all the numbers which we will return\\n    for(let i = 3; i <= n; ++i) {\\n        for(let num = 0; num <= 9; ++num) {\\n\\t\\t\\n\\t\\t\\t/* the number of digits that can be formed starting with `num` equals the sum of the number of digits that can be formed by the digits which are reachable from `num`\\n\\t\\t\\tfor instance, for n = 3 and num = 1, `16` and `18` are two 2 digit number. \\n\\t\\t\\tin order to get the 3 digit numbers starting with `1`, we need to check the digits reachable from 6 and 8\\n\\t\\t\\tfor `6` we check all the 2 digit numbers - 3 (0,1,7), and for `8` = 2 (1,3)\\n\\t\\t\\tthat is,\\n\\t\\t\\tdp[1][3] = dp[6][2] + dp[8][2]\\n\\t\\t\\tdp[6][2] = 3\\n\\t\\t\\tdp[8][2] = 2\\n\\t\\t\\t=> dp[1][3] = 5 (phone numbers - 160, 161, 167, 181, 183)\\n\\t\\t\\t*/\\n            map[num].forEach(d => dp[num][i] = (dp[num][i] + dp[d][i - 1]) % mod);\\n            if(i === n) {\\n                total = (total + dp[num][i]) % mod;\\n            }\\n        }    \\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705341,
                "title": "c-easy-solution-with-diagram",
                "content": "**Key Idea** : \\n\\nGiven you are at a position on the keypad, find all keys from where you can reach the current position. \\n\\nFor eg: 1 can be reached by a knight\\'s move from 8 and 6. Also, if you can get to 1 from 6, you can also get to 6 from 1. \\n\\n5 is a special case. It can not be reached from any key. There is no way to reach 5 other than starting out at 5.\\n\\nYou can then construct a undirected graph as below. \\n\\n![image](https://assets.leetcode.com/users/images/e5392c69-0e3d-4608-bd06-85fed7f56f34_1593109968.5285418.png)\\n\\n\\nOnce you have the adjaceny-graph, the following dp recurssion formula can be applied for all r from [1...N]: \\n```\\nfor (auto & prev : graph[curr]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD\\n```\\n\\n**Optimization**:\\n\\nOnce you have the solution using the Nx10 matrix, you can collapse the Nx10 matrix to 2x10 matrix, since for evaluting a row \\'r\\' in the Nx10 matrix we use only values from row \\'r-1\\'. You can therefore then cyclically use the 2x10 matrix to evaluate all the rows in the Nx10 matrix.\\n\\n**Solution**: \\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n\\n        int MOD = 1e9+7;\\n        \\n        vector<vector<int>> dp (N+1, vector<int> (10,0)); \\n        \\n        int rows = dp.size(); // numbers\\n        int cols = dp[0].size(); // cols\\n        \\n        for (int c = 0; c < cols; c++) {\\n            dp[1][c] = 1;\\n        }\\n        \\n        vector<vector<int>> graph =  {{4,6},   // 0 -> 4,6\\n                                      {8,6},   // 1 -> 6,8 \\n                                      {7,9},   // 2 -> 7,9\\n                                      {8,4},   // 3 -> 4,8\\n                                      {3,9,0}, // 4 -> 0,3,9\\n                                      {},      // 5 -> empty\\n                                      {1,0,7}, // 6 -> 0,1,7\\n                                      {6,2},   // 7 -> 2,6\\n                                      {1,3},   // 8 -> 1,3\\n                                      {4,2}};  // 9 -> 4,2\\n\\n        \\n        for (int r = 2; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                 dp[r][c] = 0; \\n                 for (auto & prev : graph[c]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD;\\n                 }\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int j=0; j<10; j++) \\n\\t\\t\\tresult = (result + dp[N][j]) % MOD; \\n                                 \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor (auto & prev : graph[curr]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD\\n```\n```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n\\n        int MOD = 1e9+7;\\n        \\n        vector<vector<int>> dp (N+1, vector<int> (10,0)); \\n        \\n        int rows = dp.size(); // numbers\\n        int cols = dp[0].size(); // cols\\n        \\n        for (int c = 0; c < cols; c++) {\\n            dp[1][c] = 1;\\n        }\\n        \\n        vector<vector<int>> graph =  {{4,6},   // 0 -> 4,6\\n                                      {8,6},   // 1 -> 6,8 \\n                                      {7,9},   // 2 -> 7,9\\n                                      {8,4},   // 3 -> 4,8\\n                                      {3,9,0}, // 4 -> 0,3,9\\n                                      {},      // 5 -> empty\\n                                      {1,0,7}, // 6 -> 0,1,7\\n                                      {6,2},   // 7 -> 2,6\\n                                      {1,3},   // 8 -> 1,3\\n                                      {4,2}};  // 9 -> 4,2\\n\\n        \\n        for (int r = 2; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                 dp[r][c] = 0; \\n                 for (auto & prev : graph[c]) {\\n                     dp[r][c] = (dp[r][c] + dp[r-1][prev])%MOD;\\n                 }\\n            }\\n        }\\n        \\n        int result = 0;\\n        \\n        for(int j=0; j<10; j++) \\n\\t\\t\\tresult = (result + dp[N][j]) % MOD; \\n                                 \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313285,
                "title": "c-recursion-memoization",
                "content": "we just have to traverse dial pad one by one and at each num we use dfs to count the number.\\n**\"we don\\'t need to make matrix\"**\\n```\\nclass Solution {\\npublic:\\n    int dp[5][4][5001];\\n    int mod=1000000007;\\n    int solve(int k,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=4 || j>=3 || (i==3 && (j==0 || j==2)))                            //5th OR cond for * and # (:\\n            return 0;\\n        if(k==1)\\n            return 1;\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        int a=solve(k-1,i+1,j-2)%mod;\\n            a=(a+solve(k-1,i+1,j+2))%mod;\\n            a=(a+solve(k-1,i+2,j-1))%mod;\\n            a=(a+solve(k-1,i+2,j+1))%mod;\\n            a=(a+solve(k-1,i-1,j-2))%mod;\\n            a=(a+solve(k-1,i-1,j+2))%mod;\\n            a=(a+solve(k-1,i-2,j-1))%mod;\\n            a=(a+solve(k-1,i-2,j+1))%mod;\\n            \\n        return dp[i][j][k]=a;\\n    }\\n    int knightDialer(int n)\\n    {\\n       int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n       for(int i=0;i<4;i++)                                                       // dial Pad\\n           for(int j=0;j<3;j++)\\n               ans=(ans+solve(n,i,j))%mod;\\n        return ans;\\n    }\\n};\\n\\n// Feel free to ask any doubt in comment section",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[5][4][5001];\\n    int mod=1000000007;\\n    int solve(int k,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=4 || j>=3 || (i==3 && (j==0 || j==2)))                            //5th OR cond for * and # (:\\n            return 0;\\n        if(k==1)\\n            return 1;\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        int a=solve(k-1,i+1,j-2)%mod;\\n            a=(a+solve(k-1,i+1,j+2))%mod;\\n            a=(a+solve(k-1,i+2,j-1))%mod;\\n            a=(a+solve(k-1,i+2,j+1))%mod;\\n            a=(a+solve(k-1,i-1,j-2))%mod;\\n            a=(a+solve(k-1,i-1,j+2))%mod;\\n            a=(a+solve(k-1,i-2,j-1))%mod;\\n            a=(a+solve(k-1,i-2,j+1))%mod;\\n            \\n        return dp[i][j][k]=a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2171762,
                "title": "python-math-t-m-98-96",
                "content": "```\\nclass Solution:\\n            # Consider this partition of an iteration based on last digits. In this \\n\\t\\t\\t# iretation, the four elements are a, b, c, d, where:\\n            #                   a: 1,3,7,9    b: 4,6    c: 2,8    d: 0\\n\\t\\t\\t#(Note that 5 only matters when n = 1) \\n\\t\\t\\t# For example,\\n\\t\\t\\t#      For n = 1:  len(a) = 4, len(b) = 2, len(c) = 2, len(d) = 1. Sum  is 10  (See Ex 1)\\n\\t\\t\\t#      For n = 2:  len(a) = 8, len(b) = 6, len(c) = 4, len(d) = 2. Sum  is 20  (See Ex 2)\\n\\t\\t\\t#\\n            # In general, in the next interation,  the count in each element of the partition is \\n\\t\\t\\t# determined by the counts in the current iteration.  For example,\\n\\t\\t\\t#                   new_a = 2 x old_b + 2 x old_c.\\n\\t\\t\\t# the other relations are below in the code.\\n\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1: return 10        # edge case\\n        N = 10**9+7\\n        v = [4, 2, 2, 1]            # n = 1: four in a, two in b, etc\\n        for _ in range(n-1):        # iterate n-1 times (since we start at n=1)\\n            a,b,c,d  = v\\n            v = [(2*b+2*c)%N, (a+2*d)%N, a, b]\\n        return sum(v)%N",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n            # Consider this partition of an iteration based on last digits. In this \\n\\t\\t\\t# iretation, the four elements are a, b, c, d, where:\\n            #                   a: 1,3,7,9    b: 4,6    c: 2,8    d: 0\\n\\t\\t\\t#(Note that 5 only matters when n = 1) \\n\\t\\t\\t# For example,\\n\\t\\t\\t#      For n = 1:  len(a) = 4, len(b) = 2, len(c) = 2, len(d) = 1. Sum  is 10  (See Ex 1)\\n\\t\\t\\t#      For n = 2:  len(a) = 8, len(b) = 6, len(c) = 4, len(d) = 2. Sum  is 20  (See Ex 2)\\n\\t\\t\\t#\\n            # In general, in the next interation,  the count in each element of the partition is \\n\\t\\t\\t# determined by the counts in the current iteration.  For example,\\n\\t\\t\\t#                   new_a = 2 x old_b + 2 x old_c.\\n\\t\\t\\t# the other relations are below in the code.\\n\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1: return 10        # edge case\\n        N = 10**9+7\\n        v = [4, 2, 2, 1]            # n = 1: four in a, two in b, etc\\n        for _ in range(n-1):        # iterate n-1 times (since we start at n=1)\\n            a,b,c,d  = v\\n            v = [(2*b+2*c)%N, (a+2*d)%N, a, b]\\n        return sum(v)%N",
                "codeTag": "Java"
            },
            {
                "id": 1594768,
                "title": "easy-recursion-solutinon-cpp-memoziation",
                "content": "**UPVOTE ME IF THIS IS HELPFULL AND COMMENT FOR DOUBTS \\nTHIS SIDE MOHIT.KOTA || HAPPY CODING TO ALL CODERS **\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long solve(int x,int y,int n,long hash[][4][3])\\n    { \\n        // checking whether the postion is a valid postion or not \\n        if(x<0 || y<0 || x>=4 || y>=3 || (x==3 && y==0)||(x==3 &&y==2))\\n        {\\n            return 0;\\n        }\\n        if(n==1)  // if n==1 then we can only move 1 step so return the same \\n        {\\n            return 1;\\n        }\\n        if(hash[n][x][y]>0) // taking hash as 3D array which helps to store previous result \\n        {\\n            // if it exists we can just return the same \\n            return hash[n][x][y];\\n        }\\n        int mod=1000000007; //to make sure that our answer is in range  \\n        /*\\n                    this below step is crucial one because we have only \\n                    8 direction\\'s to move to any other cell/in keypad so\\n                    just check that below one you can get a clear cut note \\\\\\n                    what i was doing ;;\\n                    just take a paper and pen and try to observe the step\\'s \\n                    you can get it easily\\'\\'\\'             \\n        */\\n        long ans= solve(x-1,y+2,n-1,hash)%mod+ \\n            solve(x+1,y+2,n-1,hash)%mod+\\n            solve(x-1,y-2,n-1,hash)%mod+\\n            solve(x+1,y-2,n-1,hash)%mod+\\n            solve(x+2,y+1,n-1,hash)%mod+\\n            solve(x+2,y-1,n-1,hash)%mod+\\n            solve(x-2,y+1,n-1,hash)%mod+\\n            solve(x-2,y-1,n-1,hash)%mod;\\n        hash[n][x][y]=ans;\\n        \\n        return ans%mod;\\n            \\n    }   \\n    int knightDialer(int n) \\n    {\\n        long hash[n+1][4][3];\\n        memset(hash,0,sizeof(hash)); //making the arr to zeroes\\n        long ans = 0;\\n        int mod = 1000000007;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                ans = (ans+solve(i,j,n,hash))%mod;   // calculating answere for every cell \\n            }\\n        }\\n        return (ans)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long solve(int x,int y,int n,long hash[][4][3])\\n    { \\n        // checking whether the postion is a valid postion or not \\n        if(x<0 || y<0 || x>=4 || y>=3 || (x==3 && y==0)||(x==3 &&y==2))\\n        {\\n            return 0;\\n        }\\n        if(n==1)  // if n==1 then we can only move 1 step so return the same \\n        {\\n            return 1;\\n        }\\n        if(hash[n][x][y]>0) // taking hash as 3D array which helps to store previous result \\n        {\\n            // if it exists we can just return the same \\n            return hash[n][x][y];\\n        }\\n        int mod=1000000007; //to make sure that our answer is in range  \\n        /*\\n                    this below step is crucial one because we have only \\n                    8 direction\\'s to move to any other cell/in keypad so\\n                    just check that below one you can get a clear cut note \\\\\\n                    what i was doing ;;\\n                    just take a paper and pen and try to observe the step\\'s \\n                    you can get it easily\\'\\'\\'             \\n        */\\n        long ans= solve(x-1,y+2,n-1,hash)%mod+ \\n            solve(x+1,y+2,n-1,hash)%mod+\\n            solve(x-1,y-2,n-1,hash)%mod+\\n            solve(x+1,y-2,n-1,hash)%mod+\\n            solve(x+2,y+1,n-1,hash)%mod+\\n            solve(x+2,y-1,n-1,hash)%mod+\\n            solve(x-2,y+1,n-1,hash)%mod+\\n            solve(x-2,y-1,n-1,hash)%mod;\\n        hash[n][x][y]=ans;\\n        \\n        return ans%mod;\\n            \\n    }   \\n    int knightDialer(int n) \\n    {\\n        long hash[n+1][4][3];\\n        memset(hash,0,sizeof(hash)); //making the arr to zeroes\\n        long ans = 0;\\n        int mod = 1000000007;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                ans = (ans+solve(i,j,n,hash))%mod;   // calculating answere for every cell \\n            }\\n        }\\n        return (ans)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270845,
                "title": "python-o-logn-100-with-explanation",
                "content": "I used to ask this question for virtually every phone screen, so I\\'ve seen this done well over a hundred times at this point. I also know the absolute *best* solution for it and this is it.\\n- create a numpy matrix representing 1 move\\n- we subtract 1 from `n` because the the number of moves is the length of the string minus 1\\n- multiplying that move matrix by itself represents 2 moves\\n- doing that `n` times, represents `2**n` moves\\n- we initialize our answer as a `1x10` vector of ones (ie one move on each square)\\n- for each power of 2, if that power of 2 is in `n`, we add it to our answer\\n- then we create the next power of 2 by multiplying it by itself\\n- we also mod by `10**9 + 7` because the question says so\\n```\\nimport numpy as np\\nMOD = (10**9 + 7)\\noneMove = np.zeros((10, 10), dtype=np.int64)\\nfor i, j in ((1, 8), (1, 6), (2, 7), (2, 9), (3, 4), (3, 8), (4, 9), (4, 0), (6, 7), (6, 0)):\\n    oneMove[i][j] = 1\\n    oneMove[j][i] = 1\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        n -= 1\\n        currMove = oneMove\\n        sumMoves = np.ones((10,), dtype=np.int64)\\n        while n > 0:\\n            if n & 1:\\n                sumMoves = np.matmul(sumMoves, currMove)\\n                sumMoves = np.mod(sumMoves, MOD)\\n            n >>= 1\\n            if n > 0:\\n                currMove = np.matmul(currMove, currMove)\\n                currMove = np.mod(currMove, MOD)\\n        return np.sum(sumMoves) % MOD\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nMOD = (10**9 + 7)\\noneMove = np.zeros((10, 10), dtype=np.int64)\\nfor i, j in ((1, 8), (1, 6), (2, 7), (2, 9), (3, 4), (3, 8), (4, 9), (4, 0), (6, 7), (6, 0)):\\n    oneMove[i][j] = 1\\n    oneMove[j][i] = 1\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        n -= 1\\n        currMove = oneMove\\n        sumMoves = np.ones((10,), dtype=np.int64)\\n        while n > 0:\\n            if n & 1:\\n                sumMoves = np.matmul(sumMoves, currMove)\\n                sumMoves = np.mod(sumMoves, MOD)\\n            n >>= 1\\n            if n > 0:\\n                currMove = np.matmul(currMove, currMove)\\n                currMove = np.mod(currMove, MOD)\\n        return np.sum(sumMoves) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399690,
                "title": "10-lines-super-concise-java-solution-beat-98-in-speed-with-explanation",
                "content": "There is no need to do DP for each specific digit. Classifying them into different sets.\\n\\n```\\npublic int knightDialer(int N) {\\n\\t// In total, 10 digits can be classified into four sets: A: {1,3,7,9}, B: {4,6}, C: {2,8}, D: {0}. \\n\\t// The digits within the same set are symmetric and hence no need to further distinguish them.\\n\\t// s(n) = 4*a(n) + 2*b(n) + 2*c(n) + d(n); s(n) means total number of distinct numbers\\n\\t//     E.g. a(n) means total number of distinct numbers when starting with numbers in set A.\\n\\t// Recursive formula: a(n) = b(n-1) + c(n-1); b(n) = 2*a(n-1) + d(n-1); c(n) = 2*a(n-1); d(n) = 2*b(n-1);\\n\\t// Base case: n = 1 -> a=b=c=d=1\\n\\tif (N == 1) return 10;\\n\\tlong a=1L, b=1L, c=1L, d=1L; // N=1 base case\\n\\tlong na, nb, nc, nd;\\n\\tfor (int i = 2; i <= N; i++) {\\n\\t\\tna = b + c;\\n\\t\\tnb = 2 * a + d;\\n\\t\\tnc = 2 * a;\\n\\t\\tnd = 2 * b;\\n\\t\\ta = na % (1000000007L); b = nb % (1000000007L); c = nc % (1000000007L); d = nd % (1000000007L);\\n\\t}\\n\\treturn (int)((4 * a + 2 * b + 2 * c + d) % (1000000007L));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int knightDialer(int N) {\\n\\t// In total, 10 digits can be classified into four sets: A: {1,3,7,9}, B: {4,6}, C: {2,8}, D: {0}. \\n\\t// The digits within the same set are symmetric and hence no need to further distinguish them.\\n\\t// s(n) = 4*a(n) + 2*b(n) + 2*c(n) + d(n); s(n) means total number of distinct numbers\\n\\t//     E.g. a(n) means total number of distinct numbers when starting with numbers in set A.\\n\\t// Recursive formula: a(n) = b(n-1) + c(n-1); b(n) = 2*a(n-1) + d(n-1); c(n) = 2*a(n-1); d(n) = 2*b(n-1);\\n\\t// Base case: n = 1 -> a=b=c=d=1\\n\\tif (N == 1) return 10;\\n\\tlong a=1L, b=1L, c=1L, d=1L; // N=1 base case\\n\\tlong na, nb, nc, nd;\\n\\tfor (int i = 2; i <= N; i++) {\\n\\t\\tna = b + c;\\n\\t\\tnb = 2 * a + d;\\n\\t\\tnc = 2 * a;\\n\\t\\tnd = 2 * b;\\n\\t\\ta = na % (1000000007L); b = nb % (1000000007L); c = nc % (1000000007L); d = nd % (1000000007L);\\n\\t}\\n\\treturn (int)((4 * a + 2 * b + 2 * c + d) % (1000000007L));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338833,
                "title": "c-top-down-with-memo-o-n-easy",
                "content": "**Intuition:** Think of every number as a state (0 to 9). You can move from one state to another just like a knight moves on a chessboard. This information is enough to find the states you can go to from a given state. You can start from any state.\\n\\nI stored the state information in a 2D vector. Now, when I start on a state, I know exactly where all I can go with the help of the 2D vector. When I move from one state to another I reduce N by 1.\\n\\nSolve the question using recursion first. You\\'ll find your solution TLE before N = 16 or so.\\nDraw the recursion tree, you\\'ll find that it has overlapping subproblems, so memoize them.\\n\\nCODE:\\n\\n```\\nvector<vector<int>> states = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\nint knh(int state, int n, vector<vector<int>> &dp){\\nif(n == 0) return 1; // base case\\nint total = 0;\\n\\nif(dp[state][n] != -1)\\nreturn dp[state][n]; //using memo table\\n\\nfor(int j = 0 ; j < states[state].size() ; j++) // for going through all states you can go\\n    total = (total + knh(states[state][j],n-1,dp)) %1000000007 ; // to from the current state\\n\\nreturn dp[state][n] = total; //memoize\\n}\\n\\nint kn(int n)\\n{\\n    vector<vector<int>> dp (10, vector<int>(n,-1));\\n    int ans = 0;\\n    for(int i = 0 ; i <= 9 ; i++) // As you can start from any state (between 0 to 9)\\n        ans = (ans + knh(i,n-1,dp))%1000000007; \\n    return ans;\\n}\\n     \\n    int knightDialer(int N) {\\n        return kn(N);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvector<vector<int>> states = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\nint knh(int state, int n, vector<vector<int>> &dp){\\nif(n == 0) return 1; // base case\\nint total = 0;\\n\\nif(dp[state][n] != -1)\\nreturn dp[state][n]; //using memo table\\n\\nfor(int j = 0 ; j < states[state].size() ; j++) // for going through all states you can go\\n    total = (total + knh(states[state][j],n-1,dp)) %1000000007 ; // to from the current state\\n\\nreturn dp[state][n] = total; //memoize\\n}\\n\\nint kn(int n)\\n{\\n    vector<vector<int>> dp (10, vector<int>(n,-1));\\n    int ans = 0;\\n    for(int i = 0 ; i <= 9 ; i++) // As you can start from any state (between 0 to 9)\\n        ans = (ans + knh(i,n-1,dp))%1000000007; \\n    return ans;\\n}\\n     \\n    int knightDialer(int N) {\\n        return kn(N);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 189232,
                "title": "python-o-n",
                "content": "```\nclass Solution:\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        \n        # N == 1 is special because it is the only instance where 5 can be used in any hop sequence\n        if N == 1:\n            return 10\n        \n        # current number of hops that end in index i, skip 5 because it is terminal\n        ends_in = [0 if i == 5 else 1 for i in range(10)]\n        \n        mod = (10**9 + 7)\n        \n        for i in range(1, N):\n            # compute how many times we can be at each number for the next iteration\n            next_ends_in = [0 for _ in range(10)]\n            next_ends_in[0] = ends_in[4] + ends_in[6] % mod\n            next_ends_in[1] = ends_in[6] + ends_in[8] % mod\n            next_ends_in[2] = ends_in[7] + ends_in[9] % mod\n            next_ends_in[3] = ends_in[4] + ends_in[8] % mod\n            next_ends_in[4] = ends_in[3] + ends_in[9] + ends_in[0] % mod\n            # skip 5 because we can never get to it\n            next_ends_in[6] = ends_in[1] + ends_in[7] + ends_in[0] % mod\n            next_ends_in[7] = ends_in[2] + ends_in[6] % mod\n            next_ends_in[8] = ends_in[1] + ends_in[3] % mod\n            next_ends_in[9] = ends_in[2] + ends_in[4] % mod\n            ends_in = next_ends_in\n        \n        return sum(ends_in) % mod\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def knightDialer(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        \n        # N == 1 is special because it is the only instance where 5 can be used in any hop sequence\n        if N == 1:\n            return 10\n        \n        # current number of hops that end in index i, skip 5 because it is terminal\n        ends_in = [0 if i == 5 else 1 for i in range(10)]\n        \n        mod = (10**9 + 7)\n        \n        for i in range(1, N):\n            # compute how many times we can be at each number for the next iteration\n            next_ends_in = [0 for _ in range(10)]\n            next_ends_in[0] = ends_in[4] + ends_in[6] % mod\n            next_ends_in[1] = ends_in[6] + ends_in[8] % mod\n            next_ends_in[2] = ends_in[7] + ends_in[9] % mod\n            next_ends_in[3] = ends_in[4] + ends_in[8] % mod\n            next_ends_in[4] = ends_in[3] + ends_in[9] + ends_in[0] % mod\n            # skip 5 because we can never get to it\n            next_ends_in[6] = ends_in[1] + ends_in[7] + ends_in[0] % mod\n            next_ends_in[7] = ends_in[2] + ends_in[6] % mod\n            next_ends_in[8] = ends_in[1] + ends_in[3] % mod\n            next_ends_in[9] = ends_in[2] + ends_in[4] % mod\n            ends_in = next_ends_in\n        \n        return sum(ends_in) % mod\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856954,
                "title": "easy-implementation-using-recursion-and-memoization-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[5004][10];\\n    vector<vector<int>>vv = { {4,6},{8,6},{7,9},{8,4},{3,9,0},{},{1,7,0},{6,2},{1,3},{2,4} };\\n    long long solve(int dig, int n){\\n        if(n == 0) return 1;\\n        if(dp[n][dig] != -1) return dp[n][dig];\\n        long long ans = 0;\\n        for(auto d : vv[dig]){\\n            ans += solve(d,n-1);\\n            ans = ans%mod;\\n        }\\n        return dp[n][dig] = ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = 0;\\n        for(int i=0; i<=9; i++){\\n            if(i == 5) continue;\\n            ans += solve(i,n-1)%mod;\\n            ans = ans%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n\\n/**\\n0 --> 4,6\\n1 --> 8,6\\n2 --> 7,9\\n3 --> 8,4\\n4 --> 3,9,0\\n5 --> \\n6 --> 1,7,0\\n7 --> 6,2\\n8 --> 1,3\\n9 --> 2,4\\n**/\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    long long dp[5004][10];\\n    vector<vector<int>>vv = { {4,6},{8,6},{7,9},{8,4},{3,9,0},{},{1,7,0},{6,2},{1,3},{2,4} };\\n    long long solve(int dig, int n){\\n        if(n == 0) return 1;\\n        if(dp[n][dig] != -1) return dp[n][dig];\\n        long long ans = 0;\\n        for(auto d : vv[dig]){\\n            ans += solve(d,n-1);\\n            ans = ans%mod;\\n        }\\n        return dp[n][dig] = ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = 0;\\n        for(int i=0; i<=9; i++){\\n            if(i == 5) continue;\\n            ans += solve(i,n-1)%mod;\\n            ans = ans%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n\\n\\n/**\\n0 --> 4,6\\n1 --> 8,6\\n2 --> 7,9\\n3 --> 8,4\\n4 --> 3,9,0\\n5 --> \\n6 --> 1,7,0\\n7 --> 6,2\\n8 --> 1,3\\n9 --> 2,4\\n**/\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358333,
                "title": "dp-solution-easy-to-undersatnd-recursion-memoization",
                "content": "```\\nlong long mod = 1e9+7;\\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\\nint dp[5][4][5002];\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\\n    {\\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\\n        if(n==0)return 1;\\n        auto &t = dp[i][j][n];\\n        if(t!=-1)return t;\\n        int ans =0;\\n        for(int k=0;k<8;k++)\\n        {\\n            int x = dx[k]+i;\\n            int y = dy[k]+j;\\n            ans= (ans+f(nums,x,y,n-1))%mod;\\n        }\\n        return t =  ans%mod;\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>> nums(4,vector<int>(3,-1));\\n        memset(dp,-1,sizeof(dp));\\n        int x=1;\\n         nums[3][1] = 0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                nums[i][j] = x;\\n                x++;\\n            }\\n        }\\n      int ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(nums[i][j]!=-1)\\n                {\\n                    ans=(ans+f(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long mod = 1e9+7;\\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\\nint dp[5][4][5002];\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\\n    {\\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\\n        if(n==0)return 1;\\n        auto &t = dp[i][j][n];\\n        if(t!=-1)return t;\\n        int ans =0;\\n        for(int k=0;k<8;k++)\\n        {\\n            int x = dx[k]+i;\\n            int y = dy[k]+j;\\n            ans= (ans+f(nums,x,y,n-1))%mod;\\n        }\\n        return t =  ans%mod;\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>> nums(4,vector<int>(3,-1));\\n        memset(dp,-1,sizeof(dp));\\n        int x=1;\\n         nums[3][1] = 0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                nums[i][j] = x;\\n                x++;\\n            }\\n        }\\n      int ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(nums[i][j]!=-1)\\n                {\\n                    ans=(ans+f(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285446,
                "title": "python-top-down-and-bottom-up-approach-following-intuition",
                "content": "# Approach\\nConsider all 8 positions knight can jump from current position in a grid of 4x3 in which all positions are valid except cell (3, 0) and (3, 2).\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n**NOTE:** Above complexity has some contants also `3 * 4 * 8 = 96` so it\\'s actually `O(96*n)`\\n\\n# Code\\n## 1. Top down with memoization\\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\ndef isInvalid(r, c):\\n    if r >= 4 or c >= 3 or r < 0 or c < 0:\\n        return True\\n    if (r, c) in [(3, 0), (3, 2)]:\\n        return True\\n    return False\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        cache = {}\\n        def countPhoneNumbers(r, c, l):\\n            if isInvalid(r, c):\\n                return 0\\n            if n == l:\\n                return 1\\n            if (r, c, l) in cache:\\n                return cache[(r, c, l)]\\n            v = 0\\n            for r0, c0 in pos:\\n                v += countPhoneNumbers(\\n                    r + r0, c + c0, l + 1)\\n            cache[(r, c, l)] = v\\n            return cache[(r, c, l)] % 1000000007\\n\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += countPhoneNumbers(r, c, 1)\\n        return res % 1000000007\\n```\\n\\n## 2. Bottom up\\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [[[0 for _ in range(n + 1)] for _ in range(3)] for _ in range(4)]\\n\\n        for r in range(4):\\n            for c in range(3):\\n                if (r, c) not in [(3, 0), (3, 2)]:\\n                    dp[r][c][1] = 1\\n\\n        for l in range(2, n + 1):\\n            for r in range(4):\\n                for c in range(3):\\n                    if (r, c) in [(3, 0), (3, 2)]:\\n                        continue\\n                    for r0, c0 in pos:\\n                        nr = r - r0\\n                        nc = c - c0\\n                        if nr >= 0 and nr < 4 and nc >= 0 and nc < 3:\\n                            dp[r][c][l] += dp[nr][nc][l - 1]\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += dp[r][c][n]\\n        return res % 1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\ndef isInvalid(r, c):\\n    if r >= 4 or c >= 3 or r < 0 or c < 0:\\n        return True\\n    if (r, c) in [(3, 0), (3, 2)]:\\n        return True\\n    return False\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        cache = {}\\n        def countPhoneNumbers(r, c, l):\\n            if isInvalid(r, c):\\n                return 0\\n            if n == l:\\n                return 1\\n            if (r, c, l) in cache:\\n                return cache[(r, c, l)]\\n            v = 0\\n            for r0, c0 in pos:\\n                v += countPhoneNumbers(\\n                    r + r0, c + c0, l + 1)\\n            cache[(r, c, l)] = v\\n            return cache[(r, c, l)] % 1000000007\\n\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += countPhoneNumbers(r, c, 1)\\n        return res % 1000000007\\n```\n```python\\npos = [(-1, -2), (-1, 2), (1, -2), (1, 2), (-2, 1), (-2, -1), (2, 1), (2, -1)]\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [[[0 for _ in range(n + 1)] for _ in range(3)] for _ in range(4)]\\n\\n        for r in range(4):\\n            for c in range(3):\\n                if (r, c) not in [(3, 0), (3, 2)]:\\n                    dp[r][c][1] = 1\\n\\n        for l in range(2, n + 1):\\n            for r in range(4):\\n                for c in range(3):\\n                    if (r, c) in [(3, 0), (3, 2)]:\\n                        continue\\n                    for r0, c0 in pos:\\n                        nr = r - r0\\n                        nc = c - c0\\n                        if nr >= 0 and nr < 4 and nc >= 0 and nc < 3:\\n                            dp[r][c][l] += dp[nr][nc][l - 1]\\n        res = 0\\n        for r in range(4):\\n            for c in range(3):\\n                res += dp[r][c][n]\\n        return res % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761128,
                "title": "python-dp-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [1] * 10\\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\\n        for _ in range(n-1):\\n            dp_next = [0] * 10\\n            for digit in range(10):\\n                for move_digit in moves[digit]:\\n                    dp_next[digit] += dp[move_digit]\\n                    \\n            dp = dp_next\\n        \\n        return sum(dp) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dp = [1] * 10\\n        moves = [[4, 6], [6, 8], [7, 9], [4, 8], [3, 9, 0], [],\\n                 [1, 7, 0], [2, 6], [1, 3], [2, 4]]\\n        for _ in range(n-1):\\n            dp_next = [0] * 10\\n            for digit in range(10):\\n                for move_digit in moves[digit]:\\n                    dp_next[digit] += dp[move_digit]\\n                    \\n            dp = dp_next\\n        \\n        return sum(dp) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437317,
                "title": "c-easy-top-down-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long int mod=1000000007;\\n\\t\\t\\tvector<long long int>dp(10);\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tdp[i]=1;\\n\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\tvector<long long int>old_dp(10);\\n\\t\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\t\\told_dp[i]=dp[i];\\n\\t\\t\\t\\tdp[0]=(old_dp[6]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t\\tdp[1]=(old_dp[6]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[2]=(old_dp[7]%mod+old_dp[9]%mod)%mod;\\n\\t\\t\\t\\tdp[3]=(old_dp[4]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[4]=(old_dp[3]%mod+old_dp[9]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[5]=0;\\n\\t\\t\\t\\tdp[6]=(old_dp[7]%mod+old_dp[1]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[7]=(old_dp[2]%mod+old_dp[6]%mod)%mod;\\n\\t\\t\\t\\tdp[8]=(old_dp[1]%mod+old_dp[3]%mod)%mod;\\n\\t\\t\\t\\tdp[9]=(old_dp[2]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t}\\n\\t\\t\\tlong long int ans=0;\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tans+=(dp[i]%mod);\\n\\t\\t\\tans%=mod;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long int mod=1000000007;\\n\\t\\t\\tvector<long long int>dp(10);\\n\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\tdp[i]=1;\\n\\t\\t\\tfor(int i=2;i<=n;i++){\\n\\t\\t\\t\\tvector<long long int>old_dp(10);\\n\\t\\t\\t\\tfor(int i=0;i<=9;i++)\\n\\t\\t\\t\\t\\told_dp[i]=dp[i];\\n\\t\\t\\t\\tdp[0]=(old_dp[6]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t\\tdp[1]=(old_dp[6]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[2]=(old_dp[7]%mod+old_dp[9]%mod)%mod;\\n\\t\\t\\t\\tdp[3]=(old_dp[4]%mod+old_dp[8]%mod)%mod;\\n\\t\\t\\t\\tdp[4]=(old_dp[3]%mod+old_dp[9]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[5]=0;\\n\\t\\t\\t\\tdp[6]=(old_dp[7]%mod+old_dp[1]%mod+old_dp[0]%mod)%mod;\\n\\t\\t\\t\\tdp[7]=(old_dp[2]%mod+old_dp[6]%mod)%mod;\\n\\t\\t\\t\\tdp[8]=(old_dp[1]%mod+old_dp[3]%mod)%mod;\\n\\t\\t\\t\\tdp[9]=(old_dp[2]%mod+old_dp[4]%mod)%mod;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2287071,
                "title": "java-dynamic-programming-explanation-in-comments",
                "content": "class Solution {\\n    \\n    /* DP:\\n    \\n    ex n=2;\\n    \\n        0   1   2   3   4   5   6   7   8   9\\n        \\n    0   0   0   0   0   0   0   0   0   0   0\\n    \\n    1   1   1   1   1   1   1   1   1   1   1\\n\\n    2   2   2   2   2   3   0   3   2   2   2\\n    \\n    3   6   5   4   5   6   0   6   5   4   5\\n    \\n    \\n    In the above matrix, the columns indicate each digit on key pad.\\n    Rows indicate number of steps.\\n    \\n    So for (1,1) will indicate number of ways the knight can land on digit 1 in 1 step. It is going to be 1.\\n    because you have 1 step and knight will directly be on 1.\\n    \\n    (2,3) will indicate number of ways the knight can land on digit 3 in 2 steps. It is going to be 2 i.e., from     8 and 4.\\n    \\n    (3,4) indicates number of ways the knight can land on digit 4 in 3 steps. Here we will need to add (2,0) ,\\n    (2,3) and (2,9) because knight can reach 4 from all these places(0,3,9) in 1 step. but we need to count how\\n    we got to all these places in two steps and so on.\\n    \\n    So \\n    Answer is going to be sum of all digits in nth row.\\n    */\\n    \\n    public int knightDialer(int n) {\\n        int mod = 1000000007;\\n        int[][] paths = {{4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        \\n        int[][] dp = new int[n+1][10];\\n        \\n        for(int i=0;i<10;i++){\\n            dp[1][i] = 1;\\n        }\\n        \\n        \\n        int sum = 0;\\n        for(int i=2;i<n+1;i++){\\n            for(int j=0; j<10; j++){\\n                for(int k =0;k<paths[j].length;k++){\\n                    int y = paths[j][k];\\n                    dp[i][j] += dp[i-1][y];\\n\\t\\t\\t\\t\\t// if this gets too big we mod it per problem description\\n                    dp[i][j] = dp[i][j] % mod;\\n                }        \\n            }\\n        }\\n        \\n        for(int j=0;j<10;j++){\\n            sum+=dp[n][j];\\n\\t\\t\\t// if this gets too big we mod it per problem description\\n            sum = sum % mod;\\n        }\\n        return sum;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\n    \\n    /* DP:\\n    \\n    ex n=2;\\n    \\n        0   1   2   3   4   5   6   7   8   9\\n        \\n    0   0   0   0   0   0   0   0   0   0   0\\n    \\n    1   1   1   1   1   1   1   1   1   1   1\\n\\n    2   2   2   2   2   3   0   3   2   2   2\\n    \\n    3   6   5   4   5   6   0   6   5   4   5\\n    \\n    \\n    In the above matrix, the columns indicate each digit on key pad.\\n    Rows indicate number of steps.\\n    \\n    So for (1,1) will indicate number of ways the knight can land on digit 1 in 1 step. It is going to be 1.\\n    because you have 1 step and knight will directly be on 1.\\n    \\n    (2,3) will indicate number of ways the knight can land on digit 3 in 2 steps. It is going to be 2 i.e., from     8 and 4.\\n    \\n    (3,4) indicates number of ways the knight can land on digit 4 in 3 steps. Here we will need to add (2,0) ,\\n    (2,3) and (2,9) because knight can reach 4 from all these places(0,3,9) in 1 step. but we need to count how\\n    we got to all these places in two steps and so on.\\n    \\n    So \\n    Answer is going to be sum of all digits in nth row.\\n    */\\n    \\n    public int knightDialer(int n) {\\n        int mod = 1000000007;\\n        int[][] paths = {{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 2241874,
                "title": "c-recursive-dp-solution-easy-to-understand",
                "content": "We simply recurse through all the possible scenarios, and store the reuslt in a dp array, so that we do not have to recalculate moves that we have already gone through. \\nFor example, \\nfor n = 3. We will consider all the numbers on the numberpad.\\nlets consider 2 paths - from number 0, and from number 3.\\nas we can see, in both the cases we will have to calculate the number of moves for n = 2 and number = 4. (since 3 and 0 both can lead to 4 by the horse). \\nthus to avoid recalculation, we will use the dp array. \\n```\\nvector <vector<int>> dp(5001, vector <int> (10, -1));\\nvector <vector<int>> reference(10);\\n\\nint MOD = 1000000007;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector <int> states(10);\\n        int ans = 0;\\n        reference[0] = {4,6};\\n        reference[1] = {8,6};\\n        reference[2] = {7,9};\\n        reference[3] = {4,8};\\n        reference[4] = {3,9,0};\\n        reference[5] = {};\\n        reference[6] = {1,7,0};\\n        reference[7] = {6,2};\\n        reference[8] = {1,3};\\n        reference[9] = {4,2};\\n        n--;\\n        if (n == 0) return 10;\\n        cout << MOD;\\n        for (int i = 0; i < 10; i++) {\\n            if (i == 5) continue;\\n            ans = (ans % MOD + solution(n, i) % MOD) % MOD;\\n        }\\n        return ans % MOD;\\n    }\\n    \\n    int solution(int n, int start) {\\n        //cout << \"YES\";\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[n][start] == -1) {\\n            dp[n][start] = 0;\\n            for (int i = 0; i < reference[start].size(); i++) {\\n                //cout << n << \" \"  << start << \" \" << dp[n][start] << \" \" << \"\\\\n\";\\n                dp[n][start] = (dp[n][start] % MOD + solution(n - 1, reference[start][i]) % MOD) % MOD;\\n                dp[n][start] = dp[n][start] % MOD;\\n            }\\n        }        \\n        return dp[n][start] % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nvector <vector<int>> dp(5001, vector <int> (10, -1));\\nvector <vector<int>> reference(10);\\n\\nint MOD = 1000000007;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector <int> states(10);\\n        int ans = 0;\\n        reference[0] = {4,6};\\n        reference[1] = {8,6};\\n        reference[2] = {7,9};\\n        reference[3] = {4,8};\\n        reference[4] = {3,9,0};\\n        reference[5] = {};\\n        reference[6] = {1,7,0};\\n        reference[7] = {6,2};\\n        reference[8] = {1,3};\\n        reference[9] = {4,2};\\n        n--;\\n        if (n == 0) return 10;\\n        cout << MOD;\\n        for (int i = 0; i < 10; i++) {\\n            if (i == 5) continue;\\n            ans = (ans % MOD + solution(n, i) % MOD) % MOD;\\n        }\\n        return ans % MOD;\\n    }\\n    \\n    int solution(int n, int start) {\\n        //cout << \"YES\";\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[n][start] == -1) {\\n            dp[n][start] = 0;\\n            for (int i = 0; i < reference[start].size(); i++) {\\n                //cout << n << \" \"  << start << \" \" << dp[n][start] << \" \" << \"\\\\n\";\\n                dp[n][start] = (dp[n][start] % MOD + solution(n - 1, reference[start][i]) % MOD) % MOD;\\n                dp[n][start] = dp[n][start] % MOD;\\n            }\\n        }        \\n        return dp[n][start] % MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2169422,
                "title": "java-dp-graph-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    final int LIMIT = (int)Math.pow(10, 9) + 7;\\n    \\n    final int[][] moves = new int[][] {\\n        { 4, 6 },    // 0\\n        { 6, 8 },    // 1\\n        { 7, 9 },    // 2\\n        { 4, 8 },    // 3\\n        { 3, 9, 0 }, // 4\\n        { },         // 5\\n        { 1, 7, 0 }, // 6\\n        { 2, 6 },    // 7\\n        { 1, 3 },    // 8\\n        { 2, 4 },    // 9\\n    };\\n    \\n    public int knightDialer(int n) {\\n        long[] prev = new long[10];\\n        for (int i = 0 ; i < 10; i++) {\\n            prev[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            long[] curr = new long[10];\\n            for (int v = 0; v < 10; v++) {\\n                for (int u : moves[v]) {\\n                    curr[u] = (curr[u] + prev[v]) % LIMIT; \\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        long total = 0;\\n        for (int i = 0; i < 10; i++) {\\n            total = (total + prev[i]) % LIMIT;\\n        }\\n        return (int) (total % LIMIT);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    final int LIMIT = (int)Math.pow(10, 9) + 7;\\n    \\n    final int[][] moves = new int[][] {\\n        { 4, 6 },    // 0\\n        { 6, 8 },    // 1\\n        { 7, 9 },    // 2\\n        { 4, 8 },    // 3\\n        { 3, 9, 0 }, // 4\\n        { },         // 5\\n        { 1, 7, 0 }, // 6\\n        { 2, 6 },    // 7\\n        { 1, 3 },    // 8\\n        { 2, 4 },    // 9\\n    };\\n    \\n    public int knightDialer(int n) {\\n        long[] prev = new long[10];\\n        for (int i = 0 ; i < 10; i++) {\\n            prev[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            long[] curr = new long[10];\\n            for (int v = 0; v < 10; v++) {\\n                for (int u : moves[v]) {\\n                    curr[u] = (curr[u] + prev[v]) % LIMIT; \\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        long total = 0;\\n        for (int i = 0; i < 10; i++) {\\n            total = (total + prev[i]) % LIMIT;\\n        }\\n        return (int) (total % LIMIT);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668711,
                "title": "python3-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dct={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\\n        dp=[1]*10\\n        for _ in range(n-1):\\n            new=[0]*10\\n            for el in dct:\\n                for num in dct[el]:\\n                    new[num]+=dp[el]\\n            dp=new\\n        return sum(dp)%(10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        dct={1:[6,8],2:[7,9],3:[4,8],4:[3,9,0],5:[],6:[1,7,0],7:[2,6],8:[1,3],9:[2,4],0:[4,6]}\\n        dp=[1]*10\\n        for _ in range(n-1):\\n            new=[0]*10\\n            for el in dct:\\n                for num in dct[el]:\\n                    new[num]+=dp[el]\\n            dp=new\\n        return sum(dp)%(10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549261,
                "title": "python-simple-top-down-approach-recursion-with-memoization",
                "content": "1. Construct a matrix to represent a dialer.\\n2. Defined in valid cells for entry.\\n3. Create helper function to return valid jumps.\\n4. Iterate over the each cell and find the possible numbers and add them.\\n\\n\\n\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.mat = [[1, 2, 3], [4,5,6], [7,8,9], [\\'*\\', 0, \\'#\\']]\\n        self.nrows = len(self.mat)\\n        self.ncols = len(self.mat[0])\\n        self.in_valid = set([(3,0), (3,2)])\\n    \\n    def valid_jumps(self, row, col):\\n        valid = []\\n        for r_inc, c_inc in [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1,-2), (-1, -2)]:\\n            n_row, n_col = row + r_inc, col + c_inc\\n            if 0<= n_row < self.nrows and 0 <= n_col < self.ncols and (n_row, n_col) not in self.in_valid:\\n                valid.append((n_row, n_col))\\n        return valid\\n    \\n    def recursive_dialer(self, row, col, jumps, cache):\\n        if jumps == 0: return 1\\n        if (row,col, jumps) in cache: return cache[(row, col, jumps)]\\n        max_number = 0\\n        \\n        for n_row, n_col in self.valid_jumps(row, col):\\n            ret = self.recursive_dialer(n_row, n_col, jumps-1, cache)\\n            max_number += ret\\n        \\n        cache[(row, col, jumps)] = max_number\\n        \\n        return cache[(row, col, jumps)]\\n    \\n    def knightDialer(self, n: int) -> int:\\n        max_number = 0\\n        if n == 0: return max_number\\n        cache = {}\\n        \\n        for row in range(self.nrows):\\n            for col in range(self.ncols):\\n                if (row, col) not in self.in_valid:\\n                    max_number += self.recursive_dialer(row, col, n-1, cache)\\n        \\n        return max_number % (10**9 + 7)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.mat = [[1, 2, 3], [4,5,6], [7,8,9], [\\'*\\', 0, \\'#\\']]\\n        self.nrows = len(self.mat)\\n        self.ncols = len(self.mat[0])\\n        self.in_valid = set([(3,0), (3,2)])\\n    \\n    def valid_jumps(self, row, col):\\n        valid = []\\n        for r_inc, c_inc in [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (-1, 2), (1,-2), (-1, -2)]:\\n            n_row, n_col = row + r_inc, col + c_inc\\n            if 0<= n_row < self.nrows and 0 <= n_col < self.ncols and (n_row, n_col) not in self.in_valid:\\n                valid.append((n_row, n_col))\\n        return valid\\n    \\n    def recursive_dialer(self, row, col, jumps, cache):\\n        if jumps == 0: return 1\\n        if (row,col, jumps) in cache: return cache[(row, col, jumps)]\\n        max_number = 0\\n        \\n        for n_row, n_col in self.valid_jumps(row, col):\\n            ret = self.recursive_dialer(n_row, n_col, jumps-1, cache)\\n            max_number += ret\\n        \\n        cache[(row, col, jumps)] = max_number\\n        \\n        return cache[(row, col, jumps)]\\n    \\n    def knightDialer(self, n: int) -> int:\\n        max_number = 0\\n        if n == 0: return max_number\\n        cache = {}\\n        \\n        for row in range(self.nrows):\\n            for col in range(self.ncols):\\n                if (row, col) not in self.in_valid:\\n                    max_number += self.recursive_dialer(row, col, n-1, cache)\\n        \\n        return max_number % (10**9 + 7)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031451,
                "title": "c-dfs-with-memoization-easiest-to-understand",
                "content": "Standard DFS + memo \\n```\\nclass Solution {\\npublic:\\n    int dp[5001][4][3] = {0}; \\n    int mod = 1000000007; \\n    int memo(int n, int i, int j){\\n        if(i<0 || j <0 || i>3 || j > 2 || (i ==3 && j == 0) || (i == 3 && j ==2)) return 0;\\n        if(n == 0) return 1; \\n        if(dp[n][i][j] > 0) return dp[n][i][j]; \\n        return dp[n][i][j] = (((((((\\n            memo(n-1, i+2, j-1)+ memo(n-1, i+2, j+1))%mod +memo(n-1, i-2, j-1))%mod+ \\n            memo(n-1, i-2, j+1))%mod + memo(n-1, i+1, j-2))%mod+ memo(n-1, i+1, j+2))%mod+ \\n            memo(n-1, i-1, j-2))%mod+  memo(n-1, i-1, j+2))%mod; \\n    }\\n    int knightDialer(int n) {\\n        int res = 0; \\n        for(int i=0; i<4; i++){\\n            for(int j =0; j<3; j++){\\n                res = (res+memo(n-1, i,j))%mod; \\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[5001][4][3] = {0}; \\n    int mod = 1000000007; \\n    int memo(int n, int i, int j){\\n        if(i<0 || j <0 || i>3 || j > 2 || (i ==3 && j == 0) || (i == 3 && j ==2)) return 0;\\n        if(n == 0) return 1; \\n        if(dp[n][i][j] > 0) return dp[n][i][j]; \\n        return dp[n][i][j] = (((((((\\n            memo(n-1, i+2, j-1)+ memo(n-1, i+2, j+1))%mod +memo(n-1, i-2, j-1))%mod+ \\n            memo(n-1, i-2, j+1))%mod + memo(n-1, i+1, j-2))%mod+ memo(n-1, i+1, j+2))%mod+ \\n            memo(n-1, i-1, j-2))%mod+  memo(n-1, i-1, j+2))%mod; \\n    }\\n    int knightDialer(int n) {\\n        int res = 0; \\n        for(int i=0; i<4; i++){\\n            for(int j =0; j<3; j++){\\n                res = (res+memo(n-1, i,j))%mod; \\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809858,
                "title": "javascript-o-n-time-o-1-space",
                "content": "First solution:\\n```\\n/**\\ndp[count][digit] = ways\\n\\nfor count 1 -> n\\n  for digit 0 -> 9\\n    foreach move\\n      dp[ c ][ d ] += dp[ c - 1 ][ m ]\\n */\\n\\nconst moves = {\\n    0: [ 4, 6 ],\\n    1: [ 6, 8 ],\\n    2: [ 7, 9 ],\\n    3: [ 4, 8 ],\\n    4: [ 0, 3, 9 ],\\n    5: [],\\n    6: [ 0, 1, 7 ],\\n    7: [ 2, 6 ],\\n    8: [ 1, 3 ],\\n    9: [ 2, 4 ],\\n}\\n\\nconst knightDialer = n => {\\n    const dp = Array.from({ length: n + 1 }, (_,i) => Array(10).fill(i===1?1:0) )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count <= n; count++ )\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dp[ count ][ digit ] += dp[ count - 1 ][ move ] % mod )\\n \\n    return dp[ n ].reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n```\\n\\nOptimized for space:\\n```\\nconst knightDialer = n => {\\n    let dpp = Array(10).fill( 0 )\\n    let dpn = Array(10).fill( 1 )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count < n; count++ ) {\\n        const hold = dpp\\n        dpp = dpn\\n        dpn = hold.fill( 0 )\\n\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dpn[ digit ] += dpp[ move ] % mod )\\n    }\\n\\n    return dpn.reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\ndp[count][digit] = ways\\n\\nfor count 1 -> n\\n  for digit 0 -> 9\\n    foreach move\\n      dp[ c ][ d ] += dp[ c - 1 ][ m ]\\n */\\n\\nconst moves = {\\n    0: [ 4, 6 ],\\n    1: [ 6, 8 ],\\n    2: [ 7, 9 ],\\n    3: [ 4, 8 ],\\n    4: [ 0, 3, 9 ],\\n    5: [],\\n    6: [ 0, 1, 7 ],\\n    7: [ 2, 6 ],\\n    8: [ 1, 3 ],\\n    9: [ 2, 4 ],\\n}\\n\\nconst knightDialer = n => {\\n    const dp = Array.from({ length: n + 1 }, (_,i) => Array(10).fill(i===1?1:0) )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count <= n; count++ )\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dp[ count ][ digit ] += dp[ count - 1 ][ move ] % mod )\\n \\n    return dp[ n ].reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n```\n```\\nconst knightDialer = n => {\\n    let dpp = Array(10).fill( 0 )\\n    let dpn = Array(10).fill( 1 )\\n    const mod = 10 ** 9 + 7\\n    \\n    for ( let count = 1; count < n; count++ ) {\\n        const hold = dpp\\n        dpp = dpn\\n        dpn = hold.fill( 0 )\\n\\n        for ( let digit = 0; digit <= 9; digit++ )\\n            moves[ digit ].forEach( move => dpn[ digit ] += dpp[ move ] % mod )\\n    }\\n\\n    return dpn.reduce( ( a, x ) => a + x, 0 ) % mod\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 766418,
                "title": "very-easy-to-understand-o-n-c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint mod = 1e9 + 7;\\n\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tvector<vector<int>> paths = {\\n\\t\\t\\t\\t{4,6}, {6,8}, {7,9}, {4,8},\\n\\t\\t\\t\\t{3,9,0}, {}, {1,7,0},\\n\\t\\t\\t\\t{6,2}, {1,3}, {2,4},\\n\\t\\t\\t};\\n\\t\\t\\tvector<vector<int>> dp(N+1, vector<int>(10, 0));\\n\\n\\t\\t\\tfor(int i=0; i<10; i++)\\n\\t\\t\\t\\tdp[1][i] = 1;\\n\\n\\t\\t\\tfor(int i=2; i<=N; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0; j<10; j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfor(int x : paths[j])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tdp[i][j] = (dp[i][j] + dp[i-1][x]) % mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong res = 0;\\n\\t\\t\\tfor(int i=0; i<10; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tres = (res + dp[N][i]) % mod;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint mod = 1e9 + 7;\\n\\n\\t\\tint knightDialer(int N) {\\n\\t\\t\\tvector<vector<int>> paths = {\\n\\t\\t\\t\\t{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 764265,
                "title": "python3-6-line-116ms-solution-using-maths",
                "content": "OK, this is a very over-engineered solution, but I find it really interesting nonetheless.\\n\\nIf we look closely at the transition graph of our positions, we can notice that there are actually 4 distinct kinds of positions:\\n* Group 1: positions 8 and 2, which can only transition to group 2,\\n* Group 2: positions 1, 3, 7 and 9, which can either transition to group 1 or 3,\\n* Group 3: positions 4 and 6, which can either transition to group 2 or 4,\\n* Group 4: position 0, which can only transition to group 3.\\n\\nLet me draw a graph of the transitions to make that more clear:\\n\\n```\\n1 -- 8 -- 3\\n|         |\\n6 -- 0 -- 4\\n|         |\\n7 -- 2 -- 9\\n```\\n\\nNow, if we call `a_k`, `b_k`, `c_k`, `d_k` the number of numbers ending in each of our four groups after k jumps, we can write the recursive relation between our values:\\n\\n* `a_(k+1) = b_k`: each knight in group 2 has one way to move at jump k + 1 to a position in group 1,\\n* `b_(k+1) = 2 * (a_k + c_k)`: each knight in group 1 has two ways to move to group 2; similarly, each knight in group 3 has two ways to move to group 2; therefore, we must count twice the numbers from both groups,\\n* `c_(k+1) = b_k + 2 * d_k`: each knight in group 2 has one way to move to a position in group 3, and each knight in group 4 has two ways to move to a position in group 3,\\n* `d_(k+1) = c_k`: each knight in group 3 has one way to move to a position in group 4.\\n\\nThis lets us write a concise recursion formula. We simply have to apply the recursion `N - 1` times from the initial state.\\n\\nThe complexity is the same as the optimized dynamic programming solution, `O(n)` time `O(1)` space.\\n\\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def knightDialer(self, N: int) -> int:\\n        if N <= 1:\\n            return 10\\n        a, b, c, d = 2, 4, 2, 1\\n        for _ in range(N - 1):\\n            a, b, c, d = (b, 2 * (a + c) % self.BASE, (b + 2 * d) % self.BASE, c)\\n        return (a + b + c + d) % self.BASE\\n```",
                "solutionTags": [],
                "code": "```\\n1 -- 8 -- 3\\n|         |\\n6 -- 0 -- 4\\n|         |\\n7 -- 2 -- 9\\n```\n```python\\nclass Solution:\\n    \\n    BASE = 10 ** 9 + 7\\n    \\n    def knightDialer(self, N: int) -> int:\\n        if N <= 1:\\n            return 10\\n        a, b, c, d = 2, 4, 2, 1\\n        for _ in range(N - 1):\\n            a, b, c, d = (b, 2 * (a + c) % self.BASE, (b + 2 * d) % self.BASE, c)\\n        return (a + b + c + d) % self.BASE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343847,
                "title": "easy-peasy-python-o-n-solution",
                "content": "\\t\\tmv = { 0: [4, 6], 1 : [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]  }\\n        \\n        rs = [1]*10\\n        \\n        for i in range(N-1):\\n            tmp = [0]*10\\n            for j in range(10):\\n                for k in mv[j]:\\n                    tmp[j] += rs[k]\\n            \\n            rs = tmp\\n    \\n        return sum(rs) % ((10**9) + 7)",
                "solutionTags": [],
                "code": "\\t\\tmv = { 0: [4, 6], 1 : [6, 8], 2: [7, 9], 3: [4, 8], 4: [0, 3, 9], 5: [], 6: [0, 1, 7], 7: [2, 6], 8: [1, 3], 9: [2, 4]  }\\n        \\n        rs = [1]*10\\n        \\n        for i in range(N-1):\\n            tmp = [0]*10\\n            for j in range(10):\\n                for k in mv[j]:\\n                    tmp[j] += rs[k]\\n            \\n            rs = tmp\\n    \\n        return sum(rs) % ((10**9) + 7)",
                "codeTag": "Unknown"
            },
            {
                "id": 189244,
                "title": "straightforward-dp-java",
                "content": "The count of values that can be generated from a given starting position with **N hops** == Sum of the counts of hops that can be generated starting from each of its neighbors with **N-1 hops.** \n\n```\nclass Solution {\n    private Map<String,Long> posHopCountMap;\n\n    private Map<Integer,Integer[]> neighbourMap;\n\n    private int mod = (int) (Math.pow(10,9)+7);\n\n    public int knightDialer(int N) {\n\n        posHopCountMap = new HashMap<>();\n        neighbourMap = new HashMap<>();\n\n        neighbourMap.put(0,new Integer[]{4,6});\n        neighbourMap.put(1,new Integer[]{6,8});\n        neighbourMap.put(2,new Integer[]{7,9});\n        neighbourMap.put(3,new Integer[]{4,8});\n        neighbourMap.put(4,new Integer[]{3,9,0});\n        neighbourMap.put(5,null);\n        neighbourMap.put(6,new Integer[]{1,7,0});\n        neighbourMap.put(7,new Integer[]{2,6});\n        neighbourMap.put(8,new Integer[]{1,3});\n        neighbourMap.put(9,new Integer[]{2,4});\n\n\n        long sum = 0;\n        for (int i=0;i<=9;i++) {\n            sum=(sum+getDistinctCount(i,N-1))%mod;\n        }\n\n        return (int)sum;\n\n    }\n\n    private long getDistinctCount(int pos,int count) {\n        if(count==0) {\n            return 1;\n        }\n        String mapKey = pos+\"_\"+count;\n        if(posHopCountMap.get(mapKey)!=null) {\n            return (posHopCountMap.get(mapKey))%mod;\n        }\n\n        long c=0;\n        if(neighbourMap.get(pos)!=null) {\n            for (Integer ne : neighbourMap.get(pos)) {\n                c=(c+getDistinctCount(ne,count-1))%mod;\n            }\n            posHopCountMap.put(mapKey,c);\n        }\n\n        return c;\n\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private Map<String,Long> posHopCountMap;\n\n    private Map<Integer,Integer[]> neighbourMap;\n\n    private int mod = (int) (Math.pow(10,9)+7);\n\n    public int knightDialer(int N) {\n\n        posHopCountMap = new HashMap<>();\n        neighbourMap = new HashMap<>();\n\n        neighbourMap.put(0,new Integer[]{4,6});\n        neighbourMap.put(1,new Integer[]{6,8});\n        neighbourMap.put(2,new Integer[]{7,9});\n        neighbourMap.put(3,new Integer[]{4,8});\n        neighbourMap.put(4,new Integer[]{3,9,0});\n        neighbourMap.put(5,null);\n        neighbourMap.put(6,new Integer[]{1,7,0});\n        neighbourMap.put(7,new Integer[]{2,6});\n        neighbourMap.put(8,new Integer[]{1,3});\n        neighbourMap.put(9,new Integer[]{2,4});\n\n\n        long sum = 0;\n        for (int i=0;i<=9;i++) {\n            sum=(sum+getDistinctCount(i,N-1))%mod;\n        }\n\n        return (int)sum;\n\n    }\n\n    private long getDistinctCount(int pos,int count) {\n        if(count==0) {\n            return 1;\n        }\n        String mapKey = pos+\"_\"+count;\n        if(posHopCountMap.get(mapKey)!=null) {\n            return (posHopCountMap.get(mapKey))%mod;\n        }\n\n        long c=0;\n        if(neighbourMap.get(pos)!=null) {\n            for (Integer ne : neighbourMap.get(pos)) {\n                c=(c+getDistinctCount(ne,count-1))%mod;\n            }\n            posHopCountMap.put(mapKey,c);\n        }\n\n        return c;\n\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744139,
                "title": "java-dp-w-explanation-solution-easier-to-read",
                "content": "# Intuition\\nLet\\'s think about this problem w/o DP first:\\nLet\\'s say we start off on the \\'1\\' button first and N=5. I can either reach 6 or 8. If i go to \\'6\\' after wards i have n=5 more jumps i can do. If i go to \\'8\\' i also have n=5 more different moves i can do. We want to check both of them\\n\\nDP:\\nThe unique combinations in our DP array we can have is based on how many moves we have left (n) and which number we\\'re currently at. \\nFor example, if on one iteration i have 4 moves left and i\\'m at number \\'0\\', the next time on a differet iteration I happen to have 4 moves left and i\\'m also at \\'0\\' we don\\'t need to recompute from here. We just pull up dp[n][0]\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] pad = new int[][] {{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\\n    int[][] dirs = new int[][] {{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1}};\\n    long[][] dp;    \\n    int modulus = (int)Math.pow(10,9)+7;\\n    long sol = 0;\\n    public int knightDialer(int n) {\\n        dp = new long[n+1][10];\\n        for(int r = 0; r<pad.length; r++){\\n            for(int c = 0; c<pad[0].length; c++){\\n                sol = (sol+helper(r,c,n))%modulus;\\n            }\\n        }\\n        return (int) sol;\\n    }\\n    public long helper(int r, int c, int n){\\n        if (n == 1 && validMove(r,c)){\\n            return 1;\\n        }\\n        if(!validMove(r,c)){\\n            return 0;\\n        }\\n        if(dp[n][pad[r][c]]>0){\\n            return dp[n][pad[r][c]];\\n        }\\n        long curr = 0;\\n        for(int[] d : dirs){\\n            int newR = d[0]+r;\\n            int newC = d[1]+c;\\n            curr = (curr+helper(newR,newC,n-1))%modulus;\\n        }\\n        dp[n][pad[r][c]] = curr;\\n        return curr;\\n    }\\n    public boolean validMove(int r, int c){\\n        if (r<0 || c<0 || r>=pad.length || c>=pad[0].length || pad[r][c] == -1){\\n            return false;\\n        }return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[][] pad = new int[][] {{1,2,3},{4,5,6},{7,8,9},{-1,0,-1}};\\n    int[][] dirs = new int[][] {{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1},{1,2},{2,1}};\\n    long[][] dp;    \\n    int modulus = (int)Math.pow(10,9)+7;\\n    long sol = 0;\\n    public int knightDialer(int n) {\\n        dp = new long[n+1][10];\\n        for(int r = 0; r<pad.length; r++){\\n            for(int c = 0; c<pad[0].length; c++){\\n                sol = (sol+helper(r,c,n))%modulus;\\n            }\\n        }\\n        return (int) sol;\\n    }\\n    public long helper(int r, int c, int n){\\n        if (n == 1 && validMove(r,c)){\\n            return 1;\\n        }\\n        if(!validMove(r,c)){\\n            return 0;\\n        }\\n        if(dp[n][pad[r][c]]>0){\\n            return dp[n][pad[r][c]];\\n        }\\n        long curr = 0;\\n        for(int[] d : dirs){\\n            int newR = d[0]+r;\\n            int newC = d[1]+c;\\n            curr = (curr+helper(newR,newC,n-1))%modulus;\\n        }\\n        dp[n][pad[r][c]] = curr;\\n        return curr;\\n    }\\n    public boolean validMove(int r, int c){\\n        if (r<0 || c<0 || r>=pad.length || c>=pad[0].length || pad[r][c] == -1){\\n            return false;\\n        }return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711116,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    int[][] canMove = {{4,6},{6,8},{7,9},{4,8},{0,3,7},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1_000_000_007;\\n    public int helper(int n, int curr, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        int ans = 0;\\n        for(int i: canMove[curr]) {\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return dp[n][curr] = ans;\\n    }\\n    \\n    public int knightDialer(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n+1][10];\\n        for(int i=0;i<10;i++){\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] canMove = {{4,6},{6,8},{7,9},{4,8},{0,3,7},{},{0,1,7},{2,6},{1,3},{2,4}};\\n    int mod = 1_000_000_007;\\n    public int helper(int n, int curr, Integer[][] dp){\\n        if(n==0)\\n            return 1;\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        int ans = 0;\\n        for(int i: canMove[curr]) {\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return dp[n][curr] = ans;\\n    }\\n    \\n    public int knightDialer(int n) {\\n        int ans = 0;\\n        Integer[][] dp = new Integer[n+1][10];\\n        for(int i=0;i<10;i++){\\n            ans = (ans%mod + helper(n-1, i, dp)%mod)%mod;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658072,
                "title": "constant-space-c-solution-with-explanation",
                "content": "# Intuition\\nJust for a second think about various positions on the dialpad and how they can be reached.\\n\\n# Approach\\nNow that you must have got an idea that every key on the dialpad can only be reached by certain keys. For example, the key 1 can only be reached by keys 8 and 6 and NONE other. Now that we know that, we can think that at every stage if we press the current button, the previous state must have had one of the possible path keys (in case of 1 - 8 and 6). Now this looks like a good problem for DP but, notice that we only need the last state of dialpad, hence can be done in constant space. \\nSo first initialise the curr vector, with 10 keys. If n=1, number of buttons pressed = 1. Initialise next vector same as current. Now at every next step ranging from 2 to n, we see that if the current button was x, what are the ways to reach x. For example x is 1, so the number of ways to reach 1 in next state is when current state is at 8 or 6. Following this logic, count the next state for every number on the dialpad. At last of iteration, assign curr to next, as this will become our current state for the next step. \\nAt last just add all the number of ways to each each key on the dialpad.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    \\n    int knightDialer(int n) {\\n        vector<long> curr(10, 1);\\n        vector<long> next = curr;\\n        for(int i=2; i<=n; i++)\\n        {\\n            next[0] = ((curr[4]%MOD)+(curr[6]%MOD))%MOD;\\n            next[1] = ((curr[8]%MOD)+(curr[6]%MOD))%MOD;\\n            next[2] = ((curr[9]%MOD)+(curr[7]%MOD))%MOD;\\n            next[3] = ((curr[4]%MOD)+(curr[8]%MOD))%MOD;\\n            next[4] = ((curr[3]%MOD)+(curr[9]%MOD)+(curr[0]%MOD))%MOD;\\n            next[5] = 0;\\n            next[6] = ((curr[1]%MOD)+(curr[7]%MOD)+(curr[0]%MOD))%MOD;\\n            next[7] = ((curr[2]%MOD)+(curr[6]%MOD))%MOD;\\n            next[8] = ((curr[1]%MOD)+(curr[3]%MOD))%MOD;\\n            next[9] = ((curr[4]%MOD)+(curr[2]%MOD))%MOD;\\n            curr = next;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<10; i++)\\n            ans=((ans+next[i])%MOD);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\npublic:\\n    \\n    int knightDialer(int n) {\\n        vector<long> curr(10, 1);\\n        vector<long> next = curr;\\n        for(int i=2; i<=n; i++)\\n        {\\n            next[0] = ((curr[4]%MOD)+(curr[6]%MOD))%MOD;\\n            next[1] = ((curr[8]%MOD)+(curr[6]%MOD))%MOD;\\n            next[2] = ((curr[9]%MOD)+(curr[7]%MOD))%MOD;\\n            next[3] = ((curr[4]%MOD)+(curr[8]%MOD))%MOD;\\n            next[4] = ((curr[3]%MOD)+(curr[9]%MOD)+(curr[0]%MOD))%MOD;\\n            next[5] = 0;\\n            next[6] = ((curr[1]%MOD)+(curr[7]%MOD)+(curr[0]%MOD))%MOD;\\n            next[7] = ((curr[2]%MOD)+(curr[6]%MOD))%MOD;\\n            next[8] = ((curr[1]%MOD)+(curr[3]%MOD))%MOD;\\n            next[9] = ((curr[4]%MOD)+(curr[2]%MOD))%MOD;\\n            curr = next;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<10; i++)\\n            ans=((ans+next[i])%MOD);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2404843,
                "title": "python3-clean-top-down-dp-solution-with-lru-cache",
                "content": "```\\nclass Solution:\\n    # T: O(N) where N is the number of allowed moves \\n    possible_moves = {\\n        0: [4,6],\\n        1: [6,8],\\n        2: [7,9],\\n        3: [4,8],\\n        4: [0,3,9],\\n        5: [],\\n        6: [0,1,7],\\n        7: [2,6],\\n        8: [1,3],\\n        9: [2,4],\\n    }\\n    \\n    MOD = 1e9 + 7\\n    \\n    def knightDialer(self, n: int) -> int:\\n        return int(sum(self.dp(start, n-1) for start in range(10)) % self.MOD) # int() to cast float to int\\n        \\n    \\n    @lru_cache(maxsize=None)\\n    def dp(self, start: int, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        return sum(self.dp(next_move, n-1) for next_move in self.possible_moves[start]) % self.MOD\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    # T: O(N) where N is the number of allowed moves \\n    possible_moves = {\\n        0: [4,6],\\n        1: [6,8],\\n        2: [7,9],\\n        3: [4,8],\\n        4: [0,3,9],\\n        5: [],\\n        6: [0,1,7],\\n        7: [2,6],\\n        8: [1,3],\\n        9: [2,4],\\n    }\\n    \\n    MOD = 1e9 + 7\\n    \\n    def knightDialer(self, n: int) -> int:\\n        return int(sum(self.dp(start, n-1) for start in range(10)) % self.MOD) # int() to cast float to int\\n        \\n    \\n    @lru_cache(maxsize=None)\\n    def dp(self, start: int, n: int) -> int:\\n        if n == 0:\\n            return 1\\n        \\n        return sum(self.dp(next_move, n-1) for next_move in self.possible_moves[start]) % self.MOD\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338188,
                "title": "easy-understanding-c-solution-o-n-tc-and-o-1-sc-using-math",
                "content": "### **Thinking:**\\n* Let\\'s part the numbers as follow:\\n* a{2,8} b{1,3,7,9} c{4,6} d{0} e{5}\\n* for n>1 there would no phone_numbers ending with 5 (not possible).\\n* For any new digit of group a, previous digit should be ending with group b.\\n\\t* Also notice that for each number, there can be only two previous numbers, both from group b.\\n\\t* i.e. for let say 2, previous digit should be either 7 or 9.\\n* For any new digit of group b, previous digit should be ending with group a or c.\\n\\t* Also notice that for each number, there can be only two previous numbers, that too one from group a, another from group c.\\n\\t* i.e. for let say 1, previous digit should be either 8 or 6.\\n*  For any new digit of group c, previous digit should be ending with group b or d.\\n\\t* Also notice that for each number, there can be only three previous numbers, that too two from group b, another from group d.\\n\\t* i.e. for let say 4, previous digit should be 3 or 9 or 0.\\n* For any new digit of group d, previous digit should be ending with group c.\\n\\t* Also notice that for each number, there can be only two previous number, both from group c.\\n\\t* i.e. for 0, previous digit should be either 4 or 6.\\n\\nLet\\'s store number of phone_numbers ending with the digit of certain group as variable a, b, c, d.\\nLet\\'s update the value for each increment of n.\\nFinally after n operations, We have the number of unique phone_numbers ending with certain group. So just multiplying those with the number of element of each group, we can find the total number of unique phone_numbers.\\n\\t\\n### **Code:**\\n```\\nclass Solution {\\n    int MOD=1e9+7;\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1) return 10;\\n        int a=2, b=2, c=3, d=2; //a{2,8} b{1,3,7,9} c{4,6} d{0}\\n        for(int i=3; i<=n; i++){\\n            int w, x, y, z;\\n            w = 2ll*b%MOD;\\n            x = (1ll*a + 1ll*c)%MOD;\\n            y = (2ll*b + 1ll*d)%MOD;\\n            z = 2ll*c%MOD;\\n            a = w; b = x; c = y; d = z;\\n        }\\n        int ans = (2ll*a + 4ll*b + 2ll*c + d)%MOD;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Comment For any Explanation, Upvote if you like it...**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int MOD=1e9+7;\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1) return 10;\\n        int a=2, b=2, c=3, d=2; //a{2,8} b{1,3,7,9} c{4,6} d{0}\\n        for(int i=3; i<=n; i++){\\n            int w, x, y, z;\\n            w = 2ll*b%MOD;\\n            x = (1ll*a + 1ll*c)%MOD;\\n            y = (2ll*b + 1ll*d)%MOD;\\n            z = 2ll*c%MOD;\\n            a = w; b = x; c = y; d = z;\\n        }\\n        int ans = (2ll*a + 4ll*b + 2ll*c + d)%MOD;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336836,
                "title": "dfs-brute-force-with-memoization",
                "content": "```\\nlong long int solve(int n,int i,int j,vector< vector<vector<int>>> &cache)\\n{\\n    if((i==3 && j!=1) || n<0 || i>=4 || j>=3 || j<0 || i<0 )\\n        return 0;\\n    \\n    if(n == 0)\\n        return 1;\\n    \\n    if(cache[n][i][j]!=-1)\\n        return cache[n][i][j];\\n    \\n    long long int res = 0;\\n    int mod = 1000000007;\\n    res+=solve(n-1,i+2,j+1,cache)%mod;\\n    res+=solve(n-1,i-2,j+1,cache)%mod;\\n    res+=solve(n-1,i+2,j-1,cache)%mod;\\n    res+=solve(n-1,i-2,j-1,cache)%mod;\\n    \\n    \\n    res+=solve(n-1,i+1,j+2,cache)%mod;\\n    res+=solve(n-1,i-1,j+2,cache)%mod;\\n    res+=solve(n-1,i+1,j-2,cache)%mod;\\n    res+=solve(n-1,i-1,j-2,cache)%mod;\\n    \\n    return(cache[n][i][j]=(res%mod));\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        long long int res=0;\\n        int mod = 1000000007;\\n        vector<vector<int>> t(5,vector<int>(4,-1));\\n        vector< vector<vector<int>>> cache(n+1,t);\\n        n-=1; //setting the knight to one of the dial pads\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=(solve(n,i,j,cache)%mod);\\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long int solve(int n,int i,int j,vector< vector<vector<int>>> &cache)\\n{\\n    if((i==3 && j!=1) || n<0 || i>=4 || j>=3 || j<0 || i<0 )\\n        return 0;\\n    \\n    if(n == 0)\\n        return 1;\\n    \\n    if(cache[n][i][j]!=-1)\\n        return cache[n][i][j];\\n    \\n    long long int res = 0;\\n    int mod = 1000000007;\\n    res+=solve(n-1,i+2,j+1,cache)%mod;\\n    res+=solve(n-1,i-2,j+1,cache)%mod;\\n    res+=solve(n-1,i+2,j-1,cache)%mod;\\n    res+=solve(n-1,i-2,j-1,cache)%mod;\\n    \\n    \\n    res+=solve(n-1,i+1,j+2,cache)%mod;\\n    res+=solve(n-1,i-1,j+2,cache)%mod;\\n    res+=solve(n-1,i+1,j-2,cache)%mod;\\n    res+=solve(n-1,i-1,j-2,cache)%mod;\\n    \\n    return(cache[n][i][j]=(res%mod));\\n}\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        long long int res=0;\\n        int mod = 1000000007;\\n        vector<vector<int>> t(5,vector<int>(4,-1));\\n        vector< vector<vector<int>>> cache(n+1,t);\\n        n-=1; //setting the knight to one of the dial pads\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=(solve(n,i,j,cache)%mod);\\n            }\\n        }\\n        \\n        return res%mod;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268842,
                "title": "o-n-time-complexity",
                "content": "possible moves for each number\\n0 -> 4,6\\n1 -> 8,6\\n2 -> 9,7\\n3 -> 4,8\\n4 -> 3,9,0\\n5 -> -\\n6 -> 1,7,0\\n7 -> 6,2\\n8 -> 1,3\\n9 -> 4,2\\n\\ninitially for n=1\\nwe can dial any no. but for n more than 2 we have to make combinations of moves associated to that number\\na=current row, b=prev row\\n```class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        int mod = pow(10, 9) + 7;\\n        vector<long long>a(10,1), b(10);\\n        for(int i=0;i<10;i++)\\n            b[i]=1;\\n        int i=1;\\n        long long sum=0;\\n        n--;\\n        while(n--){\\n            sum=0;\\n            sum+=a[0]=(b[4]+b[6])%mod;\\n            sum+=a[1]=(b[8]+b[6])%mod;\\n            sum+=a[2]=(b[9]+b[7])%mod;\\n            sum+=a[3]=(b[4]+b[8])%mod;\\n            sum+=a[4]=(b[3]+b[9]+b[0])%mod;\\n            sum+=a[5]=0;\\n            sum+=a[6]=(b[1]+b[7]+b[0])%mod;\\n            sum+=a[7]=(b[2]+b[6])%mod;\\n            sum+=a[8]=(b[1]+b[3])%mod;\\n            sum+=a[9]=(b[4]+b[2])%mod;\\n            b=a;\\n            i++;\\n        }\\n        return sum%mod;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        int mod = pow(10, 9) + 7;\\n        vector<long long>a(10,1), b(10);\\n        for(int i=0;i<10;i++)\\n            b[i]=1;\\n        int i=1;\\n        long long sum=0;\\n        n--;\\n        while(n--){\\n            sum=0;\\n            sum+=a[0]=(b[4]+b[6])%mod;\\n            sum+=a[1]=(b[8]+b[6])%mod;\\n            sum+=a[2]=(b[9]+b[7])%mod;\\n            sum+=a[3]=(b[4]+b[8])%mod;\\n            sum+=a[4]=(b[3]+b[9]+b[0])%mod;\\n            sum+=a[5]=0;\\n            sum+=a[6]=(b[1]+b[7]+b[0])%mod;\\n            sum+=a[7]=(b[2]+b[6])%mod;\\n            sum+=a[8]=(b[1]+b[3])%mod;\\n            sum+=a[9]=(b[4]+b[2])%mod;\\n            b=a;\\n            i++;\\n        }\\n        return sum%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194403,
                "title": "java-bottom-up-dp-explained-with-thinking-process",
                "content": "Given a Numeric Keypad where we can type a Number in a Knights Move, we need to calculate different number combinations of a given Length.\\nWe need some crucial Information before Proceeding ahead.\\n\\n```\\n1 | 2 | 3\\n4 | 5 | 6\\n7 | 8 | 9\\n* | 0 | #\\n```\\nFor every length, the Knight has multiple options to move from the Current Numeric Button to other Numeric Button. For every length we have 10 buttons to press. Let\\'s take a look on the Combinations:\\n```\\ni = 0: We can make a Knights move from 0 to both 4 & 6. So for current press if we choose i = 0, we are left with (n-1, 4) + (n-1, 6) presses Left.\\n\\nSimilarly I\\'ll list down all possibilities,\\n\\ni = 1: Can jump to 6 & 8 so (n-1, 6) + (n-1, 8)\\ni = 2: Can jump to 7 & 9 so (n-1, 7) + (n-1, 9)\\ni = 3: Can jump to 4 & 8 so (n-1, 4) + (n-1, 8)\\ni = 4: Can jump to 3 & 9 & 0 so (n-1, 3) + (n-1, 9) + (n-1, 0)\\ni = 5: Cannot jump anywhere so 0 for n > 1 ( Can actually jump to * & # but they are Forbidden)\\ni = 6: Can jump to 1 & 7 & 0 so (n-1, 1) + (n-1, 7) + (n-1, 0)\\ni = 7: Can jump to 2 & 6 so (n-1, 2) + (n-1, 6)\\ni = 8: Can jump to 1 & 3 so (n-1, 1) + (n-1, 3)\\ni = 9: Can jump to 2 & 4 so (n-1, 2) + (n-1, 4)\\n```\\n\\n\\nTo Simulate the Above process, we will run 2 For loops:\\n1. First for every n Length Combination that we can get.\\n2. Then for every Numeric Keypad Button from 0 to 9.\\n\\nWe would depend on the values for the Previous length Combinations that can be made. The further is explained below in the Code.\\n\\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        long[][] dp = new long[n][10];\\n        for(int i = 0; i < 10; i++)\\n            dp[0][i] = 1;\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < 10; j++)\\n                helper(dp, i, j);\\n        \\n        long ans = 0;\\n        for(int j = 0; j < 10; j++)\\n        {\\n            ans += dp[n-1][j];\\n            ans %= mod;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private void helper(long[][] dp, int i, int j)\\n    {\\n        if(j == 1)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n        else if(j == 3)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n        else if(j == 7)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][2]) % mod;\\n        else if(j == 9)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][2]) % mod;\\n        else if(j == 2)\\n            dp[i][j] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n        else if(j == 8)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n        else if(j == 4)\\n            dp[i][j] = (dp[i-1][3] + dp[i-1][9] + dp[i-1][0]) % mod;\\n        else if(j == 6)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][7] + dp[i-1][0]) % mod;\\n        else if(j == 0)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n1 | 2 | 3\\n4 | 5 | 6\\n7 | 8 | 9\\n* | 0 | #\\n```\n```\\ni = 0: We can make a Knights move from 0 to both 4 & 6. So for current press if we choose i = 0, we are left with (n-1, 4) + (n-1, 6) presses Left.\\n\\nSimilarly I\\'ll list down all possibilities,\\n\\ni = 1: Can jump to 6 & 8 so (n-1, 6) + (n-1, 8)\\ni = 2: Can jump to 7 & 9 so (n-1, 7) + (n-1, 9)\\ni = 3: Can jump to 4 & 8 so (n-1, 4) + (n-1, 8)\\ni = 4: Can jump to 3 & 9 & 0 so (n-1, 3) + (n-1, 9) + (n-1, 0)\\ni = 5: Cannot jump anywhere so 0 for n > 1 ( Can actually jump to * & # but they are Forbidden)\\ni = 6: Can jump to 1 & 7 & 0 so (n-1, 1) + (n-1, 7) + (n-1, 0)\\ni = 7: Can jump to 2 & 6 so (n-1, 2) + (n-1, 6)\\ni = 8: Can jump to 1 & 3 so (n-1, 1) + (n-1, 3)\\ni = 9: Can jump to 2 & 4 so (n-1, 2) + (n-1, 4)\\n```\n```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if(n == 1) return 10;\\n        long[][] dp = new long[n][10];\\n        for(int i = 0; i < 10; i++)\\n            dp[0][i] = 1;\\n        for(int i = 1; i < n; i++)\\n            for(int j = 0; j < 10; j++)\\n                helper(dp, i, j);\\n        \\n        long ans = 0;\\n        for(int j = 0; j < 10; j++)\\n        {\\n            ans += dp[n-1][j];\\n            ans %= mod;\\n        }\\n        return (int)ans;\\n    }\\n    \\n    private void helper(long[][] dp, int i, int j)\\n    {\\n        if(j == 1)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n        else if(j == 3)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n        else if(j == 7)\\n            dp[i][j] = (dp[i-1][6] + dp[i-1][2]) % mod;\\n        else if(j == 9)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][2]) % mod;\\n        else if(j == 2)\\n            dp[i][j] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n        else if(j == 8)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n        else if(j == 4)\\n            dp[i][j] = (dp[i-1][3] + dp[i-1][9] + dp[i-1][0]) % mod;\\n        else if(j == 6)\\n            dp[i][j] = (dp[i-1][1] + dp[i-1][7] + dp[i-1][0]) % mod;\\n        else if(j == 0)\\n            dp[i][j] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124467,
                "title": "javascript-simple-and-clean-o-n-o-1",
                "content": "```\\nvar knightDialer = function(n) {\\n  // dp = the no. of possible combinations at each number\\n  let dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; // 0-9\\n  const mod = 10**9 + 7;\\n  for(let i=2; i<=n; i++) {\\n    dp = [\\n      (dp[4] + dp[6]) % mod, // 0\\n      (dp[6] + dp[8]) % mod, // 1\\n      (dp[7] + dp[9]) % mod, // 2 ...\\n      (dp[4] + dp[8]) % mod,\\n      (dp[3] + dp[9] + dp[0]) % mod,\\n      0,\\n      (dp[1] + dp[7] + dp[0]) % mod,\\n      (dp[2] + dp[6]) % mod,\\n      (dp[1] + dp[3]) % mod,\\n      (dp[4] + dp[2]) % mod\\n    ];\\n  }\\n  return dp.reduce((prev, next) => (prev + next) % mod, 0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar knightDialer = function(n) {\\n  // dp = the no. of possible combinations at each number\\n  let dp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]; // 0-9\\n  const mod = 10**9 + 7;\\n  for(let i=2; i<=n; i++) {\\n    dp = [\\n      (dp[4] + dp[6]) % mod, // 0\\n      (dp[6] + dp[8]) % mod, // 1\\n      (dp[7] + dp[9]) % mod, // 2 ...\\n      (dp[4] + dp[8]) % mod,\\n      (dp[3] + dp[9] + dp[0]) % mod,\\n      0,\\n      (dp[1] + dp[7] + dp[0]) % mod,\\n      (dp[2] + dp[6]) % mod,\\n      (dp[1] + dp[3]) % mod,\\n      (dp[4] + dp[2]) % mod\\n    ];\\n  }\\n  return dp.reduce((prev, next) => (prev + next) % mod, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1969250,
                "title": "c-recursive-and-memoization-dp-simple-and-easy",
                "content": "```\\nclass Solution {\\n    \\n    //For memoization\\n    vector<vector<vector<int>>>memo;\\n    long long int mod=1e9+7;\\n    \\n    //recursive calls to claculate all possible moves when horse at i,j th cell\\n    int help(int n,int i,int j){\\n        \\n        if(i<0 || j<0 || i>3 || j>2 || (i==3 && j==2) || (i==3 && j==0))\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        \\n        if(memo[i][j][n]!=-1)\\n            return memo[i][j][n];\\n        //all 8 possible moves\\n        int ans=0;\\n        ans=(ans%mod+help(n-1,i-2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j+2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j+2)%mod)%mod;\\n        return memo[i][j][n]=ans%mod;\\n   \\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        long long int ans=0;\\n        //find ans when horse at every i,j th cell\\n        for(int i=0;i<=3;i++)\\n            for(int j=0;j<=2;j++)\\n                ans+=help(n-1,i,j)%mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```\\n### if you like it upvote it",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //For memoization\\n    vector<vector<vector<int>>>memo;\\n    long long int mod=1e9+7;\\n    \\n    //recursive calls to claculate all possible moves when horse at i,j th cell\\n    int help(int n,int i,int j){\\n        \\n        if(i<0 || j<0 || i>3 || j>2 || (i==3 && j==2) || (i==3 && j==0))\\n            return 0;\\n        if(n==0)\\n            return 1;\\n        \\n        if(memo[i][j][n]!=-1)\\n            return memo[i][j][n];\\n        //all 8 possible moves\\n        int ans=0;\\n        ans=(ans%mod+help(n-1,i-2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j-2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j-1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+2,j+1)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i-1,j+2)%mod)%mod;\\n        ans=(ans%mod+help(n-1,i+1,j+2)%mod)%mod;\\n        return memo[i][j][n]=ans%mod;\\n   \\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        long long int ans=0;\\n        //find ans when horse at every i,j th cell\\n        for(int i=0;i<=3;i++)\\n            for(int j=0;j<=2;j++)\\n                ans+=help(n-1,i,j)%mod;\\n        \\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923343,
                "title": "python3-dp-top-down",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        \\n        MOD = 10**9 + 7\\n        \\n        adj = {\\n            0: [6, 4], \\n            1: [6, 8], \\n            2: [9, 7], \\n            3: [4, 8], \\n            4: [9, 3, 0], \\n            5: [], \\n            6: [7, 1, 0], \\n            7: [6, 2], \\n            8: [3, 1], \\n            9: [4, 2]\\n        }\\n        \\n        @cache\\n        def res(k, num):\\n            if k == 1:\\n                return 1\\n            else:\\n                ret = 0\\n                for i in adj[num]:\\n                    ret = (ret + res(k - 1, i)) % MOD\\n                return ret\\n        \\n        ans = 0\\n        for i in range(10):\\n            ans = (ans + res(n, i)) % MOD\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        \\n        MOD = 10**9 + 7\\n        \\n        adj = {\\n            0: [6, 4], \\n            1: [6, 8], \\n            2: [9, 7], \\n            3: [4, 8], \\n            4: [9, 3, 0], \\n            5: [], \\n            6: [7, 1, 0], \\n            7: [6, 2], \\n            8: [3, 1], \\n            9: [4, 2]\\n        }\\n        \\n        @cache\\n        def res(k, num):\\n            if k == 1:\\n                return 1\\n            else:\\n                ret = 0\\n                for i in adj[num]:\\n                    ret = (ret + res(k - 1, i)) % MOD\\n                return ret\\n        \\n        ans = 0\\n        for i in range(10):\\n            ans = (ans + res(n, i)) % MOD\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892977,
                "title": "python-dp-bottom-up",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        memo = [1 for _ in range(10)]\\n        legaljumps = {\\n            0:[4,6],\\n            1:[8,6],\\n            2:[7,9],\\n            3:[4,8],\\n            4:[0,3,9],\\n            5:[],\\n            6:[0,1,7],\\n            7:[2,6],\\n            8:[1,3],\\n            9:[2,4]\\n        }\\n        m = 10**9 + 7\\n        for i in range(2, n+1):\\n            cur = [0 for _ in range(10)]\\n            for x in range(10):\\n                for end in legaljumps[x]:\\n                    cur[end] += memo[x] \\n            memo = cur\\n        return sum(memo) % m\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        memo = [1 for _ in range(10)]\\n        legaljumps = {\\n            0:[4,6],\\n            1:[8,6],\\n            2:[7,9],\\n            3:[4,8],\\n            4:[0,3,9],\\n            5:[],\\n            6:[0,1,7],\\n            7:[2,6],\\n            8:[1,3],\\n            9:[2,4]\\n        }\\n        m = 10**9 + 7\\n        for i in range(2, n+1):\\n            cur = [0 for _ in range(10)]\\n            for x in range(10):\\n                for end in legaljumps[x]:\\n                    cur[end] += memo[x] \\n            memo = cur\\n        return sum(memo) % m\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858519,
                "title": "python-easy-to-understand-dp",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n#         init = {\\n# Note there is no key = 5, because once n >= 2, we go anywhere if we start with 5, so it is not an option\\n# E.g. 0 can come from 4 or 6\\n#             0: [4, 6],\\n#             1: [6, 8],\\n#             2: [7, 9],\\n#             3: [4, 8],\\n#             4: [0, 3, 9],\\n#             6: [0, 1, 7],\\n#             7: [2, 6],\\n#             8: [1, 3],\\n#             9: [2, 4]\\n#         }\\n        \\n        list1 = [1,1,1,1,1,0,1,1,1,1]\\n        list2 = [0,0,0,0,0,0,0,0,0,0]\\n        for i in range(n - 1):\\n\\t\\t# Just follow the init logic\\n            list2[0] = list1[4] + list1[6]\\n            list2[1] = list1[6] + list1[8]\\n            list2[2] = list1[7] + list1[9]\\n            list2[3] = list1[4] + list1[8]\\n            list2[4] = list1[0] + list1[3] + list1[9]\\n            list2[6] = list1[0] + list1[1] + list1[7]\\n            list2[7] = list1[2] + list1[6]\\n            list2[8] = list1[1] + list1[3]\\n            list2[9] = list1[2] + list1[4]\\n            list1 = list2[:]\\n        \\n        return sum(list2) % (1000000007)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n#         init = {\\n# Note there is no key = 5, because once n >= 2, we go anywhere if we start with 5, so it is not an option\\n# E.g. 0 can come from 4 or 6\\n#             0: [4, 6],\\n#             1: [6, 8],\\n#             2: [7, 9],\\n#             3: [4, 8],\\n#             4: [0, 3, 9],\\n#             6: [0, 1, 7],\\n#             7: [2, 6],\\n#             8: [1, 3],\\n#             9: [2, 4]\\n#         }\\n        \\n        list1 = [1,1,1,1,1,0,1,1,1,1]\\n        list2 = [0,0,0,0,0,0,0,0,0,0]\\n        for i in range(n - 1):\\n\\t\\t# Just follow the init logic\\n            list2[0] = list1[4] + list1[6]\\n            list2[1] = list1[6] + list1[8]\\n            list2[2] = list1[7] + list1[9]\\n            list2[3] = list1[4] + list1[8]\\n            list2[4] = list1[0] + list1[3] + list1[9]\\n            list2[6] = list1[0] + list1[1] + list1[7]\\n            list2[7] = list1[2] + list1[6]\\n            list2[8] = list1[1] + list1[3]\\n            list2[9] = list1[2] + list1[4]\\n            list1 = list2[:]\\n        \\n        return sum(list2) % (1000000007)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767477,
                "title": "golang-o-n-time-o-1-mem-simple-dp",
                "content": "```go\\nconst MOD = 1_000_000_007\\n\\nfunc knightDialer(n int) int {\\n    var prev, current [10]int\\n    for i := range prev {\\n        prev[i] = 1\\n    }\\n    \\n    for i := 1; i < n; i++ {\\n        current[0] = (prev[4] + prev[6]) % MOD\\n        current[1] = (prev[6] + prev[8]) % MOD\\n        current[2] = (prev[7] + prev[9]) % MOD\\n        current[3] = (prev[4] + prev[8]) % MOD\\n        current[4] = (prev[3] + prev[9] + prev[0]) % MOD\\n        current[5] = 0\\n        current[6] = (prev[0] + prev[1] + prev[7]) % MOD\\n        current[7] = (prev[2] + prev[6]) % MOD\\n        current[8] = (prev[1] + prev[3]) % MOD\\n        current[9] = (prev[2] + prev[4]) % MOD\\n        \\n        prev, current = current, prev\\n    }\\n    \\n    sum := 0\\n    for i := range prev {\\n        sum += prev[i]\\n        if sum >= MOD {\\n            sum -= MOD\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nconst MOD = 1_000_000_007\\n\\nfunc knightDialer(n int) int {\\n    var prev, current [10]int\\n    for i := range prev {\\n        prev[i] = 1\\n    }\\n    \\n    for i := 1; i < n; i++ {\\n        current[0] = (prev[4] + prev[6]) % MOD\\n        current[1] = (prev[6] + prev[8]) % MOD\\n        current[2] = (prev[7] + prev[9]) % MOD\\n        current[3] = (prev[4] + prev[8]) % MOD\\n        current[4] = (prev[3] + prev[9] + prev[0]) % MOD\\n        current[5] = 0\\n        current[6] = (prev[0] + prev[1] + prev[7]) % MOD\\n        current[7] = (prev[2] + prev[6]) % MOD\\n        current[8] = (prev[1] + prev[3]) % MOD\\n        current[9] = (prev[2] + prev[4]) % MOD\\n        \\n        prev, current = current, prev\\n    }\\n    \\n    sum := 0\\n    for i := range prev {\\n        sum += prev[i]\\n        if sum >= MOD {\\n            sum -= MOD\\n        }\\n    }\\n    \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578340,
                "title": "python-dp",
                "content": "def knightDialer(self, n: int) -> int:\\n        move = {0:[4,6],1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[],\\n               6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\\n        MOD = 10**9 + 7\\n        dp = [1] * 10\\n        for _ in range(1,n):\\n            dp2 = [0]* 10 \\n            for j in range(10):\\n                dp2[j] = sum([dp[i] for i in move[j]]) % MOD\\n            dp = dp2\\n        return sum(dp)%MOD",
                "solutionTags": [],
                "code": "def knightDialer(self, n: int) -> int:\\n        move = {0:[4,6],1:[6,8], 2:[7,9], 3:[4,8], 4:[0,3,9],5:[],\\n               6:[0,1,7], 7:[2,6], 8:[1,3], 9:[2,4]}\\n        MOD = 10**9 + 7\\n        dp = [1] * 10\\n        for _ in range(1,n):\\n            dp2 = [0]* 10 \\n            for j in range(10):\\n                dp2[j] = sum([dp[i] for i in move[j]]) % MOD\\n            dp = dp2\\n        return sum(dp)%MOD",
                "codeTag": "Python3"
            },
            {
                "id": 1542218,
                "title": "easy-to-understand-with-explanation-java",
                "content": "There are TEN total trees, with each 0, 1, 2 ... 9 being root nodes.\\nThe final answer, is just the sum of count of leaf nodes formed, with each 0, 1, 2, ... 9 as roots.\\n\\nNow, what does each tree look like?\\n\\nIts simple:\\nFor every root, there is a finite number of leaf nodes that one can reach. \\nFor instance: \\n* \\tWith 0 as the root node, it can reach nodes 4 and 6 ( children )\\n\\t* \\tFirst child, node 4, can form links with nodes 0, 9, 3 \\n\\t* \\tSecond child, node 6, can form links with nodes 0, 1, 7\\n\\t\\n\\tThis continues till level n.\\n\\tCount the number of leaf nodes, add it to a sum variable.\\n\\t\\nWith one particular exception, which is node with root as 5. No one can reach node 5, nor can node 5 form any children.\\n\\nBruteforce would obviously timeout, because it involves recursively traversing all branches, more than once.\\n\\nA simple straight forward solution, would be to count the number of parents, that a node can have, which eventually contributes to the number of pathways from the root node.\\n\\nFor n = 1, there are no parents. So the base case, is the number of root nodes themselves, i.e 10.\\nFor n = 2:\\n\\tNode 0 can be a parent of 4 and 6,\\n\\tNode 1 can be a parent of 6 and 8 \\n\\t...\\n\\t...\\n\\tSo the final parent counts of each node for n = 2 will be:\\n\\tFor node 0 => 2 possible parents;\\n\\t\\t  node 1 => 2 possible parents;\\n\\t\\t\\t\\t   2 => 2 possible parents; \\n\\t\\t\\t\\t   3 => 2 possible parents; \\n\\t\\t\\t\\t   4 => 3 possible parents;\\n\\t\\t\\t\\t   5 => 0 possible parents;\\n\\t\\t\\t\\t   6 => 3 possible parents;\\n\\t\\t\\t\\t   7 => 2 possible parents;\\n\\t\\t\\t\\t   8 => 2 possible parents; \\n\\t\\t\\t\\t   9 => 2 possible parents;\\n\\t\\t\\t\\t   \\nTotal parent count for all nodes from 0 to 9 is = 20 ( which is the expected answer );\\n\\nBelow is the code, where branches array indicate parent to child links, branch[0] is  parent, branch[1] is the child.\\n\\nFinal Solution:\\n```\\nclass Solution {\\n    public int knightDialer(int n) {        \\n        if(n == 1) {\\n            return 10;\\n        }\\n        \\n        int[][] branches = {{0, 4}, {0, 6}, {1, 6}, {1, 8}, {2, 7}, {2, 9},\\n                            {3, 4}, {3, 8}, {4, 0}, {4, 9}, {4, 3},\\n                            {6, 0}, {6, 1}, {6, 7}, {7, 2}, {7, 6}, {8, 1}, {8, 3},\\n                            {9, 2}, {9, 4}};\\n        \\n        long[] counts = new long[10];        \\n        Arrays.fill(counts, 1);\\n        \\n        final int MOD = 1_000_000_007;\\n        for(int i = 1; i < n; i++) {\\n            long[] nextCounts = new long[10];            \\n            for(int[] pair: branches) {\\n                nextCounts[pair[1]] = (nextCounts[pair[1]] + counts[pair[0]]) % MOD;\\n            }\\n            counts = nextCounts;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < 10; i++) {\\n            sum = (int)((sum + counts[i]) % MOD);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {        \\n        if(n == 1) {\\n            return 10;\\n        }\\n        \\n        int[][] branches = {{0, 4}, {0, 6}, {1, 6}, {1, 8}, {2, 7}, {2, 9},\\n                            {3, 4}, {3, 8}, {4, 0}, {4, 9}, {4, 3},\\n                            {6, 0}, {6, 1}, {6, 7}, {7, 2}, {7, 6}, {8, 1}, {8, 3},\\n                            {9, 2}, {9, 4}};\\n        \\n        long[] counts = new long[10];        \\n        Arrays.fill(counts, 1);\\n        \\n        final int MOD = 1_000_000_007;\\n        for(int i = 1; i < n; i++) {\\n            long[] nextCounts = new long[10];            \\n            for(int[] pair: branches) {\\n                nextCounts[pair[1]] = (nextCounts[pair[1]] + counts[pair[0]]) % MOD;\\n            }\\n            counts = nextCounts;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < 10; i++) {\\n            sum = (int)((sum + counts[i]) % MOD);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503880,
                "title": "python-o-log-n-solution-beats-100-with-fast-power",
                "content": "* By symmetry, when n >= 2 there are only four states s0: [1, 3, 7, 9], s1: [2, 8], s2: [4, 6], s3: [0]\\n* The transform is linear, thus, we are able to use the fast power of matrix to solve it\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # equivalence: 0: 1 = 3 = 7 = 9, 1: 2 = 8, 2: 4 = 6, 3: 0, 5\\n\\t\\t\\n        def matmul(a, b):\\n            m = len(a)\\n            n = len(b)\\n            p = len(b[0])\\n            res = [[0] * p for _ in range(m)]\\n            \\n            for i in range(m):\\n                for k in range(n):\\n                    for j in range(p):\\n                        res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % LARGE_PRIME\\n            return res\\n        \\n        def matpow(a, n):\\n            cur = a\\n            \\n            res = [[0] * len(a) for _ in range(len(a))]\\n            for i in range(len(a)):\\n                res[i][i] = 1\\n            \\n            while n > 0:\\n                if n % 2:\\n                    res = matmul(res, cur)\\n                cur = matmul(cur, cur)\\n                n //= 2\\n                \\n            return res\\n        \\n        if n == 1:\\n            return 10\\n        \\n        LARGE_PRIME = 10 ** 9 + 7\\n        \\n        res2 = [[2], [2], [3], [2]]\\n        T = [[0, 1, 1, 0],\\n            [2, 0, 0, 0],\\n            [2, 0, 0, 1],\\n            [0, 0, 2, 0]]\\n        \\n        Tn = matpow(T, n - 2)\\n        res = matmul(Tn, res2)\\n        return (4 * res[0][0] + 2 * res[1][0] + 2 * res[2][0] + res[3][0]) % LARGE_PRIME\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # equivalence: 0: 1 = 3 = 7 = 9, 1: 2 = 8, 2: 4 = 6, 3: 0, 5\\n\\t\\t\\n        def matmul(a, b):\\n            m = len(a)\\n            n = len(b)\\n            p = len(b[0])\\n            res = [[0] * p for _ in range(m)]\\n            \\n            for i in range(m):\\n                for k in range(n):\\n                    for j in range(p):\\n                        res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % LARGE_PRIME\\n            return res\\n        \\n        def matpow(a, n):\\n            cur = a\\n            \\n            res = [[0] * len(a) for _ in range(len(a))]\\n            for i in range(len(a)):\\n                res[i][i] = 1\\n            \\n            while n > 0:\\n                if n % 2:\\n                    res = matmul(res, cur)\\n                cur = matmul(cur, cur)\\n                n //= 2\\n                \\n            return res\\n        \\n        if n == 1:\\n            return 10\\n        \\n        LARGE_PRIME = 10 ** 9 + 7\\n        \\n        res2 = [[2], [2], [3], [2]]\\n        T = [[0, 1, 1, 0],\\n            [2, 0, 0, 0],\\n            [2, 0, 0, 1],\\n            [0, 0, 2, 0]]\\n        \\n        Tn = matpow(T, n - 2)\\n        res = matmul(Tn, res2)\\n        return (4 * res[0][0] + 2 * res[1][0] + 2 * res[2][0] + res[3][0]) % LARGE_PRIME\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443294,
                "title": "java-solution-top-down-dp",
                "content": "\\tclass Solution {\\n    char[][] board = new char[4][3];\\n    int mod = 1000000007;\\n    \\n    public int knightDialer(int n) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(0, new int[]{4,6});\\n        map.put(1, new int[]{8,6});\\n        map.put(2, new int[]{7,9});\\n        map.put(3, new int[]{4,8});\\n        map.put(4, new int[]{0,9,3});\\n        map.put(6, new int[]{7,0,1});\\n        map.put(7, new int[]{2,6});\\n        map.put(8, new int[]{1,3});\\n        map.put(9, new int[]{2,4});\\n        \\n        Map<String,Integer> memoization = new HashMap<String,Integer>();\\n        int ans = 0;\\n        for(int i = 0; i <= 9; i++)\\n        {\\n            ans = (ans + dfs(map, i, n, memoization))%mod;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int dfs(Map<Integer, int[]> map, int src, int n, Map<String,Integer> memoization)\\n    {\\n        if(n == 1)\\n        {\\n            return 1;\\n        }\\n        \\n        String key = src + \" \"+ n;\\n        if(memoization.containsKey(key))\\n        {\\n            return memoization.get(key);\\n        }\\n        \\n        int localAns = 0;\\n        if(map.containsKey(src))\\n        {\\n            for(int target : map.get(src))\\n            {\\n                localAns = (localAns + dfs(map, target, n-1, memoization))%mod;\\n            }\\n        }\\n        \\n        memoization.put(key, localAns);\\n        return memoization.get(key);\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    char[][] board = new char[4][3];\\n    int mod = 1000000007;\\n    \\n    public int knightDialer(int n) {\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(0, new int[]{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 1419970,
                "title": "java-o-1-space-dp",
                "content": "\\n```\\n    private int mod = 1_000_000_007 ;\\n    public int knightDialer(int n) {\\n        if(n==1) return 10;\\n        \\n        long[] cur = new long[10];\\n        long[] pre = new long[10];\\n        \\n        for(int i=0; i < 10 ;i++) \\n            pre[i] = 1;\\n        \\n        while(n>1) {\\n            cur[0] = (pre[4]+pre[6]) % mod;\\n            cur[1] = (pre[8]+pre[6]) % mod;\\n            cur[2] = (pre[7]+pre[9]) % mod;\\n            cur[3] = (pre[4]+pre[8]) % mod;\\n            cur[4] = (pre[0]+pre[3]+pre[9]) % mod;\\n            cur[6] = (pre[1]+pre[7]+pre[0]) % mod;\\n            cur[7] = (pre[2]+pre[6]) % mod;\\n            cur[8] = (pre[1]+pre[3]) % mod;\\n            cur[9] = (pre[2]+pre[4]) % mod;\\n            for(int i=0; i < 10 ;i++) pre[i] = cur[i];\\n            n--;\\n        }\\n        \\n        int numbers = 0;\\n        for(int i=0; i < 10; i++) \\n            numbers = (int) (numbers + cur[i]) % mod ;\\n        return numbers;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int mod = 1_000_000_007 ;\\n    public int knightDialer(int n) {\\n        if(n==1) return 10;\\n        \\n        long[] cur = new long[10];\\n        long[] pre = new long[10];\\n        \\n        for(int i=0; i < 10 ;i++) \\n            pre[i] = 1;\\n        \\n        while(n>1) {\\n            cur[0] = (pre[4]+pre[6]) % mod;\\n            cur[1] = (pre[8]+pre[6]) % mod;\\n            cur[2] = (pre[7]+pre[9]) % mod;\\n            cur[3] = (pre[4]+pre[8]) % mod;\\n            cur[4] = (pre[0]+pre[3]+pre[9]) % mod;\\n            cur[6] = (pre[1]+pre[7]+pre[0]) % mod;\\n            cur[7] = (pre[2]+pre[6]) % mod;\\n            cur[8] = (pre[1]+pre[3]) % mod;\\n            cur[9] = (pre[2]+pre[4]) % mod;\\n            for(int i=0; i < 10 ;i++) pre[i] = cur[i];\\n            n--;\\n        }\\n        \\n        int numbers = 0;\\n        for(int i=0; i < 10; i++) \\n            numbers = (int) (numbers + cur[i]) % mod ;\\n        return numbers;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1318678,
                "title": "java-dp-and-recursive-solution",
                "content": "Java DP\\n```\\nprivate int knightDialerDP(int n) {\\n        long[][] dp = new long[n][10];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][0] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n            dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n            dp[i][2] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n            dp[i][3] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n            dp[i][4] = (dp[i-1][0] + dp[i-1][3] + dp[i-1][9]) % mod;\\n            dp[i][6] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][7]) % mod;\\n            dp[i][7] = (dp[i-1][2] + dp[i-1][6]) % mod;\\n            dp[i][8] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n            dp[i][9] = (dp[i-1][2] + dp[i-1][4]) % mod;\\n        }\\n        long sum = 0;\\n        for(long val : dp[n-1]) sum = (sum + val) % mod;\\n        return (int)sum;\\n    }\\n    ```\\n\\tJava recursive\\n\\t```\\n    private int knightDialerRecur(int n) {\\n        long [][][] memo = new long [n+1][4][3];\\n        long sum = 0;\\n        for (int r = 0; r < 4; r++) {\\n            for (int c = 0; c < 3; c ++)\\n            sum = (sum + knightDialerRecurHelper(n, r, c, memo)) % mod;\\n        }\\n        \\n        return (int) sum;\\n    }\\n    \\n    private long knightDialerRecurHelper(int n, int r, int c, long[][][] memo) {\\n        if((r == 3 && c != 1) || r < 0 || c< 0 || r >= 4 || c >= 3) return 0;\\n        if(n == 1) return 1;\\n        if(memo[n][r][c] != 0) return memo[n][r][c];\\n        long sum = 0;\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c - 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c - 2, memo) % mod);\\n        memo[n][r][c] = sum;\\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nprivate int knightDialerDP(int n) {\\n        long[][] dp = new long[n][10];\\n        Arrays.fill(dp[0],1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            dp[i][0] = (dp[i-1][4] + dp[i-1][6]) % mod;\\n            dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod;\\n            dp[i][2] = (dp[i-1][7] + dp[i-1][9]) % mod;\\n            dp[i][3] = (dp[i-1][4] + dp[i-1][8]) % mod;\\n            dp[i][4] = (dp[i-1][0] + dp[i-1][3] + dp[i-1][9]) % mod;\\n            dp[i][6] = (dp[i-1][0] + dp[i-1][1] + dp[i-1][7]) % mod;\\n            dp[i][7] = (dp[i-1][2] + dp[i-1][6]) % mod;\\n            dp[i][8] = (dp[i-1][1] + dp[i-1][3]) % mod;\\n            dp[i][9] = (dp[i-1][2] + dp[i-1][4]) % mod;\\n        }\\n        long sum = 0;\\n        for(long val : dp[n-1]) sum = (sum + val) % mod;\\n        return (int)sum;\\n    }\\n    ```\n```\\n    private int knightDialerRecur(int n) {\\n        long [][][] memo = new long [n+1][4][3];\\n        long sum = 0;\\n        for (int r = 0; r < 4; r++) {\\n            for (int c = 0; c < 3; c ++)\\n            sum = (sum + knightDialerRecurHelper(n, r, c, memo)) % mod;\\n        }\\n        \\n        return (int) sum;\\n    }\\n    \\n    private long knightDialerRecurHelper(int n, int r, int c, long[][][] memo) {\\n        if((r == 3 && c != 1) || r < 0 || c< 0 || r >= 4 || c >= 3) return 0;\\n        if(n == 1) return 1;\\n        if(memo[n][r][c] != 0) return memo[n][r][c];\\n        long sum = 0;\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c + 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 2, c - 1, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c + 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r + 1, c - 2, memo) % mod);\\n           sum = (sum + knightDialerRecurHelper(n - 1, r - 1, c - 2, memo) % mod);\\n        memo[n][r][c] = sum;\\n        return sum;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1198572,
                "title": "faster-than-90-both-recursive-memo-dp-and-table-iterative-dp-solution",
                "content": "**Recursive+Memo Dp-Solution:**\\njava code is:\\n# \\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    Integer dp[][];\\n    int find(int curr,int n){\\n        if(n==0)return 1;\\n        if(dp[curr][n]!=null)return dp[curr][n];\\n        int res=0;\\n        for(int a : arr[curr]){\\n            res=(res+find(a,n-1))%mod;\\n        }\\n        return dp[curr][n]=res;\\n    }\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        dp=new Integer[10][n+1];\\n        int res=0;\\n        for(int i=0;i<=9;i++)\\n            res=(res+find(i,n-1))%mod;\\n        return res;\\n    }\\n}\\n```\\n\\n**Table-Dp(Iterative) Solution:**\\n# \\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        int dp[][]=new int[n][10];\\n        dp[0]=new int[]{1,1,1,1,1,1,1,1,1,1};\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int next : arr[j]){\\n                    dp[i+1][next]=(dp[i+1][next]+dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int j=0;j<10;j++)res=(res+dp[n-1][j])%mod;\\n        return res;\\n    }\\n}\\n```\\n***Please,Upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    Integer dp[][];\\n    int find(int curr,int n){\\n        if(n==0)return 1;\\n        if(dp[curr][n]!=null)return dp[curr][n];\\n        int res=0;\\n        for(int a : arr[curr]){\\n            res=(res+find(a,n-1))%mod;\\n        }\\n        return dp[curr][n]=res;\\n    }\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        dp=new Integer[10][n+1];\\n        int res=0;\\n        for(int i=0;i<=9;i++)\\n            res=(res+find(i,n-1))%mod;\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int mod=1000000007;\\n    int arr[][];\\n    public int knightDialer(int n) {\\n        arr=new int[][]{{4,6},{6,8},{7,9},{8,4},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}};\\n        int dp[][]=new int[n][10];\\n        dp[0]=new int[]{1,1,1,1,1,1,1,1,1,1};\\n        for(int i=0;i<n-1;i++){\\n            for(int j=0;j<10;j++){\\n                for(int next : arr[j]){\\n                    dp[i+1][next]=(dp[i+1][next]+dp[i][j])%mod;\\n                }\\n            }\\n        }\\n        int res=0;\\n        for(int j=0;j<10;j++)res=(res+dp[n-1][j])%mod;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166451,
                "title": "vanilla-growing-dp",
                "content": "The idea is to grow from N=1;\\nWe create a dp array, this dp array stores all the possible combinations starting from the corresponding digit.\\nWe have 2 arrays, of new values of and old values. After every iteration the old values have to be updated as the new values. Let\\'s call our old array t1 and new array t2, based on the L paded phone. We can make the following recurrence relations for numbers starting with each digit.\\nt1 is the old array and t2 is the new array.\\nt2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\nSo for N=1 the array looks like this\\n# [1 1 1 1 1 1 1 1 1 1]\\nfor N=2 the possible combinations are;\\n{04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94} and the array looks like this\\n # [2 2 2 2 3 0 3 2 2 2]\\n For N=3, this is what the array looks like\\n # [6 5 4 4 6 0 6 5 4 5]\\n \\n\\n\\n**Here\\'s the code**\\n\\n```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n==1) return(10);\\n            long t1[]=new long[10];\\n            long t2[]=new long[10];\\n            Arrays.fill(t1,1);\\n            while(n-->1){\\n                t2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\n                for(int i=0;i<10;i++) t1[i]=t2[i]%1000000007;\\n            }\\n            long sum=0;\\n            for(int i=0;i<10;i++) sum=(sum+t1[i])%1000000007;\\n            return (int)sum;\\n    }}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n==1) return(10);\\n            long t1[]=new long[10];\\n            long t2[]=new long[10];\\n            Arrays.fill(t1,1);\\n            while(n-->1){\\n                t2[0]=t1[6]+t1[4];\\n                t2[1]=t1[6]+t1[8];\\n                t2[2]=t1[7]+t1[9];\\n                t2[3]=t1[4]+t1[8];\\n                t2[4]=t1[0]+t1[3]+t1[9];\\n                t2[5]=0;\\n                t2[6]=t1[0]+t1[1]+t1[7];\\n                t2[7]=t1[2]+t1[6];\\n                t2[8]=t1[1]+t1[3];\\n                t2[9]=t1[2]+t1[4];\\n                for(int i=0;i<10;i++) t1[i]=t2[i]%1000000007;\\n            }\\n            long sum=0;\\n            for(int i=0;i<10;i++) sum=(sum+t1[i])%1000000007;\\n            return (int)sum;\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141532,
                "title": "python-o-n-o-logn-beat-98",
                "content": "Python - O(n):\\n\\nDP[i, num]: the total ways of forming a string (length i) with last element (num)\\ncurrent ways [last element \\'num\\'] = previous ways which can jump on \\'num\\'\\nFor example, DP[i, 2] = DP[i-1, 7] + DP[i-1, 9]\\n\\nVectorize this idea: DP[i, :] = DP[i-1, :] * matrixA\\nmatrixA is a 10 x 10 matrix, which represents the rule of chess knight jump.\\n\\nSo final results, DP[n, :] = DP[1,:] * (matrixA ** (n-1))\\n\\n\\nHowever, 10 x 10 matrix is still huge. We can further simplify this.\\nBased on the knight jump rule, we can divide [0,1,2,3,4,6,7,8,9] (no 5 since no number can jump on 5)\\ninto 4 types: C (corner, 1, 3, 7, 9), E0 (Edge0, 4, 6, i.e. edge can jump to 0), E1 (Edge1, 2, 8), O (0)\\n\\nThe jump rule is:\\n1C   -> 1E0 + 1E1\\n1E0 -> 2C + 1O\\n1E1 -> 2C\\n1O  -> 2E0\\n\\nSo, if DP[i,:] = [numC, numE0, numE1, numO],\\nthen matrixA = [[ 0 1 1 0]\\n                          [ 2 0 0 1]\\n                          [ 2 0 0 0]\\n                          [ 0 2 0 0]]\\n\\nThis can be simplified as 4 x 4 matrix multiplication.\\nDP[i, :] = DP[i-1, :] * matrixA\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = self.update(numbers)\\n        return sum(numbers) % (10**9 + 7)            \\n        \\n\\tdef update(self,numbers):\\n\\t\\tnumC = 2*numbers[1] + 2*numbers[2]\\n\\t\\tnumE0 = numbers[0] + 2*numbers[3]\\n\\t\\tnumE1 = numbers[0]\\n\\t\\tnumO = numbers[1]\\n\\t\\treturn [numC, numE0, numE1, numO]\\n        \\n            \\n```\\n\\nIn short:\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = [2*numbers[1] + 2*numbers[2], numbers[0] + 2*numbers[3], numbers[0], numbers[1]]\\n        return sum(numbers) % (10**9 + 7)  \\n```\\n\\n\\n\\n\\nImprovement:\\n\\nDP[i, :] = DP[i-1, :] * matrixA <==> DP[n, :] = DP[1,:] * (matrixA ** (n-1))\\nThe problem is to calculate matrixB = matrixA ** (n-1)\\nwhich is O(logn) if we use divide and conqur in \\'Power (x, n)\\' problem\\n\\nPython - O(logn) :\\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10\\n        \\n        numbers = np.matrix([[4, 2, 2, 1]], dtype=object)\\n        A = np.matrix([[ 0, 1, 1, 0],\\n             [ 2, 0, 0, 1],\\n             [ 2, 0, 0, 0],\\n             [ 0, 2, 0, 0]], dtype=object)\\n        \\n        B, n = np.eye(4, dtype=object), n - 1\\n        while n > 0:\\n            n, res = n // 2, n % 2\\n            if res == 1: B = np.dot(B, A)  % (10**9+7)\\n            A = np.dot(A, A) % (10**9+7)\\n        return np.sum(np.dot(numbers, B)) % (10**9+7)\\n```\\n\\nThe O(N) method takes around 140-170 ms, 95% in Python.\\nHowever, due to the time complex of matrix multiplication, the final time for O(logN) is around 100 ms, 98% in Python.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = self.update(numbers)\\n        return sum(numbers) % (10**9 + 7)            \\n        \\n\\tdef update(self,numbers):\\n\\t\\tnumC = 2*numbers[1] + 2*numbers[2]\\n\\t\\tnumE0 = numbers[0] + 2*numbers[3]\\n\\t\\tnumE1 = numbers[0]\\n\\t\\tnumO = numbers[1]\\n\\t\\treturn [numC, numE0, numE1, numO]\\n        \\n            \\n```\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10          \\n        numbers = [4, 2, 2, 1]      \\n        for _ in range(n-1): numbers = [2*numbers[1] + 2*numbers[2], numbers[0] + 2*numbers[3], numbers[0], numbers[1]]\\n        return sum(numbers) % (10**9 + 7)  \\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 0: return 0\\n        if n == 1: return 10\\n        \\n        numbers = np.matrix([[4, 2, 2, 1]], dtype=object)\\n        A = np.matrix([[ 0, 1, 1, 0],\\n             [ 2, 0, 0, 1],\\n             [ 2, 0, 0, 0],\\n             [ 0, 2, 0, 0]], dtype=object)\\n        \\n        B, n = np.eye(4, dtype=object), n - 1\\n        while n > 0:\\n            n, res = n // 2, n % 2\\n            if res == 1: B = np.dot(B, A)  % (10**9+7)\\n            A = np.dot(A, A) % (10**9+7)\\n        return np.sum(np.dot(numbers, B)) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087365,
                "title": "python-top-down-hard-coding",
                "content": "Inspired by the solution on [https://leetcode.com/problems/knight-dialer/discuss/190787/How-to-solve-this-problem-explained-for-noobs!!!](http://) \\n[top rated top down solution](https://leetcode.com/problems/knight-dialer/discuss/190787/How-to-solve-this-problem-explained-for-noobs!!!) This solution is so generalized and not taking any advantage of only 10 numbers.\\nThe rule has known, so we could create a variable called \"paths\" to hard code all the possibilities.\\n\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        bound = 10**9 + 7\\n        paths = {1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],\\\\\\n                 6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]} \\n        \\n        visited = {} # (num,n)\\n\\n        def dfs(num, n):\\n            if (num,n) in visited:\\n                return visited[(num,n)]\\n            \\n            if n==1:\\n                # if num!=5:\\n                # visited[(num,1)] = 1\\n                return 1\\n                    # return 0\\n            \\n            s = 0\\n            for i in paths[num]:\\n                s+=dfs(i,n-1)%bound\\n            \\n            visited[(num,n)] = s % bound\\n            return visited[(num,n)]\\n        \\n        \\n        res = 0\\n        for i in range(10):\\n            res+=dfs(i,n)%bound\\n        return res % bound\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        bound = 10**9 + 7\\n        paths = {1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],\\\\\\n                 6:[0,1,7],7:[2,6],8:[1,3],9:[2,4],0:[4,6]} \\n        \\n        visited = {} # (num,n)\\n\\n        def dfs(num, n):\\n            if (num,n) in visited:\\n                return visited[(num,n)]\\n            \\n            if n==1:\\n                # if num!=5:\\n                # visited[(num,1)] = 1\\n                return 1\\n                    # return 0\\n            \\n            s = 0\\n            for i in paths[num]:\\n                s+=dfs(i,n-1)%bound\\n            \\n            visited[(num,n)] = s % bound\\n            return visited[(num,n)]\\n        \\n        \\n        res = 0\\n        for i in range(10):\\n            res+=dfs(i,n)%bound\\n        return res % bound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007506,
                "title": "easy-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    char t[4][3]={{\\'1\\',\\'2\\',\\'3\\'},\\n                  {\\'4\\',\\'5\\',\\'6\\'},\\n                  {\\'7\\',\\'8\\',\\'9\\'},\\n                  {\\'*\\',\\'0\\',\\'#\\'}};\\n    \\n    int row=4,col=3;\\n    int dx[8]={-2,-2,-1,1,2,2,-1,1};\\n    int dy[8]={-1,1,2,2,-1,1,-2,-2};\\n    \\n    int dp[4][3][5001]={0};\\n    \\n    bool isValid(int x, int y){\\n        return (x>=0 && x<4 && y>=0 && y<3 && t[x][y]!=\\'*\\'&& t[x][y]!=\\'#\\');\\n    }\\n    \\n    int solve(int i, int j, int n){\\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[i][j][n]!=0)\\n            return dp[i][j][n];\\n        \\n        int s=0;\\n        for(int k=0;k<8;k++){\\n            if(isValid(i+dx[k], j+dy[k])){\\n                s=(s+solve(i+dx[k],j+dy[k],n-1))%1000000007;\\n            }\\n        }\\n        return dp[i][j][n]=s%1000000007;\\n    }\\n    \\n    int knightDialer(int n) {\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if(t[i][j]!=\\'*\\' && t[i][j]!=\\'#\\'){\\n                    ans=(ans+solve(i,j,n))%1000000007;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char t[4][3]={{\\'1\\',\\'2\\',\\'3\\'},\\n                  {\\'4\\',\\'5\\',\\'6\\'},\\n                  {\\'7\\',\\'8\\',\\'9\\'},\\n                  {\\'*\\',\\'0\\',\\'#\\'}};\\n    \\n    int row=4,col=3;\\n    int dx[8]={-2,-2,-1,1,2,2,-1,1};\\n    int dy[8]={-1,1,2,2,-1,1,-2,-2};\\n    \\n    int dp[4][3][5001]={0};\\n    \\n    bool isValid(int x, int y){\\n        return (x>=0 && x<4 && y>=0 && y<3 && t[x][y]!=\\'*\\'&& t[x][y]!=\\'#\\');\\n    }\\n    \\n    int solve(int i, int j, int n){\\n        if(n==1)\\n            return 1;\\n        \\n        if(dp[i][j][n]!=0)\\n            return dp[i][j][n];\\n        \\n        int s=0;\\n        for(int k=0;k<8;k++){\\n            if(isValid(i+dx[k], j+dy[k])){\\n                s=(s+solve(i+dx[k],j+dy[k],n-1))%1000000007;\\n            }\\n        }\\n        return dp[i][j][n]=s%1000000007;\\n    }\\n    \\n    int knightDialer(int n) {\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if(t[i][j]!=\\'*\\' && t[i][j]!=\\'#\\'){\\n                    ans=(ans+solve(i,j,n))%1000000007;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929183,
                "title": "dp-memoization-approach-o-n-easy-to-understand-short-code",
                "content": "## Explanation\\n\\nFirst we need to realize what are **DP** depends on. It\\'s pretty clear that the length of the number **n** is one such parameter, the other one is our **Starting Point** say if we have n = 2\\nand we start from digit 1 then :\\n``` \\ndp[1][2] = dp[6][1] + dp[8][1];\\n```\\n**Hence we need to add answer for all possible starting points and get our answer**\\n\\n\\n# Code\\n```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{4,6,-1}, {6,8,-1},{7,9,-1},{4,8,-1},{3,0,9},\\n                               {-1,-1,-1},{0,7,1},{6,2,-1},{1,3,-1},{2,4,-1}};  \\n\\t\\t\\t\\t\\t\\t\\t   // dir[i] represents the options that we have to jump to if starting from \\'i\\' digit\\n    \\n    ll solve(int start, int n, vector<vector<int>> &dp){\\n        \\n        if(start == -1) return 0; // can\\'t jump out here coz either out of bound or */#\\n        if(n == 1) return 1; // base case\\n\\n        if(dp[start][n] != -1) return dp[start][n];\\n        \\n        ll res = 0;\\n        for(int i = 0; i<dir[start].size(); i++)\\n            res = (res + solve(dir[start][i],n-1,dp)) %mod; // jumping to possible option\\n        \\n        return dp[start][n] = res;\\n        }\\n        \\n    int knightDialer(int n) {\\n     \\n        // LOGIC\\n        // result depends on n and where we start from except * and #\\n        ll ans = 0;\\n        for(int i = 0; i< 10; i++){  // for all possible starting points\\n            vector<vector<int>> dp(10,vector<int>(n+1,-1));\\n            ans += solve(i,n,dp);\\n            ans %= mod;\\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` \\ndp[1][2] = dp[6][1] + dp[8][1];\\n```\n```\\n#define mod 1000000007\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> dir = {{4,6,-1}, {6,8,-1},{7,9,-1},{4,8,-1},{3,0,9},\\n                               {-1,-1,-1},{0,7,1},{6,2,-1},{1,3,-1},{2,4,-1}};  \\n\\t\\t\\t\\t\\t\\t\\t   // dir[i] represents the options that we have to jump to if starting from \\'i\\' digit\\n    \\n    ll solve(int start, int n, vector<vector<int>> &dp){\\n        \\n        if(start == -1) return 0; // can\\'t jump out here coz either out of bound or */#\\n        if(n == 1) return 1; // base case\\n\\n        if(dp[start][n] != -1) return dp[start][n];\\n        \\n        ll res = 0;\\n        for(int i = 0; i<dir[start].size(); i++)\\n            res = (res + solve(dir[start][i],n-1,dp)) %mod; // jumping to possible option\\n        \\n        return dp[start][n] = res;\\n        }\\n        \\n    int knightDialer(int n) {\\n     \\n        // LOGIC\\n        // result depends on n and where we start from except * and #\\n        ll ans = 0;\\n        for(int i = 0; i< 10; i++){  // for all possible starting points\\n            vector<vector<int>> dp(10,vector<int>(n+1,-1));\\n            ans += solve(i,n,dp);\\n            ans %= mod;\\n        }\\n    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796049,
                "title": "very-easy-c-solution-with-detailed-comments",
                "content": "```\\n  public int KnightDialer(int N) {\\t\\t\\n  \\n           //all possible \"from\" paths for each digit (index)...\\n            var fromPath = new int[][] { new int[]{ 4, 6 }, new int[] { 6, 8 }, new int[] { 7, 9 }, new int[] { 4, 8 },\\n                                new int[]{ 3, 9, 0 }, new int[]{ }, new int[]{ 1, 7, 0 }, new int[]{ 2, 6 }, new int[]{ 1, 3 }, new int[]{ 2, 4 } };\\n            \\n\\t\\t\\t//this has to be long instead of int due to this number being this large\\n\\t\\t\\tlong MOD = 1000000007;\\n\\n            var steps = N + 1; //include step 0 so N+1\\n            var possibleNumbers = 10; //0 through 9 in the keypad\\n\\n            //row will have all the steps\\n            //col will have all possible numbers\\n\\n            var rowCol = new long[steps, possibleNumbers]; //this already initializes everything to 0\\n\\n            //initialize step 1 (row 1) to have 1\\'s for all columns\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                rowCol[1, col] = 1;\\n            }\\n\\n            //fill the rest...\\n            for (int row = 2; row < steps; row++)\\n            {\\n                for (int col = 0; col < possibleNumbers; col++)\\n                {\\n                    var possibleFromPaths = fromPath[col];\\n                    foreach (var path in possibleFromPaths)\\n                    {\\n                        rowCol[row, col] += rowCol[row - 1, path];\\n                    }\\n                    rowCol[row, col] %= MOD;\\n                }               \\n            }\\n            long totalSum = 0;\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                totalSum += rowCol[N,col];\\n            }\\n\\n            totalSum = totalSum % MOD;\\n\\t\\t\\n            return (int)totalSum;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n  public int KnightDialer(int N) {\\t\\t\\n  \\n           //all possible \"from\" paths for each digit (index)...\\n            var fromPath = new int[][] { new int[]{ 4, 6 }, new int[] { 6, 8 }, new int[] { 7, 9 }, new int[] { 4, 8 },\\n                                new int[]{ 3, 9, 0 }, new int[]{ }, new int[]{ 1, 7, 0 }, new int[]{ 2, 6 }, new int[]{ 1, 3 }, new int[]{ 2, 4 } };\\n            \\n\\t\\t\\t//this has to be long instead of int due to this number being this large\\n\\t\\t\\tlong MOD = 1000000007;\\n\\n            var steps = N + 1; //include step 0 so N+1\\n            var possibleNumbers = 10; //0 through 9 in the keypad\\n\\n            //row will have all the steps\\n            //col will have all possible numbers\\n\\n            var rowCol = new long[steps, possibleNumbers]; //this already initializes everything to 0\\n\\n            //initialize step 1 (row 1) to have 1\\'s for all columns\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                rowCol[1, col] = 1;\\n            }\\n\\n            //fill the rest...\\n            for (int row = 2; row < steps; row++)\\n            {\\n                for (int col = 0; col < possibleNumbers; col++)\\n                {\\n                    var possibleFromPaths = fromPath[col];\\n                    foreach (var path in possibleFromPaths)\\n                    {\\n                        rowCol[row, col] += rowCol[row - 1, path];\\n                    }\\n                    rowCol[row, col] %= MOD;\\n                }               \\n            }\\n            long totalSum = 0;\\n            for (int col = 0; col < possibleNumbers; col++)\\n            {\\n                totalSum += rowCol[N,col];\\n            }\\n\\n            totalSum = totalSum % MOD;\\n\\t\\t\\n            return (int)totalSum;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 751674,
                "title": "swift-dfs-memo-dp",
                "content": "```\\nclass Solution {\\n    struct Position: Hashable {\\n        var n: Int\\n        var i: Int\\n    }\\n    var memo = [Position: Int]()\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        var comb = 0\\n        for start in moves.keys {\\n            comb += dial(N, start)  % mode\\n        }\\n\\n        return comb  % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        let pos = Position(n: N, i: i)\\n        if let c = memo[pos] { return c }\\n\\n        if N == 1 { return 1 }\\n\\n        var comb = 0\\n        for next in self.moves[i]! {\\n            comb = comb + dial(N-1, next)  % mode\\n        }\\n\\n        memo[pos, default: 0] = comb\\n        return memo[pos, default: 0]\\n    }\\n}\\n\\nclass Solution {\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    var dp = [[Int]]()\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        self.dp = Array(repeating: Array(repeating: 0, count: 10), count: N)\\n        dp[0] = [1,1,1,1,1,1,1,1,1,1]\\n        var res = 0\\n        for start in moves.keys {\\n            res += dial(N-1, start)\\n        }\\n\\n        return res % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        if dp[N][i] > 0 { return dp[N][i] }\\n\\n        for next in self.moves[i]! {\\n            dp[N][i] += dial(N-1, next)  % mode\\n        }\\n\\n        return dp[N][i]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Position: Hashable {\\n        var n: Int\\n        var i: Int\\n    }\\n    var memo = [Position: Int]()\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        var comb = 0\\n        for start in moves.keys {\\n            comb += dial(N, start)  % mode\\n        }\\n\\n        return comb  % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        let pos = Position(n: N, i: i)\\n        if let c = memo[pos] { return c }\\n\\n        if N == 1 { return 1 }\\n\\n        var comb = 0\\n        for next in self.moves[i]! {\\n            comb = comb + dial(N-1, next)  % mode\\n        }\\n\\n        memo[pos, default: 0] = comb\\n        return memo[pos, default: 0]\\n    }\\n}\\n\\nclass Solution {\\n    let moves: [Int: [Int]] = [1:[6,8], 2:[7,9], 3:[4,8],\\n                               4:[3,9,0], 5:[], 6:[1,7,0],\\n                               7:[2,6], 8:[1,3], 9:[2,4], 0:[4,6]]\\n    let mode: Int = Int(1e9 + 7)\\n\\n    var dp = [[Int]]()\\n\\n    func knightDialer(_ N: Int) -> Int {\\n        self.dp = Array(repeating: Array(repeating: 0, count: 10), count: N)\\n        dp[0] = [1,1,1,1,1,1,1,1,1,1]\\n        var res = 0\\n        for start in moves.keys {\\n            res += dial(N-1, start)\\n        }\\n\\n        return res % mode\\n    }\\n\\n    func dial(_ N: Int, _ i: Int) -> Int {\\n        if dp[N][i] > 0 { return dp[N][i] }\\n\\n        for next in self.moves[i]! {\\n            dp[N][i] += dial(N-1, next)  % mode\\n        }\\n\\n        return dp[N][i]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693989,
                "title": "easy-java-top-down-iterative-approach-with-diagram",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int modulo = (int)Math.pow(10,9)+7;\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        map.put(0,new int[] {4,6}); //Knight at 0, can jump to 4 & 6 on keypad...\\n        map.put(1,new int[] {6,8});\\n        map.put(2,new int[] {7,9});\\n        map.put(3,new int[] {4,8});\\n        map.put(4,new int[] {0,9,3});\\n        map.put(5,new int[] {});\\n        map.put(6,new int[] {1,7,0});\\n        map.put(7,new int[] {2,6});\\n        map.put(8,new int[] {1,3});\\n        map.put(9,new int[] {2,4});\\n        \\n        int[][] dp = new int[N+1][10];\\n        Arrays.fill(dp[1],1);\\n        int dial = dp[0].length;\\n        \\n        for(int i=2;i<=N;i++){\\n            for(int j=0;j<dial;j++){\\n                for(int keyNum : map.get(j)){\\n                    dp[i][j] += dp[i-1][keyNum];\\n                    dp[i][j] %= modulo;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int c=0;c<dial;c++){\\n            count += dp[N][c];\\n            count %= modulo;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nExample: \\nIf N=3, then the answer is the sum of elements from dp[N][0]...+dp[N][9]\\n\\n![image](https://assets.leetcode.com/users/alphakiller/image_1592499072.png)\\n\\nTime Complexity: O(N). Derived from O(N * dial * keyNum) = Dial is a constant & has a value of 10. KeyNum is also a constant with value either 2 or 3.\\nSpace Complexity: O(N*dial)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int N) {\\n        int modulo = (int)Math.pow(10,9)+7;\\n        HashMap<Integer, int[]> map = new HashMap<>();\\n        map.put(0,new int[] {4,6}); //Knight at 0, can jump to 4 & 6 on keypad...\\n        map.put(1,new int[] {6,8});\\n        map.put(2,new int[] {7,9});\\n        map.put(3,new int[] {4,8});\\n        map.put(4,new int[] {0,9,3});\\n        map.put(5,new int[] {});\\n        map.put(6,new int[] {1,7,0});\\n        map.put(7,new int[] {2,6});\\n        map.put(8,new int[] {1,3});\\n        map.put(9,new int[] {2,4});\\n        \\n        int[][] dp = new int[N+1][10];\\n        Arrays.fill(dp[1],1);\\n        int dial = dp[0].length;\\n        \\n        for(int i=2;i<=N;i++){\\n            for(int j=0;j<dial;j++){\\n                for(int keyNum : map.get(j)){\\n                    dp[i][j] += dp[i-1][keyNum];\\n                    dp[i][j] %= modulo;\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int c=0;c<dial;c++){\\n            count += dp[N][c];\\n            count %= modulo;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522714,
                "title": "c-dp-16ms-8-6mb-beat-100",
                "content": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n        long long int dp[N][10] = {0};\\n        for(int i = 0; i < 10; i ++){\\n            dp[0][i] = 1;\\n        }\\n        for(int i = 1; i < N; i++){\\n            for(int j = 0; j < 10; j++){\\n                switch(j){\\n                    case 1:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 2:\\n                        dp[i][j] = (dp[i - 1][7] + dp[i - 1][9]) % MOD;\\n                        break;\\n                    case 3:\\n                        dp[i][j] = (dp[i - 1][4] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 4:\\n                        dp[i][j] = (dp[i - 1][3] + dp[i - 1][9] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 5:\\n                        dp[i][j] = 0;\\n                        break;\\n                    case 6:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][7] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 7:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][2]) % MOD;\\n                        break;\\n                    case 8:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][3]) % MOD;\\n                        break;\\n                    case 9:\\n                        dp[i][j] = (dp[i - 1][2] + dp[i - 1][4]) % MOD;\\n                        break;\\n                    case 0:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][4]) % MOD;\\n                        break;\\n                }\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i = 0; i < 10; i++){\\n            sum += dp[N - 1][i];\\n            sum = sum % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define MOD 1000000007\\nclass Solution {\\npublic:\\n    int knightDialer(int N) {\\n        long long int dp[N][10] = {0};\\n        for(int i = 0; i < 10; i ++){\\n            dp[0][i] = 1;\\n        }\\n        for(int i = 1; i < N; i++){\\n            for(int j = 0; j < 10; j++){\\n                switch(j){\\n                    case 1:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 2:\\n                        dp[i][j] = (dp[i - 1][7] + dp[i - 1][9]) % MOD;\\n                        break;\\n                    case 3:\\n                        dp[i][j] = (dp[i - 1][4] + dp[i - 1][8]) % MOD;\\n                        break;\\n                    case 4:\\n                        dp[i][j] = (dp[i - 1][3] + dp[i - 1][9] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 5:\\n                        dp[i][j] = 0;\\n                        break;\\n                    case 6:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][7] + dp[i - 1][0]) % MOD;\\n                        break;\\n                    case 7:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][2]) % MOD;\\n                        break;\\n                    case 8:\\n                        dp[i][j] = (dp[i - 1][1] + dp[i - 1][3]) % MOD;\\n                        break;\\n                    case 9:\\n                        dp[i][j] = (dp[i - 1][2] + dp[i - 1][4]) % MOD;\\n                        break;\\n                    case 0:\\n                        dp[i][j] = (dp[i - 1][6] + dp[i - 1][4]) % MOD;\\n                        break;\\n                }\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i = 0; i < 10; i++){\\n            sum += dp[N - 1][i];\\n            sum = sum % MOD;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426205,
                "title": "simple-c-dp-solution",
                "content": "```\\npublic class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n        private const int ROWS = 4;\\n        private const int COLUMNS = 3;\\n        private static readonly (int, int) _stub1 = (ROWS - 1, 0);\\n        private static readonly (int, int) _stub2 = (ROWS - 1, COLUMNS - 1);\\n\\n        private static (int, int)[] _steps =\\n            {(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)};\\n\\n        public int KnightDialer(int n)\\n        {\\n            checked\\n            {\\n                int[,,] dp = new int[n, ROWS, COLUMNS];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int r = 0; r < ROWS; r++)\\n                    {\\n                        for (int c = 0; c < COLUMNS; c++)\\n                        {\\n                            if ((r == _stub1.Item1 && c == _stub1.Item2) || (r == _stub2.Item1 && c == _stub2.Item2))\\n                            {\\n                                dp[i, r, c] = 0;\\n                                continue;\\n                            }\\n\\n                            if (i == 0)\\n                            {\\n                                dp[i, r, c] = 1;\\n                                continue;\\n                            }\\n\\n                            foreach (var step in _steps)\\n                            {\\n                                int nextRow = r + step.Item1;\\n                                int nextCol = c + step.Item2;\\n\\n                                if (nextRow >= 0 && nextRow < ROWS && nextCol >= 0 && nextCol < COLUMNS)\\n                                {\\n                                    dp[i, r, c] += dp[i - 1, nextRow, nextCol];\\n                                    dp[i, r, c] = dp[i, r, c] % MODULO;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int r = 0; r < ROWS; r++)\\n                {\\n                    for (int c = 0; c < COLUMNS; c++)\\n                    {\\n                        res += dp[n - 1, r, c];\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n    {\\n        private const int MODULO = 1000000007;\\n        private const int ROWS = 4;\\n        private const int COLUMNS = 3;\\n        private static readonly (int, int) _stub1 = (ROWS - 1, 0);\\n        private static readonly (int, int) _stub2 = (ROWS - 1, COLUMNS - 1);\\n\\n        private static (int, int)[] _steps =\\n            {(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)};\\n\\n        public int KnightDialer(int n)\\n        {\\n            checked\\n            {\\n                int[,,] dp = new int[n, ROWS, COLUMNS];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int r = 0; r < ROWS; r++)\\n                    {\\n                        for (int c = 0; c < COLUMNS; c++)\\n                        {\\n                            if ((r == _stub1.Item1 && c == _stub1.Item2) || (r == _stub2.Item1 && c == _stub2.Item2))\\n                            {\\n                                dp[i, r, c] = 0;\\n                                continue;\\n                            }\\n\\n                            if (i == 0)\\n                            {\\n                                dp[i, r, c] = 1;\\n                                continue;\\n                            }\\n\\n                            foreach (var step in _steps)\\n                            {\\n                                int nextRow = r + step.Item1;\\n                                int nextCol = c + step.Item2;\\n\\n                                if (nextRow >= 0 && nextRow < ROWS && nextCol >= 0 && nextCol < COLUMNS)\\n                                {\\n                                    dp[i, r, c] += dp[i - 1, nextRow, nextCol];\\n                                    dp[i, r, c] = dp[i, r, c] % MODULO;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int r = 0; r < ROWS; r++)\\n                {\\n                    for (int c = 0; c < COLUMNS; c++)\\n                    {\\n                        res += dp[n - 1, r, c];\\n                        res = res % MODULO;\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375123,
                "title": "python-level-traversal",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        dp = [1]*10\\n        MOD = 10**9+7\\n        graph = [{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}]\\n        for i in range(N-1):\\n            temp = [0]*10\\n            for i,v in enumerate(dp):\\n                for nxt in graph[i]:\\n                    temp[nxt] += v\\n                    temp[nxt] %= MOD\\n            dp = temp\\n        return sum(dp) % MOD\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        dp = [1]*10\\n        MOD = 10**9+7\\n        graph = [{4,6},{6,8},{7,9},{4,8},{3,9,0},{},{1,7,0},{2,6},{1,3},{2,4}]\\n        for i in range(N-1):\\n            temp = [0]*10\\n            for i,v in enumerate(dp):\\n                for nxt in graph[i]:\\n                    temp[nxt] += v\\n                    temp[nxt] %= MOD\\n            dp = temp\\n        return sum(dp) % MOD\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332177,
                "title": "recursive-solution-cpp-this-is-more-reasonable-to-come-up-with-instead-of-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) \\n    {\\n        m_mem.assign(N, vector<int>(10, - 1));\\n        m_mem[0].assign(10, 1);\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i)\\n            ans = (ans + dial(i, N - 1)) % mod;\\n        return ans;\\n    }\\nprivate:\\n    int dial(int num, int N)\\n    {\\n        if(m_mem[N][num] >= 0) return m_mem[N][num];\\n        int combo = 0;\\n        for(int prev : m_moves[num])\\n            combo = (combo + dial(prev, N - 1))%mod;\\n        return m_mem[N][num] = combo;\\n    }\\n    \\n    vector<vector<int>> m_moves{{4,6}, {8,6}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {6,2},{1,3}, {4,2}};\\n    vector<vector<int>> m_mem;\\n    const int mod = 1000000007;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int N) \\n    {\\n        m_mem.assign(N, vector<int>(10, - 1));\\n        m_mem[0].assign(10, 1);\\n        int ans = 0;\\n        for(int i = 0; i <= 9; ++i)\\n            ans = (ans + dial(i, N - 1)) % mod;\\n        return ans;\\n    }\\nprivate:\\n    int dial(int num, int N)\\n    {\\n        if(m_mem[N][num] >= 0) return m_mem[N][num];\\n        int combo = 0;\\n        for(int prev : m_moves[num])\\n            combo = (combo + dial(prev, N - 1))%mod;\\n        return m_mem[N][num] = combo;\\n    }\\n    \\n    vector<vector<int>> m_moves{{4,6}, {8,6}, {7,9}, {4,8}, {3,9,0}, {}, {1,7,0}, {6,2},{1,3}, {4,2}};\\n    vector<vector<int>> m_mem;\\n    const int mod = 1000000007;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306446,
                "title": "python-4-line-solution",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\\n        for i in range(N - 1):\\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\\n        return sum(dp) % (10 ** 9 + 7)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        memo, dp = [[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[0,1,7],[2,6],[1,3],[2,4]], [1] * 10\\n        for i in range(N - 1):\\n            dp = [sum([dp[j] for j in memo[i]]) for i in range(10)]\\n        return sum(dp) % (10 ** 9 + 7)",
                "codeTag": "Java"
            },
            {
                "id": 303437,
                "title": "straightforward-python-memoization",
                "content": "```\\nclass Solution(object):\\n    moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n    \\n    def knightDialer(self, N):\\n        return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n   \\n    def knightDialer_(self, N, i, dp={}):\\n        if N == 1: return 1\\n        if (N,i) not in dp:\\n            dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\\n        return dp[(N,i)]\\n```\\n\\nOr if you\\'d rather use a generic memoization decorator:\\n\\n```\\nclass memoize:\\n    def __init__(self, f):\\n        self.f,self.memo = f,{}\\n    def __call__(self, *args):\\n        if not args in self.memo: self.memo[args] = self.f(*args)\\n        return self.memo[args]\\n\\nmoves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n   \\n@memoize\\ndef knightDialer_(N, i):\\n    if N == 1: return 1\\n    return sum(knightDialer_(N-1, j) for j in moves[i])\\n\\nclass Solution(object):\\n    def knightDialer(self, N):\\n        return sum(knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    moves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n    \\n    def knightDialer(self, N):\\n        return sum(self.knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n   \\n    def knightDialer_(self, N, i, dp={}):\\n        if N == 1: return 1\\n        if (N,i) not in dp:\\n            dp[(N,i)] = sum(self.knightDialer_(N-1, j) for j in self.moves[i])\\n        return dp[(N,i)]\\n```\n```\\nclass memoize:\\n    def __init__(self, f):\\n        self.f,self.memo = f,{}\\n    def __call__(self, *args):\\n        if not args in self.memo: self.memo[args] = self.f(*args)\\n        return self.memo[args]\\n\\nmoves = [(4,6),(6,8),(7,9),(4,8),(3,9,0),(),(1,7,0),(2,6),(1,3),(2,4)]\\n   \\n@memoize\\ndef knightDialer_(N, i):\\n    if N == 1: return 1\\n    return sum(knightDialer_(N-1, j) for j in moves[i])\\n\\nclass Solution(object):\\n    def knightDialer(self, N):\\n        return sum(knightDialer_(N, i) for i in range(10)) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294494,
                "title": "c-dynamic-programming-o-n-time-and-o-1-space",
                "content": "```\\npublic class Solution {\\n    private readonly Dictionary<int, int[]> _moves = new Dictionary<int, int[]>() { \\n        { 0, new[] { 4, 6 } },\\n        { 1, new[] { 6, 8 } },\\n        { 2, new[] { 7, 9 } },\\n        { 3, new[] { 4, 8 } },\\n        { 4, new[] { 0, 3, 9 } },\\n        { 5, new int[0] },\\n        { 6, new[] { 0, 1, 7 } },\\n        { 7, new[] { 2, 6 } },\\n        { 8, new[] { 1, 3 } },\\n        { 9, new[] { 2, 4 } }\\n    };\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int KnightDialer(int N) {\\n        int[,] dp = new int[2, 10];        \\n        int sum = 0;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int num = 0; num < 10; num++) {\\n                if (i == 0) { dp[1, num] = 1; continue; }\\n\\n                foreach (int move in _moves[num]) {\\n                    dp[1, num] += dp[0, move]; \\n                    dp[1, num] %= MOD;\\n                }\\n            }\\n            \\n            for (int num = 0; num < 10; num++) {\\n                dp[0, num] = dp[1, num];\\n                dp[1, num] = 0;\\n            }\\n        }\\n        \\n        for (int num = 0; num < 10; num++) {\\n            sum += dp[0, num];   \\n            sum %= MOD;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private readonly Dictionary<int, int[]> _moves = new Dictionary<int, int[]>() { \\n        { 0, new[] { 4, 6 } },\\n        { 1, new[] { 6, 8 } },\\n        { 2, new[] { 7, 9 } },\\n        { 3, new[] { 4, 8 } },\\n        { 4, new[] { 0, 3, 9 } },\\n        { 5, new int[0] },\\n        { 6, new[] { 0, 1, 7 } },\\n        { 7, new[] { 2, 6 } },\\n        { 8, new[] { 1, 3 } },\\n        { 9, new[] { 2, 4 } }\\n    };\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int KnightDialer(int N) {\\n        int[,] dp = new int[2, 10];        \\n        int sum = 0;\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int num = 0; num < 10; num++) {\\n                if (i == 0) { dp[1, num] = 1; continue; }\\n\\n                foreach (int move in _moves[num]) {\\n                    dp[1, num] += dp[0, move]; \\n                    dp[1, num] %= MOD;\\n                }\\n            }\\n            \\n            for (int num = 0; num < 10; num++) {\\n                dp[0, num] = dp[1, num];\\n                dp[1, num] = 0;\\n            }\\n        }\\n        \\n        for (int num = 0; num < 10; num++) {\\n            sum += dp[0, num];   \\n            sum %= MOD;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274043,
                "title": "python-rolling-dp",
                "content": "We can count number of ways to dial with K moves based on that with K-1 moves.\\nE.g. If our last dial number (Kth move) if 1, the K-1th move is either 4 or 6 based on Knight moving rule. So number of ways to reach 1 at Kth move is number of ways to reach 4 or 6at Kth move. Or ```dp[K][1] = dp[K-1][4] + dp[K-1][6]```. Based on that, we can have our recurrence equation.\\nAnd the only array we used to calculate dp[K] is dp[K-1], we can use two rolling arrays here to reduce space compleixty to O(1).\\n```\\ndef knightDialer(N):\\n\\tpad, cnt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]], [1]*10\\n\\tfor _ in range(N-1):\\n\\t\\tnext_cnt = [1]*10\\n\\t\\tfor i in range(10):\\n\\t\\t\\tnext_cnt[i] = sum(cnt[j] for j in pad[i]) % (10**9+7)\\n\\t\\tcnt = next_cnt\\n\\treturn sum(cnt) % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[K][1] = dp[K-1][4] + dp[K-1][6]```\n```\\ndef knightDialer(N):\\n\\tpad, cnt = [[4, 6], [6, 8], [7, 9], [4, 8], [0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]], [1]*10\\n\\tfor _ in range(N-1):\\n\\t\\tnext_cnt = [1]*10\\n\\t\\tfor i in range(10):\\n\\t\\t\\tnext_cnt[i] = sum(cnt[j] for j in pad[i]) % (10**9+7)\\n\\t\\tcnt = next_cnt\\n\\treturn sum(cnt) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 261616,
                "title": "java-backtrack",
                "content": "Runtime : O(10 * N)\\nSpace: O(10 * N)\\n\\n```java\\nclass Solution {\\n    // Solve problem in top down manner\\n    // Let F(i) be # of distinct numbers after i moves\\n    // Assume F(i\\') holds for all i\\' < i\\n    // F(i) is related to F(i-1) depends on where the chess is on step i. Let K be number of distinct choice at step i, we have\\n    // If chess is on 0, 1, 2, 3, 7, 8, 9, K = 2\\n    // If chess is on 4, 6, K = 3\\n    // If chess is on 5, K = 0\\n    // Base case: F(1) = 1\\n\\n    private Integer[][] memo;\\n    private int[][] nextStep = {\\n            {4, 6},\\n            {6, 8},\\n            {7, 9},\\n            {4, 8},\\n            {3, 9, 0},\\n            {},\\n            {1, 7, 0},\\n            {2, 6},\\n            {1, 3},\\n            {4, 2},\\n    };\\n\\n    public int knightDialer(int N) {\\n        this.memo = new Integer[10][N + 1];\\n        int count = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            count += backtrack(i, N);\\n            count %= 1e9 + 7;\\n        }\\n        return count;\\n    }\\n\\n    private int backtrack(int curNum, int N) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n\\n        if (memo[curNum][N] != null) {\\n            return memo[curNum][N];\\n        }\\n\\n        memo[curNum][N] = 0;\\n        for (int nextNum : nextStep[curNum]) {\\n            memo[curNum][N] += backtrack(nextNum, N - 1);\\n            memo[curNum][N] %= (int)1e9 + 7;\\n        }\\n        return memo[curNum][N];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    // Solve problem in top down manner\\n    // Let F(i) be # of distinct numbers after i moves\\n    // Assume F(i\\') holds for all i\\' < i\\n    // F(i) is related to F(i-1) depends on where the chess is on step i. Let K be number of distinct choice at step i, we have\\n    // If chess is on 0, 1, 2, 3, 7, 8, 9, K = 2\\n    // If chess is on 4, 6, K = 3\\n    // If chess is on 5, K = 0\\n    // Base case: F(1) = 1\\n\\n    private Integer[][] memo;\\n    private int[][] nextStep = {\\n            {4, 6},\\n            {6, 8},\\n            {7, 9},\\n            {4, 8},\\n            {3, 9, 0},\\n            {},\\n            {1, 7, 0},\\n            {2, 6},\\n            {1, 3},\\n            {4, 2},\\n    };\\n\\n    public int knightDialer(int N) {\\n        this.memo = new Integer[10][N + 1];\\n        int count = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            count += backtrack(i, N);\\n            count %= 1e9 + 7;\\n        }\\n        return count;\\n    }\\n\\n    private int backtrack(int curNum, int N) {\\n        if (N == 1) {\\n            return 1;\\n        }\\n\\n        if (memo[curNum][N] != null) {\\n            return memo[curNum][N];\\n        }\\n\\n        memo[curNum][N] = 0;\\n        for (int nextNum : nextStep[curNum]) {\\n            memo[curNum][N] += backtrack(nextNum, N - 1);\\n            memo[curNum][N] %= (int)1e9 + 7;\\n        }\\n        return memo[curNum][N];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241756,
                "title": "python-dp-solution",
                "content": "```\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        c = 10**9+7\\n        next_step = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\\n        dp = [1]*10\\n        for i in range(N-1):\\n            new_dp = [0]*10\\n            for j in range(10):\\n                for n in next_step[j]:\\n                    new_dp[j] += dp[n]%c\\n                new_dp[j] %=c\\n            dp = new_dp\\n        return sum(dp)%c\\n```",
                "solutionTags": [],
                "code": "```\\n    def knightDialer(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        c = 10**9+7\\n        next_step = [[4,6],[6,8],[7,9],[4,8],[0,3,9],[],[0,1,7],[2,6],[1,3],[2,4]]\\n        dp = [1]*10\\n        for i in range(N-1):\\n            new_dp = [0]*10\\n            for j in range(10):\\n                for n in next_step[j]:\\n                    new_dp[j] += dp[n]%c\\n                new_dp[j] %=c\\n            dp = new_dp\\n        return sum(dp)%c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 205506,
                "title": "c-13line",
                "content": "```\\n    int knightDialer(int N) {\\n        const long long mod = 1e9 + 7;\\n        const vector<vector<int>> g = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0},\\n            {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        vector<long long> pre(10,1), cur(10,0);\\n        for(int i=0; i<N-1;i++){\\n            for(int j=0;j<10;j++){\\n                cur[j] = 0;\\n                for(auto neighbor : g[j]) cur[j] += pre[neighbor];\\n                cur[j] %= mod;\\n            }\\n            swap(cur, pre);\\n        }\\n        return accumulate(pre.begin(), pre.end(), 0LL) % mod;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int knightDialer(int N) {\\n        const long long mod = 1e9 + 7;\\n        const vector<vector<int>> g = {{4,6}, {6,8}, {7,9}, {4,8}, {3,9,0},\\n            {}, {1,7,0}, {2,6}, {1,3}, {2,4}};\\n        vector<long long> pre(10,1), cur(10,0);\\n        for(int i=0; i<N-1;i++){\\n            for(int j=0;j<10;j++){\\n                cur[j] = 0;\\n                for(auto neighbor : g[j]) cur[j] += pre[neighbor];\\n                cur[j] %= mod;\\n            }\\n            swap(cur, pre);\\n        }\\n        return accumulate(pre.begin(), pre.end(), 0LL) % mod;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 190620,
                "title": "c-o-logn-time-o-1-space-complexity",
                "content": "If you represent the digits as nodes in a graph and create their adjacency matrix, you can raise the matrix to the (N - 1)th power to get a new adjacency matrix, the values of which now mean the number of different paths from node `i` to node `j` after (N - 1) moves. Using this in combination with the fast power for matrices allows you to do this all in O(logN).\\n\\nI\\'ve left my output of the resulting matrix there so that you can easily see it if you want to.\\n\\nI\\'ve already seen this solution here, but it was written in Python so I decided to share mine too.\\n\\n```\\n#define MOD 1000000007\\n#define DIGITS 10\\n\\nclass Solution {\\npublic:\\n    vector<vector<long long>> identity;\\n    vector<vector<long long>> edges;\\n    \\n    vector<vector<long long>> multiply(vector<vector<long long>> &m1, vector<vector<long long>> &m2) {\\n        vector<vector<long long>> result(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                for (int k = 0; k < DIGITS; k++) {\\n                    result[i][j] = (result[i][j] + m1[i][k] * m2[k][j]) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<vector<long long>> matrixPower(vector<vector<long long>> &matrix, int n) {\\n        if (n == 0) {\\n            return identity;\\n        }\\n        if (n == 1) {\\n            return matrix;\\n        }\\n        vector<vector<long long>> half = matrixPower(matrix, n / 2);\\n        vector<vector<long long>> halfSquared = multiply(half, half);\\n        return n % 2 == 0\\n            ? halfSquared\\n            : multiply(halfSquared, matrix);\\n    }\\n    \\n    void addEdge(int a, int b) {\\n        edges[a][b] = edges[b][a] = 1;\\n    }\\n    \\n    int knightDialer(int N) {\\n        identity = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            identity[i][i] = 1;\\n        }\\n        edges = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        \\n        addEdge(0, 4);\\n        addEdge(0, 6);\\n        addEdge(1, 6);\\n        addEdge(1, 8);\\n        addEdge(2, 7);\\n        addEdge(2, 9);\\n        addEdge(3, 4);\\n        addEdge(3, 8);\\n        addEdge(4, 9);\\n        addEdge(6, 7);\\n        \\n        vector<vector<long long>> power = matrixPower(edges, N - 1);\\n        // for (int i = 0; i < DIGITS; i++) {\\n        //     for (int j = 0; j < DIGITS; j++) {\\n        //         cout << power[i][j] << \" \";\\n        //     }\\n        //     cout << \"\\\\n\";\\n        // }\\n        long long sum = 0;\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                sum += power[i][j];\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n#define DIGITS 10\\n\\nclass Solution {\\npublic:\\n    vector<vector<long long>> identity;\\n    vector<vector<long long>> edges;\\n    \\n    vector<vector<long long>> multiply(vector<vector<long long>> &m1, vector<vector<long long>> &m2) {\\n        vector<vector<long long>> result(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                for (int k = 0; k < DIGITS; k++) {\\n                    result[i][j] = (result[i][j] + m1[i][k] * m2[k][j]) % MOD;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    vector<vector<long long>> matrixPower(vector<vector<long long>> &matrix, int n) {\\n        if (n == 0) {\\n            return identity;\\n        }\\n        if (n == 1) {\\n            return matrix;\\n        }\\n        vector<vector<long long>> half = matrixPower(matrix, n / 2);\\n        vector<vector<long long>> halfSquared = multiply(half, half);\\n        return n % 2 == 0\\n            ? halfSquared\\n            : multiply(halfSquared, matrix);\\n    }\\n    \\n    void addEdge(int a, int b) {\\n        edges[a][b] = edges[b][a] = 1;\\n    }\\n    \\n    int knightDialer(int N) {\\n        identity = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        for (int i = 0; i < DIGITS; i++) {\\n            identity[i][i] = 1;\\n        }\\n        edges = vector<vector<long long>>(DIGITS, vector<long long>(DIGITS));\\n        \\n        addEdge(0, 4);\\n        addEdge(0, 6);\\n        addEdge(1, 6);\\n        addEdge(1, 8);\\n        addEdge(2, 7);\\n        addEdge(2, 9);\\n        addEdge(3, 4);\\n        addEdge(3, 8);\\n        addEdge(4, 9);\\n        addEdge(6, 7);\\n        \\n        vector<vector<long long>> power = matrixPower(edges, N - 1);\\n        // for (int i = 0; i < DIGITS; i++) {\\n        //     for (int j = 0; j < DIGITS; j++) {\\n        //         cout << power[i][j] << \" \";\\n        //     }\\n        //     cout << \"\\\\n\";\\n        // }\\n        long long sum = 0;\\n        for (int i = 0; i < DIGITS; i++) {\\n            for (int j = 0; j < DIGITS; j++) {\\n                sum += power[i][j];\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 189237,
                "title": "java-solution",
                "content": "```\\npublic int knightDialer(int n) {\\n    long[] last = new long[10];\\n    for (int j = 0; j < 10; j++)\\n        last[j] = 1;\\n\\n    long mod = 1000000007;\\n    for (int i = 1; i < n; i++) {\\n        long[] temp = new long[10];\\n        temp[0] = ((last[4] + last[6]) % mod);\\n        temp[1] = ((last[6] + last[8]) % mod);\\n        temp[2] = ((last[7] + last[9]) % mod);\\n        temp[3] = ((last[4] + last[8]) % mod);\\n        temp[4] = ((last[0] + last[3] + last[9]) % mod);\\n        temp[6] = ((last[0] + last[1] + last[7]) % mod);\\n        temp[7] = ((last[2] + last[6]) % mod);\\n        temp[8] = ((last[1] + last[3]) % mod);\\n        temp[9] = ((last[4] + last[2]) % mod);\\n        last = temp;\\n    }\\n    long sum = 0;\\n    for (long num : last)\\n        sum += num % mod;\\n\\n    return (int) (sum % mod);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int knightDialer(int n) {\\n    long[] last = new long[10];\\n    for (int j = 0; j < 10; j++)\\n        last[j] = 1;\\n\\n    long mod = 1000000007;\\n    for (int i = 1; i < n; i++) {\\n        long[] temp = new long[10];\\n        temp[0] = ((last[4] + last[6]) % mod);\\n        temp[1] = ((last[6] + last[8]) % mod);\\n        temp[2] = ((last[7] + last[9]) % mod);\\n        temp[3] = ((last[4] + last[8]) % mod);\\n        temp[4] = ((last[0] + last[3] + last[9]) % mod);\\n        temp[6] = ((last[0] + last[1] + last[7]) % mod);\\n        temp[7] = ((last[2] + last[6]) % mod);\\n        temp[8] = ((last[1] + last[3]) % mod);\\n        temp[9] = ((last[4] + last[2]) % mod);\\n        last = temp;\\n    }\\n    long sum = 0;\\n    for (long num : last)\\n        sum += num % mod;\\n\\n    return (int) (sum % mod);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069244,
                "title": "dp-both-approaches",
                "content": "# Recursive and Memoized Version (kinda noob one) \\n# Code\\n```\\nfunction knightDialer(len: number): number {\\n\\n  const dialpad = [\\n      [\\'1\\', \\'2\\', \\'3\\'],\\n      [\\'4\\', \\'5\\', \\'6\\'],\\n      [\\'7\\', \\'8\\', \\'9\\'],\\n      [\\'*\\', \\'0\\', \\'#\\'],\\n  ]\\n\\n const knight = (dialpad, n, i, j) => {\\n   if (\\n     i < 0 ||\\n     i >= dialpad.length ||\\n     j < 0 ||\\n     j >= dialpad[0].length ||\\n     dialpad[i][j] === \\'*\\' ||\\n     dialpad[i][j] === \\'#\\'\\n   ) \\n   return 0\\n\\n   if (n === 0) \\n     return 1\\n\\n   const k = `${i} - ${j} - ${n}`\\n\\n   if (!!dp.has(k)) \\n      return dp.get(k)\\n\\n   const ans =\\n     (knight(dialpad, n - 1, i + 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i + 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j - 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j - 1) % mod)\\n \\n  dp.set(k, ans)\\n  return ans\\n  \\n }\\n\\n let ans = 0\\n const mod = 1e9 + 7\\n let dp = new Map()\\n\\n for (let i = 0; i < dialpad.length; i++) {\\n   for (let j = 0; j < dialpad[0].length; j++) {\\n     let currentAns = knight(dialpad, len-1, i, j)\\n     ans += currentAns\\n   }\\n }\\n\\n return ans % mod;\\n};\\n```  \\n\\n# Tabulation\\nThink like a function f(n, d) where n is the input and d is a numner from 0 to 9 basically if i need \\nf(n, 1) = f(n-1, 6) + f(n-1, 4) \\nthese are 2 possible ways that could get me to one \\n\\n```\\nfunction knightDialer(n: number): number { \\n    const dp = new Array(n+1); \\n    const mod = 1e9 + 7\\n    for( let i = 0; i <= n; i++) { \\n        dp[i] = new Array(10);\\n    } \\n\\n    for( let i = 0; i <= n; i++) { \\n        for (let j = 0; j < 10; j++) {\\n            if(i === 0) dp[i][j] = 0; \\n            if( i === 1) dp[i][j] = 1; \\n         }\\n    } \\n\\n\\n    for(let i = 2; i <= n; i++) { \\n        for ( let j = 0; j < 10; j++) { \\n            if(j === 0) { dp[i][0] = (dp[i-1][6] + dp[i-1][4]) % mod  } \\n            if(j === 1) { dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod } \\n            if(j === 2) { dp[i][2] = (dp[i-1][9] + dp[i-1][7]) % mod } \\n            if(j === 3) { dp[i][3] =  (dp[i-1][8] + dp[i-1][4]) % mod } \\n            if(j === 4) { dp[i][4] =  (dp[i-1][9] + dp[i-1][0] + dp[i-1][3]) % mod } \\n            if(j === 5) { (dp[i][5] = 0) % mod } \\n            if(j === 6) { dp[i][6] =  (dp[i-1][0] + dp[i-1][7] + dp[i-1][1]) % mod}\\n            if(j === 7) { dp[i][7] =  (dp[i-1][2] + dp[i-1][6]) % mod }\\n            if(j === 8) { dp[i][8] =  (dp[i-1][1] + dp[i-1][3] )% mod }\\n            if(j === 9) { dp[i][9] =  (dp[i-1][4] + dp[i-1][2]) % mod } \\n        }\\n    } \\n\\n    let sum = 0; \\n    for( let i = 0; i < 10; i++) { \\n        sum+=dp[n][i]\\n    }\\n\\n return sum % mod;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction knightDialer(len: number): number {\\n\\n  const dialpad = [\\n      [\\'1\\', \\'2\\', \\'3\\'],\\n      [\\'4\\', \\'5\\', \\'6\\'],\\n      [\\'7\\', \\'8\\', \\'9\\'],\\n      [\\'*\\', \\'0\\', \\'#\\'],\\n  ]\\n\\n const knight = (dialpad, n, i, j) => {\\n   if (\\n     i < 0 ||\\n     i >= dialpad.length ||\\n     j < 0 ||\\n     j >= dialpad[0].length ||\\n     dialpad[i][j] === \\'*\\' ||\\n     dialpad[i][j] === \\'#\\'\\n   ) \\n   return 0\\n\\n   if (n === 0) \\n     return 1\\n\\n   const k = `${i} - ${j} - ${n}`\\n\\n   if (!!dp.has(k)) \\n      return dp.get(k)\\n\\n   const ans =\\n     (knight(dialpad, n - 1, i + 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i + 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j + 2) % mod) +\\n     (knight(dialpad, n - 1, i - 1, j - 2) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i + 2, j - 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j + 1) % mod) +\\n     (knight(dialpad, n - 1, i - 2, j - 1) % mod)\\n \\n  dp.set(k, ans)\\n  return ans\\n  \\n }\\n\\n let ans = 0\\n const mod = 1e9 + 7\\n let dp = new Map()\\n\\n for (let i = 0; i < dialpad.length; i++) {\\n   for (let j = 0; j < dialpad[0].length; j++) {\\n     let currentAns = knight(dialpad, len-1, i, j)\\n     ans += currentAns\\n   }\\n }\\n\\n return ans % mod;\\n};\\n```\n```\\nfunction knightDialer(n: number): number { \\n    const dp = new Array(n+1); \\n    const mod = 1e9 + 7\\n    for( let i = 0; i <= n; i++) { \\n        dp[i] = new Array(10);\\n    } \\n\\n    for( let i = 0; i <= n; i++) { \\n        for (let j = 0; j < 10; j++) {\\n            if(i === 0) dp[i][j] = 0; \\n            if( i === 1) dp[i][j] = 1; \\n         }\\n    } \\n\\n\\n    for(let i = 2; i <= n; i++) { \\n        for ( let j = 0; j < 10; j++) { \\n            if(j === 0) { dp[i][0] = (dp[i-1][6] + dp[i-1][4]) % mod  } \\n            if(j === 1) { dp[i][1] = (dp[i-1][6] + dp[i-1][8]) % mod } \\n            if(j === 2) { dp[i][2] = (dp[i-1][9] + dp[i-1][7]) % mod } \\n            if(j === 3) { dp[i][3] =  (dp[i-1][8] + dp[i-1][4]) % mod } \\n            if(j === 4) { dp[i][4] =  (dp[i-1][9] + dp[i-1][0] + dp[i-1][3]) % mod } \\n            if(j === 5) { (dp[i][5] = 0) % mod } \\n            if(j === 6) { dp[i][6] =  (dp[i-1][0] + dp[i-1][7] + dp[i-1][1]) % mod}\\n            if(j === 7) { dp[i][7] =  (dp[i-1][2] + dp[i-1][6]) % mod }\\n            if(j === 8) { dp[i][8] =  (dp[i-1][1] + dp[i-1][3] )% mod }\\n            if(j === 9) { dp[i][9] =  (dp[i-1][4] + dp[i-1][2]) % mod } \\n        }\\n    } \\n\\n    let sum = 0; \\n    for( let i = 0; i < 10; i++) { \\n        sum+=dp[n][i]\\n    }\\n\\n return sum % mod;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960054,
                "title": "best-solution-for-beginners-easily-explained",
                "content": "# Complexity\\n- Time complexity: $$O(10*8*n)$$ = O(n) \\n\\n- Space complexity: $$O(10*n)$$ = O(n)\\n\\n# Code\\n```\\n//dp[num][movesLeft] represents no. of ways to make a combination \\n//when I am standing at number = \\'num\\' and having \\'movesLeft\\' more moves to make\\nclass Solution {\\n    //these are the valid knight moves in x and y direction\\n    vector<int> moveInX = {-2,-2,-1,1,2, 2, 1,-1};\\n    vector<int> moveInY = {-1, 1, 2,2,1,-1,-2,-2};\\n    int solve(int i, int j, int num, int movesLeft, vector<vector<int>>& phonePad, vector<vector<int>>& dp)\\n    { //base case\\n      if(movesLeft == 0)\\n       return 1;\\n      \\n      if(dp[num][movesLeft] != -1) //memoization step\\n       return dp[num][movesLeft];\\n\\n     dp[num][movesLeft] = 0;\\n     //explore all valid possibilities for next move\\n     for(int k=0; k<8; k++)\\n     {\\n         int r = i + moveInX[k];\\n         int c = j + moveInY[k];\\n        \\n         if(r >= 0 && r < 4 && c >= 0 && c < 3 && phonePad[r][c] != -1)\\n         { //reduce movesLeft by 1\\n          dp[num][movesLeft] += solve(r,c,phonePad[r][c],movesLeft-1,phonePad,dp);\\n          dp[num][movesLeft] = dp[num][movesLeft] % 1000000007; //to avoid overflow\\n         }\\n     }\\n    return dp[num][movesLeft];\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        int movesLeft = n;\\n        vector<vector<int>> phonePad;\\n        vector<vector<int>> dp(10,vector<int>(movesLeft+1,-1));\\n\\n        //draw a phone pad as shown in problem statement\\n        phonePad.push_back({ 1, 2, 3 });\\n        phonePad.push_back({ 4, 5, 6 });\\n        phonePad.push_back({ 7, 8, 9 });\\n        phonePad.push_back({-1, 0,-1 });\\n\\n        int ans = 0;\\n        for(int i=0; i<4; i++)\\n        {\\n            for(int j=0; j<3; j++)\\n            {\\n             if(phonePad[i][j] == -1)\\n              continue;\\n             //make n-1 moves starting from position [i,j]\\n             ans += solve(i,j,phonePad[i][j],movesLeft-1,phonePad,dp);\\n             ans = ans % 1000000007;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//dp[num][movesLeft] represents no. of ways to make a combination \\n//when I am standing at number = \\'num\\' and having \\'movesLeft\\' more moves to make\\nclass Solution {\\n    //these are the valid knight moves in x and y direction\\n    vector<int> moveInX = {-2,-2,-1,1,2, 2, 1,-1};\\n    vector<int> moveInY = {-1, 1, 2,2,1,-1,-2,-2};\\n    int solve(int i, int j, int num, int movesLeft, vector<vector<int>>& phonePad, vector<vector<int>>& dp)\\n    { //base case\\n      if(movesLeft == 0)\\n       return 1;\\n      \\n      if(dp[num][movesLeft] != -1) //memoization step\\n       return dp[num][movesLeft];\\n\\n     dp[num][movesLeft] = 0;\\n     //explore all valid possibilities for next move\\n     for(int k=0; k<8; k++)\\n     {\\n         int r = i + moveInX[k];\\n         int c = j + moveInY[k];\\n        \\n         if(r >= 0 && r < 4 && c >= 0 && c < 3 && phonePad[r][c] != -1)\\n         { //reduce movesLeft by 1\\n          dp[num][movesLeft] += solve(r,c,phonePad[r][c],movesLeft-1,phonePad,dp);\\n          dp[num][movesLeft] = dp[num][movesLeft] % 1000000007; //to avoid overflow\\n         }\\n     }\\n    return dp[num][movesLeft];\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        int movesLeft = n;\\n        vector<vector<int>> phonePad;\\n        vector<vector<int>> dp(10,vector<int>(movesLeft+1,-1));\\n\\n        //draw a phone pad as shown in problem statement\\n        phonePad.push_back({ 1, 2, 3 });\\n        phonePad.push_back({ 4, 5, 6 });\\n        phonePad.push_back({ 7, 8, 9 });\\n        phonePad.push_back({-1, 0,-1 });\\n\\n        int ans = 0;\\n        for(int i=0; i<4; i++)\\n        {\\n            for(int j=0; j<3; j++)\\n            {\\n             if(phonePad[i][j] == -1)\\n              continue;\\n             //make n-1 moves starting from position [i,j]\\n             ans += solve(i,j,phonePad[i][j],movesLeft-1,phonePad,dp);\\n             ans = ans % 1000000007;\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927716,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        prev = [1 for j in range(10)]\\n        for i in range(1,n):\\n            curr = [0 for j in range(10)]\\n            for j in range(10):\\n                \\n                curr[0] = prev[4] + prev[6]\\n                curr[1] = prev[8] + prev[6]\\n                curr[2] = prev[7] + prev[9]\\n                curr[3] = prev[4] + prev[8]\\n                curr[4] = prev[0] + prev[3] + prev[9]\\n                curr[5] = 0\\n                curr[6] = prev[7] + prev[1] + prev[0]\\n                curr[7] = prev[2] + prev[6]\\n                curr[8] = prev[1] + prev[3]\\n                curr[9] = prev[4] + prev[2]\\n            prev = curr\\n        \\n        return sum(prev)%1000000007\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        prev = [1 for j in range(10)]\\n        for i in range(1,n):\\n            curr = [0 for j in range(10)]\\n            for j in range(10):\\n                \\n                curr[0] = prev[4] + prev[6]\\n                curr[1] = prev[8] + prev[6]\\n                curr[2] = prev[7] + prev[9]\\n                curr[3] = prev[4] + prev[8]\\n                curr[4] = prev[0] + prev[3] + prev[9]\\n                curr[5] = 0\\n                curr[6] = prev[7] + prev[1] + prev[0]\\n                curr[7] = prev[2] + prev[6]\\n                curr[8] = prev[1] + prev[3]\\n                curr[9] = prev[4] + prev[2]\\n            prev = curr\\n        \\n        return sum(prev)%1000000007\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598919,
                "title": "python-solution-taking-each-possible-case-into-consideration-recursive-forumla-dp",
                "content": "Each number has only certain numbers Knight can move from\\nEg. From 1, Knight can move to 8 or 6 Similarly, we can map for all the numbers\\n\\nNow we can specify a recursive formula\\ndp[start, len]: Mentions the possibilities of len length phone numbers starting from start\\nfor all numbers in mapping[start]\\ndp[start, len] = sum(dp[num, len-1])\\n\\nNow, if we are at a number, the next move can be to any of the numbers it can go to\\n# Code\\n```python \\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        mapping = {\\n            0:[6,4],\\n            1:[6,8],\\n            2:[9,7],\\n            3:[4,8],\\n            4:[0,9,3],\\n            5:[],\\n            6:[0,7,1],\\n            7:[6,2],\\n            8:[3,1],\\n            9:[4,2]\\n        }\\n        mod = 1e9+7\\n        @cache\\n        def helper(num, l):\\n            if l == 0:\\n                return 1\\n            ans = 0\\n            for to in mapping[num]:\\n                ans = (ans+helper(to, l-1))%mod\\n            return ans\\n        ret = 0\\n        for i in range(10):\\n            ret = (ret+helper(i,n-1))%mod\\n        return int(ret)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python \\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        mapping = {\\n            0:[6,4],\\n            1:[6,8],\\n            2:[9,7],\\n            3:[4,8],\\n            4:[0,9,3],\\n            5:[],\\n            6:[0,7,1],\\n            7:[6,2],\\n            8:[3,1],\\n            9:[4,2]\\n        }\\n        mod = 1e9+7\\n        @cache\\n        def helper(num, l):\\n            if l == 0:\\n                return 1\\n            ans = 0\\n            for to in mapping[num]:\\n                ans = (ans+helper(to, l-1))%mod\\n            return ans\\n        ret = 0\\n        for i in range(10):\\n            ret = (ret+helper(i,n-1))%mod\\n        return int(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521767,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long c=1e9+7;\\n        if(n==1){\\n          return 10;\\n        }\\n        long long g0=10,g4=6,g2=4;\\n        long long l0=2,l1=8,l4=6,l2=4;\\n        for(int i=3;i<=n;i++){\\n            long long tl0=l0,tl1=l1,tl4=l4,tl2=l2;\\n            g0=((3*tl4)%c+(2*tl2)%c)%c;\\n            l0=tl4;\\n            g4=((2*tl0)%c+(tl1%c))%c;\\n            g2=tl1;\\n            l4=g4;\\n            l2=g2;\\n            l1=(g0%c-l0%c+c)%c;\\n        }\\n        long long sum=(g0+g4+g2)%c;\\n        return sum;\\n    }\\n};\\n```\\n\\n```Python3 []\\nadj = (\\n    (4, 6),\\n    (6, 8),\\n    (7, 9),\\n    (4, 8),\\n    (0, 3, 9),\\n    (),\\n    (0, 1, 7),\\n    (2, 6),\\n    (1, 3),\\n    (2, 4),\\n)\\n@functools.cache\\ndef knightDialerRec(positions, n):\\n    if n == 1:\\n        return len(positions)\\n    else:\\n        t = 0\\n        for p in positions:\\n            t += knightDialerRec(adj[p], n - 1)\\n            t %= 1000000007\\n        return t\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        return knightDialerRec(range(10), n)\\n```\\n\\n```Java []\\nclass Solution {\\n    long array[][],matrix[][],mod=1000000007;\\n    public void multiply(long ref1[][],long ref2[][]){\\n        long[][] ref=new long[ref1.length][ref2[0].length];\\n        for(int i=0;i<ref.length;i++)\\n            for(int j=0;j<ref2[0].length;j++)\\n                for(int k=0;k<ref2.length;k++)\\n                    ref[i][j]=(int)((ref[i][j]+ref1[i][k]*ref2[k][j]%mod)%mod);\\n        if(ref1!=ref2)array=ref;\\n        else matrix=ref;\\n    }\\n    public int knightDialer(int n) {\\n        matrix=new long[][]{{0,0,0,2}, {0,0,1,1}, {0,2,0,0}, {1,2,0,0}};\\n        array=new long[][]{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};\\n        if(n==1)return 10;n-=2;\\n        while(n!=0){\\n            if(n%2==1){multiply(array,matrix);n--;}\\n            else {multiply(matrix,matrix);n/=2;}\\n        }\\n        multiply(array,new long[][]{{2},{2},{2},{3}});\\n        return (int)((((array[0][0]+array[1][0]*4%mod)%mod+array[2][0]*2%mod)%mod+array[3][0]*2%mod)%mod);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long c=1e9+7;\\n        if(n==1){\\n          return 10;\\n        }\\n        long long g0=10,g4=6,g2=4;\\n        long long l0=2,l1=8,l4=6,l2=4;\\n        for(int i=3;i<=n;i++){\\n            long long tl0=l0,tl1=l1,tl4=l4,tl2=l2;\\n            g0=((3*tl4)%c+(2*tl2)%c)%c;\\n            l0=tl4;\\n            g4=((2*tl0)%c+(tl1%c))%c;\\n            g2=tl1;\\n            l4=g4;\\n            l2=g2;\\n            l1=(g0%c-l0%c+c)%c;\\n        }\\n        long long sum=(g0+g4+g2)%c;\\n        return sum;\\n    }\\n};\\n```\n```Python3 []\\nadj = (\\n    (4, 6),\\n    (6, 8),\\n    (7, 9),\\n    (4, 8),\\n    (0, 3, 9),\\n    (),\\n    (0, 1, 7),\\n    (2, 6),\\n    (1, 3),\\n    (2, 4),\\n)\\n@functools.cache\\ndef knightDialerRec(positions, n):\\n    if n == 1:\\n        return len(positions)\\n    else:\\n        t = 0\\n        for p in positions:\\n            t += knightDialerRec(adj[p], n - 1)\\n            t %= 1000000007\\n        return t\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        return knightDialerRec(range(10), n)\\n```\n```Java []\\nclass Solution {\\n    long array[][],matrix[][],mod=1000000007;\\n    public void multiply(long ref1[][],long ref2[][]){\\n        long[][] ref=new long[ref1.length][ref2[0].length];\\n        for(int i=0;i<ref.length;i++)\\n            for(int j=0;j<ref2[0].length;j++)\\n                for(int k=0;k<ref2.length;k++)\\n                    ref[i][j]=(int)((ref[i][j]+ref1[i][k]*ref2[k][j]%mod)%mod);\\n        if(ref1!=ref2)array=ref;\\n        else matrix=ref;\\n    }\\n    public int knightDialer(int n) {\\n        matrix=new long[][]{{0,0,0,2}, {0,0,1,1}, {0,2,0,0}, {1,2,0,0}};\\n        array=new long[][]{{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}};\\n        if(n==1)return 10;n-=2;\\n        while(n!=0){\\n            if(n%2==1){multiply(array,matrix);n--;}\\n            else {multiply(matrix,matrix);n/=2;}\\n        }\\n        multiply(array,new long[][]{{2},{2},{2},{3}});\\n        return (int)((((array[0][0]+array[1][0]*4%mod)%mod+array[2][0]*2%mod)%mod+array[3][0]*2%mod)%mod);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404090,
                "title": "hashmap-dp-c",
                "content": "# Code\\n```\\nclass Solution {\\n    long long int cnt=0;\\npublic:\\n    long long int solve(int i , unordered_map<int , vector<int>>& mp , int size ,vector <vector <long long int>>& dp)\\n    {\\n\\n        if(size==0){\\n            return 1;\\n        }\\n\\n        if(dp[i][size]!=-1) return dp[i][size];\\n\\n        long long int sum=0;\\n\\n        for(int j=0 ; j<mp[i].size() ; j++){\\n            sum+=solve(mp[i][j] ,mp , size-1 ,dp)%1000000007;\\n        }\\n\\n        dp[i][size]=sum;\\n        return dp[i][size];\\n    }\\n    int knightDialer(int n) {\\n        if(!n) return 0;\\n        cnt=0;\\n        vector <vector <long long int>> dp(10, vector<long long int> (n , -1));\\n        unordered_map<int , vector<int>> mp = {\\n            { 1 , {6,8} },\\n            { 2 , {7,9} },\\n            { 3 , {4,8} },\\n            { 4 , {0,3,9} },\\n            { 5 , {}},\\n            { 6 , {0,1,7}},\\n            { 7 , {2,6}},\\n            { 8 , {1,3}},\\n            { 9 , {2,4}},\\n            { 0 ,{4,6}}\\n        };\\n\\n        for(int it=0 ; it<=9 ; it++){\\n            cnt+=solve(it , mp ,n-1 , dp);\\n        }\\n\\n        return cnt % 1000000007;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long int cnt=0;\\npublic:\\n    long long int solve(int i , unordered_map<int , vector<int>>& mp , int size ,vector <vector <long long int>>& dp)\\n    {\\n\\n        if(size==0){\\n            return 1;\\n        }\\n\\n        if(dp[i][size]!=-1) return dp[i][size];\\n\\n        long long int sum=0;\\n\\n        for(int j=0 ; j<mp[i].size() ; j++){\\n            sum+=solve(mp[i][j] ,mp , size-1 ,dp)%1000000007;\\n        }\\n\\n        dp[i][size]=sum;\\n        return dp[i][size];\\n    }\\n    int knightDialer(int n) {\\n        if(!n) return 0;\\n        cnt=0;\\n        vector <vector <long long int>> dp(10, vector<long long int> (n , -1));\\n        unordered_map<int , vector<int>> mp = {\\n            { 1 , {6,8} },\\n            { 2 , {7,9} },\\n            { 3 , {4,8} },\\n            { 4 , {0,3,9} },\\n            { 5 , {}},\\n            { 6 , {0,1,7}},\\n            { 7 , {2,6}},\\n            { 8 , {1,3}},\\n            { 9 , {2,4}},\\n            { 0 ,{4,6}}\\n        };\\n\\n        for(int it=0 ; it<=9 ; it++){\\n            cnt+=solve(it , mp ,n-1 , dp);\\n        }\\n\\n        return cnt % 1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387861,
                "title": "simple-and-easy-to-understand-approach-using-concept-of-dfs-and-memoization-clean-and-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimilar to problem [688. Knight Probability in Chessboard\\n](https://leetcode.com/problems/knight-probability-in-chessboard/\\n)\\nJust modified the constraints and base case\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(4x3xN)=O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Drow[8] = {2, 2, -2, -2, 1, 1, -1, -1};\\n    int Dcol[8] = {1, -1, 1, -1, 2, -2, 2, -2};\\n    vector<vector<vector<long long>>> dp;\\n    int mod = 1e9+7;\\n\\n    int knightDialer(int n) {\\n        dp.resize(4, vector<vector<long long>>(3, vector<long long>(n + 1, -1)));\\n        long long res = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                res = (res + solve(i, j, n)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long solve(int row, int col, int n) {\\n        if (row < 0 || col < 0 || row >= 4 || col >= 3 || (row == 3 && (col == 0 || col == 2))) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (dp[row][col][n] != -1) {\\n            return dp[row][col][n]; \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 8; i++) {\\n            res = (res + solve(row + Drow[i], col + Dcol[i], n - 1))%mod ;\\n        }\\n        return dp[row][col][n] = res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Drow[8] = {2, 2, -2, -2, 1, 1, -1, -1};\\n    int Dcol[8] = {1, -1, 1, -1, 2, -2, 2, -2};\\n    vector<vector<vector<long long>>> dp;\\n    int mod = 1e9+7;\\n\\n    int knightDialer(int n) {\\n        dp.resize(4, vector<vector<long long>>(3, vector<long long>(n + 1, -1)));\\n        long long res = 0;\\n        for (int i = 0; i < 4; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                res = (res + solve(i, j, n)) % mod;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    long long solve(int row, int col, int n) {\\n        if (row < 0 || col < 0 || row >= 4 || col >= 3 || (row == 3 && (col == 0 || col == 2))) {\\n            return 0;\\n        }\\n        if (n == 1) {\\n            return 1;\\n        }\\n        if (dp[row][col][n] != -1) {\\n            return dp[row][col][n]; \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 8; i++) {\\n            res = (res + solve(row + Drow[i], col + Dcol[i], n - 1))%mod ;\\n        }\\n        return dp[row][col][n] = res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362170,
                "title": "100-working-solution-in-java-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\n    int mod= 1000000007;\\n    int[] dx= {-2,-1,1,2,2,1,-1,-2};\\n    int[] dy= {1,2,2,1,-1,-2,-2,-1};\\n    int[][][] dp= new int[5][4][5002];\\n    \\n    public int knightDialer(int n) {\\n        int[][] nums= new int[4][3];\\n        nums[3][1]= 0;\\n        nums[3][0]= -1;\\n        nums[3][2]= -1;\\n        int x=1;\\n        for(int i=0; i<3; i++){\\n            for(int j=0; j<3; j++){\\n                nums[i][j]=x;\\n                x++;\\n            }\\n        }\\n        \\n        for(int i=0; i<5; i++){\\n            for(int j=0; j<4; j++){\\n                for(int k=0; k<5002; k++){\\n                    dp[i][j][k]= -1;\\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(nums[i][j]!=-1){\\n                    ans= (ans+solve(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int solve(int[][] nums, int i, int j, int n){\\n        if(i<0 || j<0 || i>=4 || j>=3 || nums[i][j]==-1){\\n            return 0;\\n        }\\n        \\n        if(n==0){\\n            return 1;\\n        }\\n        \\n        if(dp[i][j][n]!=-1){\\n            return dp[i][j][n];\\n        }\\n        \\n        int t=0;\\n        for(int k=0; k<8; k++){\\n            int x= i+dx[k];\\n            int y= j+dy[k];\\n            \\n            t= (t+solve(nums,x,y,n-1))%mod;\\n        }\\n        \\n        return dp[i][j][n] = (t%mod);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    int mod= 1000000007;\\n    int[] dx= {-2,-1,1,2,2,1,-1,-2}",
                "codeTag": "Java"
            },
            {
                "id": 3040767,
                "title": "python-concise-dynamic-programming-bottom-up",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nObserve that, moving as a knight, you can only reach certain keys from certain others (we exclude `*` and `#` as they are not part of valid numbers)\\n\\nThus, the number of ways to reach a certain square is simply the sum of ways to reach each previous square that can lead to it. This screams dynamic programming!\\n \\n\\n# Code\\n```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # which keys can precede a certain key due to knight movement\\n        ways_to_reach_key = {\\n            0: [4, 6],\\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        # number of moves required to reach 0-9 as ending digit\\n        moves = [1 for _ in range(10)]\\n\\n        for _ in range(1, n):\\n            prev = deepcopy(moves)\\n            for j in range(10):\\n                moves[j] = sum([prev[k] % (10**9 + 7) for k in ways_to_reach_key[j]])  % (10**9 + 7)\\n            \\n        return sum(moves) % (10**9 + 7)\\n```\\n\\n# Optimization\\nWe make the code run a bit faster by taking advantage of mathematical property `( x + y ) % z == ( x % z + y % z ) % z` to make the intermediate numbers smaller. \\n\\nWe could make the code significantly faster by using a 2d array rather than updating it, but that would balloon the space complexity.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        # which keys can precede a certain key due to knight movement\\n        ways_to_reach_key = {\\n            0: [4, 6],\\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        # number of moves required to reach 0-9 as ending digit\\n        moves = [1 for _ in range(10)]\\n\\n        for _ in range(1, n):\\n            prev = deepcopy(moves)\\n            for j in range(10):\\n                moves[j] = sum([prev[k] % (10**9 + 7) for k in ways_to_reach_key[j]])  % (10**9 + 7)\\n            \\n        return sum(moves) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904752,
                "title": "java-solution-easy-and-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int knightDialer(int n) {\\n       long mod = 1000000007;\\n\\t\\tlong[] dp = new long[10];\\n\\t\\tArrays.fill(dp, 1);\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\tlong[] temp = new long[10];\\n\\t\\t\\ttemp[0] = (dp[4] + dp[6]) % mod;\\n\\t\\t\\ttemp[1] = (dp[8] + dp[6]) % mod;\\n\\t\\t\\ttemp[2] = (dp[7] + dp[9]) % mod;\\n\\t\\t\\ttemp[3] = (dp[4] + dp[8]) % mod;\\n\\t\\t\\ttemp[4] = (((dp[3] + dp[9]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[6] = (((dp[7] + dp[1]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[7] = (dp[2] + dp[6]) % mod;\\n\\t\\t\\ttemp[8] = (dp[3] + dp[1]) % mod;\\n\\t\\t\\ttemp[9] = (dp[4] + dp[2]) % mod;\\n\\t\\t\\tdp = temp;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(long val : dp) {\\n\\t\\t\\tans = (int) ((ans + val) % mod);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n       long mod = 1000000007;\\n\\t\\tlong[] dp = new long[10];\\n\\t\\tArrays.fill(dp, 1);\\n\\t\\tint ans = 0;\\n\\t\\t\\n\\t\\tfor(int i=1; i<n; i++) {\\n\\t\\t\\tlong[] temp = new long[10];\\n\\t\\t\\ttemp[0] = (dp[4] + dp[6]) % mod;\\n\\t\\t\\ttemp[1] = (dp[8] + dp[6]) % mod;\\n\\t\\t\\ttemp[2] = (dp[7] + dp[9]) % mod;\\n\\t\\t\\ttemp[3] = (dp[4] + dp[8]) % mod;\\n\\t\\t\\ttemp[4] = (((dp[3] + dp[9]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[6] = (((dp[7] + dp[1]) % mod) + dp[0]) % mod;\\n\\t\\t\\ttemp[7] = (dp[2] + dp[6]) % mod;\\n\\t\\t\\ttemp[8] = (dp[3] + dp[1]) % mod;\\n\\t\\t\\ttemp[9] = (dp[4] + dp[2]) % mod;\\n\\t\\t\\tdp = temp;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(long val : dp) {\\n\\t\\t\\tans = (int) ((ans + val) % mod);\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730909,
                "title": "c-dfs-recursion-memoization",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/7556f7f2-d573-40a0-b5a1-43b70eb0d6f2_1666409793.871762.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1},{-2,1},{2,-1},{2,1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n\\t\\tint mod=1e9+7;\\n\\t\\tint dfs(int i,int j,int n){\\n\\t\\t\\tif(!n) return 1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\tint r=i+d.first;\\n\\t\\t\\t\\tint c=j+d.second;\\n\\t\\t\\t\\tif(r<3 && r>=0 && c<3 && c>=0) ans+=dfs(r,c,n-1)%mod;\\n\\t\\t\\t\\telse if(r==3 && c==1) ans+=dfs(r,c,n-1)%mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans%mod;\\n\\t\\t}\\n\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\tfor(int j=0;j<3;j++){\\n\\t\\t\\t\\t\\tif((i==3 && j==0) || (i==3 && j==2)) continue;\\n\\t\\t\\t\\t\\tcount+=dfs(i,j,n-1)%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count%mod;\\n\\t\\t}\\n\\t};\\n\\n\\n# Method -2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/a669d023-8e91-4f93-af77-84df93d8d6ea_1666409807.1825833.png)\\n\\n**T->O(12 * n) && S->O(12 * n) && O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1},{-2,1},{2,-1},{2,1},{-1,2},{1,2},{-1,-2},{1,-2}};\\n\\t\\tint mod=1e9+7;\\n\\t\\tint dfs(int i,int j,int n,vector<vector<vector<int>>>& dp){\\n\\t\\t\\tif(!n) return 1;\\n\\t\\t\\tif(dp[i][j][n]!=-1) return dp[i][j][n];\\n\\t\\t\\tlong long ans=0;\\n\\t\\t\\tfor(auto d:dir){\\n\\t\\t\\t\\tint r=i+d.first;\\n\\t\\t\\t\\tint c=j+d.second;\\n\\t\\t\\t\\tif(r<3 && r>=0 && c<3 && c>=0) ans+=dfs(r,c,n-1,dp)%mod;\\n\\t\\t\\t\\telse if(r==3 && c==1) ans+=dfs(r,c,n-1,dp)%mod;\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[i][j][n]=ans%mod;\\n\\t\\t}\\n\\n\\t\\tint knightDialer(int n) {\\n\\t\\t\\tlong long count=0;\\n\\t\\t\\tvector<vector<vector<int>>> dp(4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n\\t\\t\\tfor(int i=0;i<4;i++){\\n\\t\\t\\t\\tfor(int j=0;j<3;j++){\\n\\t\\t\\t\\t\\tif((i==3 && j==0) || (i==3 && j==2)) continue;\\n\\t\\t\\t\\t\\tcount+=dfs(i,j,n-1,dp)%mod;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count%mod;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<pair<int,int>> dir{{-2,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2608668,
                "title": "935",
                "content": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tjumps ={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[6,2],8:[1,3],9:[2,4]}\\n\\t\\t\\tdp = [1]*10\\n\\t\\t\\tmod = int(1e9+7)\\n\\t\\t\\tfor _ in range(n-1):\\n\\t\\t\\t\\tnewdp = [0]*10\\n\\t\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\t\\tfor j in jumps[i]:\\n\\t\\t\\t\\t\\t\\tnewdp[i] += dp[j]\\n\\t\\t\\t\\t\\t\\tnewdp[i] %= mod\\n\\t\\t\\t\\tdp = newdp\\n\\n\\t\\t\\treturn sum(dp)%mod",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tjumps ={0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[6,2],8:[1,3],9:[2,4]}",
                "codeTag": "Java"
            },
            {
                "id": 2569606,
                "title": "java-completely-explained-tabulation-efficient",
                "content": "```\\nclass Solution {\\n    // this stores the cells  we can reach from every index after executing a chess movement\\n    int[][] cells = {{4,6}, {6,8}, {7,9},{4,8},{3,9,0}, {}, {1,7,0},{2,6},{1,3},{2,4}};\\n    public int knightDialer(int n) {\\n        \\n        /*\\n           we decide that in the beggining all the actions and movements by the knight has been completed and for each \\n           cell we check from which positions it has come like for eg. to come to zero we can arrive from 4 and 6 and so on and\\n           we traverse back to initial positions with each increasing n.\\n        */\\n        \\n        int [][] dp =new int[n+1][10];\\n        \\n        // first row is filled with zeroes and second row is filled with ones \\n        // cause we have to move n-1 times\\n        for(int j=0;j<dp[0].length;j++)\\n        {\\n            dp[1][j]=1;\\n        }\\n        \\n        for(int i=2;i<dp.length;i++)\\n        {\\n            for(int j=0;j<dp[0].length;j++)\\n            {\\n                 for(int cell :cells[j])\\n                 {\\n                     dp[i][j] = (dp[i][j] +dp[i-1][cell]) % 1000000007;\\n                 }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int k=0;k<dp[0].length;k++)\\n        {\\n            res= (res + dp[n][k])  % 1000000007;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    // this stores the cells  we can reach from every index after executing a chess movement\\n    int[][] cells = {{4,6}",
                "codeTag": "Java"
            },
            {
                "id": 2547327,
                "title": "python3-dp-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tM = 1000000007\\n\\t\\t\\tdp = [[0] * n for _ in range(10)]\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tdp[i][0] = 1\\n\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tdp[1][i] = dp[6][i - 1] + dp[8][i - 1]\\n\\t\\t\\t\\tdp[2][i] = dp[7][i - 1] + dp[9][i - 1]\\n\\t\\t\\t\\tdp[3][i] = dp[8][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tdp[4][i] = dp[3][i - 1] + dp[9][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[5][i] = 0\\n\\t\\t\\t\\tdp[6][i] = dp[1][i - 1] + dp[7][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[7][i] = dp[2][i - 1] + dp[6][i - 1]\\n\\t\\t\\t\\tdp[8][i] = dp[3][i - 1] + dp[1][i - 1]\\n\\t\\t\\t\\tdp[9][i] = dp[4][i - 1] + dp[2][i - 1]\\n\\t\\t\\t\\tdp[0][i] = dp[6][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tfor j in range(10):\\n\\t\\t\\t\\t\\tdp[j][i] %= M\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tres += dp[i][n - 1]\\n\\t\\t\\treturn res % M",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef knightDialer(self, n: int) -> int:\\n\\t\\t\\tM = 1000000007\\n\\t\\t\\tdp = [[0] * n for _ in range(10)]\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tdp[i][0] = 1\\n\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tdp[1][i] = dp[6][i - 1] + dp[8][i - 1]\\n\\t\\t\\t\\tdp[2][i] = dp[7][i - 1] + dp[9][i - 1]\\n\\t\\t\\t\\tdp[3][i] = dp[8][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tdp[4][i] = dp[3][i - 1] + dp[9][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[5][i] = 0\\n\\t\\t\\t\\tdp[6][i] = dp[1][i - 1] + dp[7][i - 1] + dp[0][i - 1]\\n\\t\\t\\t\\tdp[7][i] = dp[2][i - 1] + dp[6][i - 1]\\n\\t\\t\\t\\tdp[8][i] = dp[3][i - 1] + dp[1][i - 1]\\n\\t\\t\\t\\tdp[9][i] = dp[4][i - 1] + dp[2][i - 1]\\n\\t\\t\\t\\tdp[0][i] = dp[6][i - 1] + dp[4][i - 1]\\n\\t\\t\\t\\tfor j in range(10):\\n\\t\\t\\t\\t\\tdp[j][i] %= M\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(10):\\n\\t\\t\\t\\tres += dp[i][n - 1]\\n\\t\\t\\treturn res % M",
                "codeTag": "Java"
            },
            {
                "id": 2453739,
                "title": "c-dp-tabulation-method-tc-o-n-sc-o-1",
                "content": "* Using constant extra space of number of numeric digits in the keypad ,i.e, 10.\\n* Time Complexity is O(n*number_of_numeric_digits).\\n* Upvote if you like the solution.\\n```\\n#define ll long long\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector<ll> prev(10,1);\\n        vector<ll> curr=prev;ll lastSum=10;\\n        for(int j=0;j<n-1;j++){\\n            lastSum=0;\\n                for(int i=0;i<=9;i++){\\n                if(i==0) curr[i]=(prev[4]+prev[6])%mod;\\n                else if(i==1) curr[i]=(prev[6]+prev[8])%mod;\\n                else if(i==2) curr[i]=(prev[7]+prev[9])%mod;\\n                else if(i==3) curr[i]=(prev[4]+prev[8])%mod;\\n                else if(i==4) curr[i]=(prev[3]+prev[9]+prev[0])%mod;\\n                else if(i==5) curr[i]=0;\\n                else if(i==6) curr[i]=(prev[7]+prev[1]+prev[0])%mod;\\n                else if(i==7) curr[i]=(prev[2]+prev[6])%mod;\\n                else if(i==8) curr[i]=(prev[1]+prev[3])%mod;\\n                else curr[i]=(prev[4]+prev[2])%mod;\\n                    lastSum+=curr[i]%mod;\\n            }\\n            prev=curr;\\n        }\\n        return lastSum%mod;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        vector<ll> prev(10,1);\\n        vector<ll> curr=prev;ll lastSum=10;\\n        for(int j=0;j<n-1;j++){\\n            lastSum=0;\\n                for(int i=0;i<=9;i++){\\n                if(i==0) curr[i]=(prev[4]+prev[6])%mod;\\n                else if(i==1) curr[i]=(prev[6]+prev[8])%mod;\\n                else if(i==2) curr[i]=(prev[7]+prev[9])%mod;\\n                else if(i==3) curr[i]=(prev[4]+prev[8])%mod;\\n                else if(i==4) curr[i]=(prev[3]+prev[9]+prev[0])%mod;\\n                else if(i==5) curr[i]=0;\\n                else if(i==6) curr[i]=(prev[7]+prev[1]+prev[0])%mod;\\n                else if(i==7) curr[i]=(prev[2]+prev[6])%mod;\\n                else if(i==8) curr[i]=(prev[1]+prev[3])%mod;\\n                else curr[i]=(prev[4]+prev[2])%mod;\\n                    lastSum+=curr[i]%mod;\\n            }\\n            prev=curr;\\n        }\\n        return lastSum%mod;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2422753,
                "title": "python-different-solution-with-thorough-explanation",
                "content": "# Method One: Smart\\nWe have `x0` through `x9` for each of the digits on the number pad that represent the amount of possible phone numbers that it can dial (we continuously update it as we move iterations).\\n\\nThe intuition is that we iterate through `n-1` times and each time we update `x0` through `x9` to be the sum of the total possible paths that they can do. \\n\\nFor example, from `x1` the knight can jump to `x6` or `x8`, so we update `x1` to be the sum of `x6` and `x8`. After that, the amount of total combinations will be the sum of the total combinations of each pad. Of course, we handle the mod.\\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(n-1):\\n            x1,x2,x3,x4,x5,x6,x7,x8,x9,x0 = x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x4+x2, x4+x6\\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0) % (10**9+7)\\n```\\n\\t\\n# Method 2: Recursion with Memo\\nWe use recursion with memorization here to avoid the nasty TLE errors.\\nThe intuition is the same as method 1, but implemented a bit differently. \\n\\nWe map each cell to the possible paths it could take the the next ceoo. I used `-1` as the pad before the knight is on the number pad, since the knight can start at any cell. We use a helper function to recurse and get the count of total possible paths. \\n\\nWe pass our paths dictionary, `n` as the index (amount of digits dialed), `-1` as the starting cell, but `curr` will eventually be the current cell, and our cache (initialized to `{}`). \\n\\nInside the helper function:\\n1. check if current index + path are already saved: if yes, just return it (that\\'s literally the entire point of caching and memo)\\n2. if the index is 0 (we haven\\'t even started yet), we can only dial 1 number: the number we are on right now\\n\\nNow the real stuff is starting:\\n3. initialize count to be total amount of paths\\n4. for every possible path from this current cell,\\n5. we recurse the previous index and add that to our count\\n6. save it to the cache\\n7. the helper function returns an integer `count`: the total number of paths from `curr` at index `n`. \\n\\nNote: the initial call for the helper function has parameter `idx` of `n`, not `n-1` since we start from the dummy pad -1. \\n\\nAnd we return the function return mod 10^9 + 7.\\n\\nRecursion expansion:\\n[![image](https://assets.leetcode.com/users/images/3c66d256-869d-4146-85ae-6a10b5addbfa_1660512488.936091.png)\\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        x1 = x2 = x3 = x4 = x5 = x6 = x7 = x8 = x9 = x0 = 1\\n        for i in range(n-1):\\n            x1,x2,x3,x4,x5,x6,x7,x8,x9,x0 = x6+x8, x7+x9, x4+x8, x3+x9+x0, 0, x1+x7+x0, x2+x6, x1+x3, x4+x2, x4+x6\\n        return (x1+x2+x3+x4+x5+x6+x7+x8+x9+x0) % (10**9+7)\\n```\n```py\\nclass Solution(object):\\n    def knightDialer(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        paths = {-1: [0,1,2,3,4,5,6,7,8,9], 0: [4,6], 1: [6,8], 2: [7,9], \\n\\t\\t3: [4,8], 4: [0,3,9], 5: [], 6: [0,1,7], 7: [2,6], 8: [1,3], 9: [2,4] }\\n        \\n        return self.helper(paths, n, -1, {}) % (10 ** 9 + 7)\\n        \\n    def helper(self, paths, idx, curr, cache):\\n        if (idx,curr) in cache:\\n            return cache[(idx,curr)]\\n        if idx == 0:\\n            return 1\\n        \\n        count = 0\\n        for num in paths[curr]:\\n            count += self.helper(paths, idx-1, num, cache)\\n        \\n        cache[(idx,curr)] = count\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396607,
                "title": "java-recursion-memoization-easy-solution",
                "content": "```\\nclass Solution {\\n    int[] dx = {-2, -2, 2, 2, 1, -1, 1, -1};\\n    int[] dy = {1, -1, -1, 1, 2, 2, -2, -2};\\n    int[][] nums;\\n    long MOD = 1000000000+7;\\n    Long[][][] dp;\\n    boolean isValid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m || nums[i][j] == -1) return false;\\n        else return true;\\n    }\\n    \\n    long helper(int i, int j, int n, int r, int c){\\n        if(n == 0) return 1;\\n        \\n        if(dp[i][j][n] != null) return dp[i][j][n];\\n        \\n        long ans = 0;\\n        for(int k = 0; k < 8; k++){\\n            int nx = i + dx[k];\\n            int ny = j + dy[k];\\n            if(isValid(nx, ny, r, c)){\\n                ans += helper(nx, ny, n-1, r, c);\\n                ans = ans%MOD;\\n            }\\n        }\\n        \\n        return dp[i][j][n] = ans;\\n    }\\n    public int knightDialer(int n) {\\n        nums = new int[4][3];\\n        nums[3][0] = -1;\\n        nums[3][2] = -1;\\n        dp = new Long[5][5][n+1];\\n        long ans = 0L;\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < 3; j++){\\n                if(nums[i][j] != -1){\\n                    ans += helper(i, j, n-1, 4, 3);\\n                    ans = ans%MOD;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] dx = {-2, -2, 2, 2, 1, -1, 1, -1};\\n    int[] dy = {1, -1, -1, 1, 2, 2, -2, -2};\\n    int[][] nums;\\n    long MOD = 1000000000+7;\\n    Long[][][] dp;\\n    boolean isValid(int i, int j, int n, int m){\\n        if(i < 0 || i >= n || j < 0 || j >= m || nums[i][j] == -1) return false;\\n        else return true;\\n    }\\n    \\n    long helper(int i, int j, int n, int r, int c){\\n        if(n == 0) return 1;\\n        \\n        if(dp[i][j][n] != null) return dp[i][j][n];\\n        \\n        long ans = 0;\\n        for(int k = 0; k < 8; k++){\\n            int nx = i + dx[k];\\n            int ny = j + dy[k];\\n            if(isValid(nx, ny, r, c)){\\n                ans += helper(nx, ny, n-1, r, c);\\n                ans = ans%MOD;\\n            }\\n        }\\n        \\n        return dp[i][j][n] = ans;\\n    }\\n    public int knightDialer(int n) {\\n        nums = new int[4][3];\\n        nums[3][0] = -1;\\n        nums[3][2] = -1;\\n        dp = new Long[5][5][n+1];\\n        long ans = 0L;\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < 3; j++){\\n                if(nums[i][j] != -1){\\n                    ans += helper(i, j, n-1, 4, 3);\\n                    ans = ans%MOD;\\n                }\\n            }\\n        }\\n        return (int)ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392430,
                "title": "c-wrong-what-s-wrong",
                "content": "```\\n\\nGetting wrong answer what i missing anyone ?????\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n     long int one=1,two=1,three=1,four=1,five=1,six=1,seven=1,eight=1,nine=1,zero=1,star=0,hash=0;\\n      long int  one1,two1,three1,four1,five1,six1,seven1,eight1,nine1,zero1,star1,hash1; \\n        long mod=pow(10,9)+7;\\n        for(int j=2;j<=n;j++){\\n            one1=(eight+six)%mod;\\n                two1=(seven+nine)%mod;\\n                three1=(eight+four)%mod;\\n                four1=(zero+three)%mod;\\n                // five1=()%mod;\\n            five1=(star+hash)%mod;\\n                six1=(zero+one)%mod;\\n            seven1=(six+two+hash)%mod;\\n                eight1=(three+one)%mod;\\n                nine1=(two+four+star)%mod;\\nzero1= (six+four)%mod;\\n            star1=(five+nine)%mod;\\n            hash1=(five+seven)%mod;\\none=one1,two=two1,three=three1,four=four1,five=five1,six=six1,seven=seven1,eight=eight1,nine=nine1,zero=zero1,star=star1,hash=hash1;\\n        }\\n        return (one+two+three+four+five+six+seven+eight+nine+zero+star+hash)%mod;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int knightDialer(int n) {\\n     long int one=1,two=1,three=1,four=1,five=1,six=1,seven=1,eight=1,nine=1,zero=1,star=0,hash=0;\\n      long int  one1,two1,three1,four1,five1,six1,seven1,eight1,nine1,zero1,star1,hash1; \\n        long mod=pow(10,9)+7;\\n        for(int j=2;j<=n;j++){\\n            one1=(eight+six)%mod;\\n                two1=(seven+nine)%mod;\\n                three1=(eight+four)%mod;\\n                four1=(zero+three)%mod;\\n                // five1=()%mod;\\n            five1=(star+hash)%mod;\\n                six1=(zero+one)%mod;\\n            seven1=(six+two+hash)%mod;\\n                eight1=(three+one)%mod;\\n                nine1=(two+four+star)%mod;\\nzero1= (six+four)%mod;\\n            star1=(five+nine)%mod;\\n            hash1=(five+seven)%mod;\\none=one1,two=two1,three=three1,four=four1,five=five1,six=six1,seven=seven1,eight=eight1,nine=nine1,zero=zero1,star=star1,hash=hash1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2369123,
                "title": "java-dp-o-1-space-o-n-time",
                "content": "```java\\nclass Solution {\\n    public int knightDialer(int n) {\\n        var dp = new long[10];\\n        var tmp = new long[10];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < n; i++) {\\n            tmp[1] = dp[6]+dp[8];\\n            tmp[2] = dp[7]+dp[9];\\n            tmp[3] = dp[4]+dp[8];\\n            tmp[4] = dp[0]+dp[3]+dp[9];\\n            tmp[5] = 0;\\n            tmp[6] = dp[0]+dp[1]+dp[7];\\n            tmp[7] = dp[2]+dp[6];\\n            tmp[8] = dp[1]+dp[3];\\n            tmp[9] = dp[2]+dp[4];\\n            tmp[0] = dp[4]+dp[6];\\n            for (int j = 0; j < 10; j++) tmp[j] = tmp[j] % 1000000007;\\n            var arr = dp;\\n            dp = tmp;\\n            tmp = arr;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 10; i++) {\\n            res = (res+dp[i]) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int knightDialer(int n) {\\n        var dp = new long[10];\\n        var tmp = new long[10];\\n        Arrays.fill(dp, 1);\\n        for (int i = 1; i < n; i++) {\\n            tmp[1] = dp[6]+dp[8];\\n            tmp[2] = dp[7]+dp[9];\\n            tmp[3] = dp[4]+dp[8];\\n            tmp[4] = dp[0]+dp[3]+dp[9];\\n            tmp[5] = 0;\\n            tmp[6] = dp[0]+dp[1]+dp[7];\\n            tmp[7] = dp[2]+dp[6];\\n            tmp[8] = dp[1]+dp[3];\\n            tmp[9] = dp[2]+dp[4];\\n            tmp[0] = dp[4]+dp[6];\\n            for (int j = 0; j < 10; j++) tmp[j] = tmp[j] % 1000000007;\\n            var arr = dp;\\n            dp = tmp;\\n            tmp = arr;\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 10; i++) {\\n            res = (res+dp[i]) % 1000000007;\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363389,
                "title": "python-matrix-multiplication-solution",
                "content": "Start with identity matrix and multiply by M^2i at the relevant bits!\\nI mistook the bit breakdown (addition) and forgot it\\'s actually in the power when solving the problem\\nWe just keep multiplying till the end, and finally sum all the elements up\\n\\nSimilar problem: [Leetcode 552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/)\\n\\nThat one is little harder to arrive at the state transitions though\\n```\\nclass Solution:\\n    # This look like a matrix multiplication problem\\n    # At least, we see that there are well defined transitions possible\\n    # 1 -> 6, 8\\n    # 2 -> 7, 9\\n    # 3 -> 4, 8\\n    # 4 -> 3, 9, 0\\n    # 5 -> {}\\n    # 6 -> 1, 7, 0\\n    # 7 -> 2, 6\\n    # 8 -> 1, 3\\n    # 9 -> 2, 4\\n    # 0 -> 4, 6\\n    # The transition matrix M is well defined\\n    # Then we can break down n into power of 2s. (n >> i = 1 or not)\\n    # And just sum up the matrix contribution each time it is squared\\n    def matrix_multiply(self, A, C):\\n        n = len(A)\\n        B = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    B[i][j] += A[i][k]*C[k][j] \\n                    B[i][j] %= self.MOD\\n        return B\\n    \\n    def knightDialer(self, n: int) -> int:\\n        self.MOD = pow(10, 9) + 7\\n        M = [[0,0,0,0,1,0,1,0,0,0],\\n             [0,0,0,0,0,0,1,0,1,0],\\n             [0,0,0,0,0,0,0,1,0,1],\\n             [0,0,0,0,1,0,0,0,1,0],\\n             [1,0,0,1,0,0,0,0,0,1],\\n             [0,0,0,0,0,0,0,0,0,0],\\n             [1,1,0,0,0,0,0,1,0,0],\\n             [0,0,1,0,0,0,1,0,0,0],\\n             [0,1,0,1,0,0,0,0,0,0],\\n             [0,0,1,0,1,0,0,0,0,0]]\\n        seed = [[0 for i in range(10)] for j in range(10)] \\n        for i in range(10):\\n            seed[i][i] = 1\\n        \\n        \\n        for i in range((n-1).bit_length()):\\n            if (n-1) & (1 << i) != 0:\\n                seed = self.matrix_multiply(seed, M)\\n            M = self.matrix_multiply(M, M)\\n        \\n        result = 0    \\n        for j in range(10):\\n            for k in range(10):\\n                result += seed[j][k]\\n                result %= self.MOD\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # This look like a matrix multiplication problem\\n    # At least, we see that there are well defined transitions possible\\n    # 1 -> 6, 8\\n    # 2 -> 7, 9\\n    # 3 -> 4, 8\\n    # 4 -> 3, 9, 0\\n    # 5 -> {}\\n    # 6 -> 1, 7, 0\\n    # 7 -> 2, 6\\n    # 8 -> 1, 3\\n    # 9 -> 2, 4\\n    # 0 -> 4, 6\\n    # The transition matrix M is well defined\\n    # Then we can break down n into power of 2s. (n >> i = 1 or not)\\n    # And just sum up the matrix contribution each time it is squared\\n    def matrix_multiply(self, A, C):\\n        n = len(A)\\n        B = [[0 for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    B[i][j] += A[i][k]*C[k][j] \\n                    B[i][j] %= self.MOD\\n        return B\\n    \\n    def knightDialer(self, n: int) -> int:\\n        self.MOD = pow(10, 9) + 7\\n        M = [[0,0,0,0,1,0,1,0,0,0],\\n             [0,0,0,0,0,0,1,0,1,0],\\n             [0,0,0,0,0,0,0,1,0,1],\\n             [0,0,0,0,1,0,0,0,1,0],\\n             [1,0,0,1,0,0,0,0,0,1],\\n             [0,0,0,0,0,0,0,0,0,0],\\n             [1,1,0,0,0,0,0,1,0,0],\\n             [0,0,1,0,0,0,1,0,0,0],\\n             [0,1,0,1,0,0,0,0,0,0],\\n             [0,0,1,0,1,0,0,0,0,0]]\\n        seed = [[0 for i in range(10)] for j in range(10)] \\n        for i in range(10):\\n            seed[i][i] = 1\\n        \\n        \\n        for i in range((n-1).bit_length()):\\n            if (n-1) & (1 << i) != 0:\\n                seed = self.matrix_multiply(seed, M)\\n            M = self.matrix_multiply(M, M)\\n        \\n        result = 0    \\n        for j in range(10):\\n            for k in range(10):\\n                result += seed[j][k]\\n                result %= self.MOD\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308692,
                "title": "o-logn-solution",
                "content": "```\\npublic class Solution {\\n    public int KnightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        long[,] matrix = {\\n            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},\\n            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\\n            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},\\n            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},\\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\\n            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},                     \\n            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},\\n            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\\n            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0},            \\n        };\\n        long[,] res = {\\n            {1,1,1,1,1,1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){ \\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n=n/2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n--;\\n            }\\n        }\\n        long count=0;\\n        for(int c=0;c<10;c++){\\n            count= (count+res[0,c])%1000000007;\\n        }\\n        return (int)count;\\n        \\n    }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[10,10];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    product[i,j] = (product[i,j] + matrix1[i,k]*matrix2[j,k])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int KnightDialer(int n) {\\n        if(n==1)\\n            return 10;\\n        long[,] matrix = {\\n            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},\\n            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\\n            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\\n            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},\\n            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},\\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\\n            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},                     \\n            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},\\n            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\\n            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0},            \\n        };\\n        long[,] res = {\\n            {1,1,1,1,1,1,1,1,1,1}\\n        };\\n        n=n-1;\\n        while(n>0){\\n            if(n%2==0){ \\n                matrix = MatrixMultiplication(matrix,matrix);\\n                n=n/2;\\n            }\\n            else{\\n                res = MatrixMultiplication(res,matrix);\\n                n--;\\n            }\\n        }\\n        long count=0;\\n        for(int c=0;c<10;c++){\\n            count= (count+res[0,c])%1000000007;\\n        }\\n        return (int)count;\\n        \\n    }\\n    \\n    public long[,] MatrixMultiplication(long[,] matrix1,long[,] matrix2){\\n        long[,] product = new long[10,10];\\n        for(int i=0;i<matrix1.GetLength(0);i++){\\n            for(int j=0;j<10;j++){\\n                for(int k=0;k<10;k++){\\n                    product[i,j] = (product[i,j] + matrix1[i,k]*matrix2[j,k])%1000000007;\\n                }\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267066,
                "title": "70-86-faster-pyhton-dynamic-programming-tabulation-d-p",
                "content": "If you think you are weak in Dynamic Programming please watch the Dynamic playlist by Striver on youtube the link is given below .It helped me a lot.\\n[https://www.youtube.com/watch?v=FfXoiwwnxFw&list=PLgUwDviBIf0qUlt5H_kiKYaNSqJ81PMMY](http://)\\nThe dpTab is the ap array keeps the track of the previous iteration with all the numbers excluding 5 as 5 can never be obtained n>=2 .\\nThe code for the same is given below .\\nI will request you all to understand the recursive code first then move on to Tabulated one .\\n\\n\\n**RECURSIVE CODE:---(WILL GIVE TLE)**\\n```\\nimport collections\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        def moves(adj,n,curr,dp):\\n            mod=10**9+7\\n            if(n==0):\\n                return 1\\n            if(dp[str(n)+\\'.\\'+str(curr)]!=-1):\\n                return dp[str(n)+\\'.\\'+str(curr)]\\n            a=0\\n            for j in adj[curr]:\\n                a=(a+ moves(adj,n-1,j,dp))%mod\\n            dp[str(n)+\\'.\\'+str(curr)]=a%mod\\n            return dp[str(n)+\\'.\\'+str(curr)]\\n        \\n        sumi=0\\n        def re():\\n            return -1\\n        dp=collections.defaultdict(re)\\n        mod=10**9+7\\n        for i in range(10):\\n            if(i==5):\\n                continue\\n            sumi=(sumi+moves(adj,n-1,i,dp))%mod\\n        return sumi\\n```\\n\\n\\n\\n**TABULATED CODE (ACCEPTED!)**\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        mod=10**9+7\\n        def tab():\\n            dpTab=[[0 for i in range(10)] for _ in range(n)]\\n            for i in range(10):\\n                dpTab[0][i]=1\\n            for i in range(1,n):\\n                for curr in range(10):\\n                    if(curr==5):\\n                        continue\\n                    a=0\\n                    for j in adj[curr]:\\n                        a=(a+dpTab[i-1][j])%mod\\n                    dpTab[i][curr]=a%mod\\n            return sum(dpTab[n-1])%mod\\n        return tab()\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        def moves(adj,n,curr,dp):\\n            mod=10**9+7\\n            if(n==0):\\n                return 1\\n            if(dp[str(n)+\\'.\\'+str(curr)]!=-1):\\n                return dp[str(n)+\\'.\\'+str(curr)]\\n            a=0\\n            for j in adj[curr]:\\n                a=(a+ moves(adj,n-1,j,dp))%mod\\n            dp[str(n)+\\'.\\'+str(curr)]=a%mod\\n            return dp[str(n)+\\'.\\'+str(curr)]\\n        \\n        sumi=0\\n        def re():\\n            return -1\\n        dp=collections.defaultdict(re)\\n        mod=10**9+7\\n        for i in range(10):\\n            if(i==5):\\n                continue\\n            sumi=(sumi+moves(adj,n-1,i,dp))%mod\\n        return sumi\\n```\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if(n==1):\\n            return 10\\n        adj=[[4,6],[6,8],[7,9],[8,4],[3,9,0],[],[1,7,0],[2,6],[1,3],[2,4]]\\n        mod=10**9+7\\n        def tab():\\n            dpTab=[[0 for i in range(10)] for _ in range(n)]\\n            for i in range(10):\\n                dpTab[0][i]=1\\n            for i in range(1,n):\\n                for curr in range(10):\\n                    if(curr==5):\\n                        continue\\n                    a=0\\n                    for j in adj[curr]:\\n                        a=(a+dpTab[i-1][j])%mod\\n                    dpTab[i][curr]=a%mod\\n            return sum(dpTab[n-1])%mod\\n        return tab()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247460,
                "title": "easy-java-solution-dp",
                "content": "**Please upvote if you like the solution, Happy learning!**\\n**Explanation:**\\n1. First fill the map with possible positions knight can move from every number from `0 - 9`\\n2. Since now you know from every position, where is the next step, start running  a path finder from `0-9`\\n\\n```\\nclass Solution {\\n    private void init(Map<Integer, List<Integer>> map) {\\n        map.put(0, Arrays.asList(4, 6));\\n        map.put(1, Arrays.asList(6, 8));\\n        map.put(2, Arrays.asList(7, 9));\\n        map.put(3, Arrays.asList(4, 8));\\n        map.put(4, Arrays.asList(0, 3, 9));\\n        map.put(5, Arrays.asList());\\n        map.put(6, Arrays.asList(0, 1, 7));\\n        map.put(7, Arrays.asList(2, 6));\\n        map.put(8, Arrays.asList(1, 3));\\n        map.put(9, Arrays.asList(2, 4));\\n    }\\n    private Map<Integer, List<Integer>> map = new HashMap();\\n    private static final int mod = (int) 1e9 + 7;\\n    private Integer dp[][];\\n    public int knightDialer(int n) {\\n        init(map);\\n        this.dp = new Integer[10][n+1];\\n        int ans = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            ans = (ans + paths(i, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n    \\n    private int paths(int num, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[num][n] != null) {\\n            return dp[num][n];\\n        }\\n        int ans = 0;\\n        for (int nextNum: map.get(num)) {\\n            ans = (ans + paths(nextNum, n - 1)) % mod;\\n        }\\n        return dp[num][n] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private void init(Map<Integer, List<Integer>> map) {\\n        map.put(0, Arrays.asList(4, 6));\\n        map.put(1, Arrays.asList(6, 8));\\n        map.put(2, Arrays.asList(7, 9));\\n        map.put(3, Arrays.asList(4, 8));\\n        map.put(4, Arrays.asList(0, 3, 9));\\n        map.put(5, Arrays.asList());\\n        map.put(6, Arrays.asList(0, 1, 7));\\n        map.put(7, Arrays.asList(2, 6));\\n        map.put(8, Arrays.asList(1, 3));\\n        map.put(9, Arrays.asList(2, 4));\\n    }\\n    private Map<Integer, List<Integer>> map = new HashMap();\\n    private static final int mod = (int) 1e9 + 7;\\n    private Integer dp[][];\\n    public int knightDialer(int n) {\\n        init(map);\\n        this.dp = new Integer[10][n+1];\\n        int ans = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            ans = (ans + paths(i, n - 1)) % mod;\\n        }\\n        return ans;\\n    }\\n    \\n    private int paths(int num, int n) {\\n        if (n == 0) {\\n            return 1;\\n        }\\n        if (dp[num][n] != null) {\\n            return dp[num][n];\\n        }\\n        int ans = 0;\\n        for (int nextNum: map.get(num)) {\\n            ans = (ans + paths(nextNum, n - 1)) % mod;\\n        }\\n        return dp[num][n] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238560,
                "title": "python-dp",
                "content": "```\\n def knightDialer(self, n: int) -> int:\\n        mod=10**9+7\\n        dp=[[0 for j in range(10)]  for i in range(1+n)]\\n        dp[1]=[1 for j in range(10)]\\n        m={}\\n        m[0]=[4,6]\\n        m[1]=[6,8]\\n        m[2]=[7,9]\\n        m[3]=[4,8]\\n        m[4]=[0,9,3]\\n        m[5]=[]\\n        m[6]=[0,1,7]\\n        m[7]=[2,6]\\n        m[8]=[1,3]\\n        m[9]=[2,4]\\n        for i in range(2,n+1):\\n            for j in range(10):\\n                sources=m[j]\\n                for prev in sources:\\n                    dp[i][j]+=dp[i-1][prev]\\n                    dp[i][j]=dp[i][j]%mod\\n        res=sum(dp[n])%mod\\n        return res",
                "solutionTags": [],
                "code": "```\\n def knightDialer(self, n: int) -> int:\\n        mod=10**9+7\\n        dp=[[0 for j in range(10)]  for i in range(1+n)]\\n        dp[1]=[1 for j in range(10)]\\n        m={}\\n        m[0]=[4,6]\\n        m[1]=[6,8]\\n        m[2]=[7,9]\\n        m[3]=[4,8]\\n        m[4]=[0,9,3]\\n        m[5]=[]\\n        m[6]=[0,1,7]\\n        m[7]=[2,6]\\n        m[8]=[1,3]\\n        m[9]=[2,4]\\n        for i in range(2,n+1):\\n            for j in range(10):\\n                sources=m[j]\\n                for prev in sources:\\n                    dp[i][j]+=dp[i-1][prev]\\n                    dp[i][j]=dp[i][j]%mod\\n        res=sum(dp[n])%mod\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2206866,
                "title": "very-simple-dp-approach",
                "content": "\\nclass Solution {\\npublic:\\n    int M=1e9+7;\\n    long long dp[10][5003];\\n       \\n      long long func(int key,int n){\\n          \\n          if(n==1)return 1;\\n          if(dp[key][n]!=-1) return dp[key][n];\\n          if(key==1){\\n              return  dp[key][n]=(func(8,n-1)%M+ func(6,n-1)%M)%M;\\n          }\\n             if(key==2){\\n              return  dp[key][n]= (func(7,n-1)%M+ func(9,n-1)%M)%M;\\n          }\\n             if(key==3){\\n              return  dp[key][n]= (func(8,n-1)%M+ func(4,n-1)%M)%M;\\n          }\\n             if(key==4){\\n              return  dp[key][n]= (func(3,n-1)%M+ func(9,n-1)%M+func(0,n-1)%M)%M;\\n          }\\n             if(key==5){\\n              return  dp[key][n]= 0;\\n          }\\n             if(key==6){\\n              return  dp[key][n]= (func(1,n-1)%M+ func(7,n-1)%M+func(0,n-1)%M)%M;\\n          }\\n             if(key==7){\\n              return   dp[key][n]=( func(2,n-1)%M + func(6,n-1)%M )%M;\\n          }\\n             if(key==8){ \\n              return  dp[key][n]= (func(1,n-1)%M+ func(3,n-1)%M)%M;\\n          }\\n             if(key==9){\\n              return  dp[key][n]= (func(4,n-1)%M+ func(2,n-1)%M)%M;\\n          }\\n           if(key==0){\\n              return   dp[key][n]=(func(4,n-1)%M+ func(6,n-1)%M)%M;\\n          }\\n          return 0;\\n      }\\n    int knightDialer(int n) {\\n         int ans=0;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<=9;i++){\\n             ans= (ans%M+func(i,n)%M)%M;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int M=1e9+7;\\n    long long dp[10][5003];\\n       \\n      long long func(int key,int n){\\n          \\n          if(n==1)return 1;\\n          if(dp[key][n]!=-1) return dp[key][n];\\n          if(key==1){\\n              return  dp[key][n]=(func(8,n-1)%M+ func(6,n-1)%M)%M;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2172077,
                "title": "python-dp-clean-code",
                "content": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        jumps = {\\n            0: [4, 6], \\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        prevDp = [1] * 10\\n        \\n        for length in range(n - 1):\\n            dp = [0] * 10\\n            \\n            for digit in range(10):\\n                for jump in jumps[digit]:\\n                    dp[jump] += prevDp[digit]\\n            \\n            prevDp = dp\\n        \\n        return sum(prevDp) % 1000000007\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        jumps = {\\n            0: [4, 6], \\n            1: [6, 8],\\n            2: [7, 9],\\n            3: [4, 8],\\n            4: [0, 3, 9],\\n            5: [],\\n            6: [0, 1, 7],\\n            7: [2, 6],\\n            8: [1, 3],\\n            9: [2, 4]\\n        }\\n        \\n        prevDp = [1] * 10\\n        \\n        for length in range(n - 1):\\n            dp = [0] * 10\\n            \\n            for digit in range(10):\\n                for jump in jumps[digit]:\\n                    dp[jump] += prevDp[digit]\\n            \\n            prevDp = dp\\n        \\n        return sum(prevDp) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141399,
                "title": "java-solution-2d-dp-memoization",
                "content": "```\\nclass Solution {\\n    \\n    public long mod= 1000000007;\\n    public int knightDialer(int n) {\\n        \\n        int[][] grid= { {1,2,3}, {4,5,6}, {7,8,9}, {-1,0,-1} };\\n        \\n        long[][] dp= new long[10][n+1];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++)\\n                dp[i][j]= -1;\\n        }\\n        \\n        //iterate over all digits and count the valid Knight numbers\\n        long count=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i][j]!= -1){\\n                    count= (count+ validNumbers(n,i,j,dp,grid))%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)count; \\n    }\\n    \\n    private long validNumbers(int n,int i,int j,long[][] dp,int[][] grid){\\n        \\n        int row =grid.length, col =grid[0].length;\\n        \\n        if(i<0 || i>=row || j<0 || j>=col)\\n            return 0;\\n        \\n        if(grid[i][j]== -1)\\n            return 0;\\n        \\n        \\n        int num=grid[i][j];\\n        \\n        if(n ==1)\\n            return 1;\\n        \\n        if(dp[num][n]!= -1)\\n            return dp[num][n];\\n        \\n        long value=0;\\n        value+= validNumbers(n-1,i-2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j-1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-2,j-1,dp,grid)%mod;\\n        \\n        \\n        return dp[num][n]= value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long mod= 1000000007;\\n    public int knightDialer(int n) {\\n        \\n        int[][] grid= { {1,2,3}, {4,5,6}, {7,8,9}, {-1,0,-1} };\\n        \\n        long[][] dp= new long[10][n+1];\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<dp[0].length; j++)\\n                dp[i][j]= -1;\\n        }\\n        \\n        //iterate over all digits and count the valid Knight numbers\\n        long count=0;\\n        for(int i=0; i<4; i++){\\n            for(int j=0; j<3; j++){\\n                if(grid[i][j]!= -1){\\n                    count= (count+ validNumbers(n,i,j,dp,grid))%mod;\\n                }\\n            }\\n        }\\n        \\n        return (int)count; \\n    }\\n    \\n    private long validNumbers(int n,int i,int j,long[][] dp,int[][] grid){\\n        \\n        int row =grid.length, col =grid[0].length;\\n        \\n        if(i<0 || i>=row || j<0 || j>=col)\\n            return 0;\\n        \\n        if(grid[i][j]== -1)\\n            return 0;\\n        \\n        \\n        int num=grid[i][j];\\n        \\n        if(n ==1)\\n            return 1;\\n        \\n        if(dp[num][n]!= -1)\\n            return dp[num][n];\\n        \\n        long value=0;\\n        value+= validNumbers(n-1,i-2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j+2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j+1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+2,j-1,dp,grid)%mod;\\n        value+= validNumbers(n-1,i+1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-1,j-2,dp,grid)%mod;\\n        value+= validNumbers(n-1,i-2,j-1,dp,grid)%mod;\\n        \\n        \\n        return dp[num][n]= value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136453,
                "title": "python-somewhat-ok-solution",
                "content": "```python\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        Mod = 10**9 + 7\\n        pad = [\\n            (4, 6), (8, 6), (7, 9), (4, 8), (3, 9, 0),\\n            (), (1, 7, 0), (2, 6), (1, 3), (2, 4)\\n        ]\\n        \\n        @cache\\n        def dfs(i, n):\\n\\t\\t   # search reached the end, found 1 solution\\n            if n == 0: return 1\\n\\t\\t\\t# search not reach the end, keep looking for solution for n - 1\\n            return sum(dfs(nxt, n - 1) for nxt in pad[i]) % Mod\\n\\n        # starting from each number, count the total solution to n\\n\\t\\t# because placing the chess to i takes 1 count, so search for n - 1\\n        return sum(dfs(i, n - 1)  for i in range(10)) % Mod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        Mod = 10**9 + 7\\n        pad = [\\n            (4, 6), (8, 6), (7, 9), (4, 8), (3, 9, 0),\\n            (), (1, 7, 0), (2, 6), (1, 3), (2, 4)\\n        ]\\n        \\n        @cache\\n        def dfs(i, n):\\n\\t\\t   # search reached the end, found 1 solution\\n            if n == 0: return 1\\n\\t\\t\\t# search not reach the end, keep looking for solution for n - 1\\n            return sum(dfs(nxt, n - 1) for nxt in pad[i]) % Mod\\n\\n        # starting from each number, count the total solution to n\\n\\t\\t# because placing the chess to i takes 1 count, so search for n - 1\\n        return sum(dfs(i, n - 1)  for i in range(10)) % Mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118758,
                "title": "c-easy-and-concise-code-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[4][3][5005];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 }, dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n    bool isValid(int i,int j,vector<vector<char>>&mat)\\n    {\\n        return (i>=0 && i<4 && j>=0 && j<3 && mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')? true:false;\\n    }\\n    long long solve(vector<vector<char>>&mat,int n,int i,int j)\\n    {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(dp[i][j][n]>0) return dp[i][j][n];\\n        long long ans=0;\\n        for(int k=0;k<8;k++)\\n        {\\n            if(isValid(i+dx[k],j+dy[k],mat))\\n            {\\n                ans+=solve(mat,n-1,i+dx[k],j+dy[k]);\\n            }\\n        }\\n       return dp[i][j][n]=ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<char>>mat(4,vector<char>(3));\\n        int k=1;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                mat[i][j]=(k+\\'0\\');\\n                k++;\\n            }\\n        }\\n        mat[3][0]=\\'*\\',mat[3][1]=\\'0\\',mat[3][2]=\\'#\\';\\n        long long ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')\\n                ans+=solve(mat,n,i,j);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    long long dp[4][3][5005];\\n    int dx[8] = { 2, 1, -1, -2, -2, -1, 1, 2 }, dy[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };\\n    \\n    bool isValid(int i,int j,vector<vector<char>>&mat)\\n    {\\n        return (i>=0 && i<4 && j>=0 && j<3 && mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')? true:false;\\n    }\\n    long long solve(vector<vector<char>>&mat,int n,int i,int j)\\n    {\\n        if(n==1){\\n            return 1;\\n        }\\n        if(dp[i][j][n]>0) return dp[i][j][n];\\n        long long ans=0;\\n        for(int k=0;k<8;k++)\\n        {\\n            if(isValid(i+dx[k],j+dy[k],mat))\\n            {\\n                ans+=solve(mat,n-1,i+dx[k],j+dy[k]);\\n            }\\n        }\\n       return dp[i][j][n]=ans%mod;\\n    }\\n    int knightDialer(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<vector<char>>mat(4,vector<char>(3));\\n        int k=1;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                mat[i][j]=(k+\\'0\\');\\n                k++;\\n            }\\n        }\\n        mat[3][0]=\\'*\\',mat[3][1]=\\'0\\',mat[3][2]=\\'#\\';\\n        long long ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(mat[i][j]!=\\'*\\' && mat[i][j]!=\\'#\\')\\n                ans+=solve(mat,n,i,j);\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056965,
                "title": "memoized-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9)+7;\\n\\n\\t// creating a map for maintaning all those indexes that can be reached from a given index.\\n\\t// for ex: 0 can reach 4 and 6. Similarily 1 can reach 6 , 8 and so on.\\n\\t\\n    vector<vector<int>> graph = {\\n        {4,6},\\n        {6,8},\\n        {7,9},\\n        {4,8},\\n        {0,3,9},\\n        {},\\n        {0,1,7},\\n        {2,6},\\n        {1,3},\\n        {2,4}\\n    };\\n    \\n    vector<vector<int>> dp;\\n    \\n\\t// int i = currentNumber \\n\\t// int len = length Of Current Number on Dialpad.\\n\\t\\n    int helper(int i,int len,int n){\\n        int ans = 0;\\n        if(len == n){\\n            return dp[i][len]=1;\\n        }\\n        \\n        if(dp[i][len] != -1) return dp[i][len];\\n        \\n        for(auto d:g[i]){\\n            ans += helper(d,len+1,n);\\n            ans = ans % mod;\\n        }\\n        \\n        return dp[i][len] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n        int ans = 0;\\n        dp.resize(10,vector<int>(n,-1));\\n        for(int i=0;i<=9;i++){\\n            ans += helper(i,0,n-1);\\n            ans = ans % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = pow(10,9)+7;\\n\\n\\t// creating a map for maintaning all those indexes that can be reached from a given index.\\n\\t// for ex: 0 can reach 4 and 6. Similarily 1 can reach 6 , 8 and so on.\\n\\t\\n    vector<vector<int>> graph = {\\n        {4,6},\\n        {6,8},\\n        {7,9},\\n        {4,8},\\n        {0,3,9},\\n        {},\\n        {0,1,7},\\n        {2,6},\\n        {1,3},\\n        {2,4}\\n    };\\n    \\n    vector<vector<int>> dp;\\n    \\n\\t// int i = currentNumber \\n\\t// int len = length Of Current Number on Dialpad.\\n\\t\\n    int helper(int i,int len,int n){\\n        int ans = 0;\\n        if(len == n){\\n            return dp[i][len]=1;\\n        }\\n        \\n        if(dp[i][len] != -1) return dp[i][len];\\n        \\n        for(auto d:g[i]){\\n            ans += helper(d,len+1,n);\\n            ans = ans % mod;\\n        }\\n        \\n        return dp[i][len] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n        int ans = 0;\\n        dp.resize(10,vector<int>(n,-1));\\n        for(int i=0;i<=9;i++){\\n            ans += helper(i,0,n-1);\\n            ans = ans % mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052655,
                "title": "dp-c",
                "content": "```\\n// dp[i][j][k]=count of i digits no\\'s that can be formed if start moving from from (j,k)\\n//from (i,j) we have 8 choices to move as per the move of knight\\n\\n#define lln long long int\\nlln mod=1e9+7;\\n\\nint dx[8]={2,2,-2,-2,1,1,-1,-1};\\nint dy[8]={1,-1,1,-1,2,-2,2,-2};\\n\\nlln dp[5001][4][4]; \\n\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        lln ans=0;\\n        \\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if((i==3 && j==0) || (i==3 && j==2))\\n                    continue;\\n                \\n                ans=(ans%mod+find(i,j,1,n)%mod)%mod;\\n            }\\n        }\\n        \\n        return ans%mod;\\n    }\\n    \\n    lln find(int i,int j,int len,int n){\\n    \\n        if(len==n){\\n            return 1;\\n        }\\n        \\n        if(dp[len][i][j]!=-1)\\n            return dp[len][i][j];\\n        \\n        lln count=0;\\n        \\n        for(int x=0;x<8;x++){\\n            int i1=i+dx[x];\\n            int j1=j+dy[x];\\n            \\n         if((i1==3 && j1==0) || (i1==3 && j1==2))\\n             continue;\\n    \\n        if(i1>=4 || i1<0 || j1>=3 || j1<0)\\n            continue;\\n                \\n         count=(count%mod+find(i1,j1,len+1,n)%mod)%mod;\\n\\n        }\\n        \\n        return dp[len][i][j]=count%mod;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int knightDialer(int n) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        lln ans=0;\\n        \\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                if((i==3 && j==0) || (i==3 && j==2))\\n                    continue;\\n                \\n                ans=(ans%mod+find(i,j,1,n)%mod)%mod;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2030753,
                "title": "java-dp-memoization-solution",
                "content": "```\\nclass Solution {\\n     int mod = 1000000007;\\n    public  int knightDialer(int n) {\\n        int[][] dp = new int[n+1][10];\\n        for (int [] d : dp)Arrays.fill(d,-1);\\n        HashMap<Integer, List<Integer>> routes = new HashMap<>();\\n        routes.put(0, Arrays.asList(4,6));\\n        routes.put(1, Arrays.asList(6,8));\\n        routes.put(2, Arrays.asList(7,9));\\n        routes.put(3, Arrays.asList(4,8));\\n        routes.put(4, Arrays.asList(0,3,9));\\n        routes.put(5, Arrays.asList());\\n        routes.put(6, Arrays.asList(0,1,7));\\n        routes.put(7, Arrays.asList(2,6));\\n        routes.put(8, Arrays.asList(1,3));\\n        routes.put(9, Arrays.asList(2,4));\\n        int count =0;\\n        for (int i=0;i<=9;i++){\\n            count = count  + helper(routes,i,2,n,dp)%mod;\\n            count = count%mod;\\n        }\\n\\n        return count;\\n    }\\n\\n    private  int helper(HashMap<Integer, List<Integer>> routes, int i, int pos, int n, int [][] dp) {\\n\\n        if (pos == n+1) return 1;\\n        if (dp[pos][i] != -1) return dp[pos][i];\\n        int count = 0;\\n        for (int val : routes.get(i)) {\\n            count = count + helper(routes, val, pos + 1, n,dp) % mod;\\n            count = count % mod;\\n        }\\n        return dp[pos][i] = count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     int mod = 1000000007;\\n    public  int knightDialer(int n) {\\n        int[][] dp = new int[n+1][10];\\n        for (int [] d : dp)Arrays.fill(d,-1);\\n        HashMap<Integer, List<Integer>> routes = new HashMap<>();\\n        routes.put(0, Arrays.asList(4,6));\\n        routes.put(1, Arrays.asList(6,8));\\n        routes.put(2, Arrays.asList(7,9));\\n        routes.put(3, Arrays.asList(4,8));\\n        routes.put(4, Arrays.asList(0,3,9));\\n        routes.put(5, Arrays.asList());\\n        routes.put(6, Arrays.asList(0,1,7));\\n        routes.put(7, Arrays.asList(2,6));\\n        routes.put(8, Arrays.asList(1,3));\\n        routes.put(9, Arrays.asList(2,4));\\n        int count =0;\\n        for (int i=0;i<=9;i++){\\n            count = count  + helper(routes,i,2,n,dp)%mod;\\n            count = count%mod;\\n        }\\n\\n        return count;\\n    }\\n\\n    private  int helper(HashMap<Integer, List<Integer>> routes, int i, int pos, int n, int [][] dp) {\\n\\n        if (pos == n+1) return 1;\\n        if (dp[pos][i] != -1) return dp[pos][i];\\n        int count = 0;\\n        for (int val : routes.get(i)) {\\n            count = count + helper(routes, val, pos + 1, n,dp) % mod;\\n            count = count % mod;\\n        }\\n        return dp[pos][i] = count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997235,
                "title": "java-dp-memoization-intuitive-approach",
                "content": "The idea is to find the repeatitive subproblems with optimal substructure property. \\nHere we can see that all the states when which have \\'1\\' (or any other digit) in previous position will not be same. (1_ and 1 _ _  are not same subproblems, as these two states have different answers).\\nSo what our subproblem will be?\\nCan we say that whenever our previous position =1 (for example) and if the number of remaining digits are same, then these 2 will be same subproblems.\\nex - 231_ _ and 51_ _ => are same states, as now onward both will produce same answer, since both have 2 digits remaining and for both states last filled digit is same.\\nThus in our dp solution, we will be be caching previous digit and number of remaining digits as one state. \\n\\nclass Solution {\\n    \\n    int mod = (int) (1e9+7);\\n    public int knightDialer(int n) {\\n        if(n==1)    return 10;\\n        Map<Integer,List<Integer>> adjMap = new HashMap<>();\\n        getAdjMap(adjMap);\\n                \\n        int dp[][] = new int[10][n+1];\\n        for(int row[]:dp)  Arrays.fill(row,-1);\\n        \\n        int cnt=0;\\n        int pos=2;\\n        for(int i=0;i<=9;i++){\\n            cnt += dfs(adjMap, i, pos, n, dp);\\n            cnt = cnt%mod;\\n        }\\n        \\n        return cnt;\\n    }\\n    \\n    // dp states - prev, n-pos+1          \\n\\t// prev - digit present at previous position. \\n\\t// n-pos+1 - number of left positions to be filled\\n\\t// (pos: current position to be filled; n: lenght of phone number)\\n    \\n    private int dfs(Map<Integer,List<Integer>> adjMap, int prev, int pos, int n, int dp[][]){\\n        \\n        if(pos == n+1)                      \\n            return 1;                \\n        \\n        if(dp[prev][n-pos+1]!=-1)   return dp[prev][n-pos+1];\\n        \\n        int t=0;\\n        for(int child: adjMap.get(prev)){\\n            t += dfs(adjMap, child, pos+1, n, dp);  \\n            t=t%mod;\\n        }\\n        \\n        return dp[prev][n-pos+1] = t;\\n    }\\n    \\n    private void getAdjMap(Map<Integer,List<Integer>> map){\\n        for(int i=0;i<=9;i++)\\n            map.put(i, new ArrayList<>());\\n        \\n        map.put(0, List.of(4,6));\\n        map.put(1, List.of(6,8));\\n        map.put(2, List.of(7,9));\\n        map.put(3, List.of(4,8));\\n        map.put(4, List.of(0,3,9));\\n        map.put(6, List.of(0,1,7));\\n        map.put(7, List.of(2,6));\\n        map.put(8, List.of(1,3));\\n        map.put(9, List.of(2,4));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int mod = (int) (1e9+7);\\n    public int knightDialer(int n) {\\n        if(n==1)    return 10;\\n        Map<Integer,List<Integer>> adjMap = new HashMap<>();\\n        getAdjMap(adjMap);\\n                \\n        int dp[][] = new int[10][n+1];\\n        for(int row[]:dp)  Arrays.fill(row,-1);\\n        \\n        int cnt=0;\\n        int pos=2;\\n        for(int i=0;i<=9;i++){\\n            cnt += dfs(adjMap, i, pos, n, dp);\\n            cnt = cnt%mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1978970,
                "title": "simple-recursive-dp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f605fb70-db83-41d3-bbb2-902297aa2039_1650817004.5904217.png)\\n```\\nconst int mod = (int)1e9 + 7 ; \\n\\nclass Solution {\\npublic:\\n    /*\\n    Its clear we have to use recursion !\\n    From the constraint we are clear that DP is needed \\n    \\n    ans -> Solution(0, n) + Solution(1, n) + .. Solution(9, n) ;\\n    \\n    */\\n    long long dp[10][5001] ; \\n    vector<vector<int>> valid_places = {{4, 6}, {6, 8},\\n                                        {7, 9}, {4, 8},\\n                                        {3, 9, 0}, {}, {1, 7, 0},\\n                                        {2 ,6}, {1, 3}, {4, 2}} ; \\n    \\n    long long util(int src, int n) {\\n        if(n == 1) return 1LL ;\\n        if(dp[src][n] != -1) return dp[src][n] ; \\n        long long total = 0; \\n        for(auto &p : valid_places[src]){\\n           total = (total + util(p, n-1)) % mod ; \\n        }\\n        return dp[src][n] = total ; \\n    }\\n    \\n    int knightDialer(int n) {\\n        memset(dp, -1, sizeof(dp)) ; \\n        long long ans = 0 ; \\n        for(int i = 0 ; i<10 ; i++)\\n            ans = (ans + util(i, n)) % mod ; \\n        return (int)ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int mod = (int)1e9 + 7 ; \\n\\nclass Solution {\\npublic:\\n    /*\\n    Its clear we have to use recursion !\\n    From the constraint we are clear that DP is needed \\n    \\n    ans -> Solution(0, n) + Solution(1, n) + .. Solution(9, n) ;\\n    \\n    */\\n    long long dp[10][5001] ; \\n    vector<vector<int>> valid_places = {{4, 6}, {6, 8},\\n                                        {7, 9}, {4, 8},\\n                                        {3, 9, 0}, {}, {1, 7, 0},\\n                                        {2 ,6}, {1, 3}, {4, 2}} ; \\n    \\n    long long util(int src, int n) {\\n        if(n == 1) return 1LL ;\\n        if(dp[src][n] != -1) return dp[src][n] ; \\n        long long total = 0; \\n        for(auto &p : valid_places[src]){\\n           total = (total + util(p, n-1)) % mod ; \\n        }\\n        return dp[src][n] = total ; \\n    }\\n    \\n    int knightDialer(int n) {\\n        memset(dp, -1, sizeof(dp)) ; \\n        long long ans = 0 ; \\n        for(int i = 0 ; i<10 ; i++)\\n            ans = (ans + util(i, n)) % mod ; \\n        return (int)ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967691,
                "title": "c-60-fast-solution-top-down-dp-very-easy-approach",
                "content": "```\\nvector<vector<int>>moves{\\n    {4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}\\n};\\nint mod=1e9+7;\\nclass Solution {\\n    long long count_no(int n,int x,vector<vector<int>>&dp){\\n       if(n==0)return 1;\\n        if(dp[n][x]!=-1)return dp[n][x];\\n        long long n1=0;\\n        for(int val:moves[x])\\n            n1=(n1+count_no(n-1,val,dp))%mod;\\n        return dp[n][x]=n1;\\n    }\\n    \\npublic:\\n    int knightDialer(int n) {\\n        long long res=0;\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        for(int i=0;i<10;i++)\\n            res=(res+count_no(n-1, i,dp))%mod;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nvector<vector<int>>moves{\\n    {4,6},{6,8},{7,9},{4,8},{0,3,9},{},{0,1,7},{2,6},{1,3},{2,4}\\n};\\nint mod=1e9+7;\\nclass Solution {\\n    long long count_no(int n,int x,vector<vector<int>>&dp){\\n       if(n==0)return 1;\\n        if(dp[n][x]!=-1)return dp[n][x];\\n        long long n1=0;\\n        for(int val:moves[x])\\n            n1=(n1+count_no(n-1,val,dp))%mod;\\n        return dp[n][x]=n1;\\n    }\\n    \\npublic:\\n    int knightDialer(int n) {\\n        long long res=0;\\n        vector<vector<int>>dp(n+1,vector<int>(10,-1));\\n        for(int i=0;i<10;i++)\\n            res=(res+count_no(n-1, i,dp))%mod;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894969,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int mod=1000000000+7;\\n    int moves[8][2]={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};\\n    vector<vector<vector<int>>>memo;\\n    int findAns(int r,int c,int n){\\n        if(r<0 or r>3 or c<0 or c>2 or (r==3 and c==2) or (r==3 and c==0)){\\n            return 0;\\n        } else if(n==0){\\n            return 1;\\n        } else if(memo[r][c][n]!=-1){\\n            return memo[r][c][n];\\n        } else {\\n            int ans=0;\\n            for(int i=0;i<8;i++){\\n                int nr=r+moves[i][0];\\n                int nc=c+moves[i][1];\\n                if(nr<0 or nc<0 or nr>3 or nc>2 or (nr==3 and (nc==0 or nc==2))){\\n                    continue;\\n                } else {\\n                    ans=(ans%mod+findAns(nr,nc,n-1)%mod)%mod;\\n                }\\n            }\\n            return memo[r][c][n]=ans%mod;\\n        }\\n    }\\npublic:\\n    int knightDialer(int n) {\\n        memo=vector<vector<vector<int>>>(4,vector<vector<int>>(3,vector<int>(n,-1)));\\n        int ans=0;\\n        for(int i=0;i<4;i++){\\n            for(int j=0;j<3;j++){\\n                ans=(ans%mod+findAns(i,j,n-1)%mod)%mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    int mod=1000000000+7;\\n    int moves[8][2]={{1,2}",
                "codeTag": "Java"
            },
            {
                "id": 1857693,
                "title": "c-recursion-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    int mod = 1e9 + 7; \\n    int dp[10][5005];\\n    int solve(int num, int n, map<int, vector<int>> & v){\\n          if(n == 1) return 1;\\n          int ans = 0;\\n          if(dp[num][n] != -1) return dp[num][n];\\n          for(int i : v[num]){\\n              ans = (ans + solve(i, n - 1, v)) % mod;\\n          }\\n        return dp[num][n] = ans;\\n        \\n    }\\n    int knightDialer(int n) {\\n          map<int, vector<int>> v;\\n    v[1] = {6,8},v[2] = {7,9}, v[3] = {4,8}, v[4] = {0,3,9}, v[5] = {}, v[6] = {0,1,7}, v[7] = {2,6}, v[8] = {1,3}, v[9] = {2,4}, v[0] = {4,6};\\n         memset(dp, -1, sizeof(dp));\\n         int ans = 0;\\n         for(int i=0; i<=9; i++){\\n             ans = (ans + solve(i,n, v)) % mod;\\n         }\\n        \\n         return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n  \\n    int mod = 1e9 + 7; \\n    int dp[10][5005];\\n    int solve(int num, int n, map<int, vector<int>> & v){\\n          if(n == 1) return 1;\\n          int ans = 0;\\n          if(dp[num][n] != -1) return dp[num][n];\\n          for(int i : v[num]){\\n              ans = (ans + solve(i, n - 1, v)) % mod;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1847842,
                "title": "javascript-top-down-recursive-memoization-explanation",
                "content": "```\\n/** https://leetcode.com/problems/knight-dialer/\\n * @param {number} n\\n * @return {number}\\n */\\nvar knightDialer = function(n) {\\n  // Memo\\n  this.memo = new Map();\\n  \\n  // Modulo\\n  this.mod = (10 ** 9) + 7;\\n  \\n  // All valid knight\\'s directions and valid keypad numeric\\'s coordinates\\n  let directions = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]];\\n  let numericCoord = [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2], [3, 1]];\\n  \\n  let count = 0;\\n  \\n  // Starting coordinate of every valid key in the keypad\\n  for (let [r, c] of numericCoord) {\\n    count += dp(n, directions, r, c, n - 1);\\n  }\\n  \\n  // Return result with modulo\\n  return count % this.mod;\\n};\\n\\nvar dp = function(n, directions, r, c, remain) {\\n  let key = `${r}_${c}_${remain}`;\\n  \\n  // Base case\\n  if (remain === 0) {\\n    return 1;\\n  }\\n  \\n  // Return from memo\\n  if (this.memo.has(key) === true) {\\n    return this.memo.get(key);\\n  }\\n  \\n  let count = 0;\\n  \\n  // Try to go every valid directions a knight can go\\n  for (let [nextR, nextC] of directions) {\\n    // If the next direction is invalid, try another direction\\n    if (isValid(r + nextR, c + nextC) === false) {\\n      continue;\\n    }\\n    \\n    // Next direction is valid, result could be huge so we perform modulo\\n    count += dp(n, directions, r + nextR, c + nextC, remain - 1) % this.mod;\\n  }\\n  \\n  // Set memo\\n  this.memo.set(key, count);\\n  \\n  return count;\\n};\\n\\nvar isValid = function(r, c) {\\n  // Check if coordinate is in keypad coordinate boundary, except the asterisk (3, 0) and hashtag (3, 2)\\n  return (r >= 0 && r < 4 && c >= 0 && c < 3) &&\\n    !(r === 3 && c === 0) &&\\n    !(r === 3 && c === 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/** https://leetcode.com/problems/knight-dialer/\\n * @param {number} n\\n * @return {number}\\n */\\nvar knightDialer = function(n) {\\n  // Memo\\n  this.memo = new Map();\\n  \\n  // Modulo\\n  this.mod = (10 ** 9) + 7;\\n  \\n  // All valid knight\\'s directions and valid keypad numeric\\'s coordinates\\n  let directions = [[-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2], [-1, -2]];\\n  let numericCoord = [[0,0], [0,1], [0,2], [1,0], [1,1], [1,2], [2,0], [2,1], [2,2], [3, 1]];\\n  \\n  let count = 0;\\n  \\n  // Starting coordinate of every valid key in the keypad\\n  for (let [r, c] of numericCoord) {\\n    count += dp(n, directions, r, c, n - 1);\\n  }\\n  \\n  // Return result with modulo\\n  return count % this.mod;\\n};\\n\\nvar dp = function(n, directions, r, c, remain) {\\n  let key = `${r}_${c}_${remain}`;\\n  \\n  // Base case\\n  if (remain === 0) {\\n    return 1;\\n  }\\n  \\n  // Return from memo\\n  if (this.memo.has(key) === true) {\\n    return this.memo.get(key);\\n  }\\n  \\n  let count = 0;\\n  \\n  // Try to go every valid directions a knight can go\\n  for (let [nextR, nextC] of directions) {\\n    // If the next direction is invalid, try another direction\\n    if (isValid(r + nextR, c + nextC) === false) {\\n      continue;\\n    }\\n    \\n    // Next direction is valid, result could be huge so we perform modulo\\n    count += dp(n, directions, r + nextR, c + nextC, remain - 1) % this.mod;\\n  }\\n  \\n  // Set memo\\n  this.memo.set(key, count);\\n  \\n  return count;\\n};\\n\\nvar isValid = function(r, c) {\\n  // Check if coordinate is in keypad coordinate boundary, except the asterisk (3, 0) and hashtag (3, 2)\\n  return (r >= 0 && r < 4 && c >= 0 && c < 3) &&\\n    !(r === 3 && c === 0) &&\\n    !(r === 3 && c === 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821648,
                "title": "c-3d-dp",
                "content": "Hopefully it helps average peeps like me get some intuition.\\n```\\nconst vector<vector<int>> pad = {\\n            {  1,  2,  3 },\\n            {  4,  5,  6 },\\n            {  7,  8,  9 },\\n            { -1,  0, -1 }\\n};\\nconst int MOD = (int)1e9 + 7;\\nclass Solution {\\n    vector<vector<vector<int>>> dp;\\n    vector<int> dr = { -2, -2, 2, 2, -1, 1, -1, 1 };\\n    vector<int> dc = { -1, 1, -1, 1, -2, -2, 2, 2 };\\npublic:\\n    int f(int i, int j, int n)\\n    {\\n        if (i < 0 || j < 0) return 0;\\n        if (i > 3 || j > 2) return 0;\\n        if (pad[i][j] == -1) return 0;\\n        if (n == 0) return 1;\\n        if (dp[i][j][n] != -1) return dp[i][j][n];\\n\\n        dp[i][j][n] = 0;\\n        for (int k = 0; k < 8; ++k) {\\n            dp[i][j][n] = (dp[i][j][n] + f(i + dr[k], j + dc[k], n - 1)) % MOD;\\n        }\\n        return dp[i][j][n] % MOD;\\n    }\\n    int knightDialer(int n)\\n    {\\n        vector<vector<vector<int>>> t(5, vector<vector<int>>(4, vector<int>(5005, -1)));\\n        dp = t;\\n        int sum = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                sum = (sum + f(i, j, n - 1)) % MOD;\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst vector<vector<int>> pad = {\\n            {  1,  2,  3 },\\n            {  4,  5,  6 },\\n            {  7,  8,  9 },\\n            { -1,  0, -1 }\\n};\\nconst int MOD = (int)1e9 + 7;\\nclass Solution {\\n    vector<vector<vector<int>>> dp;\\n    vector<int> dr = { -2, -2, 2, 2, -1, 1, -1, 1 };\\n    vector<int> dc = { -1, 1, -1, 1, -2, -2, 2, 2 };\\npublic:\\n    int f(int i, int j, int n)\\n    {\\n        if (i < 0 || j < 0) return 0;\\n        if (i > 3 || j > 2) return 0;\\n        if (pad[i][j] == -1) return 0;\\n        if (n == 0) return 1;\\n        if (dp[i][j][n] != -1) return dp[i][j][n];\\n\\n        dp[i][j][n] = 0;\\n        for (int k = 0; k < 8; ++k) {\\n            dp[i][j][n] = (dp[i][j][n] + f(i + dr[k], j + dc[k], n - 1)) % MOD;\\n        }\\n        return dp[i][j][n] % MOD;\\n    }\\n    int knightDialer(int n)\\n    {\\n        vector<vector<vector<int>>> t(5, vector<vector<int>>(4, vector<int>(5005, -1)));\\n        dp = t;\\n        int sum = 0;\\n        for (int i = 0; i < 4; ++i) {\\n            for (int j = 0; j < 3; ++j) {\\n                sum = (sum + f(i, j, n - 1)) % MOD;\\n            }\\n        }\\n        return sum % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794663,
                "title": "java-easy-clean-and-detailed-solution",
                "content": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n == 1)\\n            return 10;\\n        int[] og = new int[10];\\n        int mod = 1000000007;\\n        Arrays.fill(og, 1);\\n        int[][] reach = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        for(int i = 2; i <= n; i++){\\n            int[] newarr = new int[10];\\n            int sum = 0;\\n            for(int j = 0; j < reach.length; j++){\\n                for(int k = 0; k < reach[j].length; k++){\\n                    newarr[j] = (newarr[j] + og[reach[j][k]]) % mod;\\n                }\\n                sum = (sum + newarr[j]) % mod;\\n            }\\n            og = newarr;\\n            if(i == n)\\n            \\treturn sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int knightDialer(int n) {\\n        if(n == 1)\\n            return 10;\\n        int[] og = new int[10];\\n        int mod = 1000000007;\\n        Arrays.fill(og, 1);\\n        int[][] reach = {{4, 6}, {6, 8}, {7, 9}, {4, 8}, {0, 3, 9}, {}, {0, 1, 7}, {2, 6}, {1, 3}, {2, 4}};\\n        for(int i = 2; i <= n; i++){\\n            int[] newarr = new int[10];\\n            int sum = 0;\\n            for(int j = 0; j < reach.length; j++){\\n                for(int k = 0; k < reach[j].length; k++){\\n                    newarr[j] = (newarr[j] + og[reach[j][k]]) % mod;\\n                }\\n                sum = (sum + newarr[j]) % mod;\\n            }\\n            og = newarr;\\n            if(i == n)\\n            \\treturn sum;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773547,
                "title": "c-ez-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long dp[n+1][10];\\n        int m = 1e9+7;\\n        memset(dp,0,sizeof(dp));\\n        for(int i = 0;i<10;i++){\\n            dp[1][i] = 1;//with length = 1 and end with 0,1,...9 = 1 way\\n        }\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0;j<10;j++){\\n                if(j == 0){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][6])%m; \\n                    ///with length = i we will have result = sum of ways with length = i-1 end with 4 and end with 6, because 4 and 6 will jump to 0. \\n\\t\\t\\t\\t\\t///Similar for other case\\n                }\\n                else if(j == 1){\\n                    dp[i][j] = (dp[i-1][6]+dp[i-1][8])%m;\\n                }\\n                else if(j == 2){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9])%m;\\n                }\\n                else if(j == 3){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][8])%m;\\n                }\\n                else if(j == 4){\\n                    dp[i][j] = (dp[i-1][3]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 6){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 7){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][6])%m;\\n                }\\n                else if(j == 8){\\n                    dp[i][j] = (dp[i-1][1]+dp[i-1][3])%m;\\n                }\\n                else if(j == 9){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][4])%m;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0;i<10;i++){\\n            res = (res+dp[n][i])%m;\\n        }\\n        return res;\\n    }\\n};\\n```\\nif this help, pls upvote",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) {\\n        long long dp[n+1][10];\\n        int m = 1e9+7;\\n        memset(dp,0,sizeof(dp));\\n        for(int i = 0;i<10;i++){\\n            dp[1][i] = 1;//with length = 1 and end with 0,1,...9 = 1 way\\n        }\\n        for(int i = 2;i<=n;i++){\\n            for(int j = 0;j<10;j++){\\n                if(j == 0){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][6])%m; \\n                    ///with length = i we will have result = sum of ways with length = i-1 end with 4 and end with 6, because 4 and 6 will jump to 0. \\n\\t\\t\\t\\t\\t///Similar for other case\\n                }\\n                else if(j == 1){\\n                    dp[i][j] = (dp[i-1][6]+dp[i-1][8])%m;\\n                }\\n                else if(j == 2){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9])%m;\\n                }\\n                else if(j == 3){\\n                    dp[i][j] = (dp[i-1][4]+dp[i-1][8])%m;\\n                }\\n                else if(j == 4){\\n                    dp[i][j] = (dp[i-1][3]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 6){\\n                    dp[i][j] = (dp[i-1][7]+dp[i-1][9]+dp[i-1][0])%m;\\n                }\\n                else if(j == 7){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][6])%m;\\n                }\\n                else if(j == 8){\\n                    dp[i][j] = (dp[i-1][1]+dp[i-1][3])%m;\\n                }\\n                else if(j == 9){\\n                    dp[i][j] = (dp[i-1][2]+dp[i-1][4])%m;\\n                }\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0;i<10;i++){\\n            res = (res+dp[n][i])%m;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772664,
                "title": "c-sol-recursion-memoization",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int NumOfWays(int i, int j, int len, vector<vector<vector<int>>> &dp)\\n    {\\n        if ( (i == 3 && j == 0) || (i == 3 && j == 2) || (i > 3) || (j > 2) || (i < 0) || (j < 0))\\n            return 0;\\n        if ( len == 1)\\n            return 1;\\n        if (dp[i][j][len] != -1)\\n            return dp[i][j][len];\\n        \\n        int ans = 0;\\n        ans = (ans +(NumOfWays(i-2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j+2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j+2,len-1,dp)%mod))%mod;\\n        return dp[i][j][len] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp (4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                ans += (NumOfWays(i,j,n,dp)%mod);\\n                ans%= mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity -: O(n x 4 x 3) = O(n);",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\npublic:\\n    int NumOfWays(int i, int j, int len, vector<vector<vector<int>>> &dp)\\n    {\\n        if ( (i == 3 && j == 0) || (i == 3 && j == 2) || (i > 3) || (j > 2) || (i < 0) || (j < 0))\\n            return 0;\\n        if ( len == 1)\\n            return 1;\\n        if (dp[i][j][len] != -1)\\n            return dp[i][j][len];\\n        \\n        int ans = 0;\\n        ans = (ans +(NumOfWays(i-2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j-1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+2,j+1,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i-1,j+2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j-2,len-1,dp)%mod))%mod;\\n        ans = (ans +(NumOfWays(i+1,j+2,len-1,dp)%mod))%mod;\\n        return dp[i][j][len] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp (4,vector<vector<int>>(3,vector<int>(n+1,-1)));\\n        int ans = 0;\\n        for (int i = 0; i < 4; i++)\\n        {\\n            for (int j = 0; j < 3; j++)\\n            {\\n                ans += (NumOfWays(i,j,n,dp)%mod);\\n                ans%= mod;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723487,
                "title": "python3-bottom-up-approach-dp",
                "content": "**consider after ith jump we reach digit 1 , then on (i-1)th jump we will be at either 6 or 8\\nso dp relation becomes dp[i][1]=dp[i-1][6]+dp[i-1][8]. Similar for every number .**\\n```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr=[[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[1,0,7],[2,6],[1,3],[2,4]] #arr[i] stores the position to which we can go next from i\\n        dp=[[0 for i in range(10)] for j in range(n)]\\n        mod=10**9+7\\n        for i in range(10):\\n            dp[0][i]=1\\n        for i in range(1,n):\\n            for j in range(10):\\n                for k in range(len(arr[j])):\\n                    dp[i][j]+=dp[i-1][arr[j][k]]\\n        return sum(dp[n-1])%mod\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        arr=[[4,6],[8,6],[7,9],[4,8],[3,9,0],[],[1,0,7],[2,6],[1,3],[2,4]] #arr[i] stores the position to which we can go next from i\\n        dp=[[0 for i in range(10)] for j in range(n)]\\n        mod=10**9+7\\n        for i in range(10):\\n            dp[0][i]=1\\n        for i in range(1,n):\\n            for j in range(10):\\n                for k in range(len(arr[j])):\\n                    dp[i][j]+=dp[i-1][arr[j][k]]\\n        return sum(dp[n-1])%mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701719,
                "title": "c-solution-dynamic-programming-recursive-bottom-up",
                "content": "\\n\\tint mod = 1000000007;\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &v, int i,int j,int n,int count)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[i].size() || v[i][j]==\\'*\\' || v[i][j]==\\'#\\')\\n            return 0;\\n        if(count==n)\\n            return 1;\\n        if(dp[count][i][j]>0)\\n            return dp[count][i][j];\\n        long long int run1=solve(dp,v,i-2,j-1,n,count+1)%mod;\\n        long long int run2=solve(dp,v,i-2,j+1,n,count+1)%mod;\\n        long long int run3=solve(dp,v,i-1,j-2,n,count+1)%mod;\\n        long long int run4=solve(dp,v,i-1,j+2,n,count+1)%mod;\\n        long long int run5=solve(dp,v,i+2,j+1,n,count+1)%mod;\\n        long long int run6=solve(dp,v,i+2,j-1,n,count+1)%mod;\\n        long long int run7=solve(dp,v,i+1,j+2,n,count+1)%mod;\\n        long long int run8=solve(dp,v,i+1,j-2,n,count+1)%mod;\\n        return dp[count][i][j]=((run1+run2+run3+run4+run5+run6+run7+run8)%mod)%mod;\\n        \\n    }\\n    int knightDialer(int n) {\\n        vector<vector<char>> v={{\\'1\\',\\'2\\',\\'3\\'},{\\'4\\',\\'5\\',\\'6\\'},{\\'7\\',\\'8\\',\\'9\\'},{\\'*\\',\\'0\\',\\'#\\'}};\\n       // vector<string> ans;\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(4,vector<int> (4,0)));\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n                ans+=( solve(dp,v,i,j,n-1,0)%mod);\\n        }\\n        return ans%mod;\\n\\t\\t\\nPlease upvote if you like this solution.\\nThanks",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\n\\tint mod = 1000000007;\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &v, int i,int j,int n,int count)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v[i].size() || v[i][j]==\\'*\\' || v[i][j]==\\'#\\')\\n            return 0;\\n        if(count==n)\\n            return 1;\\n        if(dp[count][i][j]>0)\\n            return dp[count][i][j];\\n        long long int run1=solve(dp,v,i-2,j-1,n,count+1)%mod;\\n        long long int run2=solve(dp,v,i-2,j+1,n,count+1)%mod;\\n        long long int run3=solve(dp,v,i-1,j-2,n,count+1)%mod;\\n        long long int run4=solve(dp,v,i-1,j+2,n,count+1)%mod;\\n        long long int run5=solve(dp,v,i+2,j+1,n,count+1)%mod;\\n        long long int run6=solve(dp,v,i+2,j-1,n,count+1)%mod;\\n        long long int run7=solve(dp,v,i+1,j+2,n,count+1)%mod;\\n        long long int run8=solve(dp,v,i+1,j-2,n,count+1)%mod;\\n        return dp[count][i][j]=((run1+run2+run3+run4+run5+run6+run7+run8)%mod)%mod;\\n        \\n    }\\n    int knightDialer(int n) {\\n        vector<vector<char>> v={{\\'1\\',\\'2\\',\\'3\\'},{\\'4\\',\\'5\\',\\'6\\'},{\\'7\\',\\'8\\',\\'9\\'},{\\'*\\',\\'0\\',\\'#\\'}};\\n       // vector<string> ans;\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(4,vector<int> (4,0)));\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=0;j<v[i].size();j++)\\n                ans+=( solve(dp,v,i,j,n-1,0)%mod);\\n        }\\n        return ans%mod;\\n\\t\\t\\nPlease upvote if you like this solution.\\nThanks",
                "codeTag": "Unknown"
            },
            {
                "id": 1671885,
                "title": "python-top-down-dynamic-programming-time-out",
                "content": "Could someone explain why this is getting time-out errors?\\n\\nI\\'ve used top-down DP (recursion + memoization) and it\\'s still timing out:\\n\\n```{python}\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t\\trows = 3\\n\\t\\tcolumns = 2\\n\\t\\tcache = {}\\n\\t\\t# three state variables\\n\\n\\t\\tdef recurse(i, j, n):\\n\\t\\t\\tif i > rows or i < 0 or j > columns or j < 0 or [i,j] == [3,0] or [i,j] == [3,2]:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\telif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\tif (i ,j, n) in cache:\\n\\t\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\t\\tcache[(i, j, n)] =  sum([recurse(i - 2, j - 1, n - 1), recurse(i - 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i - 2, j + 1, n - 1), recurse(i - 1, j  + 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j - 1, n - 1), recurse(i + 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j + 1, n - 1), recurse(i + 1, j + 2, n - 1)])\\n\\n\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\treturn sum([recurse(0, 0, n - 1), recurse(0, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(0, 2, n - 1), recurse(1, 0, n - 1),\\n\\t\\t\\t\\t\\trecurse(1, 1, n - 1), recurse(1, 2, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 0, n - 1), recurse(2, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 2, n - 1), recurse(3, 1, n - 1)]) % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```{python}\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n\\t\\trows = 3\\n\\t\\tcolumns = 2\\n\\t\\tcache = {}\\n\\t\\t# three state variables\\n\\n\\t\\tdef recurse(i, j, n):\\n\\t\\t\\tif i > rows or i < 0 or j > columns or j < 0 or [i,j] == [3,0] or [i,j] == [3,2]:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\telif n == 0:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\tif (i ,j, n) in cache:\\n\\t\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\t\\tcache[(i, j, n)] =  sum([recurse(i - 2, j - 1, n - 1), recurse(i - 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i - 2, j + 1, n - 1), recurse(i - 1, j  + 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j - 1, n - 1), recurse(i + 1, j - 2, n - 1),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t recurse(i + 2, j + 1, n - 1), recurse(i + 1, j + 2, n - 1)])\\n\\n\\t\\t\\treturn cache[(i, j, n)]\\n\\n\\t\\treturn sum([recurse(0, 0, n - 1), recurse(0, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(0, 2, n - 1), recurse(1, 0, n - 1),\\n\\t\\t\\t\\t\\trecurse(1, 1, n - 1), recurse(1, 2, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 0, n - 1), recurse(2, 1, n - 1),\\n\\t\\t\\t\\t\\trecurse(2, 2, n - 1), recurse(3, 1, n - 1)]) % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662475,
                "title": "python-2-ways-dfs-cache-dp",
                "content": "Solution1 : DFS + Memo\\n```\\ndef knightDialer(self, n: int) -> int:\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\n\\t@cache\\n\\tdef path(x, l): # x: current number, l :length\\n\\t\\tnonlocal mapping, n\\n\\t\\tif l == n:\\n\\t\\t\\treturn 1\\n\\t\\tnexts = mapping.get(x, [])\\n\\t\\tres = 0\\n\\t\\tfor n1 in nexts:\\n\\t\\t\\tres+=path(n1, l+1)\\n\\t\\treturn res\\n\\tresult = 0\\n\\tfor i in range(0, 10):\\n\\t\\tresult += path(i,1)\\n\\treturn result % (pow(10,9)+7)\\n```\\n\\nThink about when standing at number x, length=n , path(n) += each path(mapping(n-1)) , so if we solve all length=n-1 case for all numbers (0-9), can get number x when length=n , formular :\\ndp[n][x] += dp[n-1][mapping[n]] \\nso we could start with solving n=1 case, then n=2 , ... until n=n \\nSolution2 : DP\\n```\\ndef knightDialer(self, n: int) -> int:\\n\\t\"\"\"\\n\\t\\tDP. Sample keyboard :\\n\\t\\tb - c\\n\\t\\t- - -\\n\\t\\t- a -\\n\\t\\tstep 1.For length=1, easy to get dp[1][a]=1, dp[1][b]=1, dp[1][c]=1\\n\\t\\tstep 2.dp[2][a] = dp[1][b] + dp[1][c]\\n\\t\\t...\\n\\t\\tdp[n][a] = dp[n-1][b]+dp[n-1][c]\\n\\t\"\"\"\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\tdp = [[0]*10 for _ in range(n+1)]  #dp[length][count]\\n\\n\\tfor i in range(0, 10):  # length=1, only 1 way for each number (0-9)\\n\\t\\tdp[1][i] = 1\\n\\n\\tfor i in range(2, n+1):\\n\\t\\tfor j in range(0, 10):\\n\\t\\t\\tfor x in mapping.get(j, []):\\n\\t\\t\\t\\tdp[i][j] += dp[i-1][x]\\n\\treturn sum(dp[n][i] for i in range(0, 10))  % (pow(10,9)+7)\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef knightDialer(self, n: int) -> int:\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\n\\t@cache\\n\\tdef path(x, l): # x: current number, l :length\\n\\t\\tnonlocal mapping, n\\n\\t\\tif l == n:\\n\\t\\t\\treturn 1\\n\\t\\tnexts = mapping.get(x, [])\\n\\t\\tres = 0\\n\\t\\tfor n1 in nexts:\\n\\t\\t\\tres+=path(n1, l+1)\\n\\t\\treturn res\\n\\tresult = 0\\n\\tfor i in range(0, 10):\\n\\t\\tresult += path(i,1)\\n\\treturn result % (pow(10,9)+7)\\n```\n```\\ndef knightDialer(self, n: int) -> int:\\n\\t\"\"\"\\n\\t\\tDP. Sample keyboard :\\n\\t\\tb - c\\n\\t\\t- - -\\n\\t\\t- a -\\n\\t\\tstep 1.For length=1, easy to get dp[1][a]=1, dp[1][b]=1, dp[1][c]=1\\n\\t\\tstep 2.dp[2][a] = dp[1][b] + dp[1][c]\\n\\t\\t...\\n\\t\\tdp[n][a] = dp[n-1][b]+dp[n-1][c]\\n\\t\"\"\"\\n\\tmapping = {0:(4,6),1:(6,8),2:(7,9),3:(4,8),4:(3,9,0),6:(1,7,0),7:(2,6),8:(1,3),9:(2,4)}\\n\\tdp = [[0]*10 for _ in range(n+1)]  #dp[length][count]\\n\\n\\tfor i in range(0, 10):  # length=1, only 1 way for each number (0-9)\\n\\t\\tdp[1][i] = 1\\n\\n\\tfor i in range(2, n+1):\\n\\t\\tfor j in range(0, 10):\\n\\t\\t\\tfor x in mapping.get(j, []):\\n\\t\\t\\t\\tdp[i][j] += dp[i-1][x]\\n\\treturn sum(dp[n][i] for i in range(0, 10))  % (pow(10,9)+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1661330,
                "title": "java-2ms-dp",
                "content": "`static` memo is the key.\\n\\n```\\nclass Solution {\\n    \\n    static int mod = 1000_000_007;\\n    static int[][] map = new int[10][];\\n    static List<int[]> memo = new ArrayList<>();\\n    static {\\n        map[0] = new int[] {4, 6};\\n        map[1] = new int[] {6, 8};\\n        map[2] = new int[] {7, 9};\\n        map[3] = new int[] {4, 8};\\n        map[4] = new int[] {3, 9, 0};\\n        map[5] = new int[0];\\n        map[6] = new int[] {1, 7, 0};\\n        map[7] = new int[] {2, 6};\\n        map[8] = new int[] {1, 3};\\n        map[9] = new int[] {2, 4};\\n        memo.add(new int[] {1, 1, 1, 1, 1, 0, 1, 1, 1, 1});\\n    }\\n\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        while (memo.size() < n) {\\n            int[] cur = memo.get(memo.size() - 1);\\n            int[] next = new int[10];\\n            for (int i = 0; i < 10; i++) {\\n                for (int d : map[i]) {\\n                    next[d] = (next[d] + cur[i]) % mod;\\n                }\\n            }\\n            memo.add(next);\\n        }\\n        int sum = 0;\\n        for (int x : memo.get(n - 1)) {\\n            sum = (sum + x) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static int mod = 1000_000_007;\\n    static int[][] map = new int[10][];\\n    static List<int[]> memo = new ArrayList<>();\\n    static {\\n        map[0] = new int[] {4, 6};\\n        map[1] = new int[] {6, 8};\\n        map[2] = new int[] {7, 9};\\n        map[3] = new int[] {4, 8};\\n        map[4] = new int[] {3, 9, 0};\\n        map[5] = new int[0];\\n        map[6] = new int[] {1, 7, 0};\\n        map[7] = new int[] {2, 6};\\n        map[8] = new int[] {1, 3};\\n        map[9] = new int[] {2, 4};\\n        memo.add(new int[] {1, 1, 1, 1, 1, 0, 1, 1, 1, 1});\\n    }\\n\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        while (memo.size() < n) {\\n            int[] cur = memo.get(memo.size() - 1);\\n            int[] next = new int[10];\\n            for (int i = 0; i < 10; i++) {\\n                for (int d : map[i]) {\\n                    next[d] = (next[d] + cur[i]) % mod;\\n                }\\n            }\\n            memo.add(next);\\n        }\\n        int sum = 0;\\n        for (int x : memo.get(n - 1)) {\\n            sum = (sum + x) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641780,
                "title": "c-o-n-time-o-1-space-0-ms-5-8-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) { \\n        // Edge case\\n        if( n == 1 ) {\\n            return 10;\\n        }\\n\\n        // Define all nodes(numbers) such a way:\\n        // Red nodes(4 and 6) derive three nodes in the next level\\n        // Each red node gives two green nodes and one zero\\n        long long redCount( 2 );\\n        // Green nodes(3, 9, 1, 7) derive red nodes in the next level\\n        // Each green node gives one red and one blue node\\n        long long greenCount( 4 );\\n        // Zero node(0) derives only TWO red nodes in the next level\\n        long long zeroCount( 1 );\\n        // Blue nodes(2 and 8) derive green nodes in the next level\\n        // Each blue node gives two green nodes\\n        long long blueCount( 2 );\\n\\n        // module\\n        constexpr int mod = 1000 * 1000 * 1000 + 7;\\n        \\n        // Calculate nodes count in each level from count in the previous level\\n        for( int i = 2; i <= n; i++ ) {\\n            long long newRedCount = zeroCount * 2 + greenCount;\\n            long long newGreenCount = redCount * 2 + blueCount * 2;\\n            long long newZeroCount = redCount;\\n            long long newBlueCount = greenCount;\\n\\n            // refresh values\\n            redCount = newRedCount % mod;\\n            greenCount = newGreenCount % mod;\\n            zeroCount = newZeroCount % mod;\\n            blueCount = newBlueCount % mod;\\n        }\\n\\n        // Calculate phone numbers count        \\n        long long allNumbersCount = redCount + greenCount + zeroCount + blueCount;\\n        return allNumbersCount % mod;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int knightDialer(int n) { \\n        // Edge case\\n        if( n == 1 ) {\\n            return 10;\\n        }\\n\\n        // Define all nodes(numbers) such a way:\\n        // Red nodes(4 and 6) derive three nodes in the next level\\n        // Each red node gives two green nodes and one zero\\n        long long redCount( 2 );\\n        // Green nodes(3, 9, 1, 7) derive red nodes in the next level\\n        // Each green node gives one red and one blue node\\n        long long greenCount( 4 );\\n        // Zero node(0) derives only TWO red nodes in the next level\\n        long long zeroCount( 1 );\\n        // Blue nodes(2 and 8) derive green nodes in the next level\\n        // Each blue node gives two green nodes\\n        long long blueCount( 2 );\\n\\n        // module\\n        constexpr int mod = 1000 * 1000 * 1000 + 7;\\n        \\n        // Calculate nodes count in each level from count in the previous level\\n        for( int i = 2; i <= n; i++ ) {\\n            long long newRedCount = zeroCount * 2 + greenCount;\\n            long long newGreenCount = redCount * 2 + blueCount * 2;\\n            long long newZeroCount = redCount;\\n            long long newBlueCount = greenCount;\\n\\n            // refresh values\\n            redCount = newRedCount % mod;\\n            greenCount = newGreenCount % mod;\\n            zeroCount = newZeroCount % mod;\\n            blueCount = newBlueCount % mod;\\n        }\\n\\n        // Calculate phone numbers count        \\n        long long allNumbersCount = redCount + greenCount + zeroCount + blueCount;\\n        return allNumbersCount % mod;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1612327,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    long mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        Map<Integer, int[]> moves = new HashMap<>();\\n        moves.put(0, new int[]{4, 6});\\n        moves.put(1, new int[]{6, 8});\\n        moves.put(2, new int[]{7, 9});\\n        moves.put(3, new int[]{4, 8});\\n        moves.put(4, new int[]{0, 3, 9});\\n        moves.put(5, new int[]{});\\n        moves.put(6, new int[]{0, 1, 7});\\n        moves.put(7, new int[]{2, 6});\\n        moves.put(8, new int[]{1, 3});\\n        moves.put(9, new int[]{2, 4});\\n        \\n        long[][] dp = new long[10][n + 1];\\n        for (int i = 0; i < 10; i++) \\n            Arrays.fill(dp[i], -1);\\n        \\n        long res = 0;\\n        for (int i = 0; i < 10; i++) \\n            res += knightDialerHelper(i, 1, n, moves, dp);\\n        return (int) (res % mod);\\n    }\\n    \\n    public long knightDialerHelper(int step, int level, int targetLevel, Map<Integer, int[]> moves, long[][] dp) {\\n        if (level == targetLevel) return 1;\\n        if (dp[step][level] != -1) return dp[step][level];\\n        \\n        long res = 0;\\n        for (int neighbors : moves.get(step)) \\n            res += knightDialerHelper(neighbors, level + 1, targetLevel, moves, dp) % mod;\\n        \\n        dp[step][level] = res;\\n        return dp[step][level];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    long mod = 1_000_000_007;\\n    public int knightDialer(int n) {\\n        if (n == 1) return 10;\\n        Map<Integer, int[]> moves = new HashMap<>();\\n        moves.put(0, new int[]{4, 6}",
                "codeTag": "Java"
            },
            {
                "id": 1591091,
                "title": "clean-dp-c-11-solution",
                "content": "```\\nclass Solution {\\n    \\n    public:\\n    int knightDialer(int n) {        \\n        unordered_map<int,vector<int>> movesMap; // num to {num,...,num}\\n        movesMap[0] = {4,6};\\n        movesMap[1] = {8,6};\\n        movesMap[2] = {7,9};\\n        movesMap[3] = {4,8};\\n        movesMap[4] = {0,3,9};\\n        movesMap[5] = {};\\n        movesMap[6] = {0,1,7};\\n        movesMap[7] = {2,6};\\n        movesMap[8] = {1,3};\\n        movesMap[9] = {2,4};\\n\\n        vector<int> dp(10,1); \\n\\n        const int modVal = 1000000007;\\n        auto safeAdd = [=](int a, int b) {return (a+b)%modVal;}; // why the fuck can\\'t i make this cleaner\\n        \\n        for (int j = 2; j <= n; j++) { \\n            vector<int> thisCol(10,0); \\n            \\n            for (int i = 0; i <= 9; i++)\\n                for (auto move : movesMap[i])\\n                    thisCol[i] = safeAdd(thisCol[i], dp[move]); // Aggregate dp values for j-1 \\n                \\n            std::swap(dp,thisCol); \\n        }\\n        \\n        return std::accumulate(dp.begin(), dp.end(),0, safeAdd); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public:\\n    int knightDialer(int n) {        \\n        unordered_map<int,vector<int>> movesMap; // num to {num,...,num}\\n        movesMap[0] = {4,6};\\n        movesMap[1] = {8,6};\\n        movesMap[2] = {7,9};\\n        movesMap[3] = {4,8};\\n        movesMap[4] = {0,3,9};\\n        movesMap[5] = {};\\n        movesMap[6] = {0,1,7};\\n        movesMap[7] = {2,6};\\n        movesMap[8] = {1,3};\\n        movesMap[9] = {2,4};\\n\\n        vector<int> dp(10,1); \\n\\n        const int modVal = 1000000007;\\n        auto safeAdd = [=](int a, int b) {return (a+b)%modVal;}; // why the fuck can\\'t i make this cleaner\\n        \\n        for (int j = 2; j <= n; j++) { \\n            vector<int> thisCol(10,0); \\n            \\n            for (int i = 0; i <= 9; i++)\\n                for (auto move : movesMap[i])\\n                    thisCol[i] = safeAdd(thisCol[i], dp[move]); // Aggregate dp values for j-1 \\n                \\n            std::swap(dp,thisCol); \\n        }\\n        \\n        return std::accumulate(dp.begin(), dp.end(),0, safeAdd); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589287,
                "title": "easy-c-dfs-memo-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> offsets={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\\n    int knightDialer(int n) {\\n        int rows=4;\\n        int cols=3;\\n        \\n        //use a dp to memoize the number of possible combinations on every stirng\\n        vector<vector<vector<long>>> dp(rows,vector<vector<long>>(cols,vector<long>(n+1,-1)));\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=solve(i,j,rows,cols,n-1,dp);\\n                res%=1000000007;\\n            }\\n        }\\n        \\n        //for the last 0 cell\\n        res+=solve(3,1,rows,cols,n-1,dp);\\n        return (int)res%1000000007;\\n    }\\n    long solve(int i,int j,int& rows,int& cols,int n,vector<vector<vector<long>>>& dp)\\n    {\\n        if(n<=0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j][n]!=-1)\\n            return dp[i][j][n];\\n        long ans=0;\\n        //try all possible 8 directions\\n        for(int k=0;k<8;k++)\\n        {\\n            int x=i+offsets[k][0];\\n            int y=j+offsets[k][1];\\n            if(x<0 || y<0 || x>=rows || y>=cols || (x==3 && y==0) || (x==3 && y==2))\\n                continue;\\n            ans+=solve(x,y,rows,cols,n-1,dp);\\n        }\\n        return dp[i][j][n]=ans%1000000007;\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> offsets={{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};\\n    int knightDialer(int n) {\\n        int rows=4;\\n        int cols=3;\\n        \\n        //use a dp to memoize the number of possible combinations on every stirng\\n        vector<vector<vector<long>>> dp(rows,vector<vector<long>>(cols,vector<long>(n+1,-1)));\\n        \\n        int res=0;\\n        \\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                res+=solve(i,j,rows,cols,n-1,dp);\\n                res%=1000000007;\\n            }\\n        }\\n        \\n        //for the last 0 cell\\n        res+=solve(3,1,rows,cols,n-1,dp);\\n        return (int)res%1000000007;\\n    }\\n    long solve(int i,int j,int& rows,int& cols,int n,vector<vector<vector<long>>>& dp)\\n    {\\n        if(n<=0)\\n        {\\n            return 1;\\n        }\\n        if(dp[i][j][n]!=-1)\\n            return dp[i][j][n];\\n        long ans=0;\\n        //try all possible 8 directions\\n        for(int k=0;k<8;k++)\\n        {\\n            int x=i+offsets[k][0];\\n            int y=j+offsets[k][1];\\n            if(x<0 || y<0 || x>=rows || y>=cols || (x==3 && y==0) || (x==3 && y==2))\\n                continue;\\n            ans+=solve(x,y,rows,cols,n-1,dp);\\n        }\\n        return dp[i][j][n]=ans%1000000007;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535517,
                "title": "python-recursion-memo",
                "content": "```\\nclass Solution:\\n    \\n    knight_motion = [(-1,2), (1,2), (2,1), (2,-1), (1,-2),(-1,-2),(-2,-1),(-2,1)]\\n    \\n    map = [[1,2,3],[4,5,6],[7,8,9],[-1, 0, -1]]\\n    const = int(pow(10,9))\\n    \\n    \\n    dp = {}\\n    \\n    def isvalid(self,row : int, col : int): \\n        return row < len(self.map) and col < len(self.map[0]) and col >= 0 and row >= 0 and self.map[row][col] >= 0\\n    \\n    def modulo(self, num : int) -> int: \\n        return num % (self.const + 7)\\n        \\n    def recurse(self, n : int, i : int, j : int) -> int: \\n        if n == 1: \\n            return 1 \\n        \\n        count = 0 \\n        \\n        if (i,j,n) in self.dp: \\n            return self.dp[(i,j,n)]\\n        \\n        for (row,col) in self.knight_motion: \\n            newrow = i + row \\n            newcol = j + col \\n\\n            if self.isvalid(newrow, newcol): \\n                count += self.modulo(self.recurse(n-1, newrow, newcol))\\n        \\n        self.dp[(i,j,n)] = self.modulo(count)\\n        \\n        return self.dp[(i,j,n)]\\n        \\n    \\n    def knightDialer(self, n: int) -> int:\\n        count = 0 \\n        \\n        for i in range(len(self.map)): \\n            for j in range(len(self.map[0])): \\n                \\n                if self.map[i][j] >= 0: \\n                    count+= self.recurse(n, i,j)\\n                    count = self.modulo(count)\\n        \\n        return count\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    knight_motion = [(-1,2), (1,2), (2,1), (2,-1), (1,-2),(-1,-2),(-2,-1),(-2,1)]\\n    \\n    map = [[1,2,3],[4,5,6],[7,8,9],[-1, 0, -1]]\\n    const = int(pow(10,9))\\n    \\n    \\n    dp = {}\\n    \\n    def isvalid(self,row : int, col : int): \\n        return row < len(self.map) and col < len(self.map[0]) and col >= 0 and row >= 0 and self.map[row][col] >= 0\\n    \\n    def modulo(self, num : int) -> int: \\n        return num % (self.const + 7)\\n        \\n    def recurse(self, n : int, i : int, j : int) -> int: \\n        if n == 1: \\n            return 1 \\n        \\n        count = 0 \\n        \\n        if (i,j,n) in self.dp: \\n            return self.dp[(i,j,n)]\\n        \\n        for (row,col) in self.knight_motion: \\n            newrow = i + row \\n            newcol = j + col \\n\\n            if self.isvalid(newrow, newcol): \\n                count += self.modulo(self.recurse(n-1, newrow, newcol))\\n        \\n        self.dp[(i,j,n)] = self.modulo(count)\\n        \\n        return self.dp[(i,j,n)]\\n        \\n    \\n    def knightDialer(self, n: int) -> int:\\n        count = 0 \\n        \\n        for i in range(len(self.map)): \\n            for j in range(len(self.map[0])): \\n                \\n                if self.map[i][j] >= 0: \\n                    count+= self.recurse(n, i,j)\\n                    count = self.modulo(count)\\n        \\n        return count\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511068,
                "title": "python-super-simple-bottom-up-dp",
                "content": "```\\nNumberToJumps = {\\n    1 : [8, 6],\\n    2: [7, 9],\\n    3: [4, 8],\\n    4: [3, 9, 0],\\n    5: [],\\n    6: [1, 7, 0],\\n    7: [2, 6],\\n    8: [1, 3],\\n    9: [4, 2],\\n    0: [4, 6],\\n}\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n        numberToNumPathsOfCurrentPathLength = [1]*10\\n        currentPathLength = 1\\n        while currentPathLength < n:\\n            numberToNumPathsOfNextPathLength = [0]*10\\n            \\n            for telephoneNumber in range(10):\\n                for numberToJumpTo in NumberToJumps[telephoneNumber]:\\n                    numberToNumPathsOfNextPathLength[telephoneNumber] += numberToNumPathsOfCurrentPathLength[numberToJumpTo]\\n            \\n            currentPathLength += 1\\n            numberToNumPathsOfCurrentPathLength = numberToNumPathsOfNextPathLength\\n        \\n        return sum(numberToNumPathsOfCurrentPathLength) % (pow(10, 9) + 7)",
                "solutionTags": [],
                "code": "```\\nNumberToJumps = {\\n    1 : [8, 6],\\n    2: [7, 9],\\n    3: [4, 8],\\n    4: [3, 9, 0],\\n    5: [],\\n    6: [1, 7, 0],\\n    7: [2, 6],\\n    8: [1, 3],\\n    9: [4, 2],\\n    0: [4, 6],\\n}\\n\\nclass Solution:\\n    def knightDialer(self, n: int) -> int:\\n        if n == 1:\\n            return 10\\n        \\n        numberToNumPathsOfCurrentPathLength = [1]*10\\n        currentPathLength = 1\\n        while currentPathLength < n:\\n            numberToNumPathsOfNextPathLength = [0]*10\\n            \\n            for telephoneNumber in range(10):\\n                for numberToJumpTo in NumberToJumps[telephoneNumber]:\\n                    numberToNumPathsOfNextPathLength[telephoneNumber] += numberToNumPathsOfCurrentPathLength[numberToJumpTo]\\n            \\n            currentPathLength += 1\\n            numberToNumPathsOfCurrentPathLength = numberToNumPathsOfNextPathLength\\n        \\n        return sum(numberToNumPathsOfCurrentPathLength) % (pow(10, 9) + 7)",
                "codeTag": "Java"
            },
            {
                "id": 1455243,
                "title": "dp-on-the-possible-paths-of-knight-c",
                "content": "```\\nclass Solution {\\npublic: int md=1e9+7;\\n    int knightDialer(int n) {\\n        unordered_map<int,vector<int>>mp;\\n        mp[0]={4,6};\\n        mp[1]={6,8};\\n        mp[2]={7,9};\\n        mp[3]={4,8};\\n        mp[4]={0,3,9};\\n        mp[5]={};\\n        mp[6]={0,1,7};\\n        mp[7]={2,6};\\n        mp[8]={1,3};\\n        mp[9]={2,4};\\n        vector<vector<int>>dp(n+1,vector<int>(10));\\n        for(int i=0;i<10;i++)dp[1][i]=1;\\n        for(int i=2;i<=n;i++)\\n            for(int j=0;j<10;j++)\\n                for(auto &n:mp[j])\\n                    dp[i][j]=(dp[i][j]+dp[i-1][n])%md;\\n        for(int j=0;j<9;j++)\\n            dp[n][9]=(dp[n][9]+dp[n][j])%md;\\n        return dp[n][9];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic: int md=1e9+7;\\n    int knightDialer(int n) {\\n        unordered_map<int,vector<int>>mp;\\n        mp[0]={4,6};\\n        mp[1]={6,8};\\n        mp[2]={7,9};\\n        mp[3]={4,8};\\n        mp[4]={0,3,9};\\n        mp[5]={};\\n        mp[6]={0,1,7};\\n        mp[7]={2,6};\\n        mp[8]={1,3};\\n        mp[9]={2,4};\\n        vector<vector<int>>dp(n+1,vector<int>(10));\\n        for(int i=0;i<10;i++)dp[1][i]=1;\\n        for(int i=2;i<=n;i++)\\n            for(int j=0;j<10;j++)\\n                for(auto &n:mp[j])\\n                    dp[i][j]=(dp[i][j]+dp[i-1][n])%md;\\n        for(int j=0;j<9;j++)\\n            dp[n][9]=(dp[n][9]+dp[n][j])%md;\\n        return dp[n][9];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431522,
                "title": "python-o-n-dp-and-thinking-process",
                "content": "We could start from a naive brutal force recursive solution as follows. Just iterate each possible next positions on the dial board.\\n\\n```\\n        board = [\\n            [1,2,3],\\n            [4,5,6],\\n            [7,8,9],\\n            [-1, 0, -1]\\n        ]\\n        \\n        r_lim = len(board)\\n        c_lim = len(board[0])\\n        \\n        offset_list = [\\n            [-1, -2],\\n            [-2, -1],\\n            [-2, 1],\\n            [-1, 2],\\n            [1, -2],\\n            [2, -1],\\n            [2, 1],\\n            [1, 2]     \\n        ]\\n        \\n        mod = 10**9+7\\n        \\n        def recur_f(c_r, c_c, c_steps):\\n            \\n            if(c_steps == n):\\n                return 1\\n            \\n            result = 0\\n            for offset in offset_list:\\n                n_r = c_r + offset[0]\\n                n_c = c_c + offset[1]\\n                \\n                if(0 <= n_r < r_lim \\n                    and \\n                   0 <= n_c < c_lim\\n                    and\\n                   board[n_r][n_c] != -1\\n                  ):\\n                    result+=recur_f(n_r, n_c, c_steps+1)\\n            \\n            return result%mod\\n        \\n        final_result = 0\\n        for r in range(0, r_lim):\\n            for c in range(0, c_lim):\\n                if(board[r][c] != -1):\\n                    final_result += recur_f(r, c, 1)\\n\\n        return final_result%mod\\n```\\n\\nSo we found the key is actually compute the **number of next position**, which is the **current end digit of the dial string**. And since the dial board is a small and fixed one, we could store all possible next positions given the current position. And keep updating number of strings with each ending digits.\\n\\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = (2, [6,8])\\n        pos_n_move_dict[2] = (2, [7,9])\\n        pos_n_move_dict[3] = (2, [4,8])\\n        pos_n_move_dict[4] = (3, [3,9,0])\\n        pos_n_move_dict[5] = (0, [])\\n        pos_n_move_dict[6] = (3, [1,7,0])\\n        pos_n_move_dict[7] = (2, [2,6])\\n        pos_n_move_dict[8] = (2, [1,3])\\n        pos_n_move_dict[9] = (2, [2,4])\\n        pos_n_move_dict[0] = (2, [4,6])\\n        \\n        c_pos_dict = {}\\n        for i in range(0, 10):\\n            c_pos_dict[i] = 1\\n        \\n        dp_list = [-1]*(n+1)\\n        \\n        dp_list[1] = 10\\n        \\n        for i in range(2, n+1):\\n            \\n            c_cnt = 0\\n            for pos, pos_cnt in c_pos_dict.items():\\n                c_cnt+= pos_cnt*pos_n_move_dict[pos][0]\\n            \\n            new_pos_dict = {}\\n            for pos, pos_cnt in c_pos_dict.items():\\n                n_pos_list = pos_n_move_dict[pos][1]\\n                \\n                for n_pos in n_pos_list:\\n                    if(n_pos in new_pos_dict):\\n                        new_pos_dict[n_pos]+=pos_cnt\\n                    else:\\n                        new_pos_dict[n_pos]=pos_cnt\\n                        \\n            c_pos_dict = new_pos_dict\\n            \\n            dp_list[i] = c_cnt%mod\\n        \\n        return dp_list[n]%mod\\n```\\n\\nAnd the final version is using a two-dim dp_array. The first dimension is the current step. And the second dimension is the **numbers of string with that ending digit**.\\n\\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = [6,8]\\n        pos_n_move_dict[2] = [7,9]\\n        pos_n_move_dict[3] = [4,8]\\n        pos_n_move_dict[4] = [3,9,0]\\n        pos_n_move_dict[5] = []\\n        pos_n_move_dict[6] = [1,7,0]\\n        pos_n_move_dict[7] = [2,6]\\n        pos_n_move_dict[8] = [1,3]\\n        pos_n_move_dict[9] = [2,4]\\n        pos_n_move_dict[0] = [4,6]\\n    \\n        \\n        dp_array = []\\n        for i in range(0, n+1):\\n            dp_array.append([0]*10)\\n        \\n        for i in range(0, 10):\\n            dp_array[1][i]=1\\n        \\n        for step in range(2, n+1):\\n            \\n            c_list = [0]*10\\n        \\n            for end_digit in range(0, 10):\\n                for next_end_digit in pos_n_move_dict[end_digit]:\\n                    dp_array[step][next_end_digit]+=dp_array[step-1][end_digit]\\n        \\n        result = 0\\n        for i in range(0, 10):\\n            result += dp_array[n][i]\\n            result = result%mod\\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n        board = [\\n            [1,2,3],\\n            [4,5,6],\\n            [7,8,9],\\n            [-1, 0, -1]\\n        ]\\n        \\n        r_lim = len(board)\\n        c_lim = len(board[0])\\n        \\n        offset_list = [\\n            [-1, -2],\\n            [-2, -1],\\n            [-2, 1],\\n            [-1, 2],\\n            [1, -2],\\n            [2, -1],\\n            [2, 1],\\n            [1, 2]     \\n        ]\\n        \\n        mod = 10**9+7\\n        \\n        def recur_f(c_r, c_c, c_steps):\\n            \\n            if(c_steps == n):\\n                return 1\\n            \\n            result = 0\\n            for offset in offset_list:\\n                n_r = c_r + offset[0]\\n                n_c = c_c + offset[1]\\n                \\n                if(0 <= n_r < r_lim \\n                    and \\n                   0 <= n_c < c_lim\\n                    and\\n                   board[n_r][n_c] != -1\\n                  ):\\n                    result+=recur_f(n_r, n_c, c_steps+1)\\n            \\n            return result%mod\\n        \\n        final_result = 0\\n        for r in range(0, r_lim):\\n            for c in range(0, c_lim):\\n                if(board[r][c] != -1):\\n                    final_result += recur_f(r, c, 1)\\n\\n        return final_result%mod\\n```\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = (2, [6,8])\\n        pos_n_move_dict[2] = (2, [7,9])\\n        pos_n_move_dict[3] = (2, [4,8])\\n        pos_n_move_dict[4] = (3, [3,9,0])\\n        pos_n_move_dict[5] = (0, [])\\n        pos_n_move_dict[6] = (3, [1,7,0])\\n        pos_n_move_dict[7] = (2, [2,6])\\n        pos_n_move_dict[8] = (2, [1,3])\\n        pos_n_move_dict[9] = (2, [2,4])\\n        pos_n_move_dict[0] = (2, [4,6])\\n        \\n        c_pos_dict = {}\\n        for i in range(0, 10):\\n            c_pos_dict[i] = 1\\n        \\n        dp_list = [-1]*(n+1)\\n        \\n        dp_list[1] = 10\\n        \\n        for i in range(2, n+1):\\n            \\n            c_cnt = 0\\n            for pos, pos_cnt in c_pos_dict.items():\\n                c_cnt+= pos_cnt*pos_n_move_dict[pos][0]\\n            \\n            new_pos_dict = {}\\n            for pos, pos_cnt in c_pos_dict.items():\\n                n_pos_list = pos_n_move_dict[pos][1]\\n                \\n                for n_pos in n_pos_list:\\n                    if(n_pos in new_pos_dict):\\n                        new_pos_dict[n_pos]+=pos_cnt\\n                    else:\\n                        new_pos_dict[n_pos]=pos_cnt\\n                        \\n            c_pos_dict = new_pos_dict\\n            \\n            dp_list[i] = c_cnt%mod\\n        \\n        return dp_list[n]%mod\\n```\n```\\n        mod = 10**9+7\\n        \\n        pos_n_move_dict = {}\\n        pos_n_move_dict[1] = [6,8]\\n        pos_n_move_dict[2] = [7,9]\\n        pos_n_move_dict[3] = [4,8]\\n        pos_n_move_dict[4] = [3,9,0]\\n        pos_n_move_dict[5] = []\\n        pos_n_move_dict[6] = [1,7,0]\\n        pos_n_move_dict[7] = [2,6]\\n        pos_n_move_dict[8] = [1,3]\\n        pos_n_move_dict[9] = [2,4]\\n        pos_n_move_dict[0] = [4,6]\\n    \\n        \\n        dp_array = []\\n        for i in range(0, n+1):\\n            dp_array.append([0]*10)\\n        \\n        for i in range(0, 10):\\n            dp_array[1][i]=1\\n        \\n        for step in range(2, n+1):\\n            \\n            c_list = [0]*10\\n        \\n            for end_digit in range(0, 10):\\n                for next_end_digit in pos_n_move_dict[end_digit]:\\n                    dp_array[step][next_end_digit]+=dp_array[step-1][end_digit]\\n        \\n        result = 0\\n        for i in range(0, 10):\\n            result += dp_array[n][i]\\n            result = result%mod\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1422012,
                "title": "c-dp-98",
                "content": "public class Solution {\\n  \\n    long mod = 1000*1000*1000+7;\\n    \\n   \\n           \\n    public int KnightDialer(int n) {\\n        \\n         \\n        long[,] dp = new long[10,n+1];\\n        \\n        for(int i=0;i<10;i++)\\n        {\\n            dp[i,1] = 1;\\n        }\\n        \\n        for(int steps=2;steps<=n;steps++)\\n        {\\n            dp[0,steps] = (dp[4,steps-1] + dp[6,steps-1]) % mod;\\n            dp[1,steps] = (dp[6,steps-1] + dp[8,steps-1]) % mod;\\n            dp[2,steps] = (dp[7,steps-1] + dp[9,steps-1]) % mod;\\n            dp[3,steps] = (dp[4,steps-1] + dp[8,steps-1]) % mod;\\n            dp[4,steps] = (dp[0,steps-1] + dp[3,steps-1] + dp[9,steps-1]) % mod ;\\n            dp[6,steps] = (dp[1,steps-1] + dp[7,steps-1] + dp[0,steps-1]) % mod;\\n            dp[7,steps] = (dp[2,steps-1] + dp[6,steps-1]) % mod;\\n            dp[8,steps] = (dp[1,steps-1] + dp[3,steps-1]) % mod;\\n            dp[9,steps] = (dp[4,steps-1] + dp[2,steps-1]) % mod;\\n        }\\n        \\n        long total = 0;\\n        for(int i=0;i<10;i++)\\n        {\\n              total += dp[i,n] % mod;\\n        }\\n          \\n        return (int)(total % mod);\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n  \\n    long mod = 1000*1000*1000+7;\\n    \\n   \\n           \\n    public int KnightDialer(int n) {\\n        \\n         \\n        long[,] dp = new long[10,n+1];\\n        \\n        for(int i=0;i<10;i++)\\n        {\\n            dp[i,1] = 1;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566349,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568198,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566837,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572988,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1979888,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873741,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576739,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1967464,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1966818,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1860704,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566349,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1568198,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1566837,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572988,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1979888,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873741,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1576739,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1967464,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1966818,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1860704,
                "content": [
                    {
                        "username": "fohreal",
                        "content": "Can any one please elaborate the question and test cases ? \\n\\nwhat the starting position of the knight ?\\n\\nif N =1 which key is the starting point ?  0 or 1 if its 0 how it can take 1 hopp and ans is 6 +4 because knight can take only N-1 hoop. \\n\\nI am super frustrated even after reading all this answer not able to understand this question."
                    },
                    {
                        "username": "sanghota4567",
                        "content": "I went through the initial 5 mins of this, I got an idea, what the question ask. Please check this if its helpful : https://www.youtube.com/watch?v=wRF40TQUpxg"
                    },
                    {
                        "username": "JonPotato",
                        "content": "The question asks you to count the permutations from each starting point. So, all the numbers starting from 0 + all the numbers starting from 1 + ... all the numbers starting from 9"
                    },
                    {
                        "username": "2nnet2",
                        "content": "Tell me I if I get this wrong. \\nHere is the list of numbers you start at and the ones you can job to from that starting postion\\n\\nStarting key : keys you can job to.\\n\\n1: 6, 8\\n2: 4,7\\n3: 4,8\\n4: 3,9,0\\n5: Cannot move\\n6: 1,7,0\\n7:2,6\\n8:3,1\\n9:2,4\\n0:6,4\\n\\nSo if you start at 5, you can at most get 1 unique number since the position you start counts as one and you cannot make any valid moves from or to 5.\\n\\nNow for N=2, the example says 20. \\nI count 21 from the above. Do you could 5 as makeing zero numbers becasue it cannot move? That would contradict the example where N=1 and the result is 10.\\n"
                    },
                    {
                        "username": "wise",
                        "content": "it is easy to understand for input is 1, the answer is 10\\nfor input is 2, we start from any key, each key will have two next choices, except:\\n1. 5 has no next choice\\n2. 4 and 6 have 3 next choices\\n\\nso the total answer will be 10 x 2 - 1 + 2 = 21? can anyone help me understand why the answer is 20?\\n\\nThanks!"
                    },
                    {
                        "username": "the_kalakar",
                        "content": "[@yimengael](/yimengael) In the end, both paths 4->1->2->3, 4->5->6->3 end up in number 43, hence it is treated the same."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "It should have been (10-1)*2 + 2 = 20. It is because nothing can be formed by 5 and 1 extra can be formed from 4 and 6."
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9`, `4->5->6->9`, `4->5->6->3` Please correct me if I\\'m wrong. Just trying to understand.\\nSame reasoning for 6."
                    },
                    {
                        "username": "papera",
                        "content": "you should have done (10-1)*2  + 2  = 21"
                    },
                    {
                        "username": "zachOneMoreTime",
                        "content": "Can anyone help me undestand why we need to modulo here? And why the number is 10 ^ 9 + 7?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Modulo is needed because the numbers overflow normal integer ranges. 10 ^ 9 + 7 is arbitrary but has nice properties: it fits nicely into the max integer, so that the remainder doesn\\'t overflow. It\\'s also prime, meaning that incorrect answers won\\'t equal the same thing as correct ones when this modulus is taken"
                    },
                    {
                        "username": "shivi127",
                        "content": "I made a video explanation https://www.youtube.com/watch?v=6BdxzqhivOM"
                    },
                    {
                        "username": "Aditya_Dixit94",
                        "content": "for optimising use - 3d-dp"
                    },
                    {
                        "username": "rev0let",
                        "content": "For example, for n=2, \"40\" is not a valid answer because a knight at position 4 cannot reach 0 with the specified movement rules. (however, 0 -> 4  is valid)"
                    },
                    {
                        "username": "yimengael",
                        "content": "It seems like 4 has 4 next choices:\\n`4->1->2->3`, `4->7->8->9,` `4->5->6->9`, `4->5->6->3`. Please correct me if I\\'m wrong. Just trying to understand.Same reasoning for 6."
                    },
                    {
                        "username": "aj1911",
                        "content": "## This code gives TLE even after memoisation. Whats going wrong?\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9 + 7;\\n    vector<vector<int>> dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2,1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\\n\\n    int solve(int i, int j, int k, vector<vector<vector<int>>> &dp){\\n        \\n        if(i < 0 || j < 0 || i >= 4 || j >= 3 || (i == 3 && j != 1)) return 0;\\n        if(k == 0) return 1;\\n        if(dp[i][j][k] > 0) return dp[i][j][k];\\n        int ans = 0;\\n        for(vector<int> d: dirs){\\n            int c = solve(i + d[0], j + d[1], k - 1, dp);\\n            ans = ((ans % mod) + (c % mod))% mod;\\n        }\\n\\n        return dp[i][j][k] = ans;\\n    }\\n    int knightDialer(int n) {\\n        vector<vector<vector<int>>> dp(4, vector<vector<int>>(4, vector<int>(n+1, -1)));\\n        int ans = solve(3, 1, n-1, dp) % mod;\\n        for(int i = 0; i < 3; i++){\\n            for(int j = 0; j < 3; j++){\\n                int c = solve(i, j, n - 1, dp);\\n                ans = ((ans % mod) + (c % mod)) % mod;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "anshh10",
                        "content": "I need some help, when in the solution are we supposed to mod the results?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the maximum value of integer in cpp or another lang can be long long int (2 ^ 64) which is  (18,446,744,073,709,551,616) \\nhere in this question it might be possible that Ans can be greater value than this so we modulo it by 10e9+7  which is (10000000007) which make the result smaller  so that answer can fit in the memory  "
                    },
                    {
                        "username": "ankush920",
                        "content": "\\nMemorization||recursion || 94ms|| Easy\\nankush920\\n-1\\nin a few seconds\\nIntuition\\ncheck for all possbility and store answer for valid possibilty\\n\\nApproach\\nMemorization\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\nclass Solution {\\npublic:\\n int nums [4][3];\\n  int mod =1e9+7;\\n\\n int dp [11][5001] ={-1};\\n    int dailer (int n ,int i ,int j , int &count )\\n      {\\n\\n        \\n           if( i >3 ||j >2||i<0||j<0|| nums[i][j]==-1)\\n           {\\n                return 0 ;\\n           }\\n\\n           if( n==1)\\n       { \\n         return 1;\\n       }\\n \\n   int  number =nums[i][j];\\n\\n        if( dp[number][n]!=-1)\\n        {\\n           return dp[number][n];\\n        }\\n      \\n      long long val1 = dailer(n-1 ,i-2 , j-1 , count);  ///up\\n      \\n     long long val2 =    dailer(n-1 ,i-2 , j+1 , count);\\n      \\n      long long val3 =   dailer(n-1 ,i-1 , j-2 , count);   //left\\n      \\n      long long val4 =   dailer(n-1 ,i+1 , j-2 , count);\\n      \\n        long long val5 = dailer(n-1 ,i+2, j-1 , count);  //down\\n      \\n       long long val6=  dailer(n-1 ,i+2, j+1 , count);\\n      \\n      long long val7 = dailer(n-1 ,i-1, j+2, count);  //right\\n      \\n     long long val8=  dailer(n-1 ,i+1, j+2, count);\\n      \\n    \\n  \\n      long long ans = val1 +val2 +val3 + val4 + val5 + val6 + val7 +val8; \\n     \\n      ans =( (ans) %mod)%mod;\\n\\n      dp[number][n]= ans;\\n      return  dp[number][n] ;\\n      }\\n\\n\\n\\n    int knightDialer(int n) {\\n      \\n       //// intializing the 2-D matrix of keypad  \\n         int var = 1;\\n        for(int i =0 ;i<3;i++)\\n        {\\n             for( int j= 0 ; j<3 ;j++)\\n             {\\n                  nums[i][j]=var ;\\n                  var++;\\n             }\\n        }\\n\\n        nums[3][1]=0;\\n        nums[3][0]=-1;\\n        nums[3][2]=-1;\\n        \\n        memset( dp ,-1 ,sizeof( dp));\\n        //// use for storing count \\n      int count =0;\\n        \\n\\n        //// Doing call for each number \\n        for(int i=0 ;i<4;i++)\\n        {\\n            for( int j=0; j<3;j++)\\n            {\\n                if( nums[i][j]==-1)\\n                {\\n                    continue ;\\n                }\\n      \\n              int val =(dailer( n, i, j ,count))%mod;\\n              count =count+val;\\n              count= count%mod;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Longest Substring Containing Vowels in Even Counts",
        "question_content": "<p>Given the string <code>s</code>, return the size of the longest substring containing each vowel an even number of times. That is, &#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, and &#39;u&#39; must appear an even number of times.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;eleetminicoworoep&quot;\n<strong>Output:</strong> 13\n<strong>Explanation: </strong>The longest substring is &quot;leetminicowor&quot; which contains two each of the vowels: <strong>e</strong>, <strong>i</strong> and <strong>o</strong> and zero of the vowels: <strong>a</strong> and <strong>u</strong>.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcodeisgreat&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The longest substring is &quot;leetc&quot; which contains two e&#39;s.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bcbcbc&quot;\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> In this case, the given string &quot;bcbcbc&quot; is the longest because all vowels: <strong>a</strong>, <strong>e</strong>, <strong>i</strong>, <strong>o</strong> and <strong>u</strong> appear zero times.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li>\n\t<li><code>s</code>&nbsp;contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 531840,
                "title": "java-c-python-one-pass",
                "content": "# Explanation\\n`cur` records the count of \"aeiou\"\\n`cur & 1` = the records of `a` % 2\\n`cur & 2` = the records of `e` % 2\\n`cur & 4` = the records of `i` % 2\\n`cur & 8` = the records of `o` % 2\\n`cur & 16` = the records of `u` % 2\\n`seen` note the index of first occurrence of `cur`\\n\\n\\nNote that we don\\'t really need the exact count number,\\nwe only need to know if it\\'s odd or even.\\n\\nIf it\\'s one of `aeiou`,\\n`\\'aeiou\\'.find(c)` can find the index of vowel,\\n`cur ^= 1 << \\'aeiou\\'.find(c)` will toggle the count of vowel.\\n\\nBut for no vowel characters,\\n`\\'aeiou\\'.find(c)` will return -1,\\nthat\\'s reason that we do `1 << (\\'aeiou\\'.find(c) + 1) >> 1`.\\n\\nHope this explain enough.\\n\\n# Complexity\\nTime `O(N)`, Space `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0 , cur = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1 ) >> 1;\\n            seen.putIfAbsent(cur, i);\\n            res = Math.max(res, i - seen.get(cur));\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\nby @chenkkkabc\\n```cpp\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m{{0, -1}};\\n        int res = 0, n = s.length(), cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            cur ^= 1 << string(\"aeiou\").find(s[i]) + 1 >> 1;\\n            if (!m.count(cur)) m[cur] = i;\\n            res = max(res, i - m[cur]);\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def findTheLongestSubstring(self, s):\\n        seen = {0: -1}\\n        res = cur = 0\\n        for i, c in enumerate(s):\\n            cur ^= 1 << (\\'aeiou\\'.find(c) + 1) >> 1\\n            seen.setdefault(cur, i)\\n            res = max(res, i - seen[cur])\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0 , cur = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            cur ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1 ) >> 1;\\n            seen.putIfAbsent(cur, i);\\n            res = Math.max(res, i - seen.get(cur));\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m{{0, -1}};\\n        int res = 0, n = s.length(), cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            cur ^= 1 << string(\"aeiou\").find(s[i]) + 1 >> 1;\\n            if (!m.count(cur)) m[cur] = i;\\n            res = max(res, i - m[cur]);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def findTheLongestSubstring(self, s):\\n        seen = {0: -1}\\n        res = cur = 0\\n        for i, c in enumerate(s):\\n            cur ^= 1 << (\\'aeiou\\'.find(c) + 1) >> 1\\n            seen.setdefault(cur, i)\\n            res = max(res, i - seen[cur])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534135,
                "title": "c-java-with-picture",
                "content": "#### Intuition\\nWe do not need to know the exact count, we just need a flag indicating whether a vowel is even or odd. So, we can track the status of each vowel using a bit mask. Since we only have 5 vowels in the English alphabet, we will have 32 possible combinations.\\n\\nNow, if our mask is zero, then our string contains only even vowels. Also, if a mask is the same for indexes `i` and `j`, the mask for substring `[i +1, j]` must be zero. Therefore, substring `[i +1, j]` also contains even vowels only.\\n\\n#### Algorithm\\nAs we go through our string, we update `mask`, and track the smallest index for each `mask` combination. If we encounter the same `mask` later in the string, that means the string between smallest (exclusive) and current (inclusive) index meets the problem criteria.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1584056896.png)\\n\\nIn other words, we need to find the maximum distance between the first and last index for each `mask` combination.\\n\\n> Note that for zero `mask` (all vowels\\' count is even), the first index is \\'-1\\' - so that we include the string from very beginning. \\n\\n**C++**\\nI am using arrays here (e.g. instead of hash maps) for the performance. With fast IO settings, the runtime of this C++ code is 16 ms.\\n\\n```cpp\\nstatic constexpr char c_m[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};    \\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    vector<int> m(32, -1);\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= c_m[s[i] - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\nchar[] c_m = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\npublic int findTheLongestSubstring(String s) {\\n    int mask = 0, res = 0;\\n    int[] m = new int[32];\\n    Arrays.fill(m, -1);\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= c_m[s.charAt(i) - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = Math.max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Complexity Analysis\\n- Time: O(n)\\n- Memory: O(2 ^ m), where m is the number of characters we need to track counts for.\\n  - 5 vowels needs 32 positions to track in this problem.",
                "solutionTags": [],
                "code": "```cpp\\nstatic constexpr char c_m[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};    \\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    vector<int> m(32, -1);\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= c_m[s[i] - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```\n```java\\nchar[] c_m = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\npublic int findTheLongestSubstring(String s) {\\n    int mask = 0, res = 0;\\n    int[] m = new int[32];\\n    Arrays.fill(m, -1);\\n    for (int i = 0; i < s.length(); ++i) {\\n        mask ^= c_m[s.charAt(i) - \\'a\\'];\\n        if (mask != 0 && m[mask] == -1)\\n            m[mask] = i;\\n        res = Math.max(res, i - m[mask]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 531850,
                "title": "python-solution-in-o-n-time-and-o-1-space-explained",
                "content": "We can use 5 bits to represent the parity of the number of occurrences of vowels. For example, we can use 0/1 for even/odd numbers, then if we have 4a, 3e, 2i, 1o, 0u, the representation would be 01010. As we scan through the array, we can update the representation in O(1) time by using the XOR operation, and then store the index where every different representation first appeared. When we encounter a representation, say 01010 again at index `j`, we can look back on the index `i` where 01010 first appeared, and we know that the substring from `i` to `j` must be a valid string, and it is the longest valid substring that ends at `j`.\\n```python\\ndef findTheLongestSubstring(self, s: str) -> int:\\n    vowels = {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n    d, n, r = {0: -1}, 0, 0\\n    for i, c in enumerate(s):\\n        if c in vowels:\\n            n ^= vowels[c]\\n        if n not in d:\\n            d[n] = i\\n        else:\\n            r = max(r, i - d[n])\\n    return r\\n```\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```python\\ndef findTheLongestSubstring(self, s: str) -> int:\\n    vowels = {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n    d, n, r = {0: -1}, 0, 0\\n    for i, c in enumerate(s):\\n        if c in vowels:\\n            n ^= vowels[c]\\n        if n not in d:\\n            d[n] = i\\n        else:\\n            r = max(r, i - d[n])\\n    return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534210,
                "title": "dew-it-simple-illustration-for-the-trick",
                "content": "**THE BASIC IDEA**\\nExample: \"leetcodeisgreat\"\\n* For any index i in the given char array, we can imagine a 5 sized vector *u* representing the count of the 5 vowels from 0 to i (i.e. the prefix sum of vowels\\' count)\\n\\n*u*\\'s for all indices\\n|chars|l|e|e|t|c|o|d|e|i|s|g|r|e|a|t|\\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\\n|a|0|0|0|0|0|0|0|0|0|0|0|0|0|1|1|\\n|e|0|1|2|2|2|2|2|3|3|3|3|3|4|4|4|\\n|i|0|0|0|0|0|0|0|0|1|1|1|1|1|1|1|\\n|o|0|0|0|0|0|1|1|1|1|1|1|1|1|1|1|\\n|u|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\\n\\n* Further, imagine a vector *v* where the counts from *u* go through an \\'isOdd\\' check and give boolean values\\n\\n*v*\\'s for all indices\\n|chars|l|e|e|t|c|o|d|e|i|s|g|r|e|a|t|\\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\\n|a|false|false|false|false|false|false|false|false|false|false|false|false|false|true|true|\\n|e|false|true|false|false|false|false|false|true|true|true|true|true|false|false|false|\\n|i|false|false|false|false|false|false|false|false|true|true|true|true|true|true|true|\\n|o|false|false|false|false|false|true|true|true|true|true|true|true|true|true|true|\\n|u|false|false|false|false|false|false|false|false|false|false|false|false|false|false|false|\\n\\n* Now, think about \\'a\\' alone for a sec: our required substring (containing even counts for \\'a\\') ending at i should begin at a point j where the **prefix sum at j-1 matches the prefix sum at i**. Here, \"match\" means if prefix sum is odd at i, the start should also have the prefix sum odd (even = vice versa)\\n* Standing at index i, we may ask: what\\'s the longest substring ending with i where every vowel occurs even number of times?\\n**For the *v* computed at i, we need to find the VERY FIRST occurrence of the same *v* before i**\\n* We can \"encode\" the vector *v* by representing true/false as bits 1/0 and finding the decimal representation\\n\\n|vowel|a|e|i|o|u|\\n|:-:|:-:|:-:|:-:|:-:|:-:|\\n|contrib\\'n if true|1|2|4|8|16\\n\\n|chars|-|l|e|e|t|c|o|d|e|i|s|g|r|e|a|t|\\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\\n|code|0|0|2|0|0|0|8|8|10|14|14|14|14|12|13|13|\\n**THE CODE**\\n\\n**Readable**\\n```\\nclass Solution {\\n    char[] vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    int[] pow = { 1, 2, 4, 8, 16 };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd = new boolean[5];\\n        \\n        HashMap<Integer, Integer> encoded = new HashMap<>();\\n        encoded.put(code, -1);\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded.containsKey(code)) ans = Math.max(i-encoded.get(code), ans);\\n            else encoded.put(code, i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**Faster**\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray(), vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd =  new boolean[5];\\n        \\n        int[] encoded = new int[32], pow = { 1, 2, 4, 8, 16 };\\n        for(int i=0; i<32; ++i) encoded[i] = -2;\\n        encoded[0] = -1;\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded[code]>-2) ans = Math.max(i-encoded[code], ans);\\n            else encoded[code] = i;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[] vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n    int[] pow = { 1, 2, 4, 8, 16 };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd = new boolean[5];\\n        \\n        HashMap<Integer, Integer> encoded = new HashMap<>();\\n        encoded.put(code, -1);\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded.containsKey(code)) ans = Math.max(i-encoded.get(code), ans);\\n            else encoded.put(code, i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char[] arr = s.toCharArray(), vowels = { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n        int n = arr.length, code = 0, ans = 0;\\n        boolean[] odd =  new boolean[5];\\n        \\n        int[] encoded = new int[32], pow = { 1, 2, 4, 8, 16 };\\n        for(int i=0; i<32; ++i) encoded[i] = -2;\\n        encoded[0] = -1;\\n        for(int i=0; i<n; ++i) {\\n            for(int j=0; j<5; ++j) {\\n                if(arr[i] == vowels[j]) {\\n                    code += (odd[j]?-1:1)*pow[j];\\n                    odd[j] = !odd[j];\\n                    break;\\n                }\\n            }\\n            if(encoded[code]>-2) ans = Math.max(i-encoded[code], ans);\\n            else encoded[code] = i;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532101,
                "title": "java-o-n-one-pass-solution-easy-to-understand",
                "content": "Inspired by lee215\\'s solution with some extension to make the solution more easy to understand.\\n\\nlee 215\\'s solution\\n https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531840/JavaPython-One-Pass\\n \\n Same idea, we use a state to encode the vowels inforation for prefix string end at index i.\\n*  1 State has 5 bits, each bits to indicate if the corresponding vowel have even count or not.\\n*  2 When current index have a vowel character, we use bitwise xor to toggle the bit value.  state ^= (1 << digit);\\n*  3 For the substring between two index have identical state, then all vowels\\'s count are even number.\\n\\t* Eg if from 0 - i, we have even number of \\'a\\', and from 0- j, if we have even number of \\'a\\' again, then the substring between i and j will have even number of \\'a\\' as well. This would be the same if 0 - i and 0 - j both have odd number of \\'a\\'.  \\n\\n*  * Suggested by @multics, we are tracking the value that corresponds to the value of the desired bit to flip. In this way, we can avoid bit shifting.\\n\\n```\\nclass Solution {\\n    HashMap<Character, Integer> vowlToBitIndex = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 1);\\n            put(\\'e\\', 2);\\n            put(\\'i\\', 4);\\n            put(\\'o\\', 8);\\n            put(\\'u\\', 16);\\n        }\\n    };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> stateToIndex = new HashMap<>();\\n        stateToIndex.put(0, -1);\\n        int state = 0, maxLen = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            char cur = s.charAt(i);\\n            if(vowlToBitIndex.containsKey(cur)) {\\n                // flap the digits of the state. 1-> 0 or 0 -> 1\\n                int bitToFlip = vowlToBitIndex.get(cur); \\n                state ^= bitToFlip; \\n            }\\n            \\n            stateToIndex.putIfAbsent(state, i);\\n            maxLen = Math.max(maxLen, i - stateToIndex.get(state));\\n        }\\n        \\n        return maxLen;    \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<Character, Integer> vowlToBitIndex = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 1);\\n            put(\\'e\\', 2);\\n            put(\\'i\\', 4);\\n            put(\\'o\\', 8);\\n            put(\\'u\\', 16);\\n        }\\n    };\\n    \\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> stateToIndex = new HashMap<>();\\n        stateToIndex.put(0, -1);\\n        int state = 0, maxLen = 0;\\n        for(int i = 0; i < s.length(); ++i) {\\n            char cur = s.charAt(i);\\n            if(vowlToBitIndex.containsKey(cur)) {\\n                // flap the digits of the state. 1-> 0 or 0 -> 1\\n                int bitToFlip = vowlToBitIndex.get(cur); \\n                state ^= bitToFlip; \\n            }\\n            \\n            stateToIndex.putIfAbsent(state, i);\\n            maxLen = Math.max(maxLen, i - stateToIndex.get(state));\\n        }\\n        \\n        return maxLen;    \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1245925,
                "title": "easy-c-with-thought-process-of-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\t//the problem is hard one \\n\\t// so lets start\\n\\t//we will require a mask to implement this(thought process- we cannot apply sliding window because removing current even vowel can destroy our maximum length of even vowel substring in future p.s(i tried sliding window :p))\\n\\t// mask ~ aeiou\\n  //          00000\\n//when ever i will find a vowel i will toggle the bit and if in any case the state gets repeated this means we have even vowels within the indices\\n\\t\\t\\t // reason ~ every bit takes two toggle to return to its original state like 0-->1-->0\\n\\t\\n    map<int,int>m;\\n        m[0]=-1;\\n        string v=\"aeiou\";\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<5;j++){\\n                if(s[i]==v[j]){\\n                    mask=mask^(1<<j);\\n                    break;\\n                }\\n            }\\n                //cout<<1<<\" \";\\n                if(m.find(mask)==m.end()){\\n                    m[mask]=i;\\n                }\\n                res=max(res,i-m[mask]);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\t//the problem is hard one \\n\\t// so lets start\\n\\t//we will require a mask to implement this(thought process- we cannot apply sliding window because removing current even vowel can destroy our maximum length of even vowel substring in future p.s(i tried sliding window :p))\\n\\t// mask ~ aeiou\\n  //          00000\\n//when ever i will find a vowel i will toggle the bit and if in any case the state gets repeated this means we have even vowels within the indices\\n\\t\\t\\t // reason ~ every bit takes two toggle to return to its original state like 0-->1-->0\\n\\t\\n    map<int,int>m;\\n        m[0]=-1;\\n        string v=\"aeiou\";\\n        int mask=0;\\n        int res=0;\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<5;j++){\\n                if(s[i]==v[j]){\\n                    mask=mask^(1<<j);\\n                    break;\\n                }\\n            }\\n                //cout<<1<<\" \";\\n                if(m.find(mask)==m.end()){\\n                    m[mask]=i;\\n                }\\n                res=max(res,i-m[mask]);\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 531807,
                "title": "python-two-sum-like-hash-map-solution",
                "content": "Python two-sum-like hash map solution\\n\\nUse a 5-dimension True/False tuple to represent how many times each vowel has appeared so far. If a vowel has appeared even times, that dimension is False, otherwise that dimension is True. So whenever a vowel appears, just copy the previous tuple, and toggle that corresponding dimension.\\n\\nThe rest is just like two-sum: iterate each tuple, and check if we have seen this tuple before.\\n\\n```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        integrals = [(False, False, False, False, False)] # integrals[10][mapping[\"a\"]] == False means we have seen \"a\" appears even times before index 10\\n        mapping = {\\n            \"a\": 0,\\n            \"i\": 1,\\n            \"u\": 2,\\n            \"e\": 3,\\n            \"o\": 4\\n        }\\n\\n        for v in s:\\n            vector = list(integrals[-1])\\n            if v in mapping: # if v is a vowel\\n                vector[mapping[v]] = not vector[mapping[v]] # toggle that dimension, because if v had appeared even times before, it becomes odd times now\\n            integrals.append(tuple(vector))\\n\\n        seen = {}\\n        res = 0\\n\\n        for i, v in enumerate(integrals):\\n            if v in seen: # we have seen this vector before\\n                res = max(res, i - seen[v]) # compare its substring length\\n            else:\\n                seen[v] = i # just record the first time each vector appears\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        integrals = [(False, False, False, False, False)] # integrals[10][mapping[\"a\"]] == False means we have seen \"a\" appears even times before index 10\\n        mapping = {\\n            \"a\": 0,\\n            \"i\": 1,\\n            \"u\": 2,\\n            \"e\": 3,\\n            \"o\": 4\\n        }\\n\\n        for v in s:\\n            vector = list(integrals[-1])\\n            if v in mapping: # if v is a vowel\\n                vector[mapping[v]] = not vector[mapping[v]] # toggle that dimension, because if v had appeared even times before, it becomes odd times now\\n            integrals.append(tuple(vector))\\n\\n        seen = {}\\n        res = 0\\n\\n        for i, v in enumerate(integrals):\\n            if v in seen: # we have seen this vector before\\n                res = max(res, i - seen[v]) # compare its substring length\\n            else:\\n                seen[v] = i # just record the first time each vector appears\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531818,
                "title": "c-bit-mask",
                "content": "Since there are only 5 vowels, we can use bit-mask to record 32 states. (For each vowel, its count is either odd or even.) ```0``` means even number of counts while ```1``` means odd number of counts. We pass the string one time and record the state up to each character. If we find a state that has been found before, by the property of odd and even numbers, the substring between two indices meets the criteria. Since we want the longest one, we only record the index of the state when it first appears.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        const string vowels(\"aeiou\");\\n        int ans(0), mask(0);\\n        \\n        for (int k = 0; k < s.length(); ++k) {\\n            for (int i = 0; i < 5; ++i)\\n                if (s[k] == vowels[i]) {\\n                    mask ^= 1 << i;\\n                    break;\\n                }\\n            states[mask] == -2 ? states[mask] = k : ans = max(ans, k - states[mask]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```0```\n```1```\n```cpp\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        const string vowels(\"aeiou\");\\n        int ans(0), mask(0);\\n        \\n        for (int k = 0; k < s.length(); ++k) {\\n            for (int i = 0; i < 5; ++i)\\n                if (s[k] == vowels[i]) {\\n                    mask ^= 1 << i;\\n                    break;\\n                }\\n            states[mask] == -2 ? states[mask] = k : ans = max(ans, k - states[mask]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531870,
                "title": "python-easy-sliding-window",
                "content": "Explaination - Sliding window over each substring of s starting with substring of len(s). If count of any vowel in substring is not even, break and try next substring.\\n\\nHope this makes sense, feel free to critique my code - very new to programming. Thanks!\\n\\n```class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        for i in range(len(s),-1,-1):\\n            for x in range(len(s) - i +1):\\n                counter = 0\\n                temp = s[x:x+i]\\n                for k in \\'aeiou\\':\\n                    if temp.count(k) % 2 != 0:\\n                        counter += 1\\n                        break\\n                if counter == 0:\\n                    return i\\n",
                "solutionTags": [],
                "code": "Explaination - Sliding window over each substring of s starting with substring of len(s). If count of any vowel in substring is not even, break and try next substring.\\n\\nHope this makes sense, feel free to critique my code - very new to programming. Thanks!\\n\\n```class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        for i in range(len(s),-1,-1):\\n            for x in range(len(s) - i +1):\\n                counter = 0\\n                temp = s[x:x+i]\\n                for k in \\'aeiou\\':\\n                    if temp.count(k) % 2 != 0:\\n                        counter += 1\\n                        break\\n                if counter == 0:\\n                    return i\\n",
                "codeTag": "Java"
            },
            {
                "id": 1471541,
                "title": "c-1-using-sliding-window-tle-2-using-mask-linear-approach-accepted",
                "content": "```\\n//Approach-1 (Using Sliding Window) 52/53 test cases passed\\nclass Solution {\\npublic:\\n    bool isVowel(const char& ch) {\\n        return ch==\\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        int n     = s.length();\\n        int maxL  = 0;\\n        int start = 0;\\n        int end   = 0;\\n        \\n        while(end < n) {\\n            char curr = s[end];\\n            end++;\\n            if(isVowel(curr)) mp[curr]++;\\n            \\n            unordered_map<char, int> temp(mp); //create a temporary map\\n            \\n            //you need to decrease the window size until you get all vowels in even count\\n            while(temp[\\'a\\']%2 || temp[\\'e\\']%2 || temp[\\'i\\']%2 || temp[\\'o\\']%2 || temp[\\'u\\']%2) {\\n                if(isVowel(s[start]))\\n                    temp[s[start]]--;\\n                \\n                start++; //reduce the window size\\n                \\n                if(end-start <= maxL) break; //aage barhne se fayda nahi hai bhai\\n            }\\n            \\n            maxL = max(maxL, end-start);\\n            start = 0;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (using Mask and Xor property)\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int mask = 0;\\n        int maxL = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            int val = 0;\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                val = s[i]; //agar vowel hai to uski value lelo else consonant me 0 rahegi val\\n            \\n            mask = mask^val; //xor nikala\\n            \\n            if(!mp.count(mask)) //agar past me nahi dekha to map me daaldo\\n                mp[mask] = i;\\n            \\n            maxL = max(maxL, i - mp[mask]); //maxL nikaal lo\\n        }\\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Sliding Window) 52/53 test cases passed\\nclass Solution {\\npublic:\\n    bool isVowel(const char& ch) {\\n        return ch==\\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        int n     = s.length();\\n        int maxL  = 0;\\n        int start = 0;\\n        int end   = 0;\\n        \\n        while(end < n) {\\n            char curr = s[end];\\n            end++;\\n            if(isVowel(curr)) mp[curr]++;\\n            \\n            unordered_map<char, int> temp(mp); //create a temporary map\\n            \\n            //you need to decrease the window size until you get all vowels in even count\\n            while(temp[\\'a\\']%2 || temp[\\'e\\']%2 || temp[\\'i\\']%2 || temp[\\'o\\']%2 || temp[\\'u\\']%2) {\\n                if(isVowel(s[start]))\\n                    temp[s[start]]--;\\n                \\n                start++; //reduce the window size\\n                \\n                if(end-start <= maxL) break; //aage barhne se fayda nahi hai bhai\\n            }\\n            \\n            maxL = max(maxL, end-start);\\n            start = 0;\\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\n```\\n//Approach-2 (using Mask and Xor property)\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int mask = 0;\\n        int maxL = 0;\\n        for(int i = 0; i<s.length(); i++) {\\n            int val = 0;\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                val = s[i]; //agar vowel hai to uski value lelo else consonant me 0 rahegi val\\n            \\n            mask = mask^val; //xor nikala\\n            \\n            if(!mp.count(mask)) //agar past me nahi dekha to map me daaldo\\n                mp[mask] = i;\\n            \\n            maxL = max(maxL, i - mp[mask]); //maxL nikaal lo\\n        }\\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373747,
                "title": "java-one-pass-bit-mask",
                "content": "```\\npublic int findTheLongestSubstring(String s) {\\n        int mask = 0;\\n        int[] freq = new int[128];\\n        int ans = 0;\\n        Arrays.fill(freq,-2);\\n        freq[0] = -1;\\n        int i=0;\\n        for(Character ch:s.toCharArray()){\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'e\\' || ch == \\'o\\' || ch == \\'u\\'){\\n                if(ch == \\'a\\'){\\n                    mask^=(1<<0);\\n                }\\n                else if(ch == \\'e\\'){\\n                    mask^=(1<<1);\\n                }\\n                else if(ch == \\'i\\'){\\n                    mask^=(1<<2);\\n                }\\n                else if(ch == \\'o\\'){\\n                    mask^=(1<<3);\\n                }\\n                else{\\n                    mask^=(1<<4);\\n                }\\n            }\\n            if(freq[mask]!=-2){\\n                ans = Math.max(ans,i-freq[mask]);\\n            }\\n            else{\\n                freq[mask] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheLongestSubstring(String s) {\\n        int mask = 0;\\n        int[] freq = new int[128];\\n        int ans = 0;\\n        Arrays.fill(freq,-2);\\n        freq[0] = -1;\\n        int i=0;\\n        for(Character ch:s.toCharArray()){\\n            if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'e\\' || ch == \\'o\\' || ch == \\'u\\'){\\n                if(ch == \\'a\\'){\\n                    mask^=(1<<0);\\n                }\\n                else if(ch == \\'e\\'){\\n                    mask^=(1<<1);\\n                }\\n                else if(ch == \\'i\\'){\\n                    mask^=(1<<2);\\n                }\\n                else if(ch == \\'o\\'){\\n                    mask^=(1<<3);\\n                }\\n                else{\\n                    mask^=(1<<4);\\n                }\\n            }\\n            if(freq[mask]!=-2){\\n                ans = Math.max(ans,i-freq[mask]);\\n            }\\n            else{\\n                freq[mask] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 664445,
                "title": "short-and-simple-c-solution-well-explained",
                "content": "**Approach - 1**\\n\\n```\\n/*\\n\\tI first tried this approach to keep the count of vowels at every step as a binary string an then comapre it.\\n\\tBut it shows that all the test cases passed but took too long.\\n\\tSO BASICALLY THIS APPROACH GETS TLE.\\n*/\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char,int>cnt;\\n        unordered_map<string,int>mp; mp[\"00000\"]=-1;\\n        vector<char>vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int ans=0; string temp=\"\";\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            char x=s[i]; temp=\"\";\\n            cnt[x]++;\\n            for(int j=0 ; j<5 ; j++) temp+=to_string(cnt[vowels[j]]%2);\\n            if(mp.find(temp)!=mp.end()) ans=max(ans,i-mp[temp]);\\n            else mp[temp]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Approach - 2**\\n\\n\\n```\\n/*\\n\\t\\tSo I tried with some modifications and this one worked fine.\\n\\tEach time we process a vowel, update the running bitmask by flipping this vowel\\'s parity.\\n\\tFor each different parity state, we save its earliest occurence in a map. \\n\\tFor each state, if it has never appeared before, save it to the map.\\n\\tIf it has appeared before, update the global best result. \\n\\tA repeating state means the substring in between its earliest and current occurence has all even counts of vowels.\\n*/\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int ans=0; int curr=0; mp[0]=-1;\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int x=s[i]-\\'a\\';\\n                curr ^= 1<<x;      //update the parity when you see a vowel\\n            }\\n            if(mp.find(curr)==mp.end()) mp[curr]=i;   \\n            ans=max(ans,i-mp[curr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tI first tried this approach to keep the count of vowels at every step as a binary string an then comapre it.\\n\\tBut it shows that all the test cases passed but took too long.\\n\\tSO BASICALLY THIS APPROACH GETS TLE.\\n*/\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char,int>cnt;\\n        unordered_map<string,int>mp; mp[\"00000\"]=-1;\\n        vector<char>vowels{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        int ans=0; string temp=\"\";\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            char x=s[i]; temp=\"\";\\n            cnt[x]++;\\n            for(int j=0 ; j<5 ; j++) temp+=to_string(cnt[vowels[j]]%2);\\n            if(mp.find(temp)!=mp.end()) ans=max(ans,i-mp[temp]);\\n            else mp[temp]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/*\\n\\t\\tSo I tried with some modifications and this one worked fine.\\n\\tEach time we process a vowel, update the running bitmask by flipping this vowel\\'s parity.\\n\\tFor each different parity state, we save its earliest occurence in a map. \\n\\tFor each state, if it has never appeared before, save it to the map.\\n\\tIf it has appeared before, update the global best result. \\n\\tA repeating state means the substring in between its earliest and current occurence has all even counts of vowels.\\n*/\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int ans=0; int curr=0; mp[0]=-1;\\n        for(int i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int x=s[i]-\\'a\\';\\n                curr ^= 1<<x;      //update the parity when you see a vowel\\n            }\\n            if(mp.find(curr)==mp.end()) mp[curr]=i;   \\n            ans=max(ans,i-mp[curr]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976840,
                "title": "python-3-8-lines-bit-mask-w-example-t-m-91-69",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n                                                    #       Example: \\'leetcodoe\\'\\n        d = defaultdict(int)\\n        v = {\\'a\\':0,\\'e\\':1,\\'i\\':2,\\'o\\':3,\\'u\\':4,}        #    i   ch      n    ans    d\\n        n, ans, d[0] = 0, 0, -1                     #  \\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #    0    l    00000   1    {0:-1}\\n        for i, ch in enumerate(s):                  #    1    e    00010   1    {0:-1, 2:1}}\\n            if ch in \\'aeiou\\': n ^= (1<<v[ch])       #    2    e    00000   3    {0:-1, 2:1}}\\n                                                    #    3    t    00000   4    {0:-1, 2:1}}\\n            if n in d: ans = max(ans, i - d[n])     #    4    c    00000   5    {0:-1, 2:1, 8:5}\\n            else:      d[n] = i                     #    5    o    01000   5    {0:-1, 2:1, 8:5}\\n                                                    #    6    d    01000   5    {0:-1, 2:1, 8:5}\\n        return ans                                  #    7    o    00000   8    {0:-1, 2:1, 8:5}\\n                                                    #    8    e    00010   8    {0:-1, 2:1, 8:5}\\n                                                    #   /          |||||\\n                                                    #  return     \\'uoiea\\'\\n```\\n[https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/submissions/868729915/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n                                                    #       Example: \\'leetcodoe\\'\\n        d = defaultdict(int)\\n        v = {\\'a\\':0,\\'e\\':1,\\'i\\':2,\\'o\\':3,\\'u\\':4,}        #    i   ch      n    ans    d\\n        n, ans, d[0] = 0, 0, -1                     #  \\u2013\\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                    #    0    l    00000   1    {0:-1}\\n        for i, ch in enumerate(s):                  #    1    e    00010   1    {0:-1, 2:1}}\\n            if ch in \\'aeiou\\': n ^= (1<<v[ch])       #    2    e    00000   3    {0:-1, 2:1}}\\n                                                    #    3    t    00000   4    {0:-1, 2:1}}\\n            if n in d: ans = max(ans, i - d[n])     #    4    c    00000   5    {0:-1, 2:1, 8:5}\\n            else:      d[n] = i                     #    5    o    01000   5    {0:-1, 2:1, 8:5}\\n                                                    #    6    d    01000   5    {0:-1, 2:1, 8:5}\\n        return ans                                  #    7    o    00000   8    {0:-1, 2:1, 8:5}\\n                                                    #    8    e    00010   8    {0:-1, 2:1, 8:5}\\n                                                    #   /          |||||\\n                                                    #  return     \\'uoiea\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751178,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_set<char>vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int n = s.length();\\n        int max_len = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(vowel.find(s[i]) != vowel.end())\\n            {\\n                mask ^= 1 << (s[i] - \\'a\\');\\n                if(M.find(mask) == M.end())\\n                    M[mask] = i;\\n            }\\n            max_len = max(max_len,i - M[mask]);\\n            \\n        }\\n        return max_len;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_set<char>vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        unordered_map<int,int>M;\\n        M[0] = -1;\\n        int mask = 0;\\n        int n = s.length();\\n        int max_len = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(vowel.find(s[i]) != vowel.end())\\n            {\\n                mask ^= 1 << (s[i] - \\'a\\');\\n                if(M.find(mask) == M.end())\\n                    M[mask] = i;\\n            }\\n            max_len = max(max_len,i - M[mask]);\\n            \\n        }\\n        return max_len;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782312,
                "title": "bit-mask-o-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sz = (1<<6) - 1;\\n    int INF = 1e9 + 7;\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int>mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<int>dp(sz, INF);\\n        \\n        dp[0] = -1;\\n        int mask = 0;\\n        int ans = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.count(s[i]) != 0)\\n                mask ^= 1 << (mp[s[i]]);\\n            \\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sz = (1<<6) - 1;\\n    int INF = 1e9 + 7;\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int>mp;\\n        mp[\\'a\\'] = 0;\\n        mp[\\'e\\'] = 1;\\n        mp[\\'i\\'] = 2;\\n        mp[\\'o\\'] = 3;\\n        mp[\\'u\\'] = 4;\\n        \\n        vector<int>dp(sz, INF);\\n        \\n        dp[0] = -1;\\n        int mask = 0;\\n        int ans = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(mp.count(s[i]) != 0)\\n                mask ^= 1 << (mp[s[i]]);\\n            \\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(dp[mask], i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643618,
                "title": "c-hash-map",
                "content": "**Intuition:**\\nKeep a mask vector for all vowels.\\nKeeping xoring the vowel masks, set each mask\\'s 1st encounter index in hashmap. If we encounter this mask again we calculate the current length  with (i-hm[mask]). If mask is zero, then calculate the length from start of the string.\\n(i-(-1) = i+1) \\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int mask = 0, res = 0;\\n        vector<int>count = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        unordered_map<int, int>hm;\\n        hm[0]=-1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= count[s[i]-\\'a\\'];\\n            \\n            if (mask != 0 && hm.find(mask) == hm.end())\\n                hm[mask] = i;\\n            \\n            res = max(res, i-hm[mask]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int mask = 0, res = 0;\\n        vector<int>count = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        unordered_map<int, int>hm;\\n        hm[0]=-1;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            mask ^= count[s[i]-\\'a\\'];\\n            \\n            if (mask != 0 && hm.find(mask) == hm.end())\\n                hm[mask] = i;\\n            \\n            res = max(res, i-hm[mask]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531829,
                "title": "python-bit-mask-one-pass-prefix-hashtable",
                "content": "```\\n  \\n  def findTheLongestSubstring(self, s: str) -> int:\\n\\t\\t\\n\\t\\tlookup={\\'a\\':4,\\'e\\':3,\\'i\\':2,\\'o\\':1,\\'u\\':0}\\n        maxLen=0\\n        prefix={}\\n        prefix[0]=-1\\n        cur=0\\n        for i,ch in enumerate(s):\\n            if ch in lookup:\\n                cur^=(1<<lookup[ch])\\n            if cur in prefix:\\n                maxLen=max(maxLen,i-prefix[cur])\\n            else:\\n\\t\\t\\t\\tprefix[cur]=i\\n        return maxLen\\n",
                "solutionTags": [],
                "code": "```\\n  \\n  def findTheLongestSubstring(self, s: str) -> int:\\n\\t\\t\\n\\t\\tlookup={\\'a\\':4,\\'e\\':3,\\'i\\':2,\\'o\\':1,\\'u\\':0}\\n        maxLen=0\\n        prefix={}\\n        prefix[0]=-1\\n        cur=0\\n        for i,ch in enumerate(s):\\n            if ch in lookup:\\n                cur^=(1<<lookup[ch])\\n            if cur in prefix:\\n                maxLen=max(maxLen,i-prefix[cur])\\n            else:\\n\\t\\t\\t\\tprefix[cur]=i\\n        return maxLen\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2596808,
                "title": "c-easy-to-understand-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }\\n            else\\n                mp[cnt]=i;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1125562,
                "title": "python3-bitmask",
                "content": "\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        ans = mask = 0 \\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            if c in \"aeiou\": \\n                mask ^= 1 << (\"aeiou\".find(c))\\n            if mask in seen: ans = max(ans, i - seen[mask])\\n            seen.setdefault(mask, i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        ans = mask = 0 \\n        seen = {0: -1}\\n        for i, c in enumerate(s):\\n            if c in \"aeiou\": \\n                mask ^= 1 << (\"aeiou\".find(c))\\n            if mask in seen: ans = max(ans, i - seen[mask])\\n            seen.setdefault(mask, i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 532958,
                "title": "easy-solution-using-sliding-window-in-java",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'a\\',0); map.put(\\'e\\',0); map.put(\\'i\\',0); map.put(\\'o\\',0); map.put(\\'u\\',0);\\n        int l=0,maxlen=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            char curr=s.charAt(r);\\n            if(map.containsKey(curr))\\n            {\\n                map.put(curr,map.get(curr)+1);\\n            }\\n            Map<Character,Integer>temp=new HashMap<>();\\n            \\n            temp.put(\\'a\\',map.get(\\'a\\')); \\n            temp.put(\\'e\\',map.get(\\'e\\')); \\n            temp.put(\\'i\\',map.get(\\'i\\')); \\n            temp.put(\\'o\\',map.get(\\'o\\')); \\n            temp.put(\\'u\\',map.get(\\'u\\'));\\n            \\n            while(temp.get(\\'a\\')%2==1||temp.get(\\'e\\')%2==1||temp.get(\\'i\\')%2==1||temp.get(\\'o\\')%2==1||temp.get(\\'u\\')%2==1)\\n            {\\n                char left=s.charAt(l);\\n                if(temp.containsKey(left))\\n                {\\n                    temp.put(left,temp.get(left)-1);\\n                }\\n                l++;\\n            }\\n           maxlen=Math.max(maxlen,r-l+1);\\n           l=0;\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n        Map<Character,Integer>map=new HashMap<>();\\n        map.put(\\'a\\',0); map.put(\\'e\\',0); map.put(\\'i\\',0); map.put(\\'o\\',0); map.put(\\'u\\',0);\\n        int l=0,maxlen=0;\\n        for(int r=0;r<n;r++)\\n        {\\n            char curr=s.charAt(r);\\n            if(map.containsKey(curr))\\n            {\\n                map.put(curr,map.get(curr)+1);\\n            }\\n            Map<Character,Integer>temp=new HashMap<>();\\n            \\n            temp.put(\\'a\\',map.get(\\'a\\')); \\n            temp.put(\\'e\\',map.get(\\'e\\')); \\n            temp.put(\\'i\\',map.get(\\'i\\')); \\n            temp.put(\\'o\\',map.get(\\'o\\')); \\n            temp.put(\\'u\\',map.get(\\'u\\'));\\n            \\n            while(temp.get(\\'a\\')%2==1||temp.get(\\'e\\')%2==1||temp.get(\\'i\\')%2==1||temp.get(\\'o\\')%2==1||temp.get(\\'u\\')%2==1)\\n            {\\n                char left=s.charAt(l);\\n                if(temp.containsKey(left))\\n                {\\n                    temp.put(left,temp.get(left)-1);\\n                }\\n                l++;\\n            }\\n           maxlen=Math.max(maxlen,r-l+1);\\n           l=0;\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377562,
                "title": "xor-operation-c",
                "content": "```\\n//When the xor of all the even times numbers are done it results in 0. The xor of the vowels are done by indicating \\n//them with a single digit and the xor value is stored in a map\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int x= 0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int n=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                x^= (s[i]-\\'a\\'+1);\\n               if(mp.find(x)==mp.end())\\n                  mp[x]=i;\\n            }\\n            if(mp.find(x)!=mp.end())\\n                n= max(n,i-mp[x]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n//When the xor of all the even times numbers are done it results in 0. The xor of the vowels are done by indicating \\n//them with a single digit and the xor value is stored in a map\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int x= 0;\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int n=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\'){\\n                x^= (s[i]-\\'a\\'+1);\\n               if(mp.find(x)==mp.end())\\n                  mp[x]=i;\\n            }\\n            if(mp.find(x)!=mp.end())\\n                n= max(n,i-mp[x]);\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859014,
                "title": "simple-and-logical-approach-one-pass-easy-to-understand",
                "content": "### Idea behind the solution:\\n- We are concerned about whether the particular vowel is occuring even or odd number of times.\\n- We don\\'t bother about the count of each vowles\\n- Now suppose we want to deal with only one vowel, lets say we take \\'a\\' now whether \\'a\\' has occured even or odd times, we can find it by just triggering a bit, that\\'s where bit manipulation comes in.\\n- Now to trigger the bit we can use xor as for the xor property 0^a=a(odd times \\'a\\') and a^a=0(even times \\'a\\')\\n\\nnow there are 5 vowels:\\n- to trigger  \\'a\\' we can xor with the 1st bit\\n- to trigger  \\'e\\' we can xor with the 5th bit\\n- to trigger  \\'i\\' we can xor with 9th bit\\n- to trigger \\'o\\' we can xor with 15th bit\\n- to trigger \\'u\\' we can xor with 21st bit\\n\\nnow at any particular point if we have countered same xor that means previously we had a substring for which we had even number of vowels.\\n\\nlets take the example of\\ne l e e t m i n i c o w o r o e p\\n\\ninitially we have even count for all vowels so we take the xor value as 0\\nnow at index 0 we encounter \\'e\\'(vowel) so xor = xor^e=0^e=e\\nwe didnt come across xor=e before so we continue but to maintain the search we maintain a hashmap of integer and integer where key is xor and value is the first index(as we want to take the longest substring)\\nmap: {0:-1}, {e:0}\\n\\nthen we come to index 1 we encounter \\'l\\'(consonent) so for consonents we will take xor with 0. therefor, xor=xor^0=e^0=e\\nnow we came across e before so longest length substring now will be current index-starting index of \\'e\\'=1-0=1\\n\\nthen we come to index 2 we encounter \\'e\\'(vowel), xor=xor^e=e^e=0\\nwe had put key 0 with value -1 as indexcause if our xor value is 0 again then it means we have a substring right from the start, so longestsubstring= max(1, 2-(-1))=max(0, 3)=3\\n\\n\\nHere is a simple java code for same\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        // storing the vowels for checking\\n\\t\\tHashSet<Character> set= new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n\\t\\t\\n\\t\\t// hash map to maintain the xor and their respective first occurence index\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n\\t\\t\\n\\t\\t// for the substrings for which it starts from 0\\n        map.put(0, -1);\\n\\t\\t\\n\\t\\t// initially all the vowels are 0count which is even\\n        int xor=0;\\n\\t\\t\\n        // longest substring initailly is 0\\n\\t\\tint maxLen=0;\\n        \\n\\t\\t// traversing the array\\n\\t\\tfor(int i=0; i<s.length(); i++){\\n\\t\\t\\n\\t\\t    // checking if the character is vowel or not\\n            if(set.contains(s.charAt(i))){\\n\\t\\t\\t\\t// if it is vowel then we xor(trigger) the respective bit of the vowel and we ignore for the consonent as xor=xor^0=xor\\n                xor^=(s.charAt(i)-\\'a\\'+1);   \\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if we didnt come across the same xor that means there are no even valued vowels as of now\\n            if(!map.containsKey(xor)){\\n\\t\\t\\t\\t// we encounter the xor first time so we put their first index of occurence\\n                map.put(xor, i);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// NOTE: we could have put this in else part but if we have no even valued vowels so the maxlength will be i-i=0\\n\\t\\t\\t// here we update if we had any xor value that we encountered before then \\n\\t\\t\\t// we check the longest substring which have even counts of vowels.\\n            maxLen=Math.max(maxLen, i-map.get(xor));\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        // storing the vowels for checking\\n\\t\\tHashSet<Character> set= new HashSet<>();\\n        set.add(\\'a\\');\\n        set.add(\\'e\\');\\n        set.add(\\'i\\');\\n        set.add(\\'o\\');\\n        set.add(\\'u\\');\\n\\t\\t\\n\\t\\t// hash map to maintain the xor and their respective first occurence index\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n\\t\\t\\n\\t\\t// for the substrings for which it starts from 0\\n        map.put(0, -1);\\n\\t\\t\\n\\t\\t// initially all the vowels are 0count which is even\\n        int xor=0;\\n\\t\\t\\n        // longest substring initailly is 0\\n\\t\\tint maxLen=0;\\n        \\n\\t\\t// traversing the array\\n\\t\\tfor(int i=0; i<s.length(); i++){\\n\\t\\t\\n\\t\\t    // checking if the character is vowel or not\\n            if(set.contains(s.charAt(i))){\\n\\t\\t\\t\\t// if it is vowel then we xor(trigger) the respective bit of the vowel and we ignore for the consonent as xor=xor^0=xor\\n                xor^=(s.charAt(i)-\\'a\\'+1);   \\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if we didnt come across the same xor that means there are no even valued vowels as of now\\n            if(!map.containsKey(xor)){\\n\\t\\t\\t\\t// we encounter the xor first time so we put their first index of occurence\\n                map.put(xor, i);\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// NOTE: we could have put this in else part but if we have no even valued vowels so the maxlength will be i-i=0\\n\\t\\t\\t// here we update if we had any xor value that we encountered before then \\n\\t\\t\\t// we check the longest substring which have even counts of vowels.\\n            maxLen=Math.max(maxLen, i-map.get(xor));\\n        }\\n        \\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428517,
                "title": "python-3-hash-table-bitmask-tuple-o-n-two-implementations-explanation",
                "content": "### Approach #1 Masking with Tuple\\n- There are 5 vowels, and we only care whether the substring contains even or odd number of same vowel. That being said:\\n\\t- `\\'aabc\\'` is essentially same as `\\'aabcaa\\'`, because there are even numbers of  `a` in both string\\n- Say `0` means even number of a vowel and `1` means odd numbers of a vowel, given 5 vowels, there are only 32 different permutations of a length 5 tuple with only `0` and `1` in it. We will call any of the permutation `mask`.\\n- Anyhow, we will run a prefix count on substring vowels, to calculate the result, we need to take the index of the current `mask` minus the lowest index of the same `mask`\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = collections.defaultdict(lambda: sys.maxsize)\\n        cur = (0, 0, 0, 0, 0)                            # current mask\\n        ans = d[cur] = -1                                # initialize result\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4} # index mapping\\n        for i, c in enumerate(s):\\n            if c in vowel:                               # if `c` is a vowel, update the `cur` (mask)\\n                idx = vowel[c]\\n                cur = cur[:idx] + (1-cur[idx],) + cur[idx+1:]\\n            if d[cur] == sys.maxsize: \\n                d[cur] = i                               # if mask is never recorded, recorded it since it\\'s the lowest index of this current mask\\n            ans = max(ans, i - d[cur])                   # update `ans` by calculating `i - lower_idx_of_mask`\\n        return ans\\n```\\n### Approach #2 Bitmasking\\n- As you can see, this method is essentially the same as the previous\\n- From time complexity perspective, both are `O(N)`, where `N` is the length of `s`\\n- However, with bit manipulation, the performance of this method will be slightly better than __*approach #1*__\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = {0: -1}\\n        ans = cur = 0\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        for i, c in enumerate(s):\\n            if c in vowel:\\n                cur ^= 1 << vowel[c]\\n            if cur not in d:\\n                d[cur] = i\\n            ans = max(ans, i - d[cur]) \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = collections.defaultdict(lambda: sys.maxsize)\\n        cur = (0, 0, 0, 0, 0)                            # current mask\\n        ans = d[cur] = -1                                # initialize result\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4} # index mapping\\n        for i, c in enumerate(s):\\n            if c in vowel:                               # if `c` is a vowel, update the `cur` (mask)\\n                idx = vowel[c]\\n                cur = cur[:idx] + (1-cur[idx],) + cur[idx+1:]\\n            if d[cur] == sys.maxsize: \\n                d[cur] = i                               # if mask is never recorded, recorded it since it\\'s the lowest index of this current mask\\n            ans = max(ans, i - d[cur])                   # update `ans` by calculating `i - lower_idx_of_mask`\\n        return ans\\n```\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        d = {0: -1}\\n        ans = cur = 0\\n        vowel = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        for i, c in enumerate(s):\\n            if c in vowel:\\n                cur ^= 1 << vowel[c]\\n            if cur not in d:\\n                d[cur] = i\\n            ans = max(ans, i - d[cur]) \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757131,
                "title": "c-o-n-bitmask-and-hashmap",
                "content": "\\n```\\nint findTheLongestSubstring(string s) {\\n        \\n        string vowels = \"aeiou\";\\n        unordered_map<int, int> umap{{0,-1}};   //mask=>index when it first occurred\\n        int res=0, mask=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(vowels.find(s[i])!=string::npos)\\n                mask ^= 1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\n            if(umap.count(mask))\\n                res = max(res, i-umap[mask]);\\n            else\\n                umap[mask]=i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findTheLongestSubstring(string s) {\\n        \\n        string vowels = \"aeiou\";\\n        unordered_map<int, int> umap{{0,-1}};   //mask=>index when it first occurred\\n        int res=0, mask=0;\\n        for(int i=0; i<s.length(); i++){\\n            if(vowels.find(s[i])!=string::npos)\\n                mask ^= 1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\n            if(umap.count(mask))\\n                res = max(res, i-umap[mask]);\\n            else\\n                umap[mask]=i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 718813,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int status = 0;\\n        int ans = 0;\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(status, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            status ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1) >> 1; // in case char is not vowel\\n            if (!seen.containsKey(status)) {\\n                seen.put(status, i);  // record earliest index\\n            }\\n            ans = Math.max(ans, i - seen.get(status));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int status = 0;\\n        int ans = 0;\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        seen.put(status, -1);\\n        for (int i = 0; i < s.length(); i++) {\\n            status ^= 1 << (\"aeiou\".indexOf(s.charAt(i)) + 1) >> 1; // in case char is not vowel\\n            if (!seen.containsKey(status)) {\\n                seen.put(status, i);  // record earliest index\\n            }\\n            ans = Math.max(ans, i - seen.get(status));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578071,
                "title": "python-solution-sliding-window-easy-to-read",
                "content": "So I saw a lot of the solutions are great and make a lot of sense, but I wanted to make it more reader friendly so I took some inspiration from the solutions and did this. I notice that LC is great for practicing and really honing your skills but most of the code here at times aren\\'t readable and I hope in the future if you have an answer / idea to try to be more legibile for the new comers :). Notice that the problem is like a sliding window but not the one\\'s we\\'re used to. You look for the max length so why not start at the max and contract the window from there. Your RHS of window is your end of your string where you try to remove each letter 1 by 1. Since we are assuming that every string we\\'ve seen so far is \"valid\" almost. Our code is \"almost\" going to try to break you. If our code tried and still couldn\\'t break you then we know you\\'re an even length and since we started from the max and are decrementing we know it\\'s the best length.\\nI wanted to specifically talk about this piece. \\n` sub_str = s[start:start + substr_len]`\\nUnderstand that this code of our start is us trying the \"combinations from the beginning (until end_remove) because we want to make sure to \"break said code\". So understand this sub_str literally tries all the ones and for every deletion of the front we add back to the end since we want to try it specifically for the position try the combinations given the length we have. If you\\'re discouraged by this problem don\\'t be :). I am working at a Big N and this one gave me trouble. Time to dust off the old LC hat :P \\n```\\nimport collections \\nclass Solution:\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        for substr_len in range(len(s), -1, -1): #dynamic sliding window []\\n            end_remove = len(s) - substr_len + 1 \\n            \\n            for start in range(end_remove):\\n                even = True #Let\\'s assume everything is true so far (our code is going to try to break you)\\n                sub_str = s[start:start + substr_len]\\n                \\n                for vowel in \\'aeiou\\': \\n                    if sub_str.count(vowel) % 2 != 0:\\n                        even = False #means we\\'re odd length c\\n                        break\\n                if even == True: #counter == 0 is saying all are odd \\n                    return substr_len\\n```\\n",
                "solutionTags": [],
                "code": "```\\nimport collections \\nclass Solution:\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        for substr_len in range(len(s), -1, -1): #dynamic sliding window []\\n            end_remove = len(s) - substr_len + 1 \\n            \\n            for start in range(end_remove):\\n                even = True #Let\\'s assume everything is true so far (our code is going to try to break you)\\n                sub_str = s[start:start + substr_len]\\n                \\n                for vowel in \\'aeiou\\': \\n                    if sub_str.count(vowel) % 2 != 0:\\n                        even = False #means we\\'re odd length c\\n                        break\\n                if even == True: #counter == 0 is saying all are odd \\n                    return substr_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532459,
                "title": "c-dp-solution",
                "content": "Rolling dp. The every integer in the dp map represents a state that can be formed so far, where each state is of the form {#a%2, #e%2, #i%2, #o%2, #u%2}. \\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> dp, dp2;\\n        vector<int> m(256, 0);\\n        m[\\'a\\'] = 0;\\n        m[\\'e\\'] = 1;\\n        m[\\'i\\'] = 2;\\n        m[\\'o\\'] = 3;\\n        m[\\'u\\'] = 4;\\n        \\n        dp[0] = 0;\\n        int ans = 0;\\n        int cnt = 0;\\n        for (const auto c: s) {\\n            if (c == \\'a\\'|| c == \\'e\\'|| c == \\'i\\'|| c == \\'o\\'|| c == \\'u\\') {\\n                dp2.clear();\\n                for (const auto& kv: dp) {\\n                    int mask = 1<<m[c];\\n                    dp2[kv.first^mask] = kv.second+1+cnt;\\n                }\\n                dp = dp2;\\n                cnt = 0;\\n            } else {\\n                cnt++;\\n            }\\n\\n            ans = max(dp[0]+cnt, ans);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> dp, dp2;\\n        vector<int> m(256, 0);\\n        m[\\'a\\'] = 0;\\n        m[\\'e\\'] = 1;\\n        m[\\'i\\'] = 2;\\n        m[\\'o\\'] = 3;\\n        m[\\'u\\'] = 4;\\n        \\n        dp[0] = 0;\\n        int ans = 0;\\n        int cnt = 0;\\n        for (const auto c: s) {\\n            if (c == \\'a\\'|| c == \\'e\\'|| c == \\'i\\'|| c == \\'o\\'|| c == \\'u\\') {\\n                dp2.clear();\\n                for (const auto& kv: dp) {\\n                    int mask = 1<<m[c];\\n                    dp2[kv.first^mask] = kv.second+1+cnt;\\n                }\\n                dp = dp2;\\n                cnt = 0;\\n            } else {\\n                cnt++;\\n            }\\n\\n            ans = max(dp[0]+cnt, ans);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531872,
                "title": "concise-c-and-java-solutions-with-explanation-o-n-o-1-time-space",
                "content": "You can represent odd/even using 0 and 1. As you iterate over the input string, when you arrive at some index, say index \"t\", you can represent whether the number of each vowel which has been seen up to and including index \"t\", is odd or even, using a 5 bit binary number, for example 01101. The number 01101 (13) represents that the number of a\\'s and o\\'s seen is even, while the number of e\\'s, i\\'s and u\\'s seen is odd. \\n\\nThe longest substring with even number of vowels which ends at index \"t\", is going to begin at the index after the lowest index you\\'ve seen the binary number at index \"t\". So, the idea here, is to track the first time you see these numbers and use these numbers to determine the longest substring ending at each index of the input string. By the time you\\'ve iterated over the string once, you\\'ll have the result, which is simply the maximum length you found while iterating over the string. Since these binary numbers are 5 bits, there are at most 32 of them, which is very manageable. \\n\\nThis is a nice situation to use the XOR operator as well. You can derive the binary number at index \"t\" very easily using a XOR operator, if you give each vowel a binary representation with only one bit set to 1. I chose \\'a\\'=10000=16, \\'e\\'=01000=8, etc... This is what is going on in my chrToBin array below. If you XOR this with the binary number from index \"t - 1\", you will have the new binary representation for index \"t\" telling you exactly whether the number of each vowel up to and including index \"t\" is even or odd.\\n\\n**Example C# solution:**\\n```\\n    public int FindTheLongestSubstring(string s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Array.Fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            last ^= chrToBin[s[i] - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.Max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\n**Example Java solution:**\\n```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Arrays.fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            last ^= chrToBin[s.charAt(i) - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int FindTheLongestSubstring(string s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Array.Fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            last ^= chrToBin[s[i] - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.Max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```\n```java\\n    public int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        int[] chrToBin = {16, 0, 0, 0, 8, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0};\\n        int[] minIndexSeen = new int[32];\\n        Arrays.fill(minIndexSeen, -1);\\n        minIndexSeen[0] = 0;\\n        int last = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            last ^= chrToBin[s.charAt(i) - \\'a\\'];     \\n            minIndexSeen[last] = (minIndexSeen[last] != -1) ? minIndexSeen[last] : i + 1;\\n            res = Math.max(res, i - minIndexSeen[last] + 1);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3287047,
                "title": "fully-commented-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        //final ans to be retruned from the function\\n        int ans = 0;\\n\\n        //the count of the vowel must be even number of times \\n        //vowels can occur even number of times..0 , 2 , 4 , 6...2(n)  \\n\\n        //to maintain the bit mask we will have a count \\n        int num = 0;\\n\\n        //we are going to store the number in a unordered_map\\n        unordered_map<int,int>mp;    \\n\\n        //an idx to iterate over the string\\n        int idx = 0;\\n        \\n        //storing the inital count in the map\\n        mp[num] = -1;\\n\\n        //basically the consonant will help to increase the length of the string\\n        while(idx < s.length())\\n        {\\n            char ch = s[idx];\\n            \\n            if(isVowel(ch) == true)\\n            {\\n                char ch = s[idx];\\n                int pos = ch - \\'a\\';\\n\\n                //we will toggle the bit to the currosponding pos of the char\\n                num = (num ^ (1<<pos));\\n\\n                if(mp.find(num) != mp.end())\\n                {\\n                    //previously we have encountred the num before also\\n                    int start = mp[num]+1;\\n                    int end   = idx;\\n                    int wind_size = (end - start + 1);\\n\\n                    if(wind_size > ans)\\n                    ans = wind_size;\\n                }\\n            }\\n            else\\n            {\\n                //consonant will only help to increase the length of the substring\\n                //in which the count of the vowel is even number of times\\n              \\n                //consonant will not contribute any value to the num\\n                int start = mp[num]+1;\\n                int end   = idx;\\n                int wind_size = (end - start + 1);\\n\\n                if(wind_size > ans)\\n                ans = wind_size;\\n            }\\n            if(mp.find(num) == mp.end())\\n            {\\n                mp[num] = idx;\\n            }\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\') return true;\\n        if(ch == \\'e\\') return true;\\n        if(ch == \\'i\\') return true;\\n        if(ch == \\'o\\') return true;\\n        if(ch == \\'u\\') return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        //final ans to be retruned from the function\\n        int ans = 0;\\n\\n        //the count of the vowel must be even number of times \\n        //vowels can occur even number of times..0 , 2 , 4 , 6...2(n)  \\n\\n        //to maintain the bit mask we will have a count \\n        int num = 0;\\n\\n        //we are going to store the number in a unordered_map\\n        unordered_map<int,int>mp;    \\n\\n        //an idx to iterate over the string\\n        int idx = 0;\\n        \\n        //storing the inital count in the map\\n        mp[num] = -1;\\n\\n        //basically the consonant will help to increase the length of the string\\n        while(idx < s.length())\\n        {\\n            char ch = s[idx];\\n            \\n            if(isVowel(ch) == true)\\n            {\\n                char ch = s[idx];\\n                int pos = ch - \\'a\\';\\n\\n                //we will toggle the bit to the currosponding pos of the char\\n                num = (num ^ (1<<pos));\\n\\n                if(mp.find(num) != mp.end())\\n                {\\n                    //previously we have encountred the num before also\\n                    int start = mp[num]+1;\\n                    int end   = idx;\\n                    int wind_size = (end - start + 1);\\n\\n                    if(wind_size > ans)\\n                    ans = wind_size;\\n                }\\n            }\\n            else\\n            {\\n                //consonant will only help to increase the length of the substring\\n                //in which the count of the vowel is even number of times\\n              \\n                //consonant will not contribute any value to the num\\n                int start = mp[num]+1;\\n                int end   = idx;\\n                int wind_size = (end - start + 1);\\n\\n                if(wind_size > ans)\\n                ans = wind_size;\\n            }\\n            if(mp.find(num) == mp.end())\\n            {\\n                mp[num] = idx;\\n            }\\n            idx++;\\n        }\\n        return ans;\\n    }\\n    bool isVowel(char ch)\\n    {\\n        if(ch == \\'a\\') return true;\\n        if(ch == \\'e\\') return true;\\n        if(ch == \\'i\\') return true;\\n        if(ch == \\'o\\') return true;\\n        if(ch == \\'u\\') return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898302,
                "title": "python-javascript-efficient-solution-with-detailed-explanation",
                "content": "# Intuition\\n\\n## We are looking for the empty hashtable \\n\\nCounting vowels in \"abceiae\": { \"a\" : 2, \"e\" : 2, \"i\" : 1}.\\n\\n4 == 2 == 0. It\\'s all even.\\n5 == 3 == 1. It\\'s all odd.\\nSo \"abceiae\" is : { \"a\" : 0, \"e\" : 0, \"i\" : 1}.\\nOr better,  \"abceiae\" is : {\"i\" : 1}.\\nEncounting any vowel even times is as good as never encounting any \\u263A\\uFE0F\\n\\nTo summarize, vowels in \"abceiae\":\\n{\"a\" : 2, \"e\" : 2, \"i\" : 1} -> { \"a\" : 0, \"e\" : 0, \"i\" : 1} -> {\"i\" : 1}\\n\\nhashtable is empty** == **all vowel counts in that particular string are even\\n\\n## Equal hashtables == potential substring\\n\\nLet\\'s take a look at **\"ieaa\"**:\\n\\n0. In the start hashtable is empty.\\n1. on letter **i**: { \"i\": 1 }\\n2. on letter **e**: { \"i\": 1, \"e\" : 1 }\\n3. on letter **a**: { \"i\": 1, \"e\" : 1, \"a\" : 1 }\\n4. on letter **a**: { \"i\": 1, \"e\" : 1 }\\n\\nHashtables on step 2 and step 4 hashtable looks the same.\\nSubstract them from each other { \"i\": 1, \"e\" : 1 } -  { \"i\": 1, \"e\" : 1 } = {} \\nWe will get an empty hashtable = even vowel substring with length 4 - 2 = 2\\n\\n## Replace hashtable with bitmask\\nLet\\'s encode hashtable it a bitmask. \\n``a e i o u``\\n``0 1 1 0 0`` is a bitmask for { \"i\": 1, \"e\" : 1 }.\\n\\n``a e i o u``\\n``1 0 1 0 1`` is a bitmask for { \"a\": 1, \"i\" : 1, \"u\" : 1 }.\\n\\n``a e i o u``\\n``0 0 0 0 0`` is a bitmask for {}. So empty hashtable == 0.\\n\\nSpeaking binary:\\n1 == 0\\n2 == 10\\n4 == 100\\n8 == 1000\\n16 == 10000\\n\\nE.g. we encode { \"i\": 1, \"e\" : 1 } as 01100 = 1100 = 12\\n\\n## XOR operation\\n\\n^ is the binary operation of XOR. It\\'s perfect for the situation. \\uD83D\\uDC4C\\n\\n- 1 ^ 1 = 0 odd + odd = even\\n- 1 ^ 0 = 1 odd + even = odd\\n- 0 ^ 1 = 1 even + odd = odd\\n- 0 ^ 0 = 0 even + even = even\\n\\n# Approach\\n1. Go through the string recording current hashtable (bitmask) \\u2705 \\n2. If this hashtable (bitmask) was seen before, calculate potential substring length \\u2705 \\n\\n# Complexity\\n## Time complexity: O(n)\\nWe go through the string once.\\n\\n## Space complexity: O(1)\\nWe store the code for each letter and all the possible bitmasks. \\nAs we have only 5 letters, it\\'s 2^5 = 32 = constant complexy.\\n\\n# Code \\n## Python\\n```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        map = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16}\\n        first_time = { 0 : -1 } # first time we encounter 0 mask at index -1\\n        cur_mask = 0\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] in map:\\n                cur_mask ^= map[s[i]]\\n            if cur_mask in first_time:\\n                max_len = max(max_len, i - first_time[cur_mask])\\n            else:\\n                first_time[cur_mask] = i\\n        return max_len\\n```\\n## Javascript\\n```js\\nvar findTheLongestSubstring = function(s) {\\n    let mapping = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16};\\n    let firstTime = new Map();\\n    firstTime.set(0, -1); // mask 0 has index -1\\n    let curMask = 0;\\n    let maxLen = 0;\\n\\n    for (let i in s) {\\n        if (s[i] in mapping) {\\n            curMask ^= mapping[s[i]];\\n        }\\n        if (firstTime.has(curMask)) {\\n            start = firstTime.get(curMask);\\n            maxLen = Math.max(i - start, maxLen);\\n        } else {\\n            firstTime.set(curMask, i);\\n        }   \\n    }\\n    return maxLen; \\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Hash Table",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        map = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16}\\n        first_time = { 0 : -1 } # first time we encounter 0 mask at index -1\\n        cur_mask = 0\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] in map:\\n                cur_mask ^= map[s[i]]\\n            if cur_mask in first_time:\\n                max_len = max(max_len, i - first_time[cur_mask])\\n            else:\\n                first_time[cur_mask] = i\\n        return max_len\\n```\n```js\\nvar findTheLongestSubstring = function(s) {\\n    let mapping = {\"a\" : 1, \"e\" : 2, \"i\" : 4, \"o\" : 8, \"u\" : 16};\\n    let firstTime = new Map();\\n    firstTime.set(0, -1); // mask 0 has index -1\\n    let curMask = 0;\\n    let maxLen = 0;\\n\\n    for (let i in s) {\\n        if (s[i] in mapping) {\\n            curMask ^= mapping[s[i]];\\n        }\\n        if (firstTime.has(curMask)) {\\n            start = firstTime.get(curMask);\\n            maxLen = Math.max(i - start, maxLen);\\n        } else {\\n            firstTime.set(curMask, i);\\n        }   \\n    }\\n    return maxLen; \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065640,
                "title": "c-solution-o-n-time",
                "content": "This problem is similar to Longest subarray of sum 0\\n\\nWe can take prefix xor and use mask to track even counts\\nMask = 0 represent all the vowels are even.\\nAlso, if mask at i == mask at j, then mask at i+1 to j = 0\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int map[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        unordered_map<int,int> um;\\n        um[0] = -1;\\n        int mask = 0,ans = 0;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            mask ^= map[s[i]-\\'a\\'];\\n            if(um.find(mask)!=um.end())\\n                ans = max(ans,i-um[mask]);\\n            else\\n                um[mask] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int map[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        unordered_map<int,int> um;\\n        um[0] = -1;\\n        int mask = 0,ans = 0;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            mask ^= map[s[i]-\\'a\\'];\\n            if(um.find(mask)!=um.end())\\n                ans = max(ans,i-um[mask]);\\n            else\\n                um[mask] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407696,
                "title": "simple-python-commented-line-by-line",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define a dict for number of left shifts for each vowel\\n        vowel2shift = {\\'a\\': 4, \\'e\\': 3, \\'i\\': 2, \\'o\\': 1, \\'u\\': 0}\\n        # define a dict for the index of first appearance of a specific parity\\n        parity2firstIdx = {0: -1}\\n        # parity initialized to 00000, each vowel appear 0 time which is even\\n        ret = parity = 0\\n        # iterate through each letter of s\\n        for i, letter in enumerate(s):\\n            # if letter is a vowel, swap/toggle its corresponding bit\\n            if letter in vowel2shift:\\n                parity ^= 1 << vowel2shift[letter]\\n            # if we\\'ve seen this particular parity before, it means each vowel \\n            # appeared an even number of time between now and then\\n            # odd + even = odd\\n            # even + even = even\\n            if parity in parity2firstIdx:\\n                ret = max(ret, i-parity2firstIdx[parity])\\n            # otherwise, record its index of first appearance\\n            else:\\n                parity2firstIdx[parity] = i\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define a dict for number of left shifts for each vowel\\n        vowel2shift = {\\'a\\': 4, \\'e\\': 3, \\'i\\': 2, \\'o\\': 1, \\'u\\': 0}\\n        # define a dict for the index of first appearance of a specific parity\\n        parity2firstIdx = {0: -1}\\n        # parity initialized to 00000, each vowel appear 0 time which is even\\n        ret = parity = 0\\n        # iterate through each letter of s\\n        for i, letter in enumerate(s):\\n            # if letter is a vowel, swap/toggle its corresponding bit\\n            if letter in vowel2shift:\\n                parity ^= 1 << vowel2shift[letter]\\n            # if we\\'ve seen this particular parity before, it means each vowel \\n            # appeared an even number of time between now and then\\n            # odd + even = odd\\n            # even + even = even\\n            if parity in parity2firstIdx:\\n                ret = max(ret, i-parity2firstIdx[parity])\\n            # otherwise, record its index of first appearance\\n            else:\\n                parity2firstIdx[parity] = i\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302845,
                "title": "python-bitmask-concise-solution-o-n",
                "content": "The algorithm is straightforward. \\n1. Update bitmask and remember the leftmost index of the mask only if the character belongs to \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'\\n2. Get the maximum. If the mask is zero, it means the number of aeiou is even so far. Else, the length would be current index - last index\\nTime complexity O(n)\\nSpace complexity O(1)\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        m = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        cnt = [float(\\'inf\\')] * 32 # idx 0 to 31\\n        mask = maxval = 0 \\n        for i, c in enumerate(s):\\n            if c in m:\\n                mask ^= 1 << m[c] # update bit mask\\n                cnt[mask] = min(cnt[mask], i) # remember of leftmost index for same mask\\n            maxval = max(maxval, i + 1) if mask == 0 else max(maxval, i - cnt[mask]) \\n                \\n        return maxval\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        m = {\\'a\\': 0, \\'e\\': 1, \\'i\\': 2, \\'o\\': 3, \\'u\\': 4}\\n        cnt = [float(\\'inf\\')] * 32 # idx 0 to 31\\n        mask = maxval = 0 \\n        for i, c in enumerate(s):\\n            if c in m:\\n                mask ^= 1 << m[c] # update bit mask\\n                cnt[mask] = min(cnt[mask], i) # remember of leftmost index for same mask\\n            maxval = max(maxval, i + 1) if mask == 0 else max(maxval, i - cnt[mask]) \\n                \\n        return maxval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258675,
                "title": "java-bit-masking-sliding-window-logic-o-n-solution",
                "content": "# Algorithm in words: \\nfor every character in the string we do the following :\\n\\nbitmasking : integer x to keep track of even or odd count of each vowel\\n\\t\\t\\t     \\t\\n\\t\\tx     ------------>\\t\\t\\t0      0      0      0     0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu      o      i      e     a\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t16     8      4      2     1\\n\\nif the current character is vowel and lets say it is equal to \\'o\\' we do xor of x and the value from \\'vowelMask\\' i.e, vowelMask.get(\\'o\\') .By doing xor we change the current bit position of \\'o\\' state in x to 1 if it was 0 otherwise to 0. \\nif current vowel posistion has bit 0, it has even count until now, otherwise it is odd\\n\\nAfter bitmasking, we check whether the current state - x is already present in the hashmap, if it is present, we get the index from the hashmap where it has occured 1st (Say j), which means in between indices j and i, we have vowel count as even. so we update maxLength by checking if j-i is greater than maxLength\\n\\nIf the current state - x is not present in the hashmap we add it to the hashmap as key and index as current index\\n\\n# Code\\n\\n```\\nclass Solution {\\n    HashMap<Character, Integer> vowelMask = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\',1);\\n            put(\\'e\\',2);\\n            put(\\'i\\',4);\\n            put(\\'o\\',8);\\n            put(\\'u\\',16);\\n        }\\n    };\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> hmap = new HashMap<Integer, Integer>();\\n        hmap.put(0,-1);\\n        int maxLength = 0;\\n        int x = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(vowelMask.containsKey(s.charAt(i))) {\\n                x = x ^ vowelMask.get(s.charAt(i));\\n            }\\n            if(hmap.containsKey(x)) {\\n                maxLength = Math.max(maxLength,i - hmap.get(x));\\n            }\\n            else {\\n                hmap.put(x, i);\\n            }\\n            \\n        }\\n        return maxLength; \\n    }\\n}\\n```\\n\\n# Tracing:\\n\\nExample : \"eleetminicoworoep\"\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvowelMask :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'a\\'  ----------->             1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'e\\'  ------------>           10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'i\\'  ------------>          100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'o\\'  ------------>         1000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'u\\'  ------------>        10000\\n\\t\\t\\n\\tindex          vowel                     x value                                            hmap                                 maxLength\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   00000  : -1                              0\\n\\t0(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   hmap(00010) ---------  (not exists)   --------->    00010 :  0                              0\\n\\t1(l)               X                   hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = Maximum(0, 1 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1 \\n\\t2(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   =  00000  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(1, 2 - (-1))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t3(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 3 - 0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t4(t)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 4 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4\\n\\t5(m)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(4, 5 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t6(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 00010 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 00110                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t hmap(00110) ---------   (not exists)   --------->    00110 :  6                           5\\n\\t7(n)               X                     hmap(00110)               ---------------            (exists)                          Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     = Maximum(5, 7 - 6))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t8(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      x = 00110 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(00010)                ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(5, 8 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   8 \\n\\t9(c)               X                      hmap(00010)               ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         = Maximum(8, 9 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n    10(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(01010) ---------   (not exists)   --------->    01010 :  10                         9\\n\\t11(w)              X                      hmap(01010)              ----------------            (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = aximum(8, 11 - 10))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n\\t12(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       x = 01010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   map(00010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(9, 12 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t12\\n\\t13(r)              X                       hmap(00010)                 ---------------         (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(12, 13 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t13\\n    14(o)              O                             x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(01010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 14- 10)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    13\\n\\t15(e)              O                              x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 01010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 01000                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(01000) ---------   (not exists)   --------->  01010 :  15                          13\\n\\t16(p)              X                         hmap(01000)                ---------------           (exists)                       Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 16 - 15))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 13\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Character, Integer> vowelMask = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\',1);\\n            put(\\'e\\',2);\\n            put(\\'i\\',4);\\n            put(\\'o\\',8);\\n            put(\\'u\\',16);\\n        }\\n    };\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Integer, Integer> hmap = new HashMap<Integer, Integer>();\\n        hmap.put(0,-1);\\n        int maxLength = 0;\\n        int x = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            if(vowelMask.containsKey(s.charAt(i))) {\\n                x = x ^ vowelMask.get(s.charAt(i));\\n            }\\n            if(hmap.containsKey(x)) {\\n                maxLength = Math.max(maxLength,i - hmap.get(x));\\n            }\\n            else {\\n                hmap.put(x, i);\\n            }\\n            \\n        }\\n        return maxLength; \\n    }\\n}\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvowelMask :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'a\\'  ----------->             1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'e\\'  ------------>           10\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'i\\'  ------------>          100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'o\\'  ------------>         1000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\'u\\'  ------------>        10000\\n\\t\\t\\n\\tindex          vowel                     x value                                            hmap                                 maxLength\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   00000  : -1                              0\\n\\t0(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   hmap(00010) ---------  (not exists)   --------->    00010 :  0                              0\\n\\t1(l)               X                   hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = Maximum(0, 1 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1 \\n\\t2(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   =  00000  \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(00010)             ---------------             (exists)                             Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(1, 2 - (-1))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t3(e)               O                         x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t x = 00000 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 3 - 0)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   3\\n\\t4(t)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(3, 4 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4\\n\\t5(m)               X                     hmap(00010)             ---------------             (exists)                           Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(4, 5 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t6(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 00010 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 00110                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t hmap(00110) ---------   (not exists)   --------->    00110 :  6                           5\\n\\t7(n)               X                     hmap(00110)               ---------------            (exists)                          Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     = Maximum(5, 7 - 6))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   5\\n\\t8(i)               O                          x = x(xor)vowelMask.get(\\'i\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      x = 00110 ^ 00100\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(00010)                ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(5, 8 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   8 \\n\\t9(c)               X                      hmap(00010)               ---------------           (exists)                         Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         = Maximum(8, 9 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n    10(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  hmap(01010) ---------   (not exists)   --------->    01010 :  10                         9\\n\\t11(w)              X                      hmap(01010)              ----------------            (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = aximum(8, 11 - 10))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   9\\n\\t12(o)              O                           x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t       x = 01010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t= 00010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   map(00010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t = Maximum(9, 12 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t12\\n\\t13(r)              X                       hmap(00010)                 ---------------         (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(12, 13 - 0))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t13\\n    14(o)              O                             x = x(xor)vowelMask.get(\\'o\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     x = 00010 ^ 01000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   = 01010                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    hmap(01010)                 ---------------          (exists)                        Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 14- 10)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    13\\n\\t15(e)              O                              x = x(xor)vowelMask.get(\\'e\\')\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  x = 01010 ^ 00010\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    = 01000                                                              \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     hmap(01000) ---------   (not exists)   --------->  01010 :  15                          13\\n\\t16(p)              X                         hmap(01000)                ---------------           (exists)                       Maximum (maxLength, index - hmap.get(x))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  = Maximum(13, 16 - 15))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 13\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921145,
                "title": "o-n-solution-in-c-without-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef unordered_map<string, int> posMap;\\n    typedef unordered_map<char, int> cMap;\\n    \\n    // mark every position with 010101: 0 -> even, 1 -> odd\\n    // for every position, find the smallest matching string\\n    int findTheLongestSubstring(string s) {\\n        posMap indexes;\\n        cMap chars({{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}});\\n        string evenOdd = \"00000\";\\n        indexes[evenOdd] = -1;\\n        \\n        int length = 0;\\n        for (int i=0; i<s.size(); ++i) {\\n            char c = s[i];\\n            \\n            auto it = chars.find(c);\\n            if (it != chars.end()) {  // vowel\\n                evenOdd[it->second] = evenOdd[it->second] == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n            \\n            auto lastIndex = indexes.find(evenOdd);\\n            if (lastIndex == indexes.end()) {\\n                indexes[evenOdd] = i;\\n            } else {\\n                length = max(length, i - lastIndex->second);\\n            }\\n        }\\n        return length;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef unordered_map<string, int> posMap;\\n    typedef unordered_map<char, int> cMap;\\n    \\n    // mark every position with 010101: 0 -> even, 1 -> odd\\n    // for every position, find the smallest matching string\\n    int findTheLongestSubstring(string s) {\\n        posMap indexes;\\n        cMap chars({{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}});\\n        string evenOdd = \"00000\";\\n        indexes[evenOdd] = -1;\\n        \\n        int length = 0;\\n        for (int i=0; i<s.size(); ++i) {\\n            char c = s[i];\\n            \\n            auto it = chars.find(c);\\n            if (it != chars.end()) {  // vowel\\n                evenOdd[it->second] = evenOdd[it->second] == \\'0\\' ? \\'1\\' : \\'0\\';\\n            }\\n            \\n            auto lastIndex = indexes.find(evenOdd);\\n            if (lastIndex == indexes.end()) {\\n                indexes[evenOdd] = i;\\n            } else {\\n                length = max(length, i - lastIndex->second);\\n            }\\n        }\\n        return length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917460,
                "title": "c-easy-solution-using-map-single-parse-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        string val = \"00000\"; // This string denotes (number of occurence%2) of each vowel. Set all as 0 initially\\n        map<char, int> vowels = {{\\'a\\', 0},\\n                          {\\'e\\', 1},\\n                          {\\'i\\', 2},\\n                          {\\'o\\', 3},\\n                          {\\'u\\', 4}};\\n\\t\\t// The map indicates index of vowel in string val\\n        map<string, int> dict;\\n        int answer = 0, i = 0, size = s.length();\\n        if (size == 1) {\\n\\t\\t\\t// If size = 1; check if it is a vowel. If yes return 0, else 1\\n            if (vowels.find(s[0]) != vowels.end() ) return 0;\\n            return 1;\\n        }\\n        dict[val] = -1; // Set dict[\"00000\"] = -1 \\n        while (i < size) {\\n            if (vowels.find(s[i]) != vowels.end()) {\\n\\t\\t\\t\\t// if current element is a vowel, mark the bit in string val accordingly.\\n                int ind = vowels[s[i]];\\n                if (val[ind] == \\'0\\') {\\n\\t\\t\\t\\t\\t// This represents odd number of occurence\\n                    val[ind] = \\'1\\';\\n                } else {\\n\\t\\t\\t\\t\\t// This represents even number of occurence\\n                    if (val[ind] == \\'1\\') val[ind] = \\'0\\';\\n                }\\n            }\\n            if (dict.find(val) != dict.end()) {\\n\\t\\t\\t\\t// If the string val already exists in dict map, the string between first occurence and current index will have even occurence of vowels.\\n                answer = max(answer, i - dict[val]);\\n            } else {\\n\\t\\t\\t\\t// This combination has not been seen before. Store the index in dict.\\n                dict[val] = i;\\n            }\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        string val = \"00000\"; // This string denotes (number of occurence%2) of each vowel. Set all as 0 initially\\n        map<char, int> vowels = {{\\'a\\', 0},\\n                          {\\'e\\', 1},\\n                          {\\'i\\', 2},\\n                          {\\'o\\', 3},\\n                          {\\'u\\', 4}};\\n\\t\\t// The map indicates index of vowel in string val\\n        map<string, int> dict;\\n        int answer = 0, i = 0, size = s.length();\\n        if (size == 1) {\\n\\t\\t\\t// If size = 1; check if it is a vowel. If yes return 0, else 1\\n            if (vowels.find(s[0]) != vowels.end() ) return 0;\\n            return 1;\\n        }\\n        dict[val] = -1; // Set dict[\"00000\"] = -1 \\n        while (i < size) {\\n            if (vowels.find(s[i]) != vowels.end()) {\\n\\t\\t\\t\\t// if current element is a vowel, mark the bit in string val accordingly.\\n                int ind = vowels[s[i]];\\n                if (val[ind] == \\'0\\') {\\n\\t\\t\\t\\t\\t// This represents odd number of occurence\\n                    val[ind] = \\'1\\';\\n                } else {\\n\\t\\t\\t\\t\\t// This represents even number of occurence\\n                    if (val[ind] == \\'1\\') val[ind] = \\'0\\';\\n                }\\n            }\\n            if (dict.find(val) != dict.end()) {\\n\\t\\t\\t\\t// If the string val already exists in dict map, the string between first occurence and current index will have even occurence of vowels.\\n                answer = max(answer, i - dict[val]);\\n            } else {\\n\\t\\t\\t\\t// This combination has not been seen before. Store the index in dict.\\n                dict[val] = i;\\n            }\\n            i++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862660,
                "title": "straightforward-js-solution",
                "content": "```\\nvar findTheLongestSubstring = function(s) {\\n    for (let k = s.length-1; k >= 0; k--) {\\n        let i = 0, j = k;\\n        while (j < s.length) {\\n            if (evenVowels(s.substring(i,j+1))) return j-i+1;\\n            i++, j++;\\n        }\\n    }\\n    return 0;\\n    // Time Complexity: O(n^2)\\n    // Space Complexity: O(n)\\n};\\n\\nvar evenVowels = function(str) {\\n    let m = new Map();\\n    let vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'];\\n    for (let letter of str) {\\n        if (vowels.includes(letter)) m.set(letter, m.get(letter)+1 || 1);\\n    }\\n    let occurrences = Array.from(m.values()).filter(num => (num%2) === 1);\\n    return occurrences.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findTheLongestSubstring = function(s) {\\n    for (let k = s.length-1; k >= 0; k--) {\\n        let i = 0, j = k;\\n        while (j < s.length) {\\n            if (evenVowels(s.substring(i,j+1))) return j-i+1;\\n            i++, j++;\\n        }\\n    }\\n    return 0;\\n    // Time Complexity: O(n^2)\\n    // Space Complexity: O(n)\\n};\\n\\nvar evenVowels = function(str) {\\n    let m = new Map();\\n    let vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'];\\n    for (let letter of str) {\\n        if (vowels.includes(letter)) m.set(letter, m.get(letter)+1 || 1);\\n    }\\n    let occurrences = Array.from(m.values()).filter(num => (num%2) === 1);\\n    return occurrences.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 802423,
                "title": "java-masking-o-n",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Character,Integer> mp = new HashMap();\\n        mp.put(\\'a\\',0);mp.put(\\'e\\',1);mp.put(\\'i\\',2);mp.put(\\'o\\',3);mp.put(\\'u\\',4);\\n        HashMap<Integer, Integer> mps = new HashMap();\\n        mps.put(0,-1);\\n        int msk=0, ans =0;\\n        for(int i=0;i<s.length();i++){\\n            if(mp.containsKey(s.charAt(i)))\\n                msk = msk^(1<<(mp.get(s.charAt(i))+1));\\n            if(mps.containsKey(msk))\\n                ans= Math.max(ans,i-mps.get(msk));\\n            else\\n                mps.put(msk,i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        HashMap<Character,Integer> mp = new HashMap();\\n        mp.put(\\'a\\',0);mp.put(\\'e\\',1);mp.put(\\'i\\',2);mp.put(\\'o\\',3);mp.put(\\'u\\',4);\\n        HashMap<Integer, Integer> mps = new HashMap();\\n        mps.put(0,-1);\\n        int msk=0, ans =0;\\n        for(int i=0;i<s.length();i++){\\n            if(mp.containsKey(s.charAt(i)))\\n                msk = msk^(1<<(mp.get(s.charAt(i))+1));\\n            if(mps.containsKey(msk))\\n                ans= Math.max(ans,i-mps.get(msk));\\n            else\\n                mps.put(msk,i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724007,
                "title": "sliding-window-technique-quite-easy-to-read",
                "content": "\\n\\nclass Solution {\\n\\n    public int findTheLongestSubstring(String s) {\\n        \\n        int[] map=new int[26];\\n        int[] vov={0,4,8,14,20};\\n        \\n        char[] ar=s.toCharArray();\\n        int n=ar.length;\\n        int l=0,maxlen=-1;\\n        \\n        \\n        for (int i=0;i<n;i++){\\n\\n            int v=ar[i]-\\'a\\';\\n            if (v==0 || v==4 || v==8 || v==14 || v==20){\\n                map[v]++;\\n            }\\n            int[] temp= Arrays.copyOf(map,map.length);\\n            while (temp[0]%2==1 || temp[4]%2==1||temp[8]%2==1||temp[14]%2==1 || temp[20]%2==1){\\n                int left=ar[l]-\\'a\\';\\n                if(left==0 || left==4 || left==8 ||left==14 ||left==20){\\n                    temp[left]--;\\n                }\\n                l++;\\n            }\\n            maxlen=Math.max(maxlen,i-l+1);\\n            l=0;\\n\\n        }\\n        \\n        return maxlen;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int findTheLongestSubstring(String s) {\\n        \\n        int[] map=new int[26];\\n        int[] vov={0,4,8,14,20}",
                "codeTag": "Java"
            },
            {
                "id": 722093,
                "title": "java-o-n-one-pass-solution-with-maps-with-string-keys",
                "content": "Use a String key to represent the state of all vowels (even or odd)\\nsubarray satisfying condition will be when the same exact state was first found\\n```\\nclass Solution {\\n    \\n    Map<Character, Integer> charToPosition = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 0); put(\\'e\\', 1); put(\\'i\\', 2); put(\\'o\\', 3); put(\\'u\\', 4);\\n        }\\n    };\\n    \\n    private String transition(String state, char vowel) {\\n        int position = charToPosition.get(vowel);\\n        String newBit = state.charAt(position) == \\'0\\' ? \"1\" : \"0\";\\n        StringBuffer sb = new StringBuffer(state);\\n        sb.replace(position, position + 1, newBit);\\n        return sb.toString();\\n    }\\n    \\n    public int findTheLongestSubstring(String s) {\\n        int answer = 0;\\n        Map<String, Integer> map = new HashMap<>();\\n        String state = \"00000\";\\n        map.put(state, -1);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (charToPosition.containsKey(c)) {\\n                state = transition(state, c);\\n                if (!map.containsKey(state)) {\\n                    map.put(state, i);\\n                }\\n            }\\n            answer = Math.max(answer, i - map.get(state));\\n        }        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Map<Character, Integer> charToPosition = new HashMap<Character, Integer>() {\\n        {\\n            put(\\'a\\', 0); put(\\'e\\', 1); put(\\'i\\', 2); put(\\'o\\', 3); put(\\'u\\', 4);\\n        }\\n    };\\n    \\n    private String transition(String state, char vowel) {\\n        int position = charToPosition.get(vowel);\\n        String newBit = state.charAt(position) == \\'0\\' ? \"1\" : \"0\";\\n        StringBuffer sb = new StringBuffer(state);\\n        sb.replace(position, position + 1, newBit);\\n        return sb.toString();\\n    }\\n    \\n    public int findTheLongestSubstring(String s) {\\n        int answer = 0;\\n        Map<String, Integer> map = new HashMap<>();\\n        String state = \"00000\";\\n        map.put(state, -1);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (charToPosition.containsKey(c)) {\\n                state = transition(state, c);\\n                if (!map.containsKey(state)) {\\n                    map.put(state, i);\\n                }\\n            }\\n            answer = Math.max(answer, i - map.get(state));\\n        }        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588983,
                "title": "convert-this-to-max-subarray-of-sum-equal-to-0",
                "content": "Well this is what i could come up with :), tired to write the explanation. however if u have any doubts or want an explanation feel free to ask in the comments.\\nThanks\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n       //convert the vowels in the string to 1 and -1 alternatively and we want the max substring length with sum equal to 0\\n        unordered_set<int> vowel;\\n        vector<int> arr;\\n        vowel.insert(\\'a\\');\\n        vowel.insert(\\'e\\');\\n        vowel.insert(\\'i\\');\\n        vowel.insert(\\'o\\');\\n        vowel.insert(\\'u\\');\\n        int a=1,e=10,i=100,o=1000,u=10000;\\n        for(auto x:s){\\n            if(vowel.find(x)!=vowel.end())\\n            {   if(x==\\'a\\')\\n                {\\n                  arr.push_back(a*1);\\n                  a*=-1;\\n                }\\n               if(x==\\'e\\')\\n                {\\n                  arr.push_back(e*1);\\n                  e*=-1;\\n                }\\n             if(x==\\'i\\')\\n                {\\n                  arr.push_back(i*1);\\n                  i*=-1;\\n                }\\n             if(x==\\'o\\')\\n                {\\n                  arr.push_back(o*1);\\n                  o*=-1;\\n                }\\n             if(x==\\'u\\')\\n                {\\n                  arr.push_back(u*1);\\n                  u*=-1;\\n                }\\n            \\n            }\\n            else\\n                arr.push_back(0);\\n        }\\n        //https://www.***.org/find-the-largest-subarray-with-0-sum/\\n        unordered_map<int, int> presum; \\n        int sum = 0; // Initialize the sum of elements \\n        int max_len = 0; // Initialize result \\n    // Traverse through the given array \\n        for (int i = 0; i <arr.size(); i++) { \\n        // Add current element to sum \\n            sum += arr[i]; \\n            if (arr[i] == 0 && max_len == 0) \\n                max_len = 1; \\n            if (sum == 0) \\n                max_len = i + 1; \\n            // Look for this sum in Hash table \\n            if (presum.find(sum) != presum.end()) { \\n                // If this sum is seen before, then update max_len \\n                max_len = max(max_len, i - presum[sum]); \\n            } \\n            else { \\n                // Else insert this sum with index in hash table \\n                presum[sum] = i; } } \\n    return max_len; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n       //convert the vowels in the string to 1 and -1 alternatively and we want the max substring length with sum equal to 0\\n        unordered_set<int> vowel;\\n        vector<int> arr;\\n        vowel.insert(\\'a\\');\\n        vowel.insert(\\'e\\');\\n        vowel.insert(\\'i\\');\\n        vowel.insert(\\'o\\');\\n        vowel.insert(\\'u\\');\\n        int a=1,e=10,i=100,o=1000,u=10000;\\n        for(auto x:s){\\n            if(vowel.find(x)!=vowel.end())\\n            {   if(x==\\'a\\')\\n                {\\n                  arr.push_back(a*1);\\n                  a*=-1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 550370,
                "title": "c-concise-solution-using-bitmask-and-explained-thought-process",
                "content": "I was just revisiting another problem which is very similar in implementation before moving on to this problem: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n\\nI was initially completely stuck on this problem and thought it\\'s supposed to be a \"hard\" problem. I started with greedy, consider if one longest substring must be prefix and suffix but don\\'t think that\\'s the case.\\n\\nI then **simplified** the problem and think of only two digits 0 and 1, you would like to get longest consecutive subarray with even number of 1s. This is very classic problem and obviously we can consider the prefix sum of this array, and would like to pick two numbers with same parity that are farthest apart. We can implement with an index from parity (0, 1) to leftmost index, and check whenever current prefix sum parity matches that index, record its sum.\\n\\nThen it instantly strikes me that I can generalize it to a (parity count of \\'a\\', parity count of \\'e\\', ...) profile for each prefix. And it essentially become the simplified problem. The implementation is just the standard part. You can even consider using a hash map from \\'ae\\' (representing odd number of a and e, even number of i, o, u) to leftmost index of this prefix pattern\\'s occurrence.\\n\\nHope this thought process helps. My general recommendation is to simplify a problem whenever you can, and also identify similar patterns in other problems, convert the problem statement from string to array and vice versa.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> map = {\\n            {\\'a\\', 0},\\n            {\\'e\\', 1},\\n            {\\'i\\', 2},\\n            {\\'o\\', 3},\\n            {\\'u\\', 4},\\n        };\\n        int n = s.size();\\n        int best_l = 0;\\n        int mask = 0;\\n        unordered_map<int, int> index;\\n        index[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (map.find(s[i]) != map.end()) {\\n                mask ^= (1 << map.at(s[i]));\\n            }\\n            if (index.find(mask) != index.end()) {\\n                best_l = max(best_l, i - index.at(mask));\\n            } else index[mask] = i;\\n        }\\n        return best_l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> map = {\\n            {\\'a\\', 0},\\n            {\\'e\\', 1},\\n            {\\'i\\', 2},\\n            {\\'o\\', 3},\\n            {\\'u\\', 4},\\n        };\\n        int n = s.size();\\n        int best_l = 0;\\n        int mask = 0;\\n        unordered_map<int, int> index;\\n        index[0] = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (map.find(s[i]) != map.end()) {\\n                mask ^= (1 << map.at(s[i]));\\n            }\\n            if (index.find(mask) != index.end()) {\\n                best_l = max(best_l, i - index.at(mask));\\n            } else index[mask] = i;\\n        }\\n        return best_l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531956,
                "title": "c-o-n-find-the-complementary-states-to-get-even-counts",
                "content": "```csharp\\npublic class Solution \\n{\\n    public int FindTheLongestSubstring(string s)\\n    {\\n        Dictionary<char, int> vowels = new Dictionary<char, int>()\\n        {\\n            [\\'a\\'] = 1,\\n            [\\'e\\'] = 2,\\n            [\\'i\\'] = 4,\\n            [\\'o\\'] = 8,\\n            [\\'u\\'] = 16\\n        };\\n\\n        // Sum of all vowels visited once - max possible count of states\\n        int[] firstStateVisited = new int[32];\\n        for (int i = 0; i < firstStateVisited.Length; i++)\\n        {\\n            firstStateVisited[i] = -1;\\n        }\\n        firstStateVisited[0] = 0;\\n        int maxLength = 0;\\n        int currentState = 0;\\n\\n        for (int current = 0; current < s.Length; current++)\\n        {\\n            if (vowels.ContainsKey(s[current]))\\n            {\\n                currentState ^= vowels[s[current]];\\n            }\\n\\n            if (firstStateVisited[currentState] == -1)\\n            {\\n                firstStateVisited[currentState] = current + 1;\\n            }\\n\\n            maxLength = Math.Max(maxLength, current - firstStateVisited[currentState] + 1);                \\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public int FindTheLongestSubstring(string s)\\n    {\\n        Dictionary<char, int> vowels = new Dictionary<char, int>()\\n        {\\n            [\\'a\\'] = 1,\\n            [\\'e\\'] = 2,\\n            [\\'i\\'] = 4,\\n            [\\'o\\'] = 8,\\n            [\\'u\\'] = 16\\n        };\\n\\n        // Sum of all vowels visited once - max possible count of states\\n        int[] firstStateVisited = new int[32];\\n        for (int i = 0; i < firstStateVisited.Length; i++)\\n        {\\n            firstStateVisited[i] = -1;\\n        }\\n        firstStateVisited[0] = 0;\\n        int maxLength = 0;\\n        int currentState = 0;\\n\\n        for (int current = 0; current < s.Length; current++)\\n        {\\n            if (vowels.ContainsKey(s[current]))\\n            {\\n                currentState ^= vowels[s[current]];\\n            }\\n\\n            if (firstStateVisited[currentState] == -1)\\n            {\\n                firstStateVisited[currentState] = current + 1;\\n            }\\n\\n            maxLength = Math.Max(maxLength, current - firstStateVisited[currentState] + 1);                \\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531916,
                "title": "c-o-n-bitmask-solution-similar-to-longest-subarray-w-sum-k",
                "content": "We use a bitmask to represent a state for whether each  vowel count is even or odd. Then, we just have to check if we have seen the same mask previously (if they subtract, we get all 0s, so the substring between these two indices is a valid substring). If we have, then we get the difference between the two, and check if it is greater than max. \\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(const string& s) {\\n        int max_ = 0;\\n        unordered_map<int, int> m = {{0,-1}};\\n        for(int i = 0, mask = 0, size = s.size(); i < size; ++i) {\\n            mask ^= (1<<(s[i]-\\'a\\'))&vowels;\\n            if(m.count(mask)) max_ = max(max_, i-m[mask]);\\n            else m[mask] = i;\\n        }\\n        return max_;\\n    }\\n    static const int vowels = 0 | (1<<(\\'a\\'-\\'a\\')) | (1<<(\\'e\\'-\\'a\\')) | (1<<(\\'i\\'-\\'a\\')) | (1<<(\\'o\\'-\\'a\\')) | (1<<(\\'u\\'-\\'a\\'));\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(const string& s) {\\n        int max_ = 0;\\n        unordered_map<int, int> m = {{0,-1}};\\n        for(int i = 0, mask = 0, size = s.size(); i < size; ++i) {\\n            mask ^= (1<<(s[i]-\\'a\\'))&vowels;\\n            if(m.count(mask)) max_ = max(max_, i-m[mask]);\\n            else m[mask] = i;\\n        }\\n        return max_;\\n    }\\n    static const int vowels = 0 | (1<<(\\'a\\'-\\'a\\')) | (1<<(\\'e\\'-\\'a\\')) | (1<<(\\'i\\'-\\'a\\')) | (1<<(\\'o\\'-\\'a\\')) | (1<<(\\'u\\'-\\'a\\'));\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4107053,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // taken help as for my code TLE T.C = (n^2);\\n\\n/*    static boolean check(String s){\\n        int n = s.length();\\n\\n        int arr[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            int a = s.charAt(i)-97;\\n            arr[a]++;\\n        }\\n\\n        if(arr[0]%2!=0 || arr[4]%2!=0 || arr[8]%2!=0 || arr[14]%2!=0 ||arr[20]%2!=0) return false;\\n        else return true; \\n    }\\n\\n    static int helper(String str){\\n        int ans = 0;\\n        int n = str.length();\\n        StringBuilder s = new StringBuilder(str);\\n\\n        for(int k=1; k<=n; k++){\\n            for(int i=0; i<=n-k; i++){\\n                String x = s.substring(i,i+k);\\n                if(check(x)){\\n                    ans = Math.max(ans,k);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    */\\n    public int findTheLongestSubstring(String s) {\\n\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // taken help as for my code TLE T.C = (n^2);\\n\\n/*    static boolean check(String s){\\n        int n = s.length();\\n\\n        int arr[] = new int[26];\\n\\n        for(int i=0; i<n; i++){\\n            int a = s.charAt(i)-97;\\n            arr[a]++;\\n        }\\n\\n        if(arr[0]%2!=0 || arr[4]%2!=0 || arr[8]%2!=0 || arr[14]%2!=0 ||arr[20]%2!=0) return false;\\n        else return true; \\n    }\\n\\n    static int helper(String str){\\n        int ans = 0;\\n        int n = str.length();\\n        StringBuilder s = new StringBuilder(str);\\n\\n        for(int k=1; k<=n; k++){\\n            for(int i=0; i<=n-k; i++){\\n                String x = s.substring(i,i+k);\\n                if(check(x)){\\n                    ans = Math.max(ans,k);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    */\\n    public int findTheLongestSubstring(String s) {\\n\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854980,
                "title": "java-fastest-solution-beats-100-xor",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int[] map = new int[32];\\n        Arrays.fill(map, -2);\\n        map[0] = -1;\\n        int n = s.length(), mask = 0, len = 0;\\n        for (int i = 0; i < n; i++) {\\n            char ch = s.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') mask ^= 1 << (4 -\\n                    (ch == \\'a\\' ? 0 : ch == \\'e\\' ? 1 : ch == \\'i\\' ? 2 : ch == \\'o\\' ? 3 : 4));\\n            if (map[mask] == -2) map[mask] = i;\\n            else len = Math.max(len, i - map[mask]);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026617,
                "title": "easy-c-intuitive-subarray-approach-unordered-map",
                "content": "\\n\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s)\\n    {\\n\\t\\n\\t\\n        //true - even\\n        //false - odd\\n        unordered_map<vector<bool>, int>mp;\\n\\t\\t//           [0s & 1s],  index\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        int a = 0;\\n        int e = 0;\\n        int i = 0;\\n        int o = 0;\\n        int u = 0;\\n        \\n        for(int j = 0; j<s.size(); j++)\\n        {\\n            if(s[j] == \\'a\\')\\n            {\\n                a++;\\n            }\\n            if(s[j] == \\'e\\')\\n            {\\n                e++;\\n            }\\n            if(s[j] == \\'i\\')\\n            {\\n                i++;\\n            }\\n            if(s[j] == \\'o\\')\\n            {\\n                o++;\\n            }\\n            if(s[j] == \\'u\\')\\n            {\\n                u++;\\n            }\\n            \\n            vector<bool>temp;\\n            temp.push_back(a%2);\\n            temp.push_back(e%2);\\n            temp.push_back(i%2);\\n            temp.push_back(o%2);\\n            temp.push_back(u%2);\\n            \\n            \\n            if(a%2==0 && e%2==0 && i%2==0 && o%2==0 && u%2==0)\\n            {\\n\\t\\t\\t// if all evens \\n                ans = j+1;\\n            }\\n            else if(mp.find(temp) != mp.end())\\n            {\\n\\t\\t\\t// if patteren of odds and evens already present \\n                ans = max(ans, j - mp[temp]);\\n            }\\n            else\\n\\t\\t\\t// to store every unique pattern\\n                mp[temp] = j;\\n            \\n        }\\n\\t\\t\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s)\\n    {\\n\\t\\n\\t\\n        //true - even\\n        //false - odd\\n        unordered_map<vector<bool>, int>mp;\\n\\t\\t//           [0s & 1s],  index\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        int a = 0;\\n        int e = 0;\\n        int i = 0;\\n        int o = 0;\\n        int u = 0;\\n        \\n        for(int j = 0; j<s.size(); j++)\\n        {\\n            if(s[j] == \\'a\\')\\n            {\\n                a++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2291321,
                "title": "c-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    //This problem is very much similar to \\'Subarray Sum equals k\\'\\n    //What we will try to do is :\\n    //1. we will create a bitmask that will signify us that whether the count of vowels is even or odd\\n    //2. we will store the index of first occurence of every unique bitmask in map\\n    //3. by using the idea in 2nd point while moving ahead if a bitmask repeats that means there is a substring that has even count of all the vowels b/w the curr index and the first occurence that was stored in the map, so we can simply update our answer by comparing the previous answer from such string\\n    \\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        unordered_map<char,int> bitvalue ={\\n            {\\'a\\',1},\\n            {\\'e\\',2},\\n            {\\'i\\',4},\\n            {\\'o\\',8},\\n            {\\'u\\',16}\\n        };\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            mask ^= bitvalue[s[i]];\\n            if(mask!=0 && !m.count(mask)){\\n                m[mask] = i;\\n            }\\n            ans = max(ans,i-m[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote** if you find this post useful",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //This problem is very much similar to \\'Subarray Sum equals k\\'\\n    //What we will try to do is :\\n    //1. we will create a bitmask that will signify us that whether the count of vowels is even or odd\\n    //2. we will store the index of first occurence of every unique bitmask in map\\n    //3. by using the idea in 2nd point while moving ahead if a bitmask repeats that means there is a substring that has even count of all the vowels b/w the curr index and the first occurence that was stored in the map, so we can simply update our answer by comparing the previous answer from such string\\n    \\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        unordered_map<char,int> bitvalue ={\\n            {\\'a\\',1},\\n            {\\'e\\',2},\\n            {\\'i\\',4},\\n            {\\'o\\',8},\\n            {\\'u\\',16}\\n        };\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            mask ^= bitvalue[s[i]];\\n            if(mask!=0 && !m.count(mask)){\\n                m[mask] = i;\\n            }\\n            ans = max(ans,i-m[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242173,
                "title": "simple-c-code-75-time-90-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool CheckVowels(char &m)\\n    {\\n        if(m == \\'a\\' || m == \\'e\\' || m == \\'i\\' || m == \\'o\\' || m == \\'u\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> um;\\n        um[0] = 0;\\n        int curr = 0;\\n        int i = 1, ans = 0;\\n        for(char &ch : s)\\n        {\\n            if(CheckVowels(ch))\\n            {\\n                curr ^= ch;   \\n            }\\n            if(um.count(curr))\\n            {\\n                ans = max(i-um[curr], ans);\\n            }\\n            else\\n            {\\n                um[curr] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    bool CheckVowels(char &m)\\n    {\\n        if(m == \\'a\\' || m == \\'e\\' || m == \\'i\\' || m == \\'o\\' || m == \\'u\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> um;\\n        um[0] = 0;\\n        int curr = 0;\\n        int i = 1, ans = 0;\\n        for(char &ch : s)\\n        {\\n            if(CheckVowels(ch))\\n            {\\n                curr ^= ch;   \\n            }\\n            if(um.count(curr))\\n            {\\n                ans = max(i-um[curr], ans);\\n            }\\n            else\\n            {\\n                um[curr] = i;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192176,
                "title": "most-simple-and-easy-solution-bit-mask",
                "content": "```\\nclass Solution {\\n     public int findTheLongestSubstring(String s) {\\n        int res = 0 , mask = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();// key--> Mask, value--> Index\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){ // check only vowels and skip consonant\\n                int c=s.charAt(i);\\n                mask=mask ^ c;\\n                seen.putIfAbsent(mask, i);\\n            }            \\n            res = Math.max(res, i - seen.get(mask));\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int findTheLongestSubstring(String s) {\\n        int res = 0 , mask = 0, n = s.length();\\n        HashMap<Integer, Integer> seen = new HashMap<>();// key--> Mask, value--> Index\\n        seen.put(0, -1);\\n        for (int i = 0; i < n; ++i) {\\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){ // check only vowels and skip consonant\\n                int c=s.charAt(i);\\n                mask=mask ^ c;\\n                seen.putIfAbsent(mask, i);\\n            }            \\n            res = Math.max(res, i - seen.get(mask));\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155290,
                "title": "step-by-step-c-solution",
                "content": "* Do Xor with the mask if the character is vowel \\n* for others do nothing as (0 ^ a =a)\\n* use prefix sum concept and you will make it\\n```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0,ans=0;\\n        unordered_map<int,int>m;\\n        m[mask]=-1;\\n        for(int i=0;i<s.length();i++){\\n            if(isvowel(s[i])){\\n                mask^=s[i];\\n            }\\n            if(m.count(mask)==0){\\n                m[mask]=i;\\n            }\\n            else{\\n                ans=max(ans,i-m[mask]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\'){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0,ans=0;\\n        unordered_map<int,int>m;\\n        m[mask]=-1;\\n        for(int i=0;i<s.length();i++){\\n            if(isvowel(s[i])){\\n                mask^=s[i];\\n            }\\n            if(m.count(mask)==0){\\n                m[mask]=i;\\n            }\\n            else{\\n                ans=max(ans,i-m[mask]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141578,
                "title": "java-simple-and-elegant-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    int getVowelIndex(char ch){\\n        switch(ch){\\n            case \\'a\\' : return 0;\\n            case \\'e\\' : return 1;\\n            case \\'i\\' : return 2;\\n            case \\'o\\' : return 3;\\n            case \\'u\\' : return 4;\\n            default : return -1;\\n        }\\n    }\\n    public int findTheLongestSubstring(String s) {\\n        int mask = 32-1;\\n        int n = s.length(),res = 0;\\n        int dp[] = new int[mask+1];\\n        Arrays.fill(dp,-2);\\n        dp[mask] = -1;\\n        for(int i = 0 ; i<n ; i++){\\n            int idx = getVowelIndex(s.charAt(i));\\n            if(idx!=-1){\\n                mask^=(1<<idx);\\n            }\\n            if(dp[mask]!=-2){\\n                res = Math.max(res,i-dp[mask]);\\n            }else{\\n                dp[mask] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int getVowelIndex(char ch){\\n        switch(ch){\\n            case \\'a\\' : return 0;\\n            case \\'e\\' : return 1;\\n            case \\'i\\' : return 2;\\n            case \\'o\\' : return 3;\\n            case \\'u\\' : return 4;\\n            default : return -1;\\n        }\\n    }\\n    public int findTheLongestSubstring(String s) {\\n        int mask = 32-1;\\n        int n = s.length(),res = 0;\\n        int dp[] = new int[mask+1];\\n        Arrays.fill(dp,-2);\\n        dp[mask] = -1;\\n        for(int i = 0 ; i<n ; i++){\\n            int idx = getVowelIndex(s.charAt(i));\\n            if(idx!=-1){\\n                mask^=(1<<idx);\\n            }\\n            if(dp[mask]!=-2){\\n                res = Math.max(res,i-dp[mask]);\\n            }else{\\n                dp[mask] = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646106,
                "title": "c-prefix-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<pair<int, int>> c;// storing vowels ans corresponding index in vector c\\n        vector<int >  t;\\n        int n = s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            {\\n                c.push_back({s[i],i});\\n                t.push_back(0);\\n            }\\n            else\\n                t.push_back(1);\\n        }\\n        \\n        // when there is no vowel, return s.length()\\n        if(c.size()==0)\\n            return n;\\n        //when there is only one vowel, return maximum of left and right substring of vowel length\\n        if(c.size()==1)\\n            return max(c[0].second,n-c[0].second-1);\\n        \\n        int max1 = INT_MIN;\\n        \\n        //considering only consonants, with 0 vowels means even vowels\\n        max1 = max(c[0].second, n-c.back().second-1);\\n        for(int i=1;i<c.size();i++)\\n            max1 = max(max1,c[i].second-c[i-1].second-1);\\n        \\n        // doing prefix XOR of vowels stored in vector c\\n        for(int i=1;i<c.size();i++)\\n            c[i].first^=c[i-1].first;\\n        \\n        // consdering vowels\\n        //calculating consonants before and after each vowel\\n        vector<int > left=t, right=t;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(left[i]==1)\\n                left[i]+=left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(right[i]==1)\\n                right[i]+=right[i+1];\\n        }\\n        \\n        // sotring each prefix XOR in map with corresponding vector of index\\n        map<int, vector<int >> mp;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i].first].push_back(c[i].second);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.first==0)// when prefix XOR is 0, means there is even count of all vowels from starting of string till index\\n            {\\n                int idx = it.second[it.second.size()-1];\\n                int sum1 = idx+1;\\n                if(idx<n-1)\\n                    sum1+=right[idx+1];\\n                max1 = max(max1,sum1);\\n            }\\n            else if(it.first!=0 && it.second.size()>1)// else when prefix XOR are equal\\n            {\\n                int idx1 = it.second[0],idx2 = it.second[it.second.size()-1];\\n                int sum1 = (idx2-idx1);\\n                if(idx2<n-1)\\n                    sum1+=right[idx2+1];\\n                max1 = max(max1, sum1);\\n            }\\n        }\\n        return max1;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<pair<int, int>> c;// storing vowels ans corresponding index in vector c\\n        vector<int >  t;\\n        int n = s.length();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\' || s[i]==\\'o\\' || s[i]==\\'u\\')\\n            {\\n                c.push_back({s[i],i});\\n                t.push_back(0);\\n            }\\n            else\\n                t.push_back(1);\\n        }\\n        \\n        // when there is no vowel, return s.length()\\n        if(c.size()==0)\\n            return n;\\n        //when there is only one vowel, return maximum of left and right substring of vowel length\\n        if(c.size()==1)\\n            return max(c[0].second,n-c[0].second-1);\\n        \\n        int max1 = INT_MIN;\\n        \\n        //considering only consonants, with 0 vowels means even vowels\\n        max1 = max(c[0].second, n-c.back().second-1);\\n        for(int i=1;i<c.size();i++)\\n            max1 = max(max1,c[i].second-c[i-1].second-1);\\n        \\n        // doing prefix XOR of vowels stored in vector c\\n        for(int i=1;i<c.size();i++)\\n            c[i].first^=c[i-1].first;\\n        \\n        // consdering vowels\\n        //calculating consonants before and after each vowel\\n        vector<int > left=t, right=t;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(left[i]==1)\\n                left[i]+=left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(right[i]==1)\\n                right[i]+=right[i+1];\\n        }\\n        \\n        // sotring each prefix XOR in map with corresponding vector of index\\n        map<int, vector<int >> mp;\\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i].first].push_back(c[i].second);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.first==0)// when prefix XOR is 0, means there is even count of all vowels from starting of string till index\\n            {\\n                int idx = it.second[it.second.size()-1];\\n                int sum1 = idx+1;\\n                if(idx<n-1)\\n                    sum1+=right[idx+1];\\n                max1 = max(max1,sum1);\\n            }\\n            else if(it.first!=0 && it.second.size()>1)// else when prefix XOR are equal\\n            {\\n                int idx1 = it.second[0],idx2 = it.second[it.second.size()-1];\\n                int sum1 = (idx2-idx1);\\n                if(idx2<n-1)\\n                    sum1+=right[idx2+1];\\n                max1 = max(max1, sum1);\\n            }\\n        }\\n        return max1;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530785,
                "title": "python-o-n-time-one-pass-solution",
                "content": "Use five bits to represent the vowels that have odd count, and record the left-most index for each status when they first show. Here is my code:\\n\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        indices = {a:i for i, a in enumerate(\\'aeiou\\')}\\n        lefts = {0:-1}\\n        res = status = 0\\n        for right, a in enumerate(s):\\n            if a in indices:\\n                status ^= 1 << indices[a]\\n                if status not in lefts:\\n                    lefts[status] = right\\n            res = max(res, right - lefts[status])\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        indices = {a:i for i, a in enumerate(\\'aeiou\\')}\\n        lefts = {0:-1}\\n        res = status = 0\\n        for right, a in enumerate(s):\\n            if a in indices:\\n                status ^= 1 << indices[a]\\n                if status not in lefts:\\n                    lefts[status] = right\\n            res = max(res, right - lefts[status])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428653,
                "title": "c-mask-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n      unordered_map<int,int> mp;\\n        int ans=0;\\n        int mask=0;\\n        mp[0]=-1;\\n        vector<int> v(27,0);\\n        v[\\'a\\'-97]=0;v[\\'e\\'-97]=1;v[\\'i\\'-97]=2;v[\\'o\\'-97]=3;v[\\'u\\'-97]=4;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int pos=v[s[i]-97];\\n                \\n                if(mask && (1<<pos))\\n                    mask=(mask^(1<<pos));\\n                else\\n                    mask=(mask|(1<<pos));\\n            }\\n            \\n            if(mp.count(mask))\\n              ans=max(ans,i-mp[mask]);  \\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n      unordered_map<int,int> mp;\\n        int ans=0;\\n        int mask=0;\\n        mp[0]=-1;\\n        vector<int> v(27,0);\\n        v[\\'a\\'-97]=0;v[\\'e\\'-97]=1;v[\\'i\\'-97]=2;v[\\'o\\'-97]=3;v[\\'u\\'-97]=4;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                int pos=v[s[i]-97];\\n                \\n                if(mask && (1<<pos))\\n                    mask=(mask^(1<<pos));\\n                else\\n                    mask=(mask|(1<<pos));\\n            }\\n            \\n            if(mp.count(mask))\\n              ans=max(ans,i-mp[mask]);  \\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394700,
                "title": "c-solution-o-n",
                "content": "Runtime: 52 ms, faster than 91.94% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\nMemory Usage: 16 MB, less than 97.48% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\n\\nNote: Solution taken from other post.\\n\\nThe solution of the problem uses the same technique as the solution of [525. Contiguous Array](https://leetcode.com/problems/contiguous-array/).\\n\\n```\\nHere we need to find the longest subarray containing even count of vowels only. We do not need to count\\nvowel occuerence but we need to track if the count is even or odd which we can do using bit mask. \\nAs there are 5 vowels so 00000 5 bit can have 2^5 combinations = 32 for the bit mask. 0 to 4th bit represents\\nthe even 0 or odd 1 count state of vowel a,e,i,o,u respectively. Now if the bit mask is zero then there is \\neven number of all vowels in substring range from 0 to ith index but if it is not zero then we have to \\nfind the previous occuerence of the current mask and the valid substring length will be the difference\\nbetween current index and previous occuerence of current mask index. As we found the mask again \\nthere is definately even count of vowels in between the range of previous occuerence index and current \\nindex as , previous mask + 0 = current mask. So, we store the index of mask when first time it occurs.\\nMask value can only be zero when substring occurs from the 0th index and so we do not update the \\nindex of Mask 0.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int sl = s.length();\\n        \\n        // track the first occuerence of mask\\n        vector<int> track(32,-1);\\n        \\n        // map vector for mask of vowels and non-vowels\\n        vector<int> v_map = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        // max substring length\\n        int maxL = 0;\\n        \\n        // current mask\\n        int mask = 0;\\n        \\n        // loop through item and update current mask from map vector\\n        // store the index of non-zero mask if it occurs first\\n        // calculate length of substring from previous mask index and update maxL \\n        for(int i=0;i<sl;i++)\\n        {\\n            mask^= v_map[s[i]-\\'a\\'];\\n            if(mask > 0 && track[mask]==-1)track[mask]=i;\\n            \\n            maxL = max(maxL,i-track[mask]);\\n        }        \\n        return maxL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nHere we need to find the longest subarray containing even count of vowels only. We do not need to count\\nvowel occuerence but we need to track if the count is even or odd which we can do using bit mask. \\nAs there are 5 vowels so 00000 5 bit can have 2^5 combinations = 32 for the bit mask. 0 to 4th bit represents\\nthe even 0 or odd 1 count state of vowel a,e,i,o,u respectively. Now if the bit mask is zero then there is \\neven number of all vowels in substring range from 0 to ith index but if it is not zero then we have to \\nfind the previous occuerence of the current mask and the valid substring length will be the difference\\nbetween current index and previous occuerence of current mask index. As we found the mask again \\nthere is definately even count of vowels in between the range of previous occuerence index and current \\nindex as , previous mask + 0 = current mask. So, we store the index of mask when first time it occurs.\\nMask value can only be zero when substring occurs from the 0th index and so we do not update the \\nindex of Mask 0.\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int sl = s.length();\\n        \\n        // track the first occuerence of mask\\n        vector<int> track(32,-1);\\n        \\n        // map vector for mask of vowels and non-vowels\\n        vector<int> v_map = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n        \\n        // max substring length\\n        int maxL = 0;\\n        \\n        // current mask\\n        int mask = 0;\\n        \\n        // loop through item and update current mask from map vector\\n        // store the index of non-zero mask if it occurs first\\n        // calculate length of substring from previous mask index and update maxL \\n        for(int i=0;i<sl;i++)\\n        {\\n            mask^= v_map[s[i]-\\'a\\'];\\n            if(mask > 0 && track[mask]==-1)track[mask]=i;\\n            \\n            maxL = max(maxL,i-track[mask]);\\n        }        \\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960820,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nSince there are 26 English letters in total, we can assign each bit of a 32-bit integer number to a letter. We deal with lower case English letters which means that `\"a\"` has a unicode value of `97` which is the smallest. If we subtract `97` from the unicode value of a vowel, we will be able to determine its corresponding bit in our number. If such a bit is set, the number of occurrences for the corresponding vowel in a substring starting from `0` and ending in a given position is odd. If it is unset, the occurrences are even.\\nSo in order to obtain a maximum length substring containing an even number of vowels which ends in a given position, we need to exclude the substring starting in position `0` and ending in the smallest position possible (it will be of the smallest length then) with the same vowel counts and therefore the same integer number. Subtracting an even number from an even numer and subtracting an odd number from an odd number will always lead to an even number. If there is a substring with this integer number, subtracting their vowel counts would lead to even counts only.\\n\\nIf an entry exists, we will be able to subtract the given index from the one stored in the hashmap to obtain the length of the maximum length substring. \\nHowever, if the integer number has occurred for the first time, it will be stored in the hashmap with the given index for further examinations.\\n\\nWe loop through each letter in `s` and determine, if possible, the length of the maximum substring ending in each position and store the highest one.\\n_____________________________\\n**Runtime Complexity**\\n`O(n)` for examining each input letter once (hashset and hashmap lookup and insertion is expected to be in `O(1)`).\\n____________________________\\n**Space Complexity**\\n`O(1)` for storing at maximum `2^5` numbers in the hashmap.\\n___________________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowel_counter_bit_mask = 0\\n        vowel_counter_bit_mask_to_index = {0: -1}\\n        ret = 0\\n        vowels = set([\"a\", \"e\", \"i\", \"o\", \"u\"])        \\n        \\n        for i in range(len(s)):\\n            if (s[i] in vowels):\\n                vowel_counter_bit_mask ^= 1 << (ord(s[i]) - 97)\\n            \\n            if (vowel_counter_bit_mask in vowel_counter_bit_mask_to_index):\\n                ret = max(ret, i - vowel_counter_bit_mask_to_index[vowel_counter_bit_mask])\\n            else:\\n                vowel_counter_bit_mask_to_index[vowel_counter_bit_mask] = i\\n                \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowel_counter_bit_mask = 0\\n        vowel_counter_bit_mask_to_index = {0: -1}\\n        ret = 0\\n        vowels = set([\"a\", \"e\", \"i\", \"o\", \"u\"])        \\n        \\n        for i in range(len(s)):\\n            if (s[i] in vowels):\\n                vowel_counter_bit_mask ^= 1 << (ord(s[i]) - 97)\\n            \\n            if (vowel_counter_bit_mask in vowel_counter_bit_mask_to_index):\\n                ret = max(ret, i - vowel_counter_bit_mask_to_index[vowel_counter_bit_mask])\\n            else:\\n                vowel_counter_bit_mask_to_index[vowel_counter_bit_mask] = i\\n                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852187,
                "title": "c-solution-to-the-problem",
                "content": "\\n/*\\n\\'a\\':0\\n\\'e\\':1\\n\\'i\\':2\\n\\'o\\':3\\n\\'u\\':4\\n*/\\nTips:\\nFirst of all , we can  put this question in a different way: find the longest substring from index i to j in the  given string that has vowels in even counts.\\nif [i,j] meets the requirement, it means that s[i]  is in accordance with s[j]  with regard to the vowels in odd or even counts -- if vowels before  both\\ns[i] and s[j] are either even or odd, then j-i+1 is the the substring that meets our requirement. Then we can compare the result of j-i+1 with the current max substring \\n, if the former is greater, then we will update the current max substring, otherwise, continue.\\n\\nSecond of all, there are five vowels, so the combination of bitmap to illustrate their odd or even situation will be up to 32, that is, 00000- 11111, which is why we define an\\narray with 32 int elements, which is used to store the index of i for the first occurence of one of the odd or even situations while we scan the given string.\\n\\nLast but not the least,  while we scan the given string ,  we will see that if the index of status is -1, it means the first occurence of the situation, the index will be stored \\nin the array, otherwise, we will compare and update the current max substring.\\n\\n#define MAX(a,b) ((a>b)?a:b)\\nint findTheLongestSubstring(char * s){\\n\\n\\t\\tint result=0;\\n\\t\\tint s_len=strlen(s);\\n\\t\\tint status=0;\\n\\t\\tint position[32];\\n\\t\\tint ii;\\n\\t\\tfor(ii=0;ii<32;ii++){\\n\\t\\t\\tposition[ii]=-1;\\n\\t\\t}\\n\\t\\tposition[0]=0;\\n\\t\\tfor(ii=0;ii<s_len;ii++){\\t\\n\\t\\t\\t\\n\\t\\t\\tif(s[ii]==\\'a\\'){\\n\\t\\t\\t\\tstatus ^=(1<<0);\\n\\t\\t\\t}else if(s[ii] ==\\'e\\'){\\n\\t\\t\\t\\tstatus ^=(1<<1);\\n\\t\\t\\t}else if(s[ii] == \\'i\\'){\\n\\t\\t\\t\\tstatus ^=(1<<2);\\n\\t\\t\\t}else if(s[ii] == \\'o\\'){\\n\\t\\t\\t\\tstatus ^=(1<<3);\\n\\t\\t\\t}else if(s[ii] == \\'u\\'){\\n\\t\\t\\t\\tstatus ^=(1<<4);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(position[status] != -1){\\n\\t\\t\\t\\tresult=MAX(result, ii+1- position[status]);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tposition[status]=ii+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n}",
                "solutionTags": [],
                "code": "\\n/*\\n\\'a\\':0\\n\\'e\\':1\\n\\'i\\':2\\n\\'o\\':3\\n\\'u\\':4\\n*/\\nTips:\\nFirst of all , we can  put this question in a different way: find the longest substring from index i to j in the  given string that has vowels in even counts.\\nif [i,j] meets the requirement, it means that s[i]  is in accordance with s[j]  with regard to the vowels in odd or even counts -- if vowels before  both\\ns[i] and s[j] are either even or odd, then j-i+1 is the the substring that meets our requirement. Then we can compare the result of j-i+1 with the current max substring \\n, if the former is greater, then we will update the current max substring, otherwise, continue.\\n\\nSecond of all, there are five vowels, so the combination of bitmap to illustrate their odd or even situation will be up to 32, that is, 00000- 11111, which is why we define an\\narray with 32 int elements, which is used to store the index of i for the first occurence of one of the odd or even situations while we scan the given string.\\n\\nLast but not the least,  while we scan the given string ,  we will see that if the index of status is -1, it means the first occurence of the situation, the index will be stored \\nin the array, otherwise, we will compare and update the current max substring.\\n\\n#define MAX(a,b) ((a>b)?a:b)\\nint findTheLongestSubstring(char * s){\\n\\n\\t\\tint result=0;\\n\\t\\tint s_len=strlen(s);\\n\\t\\tint status=0;\\n\\t\\tint position[32];\\n\\t\\tint ii;\\n\\t\\tfor(ii=0;ii<32;ii++){\\n\\t\\t\\tposition[ii]=-1;\\n\\t\\t}\\n\\t\\tposition[0]=0;\\n\\t\\tfor(ii=0;ii<s_len;ii++){\\t\\n\\t\\t\\t\\n\\t\\t\\tif(s[ii]==\\'a\\'){\\n\\t\\t\\t\\tstatus ^=(1<<0);\\n\\t\\t\\t}else if(s[ii] ==\\'e\\'){\\n\\t\\t\\t\\tstatus ^=(1<<1);\\n\\t\\t\\t}else if(s[ii] == \\'i\\'){\\n\\t\\t\\t\\tstatus ^=(1<<2);\\n\\t\\t\\t}else if(s[ii] == \\'o\\'){\\n\\t\\t\\t\\tstatus ^=(1<<3);\\n\\t\\t\\t}else if(s[ii] == \\'u\\'){\\n\\t\\t\\t\\tstatus ^=(1<<4);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(position[status] != -1){\\n\\t\\t\\t\\tresult=MAX(result, ii+1- position[status]);\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tposition[status]=ii+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 841821,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def countVowels(ct):\\n            if not ct[\\'a\\'] % 2 and not ct[\\'e\\'] % 2 and not ct[\\'i\\'] % 2 and not ct[\\'o\\'] % 2 and not ct[\\'u\\'] % 2:\\n                return True\\n            return False\\n\\n        #Reducer\\n            #Slider\\n            #0 - len(s)\\n            #0 - len(s) -1 -> 1 - len(s)\\n        for i in range(len(s)):\\n            ctr = collections.Counter(s[:len(s) - i])\\n            for j in range(i+1):\\n                #window = s[j:(len(s)+j) - i]\\n                if j != 0:\\n                    ctr[s[j - 1]] -= 1\\n                    ctr[s[len(s)+j - i - 1]] += 1\\n                if countVowels(ctr):\\n                    return sum(ctr.values())\\n        return 0\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def countVowels(ct):\\n            if not ct[\\'a\\'] % 2 and not ct[\\'e\\'] % 2 and not ct[\\'i\\'] % 2 and not ct[\\'o\\'] % 2 and not ct[\\'u\\'] % 2:\\n                return True\\n            return False\\n\\n        #Reducer\\n            #Slider\\n            #0 - len(s)\\n            #0 - len(s) -1 -> 1 - len(s)\\n        for i in range(len(s)):\\n            ctr = collections.Counter(s[:len(s) - i])\\n            for j in range(i+1):\\n                #window = s[j:(len(s)+j) - i]\\n                if j != 0:\\n                    ctr[s[j - 1]] -= 1\\n                    ctr[s[len(s)+j - i - 1]] += 1\\n                if countVowels(ctr):\\n                    return sum(ctr.values())\\n        return 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 797518,
                "title": "could-i-be-more-simpler-c-beats-91",
                "content": "> Appraoch\\n1. We count the vowels using xor and bitmask\\n2. for a particular vowel the corresponding bit is set( = 1 in mask) if its count is odd uptill now and \\n3. bit is unset ( = 0 in mask) if its count is even \\n4. we store the odd/even count as bit mask\\n5. there can be at max 32 states \\n\\n> Algorithm\\n\\n```\\n\\tbool isVowel(char &c) {\\n        return (c == \\'a\\'||c == \\'e\\'||c == \\'i\\'||c == \\'o\\'||c == \\'u\\');\\n    }\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> pos;\\n\\t\\t// we map the character to bit positions\\n        pos[\\'a\\'] = 0, pos[\\'e\\'] = 1, pos[\\'i\\'] = 2, pos[\\'o\\'] = 3, pos[\\'u\\'] = 4;\\n        \\n        int n = s.length();\\n\\t\\t// array to store first occurance of a mask\\n        vector<int> firstOcc(64, n);\\n\\t\\t// first occurance of mask 0 is at -1\\n        firstOcc[0] = -1;\\n        int mask = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update mask\\n                mask ^= (1 << pos[s[i]]);\\n            }\\n\\t\\t\\t// update ans \\n            ans = max(ans, i - firstOcc[mask]);\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update the first occurance of the mask\\n                firstOcc[mask] = min(firstOcc[mask], i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tbool isVowel(char &c) {\\n        return (c == \\'a\\'||c == \\'e\\'||c == \\'i\\'||c == \\'o\\'||c == \\'u\\');\\n    }\\n    \\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> pos;\\n\\t\\t// we map the character to bit positions\\n        pos[\\'a\\'] = 0, pos[\\'e\\'] = 1, pos[\\'i\\'] = 2, pos[\\'o\\'] = 3, pos[\\'u\\'] = 4;\\n        \\n        int n = s.length();\\n\\t\\t// array to store first occurance of a mask\\n        vector<int> firstOcc(64, n);\\n\\t\\t// first occurance of mask 0 is at -1\\n        firstOcc[0] = -1;\\n        int mask = 0, ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update mask\\n                mask ^= (1 << pos[s[i]]);\\n            }\\n\\t\\t\\t// update ans \\n            ans = max(ans, i - firstOcc[mask]);\\n            if(isVowel(s[i])) {\\n\\t\\t\\t\\t// update the first occurance of the mask\\n                firstOcc[mask] = min(firstOcc[mask], i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 781672,
                "title": "c-one-pass-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        int mask = 0;\\n        vector<int> dp(32, s.length());\\n        map<char,int> vo_map = {{\\'a\\',0},{\\'e\\',1},{\\'i\\',2},{\\'o\\',3},{\\'u\\',4}};\\n        dp[0] = -1;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            if (vo_map.find(s[i]) == vo_map.end()) {\\n                ans = max(ans, i - dp[mask]);\\n                continue;\\n            }\\n            mask ^= (1 << vo_map[s[i]]);\\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        int mask = 0;\\n        vector<int> dp(32, s.length());\\n        map<char,int> vo_map = {{\\'a\\',0},{\\'e\\',1},{\\'i\\',2},{\\'o\\',3},{\\'u\\',4}};\\n        dp[0] = -1;\\n        \\n        for (int i=0;i<s.length();i++) {\\n            if (vo_map.find(s[i]) == vo_map.end()) {\\n                ans = max(ans, i - dp[mask]);\\n                continue;\\n            }\\n            mask ^= (1 << vo_map[s[i]]);\\n            ans = max(ans, i - dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767408,
                "title": "the-key-idea-is-to-use-5-bit-to-store-the-odd-even-state-for-5-vowels",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        int state = 0;\\n        static string vowels(\"aeiou\");\\n        static unordered_map<char, int> masks{{\\'a\\', 1}, {\\'e\\', 2}, {\\'i\\', 4}, {\\'o\\', 8}, {\\'u\\', 16}};\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (vowels.find(s[i]) != string::npos) {\\n                state ^= masks[s[i]];\\n            }\\n            if (states[state] == -2) {\\n                states[state] = i;\\n            } else {\\n                ans = max(ans, i - states[state]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        vector<int> states(32, -2);\\n        states[0] = -1;\\n        int state = 0;\\n        static string vowels(\"aeiou\");\\n        static unordered_map<char, int> masks{{\\'a\\', 1}, {\\'e\\', 2}, {\\'i\\', 4}, {\\'o\\', 8}, {\\'u\\', 16}};\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (vowels.find(s[i]) != string::npos) {\\n                state ^= masks[s[i]];\\n            }\\n            if (states[state] == -2) {\\n                states[state] = i;\\n            } else {\\n                ans = max(ans, i - states[state]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661453,
                "title": "simple-and-concise-solution-java",
                "content": "```\\npublic int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int state = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'a\\':\\n                    state ^= 1 << 0;\\n                    break;\\n                case \\'e\\':\\n                    state ^= 1 << 1;\\n                    break;\\n                case \\'i\\':\\n                    state ^= 1 << 2;\\n                    break;\\n                case \\'o\\':\\n                    state ^= 1 << 3;\\n                    break;\\n                case \\'u\\':\\n                    state ^= 1 << 4;\\n                    break;\\n                default:\\n                    break;\\n            }\\n            if (map.containsKey(state)) {\\n                res = Math.max(res, i - map.get(state)); \\n            } else {\\n                map.put(state, i);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int findTheLongestSubstring(String s) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        int state = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            switch (ch) {\\n                case \\'a\\':\\n                    state ^= 1 << 0;\\n                    break;\\n                case \\'e\\':\\n                    state ^= 1 << 1;\\n                    break;\\n                case \\'i\\':\\n                    state ^= 1 << 2;\\n                    break;\\n                case \\'o\\':\\n                    state ^= 1 << 3;\\n                    break;\\n                case \\'u\\':\\n                    state ^= 1 << 4;\\n                    break;\\n                default:\\n                    break;\\n            }\\n            if (map.containsKey(state)) {\\n                res = Math.max(res, i - map.get(state)); \\n            } else {\\n                map.put(state, i);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 602701,
                "title": "1371-find-the-longest-substring-containing-vowels-in-even-counts-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Prefix State with HashMap**\\n| O(T): O(n) | O(S): O(1) | Rt: 2736ms | \\n```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        last, dt = {\\'00000\\': -1}, {i: 0 for i in \\'aeiou\\'}\\n        for i in range(l):\\n            if s[i] in dt: dt[s[i]] ^= 1\\n            k = \\'\\'.join(str(dt[k]) for k in \\'aeiou\\')\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```\\n\\nAlternative: | Rt: 436ms |\\n```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        k, last, mask = 0, {0: -1}, {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n        for i in range(l):\\n            if s[i] in mask: k ^= mask[s[i]]\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```\\nReferrence: https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/531850/Python-solution-in-O(n)-time-and-O(1)-space-explained",
                "solutionTags": [],
                "code": "```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        last, dt = {\\'00000\\': -1}, {i: 0 for i in \\'aeiou\\'}\\n        for i in range(l):\\n            if s[i] in dt: dt[s[i]] ^= 1\\n            k = \\'\\'.join(str(dt[k]) for k in \\'aeiou\\')\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```\n```python\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        rst, l = 0, len(s)\\n        k, last, mask = 0, {0: -1}, {\\'a\\': 1, \\'e\\': 2, \\'i\\': 4, \\'o\\': 8, \\'u\\': 16}\\n        for i in range(l):\\n            if s[i] in mask: k ^= mask[s[i]]\\n            if k not in last: last[k] = i\\n            else: rst = max(rst, i-last[k])\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 578155,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nUse a bitmask to encode the vowel state per index as a single integer value.  Either there are an even or odd amount of each vowel, the following values are added when there is an odd amount and removed when there is an even amount per each vowel.\\n```\\na == 1\\ne == 2\\ni == 4\\no == 8\\nu == 16\\n```\\n\\nUse an array `A` to create an ongoing prefix-xor sum of encoded vowel states.  xor is used because we only care about even amounts of vowels, thus xor acts as a toggle to add/remove vowels from the ongoing prefix-xor sum.  For each character in `S`, there are 2 cases to consider:\\n\\n* **Case 1:** if the character is a *not* vowel, then set the ongoing prefix-xor sum `A[i]` equal to the previous prefix-xor sum `A[i - 1]`.  (Since there are no additional vowels to add/remove, the prefix-xor sum for `A[i]` remains the same as it\\'s previous prefix-xor sum `A[i - 1]`.)\\n* **Case 2:** if the character is a vowel, then set the ongoing prefix-xor sum `A[i]` equal to the previous prefix-xor sum `A[i - 1]` xor\\'ed with the encoded vowel value.  (This xor either adds or removes the vowel from the ongoing prefix-xor sum).\\n\\nTrack the index of each `first` `seen` prefix-xor sum `A[i]` to find and return the maximum delta between the current index `i` and each `first` `seen` prefix-xor sum `A[i]`.\\n\\n**Examples:**\\n\\n*Example 0:*\\n\\nIf input = \"leet\", notice how `2` is added for the first `e` since the count of `e` is odd, and notice how `2` is removed for the second `e` since the count of `e` is even:\\n\\n```\\n      l e e t\\n      0 1 2 3 4\\nA = 0 0 2 0 0\\n    0 1 2 3 4 5\\n```\\n\\nThe answer is the index of the right-most `0` minus the index of the left-most `0`, ie. `4 - 0 = 4`.\\n\\n*Example 1:* note the value `X` in `A` is actually `10`, I wrote `X` since its a single character which aligns better for readability:\\n\\n```\\n      e l e e t m i n i c o w o r o e p\\n\\t  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\\nA = 0 2 2 0 2 2 2 6 6 2 2 X X 2 2 X 8 8 \\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\\n```\\n\\nThe answer is the index of the right-most `2` minus the index of the left-most `2`, ie. `14 - 1 = 13`.\\n\\n**Versbose Solutions:** this solution may be easier to \"see\" with verbose code\\n\\n*Javascript*\\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => 1 << V.indexOf(c);\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        if (V.indexOf(S[i - 1]) == -1) // A[i] is not a vowel\\n            A[i] = A[i - 1];\\n        else                           // A[i] is a vowel\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        if (seen.has(A[i]))\\n            max = Math.max(max, i - seen.get(A[i])); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        else\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n    }\\n    return max;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) { return 1 << V.find(c); };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            if (V.find(S[i - 1]) == string::npos) // A[i] is not a vowel\\n                A[i] = A[i - 1];\\n            else                                  // A[i] is a vowel\\n                A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            if (seen.find(A[i]) != seen.end())\\n                max = std::max(max, i - seen[A[i]]); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n            else\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```\\n\\n**Concise Solutions:** note `x ^ 0 == x`, thus we can encode non-vowels as `0`\\n\\n*Javascript:*\\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => {\\n        let i = V.indexOf(c);\\n        return i == -1 ? 0 : 1 << i;\\n    };\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        let first = seen.has(A[i]) ? seen.get(A[i]) : i;\\n        if (first == i)\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n        max = Math.max(max, i - first);  // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n    }\\n    return max;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) {\\n            auto i = V.find(c);\\n            return i == string::npos ? 0 : 1 << i;\\n        };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            auto first = seen.find(A[i]) != seen.end() ? seen[A[i]] : i;\\n            if (first == i)\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n            max = std::max(max, i - first); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\na == 1\\ne == 2\\ni == 4\\no == 8\\nu == 16\\n```\n```\\n      l e e t\\n      0 1 2 3 4\\nA = 0 0 2 0 0\\n    0 1 2 3 4 5\\n```\n```\\n      e l e e t m i n i c o w o r o e p\\n\\t  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\\nA = 0 2 2 0 2 2 2 6 6 2 2 X X 2 2 X 8 8 \\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\\n```\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => 1 << V.indexOf(c);\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        if (V.indexOf(S[i - 1]) == -1) // A[i] is not a vowel\\n            A[i] = A[i - 1];\\n        else                           // A[i] is a vowel\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        if (seen.has(A[i]))\\n            max = Math.max(max, i - seen.get(A[i])); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        else\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n    }\\n    return max;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) { return 1 << V.find(c); };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            if (V.find(S[i - 1]) == string::npos) // A[i] is not a vowel\\n                A[i] = A[i - 1];\\n            else                                  // A[i] is a vowel\\n                A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            if (seen.find(A[i]) != seen.end())\\n                max = std::max(max, i - seen[A[i]]); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n            else\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```\n```\\nlet findTheLongestSubstring = (S, V = \\'aeiou\\', max = 0) => {\\n    let encode = c => {\\n        let i = V.indexOf(c);\\n        return i == -1 ? 0 : 1 << i;\\n    };\\n    let N = S.length;\\n    let A = Array(N + 1).fill(0);\\n    let seen = new Map([[0, 0]]);\\n    for (let i = 1; i <= N; ++i) {\\n        A[i] = A[i - 1] ^ encode(S[i - 1]);\\n        let first = seen.has(A[i]) ? seen.get(A[i]) : i;\\n        if (first == i)\\n            seen.set(A[i], i); // \\uD83D\\uDC40 first seen A[i] index\\n        max = Math.max(max, i - first);  // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n    }\\n    return max;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>; // value -> first index\\n    int findTheLongestSubstring(string S, string V = \"aeiou\", int max = 0) {\\n        auto encode = [&](auto c) {\\n            auto i = V.find(c);\\n            return i == string::npos ? 0 : 1 << i;\\n        };\\n        int N = S.size();\\n        VI A(N + 1);\\n        Map seen{{0, 0}};\\n        for (auto i{ 1 }; i <= N; ++i) {\\n            A[i] = A[i - 1] ^ encode(S[i - 1]);\\n            auto first = seen.find(A[i]) != seen.end() ? seen[A[i]] : i;\\n            if (first == i)\\n                seen[A[i]] = i; // \\uD83D\\uDC40 first seen A[i] index\\n            max = std::max(max, i - first); // \\uD83C\\uDFAF max of i-th index minus first seen A[i] index\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539657,
                "title": "java-beats-100-memory-usage-o-n-time-complexity",
                "content": "The solution is inspired by other discussions in the forum and my thanks and credits to them.\\n\\nExplanation :\\na. Using last 5 bits of an integer is like maintaining  5 booleans to mark if the state.\\nb. when the state of all 5 booleans are same at 2 different spots in parsing a string s, then those 2 spots potentially have even number of vowles in between. \\nc. better explanation and inspiration to this code\\nhttps://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/discuss/534210/Dew-It-or-Simple-illustration-for-THE-trick\\n\\n\\nCode:\\n```\\npublic int findTheLongestSubstring(String s) {\\n\\n        List<String> vowles = new ArrayList<>(Arrays.asList(\"a\", \"e\", \"i\", \"o\", \"u\"));\\n        List<String> splitInputString = IntStream.range(0, s.length()).mapToObj(x -> String.valueOf(s.charAt(x))).collect(Collectors.toList());\\n        Map<Integer, Integer> maskToIndexMap = new HashMap<>();\\n        maskToIndexMap.put(0, -1);\\n        int mask = 0;\\n        int result = 0;\\n        for (int i = 0; i < splitInputString.size(); i++) {\\n            if (vowles.contains(splitInputString.get(i))) {\\n                mask = mask ^ (1 << vowles.indexOf(splitInputString.get(i)) + 1);\\n            }\\n            if (!maskToIndexMap.containsKey(mask)) {\\n                maskToIndexMap.put(mask, i);\\n            }\\n            result = Math.max(i - maskToIndexMap.get(mask), result);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheLongestSubstring(String s) {\\n\\n        List<String> vowles = new ArrayList<>(Arrays.asList(\"a\", \"e\", \"i\", \"o\", \"u\"));\\n        List<String> splitInputString = IntStream.range(0, s.length()).mapToObj(x -> String.valueOf(s.charAt(x))).collect(Collectors.toList());\\n        Map<Integer, Integer> maskToIndexMap = new HashMap<>();\\n        maskToIndexMap.put(0, -1);\\n        int mask = 0;\\n        int result = 0;\\n        for (int i = 0; i < splitInputString.size(); i++) {\\n            if (vowles.contains(splitInputString.get(i))) {\\n                mask = mask ^ (1 << vowles.indexOf(splitInputString.get(i)) + 1);\\n            }\\n            if (!maskToIndexMap.containsKey(mask)) {\\n                maskToIndexMap.put(mask, i);\\n            }\\n            result = Math.max(i - maskToIndexMap.get(mask), result);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537171,
                "title": "rust-solution-24ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let m: HashMap<char, i32> = [(\\'a\\', 1), (\\'e\\', 2), (\\'i\\', 4), (\\'o\\', 8), (\\'u\\', 16)]\\n            .iter()\\n            .cloned()\\n            .collect();\\n        let (mut res, mut mask) = (0, 0);\\n        let mut last = vec![-1; 32];\\n\\n        for (i, c) in s.chars().enumerate() {\\n            if m.contains_key(&c) {\\n                mask ^= m[&c];\\n            }\\n\\n            if mask == 0 {\\n                res = i as i32 + 1;\\n            } else if last[mask as usize] == -1 {\\n                last[mask as usize] = i as i32;\\n            } else {\\n                res = std::cmp::max(res, i as i32 - last[mask as usize]);\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let m: HashMap<char, i32> = [(\\'a\\', 1), (\\'e\\', 2), (\\'i\\', 4), (\\'o\\', 8), (\\'u\\', 16)]\\n            .iter()\\n            .cloned()\\n            .collect();\\n        let (mut res, mut mask) = (0, 0);\\n        let mut last = vec![-1; 32];\\n\\n        for (i, c) in s.chars().enumerate() {\\n            if m.contains_key(&c) {\\n                mask ^= m[&c];\\n            }\\n\\n            if mask == 0 {\\n                res = i as i32 + 1;\\n            } else if last[mask as usize] == -1 {\\n                last[mask as usize] = i as i32;\\n            } else {\\n                res = std::cmp::max(res, i as i32 - last[mask as usize]);\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532880,
                "title": "java-o-n-solution-using-hashmap",
                "content": "Concept: Since there are 5 vowels, so there can be 2^5=32 states (each vowel is repeated either odd or even times). Frame a hashmap with key as a string consisting of the states of each vowel (true if even, false if odd) and value as an arraylist of indices of the given string at which this state is achieved. Since initially all the vowels are 0(even), first store -1 in \\'all true\\' state, then iterate each character on-by-one. Then subtract the minimum value from the maximum value of each of the arraylists of the hashset and find the maximum difference.\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char c;\\n        boolean arr[]=new boolean [5]; // state storing array.\\n        HashMap<String,ArrayList<Integer>>hmap=new HashMap<>();\\n        Arrays.fill(arr,true); // initially all are true.\\n        String str; // to frame the key for the hashmap.\\n        str=\"true true true true true\";\\n        hmap.put(str,new ArrayList<>());\\n        hmap.get(str).add(-1); // add -1 initially to the \\'all true\\' state arraylist.\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n\\t\\t\\t// filp each state accordingly.\\n            if(c==\\'a\\')\\n                arr[0]=!arr[0];\\n            else if(c==\\'e\\')\\n                arr[1]=!arr[1];\\n            else if(c==\\'i\\')\\n                arr[2]=!arr[2];\\n            else if(c==\\'o\\')\\n                arr[3]=!arr[3];\\n            else if(c==\\'u\\')\\n                arr[4]=!arr[4];         \\n\\t\\t\\t\\t\\n            str=arr[0]+\" \"+arr[1]+\" \"+arr[2]+\" \"+arr[3]+\" \"+arr[4]; // frame key.\\n            hmap.putIfAbsent(str,new ArrayList<>()); \\n            hmap.get(str).add(i); // add the index.\\n        }\\n        int max=0; // to store the maximum length.\\n        ArrayList<Integer> list;\\n        for(String p:hmap.keySet()){\\n            list=hmap.get(p);\\n\\t\\t\\t// subtract the minimum index from the maximum index.\\n            max=Math.max(max,list.get(list.size()-1)-list.get(0));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        char c;\\n        boolean arr[]=new boolean [5]; // state storing array.\\n        HashMap<String,ArrayList<Integer>>hmap=new HashMap<>();\\n        Arrays.fill(arr,true); // initially all are true.\\n        String str; // to frame the key for the hashmap.\\n        str=\"true true true true true\";\\n        hmap.put(str,new ArrayList<>());\\n        hmap.get(str).add(-1); // add -1 initially to the \\'all true\\' state arraylist.\\n        for(int i=0;i<s.length();i++){\\n            c=s.charAt(i);\\n\\t\\t\\t// filp each state accordingly.\\n            if(c==\\'a\\')\\n                arr[0]=!arr[0];\\n            else if(c==\\'e\\')\\n                arr[1]=!arr[1];\\n            else if(c==\\'i\\')\\n                arr[2]=!arr[2];\\n            else if(c==\\'o\\')\\n                arr[3]=!arr[3];\\n            else if(c==\\'u\\')\\n                arr[4]=!arr[4];         \\n\\t\\t\\t\\t\\n            str=arr[0]+\" \"+arr[1]+\" \"+arr[2]+\" \"+arr[3]+\" \"+arr[4]; // frame key.\\n            hmap.putIfAbsent(str,new ArrayList<>()); \\n            hmap.get(str).add(i); // add the index.\\n        }\\n        int max=0; // to store the maximum length.\\n        ArrayList<Integer> list;\\n        for(String p:hmap.keySet()){\\n            list=hmap.get(p);\\n\\t\\t\\t// subtract the minimum index from the maximum index.\\n            max=Math.max(max,list.get(list.size()-1)-list.get(0));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532326,
                "title": "java-bit-mask-solution-with-explaination",
                "content": "```\\nclass Solution {\\n    /**\\n    for each odd number, there just two kinds of times, \\n    times%2==1, times%2==0  (the arg is notEven)\\n    \\n    if times%2==1 that means if we mask the bit for each vow(a->0. e->1, i->2, o->3, u->4), must be one vow\\n    take \\'^\\' times is not even\\n    i- NotEvenIdx, means we get len as abstract the even not even number happened at notEven index\\n    that means, if we get a odd times if vow, like 5, and first time happen at 3, then 3rd happens at 5\\n    we can get the len as 5-3=2, it is equals we count as 5,4\\n    \\n    if notEven is even, that means every vow is on even times from the start\\n    **/\\n    public int findTheLongestSubstring(String s) {\\n        Map<Character, Integer> map = new HashMap<>(7);\\n        map.put(\\'a\\', 0);\\n        map.put(\\'e\\', 1);\\n        map.put(\\'i\\', 2);\\n        map.put(\\'o\\', 3);\\n        map.put(\\'u\\', 4);\\n        int len=0;\\n        Map<Integer, Integer> notEvenHappens = new HashMap<>(22);\\n        int notEven=0;\\n        //init for length cal\\n        notEvenHappens.put(0, -1);\\n        for(int i=0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(map.containsKey(ch)) notEven ^= 1<<map.get(ch);\\n            notEvenHappens.putIfAbsent(notEven, i);\\n            len=Math.max(len, i-notEvenHappens.get(notEven));\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n    for each odd number, there just two kinds of times, \\n    times%2==1, times%2==0  (the arg is notEven)\\n    \\n    if times%2==1 that means if we mask the bit for each vow(a->0. e->1, i->2, o->3, u->4), must be one vow\\n    take \\'^\\' times is not even\\n    i- NotEvenIdx, means we get len as abstract the even not even number happened at notEven index\\n    that means, if we get a odd times if vow, like 5, and first time happen at 3, then 3rd happens at 5\\n    we can get the len as 5-3=2, it is equals we count as 5,4\\n    \\n    if notEven is even, that means every vow is on even times from the start\\n    **/\\n    public int findTheLongestSubstring(String s) {\\n        Map<Character, Integer> map = new HashMap<>(7);\\n        map.put(\\'a\\', 0);\\n        map.put(\\'e\\', 1);\\n        map.put(\\'i\\', 2);\\n        map.put(\\'o\\', 3);\\n        map.put(\\'u\\', 4);\\n        int len=0;\\n        Map<Integer, Integer> notEvenHappens = new HashMap<>(22);\\n        int notEven=0;\\n        //init for length cal\\n        notEvenHappens.put(0, -1);\\n        for(int i=0; i<s.length(); i++){\\n            char ch = s.charAt(i);\\n            if(map.containsKey(ch)) notEven ^= 1<<map.get(ch);\\n            notEvenHappens.putIfAbsent(notEven, i);\\n            len=Math.max(len, i-notEvenHappens.get(notEven));\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531940,
                "title": "c-o-n-solution-with-state-compression-32-states",
                "content": "0 means the number of occurrence of the vowel is even\\n1 means the number of occurrence of the vowel is odd\\n32 states:\\na:0,e:0,i:0,o:0,u:0\\na:1,e:0,i:0,o:0,u:0\\n......\\na:1,e:1,i:1,o:1,u:1\\n\\n```\\nclass Solution \\n{\\n    public:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int result=0;\\n        int n=s.length();\\n        int current=0;\\n        unordered_map<char,int> m;\\n        m[\\'a\\']=0;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=2;\\n        m[\\'o\\']=3;\\n        m[\\'u\\']=4;\\n        int overall[32];\\n        for(int i=0;i<32;i++)\\n            overall[i]=-1;\\n       \\n        overall[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m.find(s[i])!=m.end())\\n                current=current^((int)pow(2,m[s[i]]));\\n        \\n            if(overall[current]!=-1)\\n                result=max(result,i+1-overall[current]);\\n            else\\n                overall[current]=i+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int result=0;\\n        int n=s.length();\\n        int current=0;\\n        unordered_map<char,int> m;\\n        m[\\'a\\']=0;\\n        m[\\'e\\']=1;\\n        m[\\'i\\']=2;\\n        m[\\'o\\']=3;\\n        m[\\'u\\']=4;\\n        int overall[32];\\n        for(int i=0;i<32;i++)\\n            overall[i]=-1;\\n       \\n        overall[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m.find(s[i])!=m.end())\\n                current=current^((int)pow(2,m[s[i]]));\\n        \\n            if(overall[current]!=-1)\\n                result=max(result,i+1-overall[current]);\\n            else\\n                overall[current]=i+1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531835,
                "title": "easy-c-solution-with-dictionary",
                "content": "```\\n    public class Solution\\n    {\\n        public int FindTheLongestSubstring(string s)\\n        {\\n            int res = 0;\\n            ISet<char> vowels = new HashSet<char>() { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n            \\n            IDictionary<char, int> vowel2Count = new Dictionary<char, int>()\\n            {\\n                {\\'a\\', 0},\\n                {\\'e\\', 0},\\n                {\\'i\\', 0},\\n                {\\'o\\', 0},\\n                {\\'u\\', 0}\\n            };\\n\\n            IDictionary<string, int> key2Index = new Dictionary<string, int>()\\n            {\\n                {\"a0e0i0o0u0\", -1 }\\n            };\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                var c = s[i];\\n                if (vowels.Contains(c))\\n                {\\n                    vowel2Count[c]++;\\n                }\\n\\n                string key = $\"a{vowel2Count[\\'a\\'] % 2}e{vowel2Count[\\'e\\'] % 2}i{vowel2Count[\\'i\\'] % 2}o{vowel2Count[\\'o\\'] % 2}u{vowel2Count[\\'u\\'] % 2}\";\\n\\n                if (key2Index.ContainsKey(key))\\n                {\\n                    res = Math.Max(res, i - (key2Index[key]));\\n                }\\n\\t\\t\\t\\telse\\n                {\\n                    key2Index[key] = i;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public int FindTheLongestSubstring(string s)\\n        {\\n            int res = 0;\\n            ISet<char> vowels = new HashSet<char>() { \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\' };\\n            \\n            IDictionary<char, int> vowel2Count = new Dictionary<char, int>()\\n            {\\n                {\\'a\\', 0},\\n                {\\'e\\', 0},\\n                {\\'i\\', 0},\\n                {\\'o\\', 0},\\n                {\\'u\\', 0}\\n            };\\n\\n            IDictionary<string, int> key2Index = new Dictionary<string, int>()\\n            {\\n                {\"a0e0i0o0u0\", -1 }\\n            };\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                var c = s[i];\\n                if (vowels.Contains(c))\\n                {\\n                    vowel2Count[c]++;\\n                }\\n\\n                string key = $\"a{vowel2Count[\\'a\\'] % 2}e{vowel2Count[\\'e\\'] % 2}i{vowel2Count[\\'i\\'] % 2}o{vowel2Count[\\'o\\'] % 2}u{vowel2Count[\\'u\\'] % 2}\";\\n\\n                if (key2Index.ContainsKey(key))\\n                {\\n                    res = Math.Max(res, i - (key2Index[key]));\\n                }\\n\\t\\t\\t\\telse\\n                {\\n                    key2Index[key] = i;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012132,
                "title": "recall-in-your-mind-longest-length-subarray-having-0-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# ***if sum already exsit at i\\'th positin and again another u found it j\\'th position then it\\'s show that sum of substring from i+1, to j is 0.***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0. cur =0, map for store cur and it\\'s position \\n1. if a, e, i, o, u found flip bitposition of cur 0, 1, 2, 3, 4 respectively.\\n2. if cur already exist in map then ans=max(ans, curIndex-mp[cur]).\\n3. else store curIndex in map , map[cur]=curIndex.  \\n   \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(32)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\n        unordered_map<int,int>mp;\\n        \\n        int p=0, ans=0, i=0;\\n        mp[0]=-1;\\n        for(auto x: s)\\n        {\\n            if(x==\\'a\\') p=p^(1<<0);\\n            if(x==\\'e\\') p=p^(1<<1);\\n            if(x==\\'i\\') p=p^(1<<2);\\n            if(x==\\'o\\') p=p^(1<<3);\\n            if(x==\\'u\\') p=p^(1<<4);\\n\\n            if(mp.count(p))\\n              ans=max(ans, i-mp[p]);\\n            else\\n              mp[p]=i;\\n            \\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n\\n        unordered_map<int,int>mp;\\n        \\n        int p=0, ans=0, i=0;\\n        mp[0]=-1;\\n        for(auto x: s)\\n        {\\n            if(x==\\'a\\') p=p^(1<<0);\\n            if(x==\\'e\\') p=p^(1<<1);\\n            if(x==\\'i\\') p=p^(1<<2);\\n            if(x==\\'o\\') p=p^(1<<3);\\n            if(x==\\'u\\') p=p^(1<<4);\\n\\n            if(mp.count(p))\\n              ans=max(ans, i-mp[p]);\\n            else\\n              mp[p]=i;\\n            \\n            i++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992674,
                "title": "almost-branchless-100-fast-solution-in-c",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define FLIPBIT(bitmap, index) ((bitmap) ^ ((1) << (index)))\\n\\nint vowelIndex (char vowel)\\n{\\n    switch (vowel)\\n    {\\n        case \\'a\\': return 1;\\n        case \\'e\\': return 2;\\n        case \\'i\\': return 3;\\n        case \\'o\\': return 4;\\n        case \\'u\\': return 5;\\n        default: return 0;\\n    }\\n}\\n\\nint slen (char* s)\\n{\\n    int len = 0;\\n    while (*(s + len) != \\'\\\\0\\') ++len;\\n    return len;\\n}\\n\\nint findTheLongestSubstring (char* s)\\n{\\n    int len = slen(s);\\n    unsigned char bitmap = 0;\\n    int memo[64] = { [0 ... 63] = -1 };\\n    int currlen = 0, maxlen = 0;\\n    for (int i = 0; i < len; ++i)\\n    {\\n        bitmap = FLIPBIT(bitmap, vowelIndex(*(s + i))) & -2;\\n        if (bitmap && *(memo + bitmap) < 0) *(memo + bitmap) = i;\\n        currlen = i - *(memo + bitmap);\\n        maxlen = currlen >= maxlen ? currlen : maxlen;\\n    }\\n    return maxlen;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define FLIPBIT(bitmap, index) ((bitmap) ^ ((1) << (index)))\\n\\nint vowelIndex (char vowel)\\n{\\n    switch (vowel)\\n    {\\n        case \\'a\\': return 1;\\n        case \\'e\\': return 2;\\n        case \\'i\\': return 3;\\n        case \\'o\\': return 4;\\n        case \\'u\\': return 5;\\n        default: return 0;\\n    }\\n}\\n\\nint slen (char* s)\\n{\\n    int len = 0;\\n    while (*(s + len) != \\'\\\\0\\') ++len;\\n    return len;\\n}\\n\\nint findTheLongestSubstring (char* s)\\n{\\n    int len = slen(s);\\n    unsigned char bitmap = 0;\\n    int memo[64] = { [0 ... 63] = -1 };\\n    int currlen = 0, maxlen = 0;\\n    for (int i = 0; i < len; ++i)\\n    {\\n        bitmap = FLIPBIT(bitmap, vowelIndex(*(s + i))) & -2;\\n        if (bitmap && *(memo + bitmap) < 0) *(memo + bitmap) = i;\\n        currlen = i - *(memo + bitmap);\\n        maxlen = currlen >= maxlen ? currlen : maxlen;\\n    }\\n    return maxlen;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3975040,
                "title": "c-hash-table-bit-masking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        unordered_map<char,int> val;\\n        val[\\'a\\'] = 0;\\n        val[\\'e\\'] = 1;\\n        val[\\'i\\'] = 2;\\n        val[\\'o\\'] = 3;\\n        val[\\'u\\'] = 4;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(val.find(s[i])!=val.end())\\n            mask^=(1<<val[s[i]]);\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        unordered_map<int,int> m;\\n        int mask = 0;\\n        m[mask] = -1;\\n        int ans = INT_MIN;\\n        unordered_map<char,int> val;\\n        val[\\'a\\'] = 0;\\n        val[\\'e\\'] = 1;\\n        val[\\'i\\'] = 2;\\n        val[\\'o\\'] = 3;\\n        val[\\'u\\'] = 4;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(val.find(s[i])!=val.end())\\n            mask^=(1<<val[s[i]]);\\n            if(m.find(mask)!=m.end())\\n            {\\n                ans = max(ans,i-m[mask]);\\n            }\\n            if(m.find(mask)==m.end())\\n            m[mask] = i;\\n        }\\n        if(ans==INT_MIN)\\n        return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918071,
                "title": "o-n-python-solution",
                "content": "# Intuition\\ncalculated xor of everything, if xor is 0 then elements upto that index then we have even vowels and length of the substring will be index + 1 , but there is one another way of finding a substring with even vowels (if xor of elements from 0 to a has xor = y and xor from 0 to b has also xor = y, such that a < b, then elements from index a to b has even number of vowels and their length would be b-a)\\n\\n# Approach\\ni return index + 1 if i had 0 any time, meaning xor of elements from 0 to that index even have vowels and the length of the substring is index + 1, and i stored every other xor in a dictionary and the value had a list containing the first and last occurrence(index) of that xor, as i explained earlier b-a is also a possible substring with even number of vowels.\\n\\n# Complexity\\n- Time complexity:\\nsince the vowels are only 5 and the number of combinations that can be made of it and possible xor are also constant the complexity turns out to be O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        l={}\\n        x=0\\n        #print(len(s))\\n        m=-1\\n        for i in range(len(s)):\\n            if s[i] in [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']:\\n                x^=ord(s[i])\\n            if x not in l:\\n                l[x]=[i,-1]\\n            else:\\n                l[x][1]=i\\n            if x==0:\\n                m=max(m,i+1)\\n            if l[x][1]!=-1:\\n                m=max(m,l[x][1]-l[x][0])\\n\\n            \\n            #print(x,end=\",\")\\n        if m==-1:\\n            return 0\\n        return m\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        l={}\\n        x=0\\n        #print(len(s))\\n        m=-1\\n        for i in range(len(s)):\\n            if s[i] in [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']:\\n                x^=ord(s[i])\\n            if x not in l:\\n                l[x]=[i,-1]\\n            else:\\n                l[x][1]=i\\n            if x==0:\\n                m=max(m,i+1)\\n            if l[x][1]!=-1:\\n                m=max(m,l[x][1]-l[x][0])\\n\\n            \\n            #print(x,end=\",\")\\n        if m==-1:\\n            return 0\\n        return m\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909677,
                "title": "very-clean-and-simple-code-bits-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs it is given in question the frequency of vowels should be even in subarray. We can think of counting number of vowels at every index and think of subtracting from previous indexes to get max subarray.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The given intution will give n^2 approach, so instead of that we thought of storing whether at that index frequency of each vowel is odd or even.\\n- So we used 5 bits to store whether the frequency is odd or even,which is intialised as 0 in decimal or \"00000\" in binary.\\n- Every time we encounter the same vowel we flip the bit corresponding to it.\\n- As we know that we will get answer when we reach to same state again for eg if we are on state \"10010\" we need to be in same state in future to have frequency of every element as even.(This point might be little hard to understand just go through this once again)\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1) Constant extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int num=0; // It stores current state at every index\\n       vector<int> v(32,-1); //For storing first index of that state\\n       int i=0;\\n        for(auto a:s){\\n            if(a==\\'a\\')\\n                num = (num ^ (1 << 0)); //Code for flipping bit\\n             if(a==\\'e\\')\\n                num = (num ^ (1 << 1)); //Code for flipping bit\\n             if(a==\\'i\\')\\n                num = (num ^ (1 << 2)); //Code for flipping bit\\n             if(a==\\'o\\')\\n                num = (num ^ (1 << 3)); //Code for flipping bit\\n             if(a==\\'u\\')\\n                num = (num ^ (1 << 4)); //Code for flipping bit\\n\\n           if(v[num]==-1){\\n               v[num]=i; // first encounter of state\\n           }\\n           else{\\n               ans=max(ans,i-v[num]); //second and after encounters\\n           }\\n           if(num==0){\\n               ans=i+1; //becuase initially state or num is 0\\n           }\\n           i++;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int num=0; // It stores current state at every index\\n       vector<int> v(32,-1); //For storing first index of that state\\n       int i=0;\\n        for(auto a:s){\\n            if(a==\\'a\\')\\n                num = (num ^ (1 << 0)); //Code for flipping bit\\n             if(a==\\'e\\')\\n                num = (num ^ (1 << 1)); //Code for flipping bit\\n             if(a==\\'i\\')\\n                num = (num ^ (1 << 2)); //Code for flipping bit\\n             if(a==\\'o\\')\\n                num = (num ^ (1 << 3)); //Code for flipping bit\\n             if(a==\\'u\\')\\n                num = (num ^ (1 << 4)); //Code for flipping bit\\n\\n           if(v[num]==-1){\\n               v[num]=i; // first encounter of state\\n           }\\n           else{\\n               ans=max(ans,i-v[num]); //second and after encounters\\n           }\\n           if(num==0){\\n               ans=i+1; //becuase initially state or num is 0\\n           }\\n           i++;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885926,
                "title": "c-dp-solution",
                "content": "# Intuition\\nThe sliding window is fast and nice but I\\'d like to share an alternative solution with dynamic programming. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We maintain a dp array to record the maximum length of the substring with different vowel states ending with the position `i` of the string `s`.\\n- We keep adding new characters and toggling these states until we reach the end of the string `s`.\\n- Record the maximum substring length of state 0 (all vowels are even)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n    - We need to track the maximum length of $2^5=32$ states in each cycle. Although this is considered a constant factor, it\\'s still expensive compared with the sliding window solution.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - First Version: $$O(N)$$\\n    - Space Optimized Version: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n#### DP\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[size + 1][32];       // dp[i + 1][state]: longest substring with state that ends with s[i]\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;     // mark all states unavailable\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;  // if we have odd number of \\'a\\'s, state & 1 == 1\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask) {\\n                    // toggle the even/odd state\\n                    // if it can be transferred from a previous state, we extend its length by 1\\n                    // otherwise, we initiate it with length 1\\n                    dp[i + 1][state] = max(dp[i][state ^ mask] + 1, 1);\\n                } else {\\n                    // same thing but if the previous state is not found, we leave it unavailable\\n                    dp[i + 1][state] = (dp[i][state ^ mask] >= 0) ? dp[i][state ^ mask] + 1 : INT_MIN;\\n                }\\n            }\\n            res = max(res, dp[i + 1][0]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### DP with Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[2][32] = {0};\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask)\\n                    dp[curr][state] = max(dp[prev][state ^ mask] + 1, 1);\\n                else\\n                    dp[curr][state] = (dp[prev][state ^ mask] >= 0) ? dp[prev][state ^ mask] + 1 : INT_MIN;\\n            }\\n            res = max(res, dp[curr][0]);\\n            swap(prev, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[size + 1][32];       // dp[i + 1][state]: longest substring with state that ends with s[i]\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;     // mark all states unavailable\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;  // if we have odd number of \\'a\\'s, state & 1 == 1\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask) {\\n                    // toggle the even/odd state\\n                    // if it can be transferred from a previous state, we extend its length by 1\\n                    // otherwise, we initiate it with length 1\\n                    dp[i + 1][state] = max(dp[i][state ^ mask] + 1, 1);\\n                } else {\\n                    // same thing but if the previous state is not found, we leave it unavailable\\n                    dp[i + 1][state] = (dp[i][state ^ mask] >= 0) ? dp[i][state ^ mask] + 1 : INT_MIN;\\n                }\\n            }\\n            res = max(res, dp[i + 1][0]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int size = s.size();\\n        int dp[2][32] = {0};\\n        int prev = 0, curr = 1;\\n        int res = 0;\\n        for (int state = 0; state < 32; state++)\\n            dp[0][state] = INT_MIN;\\n        for (int i = 0; i < size; i++) {\\n            int mask;\\n            switch(s[i]) {\\n                case \\'a\\': mask = 1; break;\\n                case \\'e\\': mask = 2; break;\\n                case \\'i\\': mask = 4; break;\\n                case \\'o\\': mask = 8; break;\\n                case \\'u\\': mask = 16; break;\\n                default: mask = 0;\\n            }\\n            for (int state = 0; state < 32; state++) {\\n                if (state == mask)\\n                    dp[curr][state] = max(dp[prev][state ^ mask] + 1, 1);\\n                else\\n                    dp[curr][state] = (dp[prev][state ^ mask] >= 0) ? dp[prev][state ^ mask] + 1 : INT_MIN;\\n            }\\n            res = max(res, dp[curr][0]);\\n            swap(prev, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855763,
                "title": "fastest-c-100-speed",
                "content": "# Intuition\\nThe 5 vowels can only be either odd or even, therefore there are only 32 states (2^5). If we store the values of the first appearance of each state, whenever we encounter that state, we can simply take the difference between their indices to find the length.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo represent the state, we can use the first few bits of an integer to represent the parity of each vowel. Making an array containing all 26 letters and using the ascii values of each letter index into the array which will then will retrieve the bits assigned to the vowels which updates the parity of that vowel in the state using an xor. If the state did not yet exist, store the occurance of the index of state.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//You can use char instead of int for the letters and state\\n//Used int hoping it was faster\\n//Wrote out all the arrays to try to squeeze out every last bit of speed\\n    int letters[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n    int findTheLongestSubstring(string s) {\\n        int pos[32] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\\n        int maxLen = 0;\\n        int state = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            state ^= letters[s.at(i)-\\'a\\'];\\n            if (pos[state] == -1 && state) { //pos[0] needs to be -1\\n                pos[state] = i;\\n            }\\n            maxLen = max(maxLen, i-pos[state]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//You can use char instead of int for the letters and state\\n//Used int hoping it was faster\\n//Wrote out all the arrays to try to squeeze out every last bit of speed\\n    int letters[26] = {1,0,0,0,2,0,0,0,4,0,0,0,0,0,8,0,0,0,0,0,16,0,0,0,0,0};\\n    int findTheLongestSubstring(string s) {\\n        int pos[32] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};\\n        int maxLen = 0;\\n        int state = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++) {\\n            state ^= letters[s.at(i)-\\'a\\'];\\n            if (pos[state] == -1 && state) { //pos[0] needs to be -1\\n                pos[state] = i;\\n            }\\n            maxLen = max(maxLen, i-pos[state]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839623,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n#define IS_VOWEL(c) (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        vector<int> prefix;\\n        prefix.reserve(n + 1);\\n        prefix.push_back(0);\\n\\n        for (int i {}; i < n; i++) {\\n            int x = IS_VOWEL(s[i]) ? 1 << (s[i] - \\'a\\') : 0;\\n            prefix.push_back(prefix.back() ^ x);\\n        }\\n\\n        if (prefix.back() == 0) return n;\\n\\n        unordered_map<int, int> idx;\\n        for (int j {}; j < n; ++j) {\\n            idx[prefix[j + 1]] = j;\\n        }\\n\\n        int res = -1;\\n        for (int k {}; k < n; k++) {\\n            auto it = idx.find(prefix[k]);\\n            if (it != idx.end()) res = max(res, it->second - k);\\n        }\\n\\n        return res + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define IS_VOWEL(c) (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size();\\n        vector<int> prefix;\\n        prefix.reserve(n + 1);\\n        prefix.push_back(0);\\n\\n        for (int i {}; i < n; i++) {\\n            int x = IS_VOWEL(s[i]) ? 1 << (s[i] - \\'a\\') : 0;\\n            prefix.push_back(prefix.back() ^ x);\\n        }\\n\\n        if (prefix.back() == 0) return n;\\n\\n        unordered_map<int, int> idx;\\n        for (int j {}; j < n; ++j) {\\n            idx[prefix[j + 1]] = j;\\n        }\\n\\n        int res = -1;\\n        for (int k {}; k < n; k++) {\\n            auto it = idx.find(prefix[k]);\\n            if (it != idx.end()) res = max(res, it->second - k);\\n        }\\n\\n        return res + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836482,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn find_the_longest_substring(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n    let limit = 1 << 5;\\n    let mut memo = vec![vec![];limit];\\n    \\n    let dict = [\\'a\\',\\'i\\',\\'u\\',\\'e\\',\\'o\\'];\\n    let mut now = 0;\\n    for i in 0..n {\\n      memo[now].push(i);\\n      for j in 0..5 {\\n        if s[i] == dict[j] {\\n          let v = 1 << j;\\n          now ^= v;\\n          break\\n        }\\n      }\\n    }\\n    memo[now].push(n);\\n\\n    let mut result = 0;\\n    let mut i = 0;\\n    for arr in memo {\\n      if arr.len() >= 2 {\\n        result = result.max(arr[arr.len()-1] - arr[0]);\\n      }\\n      i += 1;\\n    }\\n    \\n    result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn find_the_longest_substring(s: String) -> i32 {\\n    let s = s.chars().collect::<Vec<char>>();\\n    let n = s.len();\\n    let limit = 1 << 5;\\n    let mut memo = vec![vec![];limit];\\n    \\n    let dict = [\\'a\\',\\'i\\',\\'u\\',\\'e\\',\\'o\\'];\\n    let mut now = 0;\\n    for i in 0..n {\\n      memo[now].push(i);\\n      for j in 0..5 {\\n        if s[i] == dict[j] {\\n          let v = 1 << j;\\n          now ^= v;\\n          break\\n        }\\n      }\\n    }\\n    memo[now].push(n);\\n\\n    let mut result = 0;\\n    let mut i = 0;\\n    for arr in memo {\\n      if arr.len() >= 2 {\\n        result = result.max(arr[arr.len()-1] - arr[0]);\\n      }\\n      i += 1;\\n    }\\n    \\n    result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795113,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int mask=0,mx=0;\\n        string v=\"aeiou\";\\n        for(int i=0;i<size(s);++i){\\n            mask^=(1<<(v.find(s[i])+1))>>1;\\n            if(!mp.count(mask))mp[mask]=i;\\n            mx=max(mx,i-mp[mask]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        mp[0]=-1;\\n        int mask=0,mx=0;\\n        string v=\"aeiou\";\\n        for(int i=0;i<size(s);++i){\\n            mask^=(1<<(v.find(s[i])+1))>>1;\\n            if(!mp.count(mask))mp[mask]=i;\\n            mx=max(mx,i-mp[mask]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700516,
                "title": "c-bitmask-and-prefix-sum",
                "content": "# Intuition\\nthere is a trick which we can use to count substrings satisfying the condition that vowwls should appear even no. of times \\nNote that parity of a character in a string can be reflected by only one bit 0/1 so we use a mask to represent the parity of each character in the prefix;\\n\\ncalculate the mask for each of the prefix of the string and increase its count\\n\\nres += dp[mask] gives the no. of prefixes havign same  mask fo substring (i+1, j) is the string with even parity\\n\\n\\n# Code\\n```\\nclass Solution {\\n    // we need to find the maximum distance between the first and last index for each mask combination.\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        // unordered_map<int, int> seen;\\n        // seen[0] = -1;\\n        mp[\\'a\\'] = 1;\\n        mp[\\'e\\'] = 2;\\n        mp[\\'i\\'] = 3;\\n        mp[\\'o\\'] = 4;\\n        mp[\\'u\\'] = 5;\\n        int n = s.length();\\n        //dp[mask] --> gives the min index for the particular mask\\n        //mask is defined for each prefic of the string \\n        vector<int> dp(1<<6, -1); \\n        dp[0] = -1;\\n        int res = 0, mask=0;//maintain a mask for prefix\\n        for(int i=0; i<n; i++){\\n            mask ^= (1<<mp[s[i]]>>1);\\n            //update the dp[i] is its -1;\\n            if(mask != 0 && dp[mask] == -1)dp[mask] = i;\\n            res = max(res, i-dp[mask]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // we need to find the maximum distance between the first and last index for each mask combination.\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<char, int> mp;\\n        // unordered_map<int, int> seen;\\n        // seen[0] = -1;\\n        mp[\\'a\\'] = 1;\\n        mp[\\'e\\'] = 2;\\n        mp[\\'i\\'] = 3;\\n        mp[\\'o\\'] = 4;\\n        mp[\\'u\\'] = 5;\\n        int n = s.length();\\n        //dp[mask] --> gives the min index for the particular mask\\n        //mask is defined for each prefic of the string \\n        vector<int> dp(1<<6, -1); \\n        dp[0] = -1;\\n        int res = 0, mask=0;//maintain a mask for prefix\\n        for(int i=0; i<n; i++){\\n            mask ^= (1<<mp[s[i]]>>1);\\n            //update the dp[i] is its -1;\\n            if(mask != 0 && dp[mask] == -1)dp[mask] = i;\\n            res = max(res, i-dp[mask]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670224,
                "title": "amazing-problem-c-bitmasking",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(32)\\n\\n# Code\\n## Please Upvote if u found my Solution useful\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(),mask = 0, maxi = 0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(check(s[i]))\\n                mask ^= 1 << (s[i] - \\'a\\');\\n            if(mask == 0){\\n                maxi = i + 1;\\n                continue;\\n            }\\n            if(mp.find(mask) == mp.end())\\n                mp[mask] = i;\\n            else\\n                maxi = max(maxi,i - mp[mask]);\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char ch){\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(),mask = 0, maxi = 0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            if(check(s[i]))\\n                mask ^= 1 << (s[i] - \\'a\\');\\n            if(mask == 0){\\n                maxi = i + 1;\\n                continue;\\n            }\\n            if(mp.find(mask) == mp.end())\\n                mp[mask] = i;\\n            else\\n                maxi = max(maxi,i - mp[mask]);\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663789,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    map<int,int>mp;\\n    int mask=0,mx=0;\\n    mp[0]=-1;\\n    for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\'){\\n            mask^=(1<<(s[i]-\\'a\\'));\\n            if(mp.find(mask)==mp.end()){\\n                mp[mask]=i;\\n            }\\n        } \\n         mx=max(mx,i-mp[mask]);\\n    }  \\n    return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    map<int,int>mp;\\n    int mask=0,mx=0;\\n    mp[0]=-1;\\n    for(int i=0;i<s.length();i++){\\n        if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\'){\\n            mask^=(1<<(s[i]-\\'a\\'));\\n            if(mp.find(mask)==mp.end()){\\n                mp[mask]=i;\\n            }\\n        } \\n         mx=max(mx,i-mp[mask]);\\n    }  \\n    return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640429,
                "title": "go-15ms-linear-bitmask",
                "content": "# Intuition\\nThe idea is to store the state: current parity for every vowel.\\nWe store it as masks: for i-th bit it means ith vowel count is odd.\\n\\nWe shall maintain the state on array $$[0:i]$$, but also for every possible state (2^5 = 32 states) the smallest prefix $$[0:j]$$, with this state. Indeed, if the count is odd on $$[0:i]$$, and it is odd on $$[0:j]$$, then it is even on $$[i:j]$$.\\n\\nThus, the answer is $$i-j$$.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nfunc toIdx(c byte) int {\\n    switch c {\\n        case \\'a\\':\\n            return 0\\n        case \\'e\\':\\n            return 1\\n        case \\'i\\':\\n            return 2\\n        case \\'o\\':\\n            return 3\\n        case \\'u\\':\\n            return 4\\n    }\\n    return -1\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc findTheLongestSubstring(s string) int {\\n    var shortestPrefix [32]int\\n    var state uint\\n    shortestPrefix[state] = 0\\n    ans := 0\\n    for i := 0; i < len(s); i++ {\\n        idx := toIdx(s[i])\\n        if idx >= 0 {\\n            state ^= 1 << idx \\n        }\\n        startIdx := shortestPrefix[state]\\n        if state == 0 || startIdx != 0 {\\n            ans = max(ans, i+1-startIdx)\\n            continue\\n        }\\n        shortestPrefix[state] = i+1\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc toIdx(c byte) int {\\n    switch c {\\n        case \\'a\\':\\n            return 0\\n        case \\'e\\':\\n            return 1\\n        case \\'i\\':\\n            return 2\\n        case \\'o\\':\\n            return 3\\n        case \\'u\\':\\n            return 4\\n    }\\n    return -1\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc findTheLongestSubstring(s string) int {\\n    var shortestPrefix [32]int\\n    var state uint\\n    shortestPrefix[state] = 0\\n    ans := 0\\n    for i := 0; i < len(s); i++ {\\n        idx := toIdx(s[i])\\n        if idx >= 0 {\\n            state ^= 1 << idx \\n        }\\n        startIdx := shortestPrefix[state]\\n        if state == 0 || startIdx != 0 {\\n            ans = max(ans, i+1-startIdx)\\n            continue\\n        }\\n        shortestPrefix[state] = i+1\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3629984,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nint findTheLongestSubstring(char * s){\\n    int max = 0;\\n    int mask = 1;\\n    mask |= ( 1 << ( \\'e\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'i\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'o\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'u\\' - \\'a\\'));\\n    for ( int i = 0 ; i < strlen(s) ; i++){\\n        int sum = 0;\\n        if ( strlen(s) - i < max ){\\n            break;\\n        }\\n        for ( int j = i ; j < strlen(s) ; j++ ){\\n            sum ^= ( 1 << ( s[j] - \\'a\\' ));\\n            if ( (sum & mask) == 0 && (j - i + 1) > max ){\\n                max = j - i + 1;\\n            } \\n        }\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findTheLongestSubstring(char * s){\\n    int max = 0;\\n    int mask = 1;\\n    mask |= ( 1 << ( \\'e\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'i\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'o\\' - \\'a\\'));\\n    mask |= ( 1 << ( \\'u\\' - \\'a\\'));\\n    for ( int i = 0 ; i < strlen(s) ; i++){\\n        int sum = 0;\\n        if ( strlen(s) - i < max ){\\n            break;\\n        }\\n        for ( int j = i ; j < strlen(s) ; j++ ){\\n            sum ^= ( 1 << ( s[j] - \\'a\\' ));\\n            if ( (sum & mask) == 0 && (j - i + 1) > max ){\\n                max = j - i + 1;\\n            } \\n        }\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611931,
                "title": "hashmap-prefix-sum-status-compression-golang",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHashMap + prefix sum + status compression\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc findTheLongestSubstring(s string) int {\\n    cnt := make([]int, 5);\\n    key2idx := make(map[int]int)\\n    key2idx[0] = -1\\n    res := 0\\n    for i, ch := range s {\\n        if ch == \\'a\\' {\\n            cnt[0]++\\n        } else if ch == \\'e\\' {\\n            cnt[1]++\\n        } else if ch == \\'i\\' {\\n            cnt[2]++\\n        } else if ch == \\'o\\' {\\n            cnt[3]++\\n        } else if ch == \\'u\\' {\\n            cnt[4]++\\n        }\\n        key := cnt2key(cnt)\\n        if idx, ok := key2idx[key]; ok {\\n            res = max(res, i - idx)\\n        } else {\\n            key2idx[key] = i\\n        }\\n    }\\n    return res\\n}\\n\\nfunc cnt2key(cnt []int) int {\\n    key := 0\\n    for i, n := range cnt {\\n        if n % 2 == 1 {\\n            key += (1 << i)\\n        }\\n    }\\n    return key\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findTheLongestSubstring(s string) int {\\n    cnt := make([]int, 5);\\n    key2idx := make(map[int]int)\\n    key2idx[0] = -1\\n    res := 0\\n    for i, ch := range s {\\n        if ch == \\'a\\' {\\n            cnt[0]++\\n        } else if ch == \\'e\\' {\\n            cnt[1]++\\n        } else if ch == \\'i\\' {\\n            cnt[2]++\\n        } else if ch == \\'o\\' {\\n            cnt[3]++\\n        } else if ch == \\'u\\' {\\n            cnt[4]++\\n        }\\n        key := cnt2key(cnt)\\n        if idx, ok := key2idx[key]; ok {\\n            res = max(res, i - idx)\\n        } else {\\n            key2idx[key] = i\\n        }\\n    }\\n    return res\\n}\\n\\nfunc cnt2key(cnt []int) int {\\n    key := 0\\n    for i, n := range cnt {\\n        if n % 2 == 1 {\\n            key += (1 << i)\\n        }\\n    }\\n    return key\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592855,
                "title": "c-hash-the-even-and-odd-count-of-vowels-using-the-bits-0-means-even-count-and-1-is-odd",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) because there can be at max (11111) no i.e. 31 numbers in the hashmap\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = 0;\\n        unordered_map<char,int>vovelmp = {{\\'a\\',0}, {\\'e\\',1}, {\\'i\\',2}, {\\'o\\',3},{\\'u\\',4}};\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i<s.size(); i++){\\n            if(vovelmp.count(s[i])){\\n                n^=(1<<vovelmp[s[i]]);\\n            }\\n            // cout<<n<<endl;\\n            if(n == 0){\\n                ans = max(ans, i+1);\\n            }\\n\\n            else{\\n                if(mp.count(n)){\\n                    ans = max(ans, i-mp[n]);\\n                }\\n                else{\\n                    mp[n] = i;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int n = 0;\\n        unordered_map<char,int>vovelmp = {{\\'a\\',0}, {\\'e\\',1}, {\\'i\\',2}, {\\'o\\',3},{\\'u\\',4}};\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        for(int i = 0; i<s.size(); i++){\\n            if(vovelmp.count(s[i])){\\n                n^=(1<<vovelmp[s[i]]);\\n            }\\n            // cout<<n<<endl;\\n            if(n == 0){\\n                ans = max(ans, i+1);\\n            }\\n\\n            else{\\n                if(mp.count(n)){\\n                    ans = max(ans, i-mp[n]);\\n                }\\n                else{\\n                    mp[n] = i;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3496683,
                "title": "find-the-longest-substring-containing-vowels-in-even-counts",
                "content": "----------------- Easy C++ Solution ------------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    int ans = 0;\\n    int prefix = 0;\\n    unordered_map<int, int> preIndex{{0, -1}};\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      int index = string(\"aeiou\").find(s[i]);\\n      if (index != -1)\\n        prefix ^= 1 << index;\\n      if (!preIndex.count(prefix))\\n        preIndex[prefix] = i;\\n      else\\n        ans = max(ans, i - preIndex[prefix]);\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n    int ans = 0;\\n    int prefix = 0;\\n    unordered_map<int, int> preIndex{{0, -1}};\\n\\n    for (int i = 0; i < s.length(); ++i) {\\n      int index = string(\"aeiou\").find(s[i]);\\n      if (index != -1)\\n        prefix ^= 1 << index;\\n      if (!preIndex.count(prefix))\\n        preIndex[prefix] = i;\\n      else\\n        ans = max(ans, i - preIndex[prefix]);\\n    }\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477581,
                "title": "java-easy-to-understand-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public void check(boolean b[],String s,int in,int n){\\n             int a=0,e=0,i=0,o=0,u=0;\\n       for(int k=in;k<n;k++){\\n           if(s.charAt(k)==\\'a\\')\\n                a++;\\n           else if(s.charAt(k)==\\'e\\')\\n                e++;\\n           else if(s.charAt(k)==\\'i\\')\\n                i++;\\n           else if(s.charAt(k)==\\'o\\')\\n                o++;\\n            else if(s.charAt(k)==\\'u\\')\\n                u++;\\n            if(a%2==0 && e%2==0 && i%2==0 && o%2==0 && u%2==0)\\n                b[k]=true;\\n       }\\n        }\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n       boolean[] b=new boolean[n];\\n       check(b,s,0,n);\\n    //    System.out.println(Arrays.toString(b));\\n       int ans=0,i=0;\\n       while(i<n){\\n           int j=n-1;\\n           if(j-i>ans){\\n           while(i<j && !b[j])\\n                j--;\\n            ans=Math.max(ans,j-i+1);\\n            i++;\\n            check(b,s,i,n);\\n       }\\n       else return ans;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n     public void check(boolean b[],String s,int in,int n){\\n             int a=0,e=0,i=0,o=0,u=0;\\n       for(int k=in;k<n;k++){\\n           if(s.charAt(k)==\\'a\\')\\n                a++;\\n           else if(s.charAt(k)==\\'e\\')\\n                e++;\\n           else if(s.charAt(k)==\\'i\\')\\n                i++;\\n           else if(s.charAt(k)==\\'o\\')\\n                o++;\\n            else if(s.charAt(k)==\\'u\\')\\n                u++;\\n            if(a%2==0 && e%2==0 && i%2==0 && o%2==0 && u%2==0)\\n                b[k]=true;\\n       }\\n        }\\n    public int findTheLongestSubstring(String s) {\\n        int n=s.length();\\n       boolean[] b=new boolean[n];\\n       check(b,s,0,n);\\n    //    System.out.println(Arrays.toString(b));\\n       int ans=0,i=0;\\n       while(i<n){\\n           int j=n-1;\\n           if(j-i>ans){\\n           while(i<j && !b[j])\\n                j--;\\n            ans=Math.max(ans,j-i+1);\\n            i++;\\n            check(b,s,i,n);\\n       }\\n       else return ans;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404413,
                "title": "slid-window-zig-zag",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncount the vowels in a slid window\\nto make it more efficient, it slid from left to right then right to left \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        C = Counter(s)\\n        d = True\\n        for i in range(len(s), -1, -1):\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i\\n            if d:\\n                C[s[i-1]] -= 1\\n                irange = range(len(s) - i + 1)\\n                jrange = range(i - 1, len(s))\\n            else:\\n                C[s[-i]] -= 1\\n                irange = reversed(range(i - 1, len(s)))\\n                jrange = reversed(range(len(s) - i + 1))\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i - 1\\n            for l, r in zip(irange, jrange):\\n                # print(l,r, i)\\n                C[s[l]] -= 1\\n                C[s[r]] += 1\\n                if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                    return i - 1\\n            d = not d\\n            # print(d)\\n        return 0\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        C = Counter(s)\\n        d = True\\n        for i in range(len(s), -1, -1):\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i\\n            if d:\\n                C[s[i-1]] -= 1\\n                irange = range(len(s) - i + 1)\\n                jrange = range(i - 1, len(s))\\n            else:\\n                C[s[-i]] -= 1\\n                irange = reversed(range(i - 1, len(s)))\\n                jrange = reversed(range(len(s) - i + 1))\\n            if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                return i - 1\\n            for l, r in zip(irange, jrange):\\n                # print(l,r, i)\\n                C[s[l]] -= 1\\n                C[s[r]] += 1\\n                if all(C[_] % 2 == 0 for _ in \"aeiou\"):\\n                    return i - 1\\n            d = not d\\n            # print(d)\\n        return 0\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340955,
                "title": "java-bitmask-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length();\\n        int[] dp = new int[32];\\n        Arrays.fill(dp, -1);\\n        int[] countArr = new int[5];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            var index = toIndex(s.charAt(i));\\n            if (index != -1) {\\n                countArr[index]++;\\n            }\\n            int mask = 0;\\n            for (int j = 0; j < 5; j++) {\\n                if (countArr[j] % 2 == 1) {\\n                    mask += 1 << j;\\n                }\\n            }\\n            if (mask == 0) {\\n                max = Math.max(max, i + 1);\\n            } else {\\n                if (dp[mask] != -1) {\\n                    max = Math.max(max, i - dp[mask]);\\n                } else {\\n                    dp[mask] = i;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n\\n    private int toIndex(char c) {\\n        switch(c) {\\n            case \\'a\\':\\n                return 0;   \\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            default:\\n                return -1;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length();\\n        int[] dp = new int[32];\\n        Arrays.fill(dp, -1);\\n        int[] countArr = new int[5];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            var index = toIndex(s.charAt(i));\\n            if (index != -1) {\\n                countArr[index]++;\\n            }\\n            int mask = 0;\\n            for (int j = 0; j < 5; j++) {\\n                if (countArr[j] % 2 == 1) {\\n                    mask += 1 << j;\\n                }\\n            }\\n            if (mask == 0) {\\n                max = Math.max(max, i + 1);\\n            } else {\\n                if (dp[mask] != -1) {\\n                    max = Math.max(max, i - dp[mask]);\\n                } else {\\n                    dp[mask] = i;\\n                }\\n            }\\n            \\n        }\\n        return max;\\n    }\\n\\n    private int toIndex(char c) {\\n        switch(c) {\\n            case \\'a\\':\\n                return 0;   \\n            case \\'e\\':\\n                return 1;\\n            case \\'i\\':\\n                return 2;\\n            case \\'o\\':\\n                return 3;\\n            case \\'u\\':\\n                return 4;\\n            default:\\n                return -1;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334629,
                "title": "easy-solution-using-bitmask",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. To check if count of all vowels in the string till now is even or not, we will use a mask. If ith bit is set in mask, then that it means that count of ith vowel is odd and it the ith bit is 0, then it means the count is even.\\n2. We will use a map to store the smallest index for a particular mask.\\n3. Now we will iterate through the string and :\\n    1. update the mask if the current character is vowel.\\n    2. if the value of mask if 0, then it means that count of all vowels is even and we will update our ans to i + 1. \\n    3. if the mask it not 0, then we will check if the mask exist in the map or not. \\n        1. If it exists, then ans = max(ans, i - m[mask]). We do this because if the current mask value is 00001, it indicates an odd count of \\'a\\'. And if m[mask] equals 2, then it means the count of \\'a\\' was also odd at the 2nd index, making the count of \\'a\\' in the substring from 2 to i even.\\n        2. if it does not exists, then we will update m[mask] = i\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<char, int>vowels = {{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}};\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(), ans = 0, mask = 0;\\n        unordered_map<int, int>m;\\n    \\n        for(int i = 0; i < n; i++) {\\n            if(vowels.find(s[i]) != vowels.end()) mask ^= (1 << vowels[s[i]]);\\n            if(mask == 0) ans = i + 1;\\n            if(m.find(mask) != m.end()) ans = max(ans, i - m[mask]);\\n            else m[mask] = i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char, int>vowels = {{\\'a\\', 0}, {\\'e\\', 1}, {\\'i\\', 2}, {\\'o\\', 3}, {\\'u\\', 4}};\\n    int findTheLongestSubstring(string s) {\\n        int n = s.size(), ans = 0, mask = 0;\\n        unordered_map<int, int>m;\\n    \\n        for(int i = 0; i < n; i++) {\\n            if(vowels.find(s[i]) != vowels.end()) mask ^= (1 << vowels[s[i]]);\\n            if(mask == 0) ans = i + 1;\\n            if(m.find(mask) != m.end()) ans = max(ans, i - m[mask]);\\n            else m[mask] = i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334081,
                "title": "java-bitmasking",
                "content": "public int findTheLongestSubstring(String s) {\\n        Map<Character,Integer>hm=new HashMap<>();\\n        hm.put(\\'a\\',0);\\n        hm.put(\\'e\\',1);\\n        hm.put(\\'i\\',2);\\n        hm.put(\\'o\\',3);\\n        hm.put(\\'u\\',4);\\n        int len=0;\\n        Map<Integer,Integer>hm2=new HashMap<>(22);\\n        int odd=0;\\n        hm2.put(0,-1);\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(hm.containsKey(ch)) \\n            odd =(odd)^(1<<hm.get(ch));\\n            hm2.putIfAbsent(odd, i);\\n            len=Math.max(len, i-hm2.get(odd));\\n        }\\n        return len;\\n    }",
                "solutionTags": [],
                "code": "public int findTheLongestSubstring(String s) {\\n        Map<Character,Integer>hm=new HashMap<>();\\n        hm.put(\\'a\\',0);\\n        hm.put(\\'e\\',1);\\n        hm.put(\\'i\\',2);\\n        hm.put(\\'o\\',3);\\n        hm.put(\\'u\\',4);\\n        int len=0;\\n        Map<Integer,Integer>hm2=new HashMap<>(22);\\n        int odd=0;\\n        hm2.put(0,-1);\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(hm.containsKey(ch)) \\n            odd =(odd)^(1<<hm.get(ch));\\n            hm2.putIfAbsent(odd, i);\\n            len=Math.max(len, i-hm2.get(odd));\\n        }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3270987,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int>Map ;\\n        int ans = 0;\\n        Map[0] = -1 ;\\n        int cur = 0 ;\\n        for(int i = 0; i < s.length();i++){\\n            char c = s[i] ;\\n            switch (c) {\\n                case \\'a\\':\\n                    cur ^= 1 ;\\n                    break;\\n                case \\'e\\':\\n                    cur ^= 2 ;\\n                    break;\\n                case \\'i\\':\\n                    cur ^= 4 ;\\n                    break;\\n                case \\'o\\':\\n                    cur ^= 8 ;\\n                    break;\\n                case \\'u\\':\\n                    cur ^= 16 ;\\n                    break;\\n                default:\\n                    break;\\n            }\\n          if (!Map.count(cur))\\n                Map[cur] = i;\\n          ans = max(ans, i - Map[cur]);            \\n        } \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int>Map ;\\n        int ans = 0;\\n        Map[0] = -1 ;\\n        int cur = 0 ;\\n        for(int i = 0; i < s.length();i++){\\n            char c = s[i] ;\\n            switch (c) {\\n                case \\'a\\':\\n                    cur ^= 1 ;\\n                    break;\\n                case \\'e\\':\\n                    cur ^= 2 ;\\n                    break;\\n                case \\'i\\':\\n                    cur ^= 4 ;\\n                    break;\\n                case \\'o\\':\\n                    cur ^= 8 ;\\n                    break;\\n                case \\'u\\':\\n                    cur ^= 16 ;\\n                    break;\\n                default:\\n                    break;\\n            }\\n          if (!Map.count(cur))\\n                Map[cur] = i;\\n          ans = max(ans, i - Map[cur]);            \\n        } \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247928,
                "title": "o-n-maintain-state-without-bitmasks",
                "content": "Since most other solutions use bitmasks/bit operations I thought of implementing the same algorithm without using bitmasks.\\n\\nHere I have a class `State` which stores a boolean array called even. The vowels are mapped to the following position in the array:\\na => 0, e => 1, i => 2, o => 3, u => 4\\n\\nThe boolean array stores for a given index ending in `i`, if the count of each vowel was even or odd upto and including that index. If the count is even for a specific vowel, we store true at the corresponding vowel position, else we store false\\n\\nThe rest of the implementation uses the typical Prefix sum + HashMap approach. \\n\\nWhile using bitmasks is faster, this approach explains the overall idea behind the bitmask approach in a simpler fashion. Hopefully might help you understand the bitmask approach more easily.\\n\\n```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        Map<State, Integer> pos = new HashMap<State, Integer>();\\n        boolean[] even = new boolean[5];\\n\\t\\t// Initially the count of vowels is even. Pre-fill each index position to true\\n        Arrays.fill(even, true);\\n        pos.put(new State(even), -1);\\n        int longest = 0;\\n        char[] c = s.toCharArray();\\n\\t\\t\\n        Map<Character, Integer> vowelPos = new HashMap<Character, Integer>();\\n        vowelPos.put(\\'a\\', 0);\\n        vowelPos.put(\\'e\\', 1);\\n        vowelPos.put(\\'i\\', 2);\\n        vowelPos.put(\\'o\\', 3);\\n        vowelPos.put(\\'u\\', 4);\\n        \\n        for (int i = 0; i < c.length; i++) {\\n            if (isVowel(c[i])) {\\n                int vpos = vowelPos.get(c[i]);\\n                even[vpos] = !even[vpos];\\n            }\\n            State key = new State(even);\\n            if (pos.containsKey(key)) {\\n                longest = Math.max(longest, i - pos.get(key));\\n            } else {\\n                pos.put(key, i);\\n            }          \\n        }\\n        \\n        return longest;\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\nclass State {\\n    boolean[] even;\\n    \\n    public State(boolean[] even) {\\n        this.even = even;\\n    }\\n    \\n    public boolean equals(Object o) {\\n        if (o == null || !(o instanceof State)) {\\n            return false;\\n        }\\n        \\n        State that = (State)o;\\n        \\n        if (even.length != that.even.length) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < even.length; i++) {\\n            if (even[i] != that.even[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int hashCode() {\\n        return Arrays.hashCode(even);\\n    }\\n}                                                              \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        Map<State, Integer> pos = new HashMap<State, Integer>();\\n        boolean[] even = new boolean[5];\\n\\t\\t// Initially the count of vowels is even. Pre-fill each index position to true\\n        Arrays.fill(even, true);\\n        pos.put(new State(even), -1);\\n        int longest = 0;\\n        char[] c = s.toCharArray();\\n\\t\\t\\n        Map<Character, Integer> vowelPos = new HashMap<Character, Integer>();\\n        vowelPos.put(\\'a\\', 0);\\n        vowelPos.put(\\'e\\', 1);\\n        vowelPos.put(\\'i\\', 2);\\n        vowelPos.put(\\'o\\', 3);\\n        vowelPos.put(\\'u\\', 4);\\n        \\n        for (int i = 0; i < c.length; i++) {\\n            if (isVowel(c[i])) {\\n                int vpos = vowelPos.get(c[i]);\\n                even[vpos] = !even[vpos];\\n            }\\n            State key = new State(even);\\n            if (pos.containsKey(key)) {\\n                longest = Math.max(longest, i - pos.get(key));\\n            } else {\\n                pos.put(key, i);\\n            }          \\n        }\\n        \\n        return longest;\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\nclass State {\\n    boolean[] even;\\n    \\n    public State(boolean[] even) {\\n        this.even = even;\\n    }\\n    \\n    public boolean equals(Object o) {\\n        if (o == null || !(o instanceof State)) {\\n            return false;\\n        }\\n        \\n        State that = (State)o;\\n        \\n        if (even.length != that.even.length) {\\n            return false;\\n        }\\n        \\n        for (int i = 0; i < even.length; i++) {\\n            if (even[i] != that.even[i]) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int hashCode() {\\n        return Arrays.hashCode(even);\\n    }\\n}                                                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239268,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func findTheLongestSubstring(_ s: String) -> Int {\\n        \\n        let ss = Array(s)\\n        let cs = Array(\"aeiou\")\\n        var cm = Array(repeating: Array(repeating: true, count: cs.count), count: ss.count + 1)\\n\\n        var ii = [0]\\n        var la = cs.count\\n        var res = 0\\n\\n        for i in ss.indices {\\n            \\n            cm[i + 1] = cm[i]\\n\\n            guard let j = cs.firstIndex(of: ss[i]) else { continue }\\n            cm[i + 1][j] = !cm[i][j]\\n\\n            let nla = cm[i + 1].filter({ $0 }).count\\n            guard nla != la else { continue }\\n\\n            ii += [i - 1, i, i + 1].filter {\\n                $0 >= 0 && $0 < ss.count && (ii.isEmpty || $0 > ii.last!)\\n            }\\n\\n            la = nla\\n        }\\n\\n        if ii.last != ss.count - 1 { ii.append(ss.count - 1) }\\n\\n        for i in 0..<ii.count {\\n            \\n            let l = ii[i]\\n            guard l + res <= ss.count else { break }\\n\\n            for j in (i..<ii.count).reversed() {\\n                let r = ii[j]\\n                guard r - l >= res || res == 0 else { break }\\n\\n                guard cm[l] == cm[r + 1] else { continue }\\n                res = r - l + 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findTheLongestSubstring(_ s: String) -> Int {\\n        \\n        let ss = Array(s)\\n        let cs = Array(\"aeiou\")\\n        var cm = Array(repeating: Array(repeating: true, count: cs.count), count: ss.count + 1)\\n\\n        var ii = [0]\\n        var la = cs.count\\n        var res = 0\\n\\n        for i in ss.indices {\\n            \\n            cm[i + 1] = cm[i]\\n\\n            guard let j = cs.firstIndex(of: ss[i]) else { continue }\\n            cm[i + 1][j] = !cm[i][j]\\n\\n            let nla = cm[i + 1].filter({ $0 }).count\\n            guard nla != la else { continue }\\n\\n            ii += [i - 1, i, i + 1].filter {\\n                $0 >= 0 && $0 < ss.count && (ii.isEmpty || $0 > ii.last!)\\n            }\\n\\n            la = nla\\n        }\\n\\n        if ii.last != ss.count - 1 { ii.append(ss.count - 1) }\\n\\n        for i in 0..<ii.count {\\n            \\n            let l = ii[i]\\n            guard l + res <= ss.count else { break }\\n\\n            for j in (i..<ii.count).reversed() {\\n                let r = ii[j]\\n                guard r - l >= res || res == 0 else { break }\\n\\n                guard cm[l] == cm[r + 1] else { continue }\\n                res = r - l + 1\\n            }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184315,
                "title": "easy-c-solutions-for-beginners-using-masking",
                "content": "# Intuition\\nWe can make a mask of size 5 for \\'a\\', \\'e\\', \\'i\\', \\'o\\' & \\'u\\' respectively and we will update that mask on each iteration and we\\'ll check if that mask is present in our hash map if it is already present we will update our answer or else we\\'ll addd that mask in our map.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map< vector<int>, int> m;\\n        vector<int> v(5,0);\\n        m[v] = -1;\\n        int ans =0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\'){\\n                v[0] ^= 1;\\n            }\\n            else if(s[i]==\\'e\\'){\\n                v[1] ^= 1;\\n            }\\n            else if(s[i]==\\'i\\'){\\n                v[2] ^= 1;\\n            }\\n            else if(s[i]==\\'o\\'){\\n                v[3] ^= 1;\\n            }\\n            else if(s[i]==\\'u\\'){\\n                v[4] ^= 1;\\n            }\\n            if(m.find(v)!=m.end()){\\n                ans = max(ans,i-m[v]);\\n            }\\n            else m[v] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map< vector<int>, int> m;\\n        vector<int> v(5,0);\\n        m[v] = -1;\\n        int ans =0;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\'){\\n                v[0] ^= 1;\\n            }\\n            else if(s[i]==\\'e\\'){\\n                v[1] ^= 1;\\n            }\\n            else if(s[i]==\\'i\\'){\\n                v[2] ^= 1;\\n            }\\n            else if(s[i]==\\'o\\'){\\n                v[3] ^= 1;\\n            }\\n            else if(s[i]==\\'u\\'){\\n                v[4] ^= 1;\\n            }\\n            if(m.find(v)!=m.end()){\\n                ans = max(ans,i-m[v]);\\n            }\\n            else m[v] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118634,
                "title": "72-15-faster-c-bitmask-hashmap-simple-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool isvowel(char c){\\n        return c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\';\\n    }\\n\\n    int findTheLongestSubstring(string s) {\\n        ll n=s.length(),mask=0,answer=0;\\n        unordered_map<ll,ll>mp;mp[0]=-1;\\n        unordered_map<char,ll>ss;ss[\\'a\\']=0;ss[\\'e\\']=1;ss[\\'i\\']=2;ss[\\'o\\']=3;ss[\\'u\\']=4;\\n        for(ll i=0;i<n;i++){\\n            if(isvowel(s[i])){\\n                mask=mask^(1<<(ss[s[i]]));\\n            }\\n            if(mp.find(mask)!=mp.end()){\\n                answer=max(answer,i-mp[mask]);\\n            }\\n            else{\\n                mp[mask]=i;\\n            }\\n        }\\n        return answer;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    bool isvowel(char c){\\n        return c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\';\\n    }\\n\\n    int findTheLongestSubstring(string s) {\\n        ll n=s.length(),mask=0,answer=0;\\n        unordered_map<ll,ll>mp;mp[0]=-1;\\n        unordered_map<char,ll>ss;ss[\\'a\\']=0;ss[\\'e\\']=1;ss[\\'i\\']=2;ss[\\'o\\']=3;ss[\\'u\\']=4;\\n        for(ll i=0;i<n;i++){\\n            if(isvowel(s[i])){\\n                mask=mask^(1<<(ss[s[i]]));\\n            }\\n            if(mp.find(mask)!=mp.end()){\\n                answer=max(answer,i-mp[mask]);\\n            }\\n            else{\\n                mp[mask]=i;\\n            }\\n        }\\n        return answer;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104482,
                "title": "faster-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let mut res = 0;\\n        let mut state = 0;\\n        let mut seen = vec![-1; 1 << 5];\\n        seen[0] = 0;\\n        for (i, c) in s.chars().enumerate() {\\n            match c {\\n                \\'a\\' => state ^= 1 << 0,\\n                \\'e\\' => state ^= 1 << 1,\\n                \\'i\\' => state ^= 1 << 2,\\n                \\'o\\' => state ^= 1 << 3,\\n                \\'u\\' => state ^= 1 << 4,\\n                _ => {}\\n            }\\n            if seen[state] >= 0 {\\n                res = res.max(i + 1 - seen[state] as usize);\\n            } else {\\n                seen[state] = i as i32 + 1;\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn find_the_longest_substring(s: String) -> i32 {\\n        let mut res = 0;\\n        let mut state = 0;\\n        let mut seen = vec![-1; 1 << 5];\\n        seen[0] = 0;\\n        for (i, c) in s.chars().enumerate() {\\n            match c {\\n                \\'a\\' => state ^= 1 << 0,\\n                \\'e\\' => state ^= 1 << 1,\\n                \\'i\\' => state ^= 1 << 2,\\n                \\'o\\' => state ^= 1 << 3,\\n                \\'u\\' => state ^= 1 << 4,\\n                _ => {}\\n            }\\n            if seen[state] >= 0 {\\n                res = res.max(i + 1 - seen[state] as usize);\\n            } else {\\n                seen[state] = i as i32 + 1;\\n            }\\n        }\\n        res as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001726,
                "title": "simple-logic-with-explanation",
                "content": "# Complexity\\n- Time complexity:O(n)  n is the length of string s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)     maximum value of n is 26\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nWe are storing unique bit position of vowels.\\nSo that single bit is representing presence of that vowel and rest of the bit is zero\\n\\n00001 - a  -> 1\\n00010 - e  -> 1<<1\\n00100 - i  -> 1<<2\\n01000 - o  -> 1<<3\\n10000 - u  -> 1<<4\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        \\n         Dictionary<char,int> dic=new Dictionary<char,int>(){{\\'a\\',1},{\\'e\\',1<<1},{\\'i\\',1<<2},{\\'o\\',1<<3},{\\'u\\',1<<4}};\\n         HashSet<char> hs=new HashSet<char>{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n         int mask=0,max=int.MinValue;\\n         Dictionary<int,int> position=new();\\n         position.Add(0,-1);\\n\\n         for(int i=0;i<s.Length;i++)\\n         {\\n             if(hs.Contains(s[i]))\\n               mask=mask^dic[s[i]];\\n\\n            if(!position.ContainsKey(mask))\\n               position[mask]=i;\\n\\n            max=Math.Max(max,i-position[mask]);        \\n         }\\n         return max;\\n    }\\n}\\n\\n```\\n\\nIf you have any doubts please comment below.I will answer as soon as possible.\\n\\nThanks !!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        \\n         Dictionary<char,int> dic=new Dictionary<char,int>(){{\\'a\\',1},{\\'e\\',1<<1},{\\'i\\',1<<2},{\\'o\\',1<<3},{\\'u\\',1<<4}};\\n         HashSet<char> hs=new HashSet<char>{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n         int mask=0,max=int.MinValue;\\n         Dictionary<int,int> position=new();\\n         position.Add(0,-1);\\n\\n         for(int i=0;i<s.Length;i++)\\n         {\\n             if(hs.Contains(s[i]))\\n               mask=mask^dic[s[i]];\\n\\n            if(!position.ContainsKey(mask))\\n               position[mask]=i;\\n\\n            max=Math.Max(max,i-position[mask]);        \\n         }\\n         return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993458,
                "title": "op-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int returnbit(char c)\\n    {\\n        if (c==\\'a\\')\\n            return 1;\\n        else if (c==\\'e\\')\\n            return 2;\\n        else if (c==\\'i\\')\\n            return 4;\\n        else if (c==\\'o\\')\\n            return 8;\\n        else if (c==\\'u\\')\\n            return 16;\\n        else\\n            return -1;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            int r=returnbit(s[i]);\\n            if (r==-1)\\n            {\\n               r=0;\\n            }\\n            mask=mask^r;\\n            if (mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[mask]);\\n            }\\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int returnbit(char c)\\n    {\\n        if (c==\\'a\\')\\n            return 1;\\n        else if (c==\\'e\\')\\n            return 2;\\n        else if (c==\\'i\\')\\n            return 4;\\n        else if (c==\\'o\\')\\n            return 8;\\n        else if (c==\\'u\\')\\n            return 16;\\n        else\\n            return -1;\\n    }\\n    int findTheLongestSubstring(string s) {\\n        int mask=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;\\n        int ans=0;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            int r=returnbit(s[i]);\\n            if (r==-1)\\n            {\\n               r=0;\\n            }\\n            mask=mask^r;\\n            if (mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[mask]);\\n            }\\n            else\\n                mp[mask]=i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955714,
                "title": "easy-to-understand-solution-short-and-concise",
                "content": "Please Upvote! If you like it.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int mask = 0,maxLen = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n                mask^=s[i];\\n                if(!mp.count(mask))\\n                    mp[mask] = i;\\n            }\\n            maxLen = max(maxLen,i-mp[mask]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n        int mask = 0,maxLen = 0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\') {\\n                mask^=s[i];\\n                if(!mp.count(mask))\\n                    mp[mask] = i;\\n            }\\n            maxLen = max(maxLen,i-mp[mask]);\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902875,
                "title": "renowned-approach-in-different-fashion",
                "content": "# **JAI HIND JAI BHARAT**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.)you should know xor usage.\\n2.)X-OR works for numbers only not for char.\\n3.) 0 ^ \\'a\\' is not correct ,hence assign numbers to these vowels\\n   like a->1,e->2,i->4,o->8,u->16.......\\n4.)through a for loop , move on string s & make a map for xor values you obtain.\\n5.)If seen before simply calculate the length.\\n6.)return max possible length.\\n\\nDO UPVOTE IF HAVE GOT THE LOGIC\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int>mp1;\\n        mp1[\\'a\\']=1;\\n        mp1[\\'e\\']=2;\\n        mp1[\\'i\\']=4;\\n        mp1[\\'o\\']=8;\\n        mp1[\\'u\\']=16;\\n        map<int,int>mp2;\\n        mp2[0]= -1;\\n        int len = 0;\\n        int demo = 0;\\n        for(int i = 0;i<s.size();++i)\\n        {\\n            demo = demo ^ mp1[s[i]];\\n            if(mp2.count(demo)==0)\\n            {\\n                mp2[demo] = i;\\n            }\\n            else\\n            {\\n                len = max(len,i - mp2[demo]);\\n            }\\n        }\\n        return len;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int>mp1;\\n        mp1[\\'a\\']=1;\\n        mp1[\\'e\\']=2;\\n        mp1[\\'i\\']=4;\\n        mp1[\\'o\\']=8;\\n        mp1[\\'u\\']=16;\\n        map<int,int>mp2;\\n        mp2[0]= -1;\\n        int len = 0;\\n        int demo = 0;\\n        for(int i = 0;i<s.size();++i)\\n        {\\n            demo = demo ^ mp1[s[i]];\\n            if(mp2.count(demo)==0)\\n            {\\n                mp2[demo] = i;\\n            }\\n            else\\n            {\\n                len = max(len,i - mp2[demo]);\\n            }\\n        }\\n        return len;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899038,
                "title": "simple-python-solution-using-rolling-and-prefix-counter-no-bit-manipulation",
                "content": "Idea is simple: we take a rolling counter and record the first time we see some encoding. To find the longest substring with even counts, we just look at the first time we saw the same encoding.\\n\\nWhy? Say we have some count like `a: 1, e: 3, i: 5, o: 4, u: 2`\\nThe encoding of this counter would be (odd, odd, odd, even, even)\\nHow can we make this counter all even?\\n\\nWell, we need to subtract an odd number of `a`, an odd number of `e`, an even odd number of `i`, an even number of `o`, and an even number of `u`. That\\'s the exact same encoding (odd, odd, odd, even, even). To get the longest such, we want the *first* time we saw this counter.\\n\\nHopefully you can see how this is similar to some prefix sum problems.\\n\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def encode(c):\\n            return c[\\'a\\']%2, c[\\'e\\']%2, c[\\'i\\']%2, c[\\'o\\']%2, c[\\'u\\']%2\\n        \\n        longest = 0\\n        memo = {}\\n        counter = collections.Counter()\\n        memo[encode(counter)] = -1\\n        for i, char in enumerate(s):\\n            counter[char] += 1\\n            code = encode(counter)\\n            if code not in memo:\\n                memo[code] = i\\n            else:\\n                longest = max(longest, i-memo[code])\\n        return longest\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        def encode(c):\\n            return c[\\'a\\']%2, c[\\'e\\']%2, c[\\'i\\']%2, c[\\'o\\']%2, c[\\'u\\']%2\\n        \\n        longest = 0\\n        memo = {}\\n        counter = collections.Counter()\\n        memo[encode(counter)] = -1\\n        for i, char in enumerate(s):\\n            counter[char] += 1\\n            code = encode(counter)\\n            if code not in memo:\\n                memo[code] = i\\n            else:\\n                longest = max(longest, i-memo[code])\\n        return longest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876874,
                "title": "c-detailed-explanation-with-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is inspired by [this post](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solutions/534135/c-java-with-picture/?orderBy=most_votes).\\nThis question is an impletation of [560. Subarray Sum Equals K](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solutions/534135/c-java-with-picture/?orderBy=most_votes).\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. For every index \\'i\\' we need to see which vowels count are even and which vowels count are odd.\\n2. We use bit manipulation to see whether the count is even or odd since we don\\'t need the total count in this case. We use the least significant 5 bits to mark the 5 vowels.\\n3. If the current mask is 0 we can say that our substring from s[0 to i] contains only even characters since all the 5 least significant bits are set to 0.\\n4. We can also say that our substring s[i+1 to j] (where mask[i] = mask[j])\\ncontains only even vowels since at \\'i only those bits were set which are set at \\'j\\'.   eg - at mask[i] = 00101 and at index mask[j] = 00101, then that means s[i+1 to j] contains only even number of each vowels since we are discarding the previous occurences till index \\'i\\'.\\n# Complexity\\n- Time complexity: \\n O(n) {String is traversed only once.}\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n O(1) {Only constant extra space of O(128) is used which can be further reduced if required.}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //1 - (-1) , 5 - 1\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int , int>codeFirstSeen;\\n        vector<int>mask(128 , 0);\\n        mask[\\'a\\'] = 1 << 0;\\n        mask[\\'e\\'] = 1 << 1;\\n        mask[\\'i\\'] = 1 << 2;\\n        mask[\\'o\\'] = 1 << 3;\\n        mask[\\'u\\'] = 1 << 4;\\n        int currMask = 0;\\n        codeFirstSeen[currMask] = -1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            char ch = s[i];\\n            currMask = currMask ^ mask[ch];\\n            if(currMask != 0 and codeFirstSeen.find(currMask) == codeFirstSeen.end())\\n            {\\n                codeFirstSeen[currMask] = i;\\n            }\\n            ans = max(ans , i - codeFirstSeen[currMask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    //1 - (-1) , 5 - 1\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int , int>codeFirstSeen;\\n        vector<int>mask(128 , 0);\\n        mask[\\'a\\'] = 1 << 0;\\n        mask[\\'e\\'] = 1 << 1;\\n        mask[\\'i\\'] = 1 << 2;\\n        mask[\\'o\\'] = 1 << 3;\\n        mask[\\'u\\'] = 1 << 4;\\n        int currMask = 0;\\n        codeFirstSeen[currMask] = -1;\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            char ch = s[i];\\n            currMask = currMask ^ mask[ch];\\n            if(currMask != 0 and codeFirstSeen.find(currMask) == codeFirstSeen.end())\\n            {\\n                codeFirstSeen[currMask] = i;\\n            }\\n            ans = max(ans , i - codeFirstSeen[currMask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838505,
                "title": "easy-c-solution-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int bit=0;\\n        int ans=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                bit=bit^(1<<(s[i]-\\'a\\'));\\n            }\\n            if(mp.find(bit)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[bit]);\\n            }\\n            else\\n            {\\n                 mp[bit]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int,int>mp;\\n        int bit=0;\\n        int ans=0;\\n        mp[0]=-1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n            {\\n                bit=bit^(1<<(s[i]-\\'a\\'));\\n            }\\n            if(mp.find(bit)!=mp.end())\\n            {\\n                ans=max(ans,i-mp[bit]);\\n            }\\n            else\\n            {\\n                 mp[bit]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790093,
                "title": "clear-and-clean-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        int num = 0;\\n        mp[0] = -1;\\n        for(int i = 0; i < s.size(); i++){\\n             if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                 ans = ans ^ (1 << (s[i] - \\'a\\'));\\n            if(mp.find(ans) == mp.end())\\n                 mp[ans] = i;\\n            else\\n                num = max(num,i - mp[ans]);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans = 0;\\n        unordered_map<int,int>mp;\\n        int num = 0;\\n        mp[0] = -1;\\n        for(int i = 0; i < s.size(); i++){\\n             if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\')\\n                 ans = ans ^ (1 << (s[i] - \\'a\\'));\\n            if(mp.find(ans) == mp.end())\\n                 mp[ans] = i;\\n            else\\n                num = max(num,i - mp[ans]);\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782593,
                "title": "easy-c-solution-bitmask",
                "content": "```\\nint findTheLongestSubstring(string s) {\\n       vector<int>mask(32,-1);\\n        int m=0;\\n        int maxlen=0;\\n      \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'i\\'){\\n                m=m^((s[i]-\\'a\\')+1);\\n            }\\n            else{\\n                m=m^0;\\n            }\\n            if(m!=0&&mask[m]==-1){\\n                mask[m]=i;\\n            }\\n            else{\\n                maxlen=max(maxlen,i-mask[m]);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint findTheLongestSubstring(string s) {\\n       vector<int>mask(32,-1);\\n        int m=0;\\n        int maxlen=0;\\n      \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'i\\'){\\n                m=m^((s[i]-\\'a\\')+1);\\n            }\\n            else{\\n                m=m^0;\\n            }\\n            if(m!=0&&mask[m]==-1){\\n                mask[m]=i;\\n            }\\n            else{\\n                maxlen=max(maxlen,i-mask[m]);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683023,
                "title": "python-solution-simple-bitmask-and-xor",
                "content": "2 notes:\\n1.  dict.get is slow. Use \"if key not in dict\" check instead\\n2.  We only the front and back of the indices. So keep only two indices for each state\\n```\\nclass Solution:\\n    # We do not care about non vowels\\n    # and there are only 5 vowels, aeiou\\n    # And we do not care about the exact number, but only if they are odd or even.\\n    # Therefore we might use a bitmask of length 5 to represent the vowels\\n    # The number of possible states is only 32\\n    # We can then iterate through s\\n    # If we see non vowels, we simply attach the current index to the XOR key\\n    # If we see vowels, we update the current key by applying ^ (1<<i)\\n    # Afterwards, we can easily find the longest substring by subtracting the last index of x and first index of x^0\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = \"aeiou\"\\n        vowels_map = {}\\n        for i, c in enumerate(vowels):\\n            vowels_map[c] = i\\n        \\n        hash_table, prefix = {}, 0\\n        hash_table[0] = [-1]\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                prefix ^= (1 << vowels_map[c])\\n            if prefix not in hash_table:\\n                hash_table[prefix] = []\\n            if len(hash_table[prefix]) <= 1:\\n                hash_table[prefix].append(i)\\n            else:\\n                hash_table[prefix][-1] = i\\n        \\n        result = 0\\n        for i in range(1<<5):\\n            if i in hash_table and i^0 in hash_table:\\n                result = max(result, hash_table[i][-1]-hash_table[i^0][0])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # We do not care about non vowels\\n    # and there are only 5 vowels, aeiou\\n    # And we do not care about the exact number, but only if they are odd or even.\\n    # Therefore we might use a bitmask of length 5 to represent the vowels\\n    # The number of possible states is only 32\\n    # We can then iterate through s\\n    # If we see non vowels, we simply attach the current index to the XOR key\\n    # If we see vowels, we update the current key by applying ^ (1<<i)\\n    # Afterwards, we can easily find the longest substring by subtracting the last index of x and first index of x^0\\n    \\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = \"aeiou\"\\n        vowels_map = {}\\n        for i, c in enumerate(vowels):\\n            vowels_map[c] = i\\n        \\n        hash_table, prefix = {}, 0\\n        hash_table[0] = [-1]\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                prefix ^= (1 << vowels_map[c])\\n            if prefix not in hash_table:\\n                hash_table[prefix] = []\\n            if len(hash_table[prefix]) <= 1:\\n                hash_table[prefix].append(i)\\n            else:\\n                hash_table[prefix][-1] = i\\n        \\n        result = 0\\n        for i in range(1<<5):\\n            if i in hash_table and i^0 in hash_table:\\n                result = max(result, hash_table[i][-1]-hash_table[i^0][0])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581796,
                "title": "python-solution",
                "content": "```\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\': 16, \\'e\\': 8, \\'i\\': 4, \\'o\\': 2, \\'u\\': 1}\\n        vote_dict = {0: -1}\\n        vcount = 0\\n        ans = 0\\n        for idx, c in enumerate(s):\\n            if c in vowels.keys():\\n                vcount = vcount ^ vowels[c]\\n            \\n            if vcount in vote_dict.keys():\\n                ans = max(ans, idx - vote_dict[vcount])\\n            else:\\n                vote_dict[vcount] = idx\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\': 16, \\'e\\': 8, \\'i\\': 4, \\'o\\': 2, \\'u\\': 1}\\n        vote_dict = {0: -1}\\n        vcount = 0\\n        ans = 0\\n        for idx, c in enumerate(s):\\n            if c in vowels.keys():\\n                vcount = vcount ^ vowels[c]\\n            \\n            if vcount in vote_dict.keys():\\n                ans = max(ans, idx - vote_dict[vcount])\\n            else:\\n                vote_dict[vcount] = idx\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2556756,
                "title": "prefixsum-map-c-o-n-solution",
                "content": "```\\n int findTheLongestSubstring(string s) {\\n        \\n        //its like all those problems jisme map use krke hum previous positiom dekhte ki ye sum kaha pr aya previously us hisab se size nikalte bs  yaha sum ke bdle xor hoga xor kyu hoga ?? xor isliye hoga kuki yaa to koi vowel odd time(1) occur hoga ya even time(0) 0,1 values ki form me represent kr skte aur agar prefix xor krte krte hume same mask mila lets suppose 2nd position tk \\'e\\' odd numeber me the nd 9th pos me b \\'e\\' odd numbers me the to in dono ka mask ki \\'e-\\'0\\' th bit 1 hogi mtlb ki same mask vps mila to mtlb 2-9 ke bich me jo substring hai usme even number of \\'e\\' hoge . SO THIS QUESTION IS A MIXTURE OF BITMASK,PREFIX-SUM and MAP.\\n        map<int,int> m;\\n        int num=0,maxLen=0;\\n        m[num]=-1;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n              if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n                 num^=(1<<(s[i]-\\'a\\'));\\n            \\n            if(m.find(num)!=m.end()) //same mask have already occured before\\n                maxLen=max(maxLen,i-m[num]);\\n            else\\n                m[num]=i;\\n        }\\n        \\n        return maxLen;\\n    }",
                "solutionTags": [],
                "code": "```\\n int findTheLongestSubstring(string s) {\\n        \\n        //its like all those problems jisme map use krke hum previous positiom dekhte ki ye sum kaha pr aya previously us hisab se size nikalte bs  yaha sum ke bdle xor hoga xor kyu hoga ?? xor isliye hoga kuki yaa to koi vowel odd time(1) occur hoga ya even time(0) 0,1 values ki form me represent kr skte aur agar prefix xor krte krte hume same mask mila lets suppose 2nd position tk \\'e\\' odd numeber me the nd 9th pos me b \\'e\\' odd numbers me the to in dono ka mask ki \\'e-\\'0\\' th bit 1 hogi mtlb ki same mask vps mila to mtlb 2-9 ke bich me jo substring hai usme even number of \\'e\\' hoge . SO THIS QUESTION IS A MIXTURE OF BITMASK,PREFIX-SUM and MAP.\\n        map<int,int> m;\\n        int num=0,maxLen=0;\\n        m[num]=-1;\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n              if(s[i]==\\'a\\' or s[i]==\\'e\\' or s[i]==\\'i\\' or s[i]==\\'o\\' or s[i]==\\'u\\')\\n                 num^=(1<<(s[i]-\\'a\\'));\\n            \\n            if(m.find(num)!=m.end()) //same mask have already occured before\\n                maxLen=max(maxLen,i-m[num]);\\n            else\\n                m[num]=i;\\n        }\\n        \\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2541980,
                "title": "c-bit-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }\\n            else\\n                mp[cnt]=i;\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    map<char,int>m;\\n    int findTheLongestSubstring(string s)\\n    {\\n        m[\\'a\\']=1;m[\\'e\\']=2;m[\\'i\\']=3;m[\\'o\\']=4;m[\\'u\\']=5;\\n        map<int ,int>mp;\\n        mp[0]=-1;\\n        int cnt=0,ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\' || s[i]==\\'e\\' || s[i]==\\'i\\'|| s[i]==\\'o\\' || s[i]==\\'u\\')\\n            cnt=cnt^(1<<(m[s[i]]));\\n           // cout<<cnt<<\" \";\\n            if(mp.count(cnt))\\n            {\\n                ans=max(ans,i-mp[cnt]);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2505884,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int mask = 0, ans = 0, val;\\n        \\n        mp[0] = -1;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            val = 0;\\n             \\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' ||\\n              s[i] == \\'u\\')\\n            {\\n                val = s[i];\\n            }\\n            \\n            mask = mask ^ val;\\n            \\n            if(!mp.count(mask))\\n            {\\n                mp[mask] = i;\\n            }\\n            \\n            ans = max(ans, i-mp[mask]);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        int mask = 0, ans = 0, val;\\n        \\n        mp[0] = -1;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            val = 0;\\n             \\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' ||\\n              s[i] == \\'u\\')\\n            {\\n                val = s[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2473378,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<char,int>c_m;\\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    c_m[\\'a\\']=1;\\n    c_m[\\'e\\']=2;\\n    c_m[\\'i\\']=3;\\n    c_m[\\'o\\']=4;\\n    c_m[\\'u\\']=5;\\n    unordered_map<int,int>m;\\n    m[0]=-1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= 1<<c_m[s[i]];\\n        int f=mask;\\n        f=f>>1;\\n       if(m.find(f)==m.end())\\n       {\\n           m[f]=i;\\n       }\\n        res = max(res, i - m[f]);\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    unordered_map<char,int>c_m;\\nint findTheLongestSubstring(string s) {\\n    int mask = 0, res = 0;\\n    c_m[\\'a\\']=1;\\n    c_m[\\'e\\']=2;\\n    c_m[\\'i\\']=3;\\n    c_m[\\'o\\']=4;\\n    c_m[\\'u\\']=5;\\n    unordered_map<int,int>m;\\n    m[0]=-1;\\n    for (int i = 0; i < s.size(); ++i) {\\n        mask ^= 1<<c_m[s[i]];\\n        int f=mask;\\n        f=f>>1;\\n       if(m.find(f)==m.end())\\n       {\\n           m[f]=i;\\n       }\\n        res = max(res, i - m[f]);\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453095,
                "title": "easy-c-bitwise-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        //use bit mask of length 5\\n        vector<int> mp(40,-2);\\n        int mask=0;\\n        vector<int> arr(26,0);\\n        int res=0;\\n        arr[0]=4;\\n        arr[\\'e\\'-\\'a\\']=3;\\n        arr[\\'i\\'-\\'a\\']=2;\\n        arr[\\'o\\'-\\'a\\']=1;\\n        arr[\\'u\\'-\\'a\\']=0;\\n        mp[0]=-1;\\n        //the mask will be the sawe if some substring has even number of vowels\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isVowel(s[i]))\\n                mask=mask^(1<<arr[s[i]-\\'a\\']);\\n            if(mp[mask]!=-2)\\n                res=max(res,i-mp[mask]);\\n            if(mp[mask]==-2)\\n                mp[mask]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c)\\n    {\\n        return (c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\');\\n    }\\n    int findTheLongestSubstring(string s) {\\n        //use bit mask of length 5\\n        vector<int> mp(40,-2);\\n        int mask=0;\\n        vector<int> arr(26,0);\\n        int res=0;\\n        arr[0]=4;\\n        arr[\\'e\\'-\\'a\\']=3;\\n        arr[\\'i\\'-\\'a\\']=2;\\n        arr[\\'o\\'-\\'a\\']=1;\\n        arr[\\'u\\'-\\'a\\']=0;\\n        mp[0]=-1;\\n        //the mask will be the sawe if some substring has even number of vowels\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(isVowel(s[i]))\\n                mask=mask^(1<<arr[s[i]-\\'a\\']);\\n            if(mp[mask]!=-2)\\n                res=max(res,i-mp[mask]);\\n            if(mp[mask]==-2)\\n                mp[mask]=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374990,
                "title": "c-easy-solu",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int n=s.size();\\n        int mask=0;\\n      unordered_map<int,set<int>>mp;\\n        mp[0].insert(-1);\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            if(s[i]==\\'a\\')\\n            {\\n                mask^=(1<<0);\\n            }\\n            else if(s[i]==\\'e\\')\\n            {\\n                mask^=(1<<1);\\n            }else if(s[i]==\\'i\\')\\n            {\\n                mask^=(1<<2);\\n            }\\n           else if(s[i]==\\'o\\')\\n            {\\n                mask^=(1<<3);\\n            }\\n            else if(s[i]==\\'u\\')\\n            {\\n                mask^=(1<<4);\\n            }\\n            if(mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-(*mp[mask].begin()));\\n            }\\n            \\n            mp[mask].insert(i);  \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int n=s.size();\\n        int mask=0;\\n      unordered_map<int,set<int>>mp;\\n        mp[0].insert(-1);\\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            \\n            if(s[i]==\\'a\\')\\n            {\\n                mask^=(1<<0);\\n            }\\n            else if(s[i]==\\'e\\')\\n            {\\n                mask^=(1<<1);\\n            }else if(s[i]==\\'i\\')\\n            {\\n                mask^=(1<<2);\\n            }\\n           else if(s[i]==\\'o\\')\\n            {\\n                mask^=(1<<3);\\n            }\\n            else if(s[i]==\\'u\\')\\n            {\\n                mask^=(1<<4);\\n            }\\n            if(mp.find(mask)!=mp.end())\\n            {\\n                ans=max(ans,i-(*mp[mask].begin()));\\n            }\\n            \\n            mp[mask].insert(i);  \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348372,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        D = {} \\n        numa = 0 \\n        nume = 0 \\n        numi = 0 \\n        numo = 0 \\n        numu = 0 \\n        \\n        ans = 0 \\n        for ind, c in enumerate(s):\\n            numa += c == \\'a\\'\\n            nume += c == \\'e\\' \\n            numi += c == \\'i\\'\\n            numo += c == \\'o\\'\\n            numu += c == \\'u\\'\\n            \\n            if (numa%2,nume%2,numi%2,numo%2,numu%2) not in D : \\n                D[(numa%2,nume%2,numi%2,numo%2,numu%2)] = ind \\n            else:\\n                ans = max(ans,ind -D[(numa%2,nume%2,numi%2,numo%2,numu%2)] )\\n            \\n            if numa%2==0 and nume%2==0 and numi%2==0 and numo%2==0 and numu%2==0:\\n                ans = max(ans,ind+1) \\n\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        \\n        vowels = [\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']\\n        D = {}",
                "codeTag": "Java"
            },
            {
                "id": 2321451,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int ans=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            String str=s.substring(0,i+1);\\n            int ch[]=new int[26];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                ch[str.charAt(j)-\\'a\\']++;\\n            }\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n            for(int j=1;j<s.length()-i;j++)\\n            {\\n                \\n                ch[s.charAt(j-1)-\\'a\\']--;\\n                ch[s.charAt(j+i)-\\'a\\']++;\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n          }\\n            if(ans!=0)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int ans=0;\\n        for(int i=s.length()-1;i>=0;i--)\\n        {\\n            String str=s.substring(0,i+1);\\n            int ch[]=new int[26];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                ch[str.charAt(j)-\\'a\\']++;\\n            }\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n            for(int j=1;j<s.length()-i;j++)\\n            {\\n                \\n                ch[s.charAt(j-1)-\\'a\\']--;\\n                ch[s.charAt(j+i)-\\'a\\']++;\\n            if(ch[0]%2==0 && ch[4]%2==0 && ch[8]%2==0 && ch[14]%2==0 && ch[20]%2==0)\\n            {\\n                ans=str.length();\\n                break;\\n            }\\n          }\\n            if(ans!=0)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319675,
                "title": "c-17-mapping-from-vowel-bitmask-to-the-left-most-position-of-its-occurrences",
                "content": "\\n\\n```\\n// Ideas / Approach: similar to LongestAwsomeSubstring.\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        // vowels: a e i o u\\n        // bit #:  0 1 2 3 4\\n\\n        // * because we care only about whether a vowel\\'s occurrences are even or odd, using a\\n        // single bit in a bitmask suffices the needs.\\n        // 5 vowels ==> 5 bits in a bitmask ==> 2^5 entries, ie 32 entries.\\n        // since the entries are just a small number, we can use an array to serve as the mapping.\\n\\n        // * because we wants the longest substring, in the mapping from vowel-bitmask to position,\\n        //   we\\'ll keep the position of the leftmost occurrence of a vowel-bitmask.\\n        // * at each iteration, we queries the mapping that wether the same bitmask occurred before.\\n        // If it does, then the distance between the leftmost occurrence and the current pos is a\\n        // candidate.\\n\\n        array<int, 32> m{}; //  leftMostPosForBitMask\\n        const int NotMeaningful = s.size();\\n        for (int i = 0; i < 32; ++i) {\\n            m[i] = NotMeaningful;\\n        }\\n\\n        m[0] = -1; // all-zero mask occurs before the s[0] is processed.\\n\\n        int best = 0;\\n        int8_t mask = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            int8_t vowelBit = VowelToBit(s[i]);\\n            if (vowelBit > 0) {\\n                mask ^= vowelBit;\\n            }\\n            if (m[mask] == NotMeaningful) { // not found\\n                m[mask] = i;\\n            } else {\\n                int len = i - m[mask];\\n                best = max(best, len);\\n            }\\n        }\\n\\n        return best;\\n    }\\n\\nprivate:\\n    static inline int8_t VowelToBit(char c) {\\n        switch (c) {\\n        case \\'a\\':\\n            return 1;\\n        case \\'e\\':\\n            return 1 << 1;\\n        case \\'i\\':\\n            return 1 << 2;\\n        case \\'o\\':\\n            return 1 << 3;\\n        case \\'u\\':\\n            return 1 << 4;\\n\\n        default:\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n// Ideas / Approach: similar to LongestAwsomeSubstring.\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        // vowels: a e i o u\\n        // bit #:  0 1 2 3 4\\n\\n        // * because we care only about whether a vowel\\'s occurrences are even or odd, using a\\n        // single bit in a bitmask suffices the needs.\\n        // 5 vowels ==> 5 bits in a bitmask ==> 2^5 entries, ie 32 entries.\\n        // since the entries are just a small number, we can use an array to serve as the mapping.\\n\\n        // * because we wants the longest substring, in the mapping from vowel-bitmask to position,\\n        //   we\\'ll keep the position of the leftmost occurrence of a vowel-bitmask.\\n        // * at each iteration, we queries the mapping that wether the same bitmask occurred before.\\n        // If it does, then the distance between the leftmost occurrence and the current pos is a\\n        // candidate.\\n\\n        array<int, 32> m{}; //  leftMostPosForBitMask\\n        const int NotMeaningful = s.size();\\n        for (int i = 0; i < 32; ++i) {\\n            m[i] = NotMeaningful;\\n        }\\n\\n        m[0] = -1; // all-zero mask occurs before the s[0] is processed.\\n\\n        int best = 0;\\n        int8_t mask = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            int8_t vowelBit = VowelToBit(s[i]);\\n            if (vowelBit > 0) {\\n                mask ^= vowelBit;\\n            }\\n            if (m[mask] == NotMeaningful) { // not found\\n                m[mask] = i;\\n            } else {\\n                int len = i - m[mask];\\n                best = max(best, len);\\n            }\\n        }\\n\\n        return best;\\n    }\\n\\nprivate:\\n    static inline int8_t VowelToBit(char c) {\\n        switch (c) {\\n        case \\'a\\':\\n            return 1;\\n        case \\'e\\':\\n            return 1 << 1;\\n        case \\'i\\':\\n            return 1 << 2;\\n        case \\'o\\':\\n            return 1 << 3;\\n        case \\'u\\':\\n            return 1 << 4;\\n\\n        default:\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316023,
                "title": "using-mapper-and-mask",
                "content": "```\\n\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        int mask = 0, res = 0;\\n        int[] m = new int[32];\\n        Array.Fill(m, -1);\\n        for (int i = 0; i < s.Length; ++i) {\\n            mask ^= mapper(s[i]);\\n            if (mask != 0 && m[mask] == -1)\\n                m[mask] = i;\\n            res = Math.Max(res, i - m[mask]);\\n        }\\n        return res;\\n    }\\n    private int mapper(char c){\\n        return c switch{\\n                \\'a\\' => 1,\\n                \\'e\\'=>2,\\n                \\'i\\'=>4,\\n                \\'o\\'=>8,\\n                \\'u\\'=>16,\\n                _=>0,\\n        };\\n    }\\n}\\n```\\nO(n)",
                "solutionTags": [],
                "code": "```\\n\\npublic class Solution {\\n    public int FindTheLongestSubstring(string s) {\\n        int mask = 0, res = 0;\\n        int[] m = new int[32];\\n        Array.Fill(m, -1);\\n        for (int i = 0; i < s.Length; ++i) {\\n            mask ^= mapper(s[i]);\\n            if (mask != 0 && m[mask] == -1)\\n                m[mask] = i;\\n            res = Math.Max(res, i - m[mask]);\\n        }\\n        return res;\\n    }\\n    private int mapper(char c){\\n        return c switch{\\n                \\'a\\' => 1,\\n                \\'e\\'=>2,\\n                \\'i\\'=>4,\\n                \\'o\\'=>8,\\n                \\'u\\'=>16,\\n                _=>0,\\n        };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278647,
                "title": "python-100-time-commented",
                "content": "Small speedup by only updating the max substring length when a new vowel is seen, otherwise it\\'s just like everyone else\\'s solution.\\n\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        #lookup table mapping vowels to bit locations for the XOR operation\\n        self.vowel_XOR_dict = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}\\n\\n        \\n    def findTheLongestSubstring(self, s):        \\n        #min_index_list[vowel_parity = p] is the index of the min length prefix with vowel parity p\\n        #-1 corresponds to the empty prefix (which has parity 0), thus min_index_list[0]=-1\\n        min_index_list = {0:-1}\\n        \\n        #maximum length of substrings with even # of vowels\\n        max_length = 0\\n        \\n        #current vowel parity\\n        vowel_parity = 0\\n        \\n        #iterate through each character in s\\n        for i in range(len(s)):          \\n            #if we see a vowel...\\n            if s[i] in self.vowel_XOR_dict:\\n                #since the parity is changing at index i, \\n                #then index i-1 is the largest index seen so far at the previous parity\\n                #so, update the maximum length substring value\\n                max_length = max(max_length,i-1-min_index_list[vowel_parity])\\n                \\n                #update the current parity\\n                vowel_parity^=self.vowel_XOR_dict[s[i]]\\n                \\n                #if we have not seen this parity before, put it in the minimum index list\\n                if vowel_parity not in min_index_list:\\n                    min_index_list[vowel_parity] = i\\n                    \\n        #update the maximum length substring value for the parity of the last prefix (whole string)      \\n        max_length = max(max_length,len(s)-1-min_index_list[vowel_parity])\\n        return max_length\\n\\t\\t",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def __init__(self):\\n        #lookup table mapping vowels to bit locations for the XOR operation\\n        self.vowel_XOR_dict = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}",
                "codeTag": "Java"
            },
            {
                "id": 2268777,
                "title": "java-bitmask-dp-solution-o-n-2-5",
                "content": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length(), ans = 0;\\n        char[] vowels = new char[] {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // dp[i][mask] -> longest substring ends at i with the vowels occurred odd(bit value = 1)/even(bit value = 0) number of times\\n        int[][] dp = new int[n+1][1<<5];\\n        for (int i = 0; i <= n; i++) Arrays.fill(dp[i], -(1<<30));\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int j = idx(s.charAt(i-1), vowels);\\n            if (j!=-1) dp[i][1<<j] = 1;\\n            else dp[i][0] = 1;\\n            for (int msk = 0; msk < 1<<5; msk++) {\\n                if (j!=-1) {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk^(1<<j)] + 1);\\n                }\\n                else {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk] + 1);\\n                }\\n            }\\n            ans = Math.max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int idx(char c, char[] vowels) {\\n        for (int i = 0; i < vowels.length; i++) {\\n            if (vowels[i] == c) return vowels.length-i-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n        int n = s.length(), ans = 0;\\n        char[] vowels = new char[] {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        // dp[i][mask] -> longest substring ends at i with the vowels occurred odd(bit value = 1)/even(bit value = 0) number of times\\n        int[][] dp = new int[n+1][1<<5];\\n        for (int i = 0; i <= n; i++) Arrays.fill(dp[i], -(1<<30));\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int j = idx(s.charAt(i-1), vowels);\\n            if (j!=-1) dp[i][1<<j] = 1;\\n            else dp[i][0] = 1;\\n            for (int msk = 0; msk < 1<<5; msk++) {\\n                if (j!=-1) {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk^(1<<j)] + 1);\\n                }\\n                else {\\n                    dp[i][msk] = Math.max(dp[i][msk], dp[i-1][msk] + 1);\\n                }\\n            }\\n            ans = Math.max(ans, dp[i][0]);\\n        }\\n        return ans;\\n    }\\n    public int idx(char c, char[] vowels) {\\n        for (int i = 0; i < vowels.length; i++) {\\n            if (vowels[i] == c) return vowels.length-i-1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255592,
                "title": "c",
                "content": "int findTheLongestSubstring(char * s){\\n    int window = 0;\\n    int posBitMap[26] = {0};\\n    posBitMap[\\'a\\'-\\'a\\'] = 1;\\n    posBitMap[\\'e\\' - \\'a\\'] = 2;\\n    posBitMap[\\'i\\' - \\'a\\'] = 4;\\n    posBitMap[\\'o\\' - \\'a\\'] = 8;\\n    posBitMap[\\'u\\' - \\'a\\'] = 16;\\n    \\n    int xorChar = 0;\\n    int count = 0;\\n    int states[32] = {0};\\n\\n    for(int clrSt = 0; clrSt < 32; clrSt++)\\n        states[clrSt] = -1;\\n    for(window = 0; s[window] != NULL; window++)\\n    {\\n        xorChar = xorChar ^ posBitMap[s[window] - \\'a\\'];\\n\\n        if(states[xorChar] == -1 && xorChar != 0)\\n        {\\n            states[xorChar] = window;\\n        }\\n\\n        count = count > (window - states[xorChar]) ? count : (window - states[xorChar]);    \\n    }\\n    return count;\\n}\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "int findTheLongestSubstring(char * s){\\n    int window = 0;\\n    int posBitMap[26] = {0};\\n    posBitMap[\\'a\\'-\\'a\\'] = 1;\\n    posBitMap[\\'e\\' - \\'a\\'] = 2;\\n    posBitMap[\\'i\\' - \\'a\\'] = 4;\\n    posBitMap[\\'o\\' - \\'a\\'] = 8;\\n    posBitMap[\\'u\\' - \\'a\\'] = 16;\\n    \\n    int xorChar = 0;\\n    int count = 0;\\n    int states[32] = {0};\\n\\n    for(int clrSt = 0; clrSt < 32; clrSt++)\\n        states[clrSt] = -1;\\n    for(window = 0; s[window] != NULL; window++)\\n    {\\n        xorChar = xorChar ^ posBitMap[s[window] - \\'a\\'];\\n\\n        if(states[xorChar] == -1 && xorChar != 0)\\n        {\\n            states[xorChar] = window;\\n        }\\n\\n        count = count > (window - states[xorChar]) ? count : (window - states[xorChar]);    \\n    }\\n    return count;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2214354,
                "title": "clean-c-solution-with-bitmasking",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n  int findTheLongestSubstring(string s)\\n    {\\n\\n        unordered_map<char, int> vowelpos;\\n        unordered_map<int, int> sametypeidx;\\n\\n        vowelpos[\\'a\\'] = 4;\\n        vowelpos[\\'e\\'] = 3;\\n        vowelpos[\\'i\\'] = 2;\\n        vowelpos[\\'o\\'] = 1;\\n        vowelpos[\\'u\\'] = 0;\\n\\n        int res = 0;\\n\\n        int mask=0;\\n\\n        sametypeidx[0]=-1;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n\\n            if(vowelpos.count(s[i]))\\n            mask=mask^(1<<vowelpos[s[i]]);\\n\\n            if (sametypeidx.count(mask))\\n                res = max(res, i - sametypeidx[mask]);\\n\\n            else\\n                sametypeidx[mask] = i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n  int findTheLongestSubstring(string s)\\n    {\\n\\n        unordered_map<char, int> vowelpos;\\n        unordered_map<int, int> sametypeidx;\\n\\n        vowelpos[\\'a\\'] = 4;\\n        vowelpos[\\'e\\'] = 3;\\n        vowelpos[\\'i\\'] = 2;\\n        vowelpos[\\'o\\'] = 1;\\n        vowelpos[\\'u\\'] = 0;\\n\\n        int res = 0;\\n\\n        int mask=0;\\n\\n        sametypeidx[0]=-1;\\n\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n\\n            if(vowelpos.count(s[i]))\\n            mask=mask^(1<<vowelpos[s[i]]);\\n\\n            if (sametypeidx.count(mask))\\n                res = max(res, i - sametypeidx[mask]);\\n\\n            else\\n                sametypeidx[mask] = i;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210856,
                "title": "python-simple-logic",
                "content": "\\n    def findTheLongestSubstring(self, s):\\n        vowels = {\"a\":1, \"e\":2, \"i\":4, \"o\":8, \"u\":16}\\n        dict1, cur, max_len = {0:-1}, 0, 0\\n        \\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                cur = cur^vowels[c]\\n            if cur not in dict1:\\n                dict1[cur] = i\\n            else:\\n                max_len = max(max_len, i - dict1[cur])\\n                \\n        return max_len",
                "solutionTags": [],
                "code": "\\n    def findTheLongestSubstring(self, s):\\n        vowels = {\"a\":1, \"e\":2, \"i\":4, \"o\":8, \"u\":16}\\n        dict1, cur, max_len = {0:-1}, 0, 0\\n        \\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                cur = cur^vowels[c]\\n            if cur not in dict1:\\n                dict1[cur] = i\\n            else:\\n                max_len = max(max_len, i - dict1[cur])\\n                \\n        return max_len",
                "codeTag": "Python3"
            },
            {
                "id": 2209495,
                "title": "c-code-hashing-and-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int> mp;\\n        map<int,int> m;\\n        \\n        mp[\\'a\\']=1;\\n        mp[\\'e\\']=2;\\n        mp[\\'i\\']=4;\\n        mp[\\'o\\']=8;\\n        mp[\\'u\\']=16;\\n        \\n        m[0]=-1;\\n        int jor=0,i=0;\\n        int n=s.length();\\n        int ans=0;\\n        \\n        while (i<n){\\n            if (mp[s[i]]){\\n                jor^=mp[s[i]];\\n            }\\n            \\n            if (m.find(jor)!=m.end()){\\n                ans=max(ans,i-m[jor]);\\n            }\\n            \\n            if (m.find(jor)==m.end()){\\n                m[jor]=i;\\n            }\\n            i++;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        map<char,int> mp;\\n        map<int,int> m;\\n        \\n        mp[\\'a\\']=1;\\n        mp[\\'e\\']=2;\\n        mp[\\'i\\']=4;\\n        mp[\\'o\\']=8;\\n        mp[\\'u\\']=16;\\n        \\n        m[0]=-1;\\n        int jor=0,i=0;\\n        int n=s.length();\\n        int ans=0;\\n        \\n        while (i<n){\\n            if (mp[s[i]]){\\n                jor^=mp[s[i]];\\n            }\\n            \\n            if (m.find(jor)!=m.end()){\\n                ans=max(ans,i-m[jor]);\\n            }\\n            \\n            if (m.find(jor)==m.end()){\\n                m[jor]=i;\\n            }\\n            i++;\\n        }\\n        \\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196775,
                "title": "c-solution-by-sliding-window-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int n = s.size();\\n        unordered_map<char, int> mapping;\\n        /*\\n            {a: 0, e: 1, i: 2, o: 3, u: 4}, other letter: -1\\n        */\\n        mapping.insert({\\'a\\', 0});\\n        mapping.insert({\\'e\\', 1});\\n        mapping.insert({\\'i\\', 2});\\n        mapping.insert({\\'o\\', 3});\\n        mapping.insert({\\'u\\', 4});\\n        for (int letter = 0; letter < 26; letter++){\\n            char c = letter + \\'a\\';\\n            if (mapping.count(c) == 0){\\n                mapping.insert({c, -1});\\n            }\\n        }\\n        vector<vector<int>> prefix(5, vector<int>(n, 0));\\n        char c = s[0];\\n        if (mapping[c] != -1){\\n            prefix[mapping[c]][0] = 1;\\n        }\\n        for (int i = 1; i < n; i++){\\n            int current_letter = mapping[s[i]];\\n            for (int letter = 0; letter < 5; letter++){\\n                prefix[letter][i] = prefix[letter][i - 1];\\n                if (current_letter == letter){\\n                    prefix[letter][i]++;\\n                }\\n            }\\n        }\\n        for (int sliding = n; sliding > 0; sliding--){\\n            if (is_satisfied(prefix, n, mapping, sliding)){\\n                return sliding;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool is_satisfied(vector<vector<int>>& prefix, int n, unordered_map<char, int>& mapping, int sliding){\\n        // printf(\"sliding = %d\\\\n\", sliding);\\n        int vowels[5];\\n        for (int start = 0; start <= n - sliding; start++){\\n            int back = start + sliding - 1;\\n            // take look at [start, back]\\n            bool satisfied = true;\\n            if (start == 0){\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back];\\n                }\\n            }\\n            else{\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back] - prefix[letter][start - 1];\\n                }\\n            }\\n            for (int letter = 0; letter < 5; letter++){\\n                if (vowels[letter] % 2 != 0){\\n                    // printf(\"return false.\\\\n\");\\n                    satisfied = false;\\n                    break;\\n                }\\n            }\\n            if (satisfied){\\n                // printf(\"return true, satisfied region is[%d, %d]\\\\n\", start, back);\\n                // for (int letter = 0; letter < 5; letter++){\\n                //     printf(\"letter:%c, count:%d\\\\n\", letter + \\'a\\', vowels[letter]);\\n                // }\\n                return true;\\n            }\\n        }\\n        // printf(\"return false.\\\\n\");\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        \\n        int n = s.size();\\n        unordered_map<char, int> mapping;\\n        /*\\n            {a: 0, e: 1, i: 2, o: 3, u: 4}, other letter: -1\\n        */\\n        mapping.insert({\\'a\\', 0});\\n        mapping.insert({\\'e\\', 1});\\n        mapping.insert({\\'i\\', 2});\\n        mapping.insert({\\'o\\', 3});\\n        mapping.insert({\\'u\\', 4});\\n        for (int letter = 0; letter < 26; letter++){\\n            char c = letter + \\'a\\';\\n            if (mapping.count(c) == 0){\\n                mapping.insert({c, -1});\\n            }\\n        }\\n        vector<vector<int>> prefix(5, vector<int>(n, 0));\\n        char c = s[0];\\n        if (mapping[c] != -1){\\n            prefix[mapping[c]][0] = 1;\\n        }\\n        for (int i = 1; i < n; i++){\\n            int current_letter = mapping[s[i]];\\n            for (int letter = 0; letter < 5; letter++){\\n                prefix[letter][i] = prefix[letter][i - 1];\\n                if (current_letter == letter){\\n                    prefix[letter][i]++;\\n                }\\n            }\\n        }\\n        for (int sliding = n; sliding > 0; sliding--){\\n            if (is_satisfied(prefix, n, mapping, sliding)){\\n                return sliding;\\n            }\\n        }\\n        return 0;\\n    }\\n    bool is_satisfied(vector<vector<int>>& prefix, int n, unordered_map<char, int>& mapping, int sliding){\\n        // printf(\"sliding = %d\\\\n\", sliding);\\n        int vowels[5];\\n        for (int start = 0; start <= n - sliding; start++){\\n            int back = start + sliding - 1;\\n            // take look at [start, back]\\n            bool satisfied = true;\\n            if (start == 0){\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back];\\n                }\\n            }\\n            else{\\n                for (int letter = 0; letter < 5; letter++){\\n                    vowels[letter] = prefix[letter][back] - prefix[letter][start - 1];\\n                }\\n            }\\n            for (int letter = 0; letter < 5; letter++){\\n                if (vowels[letter] % 2 != 0){\\n                    // printf(\"return false.\\\\n\");\\n                    satisfied = false;\\n                    break;\\n                }\\n            }\\n            if (satisfied){\\n                // printf(\"return true, satisfied region is[%d, %d]\\\\n\", start, back);\\n                // for (int letter = 0; letter < 5; letter++){\\n                //     printf(\"letter:%c, count:%d\\\\n\", letter + \\'a\\', vowels[letter]);\\n                // }\\n                return true;\\n            }\\n        }\\n        // printf(\"return false.\\\\n\");\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187909,
                "title": "easy-python-solution",
                "content": "```\\nv = {\\'a\\':0, \\'e\\':1, \\'i\\':2, \\'o\\':3, \\'u\\':4}\\ncurr = 0\\nleft = dict()\\nleft[0] = -1\\nans = 0\\nfor index, i in enumerate(s):\\n\\tif(i in v):\\n\\t\\tcurr ^= (1<<v[i])\\n\\tif(curr not in left):\\n\\t\\tleft[curr] = index\\n\\telse:\\n\\t\\tans = max(ans, index - left[curr])\\nreturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nv = {\\'a\\':0, \\'e\\':1, \\'i\\':2, \\'o\\':3, \\'u\\':4}\\ncurr = 0\\nleft = dict()\\nleft[0] = -1\\nans = 0\\nfor index, i in enumerate(s):\\n\\tif(i in v):\\n\\t\\tcurr ^= (1<<v[i])\\n\\tif(curr not in left):\\n\\t\\tleft[curr] = index\\n\\telse:\\n\\t\\tans = max(ans, index - left[curr])\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2161265,
                "title": "javascript-bitmask-prefix-sum-173ms",
                "content": "```\\nconst findTheLongestSubstring = (s) => {\\n    let n = s.length, m = new Map([[0, -1]]), res = 0, cur = 0, mask = [1, 2, 4, 8, 16];\\n    for (let i = 0; i < n; i++) {\\n        let idx = \\'aeiou\\'.indexOf(s[i]);\\n        if (idx != -1) cur ^= mask[idx];\\n        if (!m.has(cur)) m.set(cur, i); // set min index for cur\\n        let len = i - m.get(cur);\\n        res = Math.max(res, len);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nconst findTheLongestSubstring = (s) => {\\n    let n = s.length, m = new Map([[0, -1]]), res = 0, cur = 0, mask = [1, 2, 4, 8, 16];\\n    for (let i = 0; i < n; i++) {\\n        let idx = \\'aeiou\\'.indexOf(s[i]);\\n        if (idx != -1) cur ^= mask[idx];\\n        if (!m.has(cur)) m.set(cur, i); // set min index for cur\\n        let len = i - m.get(cur);\\n        res = Math.max(res, len);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140451,
                "title": "python-bitmask-clean-code",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        first_occured_index = defaultdict(lambda:float(\\'inf\\'),{0:-1})\\n        cur = res = 0\\n        for i, c in enumerate(s):\\n            if c in \"aeiou\":\\n                cur ^= (1<<(ord(c)-ord(\\'a\\')))\\n                first_occured_index[cur] = min(first_occured_index[cur], i)\\n            res = max(res, i-first_occured_index[cur])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        first_occured_index = defaultdict(lambda:float(\\'inf\\'),{0:-1}",
                "codeTag": "Java"
            },
            {
                "id": 2135967,
                "title": "c-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string A ) {\\n        \\n        string vowel = \"aeiou\";\\n        \\n        for( auto &x : A )\\n        {\\n            if( count(vowel.begin() , vowel.end(),x) )\\n            {\\n                if( x == \\'a\\' ) x = \\'0\\';\\n                if( x == \\'e\\' ) x = \\'1\\';\\n                if( x == \\'i\\' ) x = \\'2\\';\\n                if( x == \\'o\\' ) x = \\'3\\';\\n                if( x == \\'u\\' ) x = \\'4\\';\\n                \\n            }\\n        }\\n        \\n        unordered_map< string , int > M ;\\n        string t = \"00000\";\\n        \\n        M[t] = -1 ;\\n        \\n        int mx = 0 ;\\n        \\n        for( int i = 0 ; i < A.size() ; i++ )\\n        {\\n            if( A[i] >= \\'0\\' && A[i] <= \\'4\\' )\\n                t[A[i]-\\'0\\']++;\\n            \\n            for( auto &x : t )\\n            {\\n                int v = x-\\'0\\';\\n                v %= 2 ;\\n                \\n                x = v + \\'0\\';\\n            }\\n            \\n            if( M.find(t) != M.end() )\\n                mx = max( mx , i - M[t] );\\n\\n            if( M.find(t) == M.end() )\\n                M[t] = i ; \\n        }\\n        return mx ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string A ) {\\n        \\n        string vowel = \"aeiou\";\\n        \\n        for( auto &x : A )\\n        {\\n            if( count(vowel.begin() , vowel.end(),x) )\\n            {\\n                if( x == \\'a\\' ) x = \\'0\\';\\n                if( x == \\'e\\' ) x = \\'1\\';\\n                if( x == \\'i\\' ) x = \\'2\\';\\n                if( x == \\'o\\' ) x = \\'3\\';\\n                if( x == \\'u\\' ) x = \\'4\\';\\n                \\n            }\\n        }\\n        \\n        unordered_map< string , int > M ;\\n        string t = \"00000\";\\n        \\n        M[t] = -1 ;\\n        \\n        int mx = 0 ;\\n        \\n        for( int i = 0 ; i < A.size() ; i++ )\\n        {\\n            if( A[i] >= \\'0\\' && A[i] <= \\'4\\' )\\n                t[A[i]-\\'0\\']++;\\n            \\n            for( auto &x : t )\\n            {\\n                int v = x-\\'0\\';\\n                v %= 2 ;\\n                \\n                x = v + \\'0\\';\\n            }\\n            \\n            if( M.find(t) != M.end() )\\n                mx = max( mx , i - M[t] );\\n\\n            if( M.find(t) == M.end() )\\n                M[t] = i ; \\n        }\\n        return mx ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130968,
                "title": "c-o-n-bitmask-for-vowels-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m;\\n        unordered_map<char, int> xx;\\n        xx[\\'a\\'] = 0;\\n        xx[\\'e\\'] = 1;\\n        xx[\\'i\\'] = 2;\\n        xx[\\'o\\'] = 3;\\n        xx[\\'u\\'] = 4;\\n        int num = 0, ans = 0;\\n        m[num] = -1;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(xx.find(s[i]) != xx.end())\\n                num^=(1<<xx[s[i]]);\\n            if(m.find(num) != m.end())\\n                ans = max(ans, i - m[num]);\\n            else\\n                m[num] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        unordered_map<int, int> m;\\n        unordered_map<char, int> xx;\\n        xx[\\'a\\'] = 0;\\n        xx[\\'e\\'] = 1;\\n        xx[\\'i\\'] = 2;\\n        xx[\\'o\\'] = 3;\\n        xx[\\'u\\'] = 4;\\n        int num = 0, ans = 0;\\n        m[num] = -1;\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(xx.find(s[i]) != xx.end())\\n                num^=(1<<xx[s[i]]);\\n            if(m.find(num) != m.end())\\n                ans = max(ans, i - m[num]);\\n            else\\n                m[num] = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096710,
                "title": "python-bitmask-o-n-fastest-and-fugal",
                "content": "I have explanained step by step usign comments.\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define seen dict to store last seen position of mask\\n        seen = {0: -1}\\n        res = cur = 0\\n        \\n        # As vowels in fixed so manually define in dictionary\\n        vowel = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}\\n        \\n        \\n        for i, c in enumerate(s):\\n            # if it\\'s not vowel then return 0\\n            cur ^= vowel.get(c,0)\\n            \\n            # save mask with it\\'s seen position if it dosen\\'t set yet\\n            seen.setdefault(cur, i)\\n            \\n            res = max(res, i - seen[cur])\\n        return res\\n```\\n\\n**upVote^** if you find this helpful. Comment below for any query.",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        # define seen dict to store last seen position of mask\\n        seen = {0: -1}\\n        res = cur = 0\\n        \\n        # As vowels in fixed so manually define in dictionary\\n        vowel = {\\'a\\':1,\\'e\\':2,\\'i\\':4,\\'o\\':8,\\'u\\':16}\\n        \\n        \\n        for i, c in enumerate(s):\\n            # if it\\'s not vowel then return 0\\n            cur ^= vowel.get(c,0)\\n            \\n            # save mask with it\\'s seen position if it dosen\\'t set yet\\n            seen.setdefault(cur, i)\\n            \\n            res = max(res, i - seen[cur])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036375,
                "title": "go-o-n",
                "content": "```\\npackage q_1371\\n\\nvar (\\n\\tVowels2Idx = map[rune]int{\\n\\t\\t\\'a\\': 0,\\n\\t\\t\\'e\\': 1,\\n\\t\\t\\'i\\': 2,\\n\\t\\t\\'o\\': 3,\\n\\t\\t\\'u\\': 4,\\n\\t}\\n)\\n\\ntype VowelsCountManager struct {\\n\\tvowels2Idx          map[rune]int\\n\\tvowelsCnt2MaxStrIdx map[int]int\\n\\tvowelsCnt2MinStrIdx map[int]int\\n}\\n\\nfunc NewVowelsCountManager() (retHandler *VowelsCountManager) {\\n\\tretHandler = &VowelsCountManager{\\n\\t\\tvowels2Idx:          Vowels2Idx,\\n\\t\\tvowelsCnt2MaxStrIdx: map[int]int{},\\n\\t\\tvowelsCnt2MinStrIdx: map[int]int{\\n\\t\\t\\t0: -1,\\n\\t\\t},\\n\\t}\\n\\treturn retHandler\\n}\\n\\nfunc (h *VowelsCountManager) Count(s string) (retLen int) {\\n\\truneArr := []rune(s)\\n\\tbitMap := 0\\n\\tfor idx, char := range runeArr {\\n\\t\\tif vIdx, isVowel := h.vowels2Idx[char]; isVowel {\\n\\t\\t\\tbitMap ^= 1 << vIdx\\n\\t\\t\\t//fmt.Println(bitMap)\\n\\t\\t}\\n\\t\\tif max, exist := h.vowelsCnt2MaxStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t} else if max < idx {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t\\tif min, exist := h.vowelsCnt2MinStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t} else if min > idx {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t}\\n\\t//fmt.Println(h.vowelsCnt2MaxStrIdx)\\n\\t//fmt.Println(h.vowelsCnt2MinStrIdx)\\n\\tfor bitMap, max := range h.vowelsCnt2MaxStrIdx {\\n\\t\\tif min, minExist := h.vowelsCnt2MinStrIdx[bitMap]; minExist {\\n\\t\\t\\tlen := max - min\\n\\t\\t\\tif len > retLen {\\n\\t\\t\\t\\tretLen = len\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn retLen\\n}\\n\\nfunc findTheLongestSubstring(s string) (retLen int) {\\n\\th := NewVowelsCountManager()\\n\\tretLen = h.Count(s)\\n\\treturn\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npackage q_1371\\n\\nvar (\\n\\tVowels2Idx = map[rune]int{\\n\\t\\t\\'a\\': 0,\\n\\t\\t\\'e\\': 1,\\n\\t\\t\\'i\\': 2,\\n\\t\\t\\'o\\': 3,\\n\\t\\t\\'u\\': 4,\\n\\t}\\n)\\n\\ntype VowelsCountManager struct {\\n\\tvowels2Idx          map[rune]int\\n\\tvowelsCnt2MaxStrIdx map[int]int\\n\\tvowelsCnt2MinStrIdx map[int]int\\n}\\n\\nfunc NewVowelsCountManager() (retHandler *VowelsCountManager) {\\n\\tretHandler = &VowelsCountManager{\\n\\t\\tvowels2Idx:          Vowels2Idx,\\n\\t\\tvowelsCnt2MaxStrIdx: map[int]int{},\\n\\t\\tvowelsCnt2MinStrIdx: map[int]int{\\n\\t\\t\\t0: -1,\\n\\t\\t},\\n\\t}\\n\\treturn retHandler\\n}\\n\\nfunc (h *VowelsCountManager) Count(s string) (retLen int) {\\n\\truneArr := []rune(s)\\n\\tbitMap := 0\\n\\tfor idx, char := range runeArr {\\n\\t\\tif vIdx, isVowel := h.vowels2Idx[char]; isVowel {\\n\\t\\t\\tbitMap ^= 1 << vIdx\\n\\t\\t\\t//fmt.Println(bitMap)\\n\\t\\t}\\n\\t\\tif max, exist := h.vowelsCnt2MaxStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t} else if max < idx {\\n\\t\\t\\th.vowelsCnt2MaxStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t\\tif min, exist := h.vowelsCnt2MinStrIdx[bitMap]; !exist {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t} else if min > idx {\\n\\t\\t\\th.vowelsCnt2MinStrIdx[bitMap] = idx\\n\\t\\t}\\n\\t}\\n\\t//fmt.Println(h.vowelsCnt2MaxStrIdx)\\n\\t//fmt.Println(h.vowelsCnt2MinStrIdx)\\n\\tfor bitMap, max := range h.vowelsCnt2MaxStrIdx {\\n\\t\\tif min, minExist := h.vowelsCnt2MinStrIdx[bitMap]; minExist {\\n\\t\\t\\tlen := max - min\\n\\t\\t\\tif len > retLen {\\n\\t\\t\\t\\tretLen = len\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn retLen\\n}\\n\\nfunc findTheLongestSubstring(s string) (retLen int) {\\n\\th := NewVowelsCountManager()\\n\\tretLen = h.Count(s)\\n\\treturn\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947093,
                "title": "python-o-n",
                "content": "\\'\\'\\'\\n\\n\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        self.mask = {0: -1}\\n        cur_mask = 0\\n        vowel    = \\'aeiou\\'\\n        \\n        answer = 0\\n        tmp = 0\\n        for idx in range(0, len(s)):\\n            char = s[idx]\\n            if char not in vowel:\\n                tmp += 1\\n                continue\\n            if answer < tmp:\\n                answer = tmp\\n            if char == \\'a\\':\\n                cur_mask = cur_mask ^ 2 ** 0\\n            elif char == \\'e\\':\\n                cur_mask = cur_mask ^ 2 ** 1\\n            elif char == \\'i\\':\\n                cur_mask = cur_mask ^ 2 ** 2\\n            elif char == \\'o\\':\\n                cur_mask = cur_mask ^ 2 ** 3\\n            elif char == \\'u\\':\\n                cur_mask = cur_mask ^ 2 ** 4\\n            \\n            if self.mask.get(cur_mask) is None:\\n                self.mask[cur_mask] = idx\\n                tmp = 0\\n            else:\\n                tmp = idx - self.mask.get(cur_mask)\\n        else:\\n            if answer < tmp:\\n                answer = tmp\\n        \\n        return answer\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        self.mask = {0: -1}\\n        cur_mask = 0\\n        vowel    = \\'aeiou\\'\\n        \\n        answer = 0\\n        tmp = 0\\n        for idx in range(0, len(s)):\\n            char = s[idx]\\n            if char not in vowel:\\n                tmp += 1\\n                continue\\n            if answer < tmp:\\n                answer = tmp\\n            if char == \\'a\\':\\n                cur_mask = cur_mask ^ 2 ** 0\\n            elif char == \\'e\\':\\n                cur_mask = cur_mask ^ 2 ** 1\\n            elif char == \\'i\\':\\n                cur_mask = cur_mask ^ 2 ** 2\\n            elif char == \\'o\\':\\n                cur_mask = cur_mask ^ 2 ** 3\\n            elif char == \\'u\\':\\n                cur_mask = cur_mask ^ 2 ** 4\\n            \\n            if self.mask.get(cur_mask) is None:\\n                self.mask[cur_mask] = idx\\n                tmp = 0\\n            else:\\n                tmp = idx - self.mask.get(cur_mask)\\n        else:\\n            if answer < tmp:\\n                answer = tmp\\n        \\n        return answer\\n\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1946987,
                "title": "easy-explanation-with-code",
                "content": "First build intuition:\\n1. To know if a given substring contains a vowel even number of times, we don\\'t need vowel\\'s count. We need a value either false (say non-zero) or true (say 0).\\n2. XOR properties\\n\\ta. 0 ^ any = any\\n\\tb. any ^ any = 0 (i.e. take any number even number of times xored with itself, it will give 0)\\n\\t\\nNow, the code is easy. Just have dry run over \"eleetminicoworoep\". It will be super intuitive.\\n\\n```\\n// TC : O(N)\\n// SC : O(1) since we have limited range (due to input constraint of \\'a\\'-\\'z\\' only)\\nprivate final static HashMap<Character, Integer> charToUniqueNumMap = new HashMap<>() {{\\n\\t\\tput(\\'a\\', 1);\\n\\t\\tput(\\'e\\', 2);\\n\\t\\tput(\\'i\\', 4);\\n\\t\\tput(\\'o\\', 8);\\n\\t\\tput(\\'u\\', 16);\\n\\t}};\\n\\nprivate boolean isVowel(char ch) {\\n\\treturn ch == \\'a\\' \\n\\t\\t\\t|| ch == \\'e\\'\\n\\t\\t\\t|| ch == \\'i\\'\\n\\t\\t\\t|| ch == \\'o\\'\\n\\t\\t\\t|| ch == \\'u\\';\\n}\\n\\npublic int findTheLongestSubstring(String s) {\\n\\tHashMap<Integer, Integer> mp = new HashMap<>();\\n\\tmp.put(0, -1);\\n\\n\\tint xor = 0;\\n\\tint maxLen = 0;\\n\\tint N = s.length();\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\txor = xor ^ (isVowel(ch) ? charToUniqueNumMap.get(ch) : 0);\\n\\t\\tif (mp.containsKey(xor)) {\\n\\t\\t\\tmaxLen = Math.max(maxLen, i-mp.get(xor));\\n\\t\\t}\\n\\t\\tmp.putIfAbsent(xor, i);\\n\\t}\\n\\n\\treturn maxLen;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// TC : O(N)\\n// SC : O(1) since we have limited range (due to input constraint of \\'a\\'-\\'z\\' only)\\nprivate final static HashMap<Character, Integer> charToUniqueNumMap = new HashMap<>() {{\\n\\t\\tput(\\'a\\', 1);\\n\\t\\tput(\\'e\\', 2);\\n\\t\\tput(\\'i\\', 4);\\n\\t\\tput(\\'o\\', 8);\\n\\t\\tput(\\'u\\', 16);\\n\\t}};\\n\\nprivate boolean isVowel(char ch) {\\n\\treturn ch == \\'a\\' \\n\\t\\t\\t|| ch == \\'e\\'\\n\\t\\t\\t|| ch == \\'i\\'\\n\\t\\t\\t|| ch == \\'o\\'\\n\\t\\t\\t|| ch == \\'u\\';\\n}\\n\\npublic int findTheLongestSubstring(String s) {\\n\\tHashMap<Integer, Integer> mp = new HashMap<>();\\n\\tmp.put(0, -1);\\n\\n\\tint xor = 0;\\n\\tint maxLen = 0;\\n\\tint N = s.length();\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\t\\tchar ch = s.charAt(i);\\n\\t\\txor = xor ^ (isVowel(ch) ? charToUniqueNumMap.get(ch) : 0);\\n\\t\\tif (mp.containsKey(xor)) {\\n\\t\\t\\tmaxLen = Math.max(maxLen, i-mp.get(xor));\\n\\t\\t}\\n\\t\\tmp.putIfAbsent(xor, i);\\n\\t}\\n\\n\\treturn maxLen;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916343,
                "title": "simple-easy-o-n",
                "content": "Convert char  a  e  i  o  u    to its Ascii value and XOR them.\\n\\n\\n```\\n public int findTheLongestSubstring(String s) {\\n        \\n        int stream=0;\\n        Map<Integer,Integer> m= new HashMap<>();\\n        int max=0;\\n        m.putIfAbsent(stream,0);\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                int c=s.charAt(i);\\n                stream=stream ^ c;\\n            }\\n            m.putIfAbsent(stream,i+1);\\n           \\n            max=Math.max(max,i+1-m.get(stream));\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public int findTheLongestSubstring(String s) {\\n        \\n        int stream=0;\\n        Map<Integer,Integer> m= new HashMap<>();\\n        int max=0;\\n        m.putIfAbsent(stream,0);\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'a\\' || s.charAt(i)==\\'e\\' || s.charAt(i)==\\'i\\' || s.charAt(i)==\\'o\\' || s.charAt(i)==\\'u\\'){\\n                int c=s.charAt(i);\\n                stream=stream ^ c;\\n            }\\n            m.putIfAbsent(stream,i+1);\\n           \\n            max=Math.max(max,i+1-m.get(stream));\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904721,
                "title": "c-aeiou-one-integer-5-bits-32-variations-warmup-for-meta-onsite",
                "content": "April 1, 2022\\n**Introduction**\\nI could not come out working ideas to solve the algorithm. I tried to solve it using sliding window to beat brute force O(N^2) solution, but it does not work. I was so nervous since I could not find a solution, there are five vowel chars, and I need to determine left pointer with matching vowel char count even or odd. Left pointer can be moved forward and backward two directions. So I chose to read votrubac solution, since I chose to go through algorithms based on his up-voted algorithms. \\n\\n**Idea to count all vowel chars \"aeiou\" | even 0, odd 1| \"00001\" meaning: a is odd, four chars in \"eiou\" even | Easy to play**\\nGo through each char in given string once, and record the count in terms of 0 or 1 for five chars in \"aeiou\". If it is not found then set variable smallestIndex, apply substring comparison to any char not just vowel char. Do not skip non-vowel in comparison. Try yourself first, and then read my C# code, good luck!\\n\\n**Bit operation | C# | My bug written in my first practice**\\nIt is easy for me to write a C# bit operation algorithm. I checked all C# discuss post, none of them uses bit operation, so I decided to write one. But my code failed to return correct answer, given example, eleetminicoworoep, should return 13, but mine is 12. I could not figure out the reason, so I had to spend over 10 minutes to debug. \\n\\nI should apply caclulation of matching vowel chars \"vowel\" even substring to any char, not just vowel. In other words, \"leetminicowor\", my search stops \"leetminicowo\", but skip last char \\'r\\' since it is not vowel. \\n\\nI quickly fixed the bug to limit scope of if statement in the following:\\n```\\n// update bitVariation if it is vowel char\\nif (index >= 0)  // if it is vowel char\\n{\\n    var current = 1 << index;  // left shift\\n    bitVariation ^= current; // double check XOR ^\\n}\\n```\\nDo you think that it is worth time for me to practice writing and debugging? I have ideas to solve the problem using bit operation, and I can write C# code but I stumbled a few places since I did not practice and took breaks over six months in 2021. \\n\\n**Places I stumbled in C#:** \\n1. Declare C# bool[32] variable found, default value is false; but I was not sure until I debugged the code;\\n2. C# String.IndexOf(char) - syntax and usage, I have to depend on Visual Studio prompt to determine;\\n3. C# << left shift, only provide information once, vowels = \"aeiou\", I can quickly figure out how many bits to shift left;\\n4. C# XOR ^ - this is important XOR using module 2 as result, in other words 1^1 = 0, 1^0 = 1, 0^0 = 0;\\n\\n**The algorithm I chose to work on based on votrubac**\\nI cannot find time to work on more than 200 submission last 12 months, so I have to figure out ways to compensate on this lack-of-hardwork. After carefully reviewing my options, I choose to work on a most reputable player and his up-voted algorithms, compared to mock interview, paid udemy FANG interview algorithm courses. Here is the idea. Welcome comments  how to choose algorithms to work on to prepare Meta onsite. I have this idea after I reviewed 50 algorithms tag Facebook last six months. \\n\\n![image](https://assets.leetcode.com/users/images/40df5275-de43-449d-a887-943b7a4d34b8_1648850650.6111696.jpeg)\\n![image](https://assets.leetcode.com/users/images/a9e92e23-a01f-4e50-8225-fa77b4a50fa7_1648850672.7423983.jpeg)\\n\\nThe current algorithm is fourth algorithm below red circled algorthm in page 2. \\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1371_Find_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var longest = FindTheLongestSubstring(\"eleetminicoworoep\");\\n            Debug.Assert(longest == 13);\\n        }\\n\\n        /// <summary>\\n        /// code review on April 1, 2022\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int FindTheLongestSubstring(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n                return 0; \\n\\n            var vowels = \"aeiou\";\\n            var smallestIndex = new int[32];\\n            var found = new bool[32]; // default - false           \\n\\n            smallestIndex[0] = -1;\\n            found[0] = true;\\n\\n            var bitVariation = 0; // five bit, each bit matches one of vowel char \"aeiou\"\\n            var length = s.Length;\\n            var maxSubstringLength = 0; \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                var c = s[i];\\n                var index = vowels.IndexOf(c);\\n\\n                // update bitVariation if it is vowel char\\n                if (index >= 0)  // if it is vowel char\\n                {\\n                    var current = 1 << index;  // left shift\\n                    bitVariation ^= current; // double check XOR ^\\n                }\\n\\n                // it applies to any char\\n                if (!found[bitVariation])\\n                {\\n                    smallestIndex[bitVariation] = i;\\n                    found[bitVariation] = true;\\n                }\\n                else\\n                {\\n                    maxSubstringLength = Math.Max(maxSubstringLength, i - smallestIndex[bitVariation]); \\n                }                \\n            }\\n\\n            return maxSubstringLength; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// update bitVariation if it is vowel char\\nif (index >= 0)  // if it is vowel char\\n{\\n    var current = 1 << index;  // left shift\\n    bitVariation ^= current; // double check XOR ^\\n}\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _1371_Find_longest_substring\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var longest = FindTheLongestSubstring(\"eleetminicoworoep\");\\n            Debug.Assert(longest == 13);\\n        }\\n\\n        /// <summary>\\n        /// code review on April 1, 2022\\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <returns></returns>\\n        public static int FindTheLongestSubstring(string s)\\n        {\\n            if (s == null || s.Length == 0)\\n                return 0; \\n\\n            var vowels = \"aeiou\";\\n            var smallestIndex = new int[32];\\n            var found = new bool[32]; // default - false           \\n\\n            smallestIndex[0] = -1;\\n            found[0] = true;\\n\\n            var bitVariation = 0; // five bit, each bit matches one of vowel char \"aeiou\"\\n            var length = s.Length;\\n            var maxSubstringLength = 0; \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                var c = s[i];\\n                var index = vowels.IndexOf(c);\\n\\n                // update bitVariation if it is vowel char\\n                if (index >= 0)  // if it is vowel char\\n                {\\n                    var current = 1 << index;  // left shift\\n                    bitVariation ^= current; // double check XOR ^\\n                }\\n\\n                // it applies to any char\\n                if (!found[bitVariation])\\n                {\\n                    smallestIndex[bitVariation] = i;\\n                    found[bitVariation] = true;\\n                }\\n                else\\n                {\\n                    maxSubstringLength = Math.Max(maxSubstringLength, i - smallestIndex[bitVariation]); \\n                }                \\n            }\\n\\n            return maxSubstringLength; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867257,
                "title": "c-bit-mask",
                "content": "```\\nclass Solution {\\n    int getbitpos(char c)\\n    {\\n        if (c == \\'a\\')\\n            return 0;\\n        else if (c == \\'e\\')\\n            return 1;\\n        else if (c == \\'i\\')\\n            return 2;\\n        else if (c == \\'o\\')\\n            return 3;\\n        else if (c == \\'u\\')\\n            return 4;\\n        else \\n            return -1;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int indices[32], n = s.size(), code = 0, ans = 0;\\n        for(int i=0; i<32; i++)\\n            indices[i] = INT_MAX;\\n        indices[0] = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            int bitpos = getbitpos(s[i]);\\n            if (bitpos != -1)\\n                code ^= 1<<bitpos;\\n            if (indices[code] == INT_MAX)\\n                indices[code] = i;\\n            ans = max(ans, i-indices[code]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int getbitpos(char c)\\n    {\\n        if (c == \\'a\\')\\n            return 0;\\n        else if (c == \\'e\\')\\n            return 1;\\n        else if (c == \\'i\\')\\n            return 2;\\n        else if (c == \\'o\\')\\n            return 3;\\n        else if (c == \\'u\\')\\n            return 4;\\n        else \\n            return -1;\\n    }\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int indices[32], n = s.size(), code = 0, ans = 0;\\n        for(int i=0; i<32; i++)\\n            indices[i] = INT_MAX;\\n        indices[0] = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            int bitpos = getbitpos(s[i]);\\n            if (bitpos != -1)\\n                code ^= 1<<bitpos;\\n            if (indices[code] == INT_MAX)\\n                indices[code] = i;\\n            ans = max(ans, i-indices[code]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769723,
                "title": "c-solution-using-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        vector<int> dp(32, s.size());\\n        dp[0] = -1;\\n        int len = 0;\\n        string temp = \"aeiou\";\\n        for(int i = 0; i < s.size(); i++){\\n            int index = ((1<<(temp.find(s[i])+1))>>1);\\n            mask = (mask^index);\\n            len = max(len, i-dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int mask = 0;\\n        vector<int> dp(32, s.size());\\n        dp[0] = -1;\\n        int len = 0;\\n        string temp = \"aeiou\";\\n        for(int i = 0; i < s.size(); i++){\\n            int index = ((1<<(temp.find(s[i])+1))>>1);\\n            mask = (mask^index);\\n            len = max(len, i-dp[mask]);\\n            dp[mask] = min(i, dp[mask]);\\n        }\\n        \\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756609,
                "title": "c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findTheLongestSubstring(string s) {\\n\\t\\t\\tint c=0,ans=0;\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tmp[0]=-1;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n\\t\\t\\t\\t\\t c^=1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\tif(!mp.count(c)) mp[c]=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans=max(ans,i-mp[c]); \\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findTheLongestSubstring(string s) {\\n\\t\\t\\tint c=0,ans=0;\\n\\t\\t\\tunordered_map<int,int>mp;\\n\\t\\t\\tmp[0]=-1;\\n\\t\\t\\tfor(int i=0;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n\\t\\t\\t\\t\\t c^=1<<(s[i]-\\'a\\');\\n\\t\\t\\t\\t\\tif(!mp.count(c)) mp[c]=i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1745856,
                "title": "golang-bitmask-subarray-caching",
                "content": "```\\nfunc findTheLongestSubstring(s string) int {\\n    // bitmask and subarray caching\\n    vowelMap := map[byte]int {\\n        \\'a\\': 0,\\n        \\'e\\': 1,\\n        \\'i\\': 2,\\n        \\'o\\': 3,\\n        \\'u\\': 4,\\n    }\\n    \\n    mask := 0\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at index -1, the bitmask representation is 00000, 0 of all vowels\\n    res := 0\\n    for i := range s {\\n        if j, isVowel := vowelMap[s[i]]; isVowel {\\n            mask = mask ^ (1 << j)  // toggle the jth bit\\n        }\\n        if prevEnd, exist := cache[mask]; exist {\\n            res = max(res, i - prevEnd)    \\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findTheLongestSubstring(s string) int {\\n    // bitmask and subarray caching\\n    vowelMap := map[byte]int {\\n        \\'a\\': 0,\\n        \\'e\\': 1,\\n        \\'i\\': 2,\\n        \\'o\\': 3,\\n        \\'u\\': 4,\\n    }\\n    \\n    mask := 0\\n    cache := make(map[int]int)\\n    cache[0] = -1 // at index -1, the bitmask representation is 00000, 0 of all vowels\\n    res := 0\\n    for i := range s {\\n        if j, isVowel := vowelMap[s[i]]; isVowel {\\n            mask = mask ^ (1 << j)  // toggle the jth bit\\n        }\\n        if prevEnd, exist := cache[mask]; exist {\\n            res = max(res, i - prevEnd)    \\n        } else {\\n            cache[mask] = i\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741401,
                "title": "something-new-c-um-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int a = 0, e = 0, i = 0, o = 0, u = 0;\\n        unordered_map<string, int> um;\\n        int ans = 0;\\n        \\n        string ss = \"_____\";\\n        um[ss] = -1;\\n        \\n        int ind = 0;\\n        \\n        for(char c: s)\\n        {\\n            if(c == \\'a\\')\\n                a = !a;\\n            if(c == \\'e\\')\\n                e = !e;\\n            if(c == \\'i\\')\\n                i = !i;\\n            if(c == \\'o\\')\\n                o = !o;\\n            if(c == \\'u\\')\\n                u = !u;\\n          \\n            if(a) ss[0] = \\'a\\'; else ss[0] = \\'_\\';\\n            if(e) ss[1] = \\'e\\'; else ss[1] = \\'_\\';\\n            if(i) ss[2] = \\'i\\'; else ss[2] = \\'_\\';\\n            if(o) ss[3] = \\'o\\'; else ss[3] = \\'_\\';\\n            if(u) ss[4] = \\'u\\'; else ss[4] = \\'_\\';\\n            \\n            if(um.find(ss) != um.end())\\n            {\\n                ans = max(ans, ind - um[ss]);\\n            }\\n            else\\n            {\\n                um[ss] = ind;\\n            }\\n            \\n            ind++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheLongestSubstring(string s) \\n    {\\n        int a = 0, e = 0, i = 0, o = 0, u = 0;\\n        unordered_map<string, int> um;\\n        int ans = 0;\\n        \\n        string ss = \"_____\";\\n        um[ss] = -1;\\n        \\n        int ind = 0;\\n        \\n        for(char c: s)\\n        {\\n            if(c == \\'a\\')\\n                a = !a;\\n            if(c == \\'e\\')\\n                e = !e;\\n            if(c == \\'i\\')\\n                i = !i;\\n            if(c == \\'o\\')\\n                o = !o;\\n            if(c == \\'u\\')\\n                u = !u;\\n          \\n            if(a) ss[0] = \\'a\\'; else ss[0] = \\'_\\';\\n            if(e) ss[1] = \\'e\\'; else ss[1] = \\'_\\';\\n            if(i) ss[2] = \\'i\\'; else ss[2] = \\'_\\';\\n            if(o) ss[3] = \\'o\\'; else ss[3] = \\'_\\';\\n            if(u) ss[4] = \\'u\\'; else ss[4] = \\'_\\';\\n            \\n            if(um.find(ss) != um.end())\\n            {\\n                ans = max(ans, ind - um[ss]);\\n            }\\n            else\\n            {\\n                um[ss] = ind;\\n            }\\n            \\n            ind++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738624,
                "title": "c-easy-to-understand-100-runtime-solution",
                "content": "int findTheLongestSubstring(string s) {\\n        \\n            int n=s.size();\\n            unordered_map<int , int> mp;\\n           \\n            mp[0]=-1;\\n            int mask=0,ans=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    char c=s[i];\\n                    if(c==\\'a\\' || c==\\'e\\' || c==\\'o\\' || c==\\'i\\' || c==\\'u\\')\\n                    {\\n                            int k=s[i]-\\'a\\';\\n                            mask= mask ^ ( 1<<k); // left shift   1* pow(2,k);\\n                    }\\n                    else\\n                    {\\n                            mask = mask^ 0; // gives same value as mask \\n                    }\\n                    \\n                    if(mask!=0 && mp.find(mask)==mp.end())\\n                    {\\n                            mp[mask]=i;\\n                    }\\n                    ans=max(ans , i-mp[mask]);\\n                    \\n            }\\n            return ans;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "int findTheLongestSubstring(string s) {\\n        \\n            int n=s.size();\\n            unordered_map<int , int> mp;\\n           \\n            mp[0]=-1;\\n            int mask=0,ans=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    char c=s[i];\\n                    if(c==\\'a\\' || c==\\'e\\' || c==\\'o\\' || c==\\'i\\' || c==\\'u\\')\\n                    {\\n                            int k=s[i]-\\'a\\';\\n                            mask= mask ^ ( 1<<k); // left shift   1* pow(2,k);\\n                    }\\n                    else\\n                    {\\n                            mask = mask^ 0; // gives same value as mask \\n                    }\\n                    \\n                    if(mask!=0 && mp.find(mask)==mp.end())\\n                    {\\n                            mp[mask]=i;\\n                    }\\n                    ans=max(ans , i-mp[mask]);\\n                    \\n            }\\n            return ans;\\n            \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1726477,
                "title": "n-complexity-with-explanation",
                "content": "so basically what we will do here is that we will take prefix xor upto all the indices and then a subarray has xor 0 if it is in the range between the given prefixes. Now we will take in account the maximum length possible .\\n\\n\\n\\n\\n\\n int findTheLongestSubstring(string s) {\\n        \\n       int i,j=0;\\n        int n=s.size();\\n        int ans=0;\\n        int dp[n];\\n        int c=0;\\n        if(s[0]==\\'a\\'||s[0]==\\'e\\'||s[0]==\\'i\\'||s[0]==\\'o\\'||s[0]==\\'u\\'){\\n            c=s[0];\\n          \\n        }\\n        dp[0]=c;\\n        unordered_map<int,int> mp;\\n        mp[dp[0]]=0;\\n        for(i=1;i<n;i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                 c=dp[i-1]^s[i];\\n             }\\n            dp[i]=c; \\n            if(dp[i]==0){\\n                ans=max(ans,i+1);\\n            }\\n            if(mp.find(dp[i])!=mp.end()){\\n                ans=max(ans,i-mp[dp[i]]);\\n            }\\n            if(mp.find(dp[i])==mp.end()){\\n                mp[dp[i]]=i;\\n            }\\n        }\\n        \\n        \\n        \\n       \\n        \\n        return ans;    \\n    }",
                "solutionTags": [],
                "code": "so basically what we will do here is that we will take prefix xor upto all the indices and then a subarray has xor 0 if it is in the range between the given prefixes. Now we will take in account the maximum length possible .\\n\\n\\n\\n\\n\\n int findTheLongestSubstring(string s) {\\n        \\n       int i,j=0;\\n        int n=s.size();\\n        int ans=0;\\n        int dp[n];\\n        int c=0;\\n        if(s[0]==\\'a\\'||s[0]==\\'e\\'||s[0]==\\'i\\'||s[0]==\\'o\\'||s[0]==\\'u\\'){\\n            c=s[0];\\n          \\n        }\\n        dp[0]=c;\\n        unordered_map<int,int> mp;\\n        mp[dp[0]]=0;\\n        for(i=1;i<n;i++){\\n             if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'){\\n                 c=dp[i-1]^s[i];\\n             }\\n            dp[i]=c; \\n            if(dp[i]==0){\\n                ans=max(ans,i+1);\\n            }\\n            if(mp.find(dp[i])!=mp.end()){\\n                ans=max(ans,i-mp[dp[i]]);\\n            }\\n            if(mp.find(dp[i])==mp.end()){\\n                mp[dp[i]]=i;\\n            }\\n        }\\n        \\n        \\n        \\n       \\n        \\n        return ans;    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1685038,
                "title": "golang-o-n-detail-explanation",
                "content": "There are 5 vowel, number of each vowel is odd/even, thus could be represented by 1/0 -> there are 2^5 = 32 state\\n\\nAt each step `i` (0 <= i < len(s)), we will try to compute the state. There are 2 cases:\\n\\n1. If state == 0 -> all even -> obviously: max = i + 1\\n2. maximum len of substring, end with `i` is: i - first_index_where_state_appear[state]\\n\\t2.1 edge case: if first index is -1 -> just record first index is `i` and do nothing\\n\\n\\n```go\\nfunc findTheLongestSubstring(s string) (max int) {\\n    var fi [32]int // first index that state appears\\n    for i := range fi {\\n        fi[i] = -1\\n    }\\n   \\n    var state byte\\n    for i := range s {\\n        c := isVowel(s[i])\\n        \\n        if c != 5 {\\n           state ^= 1 << c // toggle on/off the bit using xor, odd->even, even->odd, 0->1, 1->0\\n        }\\n        \\n        if state == 0 {\\n            max = i + 1\\n        } else if prevPos := fi[state]; prevPos == -1 { // previous position, same state\\n            fi[state] = i\\n        } else if d := i - prevPos; d > max {\\n            max = d\\n        }\\n    }\\n    \\n    return\\n}\\n\\nfunc isVowel(ch byte) byte {\\n    switch ch {\\n    case \\'a\\':\\n        return 0\\n    case \\'e\\':\\n        return 1\\n    case \\'i\\':\\n        return 2 \\n    case \\'o\\':\\n        return 3\\n    case \\'u\\':\\n        return 4\\n    default:\\n        return 5\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findTheLongestSubstring(s string) (max int) {\\n    var fi [32]int // first index that state appears\\n    for i := range fi {\\n        fi[i] = -1\\n    }\\n   \\n    var state byte\\n    for i := range s {\\n        c := isVowel(s[i])\\n        \\n        if c != 5 {\\n           state ^= 1 << c // toggle on/off the bit using xor, odd->even, even->odd, 0->1, 1->0\\n        }\\n        \\n        if state == 0 {\\n            max = i + 1\\n        } else if prevPos := fi[state]; prevPos == -1 { // previous position, same state\\n            fi[state] = i\\n        } else if d := i - prevPos; d > max {\\n            max = d\\n        }\\n    }\\n    \\n    return\\n}\\n\\nfunc isVowel(ch byte) byte {\\n    switch ch {\\n    case \\'a\\':\\n        return 0\\n    case \\'e\\':\\n        return 1\\n    case \\'i\\':\\n        return 2 \\n    case \\'o\\':\\n        return 3\\n    case \\'u\\':\\n        return 4\\n    default:\\n        return 5\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640820,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int cur=0;\\n        unordered_map<char,int>mp,m;\\n        mp[\\'a\\']=0;\\n        mp[\\'e\\']=1;\\n        mp[\\'i\\']=2;\\n        mp[\\'o\\']=3;\\n        mp[\\'u\\']=4;\\n        m[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\'||(s[i]==\\'e\\'||(s[i]==\\'i\\'||(s[i]==\\'o\\'||s[i]==\\'u\\'))))\\n            {\\n                cur=cur^(1<<mp[s[i]]);\\n                \\n            }\\n            int x=cur;\\n           \\n            if(m.find(cur)!=m.end())\\n                {\\n                    ans=max(ans,i-(m[cur])+1);\\n                }\\n            else\\n                m[cur]=i+1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheLongestSubstring(string s) {\\n        int ans=0;\\n        int cur=0;\\n        unordered_map<char,int>mp,m;\\n        mp[\\'a\\']=0;\\n        mp[\\'e\\']=1;\\n        mp[\\'i\\']=2;\\n        mp[\\'o\\']=3;\\n        mp[\\'u\\']=4;\\n        m[0]=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\'||(s[i]==\\'e\\'||(s[i]==\\'i\\'||(s[i]==\\'o\\'||s[i]==\\'u\\'))))\\n            {\\n                cur=cur^(1<<mp[s[i]]);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1609945,
                "title": "dp-without-bit-manipulation",
                "content": "Easier to understand at first without the bit manipulation. This is the same technique with the same time complexity. The bit manipulation is just a trick to go faster. \\n\\nTime: O(len(s)). Space: O(1).\\n\\n```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\':0, \\'e\\':0, \\'i\\':0, \\'o\\':0, \\'u\\':0 }\\n        earliestSeen = { self.getKey(vowels):-1 }\\n        result = 0\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                vowels[c] = (vowels[c] + 1) % 2\\n            seenKey = self.getKey(vowels)\\n            if seenKey in earliestSeen:\\n                result = max(result, i - earliestSeen[seenKey])\\n            else:\\n                earliestSeen[seenKey] = i\\n        return result\\n    \\n    def getKey(self, vowelsDict):\\n        return tuple([(key, val) for key, val in vowelsDict.items()])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        vowels = {\\'a\\':0, \\'e\\':0, \\'i\\':0, \\'o\\':0, \\'u\\':0 }\\n        earliestSeen = { self.getKey(vowels):-1 }\\n        result = 0\\n        for i, c in enumerate(s):\\n            if c in vowels:\\n                vowels[c] = (vowels[c] + 1) % 2\\n            seenKey = self.getKey(vowels)\\n            if seenKey in earliestSeen:\\n                result = max(result, i - earliestSeen[seenKey])\\n            else:\\n                earliestSeen[seenKey] = i\\n        return result\\n    \\n    def getKey(self, vowelsDict):\\n        return tuple([(key, val) for key, val in vowelsDict.items()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603058,
                "title": "c-100ms-63-simple-easy-small-bit-hash",
                "content": "Runtime: 100 ms, faster than 62.87% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\nMemory Usage: 16.4 MB, less than 9.76% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\n```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    int mask_a = 1, mask_e = 2, mask_i = 4, mask_o = 8, mask_u = 16, mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      switch(s[i]){\\n        case \\'a\\': mask ^= mask_a; break;\\n        case \\'e\\': mask ^= mask_e; break;\\n        case \\'i\\': mask ^= mask_i; break;\\n        case \\'o\\': mask ^= mask_o; break;\\n        case \\'u\\': mask ^= mask_u; break;\\n      }\\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```\\n\\n**or such:**\\n\\nRuntime: 120 ms, faster than 45.80% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\nMemory Usage: 16.4 MB, less than 9.76% of C++ online submissions for Find the Longest Substring Containing Vowels in Even Counts.\\n```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    unordered_map<char,int>masks = {{\\'a\\',1}, {\\'e\\',2}, {\\'i\\',4}, {\\'o\\',8}, {\\'u\\',16}};\\n    int mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      if(masks.count(s[i])) mask ^= masks[s[i]]; \\n      \\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    int mask_a = 1, mask_e = 2, mask_i = 4, mask_o = 8, mask_u = 16, mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      switch(s[i]){\\n        case \\'a\\': mask ^= mask_a; break;\\n        case \\'e\\': mask ^= mask_e; break;\\n        case \\'i\\': mask ^= mask_i; break;\\n        case \\'o\\': mask ^= mask_o; break;\\n        case \\'u\\': mask ^= mask_u; break;\\n      }\\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int findTheLongestSubstring(string s) {\\n    unordered_map<int,int>table = {{0,-1}};\\n    unordered_map<char,int>masks = {{\\'a\\',1}, {\\'e\\',2}, {\\'i\\',4}, {\\'o\\',8}, {\\'u\\',16}};\\n    int mask = 0, ans = 0;\\n    \\n    for(int i = 0; i != s.size(); i++){\\n      if(masks.count(s[i])) mask ^= masks[s[i]]; \\n      \\n      if(table.count(mask)) ans = max(ans, i - table[mask]);\\n      else table[mask] = i;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564670,
                "content": [
                    {
                        "username": "Switch2on",
                        "content": "According to the time top contesters spent on this problem and number of people who solved this question, I think the problem should be marked as hard. What do you think?"
                    },
                    {
                        "username": "yang_tomato",
                        "content": "I can\\'t agree more\\n"
                    }
                ]
            }
        ]
    }
]