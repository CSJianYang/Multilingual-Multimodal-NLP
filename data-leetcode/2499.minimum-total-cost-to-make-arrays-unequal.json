[
    {
        "title": "Minimum Total Cost to Make Arrays Unequal",
        "question_content": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.\n\nExample 2:\n\nInput: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.\n\nExample 3:\n\nInput: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1.\n\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t1 <= n <= 105\n\t1 <= nums1[i], nums2[i] <= n",
        "solutions": [
            {
                "id": 2897887,
                "title": "simple-solution-with-diagram-and-intuition-c-o-n-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The first position is like a resting place. The cost of moving an element from there is 0 as the index is 0. \\n2. Swapping 2 elements can be thought of as swapping both of the elements to position 0 and then swapping them back to desired position.\\n\\n![8d5b9041-be8d-46ae-98c3-370a99a66f29.jpg](https://assets.leetcode.com/users/images/df340148-2d7b-422b-a856-e76c37f021e4_1670688047.6299748.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Lets call an index bad is nums1[index] = nums2[index]. Imagine this, you collect all \"**bad indexes**\" in the 0th index. The cost to move this index to the 0th index is the index of the element.\\n2. Now, you can use these collected indexes and distribute them to the desired positions. (note that we don\\'t have to add any extra cost here, we can assume that once an element has come to position 0, it is free to move)\\n3. The only thing to care is the case where the maximum occuring element occurs more than half the values. In this case we need to collect more indexes even though they aren\\'t \"**bad**\". \\n4. We want to collect indexes which contribute less cost, i.e which occur earlier (smallest index) as well as taking care that the value doesn\\'t equal to the max occuring element (worsening our situation) and also ensuring that nums2[index] != max occurent element\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        const int n=nums1.size();\\n        long long int ans=0;\\n        map<int,int> freq;\\n        int maxFrequency=0,maxFrequencyValue=0,toSwap = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums1[i]==nums2[i]){\\n                freq[nums1[i]]++;\\n                if(freq[nums1[i]]>maxFrequency) maxFrequencyValue=nums1[i];\\n                maxFrequency=max(maxFrequency,freq[nums1[i]]);\\n                toSwap++;\\n                ans+=i;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(maxFrequency > toSwap/2 and nums1[i]!=nums2[i] and nums1[i]!=maxFrequencyValue and nums2[i]!=maxFrequencyValue){\\n                ans+=i;\\n                toSwap++;\\n            }\\n        }\\n        \\n        if(maxFrequency > toSwap/2) return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        const int n=nums1.size();\\n        long long int ans=0;\\n        map<int,int> freq;\\n        int maxFrequency=0,maxFrequencyValue=0,toSwap = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(nums1[i]==nums2[i]){\\n                freq[nums1[i]]++;\\n                if(freq[nums1[i]]>maxFrequency) maxFrequencyValue=nums1[i];\\n                maxFrequency=max(maxFrequency,freq[nums1[i]]);\\n                toSwap++;\\n                ans+=i;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(maxFrequency > toSwap/2 and nums1[i]!=nums2[i] and nums1[i]!=maxFrequencyValue and nums2[i]!=maxFrequencyValue){\\n                ans+=i;\\n                toSwap++;\\n            }\\n        }\\n        \\n        if(maxFrequency > toSwap/2) return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897969,
                "title": "c-simple-greedy-in-o-n-with-explanation",
                "content": "# Intuition and Approach\\n1. The cost of swapping numbers at idx1 and idx2 is `idx1 + idx2`\\n2. You only need to swap numbers at i that are identical in nums1[i] and nums2[i].\\n- e.g., `nums1 = [1,2,3,4,5]; nums2 = [2,2,3,5,5]` => extract `[2,3,5]`\\n3. Let\\'s consider two cases\\n- The `count of dominant element <= the count of all extracted elements / 2`. See 4\\n- The `count of dominant element > the count of all extracted elements / 2`. See 6\\n4. You can just sum all idx of them. There must be one permutation that can achieve the criteria: no identical number. For example, `[2,3,5]` can be permutated into `[5,2,3]`, and `[2,2,4,4]` can be permuted into `[4,4,2,2]`. \\n5. You might wonder what is the least cost to make such permutation. Consider you want to swap idx `i` to somewhere `j`, you must cost `i` first and then `j`, and if `j=0` the cost is `i`. So any swap of two numbers can be regarded as a process of swapping `i <-> 0 (of the original array) <-> j`. The total cost would be the sum of all idx. For the proof, please see [l_returns\\'s](https://leetcode.com/problems/minimum-total-cost-to-make-arrays-unequal/solutions/2897969/c-simple-greedy-in-on-with-explanation/comments/1712870) comment.\\n6. If there is case like `[2,2,2,3,3]`, there is no permutation that can achieve the goal. So keep adding other elements from the original array for changing `2`, which is the dominant element in the example. Besides, you should avoid the idx `k` that `nums1[k] == dominant number || nums2[k] == dominant number`.\\n7. If the left numbers are exhausted and you still can not achieve `count of dominant element <= the count of all extract elements / 2`, return -1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(The range of the numbers)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898175,
                "title": "pigeonhole-with-o-n-algorithm",
                "content": "**Algorithm**\\nThis problem can be boilded down to a pigeonhole problem. \\n\\nStep1. w.r.t the description, no coinside is permitted. Let\\'s find all indices where nums1[i]==nums2[i]. Suppose we got the set \"S\".\\n\\nStep2. In order to have a valid relocation, no single number \"t\" should dominate the set S (aka, count(t)<= |S|/2). \\n\\nIf so, more indices should be inserted to S.  As will be explained later, we want to keep the sum of indices as small as possible. We scan from 0 to n-1 and try to add more indices until |S| is big enough. If success,  **|S| will  be even**. Why? Otherwise, no valid rellocation and FAIL.\\n\\nStep3. No dominate number can be guaranteed now.\\nIf |S| is even, we can always find a way to swap the numbers in pairs so that the result is valid.\\nWhat about |S| is odd?\\na) |S| is odd and 0 belongs to S. We can always find {0, i, j} within S. swap(0, i) and swap (0, j). In other words, 0 used twice.\\nb) |S| is odd and 0 doesn\\'t belongs to S. Simply insert 0 to S.\\n\\nAccording to the description, sum(S) will be the answer, and we don\\'t actually rearrange the numbers.\\n\\n**Example 1**\\n```\\n[1,5,3,5,5]\\n[1,2,3,4,5]\\n```\\nS={0:1, 2:3, 4:5}. No dominate number. |S|=3, 0 belongs to S. sum(S)=6. We have\\n```\\n[3,5,5,5,1]\\n[1,2,3,4,5]\\n```\\n**Example2**\\n```\\n[2,2,2,3,3]\\n[1,2,2,1,3]\\n```\\nS={1:2, 2:2, 4:3}.  Number 2 dominates.  Index 0 cannot be inserted to S, since nums1[0]==2. What we can get is S={1:2, 2:2, 4:3, 3:{3,1}}. |S|=4. sum(S)=10. And we can have\\n```\\n[2,3,3,2,2]\\n[1,2,2,1,3]\\n```\\n\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long long sum=0;\\n        int n=nums1.size(), m=0, k=0, tar=-1;\\n        unordered_map<int, int> sts;\\n        for(int i=0; i<n; ++i) {\\n            if(nums1[i]==nums2[i]) {\\n                ++m; \\n                sum+=i;\\n                ++sts[nums1[i]];\\n            }\\n        }\\n        for(auto & p:sts) {\\n            if(p.second>k) {\\n                tar=p.first;\\n                k=p.second;\\n            }\\n        }\\n        if(k+k>m) {\\n            for(int i=0; i<n && k+k>m; ++i) {\\n                if(nums1[i]!=nums2[i] && nums1[i]!=tar && nums2[i]!=tar) {\\n                    ++m;\\n                    sum+=i;\\n                }\\n            }\\n        }\\n        return k+k>m? -1 : sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[1,5,3,5,5]\\n[1,2,3,4,5]\\n```\n```\\n[3,5,5,5,1]\\n[1,2,3,4,5]\\n```\n```\\n[2,2,2,3,3]\\n[1,2,2,1,3]\\n```\n```\\n[2,3,3,2,2]\\n[1,2,2,1,3]\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        long long sum=0;\\n        int n=nums1.size(), m=0, k=0, tar=-1;\\n        unordered_map<int, int> sts;\\n        for(int i=0; i<n; ++i) {\\n            if(nums1[i]==nums2[i]) {\\n                ++m; \\n                sum+=i;\\n                ++sts[nums1[i]];\\n            }\\n        }\\n        for(auto & p:sts) {\\n            if(p.second>k) {\\n                tar=p.first;\\n                k=p.second;\\n            }\\n        }\\n        if(k+k>m) {\\n            for(int i=0; i<n && k+k>m; ++i) {\\n                if(nums1[i]!=nums2[i] && nums1[i]!=tar && nums2[i]!=tar) {\\n                    ++m;\\n                    sum+=i;\\n                }\\n            }\\n        }\\n        return k+k>m? -1 : sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934975,
                "title": "majority-element",
                "content": "The intuition is tricky; I needed a bit of whiteboarding to figure out #4 below.\\n\\n1. We check for equal elements. If `n1[i] == n2[i]`, we will need to move it, so we just add `i` to the result.\\n2. We use hashmap to count equal elements for each value.\\n3. The best strategy is to rearrange equal elements only - it will not require any additional cost.\\n4. We can always rearrange equal elements if there is no majority element. \\n\\t- In other words, we do not have a value that accounts for more than a half of equal elements.\\n\\t- If the number of equal elements is odd, the last once can be swapped with the first element for zero cost.\\n\\t\\t- We can always make this last swap since we have several values to choose from.\\n> Say, for example, we have equal elements `2, 2, 2, 3, 3, 4, 4` (odd total number). We can swap: \\n> (2, 3), (2, 3), (2, 4), then (x, 4) - x is the first element.\\n> (2, 4), (2, 4), (2, 3), then (x, 3).\\n> (2, 3), (2, 4), (3, 4), then (x, 2).\\n5. If we have a majority element `n` appearing `n_cnt` times.\\n\\t- We can swap `equal - n_cnt` equal elements for no extra cost.\\n\\t- Plus, we need to swap `2 * n_cnt - equal` equal with some non-equal elements for a cost.\\n6. We scan the array left-to-right (to minimize cost), do swaps if we can, and add indexes to the cost.\\n7. If we are able to do all swaps, return cost (and `-1` otherwise).\\n\\n**C++**\\n```cpp\\nlong long minimumTotalCost(vector<int>& n1, vector<int>& n2) {\\n    long long res = 0, cnt = 0, sz = n1.size();\\n    unordered_map<int, int> m{{0,0}}; // sentinel\\n    for (int i = 0; i < sz; ++i)\\n        if (n1[i] == n2[i]) {\\n            res += i;\\n            ++m[n1[i]];\\n            ++cnt;\\n        }\\n    const auto &[n, n_cnt] = *max_element(begin(m), end(m), \\n        [](const auto &a, const auto &b){ return a.second < b.second; });\\n    int swaps = 2 * n_cnt - cnt;\\n    for (int i = 0; swaps > 0 && i < sz; ++i)\\n        if (n1[i] != n2[i] && n1[i] != n && n2[i] != n) {\\n            res += i;\\n            --swaps;\\n        }\\n    return swaps > 0 ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minimumTotalCost(vector<int>& n1, vector<int>& n2) {\\n    long long res = 0, cnt = 0, sz = n1.size();\\n    unordered_map<int, int> m{{0,0}}; // sentinel\\n    for (int i = 0; i < sz; ++i)\\n        if (n1[i] == n2[i]) {\\n            res += i;\\n            ++m[n1[i]];\\n            ++cnt;\\n        }\\n    const auto &[n, n_cnt] = *max_element(begin(m), end(m), \\n        [](const auto &a, const auto &b){ return a.second < b.second; });\\n    int swaps = 2 * n_cnt - cnt;\\n    for (int i = 0; swaps > 0 && i < sz; ++i)\\n        if (n1[i] != n2[i] && n1[i] != n && n2[i] != n) {\\n            res += i;\\n            --swaps;\\n        }\\n    return swaps > 0 ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2898786,
                "title": "algorithm-specific-to-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClearly, the minimum cost includes the sum of all i for which nums1[i]=nums2[i].\\n\\nIn certain circumstances, this is the actual answer. However, there are two cases when this may not be true:\\n- when the number of such indices is odd\\n- when one value is so predominant among nums when nums1[i]=nums2[i] that we need to go outside this set to swap, because there aren\\'t enough swap possibilities inside the set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- When the number of indices with equality is even and one value is not predominant, the sum of i for which nums1[i]=nums2[i] is the answer; we can then swap values in pairs.\\nWhen the number is odd, but one value is not predominant, it turns out that the answer is the same, because we can use the index 0 for an extra swap, whether it is in the set or not.\\n\\n- If one value dominates, meaning that it is the value of nums for more than half the indices with equality, then we have to go outside the set and use\\n$$max\\\\_ct-(total\\\\_ct-max\\\\_ct)=2max\\\\_ct-total\\\\_ct$$\\nplaces for extra swaps, where total\\\\_ct is the total number of indices with equality and max_ct is the count of the dominant value. There can be at most one dominant value, call it val.\\nWe then go outside the set and look for 2max\\\\_ct-total\\\\_ct swap candidates. We look at all indices i, in increasing order, such that:\\n\\\\* nums1[i]!= nums2[i] (meaning i is outside the set),\\n\\\\* nums1[i]!=val\\n\\\\* nums2[i]!=val.\\nWhen finding a good index, we add it to the sum, until we find 2*max_ct-total_ct good indices or run out of candidates.\\nIf we run out of candidates, a swap is not possible. Otherwise, the updated sum is the minimal cost.\\n\\n# Complexity\\n- Time complexity: $O(n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ on top of initial data.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        l=len(nums1)\\n        sm=0\\n        dct=defaultdict(int)\\n        ct=0\\n        for i in range(l):\\n            if nums1[i]==nums2[i]:\\n                ct+=1\\n                dct[nums1[i]]+=1\\n                sm+=i\\n        if not ct:\\n            return 0\\n        max_it=max(dct.items(), key=lambda x:x[1])\\n        val=max_it[0]\\n        dif=(max_it[1]<<1)-ct\\n        i=0\\n        while dif>0:\\n            while i<l and (nums1[i]==nums2[i] or nums1[i]==val or nums2[i]==val):\\n                i+=1\\n            if i==l:\\n                break\\n            sm+=i\\n            i+=1\\n            dif-=1\\n        if dif<=0:\\n            return sm\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        l=len(nums1)\\n        sm=0\\n        dct=defaultdict(int)\\n        ct=0\\n        for i in range(l):\\n            if nums1[i]==nums2[i]:\\n                ct+=1\\n                dct[nums1[i]]+=1\\n                sm+=i\\n        if not ct:\\n            return 0\\n        max_it=max(dct.items(), key=lambda x:x[1])\\n        val=max_it[0]\\n        dif=(max_it[1]<<1)-ct\\n        i=0\\n        while dif>0:\\n            while i<l and (nums1[i]==nums2[i] or nums1[i]==val or nums2[i]==val):\\n                i+=1\\n            if i==l:\\n                break\\n            sm+=i\\n            i+=1\\n            dif-=1\\n        if dif<=0:\\n            return sm\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898939,
                "title": "python-find-smallest-set-to-permute",
                "content": "### Approach\\nBecause swapping to and from index $0$ is free, if $S\\'$ is the set of indices that are in at least one swap in the answer, then the optimal cost is `sum(S\\')`.\\n\\nLet $S \\\\subseteq S\\'$ be the set of $i$ with $A[i] = B[i]$.  We have to move these, so the answer is at least `sum(S)`.  Note that if all $A[i]$ were different, then `sum(S)` is the final answer.\\n\\nNow accounting for the values of $A[i]$, consider any $\\\\text{major} = \\\\text{mode}(\\\\{\\\\,A[i] \\\\mid i \\\\in S\\\\,\\\\})$. A necessary condition is that $\\\\text{major}$ doesn\\'t occur more than $\\\\frac{|S\\'|}{2}$ times. Actually, it\\'s also a sufficient one (*).\\n\\nSo say $\\\\text{major}$ has frequency larger than $\\\\frac{|S|}{2}$ (there can be at most one), then we need to add $i$\\'s to $S\\'$ so that $A[i]$ and $B[i]$ are not equal to $\\\\text{major}$, until we get the frequency at or below $\\\\frac{\\\\|S\\'\\\\|}{2}$.\\n\\n### Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, A, B):\\n        N = len(A)\\n        indexes = {i for i in range(N) if A[i] == B[i]}\\n        if not indexes:\\n            return 0\\n\\n        count = Counter(A[i] for i in indexes)\\n        major = max(count, key=count.__getitem__)\\n        to_add = max(count[major] * 2 - len(indexes), 0)\\n        for i in range(N):\\n            if to_add and A[i] != major != B[i] and i not in indexes:\\n                to_add -= 1\\n                indexes.add(i)\\n\\n        return -1 if to_add else sum(indexes)\\n```\\n\\n(* proof : let the largest frequencies be $(f_1, f_2, \\\\cdots)$, then decrementing $f_1$ and $f_2$ would have $f_2 \\\\leq \\\\frac{n}{2} \\\\Leftrightarrow f_2 - 1 \\\\leq \\\\frac{n-2}{2}$ and $f_3 \\\\leq \\\\frac{n}{3} \\\\leq \\\\frac{n-2}{2}$ showing our induction would hold for $n \\\\geq 6$, and small $n$ is an exercise.)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalCost(self, A, B):\\n        N = len(A)\\n        indexes = {i for i in range(N) if A[i] == B[i]}\\n        if not indexes:\\n            return 0\\n\\n        count = Counter(A[i] for i in indexes)\\n        major = max(count, key=count.__getitem__)\\n        to_add = max(count[major] * 2 - len(indexes), 0)\\n        for i in range(N):\\n            if to_add and A[i] != major != B[i] and i not in indexes:\\n                to_add -= 1\\n                indexes.add(i)\\n\\n        return -1 if to_add else sum(indexes)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897940,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        long cost = 0;\\n        int [] count = new int[n+1];\\n        int sum = 0;\\n        for(int i = 0; i<n; i++){\\n            if(nums1[i]==nums2[i]){\\n                count[nums1[i]]++;\\n                sum++;\\n                cost += (long)i;\\n            }\\n        }\\n        int rem = -1;\\n        int freq = 0;\\n        for(int i = 0; i<=n; i++){\\n            if(count[i]>(sum/2)){\\n                rem = i;\\n                freq = count[i] - (sum-count[i]);\\n                break;\\n            }\\n        }\\n        if(rem==-1) return cost;\\n        for(int i = 0; i<n; i++){\\n            if(nums1[i]!=nums2[i] && rem!=nums2[i] && rem!=nums1[i]){\\n                cost += (long)i;\\n                freq--;\\n            }\\n            if(freq==0) break;\\n        }\\n        if(freq!=0) return -1;\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        long cost = 0;\\n        int [] count = new int[n+1];\\n        int sum = 0;\\n        for(int i = 0; i<n; i++){\\n            if(nums1[i]==nums2[i]){\\n                count[nums1[i]]++;\\n                sum++;\\n                cost += (long)i;\\n            }\\n        }\\n        int rem = -1;\\n        int freq = 0;\\n        for(int i = 0; i<=n; i++){\\n            if(count[i]>(sum/2)){\\n                rem = i;\\n                freq = count[i] - (sum-count[i]);\\n                break;\\n            }\\n        }\\n        if(rem==-1) return cost;\\n        for(int i = 0; i<n; i++){\\n            if(nums1[i]!=nums2[i] && rem!=nums2[i] && rem!=nums1[i]){\\n                cost += (long)i;\\n                freq--;\\n            }\\n            if(freq==0) break;\\n        }\\n        if(freq!=0) return -1;\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897932,
                "title": "c-explained",
                "content": "# Algorithm\\nFirst off, when is there never a valid array? \\nIt turns out this is the case when the most frequent element in a and b is more frequent than the occurance of all other elements combined. This way, we always have to pair that elemnt with itself at least once. Otherwise, we can always construct a valid array. \\n\\nIt turns out that initially, we only have to change the position of the elements where a[i] == b[i]. However, what if in this subsequence (all i for which a[i] == b[i]), the most frequent element is more frequent than all other elements combined? All we have to do is greedily add indexes where a[i] != b[i], starting from the front, as we want to minimize the sum. Now, we have the subseqence where we actually want to apply changes to. Each swap adds i to the cost, and every element needs to be swapped at least once. We can always swap with the first index until we get a desired subsequence, so the answer is just the sum of all i\\'s we need to change. \\n# Code\\n```\\ntypedef long long ll; \\n\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& a, vector<int>& b) {\\n        int n = a.size(); \\n        vector<int> f(n+1, 0); \\n        for (int i = 0; i < n; ++i) {\\n            f[a[i]]++; \\n            f[b[i]]++; \\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            if (f[i] > n) return -1; \\n            f[i] = 0; \\n        }\\n        vector<int> c; \\n        int mx = 0, val = 0, mn = 1e9; \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i]) {\\n                c.push_back(i); \\n                f[a[i]] += 2; \\n                mn = min(mn, i); \\n                if (f[a[i]] > mx) {\\n                    mx = f[a[i]]; \\n                    val = a[i]; \\n                }\\n            }\\n        }\\n        \\n        if (mx > (int) c.size()) {\\n            for (int i = 0; i < n; ++i) {\\n                if (a[i] != val && b[i] != val && a[i] != b[i]) {\\n                    c.push_back(i); \\n                    mn = min(mn, i);\\n                    if (mx <= (int) c.size()) {\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0; \\n        for (int i = 0; i < (int)c.size(); ++i) ans += c[i]; \\n        \\n        return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll; \\n\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& a, vector<int>& b) {\\n        int n = a.size(); \\n        vector<int> f(n+1, 0); \\n        for (int i = 0; i < n; ++i) {\\n            f[a[i]]++; \\n            f[b[i]]++; \\n        }\\n        for (int i = 1; i <= n; ++i) {\\n            if (f[i] > n) return -1; \\n            f[i] = 0; \\n        }\\n        vector<int> c; \\n        int mx = 0, val = 0, mn = 1e9; \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i]) {\\n                c.push_back(i); \\n                f[a[i]] += 2; \\n                mn = min(mn, i); \\n                if (f[a[i]] > mx) {\\n                    mx = f[a[i]]; \\n                    val = a[i]; \\n                }\\n            }\\n        }\\n        \\n        if (mx > (int) c.size()) {\\n            for (int i = 0; i < n; ++i) {\\n                if (a[i] != val && b[i] != val && a[i] != b[i]) {\\n                    c.push_back(i); \\n                    mn = min(mn, i);\\n                    if (mx <= (int) c.size()) {\\n                        break; \\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0; \\n        for (int i = 0; i < (int)c.size(); ++i) ans += c[i]; \\n        \\n        return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898102,
                "title": "c-matching-equal-indices-o-n-explained",
                "content": "# Approach\\n\\nLet\\'s call `i` is equalIndex if `nums1[i] == nums2[i]`\\n\\nThe optimal way is to swap two indices `i`, `j` that `i` & `j` are both equalIndex and `nums1[i] != nums1[j]`\\n\\nBut in some situation, there might leave some equalIndex, more specifially:\\n1. When too many equalIndex having same number, e.g. `nums1 = [2, 2, 2, 4, 5, 6]`, `nums2 = [2, 2, 2, 4, 7, 8]`\\n    - only 1 number (in this example is `2`) will have remain equalIndex, but may have many equalIndex\\n2. The number of equalIndex is odd, e.g. `nums1 = [1, 2, 3, 4]`, `nums2 = [1, 2, 3, 5]`\\n    - only remain 1 equalIndex, but each of them can be swap with other non-equalIndex\\n\\nCase 1: iterate the array to find other non-equalIndex (the smaller the better) can swap with remaining equalIndex\\nCase 2: iterate the array to find other non-equalIndex (the smaller the better) can swap with one of any equalIndex\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        unordered_map<int,int> counter;\\n        for ( int i : nums1 ) counter[i]++;\\n        for ( int i : nums2 ) counter[i]++;\\n        for ( int i=1; i<=n; ++i ) if ( counter[i] > n ) return -1;\\n        counter.clear();\\n        \\n        vector<int> equalIndex;\\n        unordered_map<int,bool> isEqualIndex, isEqualValue;\\n        for ( int i=0; i<n; ++i ) {\\n            if ( nums1[i] == nums2[i] ) {\\n                equalIndex.emplace_back(i);\\n                isEqualIndex[i] = true;\\n                isEqualValue[nums1[i]] = true;\\n                counter[nums1[i]]++;\\n            }\\n        }\\n        \\n        int mx = 1;\\n        for ( int i=2; i<=n; ++i ) if ( counter[mx] < counter[i] ) mx = i;\\n        int ret = counter[mx] - (equalIndex.size()-counter[mx]);\\n        long long ans = 0;\\n        for ( int i : equalIndex ) ans += i;\\n        // case 1\\n        if ( ret > 0 ) {\\n            for ( int i=0; i<n; ++i ) {\\n                if ( isEqualIndex[i] || nums1[i] == mx || nums2[i] == mx ) continue;\\n                ret--;\\n                ans += i;\\n                if ( ret == 0 ) break;\\n            }\\n        } // case 2\\n        else if ( ret < 0 && equalIndex.size()%2 == 1 ) {\\n            for ( int i=0; i<n; ++i ) {\\n                if ( isEqualIndex[i] || isEqualValue[nums1[i]] || isEqualValue[nums2[i]] ) continue;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        unordered_map<int,int> counter;\\n        for ( int i : nums1 ) counter[i]++;\\n        for ( int i : nums2 ) counter[i]++;\\n        for ( int i=1; i<=n; ++i ) if ( counter[i] > n ) return -1;\\n        counter.clear();\\n        \\n        vector<int> equalIndex;\\n        unordered_map<int,bool> isEqualIndex, isEqualValue;\\n        for ( int i=0; i<n; ++i ) {\\n            if ( nums1[i] == nums2[i] ) {\\n                equalIndex.emplace_back(i);\\n                isEqualIndex[i] = true;\\n                isEqualValue[nums1[i]] = true;\\n                counter[nums1[i]]++;\\n            }\\n        }\\n        \\n        int mx = 1;\\n        for ( int i=2; i<=n; ++i ) if ( counter[mx] < counter[i] ) mx = i;\\n        int ret = counter[mx] - (equalIndex.size()-counter[mx]);\\n        long long ans = 0;\\n        for ( int i : equalIndex ) ans += i;\\n        // case 1\\n        if ( ret > 0 ) {\\n            for ( int i=0; i<n; ++i ) {\\n                if ( isEqualIndex[i] || nums1[i] == mx || nums2[i] == mx ) continue;\\n                ret--;\\n                ans += i;\\n                if ( ret == 0 ) break;\\n            }\\n        } // case 2\\n        else if ( ret < 0 && equalIndex.size()%2 == 1 ) {\\n            for ( int i=0; i<n; ++i ) {\\n                if ( isEqualIndex[i] || isEqualValue[nums1[i]] || isEqualValue[nums2[i]] ) continue;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898403,
                "title": "python-detailed-explanation-readable-code",
                "content": "This is not my invention. I borrowed this solution from [@bucketpotato](https://leetcode.com/bucketpotato/), analyzed it and made a super detailed version of their code.\\n\\n```python\\nclass Solution:\\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n    inputLength = len(nums1)\\n    maxNumber = inputLength # By the task definition\\n\\n    # Counts how many times each number appears in both arrays\\n    numFrequences = Counter(nums1 + nums2)\\n    \\n    # If a number appears more times than an array length,\\n    # it\\'s impossible to put it into 2 arrays without overlaps:\\n    # [1,1,1,2,3]\\n    # [2,3,1,1,1] // too tight for six 1s\\n    if max(numFrequences.values()) > inputLength:\\n      return -1\\n    \\n    # Will accumulate the answer here\\n    cost = 0\\n\\n    # Counting how many time each number appears in a match\\n    # between nums1 and nums2. Also counting total matches.\\n    # A map can be used instead, arrays are faster in runtime\\n    matchesByNum = [0] * (maxNumber + 1)\\n    matchesCount = 0\\n    for i in range(0, inputLength):\\n      if nums1[i] == nums2[i]:\\n        matchesByNum[nums1[i]] += 1\\n        matchesCount += 1\\n\\n        # This item must be swapped with something, no matter what with for now.\\n        # We add the cost of the half-swap (raising the i\\'th num up and waiting for moving).\\n        # We will add the cost the counterpart half-swaps later.\\n        # (cost of a swap is cost of the half-swaps of its elements)\\n        cost += i\\n    \\n    # Looking for the number that appeared in the matches the most often\\n    mostMatchingNum = 1\\n    for num in range(2, maxNumber + 1):\\n      if matchesByNum[num] > matchesByNum[mostMatchingNum]:\\n        mostMatchingNum = num\\n    mostMatchingNumFrequency = matchesByNum[mostMatchingNum]\\n    \\n    # If the frequency of the most frequent matching number\\n    # is not greater than the frequencies all the other numbers combined,\\n    # We can swap the matching numbers with each other.\\n    # [1,1,1,1,1,2,2,2,3,3] ->\\n    # [3,3,2,2,2,1,1,1,1,1] // no match any more\\n    # Since they match with each outher, their half-swaps are combined\\n    # into full swaps (like atoms of oxygen), so no extra cost is used.\\n    if mostMatchingNumFrequency * 2 <= matchesCount:\\n      return cost\\n    \\n    # Otherwise we have excess items that haven\\'t got a counterpart.\\n    # [1,1,1,2,2] ->\\n    # [2,2,1,1,1] // a match, no matter how to reorder\\n    # We need to find places for them in the nums2 array within\\n    # the numbers that didn\\'t match initialy, because all the matching\\n    # numbers either have been swapped (see above) or are to be swapped\\n    # by the loop below.\\n    # Looking for the leftmost available place to minimize the cost.\\n    excessCount = mostMatchingNumFrequency * 2 - matchesCount\\n    for i in range(0, inputLength):\\n      # Avoiding matching numbers (see the comment above)\\n      if nums1[i] == nums2[i]:\\n        continue\\n      # Swapping would mean putting mostMatchingNum to a spot\\n      # where it would be a match too\\n      if nums1[i] == mostMatchingNum:\\n        continue\\n      # mostMatchingNum wouldn\\'t make a match here, but the nums2[i]\\n      # item that we put to the mostMatchingNum old spot (as a result of the swap)\\n      # would be a match there\\n      if nums2[i] == mostMatchingNum:\\n        continue\\n\\n      # Found a good spot, performing a swap.\\n      # The cost of a half-swap of mostMatchingNum have beed added above,\\n      # so adding only a half-swap cost of nums2[i]\\n      cost += i\\n\\n      # When all the pairs for the matching elements are found, the problem is solved\\n      excessCount -= 1\\n      if excessCount == 0:\\n        break\\n    \\n    return cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n  def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n    inputLength = len(nums1)\\n    maxNumber = inputLength # By the task definition\\n\\n    # Counts how many times each number appears in both arrays\\n    numFrequences = Counter(nums1 + nums2)\\n    \\n    # If a number appears more times than an array length,\\n    # it\\'s impossible to put it into 2 arrays without overlaps:\\n    # [1,1,1,2,3]\\n    # [2,3,1,1,1] // too tight for six 1s\\n    if max(numFrequences.values()) > inputLength:\\n      return -1\\n    \\n    # Will accumulate the answer here\\n    cost = 0\\n\\n    # Counting how many time each number appears in a match\\n    # between nums1 and nums2. Also counting total matches.\\n    # A map can be used instead, arrays are faster in runtime\\n    matchesByNum = [0] * (maxNumber + 1)\\n    matchesCount = 0\\n    for i in range(0, inputLength):\\n      if nums1[i] == nums2[i]:\\n        matchesByNum[nums1[i]] += 1\\n        matchesCount += 1\\n\\n        # This item must be swapped with something, no matter what with for now.\\n        # We add the cost of the half-swap (raising the i\\'th num up and waiting for moving).\\n        # We will add the cost the counterpart half-swaps later.\\n        # (cost of a swap is cost of the half-swaps of its elements)\\n        cost += i\\n    \\n    # Looking for the number that appeared in the matches the most often\\n    mostMatchingNum = 1\\n    for num in range(2, maxNumber + 1):\\n      if matchesByNum[num] > matchesByNum[mostMatchingNum]:\\n        mostMatchingNum = num\\n    mostMatchingNumFrequency = matchesByNum[mostMatchingNum]\\n    \\n    # If the frequency of the most frequent matching number\\n    # is not greater than the frequencies all the other numbers combined,\\n    # We can swap the matching numbers with each other.\\n    # [1,1,1,1,1,2,2,2,3,3] ->\\n    # [3,3,2,2,2,1,1,1,1,1] // no match any more\\n    # Since they match with each outher, their half-swaps are combined\\n    # into full swaps (like atoms of oxygen), so no extra cost is used.\\n    if mostMatchingNumFrequency * 2 <= matchesCount:\\n      return cost\\n    \\n    # Otherwise we have excess items that haven\\'t got a counterpart.\\n    # [1,1,1,2,2] ->\\n    # [2,2,1,1,1] // a match, no matter how to reorder\\n    # We need to find places for them in the nums2 array within\\n    # the numbers that didn\\'t match initialy, because all the matching\\n    # numbers either have been swapped (see above) or are to be swapped\\n    # by the loop below.\\n    # Looking for the leftmost available place to minimize the cost.\\n    excessCount = mostMatchingNumFrequency * 2 - matchesCount\\n    for i in range(0, inputLength):\\n      # Avoiding matching numbers (see the comment above)\\n      if nums1[i] == nums2[i]:\\n        continue\\n      # Swapping would mean putting mostMatchingNum to a spot\\n      # where it would be a match too\\n      if nums1[i] == mostMatchingNum:\\n        continue\\n      # mostMatchingNum wouldn\\'t make a match here, but the nums2[i]\\n      # item that we put to the mostMatchingNum old spot (as a result of the swap)\\n      # would be a match there\\n      if nums2[i] == mostMatchingNum:\\n        continue\\n\\n      # Found a good spot, performing a swap.\\n      # The cost of a half-swap of mostMatchingNum have beed added above,\\n      # so adding only a half-swap cost of nums2[i]\\n      cost += i\\n\\n      # When all the pairs for the matching elements are found, the problem is solved\\n      excessCount -= 1\\n      if excessCount == 0:\\n        break\\n    \\n    return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898352,
                "title": "c-greedy-solution",
                "content": "# Intuition\\nThe minimum cost of the swaps is the sum of the indices involved. This means that it is beneficial to swap with the smallest possible index always.\\n\\n# Approach\\nFirstly let us think about when the answer is -1. Suppose the frequency of any number in $$nums1$$ is $x$ and $y$ in $nums2$. By pighenhole principle we can see that for the final condition to be valid $x+y<=n$. \\n\\nNow let\\'s find the value that need to be swapped. Store the frequency of all values that need to be swapped.Find out the value having the maximum frequency among all the matching numbers. Let this be $maxFreqValue$.\\nNow there can be 2 cases\\n 1.  If $freq[maxFreqValue]$ is half or less than half among all matched numbers. In such cases the matched number will be swapped among themselves and the final answer is the sum of all the indexes at which same value are present.\\n 2. Else we use as many swaps of kind 1 as possible. For the remaining instances of $maxFreqValue$ we will swap them with the $smallest$ possible index. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n## Note\\nI have used a frequency array in this code. You can constant-optimize by using an unordered map.\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int> mp(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums1[i]]++;\\n            mp[nums2[i]]++;\\n        }\\n        \\n        for(auto &freq : mp)\\n        {\\n            if(freq>n)\\n                return -1;\\n            freq=0;\\n        }\\n    \\n        long long ans=0ll;\\n        int counter=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]==nums2[i])\\n            {\\n                mp[nums1[i]]++;\\n                counter++;\\n                ans=ans+i*1ll;\\n            }\\n        }\\n\\n        long long maxFreqVal=-1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int freq=mp[i];\\n            if(counter-freq<freq)\\n                maxFreqVal=i;\\n        }\\n\\n        if(maxFreqVal==-1)\\n            return ans;\\n        mp[maxFreqVal]=2*mp[maxFreqVal]-counter;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]==nums2[i])//these have already been considered\\n                continue;\\n            if(nums1[i]!=maxFreqVal && nums2[i]!=maxFreqVal && mp[maxFreqVal]>0)\\n            {\\n                ans=ans+i*1ll;\\n                mp[maxFreqVal]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int> mp(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums1[i]]++;\\n            mp[nums2[i]]++;\\n        }\\n        \\n        for(auto &freq : mp)\\n        {\\n            if(freq>n)\\n                return -1;\\n            freq=0;\\n        }\\n    \\n        long long ans=0ll;\\n        int counter=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]==nums2[i])\\n            {\\n                mp[nums1[i]]++;\\n                counter++;\\n                ans=ans+i*1ll;\\n            }\\n        }\\n\\n        long long maxFreqVal=-1;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int freq=mp[i];\\n            if(counter-freq<freq)\\n                maxFreqVal=i;\\n        }\\n\\n        if(maxFreqVal==-1)\\n            return ans;\\n        mp[maxFreqVal]=2*mp[maxFreqVal]-counter;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i]==nums2[i])//these have already been considered\\n                continue;\\n            if(nums1[i]!=maxFreqVal && nums2[i]!=maxFreqVal && mp[maxFreqVal]>0)\\n            {\\n                ans=ans+i*1ll;\\n                mp[maxFreqVal]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988658,
                "title": "c-java-python-o-1-space-complexity-with-moore-vote-algorithm",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n\\n> **Vote welcome if this solution helped.**\\n---\\n# Intuition\\n\\n1. Define \"internally\" as indexes $i$ satisfy $$a[i] = b[i]$$. It seems that swap internally should be done as much as possible, but there is no guarantee that internal swapping is always possible.\\n2. Every time an internal pair $i,j$ which $$i \\\\ne j$$ is found, an internal swap can be completed. So if we can swap internally for whole array, the $$ S = {\\\\sum_{a[i]=b[i]}^{} i} $$ will be the result.\\n3. In which condition we must swap externally? Obviously only if the number of internal swaps is insufficient.\\n4. Why not sufficient? An obvious case is that there is a value occurs more than half of the inner. In mathematics, that is, **the majority is more than a half**.\\n5. Another case is the internal number is odd, so it must remain one index. Fortunately, **we have the freedom to choose any index as the remainder, the other indexes will always matchable**. \\n6. How to choose? Since the chosen index will swap externally, we strongly want it can swap with `0`. Is it guaranteed to find such an index? The answer is \"Yes\". \\n7. Because the majority is less than half, there are **at least 3 different value inside**. So we can always find a $$i$$ which satisfy $$a[i] \\\\ne a[0]$$ and $$ a[i] \\\\ne b[0]$$. Choose this $$i$$ as the remainder, we can still maintain the result as $$S$$.\\n8. Finally, if we are forced to do external swaps, we should choose the smallest possible indexes.\\n\\n# Approach\\nThrough the above analysis, the problem becomes:\\n1. How to find the majority?\\n2. If the majority is greater than half, which external indexes can be included for swapping?\\n\\nSolve these questions sequentially:\\n\\n1.  It\\'s a classical problem: [LeetCode 169](https://leetcode.com/problems/majority-element/), can be solved in $O(1)$ space complexity with [Boyer\\u2013Moore majority vote algorithm](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm).\\n2. First, the newly included $$j$$ must be external. Secondly, the newly included $$a[j]$$ and $$b[j]$$ can\\'t be majority, otherwise there will be an equal situation after the swap. Finally enumerate from small to large until the number is sufficient.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& a, vector<int>& b) {\\n        // repeat is the number of a[i] == b[i]\\n        int n = a.size(), repeat = 0;   \\n        // s is the sum of i that satisfies a[i] == b[i]\\n        long long s = 0; \\n        // val is the only candidate for majority  \\n        int val = -1, x = 0;   \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i]) {\\n                if (x == 0) val = a[i];\\n                x += 2 * (val == a[i]) - 1;\\n                repeat++;\\n                s += i;\\n            }\\n        }\\n        // cnt is the count of val\\n        int cnt = 0;  \\n        for (int i = 0; i < n; ++i) {\\n            cnt += a[i] == b[i] && a[i] == val;\\n        }\\n        // less than half, so s is the result\\n        if (cnt * 2 < repeat) return s;\\n        // the number which need to be swapped externally\\n        int m = 2 * cnt - repeat;\\n        for (int i = 0; i < n && m > 0; ++i) {\\n            // index satisfying this condition can be used for swap\\n            if (a[i] != val && b[i] != val && a[i] != b[i]) {\\n                s += i;\\n                m--;\\n            }\\n        }\\n        if (m > 0) return -1;\\n        return s;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public long minimumTotalCost(int[] a, int[] b) {\\n        // repeat is the number of a[i] == b[i]\\n        int n = a.length;\\n        int repeat = 0;   \\n        // s is the sum of i that satisfies a[i] == b[i]\\n        long s = 0; \\n        // val is the only candidate for majority  \\n        int val = -1;\\n        int x = 0;   \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i]) {\\n                if (x == 0) val = a[i];\\n                if (val == a[i]) x--;\\n                else x++;\\n                repeat++;\\n                s += i;\\n            }\\n        }\\n        // cnt is the count of val\\n        int cnt = 0;  \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i] && a[i] == val)\\n                cnt++;\\n        }\\n        // less than half, so s is the result\\n        if (cnt * 2 < repeat) return s;\\n        // the number which need to be swapped externally\\n        int m = 2 * cnt - repeat;\\n        for (int i = 0; i < n && m > 0; ++i) {\\n            // index satisfying this condition can be used for swap\\n            if (a[i] != val && b[i] != val && a[i] != b[i]) {\\n                s += i;\\n                m--;\\n            }\\n        }\\n        if (m > 0) return -1;\\n        return s;\\n    }\\n}\\n```\\n``` Python []\\nclass Solution:\\n    def minimumTotalCost(self, a: List[int], b: List[int]) -> int:\\n        n = len(a)\\n        # repeat is the number of a[i] == b[i]\\n        repeat = 0  \\n        # s is the sum of i that satisfies a[i] == b[i]\\n        s = 0\\n        # val is the only candidate for majority  \\n        val, x = -1, 0\\n        for i in range(n):\\n            if a[i] == b[i]:\\n                if x == 0: val = a[i]\\n                x += 2 * (val == a[i]) - 1\\n                repeat += 1\\n                s += i\\n        # cnt is the count of val\\n        cnt = sum(a[i] == b[i] and a[i] == val for i in range(n))\\n        # less than half, so s is the result\\n        if cnt * 2 < repeat: \\n            return s\\n        # the number which need to be swapped externally\\n        m = 2 * cnt - repeat\\n        for i in range(n):\\n            # index satisfying this condition can be used for swap\\n            if a[i] != val and b[i] != val and a[i] != b[i]:\\n                s += i\\n                m -= 1\\n            if m <= 0:\\n                return s\\n        return -1\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Greedy"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& a, vector<int>& b) {\\n        // repeat is the number of a[i] == b[i]\\n        int n = a.size(), repeat = 0;   \\n        // s is the sum of i that satisfies a[i] == b[i]\\n        long long s = 0; \\n        // val is the only candidate for majority  \\n        int val = -1, x = 0;   \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i]) {\\n                if (x == 0) val = a[i];\\n                x += 2 * (val == a[i]) - 1;\\n                repeat++;\\n                s += i;\\n            }\\n        }\\n        // cnt is the count of val\\n        int cnt = 0;  \\n        for (int i = 0; i < n; ++i) {\\n            cnt += a[i] == b[i] && a[i] == val;\\n        }\\n        // less than half, so s is the result\\n        if (cnt * 2 < repeat) return s;\\n        // the number which need to be swapped externally\\n        int m = 2 * cnt - repeat;\\n        for (int i = 0; i < n && m > 0; ++i) {\\n            // index satisfying this condition can be used for swap\\n            if (a[i] != val && b[i] != val && a[i] != b[i]) {\\n                s += i;\\n                m--;\\n            }\\n        }\\n        if (m > 0) return -1;\\n        return s;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public long minimumTotalCost(int[] a, int[] b) {\\n        // repeat is the number of a[i] == b[i]\\n        int n = a.length;\\n        int repeat = 0;   \\n        // s is the sum of i that satisfies a[i] == b[i]\\n        long s = 0; \\n        // val is the only candidate for majority  \\n        int val = -1;\\n        int x = 0;   \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i]) {\\n                if (x == 0) val = a[i];\\n                if (val == a[i]) x--;\\n                else x++;\\n                repeat++;\\n                s += i;\\n            }\\n        }\\n        // cnt is the count of val\\n        int cnt = 0;  \\n        for (int i = 0; i < n; ++i) {\\n            if (a[i] == b[i] && a[i] == val)\\n                cnt++;\\n        }\\n        // less than half, so s is the result\\n        if (cnt * 2 < repeat) return s;\\n        // the number which need to be swapped externally\\n        int m = 2 * cnt - repeat;\\n        for (int i = 0; i < n && m > 0; ++i) {\\n            // index satisfying this condition can be used for swap\\n            if (a[i] != val && b[i] != val && a[i] != b[i]) {\\n                s += i;\\n                m--;\\n            }\\n        }\\n        if (m > 0) return -1;\\n        return s;\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def minimumTotalCost(self, a: List[int], b: List[int]) -> int:\\n        n = len(a)\\n        # repeat is the number of a[i] == b[i]\\n        repeat = 0  \\n        # s is the sum of i that satisfies a[i] == b[i]\\n        s = 0\\n        # val is the only candidate for majority  \\n        val, x = -1, 0\\n        for i in range(n):\\n            if a[i] == b[i]:\\n                if x == 0: val = a[i]\\n                x += 2 * (val == a[i]) - 1\\n                repeat += 1\\n                s += i\\n        # cnt is the count of val\\n        cnt = sum(a[i] == b[i] and a[i] == val for i in range(n))\\n        # less than half, so s is the result\\n        if cnt * 2 < repeat: \\n            return s\\n        # the number which need to be swapped externally\\n        m = 2 * cnt - repeat\\n        for i in range(n):\\n            # index satisfying this condition can be used for swap\\n            if a[i] != val and b[i] != val and a[i] != b[i]:\\n                s += i\\n                m -= 1\\n            if m <= 0:\\n                return s\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898184,
                "title": "c-java-python3-counting-total-maximum",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/661cb4686dc915189ddbf0bc35fa51f408bf42ef) for solutions of biweekly 93. \\n\\n**Intuition**\\nOne working strategy is to count total number of equal pairs `total` and compare it to the most frequent one `most`. We want to make sure that `total >= 2*most` so that we can arrange them to achieve inequality. If that\\'s impossible, we have to consider unequal pairs whose numbers are different from the most frequent key. By doing so, if we can get `total >= 2*most`, it is possible, and the sum of their indices gives the desired answer. Otherwise, it is impossible, return -1. \\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), total = 0;\\n        long long ans = 0;\\n        unordered_map<int, int> freq;\\n        for (int i = 0; i < n; ++i)\\n            if(nums1[i] == nums2[i]) {\\n                ++freq[nums1[i]];\\n                ++total; \\n                ans += i;\\n            }\\n        if (!total) return 0; \\n        auto [key, most] = *max_element(freq.begin(), freq.end(), [&](auto& lhs, auto& rhs) {return lhs.second < rhs.second;}); \\n        for (int i = 0; i < n && 2*most > total; ++i) \\n            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {\\n                ++total;\\n                ans += i;\\n            }\\n        return 2*most > total ? -1 : ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        int n = nums1.length, total = 0; \\n        int[] freq = new int[n+1]; \\n        long ans = 0; \\n        for (int i = 0; i < n; ++i) \\n            if (nums1[i] == nums2[i]) {\\n                ++freq[nums1[i]]; \\n                ++total; \\n                ans += i; \\n            }\\n        int most = 0, key = 0; \\n        for (int i = 0; i <= n; ++i) \\n            if (freq[i] > most) {\\n                key = i; \\n                most = freq[i]; \\n            }\\n        for (int i = 0; i < n && 2*most > total; ++i) \\n            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {\\n                ++total; \\n                ans += i; \\n            }\\n        return 2*most <= total ? ans : -1; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        ans = total = 0 \\n        freq = Counter()\\n        for i, (x, y) in enumerate(zip(nums1, nums2)): \\n            if x == y: \\n                freq[x] += 1 \\n                total += 1\\n                ans += i \\n        key = max(freq, key=freq.get, default=None)\\n        most = freq[key]\\n        for i, (x, y) in enumerate(zip(nums1, nums2)): \\n            if 2*most <= total: break \\n            if len({x, y, key}) == 3: \\n                total += 1\\n                ans += i \\n        return ans if 2*most <= total else -1 \\n```\\n**Complexity**\\nTime `O(N)`\\nSpace `O(N)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), total = 0;\\n        long long ans = 0;\\n        unordered_map<int, int> freq;\\n        for (int i = 0; i < n; ++i)\\n            if(nums1[i] == nums2[i]) {\\n                ++freq[nums1[i]];\\n                ++total; \\n                ans += i;\\n            }\\n        if (!total) return 0; \\n        auto [key, most] = *max_element(freq.begin(), freq.end(), [&](auto& lhs, auto& rhs) {return lhs.second < rhs.second;}); \\n        for (int i = 0; i < n && 2*most > total; ++i) \\n            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {\\n                ++total;\\n                ans += i;\\n            }\\n        return 2*most > total ? -1 : ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        int n = nums1.length, total = 0; \\n        int[] freq = new int[n+1]; \\n        long ans = 0; \\n        for (int i = 0; i < n; ++i) \\n            if (nums1[i] == nums2[i]) {\\n                ++freq[nums1[i]]; \\n                ++total; \\n                ans += i; \\n            }\\n        int most = 0, key = 0; \\n        for (int i = 0; i <= n; ++i) \\n            if (freq[i] > most) {\\n                key = i; \\n                most = freq[i]; \\n            }\\n        for (int i = 0; i < n && 2*most > total; ++i) \\n            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {\\n                ++total; \\n                ans += i; \\n            }\\n        return 2*most <= total ? ans : -1; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        ans = total = 0 \\n        freq = Counter()\\n        for i, (x, y) in enumerate(zip(nums1, nums2)): \\n            if x == y: \\n                freq[x] += 1 \\n                total += 1\\n                ans += i \\n        key = max(freq, key=freq.get, default=None)\\n        most = freq[key]\\n        for i, (x, y) in enumerate(zip(nums1, nums2)): \\n            if 2*most <= total: break \\n            if len({x, y, key}) == 3: \\n                total += 1\\n                ans += i \\n        return ans if 2*most <= total else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898128,
                "title": "fast-and-easy-c-solution-with-explanation-greedy-approach",
                "content": "# Intuition\\nTo minimize the cost, ideally we want to swap each index that has duplicate values only once. In this case, the cost will always be the sum of all the indices with duplicate values regardless of how we perform the operations.\\n\\nThere are two cases in which we need to perform additional operation(s):\\n\\nthere odd num of elements that needs to be swapped\\nthere is a value k that makes up more half of the duplicate values\\nIn Case 1, we just add indices 0 into the operations, the cost will not be impacted.\\nIn Case 2, we just add new indices i into the operations such that nums1[i] != k and nums2[i] != k, until there are equal number of indices with value k and with other values. To minimize the cost, we search from 0 up.\\nNote that Case 1 and 2 cannot happen at the same time. In case 2, after adding the indices, we always end up getting an even number of indices to swap with.\\n\\n\\nKindly **Upvote** if it helps you :)\\nYou may suggest changes and ask doubts in comments below.\\n\\n**Thanks!**\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899899,
                "title": "c-greedy-solution-detailed-explanation-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key is that the answer depends on all the pairs need to be changed, and once we find all the pairs to change (here, a pair stands for nums1[i] and nums2[i] for some index i), we can then use a greedy solution to get the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s call the most frequent paired number x and the set of pairs to change s.\\n1. Find Pairs\\nFirst, find indices i such that nums1[i] equals nums2[i]. When do we need to find more extra pairs to change? A trivial observation is that when {2 * the number of paired x} is larger than |s| (for example, if we have two pairs of 3 and one pair of 4, there is no solution since we have four 3s and only three blocks to put in), then we should find more pairs to change. There is a greedy way to do it, which is to find from the smallest index. Note that for some index i that is not in s, if either nums1[i] equals x or nums2[i] equals x, the result would not be better if we add it in s since the block cannot be changed to x in either nums1 or nums2. Hence, when iterating through indices from 0 to n-1, skip the indices that has been in s or has x in either array.\\n\\n2. Compute The Answer\\nIf |s| is even, we can simply add the indices up since for an index i, we could always find another index j to switch.\\nIf |s| is odd, we can use the operation above until |s| equals 3. In this case, we can use index 0 to help change the order of the three number, though. For instance, to change [...,1,2,3,...] to [...,3,1,2,...]:\\n[0,...,1,2,3,...] -> [3,...,1,2,0,...]->[1,...,3,2,0,...] -> [2,...,3,1,0,...]\\nAlthough the 0 and 2 are swapped, the new array is still valid. In fact, we can make the final array [2,...,3,1,0,...], [1,...,3,0,2,...], or [3,...,0,1,2,...], and at least one of them is valid. The total cost is still the sum of indices since moving index 0 doesn\\'t cost any.\\nIn conclusion, the cost of s is simply the sum of all the indices in s, and it prove that the above greedy solution of finding s is workable.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Note\\nThere are many details to be proved in the above solution, and it\\'s really complicated. I am not even sure if this solution is totally accurate. You can try proving them if interested.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<bool>arr(n);//record pairs to change\\n        vector<int>pairs(n+1);//record frequency of pairs of number\\n        \\n        int cnt = 0;//number of pairs to change\\n        //build cnt and pairs\\n        for(int i = 0; i < n; i++){\\n            if(nums1[i] == nums2[i]){\\n                arr[i] = true;\\n                ++cnt;\\n                ++pairs[nums1[i]];\\n            }\\n        }\\n\\n        //find the most frequent paired number x and its frequency y\\n        int x = -1, y = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(pairs[i] > y){\\n                y = pairs[i];\\n                x = i;\\n            }\\n        }\\n        if(x == -1)return 0;\\n\\n        //for index i, add it into pairs to change if it doesn\\'t have any x\\n        int id = -1;\\n        while(2*y > cnt){\\n            ++id;\\n            if(id == n)return -1;//x is so much that we can\\'t fill it in the whole array\\n            if(arr[id])continue;\\n            if(nums1[id] == x || nums2[id] == x)continue;\\n            ++cnt;\\n            arr[id] = true;\\n        }\\n\\n        //since we have found all pairs to change, we could simply add up all the indices\\n        long long ret = 0;\\n        for(int i = 0; i < n; i++)if(arr[i])ret += i;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<bool>arr(n);//record pairs to change\\n        vector<int>pairs(n+1);//record frequency of pairs of number\\n        \\n        int cnt = 0;//number of pairs to change\\n        //build cnt and pairs\\n        for(int i = 0; i < n; i++){\\n            if(nums1[i] == nums2[i]){\\n                arr[i] = true;\\n                ++cnt;\\n                ++pairs[nums1[i]];\\n            }\\n        }\\n\\n        //find the most frequent paired number x and its frequency y\\n        int x = -1, y = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(pairs[i] > y){\\n                y = pairs[i];\\n                x = i;\\n            }\\n        }\\n        if(x == -1)return 0;\\n\\n        //for index i, add it into pairs to change if it doesn\\'t have any x\\n        int id = -1;\\n        while(2*y > cnt){\\n            ++id;\\n            if(id == n)return -1;//x is so much that we can\\'t fill it in the whole array\\n            if(arr[id])continue;\\n            if(nums1[id] == x || nums2[id] == x)continue;\\n            ++cnt;\\n            arr[id] = true;\\n        }\\n\\n        //since we have found all pairs to change, we could simply add up all the indices\\n        long long ret = 0;\\n        for(int i = 0; i < n; i++)if(arr[i])ret += i;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898960,
                "title": "best-explaination-so-far-with-examples-tc-sc",
                "content": "# Intuition\\nThere are Two cases in this problem\\n**Case1.**    *domCount <= (totalNum/2)*\\nindexs: [0,1,2]\\nnums1: [1,2,3]\\nnums2: [1,2,3]\\n\\nhere, **domCount**: 1 ; **domNum**: 1 ; **totalNum**: 3 (1,2,3 are duplicates)\\nSo, ans = sum off all duplicates indexes 0+1+2 as Each can be swapped among themselves to get required result\\n> Swap Only the duplicates with the help of index 0(be a part of duplicates OR not)\\n\\nswap(1,2) 0+1 = 1 nums2: [2,1,3]\\nswap(1,3) 0+2 = 2 nums2: [3,1,2]\\nans = 1 + 2 = 3 (Required Ans)\\nNote: index 0 is used everytime to reduce the cost\\n\\n---\\n\\n\\n**Case2:**   *domCount > (totalNum/2)*\\nindexs: [0,1,2,3,4]\\nnums1: [2,2,2,1,3]\\nnums2: [1,2,2,3,3]\\n\\nhere, **domCount**: 2 ; **domNum**: 2 ; **totalNum**: 3 (2(idx:1),2(idx:2),3 are duplicates)\\n> Swap Only the duplicates with the help of index 0(be a part of duplicates OR not)\\n\\nnums1: [2,2,2,1,3]\\nnums2: [1,2,2,3,3]\\n*->swap(1(idx:0),2(idx:1)) 0+1= 1* \\nnums1: [2,2,2,1,3]\\nnums2: [2,1,2,3,3]\\n*->swap(2((idx:0)),2(idx:2)) 0+2= 2* \\nnums1: [2,2,2,1,3]\\nnums2: [2,1,2,3,3]\\n*->swap(2((idx:0)),2(idx:4)) 0+4= 4 *\\nnums1: [2,2,2,1,3]\\nnums2: [3,1,2,3,2]\\nStill, Problem in index 2 => Now Pick elements from original array\\nif we pick index:0 to swap with index:2 num2 becomes similar to nums1 at index:1 . So only Swap if **(nums1[i] != nums2[i] && nums1[i] != domNum && nums2[i] != domNum**\\nSimilarly, cant swap with index:1 and index2\\nFinally can *Swap with index:3* 0+3 = 3 [if we would have included index 3 in start itself]\\nnums1: [2,2,2,1,3]\\nnums2: [3,1,3,2,2]\\nans = 1+2+4+3 = 10 (Required Ans)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int domNum = -1,domCount = 0,totalNum = 0,n = nums1.size();\\n        long ans = 0;\\n        unordered_map<int,int> store;   //store freq of duplicates in nums1 ad nums2\\n\\n        for(int i=0;i<n;i++){\\n            if(nums1[i] == nums2[i]){\\n                ans = ans + i;\\n                store[nums1[i]]++;\\n\\n                if(store[nums1[i]] > domCount){\\n                    domCount = store[nums1[i]];\\n                    domNum = nums1[i];\\n                }\\n\\n                totalNum++;\\n            }\\n        }\\n\\n        if( domCount <= (totalNum/2)){\\n            //Means Each duplicates will swap among themselves to get the required array\\n            return ans;\\n        }\\n        else{\\n            //Duplicates have to be swapped with other elements of original Array\\n\\n            for(int i=0;i<n;i++){\\n                if(nums1[i] != nums2[i] && nums1[i] != domNum && nums2[i] != domNum){\\n                    ans = ans + i;\\n                    totalNum++;\\n\\n                }\\n                \\n                if( domCount <= (totalNum/2)){\\n                    //Got the required Array , Can stop now\\n                    return ans;\\n                }\\n\\n            }\\n        }\\n\\n        //Not Possible\\n        return -1;\\n        \\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int domNum = -1,domCount = 0,totalNum = 0,n = nums1.size();\\n        long ans = 0;\\n        unordered_map<int,int> store;   //store freq of duplicates in nums1 ad nums2\\n\\n        for(int i=0;i<n;i++){\\n            if(nums1[i] == nums2[i]){\\n                ans = ans + i;\\n                store[nums1[i]]++;\\n\\n                if(store[nums1[i]] > domCount){\\n                    domCount = store[nums1[i]];\\n                    domNum = nums1[i];\\n                }\\n\\n                totalNum++;\\n            }\\n        }\\n\\n        if( domCount <= (totalNum/2)){\\n            //Means Each duplicates will swap among themselves to get the required array\\n            return ans;\\n        }\\n        else{\\n            //Duplicates have to be swapped with other elements of original Array\\n\\n            for(int i=0;i<n;i++){\\n                if(nums1[i] != nums2[i] && nums1[i] != domNum && nums2[i] != domNum){\\n                    ans = ans + i;\\n                    totalNum++;\\n\\n                }\\n                \\n                if( domCount <= (totalNum/2)){\\n                    //Got the required Array , Can stop now\\n                    return ans;\\n                }\\n\\n            }\\n        }\\n\\n        //Not Possible\\n        return -1;\\n        \\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898020,
                "title": "java-greedy-approach",
                "content": "# Intuition\\nTo minimize the cost, ideally we want to swap each index that has duplicate values only once. In this case, the cost will always be the sum of all the indices with duplicate values regardless of how we perform the operations.\\n\\nThere are two cases in which we cannot swap in the ideal approach:\\n1) there odd num of elements that needs to be swapped\\n2) there is a value `k` that makes up more half of the duplicate values\\n\\nIn Case 1, we just add indices 0 into the operations, the cost will not be impacted.\\nIn Case 2, we just add new indices `i` into the operations such that `nums1[i] != k` and `nums2[i] != k`, until there are equal number of indices with value `k` and with other values. To minimize the cost, we search from 0 up.\\nNote that Case 1 and 2 cannot occur at the same time. In case 2, after adding the indices, we always end up getting an even number of indices to swap with.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        int k = 0, m = 0, n = nums1.length; \\n        boolean[] operated = new boolean[n];\\n        long output = 0;\\n        for (int i = 0; i < n; i++) if (nums1[i] == nums2[i]) {\\n            operated[i] = true;\\n            counts.put(nums1[i], counts.getOrDefault(nums1[i], 0) + 1);\\n            m++;\\n            output += i;\\n        }\\n        for (Map.Entry<Integer, Integer> count : counts.entrySet()) if (count.getValue() > m >> 1) {\\n            k = count.getKey();\\n            break;\\n        }\\n        if (k > 0) {\\n            for (int i = 0; i < n && counts.get(k) > m >> 1; i++) if (!operated[i] && nums1[i] != k && nums2[i] != k) {\\n                m++;\\n                operated[i] = true;\\n                output += i;\\n            }\\n            if (counts.get(k) > m >> 1) return -1;\\n        }\\n        return output;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        HashMap<Integer, Integer> counts = new HashMap<>();\\n        int k = 0, m = 0, n = nums1.length; \\n        boolean[] operated = new boolean[n];\\n        long output = 0;\\n        for (int i = 0; i < n; i++) if (nums1[i] == nums2[i]) {\\n            operated[i] = true;\\n            counts.put(nums1[i], counts.getOrDefault(nums1[i], 0) + 1);\\n            m++;\\n            output += i;\\n        }\\n        for (Map.Entry<Integer, Integer> count : counts.entrySet()) if (count.getValue() > m >> 1) {\\n            k = count.getKey();\\n            break;\\n        }\\n        if (k > 0) {\\n            for (int i = 0; i < n && counts.get(k) > m >> 1; i++) if (!operated[i] && nums1[i] != k && nums2[i] != k) {\\n                m++;\\n                operated[i] = true;\\n                output += i;\\n            }\\n            if (counts.get(k) > m >> 1) return -1;\\n        }\\n        return output;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897990,
                "title": "greedy-python-3",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        z=Counter(nums1)\\n        z1=Counter(nums2)\\n        for i in z:\\n            if(n-z1[i]<z[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        for i in z1:\\n            if(n-z[i]<z1[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        z=Counter([])\\n        ans=0\\n        flag=0\\n        d=defaultdict(list)\\n        vis=[0 for i in range(n)]\\n        for i in range(n):\\n            if(nums1[i]==nums2[i]):\\n                z[nums2[i]]+=1\\n                ans+=i\\n                flag=1\\n                d[nums2[i]].append(i)\\n        t=0\\n        l=z.most_common(len(z))\\n        a=0\\n        for i in range(1,len(l)):\\n            a+=l[i][1]\\n            for j in d[l[i][0]]:\\n                vis[j]=1\\n            z[l[i][0]]=0\\n        if(l and a>=l[0][1]):\\n            return ans\\n        x=0\\n        if(l):\\n            x=l[0][1]-a\\n            z[l[0][0]]=x\\n        print(z,ans)\\n        for j in z:\\n            if(z[j]):\\n                for i in range(n):\\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\\n                        if(flag):\\n                            ans+=i\\n                            x-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        z=Counter(nums1)\\n        z1=Counter(nums2)\\n        for i in z:\\n            if(n-z1[i]<z[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        for i in z1:\\n            if(n-z[i]<z1[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        z=Counter([])\\n        ans=0\\n        flag=0\\n        d=defaultdict(list)\\n        vis=[0 for i in range(n)]\\n        for i in range(n):\\n            if(nums1[i]==nums2[i]):\\n                z[nums2[i]]+=1\\n                ans+=i\\n                flag=1\\n                d[nums2[i]].append(i)\\n        t=0\\n        l=z.most_common(len(z))\\n        a=0\\n        for i in range(1,len(l)):\\n            a+=l[i][1]\\n            for j in d[l[i][0]]:\\n                vis[j]=1\\n            z[l[i][0]]=0\\n        if(l and a>=l[0][1]):\\n            return ans\\n        x=0\\n        if(l):\\n            x=l[0][1]-a\\n            z[l[0][0]]=x\\n        print(z,ans)\\n        for j in z:\\n            if(z[j]):\\n                for i in range(n):\\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\\n                        if(flag):\\n                            ans+=i\\n                            x-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023122,
                "title": "c-solution-o-n-time-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int dominant=0,dominantcnt=0,involved=0;\\n        long long ans=0;\\n        vector<int>cnt(1e5+1,0);\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]==nums2[i]){\\n                involved++;\\n                ans+=i;\\n                cnt[nums1[i]]++;\\n                if(cnt[nums1[i]]>dominantcnt){\\n                    dominantcnt=cnt[nums1[i]];\\n                    dominant=nums1[i];\\n                }\\n            }\\n        }\\n        if(dominantcnt > involved/2){\\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i] && nums1[i]!=dominant && nums2[i]!=dominant){\\n                    ans+=i;\\n                    cnt[nums1[i]]++;\\n                    involved++;\\n                    if(dominantcnt<= involved/2){\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int dominant=0,dominantcnt=0,involved=0;\\n        long long ans=0;\\n        vector<int>cnt(1e5+1,0);\\n        for(int i=0;i<nums1.size();i++){\\n            if(nums1[i]==nums2[i]){\\n                involved++;\\n                ans+=i;\\n                cnt[nums1[i]]++;\\n                if(cnt[nums1[i]]>dominantcnt){\\n                    dominantcnt=cnt[nums1[i]];\\n                    dominant=nums1[i];\\n                }\\n            }\\n        }\\n        if(dominantcnt > involved/2){\\n            for(int i=0;i<nums1.size();i++){\\n                if(nums1[i]!=nums2[i] && nums1[i]!=dominant && nums2[i]!=dominant){\\n                    ans+=i;\\n                    cnt[nums1[i]]++;\\n                    involved++;\\n                    if(dominantcnt<= involved/2){\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979559,
                "title": "not-clean-greedy-logics-nlogn",
                "content": "this is one of those hard greedy questions which involves too many logics, but easy if you think about it and take some time\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& n1, vector<int>& n2) {\\n        int n=n1.size();\\n        map<int,int> count;\\n        map<int,int> c;\\n        long long res=0;\\n        for(int x=0;x<n;x++){\\n            count[n1[x]]++;\\n            count[n2[x]]++;\\n            if(count[n1[x]]>n or count[n2[x]]>n)// LOGIC-1\\n                return -1;\\n            if(n1[x]==n2[x]){\\n                c[n1[x]]++;\\n                res+=x;    // LOGIC-2\\n            }\\n        }\\n        multiset<pair<int,int>> s;\\n        map<int,int> m;\\n        for(auto &[a,b]:c){\\n            s.insert({b,a});\\n            m[b]++;\\n        }\\n        while(s.size()){\\n            if(m[1]==s.size() and m[1]!=1)// LOGIC-3\\n                return res;\\n            auto last=*s.rbegin();\\n            s.erase(prev(s.end()));\\n            if(s.empty()){              // LOGIC-4\\n                auto fuck=last.second;\\n                auto fuck_count=last.first;\\n                for(int x=0;x<n;x++){\\n                    if(n1[x]==n2[x])\\n                        continue;\\n                    if(n1[x]==fuck or n2[x]==fuck)\\n                        continue;\\n                    res+=x;\\n                    fuck_count--;\\n                    if(fuck_count==0)\\n                        return res;\\n                }\\n                if(fuck_count!=0)\\n                    return -1;\\n            }\\n            auto s_last=*s.rbegin();\\n            s.erase(prev(s.end()));\\n            m[last.first]--;\\n            m[s_last.first]--;\\n            last.first--;\\n            s_last.first--;\\n            if(last.first>0){\\n                m[last.first]++;\\n                s.insert(last);\\n            }\\n            if(s_last.first>0){\\n                m[s_last.first]++;\\n                s.insert(s_last);\\n            }\\n        }\\n        return res;// LOGIC-5\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& n1, vector<int>& n2) {\\n        int n=n1.size();\\n        map<int,int> count;\\n        map<int,int> c;\\n        long long res=0;\\n        for(int x=0;x<n;x++){\\n            count[n1[x]]++;\\n            count[n2[x]]++;\\n            if(count[n1[x]]>n or count[n2[x]]>n)// LOGIC-1\\n                return -1;\\n            if(n1[x]==n2[x]){\\n                c[n1[x]]++;\\n                res+=x;    // LOGIC-2\\n            }\\n        }\\n        multiset<pair<int,int>> s;\\n        map<int,int> m;\\n        for(auto &[a,b]:c){\\n            s.insert({b,a});\\n            m[b]++;\\n        }\\n        while(s.size()){\\n            if(m[1]==s.size() and m[1]!=1)// LOGIC-3\\n                return res;\\n            auto last=*s.rbegin();\\n            s.erase(prev(s.end()));\\n            if(s.empty()){              // LOGIC-4\\n                auto fuck=last.second;\\n                auto fuck_count=last.first;\\n                for(int x=0;x<n;x++){\\n                    if(n1[x]==n2[x])\\n                        continue;\\n                    if(n1[x]==fuck or n2[x]==fuck)\\n                        continue;\\n                    res+=x;\\n                    fuck_count--;\\n                    if(fuck_count==0)\\n                        return res;\\n                }\\n                if(fuck_count!=0)\\n                    return -1;\\n            }\\n            auto s_last=*s.rbegin();\\n            s.erase(prev(s.end()));\\n            m[last.first]--;\\n            m[s_last.first]--;\\n            last.first--;\\n            s_last.first--;\\n            if(last.first>0){\\n                m[last.first]++;\\n                s.insert(last);\\n            }\\n            if(s_last.first>0){\\n                m[s_last.first]++;\\n                s.insert(s_last);\\n            }\\n        }\\n        return res;// LOGIC-5\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270497,
                "title": "minimum-total-cost-to-make-arrays-unequal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe intuition is tricky; I needed a bit of whiteboarding to figure out #4 below.\\n\\nWe check for equal elements. If n1[i] == n2[i], we will need to move it, so we just add i to the result.\\nWe use hashmap to count equal elements for each value.\\nThe best strategy is to rearrange equal elements only - it will not require any additional cost.\\nWe can always rearrange equal elements if there is no majority element.\\nIn other words, we do not have a value that accounts for more than a half of equal elements.\\nIf the number of equal elements is odd, the last once can be swapped with the first element for zero cost.\\nWe can always make this last swap since we have several values to choose from.\\nSay, for example, we have equal elements 2, 2, 2, 3, 3, 4, 4 (odd total number). We can swap:\\n(2, 3), (2, 3), (2, 4), then (x, 4) - x is the first element.\\n(2, 4), (2, 4), (2, 3), then (x, 3).\\n(2, 3), (2, 4), (3, 4), then (x, 2).\\n\\nIf we have a majority element n appearing n_cnt times.\\nWe can swap equal - n_cnt equal elements for no extra cost.\\nPlus, we need to swap 2 * n_cnt - equal equal with some non-equal elements for a cost.\\nWe scan the array left-to-right (to minimize cost), do swaps if we can, and add indexes to the cost.\\nIf we are able to do all swaps, return cost (and -1 otherwise).\\n\\n# Complexity\\n- Time complexity:O(nlgn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& n1, vector<int>& n2) {\\n        long long res = 0, cnt = 0, sz = n1.size();\\n    unordered_map<int, int> m{{0,0}}; // sentinel\\n    for (int i = 0; i < sz; ++i)\\n        if (n1[i] == n2[i]) {\\n            res += i;\\n            ++m[n1[i]];\\n            ++cnt;\\n        }\\n    const auto &[n, n_cnt] = *max_element(begin(m), end(m), \\n        [](const auto &a, const auto &b){ return a.second < b.second; });\\n    int swaps = 2 * n_cnt - cnt;\\n    for (int i = 0; swaps > 0 && i < sz; ++i)\\n        if (n1[i] != n2[i] && n1[i] != n && n2[i] != n) {\\n            res += i;\\n            --swaps;\\n        }\\n    return swaps > 0 ? -1 : res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& n1, vector<int>& n2) {\\n        long long res = 0, cnt = 0, sz = n1.size();\\n    unordered_map<int, int> m{{0,0}}; // sentinel\\n    for (int i = 0; i < sz; ++i)\\n        if (n1[i] == n2[i]) {\\n            res += i;\\n            ++m[n1[i]];\\n            ++cnt;\\n        }\\n    const auto &[n, n_cnt] = *max_element(begin(m), end(m), \\n        [](const auto &a, const auto &b){ return a.second < b.second; });\\n    int swaps = 2 * n_cnt - cnt;\\n    for (int i = 0; swaps > 0 && i < sz; ++i)\\n        if (n1[i] != n2[i] && n1[i] != n && n2[i] != n) {\\n            res += i;\\n            --swaps;\\n        }\\n    return swaps > 0 ? -1 : res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252055,
                "title": "python-simple-hashmap-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1, nums2):\\n        n = len(nums1)\\n\\n        result, dict1, total, most_freq, val = 0, collections.defaultdict(int), 0, 0, 0\\n\\n        for i,(x,y) in enumerate(zip(nums1,nums2)):\\n            if x == y:\\n                result += i\\n                total += 1\\n                dict1[x] += 1\\n\\n                if dict1[x] > val:\\n                    val = dict1[x]\\n                    most_freq = x\\n\\n        if 2*val <= total:\\n            return result\\n\\n        k = 2*val - total \\n\\n        for i,(x,y) in enumerate(zip(nums1,nums2)):\\n            if x != y and x != most_freq and y != most_freq:\\n                result += i\\n                k -= 1\\n\\n            if k == 0: return result \\n\\n        return -1\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalCost(self, nums1, nums2):\\n        n = len(nums1)\\n\\n        result, dict1, total, most_freq, val = 0, collections.defaultdict(int), 0, 0, 0\\n\\n        for i,(x,y) in enumerate(zip(nums1,nums2)):\\n            if x == y:\\n                result += i\\n                total += 1\\n                dict1[x] += 1\\n\\n                if dict1[x] > val:\\n                    val = dict1[x]\\n                    most_freq = x\\n\\n        if 2*val <= total:\\n            return result\\n\\n        k = 2*val - total \\n\\n        for i,(x,y) in enumerate(zip(nums1,nums2)):\\n            if x != y and x != most_freq and y != most_freq:\\n                result += i\\n                k -= 1\\n\\n            if k == 0: return result \\n\\n        return -1\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234890,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), total = 0;\\n        long long ans = 0;\\n        unordered_map<int, int> freq;\\n        for (int i = 0; i < n; ++i)\\n            if(nums1[i] == nums2[i]) {\\n                ++freq[nums1[i]];\\n                ++total; \\n                ans += i;\\n            }\\n        if (!total) return 0; \\n        auto [key, most] = *max_element(freq.begin(), freq.end(), [&](auto& lhs, auto& rhs) {return lhs.second < rhs.second;}); \\n        for (int i = 0; i < n && 2*most > total; ++i) \\n            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {\\n                ++total;\\n                ans += i;\\n            }\\n        return 2*most > total ? -1 : ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), total = 0;\\n        long long ans = 0;\\n        unordered_map<int, int> freq;\\n        for (int i = 0; i < n; ++i)\\n            if(nums1[i] == nums2[i]) {\\n                ++freq[nums1[i]];\\n                ++total; \\n                ans += i;\\n            }\\n        if (!total) return 0; \\n        auto [key, most] = *max_element(freq.begin(), freq.end(), [&](auto& lhs, auto& rhs) {return lhs.second < rhs.second;}); \\n        for (int i = 0; i < n && 2*most > total; ++i) \\n            if (nums1[i] != nums2[i] && key != nums1[i] && key != nums2[i]) {\\n                ++total;\\n                ans += i;\\n            }\\n        return 2*most > total ? -1 : ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116811,
                "title": "swift-solution-basic-approach",
                "content": "# Approach\\n1. We can use a greedy approach to solve this problem.\\n2. We can first count the frequency of each number in the array.\\n3. If the frequency of a number is greater than n/2, then we can remove all the other numbers and replace them with that number.\\n4. We can then greedily replace the remaining numbers with the number that we want to replace them with.\\n5. If we can\\'t find a number that has a frequency greater than n/2, then we can\\'t replace all the numbers with a single number.\\n6. If we can find such a number, then we can greedily replace the remaining numbers with the number that we want to replace them with.\\n7. We can then return the cost of the replacement.\\n\\n\\n# Complexity\\n> Time complexity: O(n)\\n> Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumTotalCost(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        var cost = 0\\n        var count = [Int](repeating: 0, count: n+1)\\n        var sum = 0\\n        for i in 0..<n {\\n            if nums1[i] == nums2[i] {\\n                count[nums1[i]] += 1\\n                sum += 1\\n                cost += i\\n            }\\n        }\\n        var rem = -1\\n        var freq = 0\\n        for i in 0...n {\\n            if count[i] > (sum/2) {\\n                rem = i\\n                freq = count[i] - (sum-count[i])\\n                break\\n            }\\n        }\\n        if rem == -1 { return cost }\\n        for i in 0..<n {\\n            if nums1[i] != nums2[i] && rem != nums2[i] && rem != nums1[i] {\\n                cost += i\\n                freq -= 1\\n            }\\n            if freq == 0 { break }\\n        }\\n        if freq != 0 { return -1 }\\n        return cost\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTotalCost(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        var cost = 0\\n        var count = [Int](repeating: 0, count: n+1)\\n        var sum = 0\\n        for i in 0..<n {\\n            if nums1[i] == nums2[i] {\\n                count[nums1[i]] += 1\\n                sum += 1\\n                cost += i\\n            }\\n        }\\n        var rem = -1\\n        var freq = 0\\n        for i in 0...n {\\n            if count[i] > (sum/2) {\\n                rem = i\\n                freq = count[i] - (sum-count[i])\\n                break\\n            }\\n        }\\n        if rem == -1 { return cost }\\n        for i in 0..<n {\\n            if nums1[i] != nums2[i] && rem != nums2[i] && rem != nums1[i] {\\n                cost += i\\n                freq -= 1\\n            }\\n            if freq == 0 { break }\\n        }\\n        if freq != 0 { return -1 }\\n        return cost\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109197,
                "title": "solution-with-love-to-community-simple-explanation-o-n",
                "content": "# Explanation\\nThe code is trying to find the minimum cost of swapping elements in an array called \"nums1\" so that it becomes the same as another array called \"nums2\". The cost of swapping two elements is the sum of their indices.\\n\\nThe first thing the code does is to create some variables:\\n\\nans - this will keep track of the total cost of all the swaps\\nfreq - this is a dictionary that keeps track of how many times each element appears in the \"nums1\" array\\nmaxFrequency - this keeps track of the element that appears the most in the \"nums1\" array\\nmaxFrequencyValue - this keeps track of the value of the element that appears the most in the \"nums1\" array\\ntoSwap - this keeps track of how many elements need to be swapped in order to make \"nums1\" the same as \"nums2\"\\nThen, the code loops through all the elements in the \"nums1\" array and:\\n\\nIf the current element in \"nums1\" is the same as the corresponding element in \"nums2\", it means that no swap is needed for this element. So, the code adds the index of this element to the \"ans\" variable (since the cost of swapping is the sum of the indices, we are adding the cost of not swapping this element). The code also increments the \"toSwap\" variable since we don\\'t need to swap this element.\\nIf the current element in \"nums1\" is different from the corresponding element in \"nums2\", it means that a swap is needed for this element. So, the code adds the index of this element to the \"freq\" dictionary and increments the maxFrequency and maxFrequencyValue if needed.\\nAfter the first loop, the code loops through the \"nums1\" array again and:\\n\\nIf the maxFrequency is greater than half of the \"toSwap\" variable, and the current element in \"nums1\" is different from the corresponding element in \"nums2\", and both the current element in \"nums1\" and the corresponding element in \"nums2\" are not the maxFrequencyValue, then the code adds the index of this element to the \"ans\" variable and increments the \"toSwap\" variable.\\nFinally, the code checks if the maxFrequency is still greater than half of the \"toSwap\" variable. If it is, the code returns -1 since it is not possible to make \"nums1\" the same as \"nums2\" with the given conditions. If not, the code returns the total cost of all the swaps (stored in the \"ans\" variable).\\n\\nThe Time Complexity of this code is O(n) because we are looping through the \"nums1\" array twice, once to count the frequency of each element and once to check if we need to swap elements. The space complexity is also O(n) because we are using a dictionary \"freq\" that can contain at most n elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums1.size();\\n\\n    // Initialize variables to keep track of the total cost and frequency of values\\n    long long ans = 0;\\n    unordered_map<int, int> freq;\\n    int maxFrequency = 0;\\n    int maxFrequencyValue = 0;\\n    int toSwap = 0;\\n\\n    // Iterate through the arrays\\n    for (int i = 0; i < n; i++) {\\n        // If the values at the current index are the same\\n        if (nums1[i] == nums2[i]) {\\n            // Increase the frequency of the current value in the map\\n            freq[nums1[i]]++;\\n\\n            // Update the max frequency and max frequency value\\n            if (freq[nums1[i]] > maxFrequency) {\\n                maxFrequencyValue = nums1[i];\\n            }\\n            maxFrequency = max(maxFrequency, freq[nums1[i]]);\\n\\n            // Increase the total cost and the number of swaps needed\\n            ans += i;\\n            toSwap++;\\n        }\\n    }\\n\\n    // Iterate through the arrays again\\n    for (int i = 0; i < n; i++) {\\n        // If the max frequency is greater than half the number of swaps needed\\n        // and the values at the current index are different\\n        // and the current values are not the max frequency value\\n        if (maxFrequency > toSwap/2 && nums1[i] != nums2[i] && nums1[i] != maxFrequencyValue && nums2[i] != maxFrequencyValue) {\\n            // Increase the total cost and the number of swaps needed\\n            ans += i;\\n            toSwap++;\\n        }\\n    }\\n\\n    // If the max frequency is still greater than half the number of swaps needed\\n    if (maxFrequency > toSwap/2) {\\n        return -1;\\n    }\\n\\n    return ans;\\n}\\n\\n\\n\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums1.size();\\n\\n    // Initialize variables to keep track of the total cost and frequency of values\\n    long long ans = 0;\\n    unordered_map<int, int> freq;\\n    int maxFrequency = 0;\\n    int maxFrequencyValue = 0;\\n    int toSwap = 0;\\n\\n    // Iterate through the arrays\\n    for (int i = 0; i < n; i++) {\\n        // If the values at the current index are the same\\n        if (nums1[i] == nums2[i]) {\\n            // Increase the frequency of the current value in the map\\n            freq[nums1[i]]++;\\n\\n            // Update the max frequency and max frequency value\\n            if (freq[nums1[i]] > maxFrequency) {\\n                maxFrequencyValue = nums1[i];\\n            }\\n            maxFrequency = max(maxFrequency, freq[nums1[i]]);\\n\\n            // Increase the total cost and the number of swaps needed\\n            ans += i;\\n            toSwap++;\\n        }\\n    }\\n\\n    // Iterate through the arrays again\\n    for (int i = 0; i < n; i++) {\\n        // If the max frequency is greater than half the number of swaps needed\\n        // and the values at the current index are different\\n        // and the current values are not the max frequency value\\n        if (maxFrequency > toSwap/2 && nums1[i] != nums2[i] && nums1[i] != maxFrequencyValue && nums2[i] != maxFrequencyValue) {\\n            // Increase the total cost and the number of swaps needed\\n            ans += i;\\n            toSwap++;\\n        }\\n    }\\n\\n    // If the max frequency is still greater than half the number of swaps needed\\n    if (maxFrequency > toSwap/2) {\\n        return -1;\\n    }\\n\\n    return ans;\\n}\\n\\n\\n\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028786,
                "title": "java-counter",
                "content": "```\\n    //1.counter\\n    //Runtime: 3ms 100%; Memory: 59.9MB 72%\\n    //Time: O(N); Space: O(N)\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        long sum = 0;\\n        int maxCount = 0, maxVal = 0, totalCount = 0;\\n        int[] counter = new int[nums1.length + 1];\\n        for (int i = 0; i < nums1.length; i++) {\\n            if (nums1[i] == nums2[i]) {\\n                sum += i;\\n                totalCount++;\\n                counter[nums1[i]]++;\\n\\n                if (counter[nums1[i]] > maxCount){\\n                    maxCount = counter[nums1[i]];\\n                    maxVal = nums1[i];\\n                }\\n            }\\n        }\\n\\n        int needSwap = (maxCount << 1) - totalCount; //maxCount - (totalCount - maxCount);\\n        for (int i = 0; i < nums1.length && needSwap > 0; i++) {\\n            if (nums1[i] != nums2[i] && nums1[i] != maxVal && nums2[i] != maxVal){\\n                needSwap--;\\n                sum += i;\\n            }\\n        }\\n        return needSwap > 0 ? -1 : sum;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //1.counter\\n    //Runtime: 3ms 100%; Memory: 59.9MB 72%\\n    //Time: O(N); Space: O(N)\\n    public long minimumTotalCost(int[] nums1, int[] nums2) {\\n        long sum = 0;\\n        int maxCount = 0, maxVal = 0, totalCount = 0;\\n        int[] counter = new int[nums1.length + 1];\\n        for (int i = 0; i < nums1.length; i++) {\\n            if (nums1[i] == nums2[i]) {\\n                sum += i;\\n                totalCount++;\\n                counter[nums1[i]]++;\\n\\n                if (counter[nums1[i]] > maxCount){\\n                    maxCount = counter[nums1[i]];\\n                    maxVal = nums1[i];\\n                }\\n            }\\n        }\\n\\n        int needSwap = (maxCount << 1) - totalCount; //maxCount - (totalCount - maxCount);\\n        for (int i = 0; i < nums1.length && needSwap > 0; i++) {\\n            if (nums1[i] != nums2[i] && nums1[i] != maxVal && nums2[i] != maxVal){\\n                needSwap--;\\n                sum += i;\\n            }\\n        }\\n        return needSwap > 0 ? -1 : sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2977063,
                "title": "swift-solution",
                "content": "# Keypoint\\n1. If there is no majority element, find all i such that nums1[i] == nums2[i]\\uFF0Creturn sum(i)\\n2. If there is major element and `count of majority element >  count of all extracted elements / 2`, handle it seperately.\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumTotalCost(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        var ans = 0\\n        var freq = [Int: Int]()\\n        var maxFrequency = 0\\n        var maxFrequencyValue = 0\\n        var toSwap = 0\\n        \\n        for i in 0..<n {\\n            if nums1[i] == nums2[i] {\\n                freq[nums1[i], default: 0] += 1\\n                if freq[nums1[i]]! > maxFrequency {\\n                    maxFrequencyValue = nums1[i]\\n                }\\n                maxFrequency = max(maxFrequency, freq[nums1[i]]!)\\n                toSwap += 1\\n                ans += i\\n            }\\n        }\\n        \\n        for i in 0..<n {\\n            if maxFrequency > toSwap/2 && nums1[i] != nums2[i] && nums1[i] != maxFrequencyValue && nums2[i] != maxFrequencyValue {\\n                ans += i\\n                toSwap += 1\\n            }\\n        }\\n        \\n        if maxFrequency > toSwap/2 {\\n            return -1\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTotalCost(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        var ans = 0\\n        var freq = [Int: Int]()\\n        var maxFrequency = 0\\n        var maxFrequencyValue = 0\\n        var toSwap = 0\\n        \\n        for i in 0..<n {\\n            if nums1[i] == nums2[i] {\\n                freq[nums1[i], default: 0] += 1\\n                if freq[nums1[i]]! > maxFrequency {\\n                    maxFrequencyValue = nums1[i]\\n                }\\n                maxFrequency = max(maxFrequency, freq[nums1[i]]!)\\n                toSwap += 1\\n                ans += i\\n            }\\n        }\\n        \\n        for i in 0..<n {\\n            if maxFrequency > toSwap/2 && nums1[i] != nums2[i] && nums1[i] != maxFrequencyValue && nums2[i] != maxFrequencyValue {\\n                ans += i\\n                toSwap += 1\\n            }\\n        }\\n        \\n        if maxFrequency > toSwap/2 {\\n            return -1\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958259,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td = Counter(nums2)\\n\\t\\t\\tn = len(nums1)\\n\\t\\t\\th = n//2\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>h:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\td = defaultdict(int)\\n\\t\\t\\tans = 0\\n\\t\\t\\tcnt =0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif nums1[i]==nums2[i]:\\n\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\t\\td[nums1[i]]+=1\\n\\t\\t\\tval =0\\n\\t\\t\\tmx =0\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>mx:\\n\\t\\t\\t\\t\\tmx =j\\n\\t\\t\\t\\t\\tval = i\\n\\t\\t\\tif mx+mx>cnt:\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tif nums1[i]!=nums2[i] and nums1[i]!=val and nums2[i]!=val and mx+mx>cnt:\\n\\t\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\treturn ans\\n\\t\\t#We are doing mx+mx because lets suppose we have 3 - 3 and 4-5 so total 8 elements which are same so we can take three of 3 and three of 4 to make swap and then we are left with 3 more elements of 4 which we have to swap with any values which is not 4.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td = Counter(nums2)\\n\\t\\t\\tn = len(nums1)\\n\\t\\t\\th = n//2\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>h:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\td = defaultdict(int)\\n\\t\\t\\tans = 0\\n\\t\\t\\tcnt =0\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tif nums1[i]==nums2[i]:\\n\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\t\\t\\td[nums1[i]]+=1\\n\\t\\t\\tval =0\\n\\t\\t\\tmx =0\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>mx:\\n\\t\\t\\t\\t\\tmx =j\\n\\t\\t\\t\\t\\tval = i\\n\\t\\t\\tif mx+mx>cnt:\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tif nums1[i]!=nums2[i] and nums1[i]!=val and nums2[i]!=val and mx+mx>cnt:\\n\\t\\t\\t\\t\\t\\tans+=i\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\t\\t\\treturn ans\\n\\t\\t#We are doing mx+mx because lets suppose we have 3 - 3 and 4-5 so total 8 elements which are same so we can take three of 3 and three of 4 to make swap and then we are left with 3 more elements of 4 which we have to swap with any values which is not 4.",
                "codeTag": "Java"
            },
            {
                "id": 2924968,
                "title": "best-kotlin-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun minimumTotalCost(nums1: IntArray, nums2: IntArray): Long {\\n        var cost: Long = 0\\n        val count = IntArray(nums1.size + 1)\\n        var sum = 0\\n        for (i in nums1.indices) {\\n            if (nums1[i] == nums2[i]) {\\n                count[nums1[i]]++\\n                sum++\\n                cost += i.toLong()\\n            }\\n        }\\n        var rem = -1\\n        var freq = 0\\n        for (i in 0..nums1.size) {\\n            if (count[i] > (sum / 2)) {\\n                rem = i\\n                freq = count[i] - (sum - count[i])\\n                break\\n            }\\n        }\\n        if (rem == -1) {\\n            return cost\\n        }\\n        for (i in nums1.indices) {\\n            if ((nums1[i] != nums2[i]) && (rem != nums2[i]) && (rem != nums1[i])) {\\n                cost += i.toLong()\\n                freq--\\n            }\\n            if (freq == 0) {\\n                break\\n            }\\n        }\\n        return if (freq != 0) -1 else cost\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minimumTotalCost(nums1: IntArray, nums2: IntArray): Long {\\n        var cost: Long = 0\\n        val count = IntArray(nums1.size + 1)\\n        var sum = 0\\n        for (i in nums1.indices) {\\n            if (nums1[i] == nums2[i]) {\\n                count[nums1[i]]++\\n                sum++\\n                cost += i.toLong()\\n            }\\n        }\\n        var rem = -1\\n        var freq = 0\\n        for (i in 0..nums1.size) {\\n            if (count[i] > (sum / 2)) {\\n                rem = i\\n                freq = count[i] - (sum - count[i])\\n                break\\n            }\\n        }\\n        if (rem == -1) {\\n            return cost\\n        }\\n        for (i in nums1.indices) {\\n            if ((nums1[i] != nums2[i]) && (rem != nums2[i]) && (rem != nums1[i])) {\\n                cost += i.toLong()\\n                freq--\\n            }\\n            if (freq == 0) {\\n                break\\n            }\\n        }\\n        return if (freq != 0) -1 else cost\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923907,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_total_cost(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {\\n        let n = nums1.len();\\n        let mut res = 0;\\n        let mut d = std::collections::HashMap::new();\\n        let mut t = 0;\\n        let mut most = 0;\\n        let mut v = 0;\\n        for i in 0..n {\\n            if nums1[i] == nums2[i] {\\n                res += i as i64;\\n                t += 1;\\n                *d.entry(nums1[i]).or_insert(0) += 1;\\n                if *d.get(&nums1[i]).unwrap() > most {\\n                    most = *d.get(&nums1[i]).unwrap();\\n                    v = nums1[i];\\n                }\\n            }\\n        }\\n        if 2 * most <= t {\\n            return res;\\n        }\\n        let mut k = 2 * most - t;\\n        for i in 0..n {\\n            if nums1[i] != nums2[i] && nums1[i] != v && nums2[i] != v {\\n                res += i as i64;\\n                k -= 1;\\n            }\\n            if k == 0 {\\n                return res;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_total_cost(nums1: Vec<i32>, nums2: Vec<i32>) -> i64 {\\n        let n = nums1.len();\\n        let mut res = 0;\\n        let mut d = std::collections::HashMap::new();\\n        let mut t = 0;\\n        let mut most = 0;\\n        let mut v = 0;\\n        for i in 0..n {\\n            if nums1[i] == nums2[i] {\\n                res += i as i64;\\n                t += 1;\\n                *d.entry(nums1[i]).or_insert(0) += 1;\\n                if *d.get(&nums1[i]).unwrap() > most {\\n                    most = *d.get(&nums1[i]).unwrap();\\n                    v = nums1[i];\\n                }\\n            }\\n        }\\n        if 2 * most <= t {\\n            return res;\\n        }\\n        let mut k = 2 * most - t;\\n        for i in 0..n {\\n            if nums1[i] != nums2[i] && nums1[i] != v && nums2[i] != v {\\n                res += i as i64;\\n                k -= 1;\\n            }\\n            if k == 0 {\\n                return res;\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1719758,
                "content": [
                    {
                        "username": "mbeceanu",
                        "content": "I had a bad experience with this question. I submitted a solution during the contest and it *was accepted*. Then, about an hour afterward, I realized that even though it was accepted, the solution was wrong.\\nI corrected it and posted the correct version, then also submitted a test case to show that more test cases are needed.\\nWhat happened next? The test case was ignored, but the original solution  was regraded, some days later. I then lost the points and fell in the rankings.\\nHad I been told during the contest that my solution was wrong, I very likely could have fixed it. As it is, it took me more than an hour to realize that it was wrong. Fixing it took less than 10 minutes.\\nIt is unfair to say that the solution is *correct*, which made me stop working, and then silently regrade it and take my points away. The solution was only slightly wrong: it passed all the official testing cases and *was accepted*. If not for the misleading acceptance message, I had a real chance of fixing it during the time left.\\nI guess this happens often (before I didn\\'t understand why ratings keep changing several days after the contest), but it is my first time."
                    },
                    {
                        "username": "jesstoh",
                        "content": "Feel sorry that it happened to you. It happened to me too, LC didn\\'t even bother to inform affected contestants, I found out when I checked my ranking after few days. When I enquired more, they just pointed to the rules that they can rejudge contest. I would appreciate if they sent out the email  to inform and apologised for not testing the test cases  thoroughly prior to contest. They should at least waive the rating of this contest for negatively impacted contestant if contestant requested to do so."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Tough question. It\\'s harder than most hard problems"
                    },
                    {
                        "username": "PaulStSmith",
                        "content": "My solution can del with 85 out of 87 cases.\\n\\nI\\'m stuck in trying to solve this one:\\na = [1,2,2,3] and b = [1,2,2,1]\\n\\nThe expected result is 6, but my solution keeps spewing out 3.\\n\\nI don\\'t see what\\'s wrong with mine.\\n\\nAnyone has any clue on how to crack the above test?\\n"
                    },
                    {
                        "username": "mbeceanu",
                        "content": "Clearly 3 should not work, because there are at least two spots that need to be switched, position 1 and position 2, and you cannot switch them with each other, because the values are the same.\nAlso, if you try to only involve the first spot, position 0, then you still cannot do it. Same if you only involve the last spot. It turns out that the solution must involve all four spots, so the minimum cost is 0+1+2+3=6."
                    }
                ]
            },
            {
                "id": 1712557,
                "content": [
                    {
                        "username": "mbeceanu",
                        "content": "I had a bad experience with this question. I submitted a solution during the contest and it *was accepted*. Then, about an hour afterward, I realized that even though it was accepted, the solution was wrong.\\nI corrected it and posted the correct version, then also submitted a test case to show that more test cases are needed.\\nWhat happened next? The test case was ignored, but the original solution  was regraded, some days later. I then lost the points and fell in the rankings.\\nHad I been told during the contest that my solution was wrong, I very likely could have fixed it. As it is, it took me more than an hour to realize that it was wrong. Fixing it took less than 10 minutes.\\nIt is unfair to say that the solution is *correct*, which made me stop working, and then silently regrade it and take my points away. The solution was only slightly wrong: it passed all the official testing cases and *was accepted*. If not for the misleading acceptance message, I had a real chance of fixing it during the time left.\\nI guess this happens often (before I didn\\'t understand why ratings keep changing several days after the contest), but it is my first time."
                    },
                    {
                        "username": "jesstoh",
                        "content": "Feel sorry that it happened to you. It happened to me too, LC didn\\'t even bother to inform affected contestants, I found out when I checked my ranking after few days. When I enquired more, they just pointed to the rules that they can rejudge contest. I would appreciate if they sent out the email  to inform and apologised for not testing the test cases  thoroughly prior to contest. They should at least waive the rating of this contest for negatively impacted contestant if contestant requested to do so."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Tough question. It\\'s harder than most hard problems"
                    },
                    {
                        "username": "PaulStSmith",
                        "content": "My solution can del with 85 out of 87 cases.\\n\\nI\\'m stuck in trying to solve this one:\\na = [1,2,2,3] and b = [1,2,2,1]\\n\\nThe expected result is 6, but my solution keeps spewing out 3.\\n\\nI don\\'t see what\\'s wrong with mine.\\n\\nAnyone has any clue on how to crack the above test?\\n"
                    },
                    {
                        "username": "mbeceanu",
                        "content": "Clearly 3 should not work, because there are at least two spots that need to be switched, position 1 and position 2, and you cannot switch them with each other, because the values are the same.\nAlso, if you try to only involve the first spot, position 0, then you still cannot do it. Same if you only involve the last spot. It turns out that the solution must involve all four spots, so the minimum cost is 0+1+2+3=6."
                    }
                ]
            },
            {
                "id": 1713194,
                "content": [
                    {
                        "username": "mbeceanu",
                        "content": "I had a bad experience with this question. I submitted a solution during the contest and it *was accepted*. Then, about an hour afterward, I realized that even though it was accepted, the solution was wrong.\\nI corrected it and posted the correct version, then also submitted a test case to show that more test cases are needed.\\nWhat happened next? The test case was ignored, but the original solution  was regraded, some days later. I then lost the points and fell in the rankings.\\nHad I been told during the contest that my solution was wrong, I very likely could have fixed it. As it is, it took me more than an hour to realize that it was wrong. Fixing it took less than 10 minutes.\\nIt is unfair to say that the solution is *correct*, which made me stop working, and then silently regrade it and take my points away. The solution was only slightly wrong: it passed all the official testing cases and *was accepted*. If not for the misleading acceptance message, I had a real chance of fixing it during the time left.\\nI guess this happens often (before I didn\\'t understand why ratings keep changing several days after the contest), but it is my first time."
                    },
                    {
                        "username": "jesstoh",
                        "content": "Feel sorry that it happened to you. It happened to me too, LC didn\\'t even bother to inform affected contestants, I found out when I checked my ranking after few days. When I enquired more, they just pointed to the rules that they can rejudge contest. I would appreciate if they sent out the email  to inform and apologised for not testing the test cases  thoroughly prior to contest. They should at least waive the rating of this contest for negatively impacted contestant if contestant requested to do so."
                    },
                    {
                        "username": "saam_neu",
                        "content": "Tough question. It\\'s harder than most hard problems"
                    },
                    {
                        "username": "PaulStSmith",
                        "content": "My solution can del with 85 out of 87 cases.\\n\\nI\\'m stuck in trying to solve this one:\\na = [1,2,2,3] and b = [1,2,2,1]\\n\\nThe expected result is 6, but my solution keeps spewing out 3.\\n\\nI don\\'t see what\\'s wrong with mine.\\n\\nAnyone has any clue on how to crack the above test?\\n"
                    },
                    {
                        "username": "mbeceanu",
                        "content": "Clearly 3 should not work, because there are at least two spots that need to be switched, position 1 and position 2, and you cannot switch them with each other, because the values are the same.\nAlso, if you try to only involve the first spot, position 0, then you still cannot do it. Same if you only involve the last spot. It turns out that the solution must involve all four spots, so the minimum cost is 0+1+2+3=6."
                    }
                ]
            }
        ]
    }
]