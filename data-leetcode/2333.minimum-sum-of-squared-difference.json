[
    {
        "title": "Minimum Sum of Squared Difference",
        "question_content": "You are given two positive 0-indexed integer arrays nums1 and nums2, both of length n.\nThe sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])2 for each 0 <= i < n.\nYou are also given two positive integers k1 and k2. You can modify any of the elements of nums1 by +1 or -1 at most k1 times. Similarly, you can modify any of the elements of nums2 by +1 or -1 at most k2 times.\nReturn the minimum sum of squared difference after modifying array nums1 at most k1 times and modifying array nums2 at most k2 times.\nNote: You are allowed to modify the array elements to become negative integers.\n&nbsp;\nExample 1:\n\nInput: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0\nOutput: 579\nExplanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. \nThe sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2&nbsp;= 579.\n\nExample 2:\n\nInput: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1\nOutput: 43\nExplanation: One way to obtain the minimum sum of square difference is: \n- Increase nums1[0] once.\n- Increase nums2[2] once.\nThe minimum of the sum of square difference will be: \n(2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2&nbsp;= 43.\nNote that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t1 <= n <= 105\n\t0 <= nums1[i], nums2[i] <= 105\n\t0 <= k1, k2 <= 109",
        "solutions": [
            {
                "id": 2259191,
                "title": "bucket-sort-of-diff-o-n",
                "content": "We only need to collect all of diff.\\nThen greedy decrease max diff with some k1+k2.\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<int> diff(n);\\n        for(int i = 0; i<n; ++i) {\\n            diff[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        int M = *max_element(diff.begin(), diff.end());\\n        vector<int> bucket(M+1);\\n        for(int i = 0 ; i<n; ++i) {\\n            bucket[diff[i]]++;\\n        }\\n        int k = k1 + k2;\\n        for(int i = M; i > 0; --i) {\\n            if(bucket[i] > 0) {\\n                int minus = min(bucket[i], k);\\n                bucket[i] -= minus;\\n                bucket[i-1] += minus;\\n                k -= minus;\\n            }\\n        }\\n        long long ans = 0;\\n        for(long long i = M; i > 0; --i) {\\n            ans += bucket[i]*i*i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<int> diff(n);\\n        for(int i = 0; i<n; ++i) {\\n            diff[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        int M = *max_element(diff.begin(), diff.end());\\n        vector<int> bucket(M+1);\\n        for(int i = 0 ; i<n; ++i) {\\n            bucket[diff[i]]++;\\n        }\\n        int k = k1 + k2;\\n        for(int i = M; i > 0; --i) {\\n            if(bucket[i] > 0) {\\n                int minus = min(bucket[i], k);\\n                bucket[i] -= minus;\\n                bucket[i-1] += minus;\\n                k -= minus;\\n            }\\n        }\\n        long long ans = 0;\\n        for(long long i = M; i > 0; --i) {\\n            ans += bucket[i]*i*i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259220,
                "title": "hashmap-priority-queue-o-nlogn",
                "content": "Best strategy is to decrease the highest difference every time but the if we try to decrease every element one by one it will give TLE rather than that lets store the count of every difference as well, and then decrease the numbers. This way our k1 and k2 will not be decreased by one every time but by the count of the biggest difference\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        unordered_map<ll, ll> mp;\\n        for(int i = 0; i < n; ++i) {\\n            mp[abs(nums1[i] - nums2[i])]++;\\n        }\\n        long long tot = k1 + k2;\\n        \\n        priority_queue<array<ll, 2>> pq;\\n        for(auto [x, y]: mp) {\\n            if(x == 0) continue;\\n            pq.push({x, y});\\n        }\\n        \\n        while(!pq.empty() and tot > 0) {\\n            array<ll, 2> v = pq.top();\\n            pq.pop();\\n            \\n            if(pq.size() == 0) {\\n                ll mn = min(tot, v[1]);    \\n                tot -= mn;\\n                v[1] -= mn;\\n                if(v[0] - 1 > 0) pq.push({v[0] - 1, mn});\\n                if(v[1] > 0) pq.push(v);\\n            } else {\\n                ll mn = min(tot, v[1]);\\n                tot -= mn;\\n                v[1] -= mn;\\n                if(v[1] > 0) pq.push(v);\\n                \\n                if(pq.top()[0] == v[0] - 1) {\\n                    array<ll, 2> v1 = pq.top();\\n                    pq.pop();\\n                    v1[1] += mn;\\n                    pq.push(v1);\\n                } else if(v[0] - 1 > 0) {\\n                    pq.push({v[0] - 1, mn});\\n                }\\n            }\\n        }\\n        \\n        ll ans = 0;\\n        while(!pq.empty()) {\\n            array<ll, 2> v = pq.top();\\n            ans += v[0] * v[0] * v[1];\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        unordered_map<ll, ll> mp;\\n        for(int i = 0; i < n; ++i) {\\n            mp[abs(nums1[i] - nums2[i])]++;\\n        }\\n        long long tot = k1 + k2;\\n        \\n        priority_queue<array<ll, 2>> pq;\\n        for(auto [x, y]: mp) {\\n            if(x == 0) continue;\\n            pq.push({x, y});\\n        }\\n        \\n        while(!pq.empty() and tot > 0) {\\n            array<ll, 2> v = pq.top();\\n            pq.pop();\\n            \\n            if(pq.size() == 0) {\\n                ll mn = min(tot, v[1]);    \\n                tot -= mn;\\n                v[1] -= mn;\\n                if(v[0] - 1 > 0) pq.push({v[0] - 1, mn});\\n                if(v[1] > 0) pq.push(v);\\n            } else {\\n                ll mn = min(tot, v[1]);\\n                tot -= mn;\\n                v[1] -= mn;\\n                if(v[1] > 0) pq.push(v);\\n                \\n                if(pq.top()[0] == v[0] - 1) {\\n                    array<ll, 2> v1 = pq.top();\\n                    pq.pop();\\n                    v1[1] += mn;\\n                    pq.push(v1);\\n                } else if(v[0] - 1 > 0) {\\n                    pq.push({v[0] - 1, mn});\\n                }\\n            }\\n        }\\n        \\n        ll ans = 0;\\n        while(!pq.empty()) {\\n            array<ll, 2> v = pq.top();\\n            ans += v[0] * v[0] * v[1];\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260164,
                "title": "java-16ms-theory-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Count the differences between each nums1[i] and nums2[i] and store them into an int[100_001], as nums is between 0 and 100_000.\\n        2. Let\\'s look at the example of [1,4,10,12], [4,8,6,7]. k1= 1, k2 =1\\n             Looking at the pairs of abs diff we have 3,4,4,5.\\n             So a total of 16 diff points with k = 2.\\n             As we observe, if we use the k operations on the first pair, we can decrease 3 to 1.\\n             but this would only help with 3^2 (9) -> 1. So we decrease the totam sum diff by 8.\\n             However, if we operate on the diff of 5, this would have much more impact.\\n             5 - 1 => (4^2)25 - 16 . so we save 9 points by using 1 k\\n             5 - 2 => (3^2) 25 - 9. So we save 16 points.\\n         3. As we can see, we need to operate on the highest diff, lowering them.\\n         4. As we have counted them on step #1, we would have an array like this\\n           [0,0,0,1,2,1] : 1 diff of 3, 2 of 4 and 1 of 5.\\n         5. While k is > 0 (k1 + k2), start from the back (highest) and decrease it one group at a time.\\n           So make all 5 diffs into 4 diff, only if their cardinal is <= k. If it\\'s greater than k, we can only\\n           lower k diff to diff -1.\\n           So [0,0,0,1,2,1] and k = 2 => [0,0,0,1,3,0] and k =1\\n           We have 3 diff of 4 and just k =1 so we can turn one 4 into a 3.\\n           => [0,0,0,2,2,0]. Thus. the diff becomes 2 of 3 and 2 of 4.\\n    */\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long minSumSquare = 0;\\n        int[] diffs = new int[100_001];\\n        long totalDiff = 0;\\n        long kSum = k1 + k2;\\n        int currentDiff;\\n        int maxDiff = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            // get current diff.\\n            currentDiff = Math.abs(nums1[i] - nums2[i]);\\n            // if current diff > 0, count/store it. If not,then ignore it.\\n            if (currentDiff > 0) {\\n                totalDiff += currentDiff;\\n                diffs[currentDiff]++;\\n                maxDiff = Math.max(maxDiff, currentDiff);\\n            }\\n        }\\n        // if kSum (k1 + k2) < totalDifferences, it means we can make all numbers/differences 0s\\n        if (totalDiff <= kSum) {\\n            return 0;\\n        }\\n        // starting from the back, from the highest difference, lower that group one by one to the previous group.\\n         // we need to make all n diffs to n-1, then n-2, as long as kSum allows it.\\n        for (int i = maxDiff; i> 0 && kSum > 0; i--) {\\n            if (diffs[i] > 0) {\\n                // if current group has more differences than the totalK, we can only move k of them to the lower level.\\n                if (diffs[i] >= kSum) {\\n                    diffs[i] -= kSum;\\n                    diffs[i-1] += kSum;\\n                    kSum = 0;\\n                } else {\\n                    // else, we can make this whole group one level lower.\\n                    diffs[i-1] += diffs[i];\\n                    kSum -= diffs[i];\\n                    diffs[i] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= maxDiff; i++) {\\n            if (diffs[i] > 0) {\\n                minSumSquare += (long) (Math.pow((long)i, 2)) * diffs[i];\\n            }\\n        }\\n        return minSumSquare;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Count the differences between each nums1[i] and nums2[i] and store them into an int[100_001], as nums is between 0 and 100_000.\\n        2. Let\\'s look at the example of [1,4,10,12], [4,8,6,7]. k1= 1, k2 =1\\n             Looking at the pairs of abs diff we have 3,4,4,5.\\n             So a total of 16 diff points with k = 2.\\n             As we observe, if we use the k operations on the first pair, we can decrease 3 to 1.\\n             but this would only help with 3^2 (9) -> 1. So we decrease the totam sum diff by 8.\\n             However, if we operate on the diff of 5, this would have much more impact.\\n             5 - 1 => (4^2)25 - 16 . so we save 9 points by using 1 k\\n             5 - 2 => (3^2) 25 - 9. So we save 16 points.\\n         3. As we can see, we need to operate on the highest diff, lowering them.\\n         4. As we have counted them on step #1, we would have an array like this\\n           [0,0,0,1,2,1] : 1 diff of 3, 2 of 4 and 1 of 5.\\n         5. While k is > 0 (k1 + k2), start from the back (highest) and decrease it one group at a time.\\n           So make all 5 diffs into 4 diff, only if their cardinal is <= k. If it\\'s greater than k, we can only\\n           lower k diff to diff -1.\\n           So [0,0,0,1,2,1] and k = 2 => [0,0,0,1,3,0] and k =1\\n           We have 3 diff of 4 and just k =1 so we can turn one 4 into a 3.\\n           => [0,0,0,2,2,0]. Thus. the diff becomes 2 of 3 and 2 of 4.\\n    */\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long minSumSquare = 0;\\n        int[] diffs = new int[100_001];\\n        long totalDiff = 0;\\n        long kSum = k1 + k2;\\n        int currentDiff;\\n        int maxDiff = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            // get current diff.\\n            currentDiff = Math.abs(nums1[i] - nums2[i]);\\n            // if current diff > 0, count/store it. If not,then ignore it.\\n            if (currentDiff > 0) {\\n                totalDiff += currentDiff;\\n                diffs[currentDiff]++;\\n                maxDiff = Math.max(maxDiff, currentDiff);\\n            }\\n        }\\n        // if kSum (k1 + k2) < totalDifferences, it means we can make all numbers/differences 0s\\n        if (totalDiff <= kSum) {\\n            return 0;\\n        }\\n        // starting from the back, from the highest difference, lower that group one by one to the previous group.\\n         // we need to make all n diffs to n-1, then n-2, as long as kSum allows it.\\n        for (int i = maxDiff; i> 0 && kSum > 0; i--) {\\n            if (diffs[i] > 0) {\\n                // if current group has more differences than the totalK, we can only move k of them to the lower level.\\n                if (diffs[i] >= kSum) {\\n                    diffs[i] -= kSum;\\n                    diffs[i-1] += kSum;\\n                    kSum = 0;\\n                } else {\\n                    // else, we can make this whole group one level lower.\\n                    diffs[i-1] += diffs[i];\\n                    kSum -= diffs[i];\\n                    diffs[i] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= maxDiff; i++) {\\n            if (diffs[i] > 0) {\\n                minSumSquare += (long) (Math.pow((long)i, 2)) * diffs[i];\\n            }\\n        }\\n        return minSumSquare;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259394,
                "title": "c-easy-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int> difference( (int) 1e5+1);\\n        \\n        for(int i = 0; i<nums1.size();i++)\\n        {\\n            difference[abs(nums1[i] - nums2[i])]++;\\n        }\\n        \\n        int value = 0, left = k1+k2;\\n        int acc = 0;\\n        \\n        for(int i = (int) 1e5; i>=0; i--)\\n        {\\n            acc = difference[i];\\n            if(acc <= left)\\n            {\\n                if(i<=1)\\n                    return 0;\\n                \\n                difference[i-1] += difference[i];\\n                difference[i]=0;\\n                left -= acc;\\n            }\\n            else\\n            {\\n                if(i==0)\\n                    return 0;\\n                difference[i] -= left;\\n                difference[i-1] += left;\\n                break;\\n            }\\n        }\\n        long long answer = 0;\\n        \\n        for(int i = 1ll; i<=1e5; i++)\\n        {\\n            answer += (long long)difference[i] * ((long long)i*i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int> difference( (int) 1e5+1);\\n        \\n        for(int i = 0; i<nums1.size();i++)\\n        {\\n            difference[abs(nums1[i] - nums2[i])]++;\\n        }\\n        \\n        int value = 0, left = k1+k2;\\n        int acc = 0;\\n        \\n        for(int i = (int) 1e5; i>=0; i--)\\n        {\\n            acc = difference[i];\\n            if(acc <= left)\\n            {\\n                if(i<=1)\\n                    return 0;\\n                \\n                difference[i-1] += difference[i];\\n                difference[i]=0;\\n                left -= acc;\\n            }\\n            else\\n            {\\n                if(i==0)\\n                    return 0;\\n                difference[i] -= left;\\n                difference[i-1] += left;\\n                break;\\n            }\\n        }\\n        long long answer = 0;\\n        \\n        for(int i = 1ll; i<=1e5; i++)\\n        {\\n            answer += (long long)difference[i] * ((long long)i*i);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259475,
                "title": "python-heap-o-nlogn",
                "content": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        heap = [ -abs(x-y) for x, y in zip(nums1, nums2)]\\n        s = -sum(heap)\\n        if k1+k2 >= s: return 0\\n        delta = k1 + k2\\n        heapify(heap)\\n        n = len(nums1)\\n        while delta > 0:\\n            d = -heappop(heap)\\n            gap = max(delta//n, 1) if heap else delta\\n            d -= gap\\n            heappush(heap, -d)\\n            delta -= gap\\n        return sum(pow(e,2) for e in heap)\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        heap = [ -abs(x-y) for x, y in zip(nums1, nums2)]\\n        s = -sum(heap)\\n        if k1+k2 >= s: return 0\\n        delta = k1 + k2\\n        heapify(heap)\\n        n = len(nums1)\\n        while delta > 0:\\n            d = -heappop(heap)\\n            gap = max(delta//n, 1) if heap else delta\\n            d -= gap\\n            heappush(heap, -d)\\n            delta -= gap\\n        return sum(pow(e,2) for e in heap)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2265219,
                "title": "binary-search",
                "content": "Such a deceptive problem.\\n\\nGotchas:\\n- We can perform up to `k1 + k2` operations, and it does not matter on which array.\\n\\t- The note in the problem description (you are allowed to modify the array elements to become negative integers) gives it away.\\n- Decrementing the largest absolute difference gives the biggest bang for a buck (or operation). \\n\\t- This is because we square the difference (can be easily proven). \\n\\nTherefore, our job is to reduce maximum difference with `k1 + k2` operations. Reducing differences one-by-one (e.g. by using a priority queue) is too time consuming.\\n\\nWe can find the minimum of the maximum difference using binary search. We count how many operations we need to reduce differences to not exceed the cap, and find the smallest cap that requires `k1 + k2` operations, or less.\\n\\nThis \"or less\" above leads to the final piece. We track how many `extra` operations we can perform after reducing all differences. That means that we can reduce `extra` capped differences by `1`.\\n\\nNote that it always better to reduce two largest differences by `1`, then one of them by `2`: `(n - 2) * (n - 2) + n * n > (n - 1) * (n - 1) + (n - 1) * (n - 1)`.\\n\\n**C++**\\n```cpp\\nlong long minSumSquareDiff(vector<int>& n1, vector<int>& n2, int k1, int k2) {\\n    for (int i = 0; i < n1.size(); ++i) \\n        n1[i] = abs(n1[i] - n2[i]);\\n    long long l = 0, r = 100000, extra_ops = 0, res = 0;\\n    while (l < r) {\\n        long long m = (l + r) / 2, ops = 0;\\n        for (auto n : n1)\\n            ops += max(0LL, n - m);\\n        if (ops > k1 + k2)\\n            l = m + 1;\\n        else {\\n            r = m;\\n            extra_ops = k1 + k2 - ops;\\n        }\\n    }\\n    for (int n : n1) {\\n        long long val = n < l ? n : max(0LL, l - (--extra_ops >= 0 ? 1 : 0));\\n        res += val * val;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minSumSquareDiff(vector<int>& n1, vector<int>& n2, int k1, int k2) {\\n    for (int i = 0; i < n1.size(); ++i) \\n        n1[i] = abs(n1[i] - n2[i]);\\n    long long l = 0, r = 100000, extra_ops = 0, res = 0;\\n    while (l < r) {\\n        long long m = (l + r) / 2, ops = 0;\\n        for (auto n : n1)\\n            ops += max(0LL, n - m);\\n        if (ops > k1 + k2)\\n            l = m + 1;\\n        else {\\n            r = m;\\n            extra_ops = k1 + k2 - ops;\\n        }\\n    }\\n    for (int n : n1) {\\n        long long val = n < l ? n : max(0LL, l - (--extra_ops >= 0 ? 1 : 0));\\n        res += val * val;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259287,
                "title": "c-binary-search-and-priority-queue",
                "content": "upvote if it helps\\n```\\nbool ispossible(vector<int>&v, int cut, long long &k){\\n        long long total = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            if(v[i] > cut)\\n                total += v[i] - cut;\\n        }\\n        return total <= k;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<int>v(n);\\n        for(int i = 0; i < n; i++){\\n            v[i] = abs(nums1[i] - nums2[i]);\\n        }\\n\\t\\t/*\\n\\t\\tusing binary search we get the maximum value of abs(nums1[i] - nums2[i]) , which is possible \\n\\t\\tto reduce from all the abs differences above that and still k will be >= 0\\n\\t\\t*/\\n        int low = 0;\\n        int high = *max_element(v.begin(), v.end());\\n        int ans = 0; \\n        long long k = k1+k2;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(ispossible(v, mid, k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n\\t\\t//reducing all the abs(nums1[i] - nums2[i]) and also reducing k by that much amount\\n        long long res = 0;\\n        for(int i = 0; i < n; i++){\\n            if(v[i] > ans && k > 0){\\n                int dif = v[i] - ans;\\n                k -= dif;\\n                v[i] -= dif;\\n            }\\n        }\\n        priority_queue<int>pq;\\n        for(int i = 0; i < n; i++){\\n            pq.push(v[i]);\\n        }\\n\\t\\t//now removing rest of the extra k\\'s from the array to get optimal res\\n        while(k > 0 && pq.top() > 0){\\n            int l = pq.top();\\n            pq.pop();\\n            l -= 1;\\n            pq.push(l);\\n            k--;\\n        }\\n\\t\\t//if the maximum difference is 0, then rest of the differences will also be 0, so return 0\\n        if(pq.top() == 0)\\n            return 0;\\n\\t\\t//else, while top element is > 0, poping one by one and adding it to the res\\n        while(!pq.empty() && pq.top() > 0){\\n            res += pq.top()* 1ll * pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nbool ispossible(vector<int>&v, int cut, long long &k){\\n        long long total = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            if(v[i] > cut)\\n                total += v[i] - cut;\\n        }\\n        return total <= k;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<int>v(n);\\n        for(int i = 0; i < n; i++){\\n            v[i] = abs(nums1[i] - nums2[i]);\\n        }\\n\\t\\t/*\\n\\t\\tusing binary search we get the maximum value of abs(nums1[i] - nums2[i]) , which is possible \\n\\t\\tto reduce from all the abs differences above that and still k will be >= 0\\n\\t\\t*/\\n        int low = 0;\\n        int high = *max_element(v.begin(), v.end());\\n        int ans = 0; \\n        long long k = k1+k2;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(ispossible(v, mid, k)){\\n                ans = mid;\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n\\t\\t//reducing all the abs(nums1[i] - nums2[i]) and also reducing k by that much amount\\n        long long res = 0;\\n        for(int i = 0; i < n; i++){\\n            if(v[i] > ans && k > 0){\\n                int dif = v[i] - ans;\\n                k -= dif;\\n                v[i] -= dif;\\n            }\\n        }\\n        priority_queue<int>pq;\\n        for(int i = 0; i < n; i++){\\n            pq.push(v[i]);\\n        }\\n\\t\\t//now removing rest of the extra k\\'s from the array to get optimal res\\n        while(k > 0 && pq.top() > 0){\\n            int l = pq.top();\\n            pq.pop();\\n            l -= 1;\\n            pq.push(l);\\n            k--;\\n        }\\n\\t\\t//if the maximum difference is 0, then rest of the differences will also be 0, so return 0\\n        if(pq.top() == 0)\\n            return 0;\\n\\t\\t//else, while top element is > 0, poping one by one and adding it to the res\\n        while(!pq.empty() && pq.top() > 0){\\n            res += pq.top()* 1ll * pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259980,
                "title": "c-buckets-greedy-with-proof-detailed-explanation-o-n",
                "content": "1. compute `diffs[i]`, the absolute value of difference between `nums1[i]` and `nums2[i]`.\\n2. The sum of squared difference is the sum of `diff[i] * diff[i]` for each `i`.\\n3. In one operation, we could increase or decrease a number in `nums1[i]` or `nums2[i]` by 1.\\n4. Therefore, in one operation, the corresponding `diff[i]` could only be decreased or increased by 1.\\n5. To get minimum sum of squared difference, we have to decrease `diff[i]` in every opreation. \\n6. We could prove that it is optimal to decrease the largest `diff[i]` by 1:\\n\\t  - let `diff[i]` be `x`\\n\\t  - `x^2 - (x - 1)^2` is the difference of the sum of squared differences after `diff[i]` decreased by 1.\\n\\t  - `x^2 - (x - 1)^2` == `x^2 - x^2 + 2x - 2`\\n\\t  -  `x^2 - (x - 1)^2` == `2x - 2`\\n\\t  - Therefore, the larger `x` is, the larger we could decrease the difference.\\n6. Notice that the constraint `0 <= nums1[i], nums2[i] <= 10^5`. This constraint indicates that `0 <= diff[i] <= 10^5`. We could use buckets to contain the frequence of each `diff[i]`.\\n7. Starting from the largest `diff[i]`, decrease as many `buckets[diff[i]]` as possible in one step.\\n8. Those `diff[i]`s that got decreased in their current bucket `bucket[diff[i]]` will be put into the adjacent bucket `bucket[diff[i] - 1]`\\n9. Do this until `k1 + k2` is exhausted or all `bucket[j]`, `0 < j <= 10^5` become `0`\\n10. Return the sum of squared differences. \\n\\n```cpp\\nclass Solution {\\npublic:\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    auto diffs = std::vector<int>(nums1.size());\\n    auto maxDiff = INT_MIN;\\n    for(int i = 0; i < nums1.size(); ++i) {\\n      diffs[i] = std::abs(nums1[i] - nums2[i]);\\n      maxDiff = std::max(diffs[i], maxDiff);\\n    }\\n    // 0 <= nums1[i], nums2[i] <= 10^5 \\n    // 0 <= diffs[i] <= 10^5.\\n    auto buckets = std::vector<int>(maxDiff + 1, 0);\\n    for(auto diff : diffs) {\\n      ++buckets[diff];\\n    }\\n    \\n    auto k = k1 + k2;\\n    auto curBucket = maxDiff;\\n    while(k && curBucket >= 0) {\\n      const auto n = buckets[curBucket];\\n      const auto decreaseN = std::min(n, k);\\n      buckets[curBucket] -= decreaseN;\\n      if(curBucket - 1 >= 0) {\\n        buckets[curBucket - 1] += decreaseN;\\n      }\\n      k -= decreaseN;\\n      if(buckets[curBucket] == 0) {\\n        --curBucket;\\n      }\\n    }\\n    \\n    auto res = 0ll;\\n    for(auto i = 0ll; i < buckets.size(); ++i) {\\n      res += buckets[i] * i * i;\\n    }\\n    \\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    auto diffs = std::vector<int>(nums1.size());\\n    auto maxDiff = INT_MIN;\\n    for(int i = 0; i < nums1.size(); ++i) {\\n      diffs[i] = std::abs(nums1[i] - nums2[i]);\\n      maxDiff = std::max(diffs[i], maxDiff);\\n    }\\n    // 0 <= nums1[i], nums2[i] <= 10^5 \\n    // 0 <= diffs[i] <= 10^5.\\n    auto buckets = std::vector<int>(maxDiff + 1, 0);\\n    for(auto diff : diffs) {\\n      ++buckets[diff];\\n    }\\n    \\n    auto k = k1 + k2;\\n    auto curBucket = maxDiff;\\n    while(k && curBucket >= 0) {\\n      const auto n = buckets[curBucket];\\n      const auto decreaseN = std::min(n, k);\\n      buckets[curBucket] -= decreaseN;\\n      if(curBucket - 1 >= 0) {\\n        buckets[curBucket - 1] += decreaseN;\\n      }\\n      k -= decreaseN;\\n      if(buckets[curBucket] == 0) {\\n        --curBucket;\\n      }\\n    }\\n    \\n    auto res = 0ll;\\n    for(auto i = 0ll; i < buckets.size(); ++i) {\\n      res += buckets[i] * i * i;\\n    }\\n    \\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259216,
                "title": "python-greedy-idea-counter-sorteddict-or-priority-queue",
                "content": "**Explanation**\\n1. Greedy idea and two cases need to be considered.\\n2. The first case is that we can make all the diff between nums1 and nums2 become 0 if k1 + k2 >= sum(abs(diff)).\\n3. The second case is if k1 + k2 < sum(abs(diff)), we greedily decrease the count of max_diff between nums1 and nums2 until k = k1 + k2 becomes 0.\\n\\n**Solution 1. SortedDict**\\n\\n**For example 2: Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1.**\\nWe get diff = [4, 4, 4, 3], SortedDict({3: 1, 4: 3}), k = k1 + k2 = 2\\nDecreasing the count of max_diff iteratively, the SortedDict becomes:\\nSortedDict({3: 1, 4: 3}), k = 2 \\n-> SortedDict({3: 3, 4: 1}), k = 0\\nresult = 3 * 3^2 + 1 * 4^2 = 43\\n\\n```\\nfrom sortedcontainers import SortedDict\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = []\\n        for num1, num2 in zip(nums1, nums2):\\n            diff.append(abs(num1-num2))\\n        \\n        k = k1 + k2\\n        \\n        count = SortedDict(Counter(diff))\\n        print(diff, count)\\n        \\n        if k - sum(diff) >= 0:\\n            return 0\\n        \\n        while k > 0:\\n            key, value = count.popitem()\\n            if k >= value:\\n                k -= value\\n                count[key - 1] = count.get(key - 1, 0) + value\\n            elif k < value:\\n                count[key] = value - k\\n                count[key - 1] = count.get(key - 1, 0) + k\\n                k = 0\\n                \\n        res = 0\\n        for key, val in count.items():\\n            res += key ** 2 * val\\n            \\n        return res\\n```\\n\\n**Solution 2. Priority queue (Heap)**\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = []\\n        for num1, num2 in zip(nums1, nums2):\\n            diff.append(abs(num1-num2))\\n        \\n        k = k1 + k2\\n        \\n        if k - sum(diff) >= 0:\\n            return 0\\n        \\n        count = Counter(diff)\\n        maxHeap = [[-key, val] for key, val in count.items()]\\n        heapify(maxHeap)\\n\\n        while k:\\n            curDiff, curCount = heappop(maxHeap)\\n            if k >= curCount:\\n                k -= curCount\\n\\t\\t\\t\\t# To reduce the time complexity, we need to merge the count of diff whenever possible.\\n                if maxHeap and curDiff + 1 == maxHeap[0][0]:\\n                    maxHeap[0][1] += curCount\\n                else:\\n                    heappush(maxHeap, [curDiff+1, curCount])\\n            elif k < curCount:\\n                if maxHeap and curDiff + 1 == maxHeap[0][0]:\\n                    maxHeap[0][1] += k\\n                else:\\n                    heappush(maxHeap, [curDiff+1, k])\\n                heappush(maxHeap, [curDiff, curCount - k])\\n                k = 0\\n\\n        res = 0\\n        for curDiff, curCount in maxHeap:\\n            res += curDiff ** 2 * curCount\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedDict\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = []\\n        for num1, num2 in zip(nums1, nums2):\\n            diff.append(abs(num1-num2))\\n        \\n        k = k1 + k2\\n        \\n        count = SortedDict(Counter(diff))\\n        print(diff, count)\\n        \\n        if k - sum(diff) >= 0:\\n            return 0\\n        \\n        while k > 0:\\n            key, value = count.popitem()\\n            if k >= value:\\n                k -= value\\n                count[key - 1] = count.get(key - 1, 0) + value\\n            elif k < value:\\n                count[key] = value - k\\n                count[key - 1] = count.get(key - 1, 0) + k\\n                k = 0\\n                \\n        res = 0\\n        for key, val in count.items():\\n            res += key ** 2 * val\\n            \\n        return res\\n```\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = []\\n        for num1, num2 in zip(nums1, nums2):\\n            diff.append(abs(num1-num2))\\n        \\n        k = k1 + k2\\n        \\n        if k - sum(diff) >= 0:\\n            return 0\\n        \\n        count = Counter(diff)\\n        maxHeap = [[-key, val] for key, val in count.items()]\\n        heapify(maxHeap)\\n\\n        while k:\\n            curDiff, curCount = heappop(maxHeap)\\n            if k >= curCount:\\n                k -= curCount\\n\\t\\t\\t\\t# To reduce the time complexity, we need to merge the count of diff whenever possible.\\n                if maxHeap and curDiff + 1 == maxHeap[0][0]:\\n                    maxHeap[0][1] += curCount\\n                else:\\n                    heappush(maxHeap, [curDiff+1, curCount])\\n            elif k < curCount:\\n                if maxHeap and curDiff + 1 == maxHeap[0][0]:\\n                    maxHeap[0][1] += k\\n                else:\\n                    heappush(maxHeap, [curDiff+1, k])\\n                heappush(maxHeap, [curDiff, curCount - k])\\n                k = 0\\n\\n        res = 0\\n        for curDiff, curCount in maxHeap:\\n            res += curDiff ** 2 * curCount\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260079,
                "title": "simple-c-soln-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    # define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<ll,ll>> pq;\\n        int n=size(nums1);\\n        ll sum=0;\\n        unordered_map<ll,ll> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll temp=(ll)abs(nums1[i]-nums2[i]);\\n            sum+=temp;\\n            mp[temp]++;\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.first==0)\\n                continue;\\n            else\\n                pq.push({it.first,it.second});\\n        }\\n        \\n        ll total=(ll)(k1+k2);\\n        if(total>=sum)\\n            return 0;\\n        \\n        while(!pq.empty() and total>0)\\n        {\\n           auto temp=pq.top();\\n            pq.pop();\\n            if(pq.size()==0)\\n            {\\n                ll reduce=min(total,temp.second);\\n                total-=reduce;// total is reduced that much time as of fq bcz each time we are reducing only 1\\n                temp.second-=reduce;// we have reduced the freqency of that elemet that much time also\\n                \\n                // now after reducing each elemet by one still it has greater then zero again push it into q with the same frq as all no are decreased by 1 so frq remain same\\n                if(temp.first-1>0)\\n                    pq.push({temp.first-1,reduce});\\n                // check if frq of earlier was still greater then again push it into q\\n                if(temp.second>0)\\n                    pq.push(temp);\\n              \\n            }\\n            else\\n            {\\n                ll reduce=min(total,temp.second);\\n                total-=reduce;// total is reduced that much time as of fq bcz each time we are reducing only 1\\n                temp.second-=reduce;// we have reduced the freqency of that elemet that much time also\\n                 if(temp.second>0)\\n                    pq.push(temp);\\n                // checking if after reducing 1 the next element is same then we simply add the frq of this elemet in next and both can be done simultaneously\\n                if(pq.top().first==temp.first-1)\\n                {\\n                    auto temp1=pq.top();\\n                    pq.pop();\\n                    temp1.second+=reduce;// adding frq as they both are of same values\\n                    pq.push(temp1);\\n                    \\n                }\\n                else  if(temp.first-1>0)\\n                    pq.push({temp.first-1,reduce});\\n            }\\n        }\\n        ll ans=0;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            ans+=(ll)(temp.first*temp.first*temp.second);\\n        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    # define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<ll,ll>> pq;\\n        int n=size(nums1);\\n        ll sum=0;\\n        unordered_map<ll,ll> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll temp=(ll)abs(nums1[i]-nums2[i]);\\n            sum+=temp;\\n            mp[temp]++;\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.first==0)\\n                continue;\\n            else\\n                pq.push({it.first,it.second});\\n        }\\n        \\n        ll total=(ll)(k1+k2);\\n        if(total>=sum)\\n            return 0;\\n        \\n        while(!pq.empty() and total>0)\\n        {\\n           auto temp=pq.top();\\n            pq.pop();\\n            if(pq.size()==0)\\n            {\\n                ll reduce=min(total,temp.second);\\n                total-=reduce;// total is reduced that much time as of fq bcz each time we are reducing only 1\\n                temp.second-=reduce;// we have reduced the freqency of that elemet that much time also\\n                \\n                // now after reducing each elemet by one still it has greater then zero again push it into q with the same frq as all no are decreased by 1 so frq remain same\\n                if(temp.first-1>0)\\n                    pq.push({temp.first-1,reduce});\\n                // check if frq of earlier was still greater then again push it into q\\n                if(temp.second>0)\\n                    pq.push(temp);\\n              \\n            }\\n            else\\n            {\\n                ll reduce=min(total,temp.second);\\n                total-=reduce;// total is reduced that much time as of fq bcz each time we are reducing only 1\\n                temp.second-=reduce;// we have reduced the freqency of that elemet that much time also\\n                 if(temp.second>0)\\n                    pq.push(temp);\\n                // checking if after reducing 1 the next element is same then we simply add the frq of this elemet in next and both can be done simultaneously\\n                if(pq.top().first==temp.first-1)\\n                {\\n                    auto temp1=pq.top();\\n                    pq.pop();\\n                    temp1.second+=reduce;// adding frq as they both are of same values\\n                    pq.push(temp1);\\n                    \\n                }\\n                else  if(temp.first-1>0)\\n                    pq.push({temp.first-1,reduce});\\n            }\\n        }\\n        ll ans=0;\\n        while(!pq.empty())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            ans+=(ll)(temp.first*temp.first*temp.second);\\n        \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262449,
                "title": "c-2-approaches-explained-counting-sort-o-n",
                "content": "Process thinking:\\n* Try a dry run on a paper with the two arrays and you will see that its better to greedily reduce the largest `abs(diff)` of the two values.\\n* `k1` and `k2` is just a gimmik as both allows +1 and -1 with abs and what not.\\n* We start with storing `diff` in a priority queue and reduce the `k` count by 1 for every largest number.\\n* This is optimized further using counting sort as there can be many same `diff` values.\\n\\n**Method 1:** Using Priority Queue (\\u274C LTE)\\n```cpp\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    int n = nums1.size();\\n    priority_queue<int> pq;\\n    for(int i=0; i<n; i++)\\n        pq.push(abs(nums1[i] - nums2[i]));\\n\\n    int k = k1+k2;\\n    while(k > 0){\\n        if(pq.top() == 0) break; //don\\'t let numbers be negative\\n        int num = pq.top(); pq.pop();\\n        pq.push(num-1);\\n        k--;\\n    }\\n\\n    long long res = 0;\\n    while(!pq.empty()){\\n        long long num = pq.top(); pq.pop();\\n        res += (long long) num * num;\\n    }\\n    return res;\\n}\\n```\\n\\n**Method 2:** Using Bucket Counting (\\u2705 AC)\\n```cpp\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    int n = nums1.size();\\n    vector<int> diff(100001);\\n    for(int i=0; i<n; i++)\\n        diff[abs(nums1[i] - nums2[i])]++;\\n\\n    int k = k1+k2;\\n    for(int i=diff.size()-1; i >= 0 && k > 0; i--){\\n        if(diff[i]){\\n            int mini = min(diff[i], k);\\n            k -= mini;\\n            diff[i] -= mini;\\n\\n            int newAbsDiff  = i-1;\\n            if(newAbsDiff > 0)\\n                diff[newAbsDiff] += mini;\\n        }\\n    }\\n\\n    long long res = 0;\\n    for(int i=0; i < diff.size(); i++){\\n        long long num = i, times = diff[i];\\n        res += (long long) num * num * times;\\n    }\\n    return res;\\n}\\n```\\n\\n**Upvote and let\\'s learn together!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    int n = nums1.size();\\n    priority_queue<int> pq;\\n    for(int i=0; i<n; i++)\\n        pq.push(abs(nums1[i] - nums2[i]));\\n\\n    int k = k1+k2;\\n    while(k > 0){\\n        if(pq.top() == 0) break; //don\\'t let numbers be negative\\n        int num = pq.top(); pq.pop();\\n        pq.push(num-1);\\n        k--;\\n    }\\n\\n    long long res = 0;\\n    while(!pq.empty()){\\n        long long num = pq.top(); pq.pop();\\n        res += (long long) num * num;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    int n = nums1.size();\\n    vector<int> diff(100001);\\n    for(int i=0; i<n; i++)\\n        diff[abs(nums1[i] - nums2[i])]++;\\n\\n    int k = k1+k2;\\n    for(int i=diff.size()-1; i >= 0 && k > 0; i--){\\n        if(diff[i]){\\n            int mini = min(diff[i], k);\\n            k -= mini;\\n            diff[i] -= mini;\\n\\n            int newAbsDiff  = i-1;\\n            if(newAbsDiff > 0)\\n                diff[newAbsDiff] += mini;\\n        }\\n    }\\n\\n    long long res = 0;\\n    for(int i=0; i < diff.size(); i++){\\n        long long num = i, times = diff[i];\\n        res += (long long) num * num * times;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259738,
                "title": "c-python-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        n=nums1.size();\\n        int target=k1+k2;\\n        vector<long long>nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            nums.push_back(abs(nums1[i]-nums2[i]));\\n        }\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long l=0;\\n        long long r=1e9;\\n        long long ans=-1;\\n        while(l<=r)\\n        {\\n            long long mid=(l+r)/2;\\n            long long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                sum+=max(0ll,nums[i]-mid);\\n            }\\n            if(sum<=target)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        long long result=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            target-=max(0ll,nums[i]-ans);\\n            nums[i]=min(nums[i],ans);\\n        }\\n        for(int i=0;i<min(target,n);i++)\\n        {\\n            if(nums[i])\\n               nums[i]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            result+=(nums[i]*nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n=len(nums1)\\n        target=k1+k2\\n        nums=[]\\n        for i in range(0,n):\\n            nums.append(abs(nums1[i]-nums2[i]))\\n        nums.sort(reverse=True)\\n        l=0\\n        r=10**9\\n        ans=-1\\n        while l<=r:\\n            mid=(l+r)//2\\n            count=0\\n            for i in nums:\\n                count+=max(0,i-mid)\\n            if count<=target:\\n                r=mid-1\\n                ans=mid\\n            else:\\n                l=mid+1\\n        for i in range(0,n):\\n            target-=max(0,nums[i]-ans)\\n            nums[i]=min(nums[i],ans)\\n        for i in range(0,n):\\n            if target>0 and nums[i]>0:\\n                nums[i]-=1\\n                target-=1\\n        result=0\\n        for i in nums:\\n            result+=(i*i)\\n        return result\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        n=nums1.size();\\n        int target=k1+k2;\\n        vector<long long>nums;\\n        for(int i=0;i<n;i++)\\n        {\\n            nums.push_back(abs(nums1[i]-nums2[i]));\\n        }\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        long long l=0;\\n        long long r=1e9;\\n        long long ans=-1;\\n        while(l<=r)\\n        {\\n            long long mid=(l+r)/2;\\n            long long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                sum+=max(0ll,nums[i]-mid);\\n            }\\n            if(sum<=target)\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        long long result=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            target-=max(0ll,nums[i]-ans);\\n            nums[i]=min(nums[i],ans);\\n        }\\n        for(int i=0;i<min(target,n);i++)\\n        {\\n            if(nums[i])\\n               nums[i]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            result+=(nums[i]*nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n=len(nums1)\\n        target=k1+k2\\n        nums=[]\\n        for i in range(0,n):\\n            nums.append(abs(nums1[i]-nums2[i]))\\n        nums.sort(reverse=True)\\n        l=0\\n        r=10**9\\n        ans=-1\\n        while l<=r:\\n            mid=(l+r)//2\\n            count=0\\n            for i in nums:\\n                count+=max(0,i-mid)\\n            if count<=target:\\n                r=mid-1\\n                ans=mid\\n            else:\\n                l=mid+1\\n        for i in range(0,n):\\n            target-=max(0,nums[i]-ans)\\n            nums[i]=min(nums[i],ans)\\n        for i in range(0,n):\\n            if target>0 and nums[i]>0:\\n                nums[i]-=1\\n                target-=1\\n        result=0\\n        for i in nums:\\n            result+=(i*i)\\n        return result\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259599,
                "title": "java-priority-queue-with-explanation",
                "content": "```\\n//Intuition:\\n//There is no difference between the purpose of k1 and k2, so we add them together and store it as a variable k\\n//Every time we want to find the maximum difference and reduce the difference, so we need to use a PriorityQueue to track the max diff\\n//But if every time we reduce the max diff by one, that will be time consuming. So here is the new strategy:\\n//The first time we poll a max diff, we store it to a variable prev, and cnt equals 1\\n//The next time we get another max diff, we try to reduce prev to the current max diff, and cnt++\\n//Thus (prev - current max diff) * cnt is the total times we have to reduce to maintain this structure, \\n//until (prev - current max diff) * cnt > k\\n//If (prev - current max diff) * cnt > k, it means we can not reduce all the previous number to the current max diff\\n\\n//Example:\\n//max diff: [10, 8, 5, 5, 1]  k = 18\\n//max diff: [8, 8, 5, 5, 1]  k = 16  prev = 8  cnt = 2 \\n//max diff: [5, 5, 5, 5, 1]  k = 10  prev = 5  cnt = 3 \\n//max diff: [5, 5, 5, 5, 1]  k = 10  prev = 5  cnt = 4 \\n//max diff: then (prev - current max diff) * cnt > k \\n//We enter into else condition, now we have  max diff = [5, 5, 5, 5, 1]  k = 10  prev = 5  cnt = 4\\n//we want to reduce the previous five\\'s all to 1, but the remaining k is not enough for us to do that, \\n//so we can only all the previous five\\'s to a value that is larger than one. \\n//Thus we have int a = k / cnt = 2; int b = k % cnt = 2; int c = prev - a = 3; \\n//a is the maximum value we can reduce, b is the remaining value that we can reduce after reducing a, \\n//c is the value after we reduce a.\\n//Thus, after reducing a, we have: max diff: [3, 3, 3, 3, 1]  \\n//And we still have b = 2 remaining, so we reduce the first two values by one, \\n//then we have max diff: [2, 2, 3, 3, 1], this is what we want\\n\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        pq.add(0);\\n        for (int i = 0; i < nums1.length; i++) {\\n        \\tint diff = Math.abs(nums1[i] - nums2[i]);\\n        \\tif (diff > 0)\\n        \\t\\tpq.add(diff);\\n        }\\n        int k = k1 + k2;\\n        int prev = 0, cnt = 0;\\n        while (k > 0 && !pq.isEmpty()) {\\n        \\tint cur = pq.poll();\\n        \\tlong x = (prev - cur) * cnt;\\n        \\tif (x <= k) {\\n        \\t\\tprev = cur;\\n        \\t\\tcnt++;\\n        \\t\\tk -= x;\\n        \\t} else {\\n        \\t\\tint a = k / cnt; \\n        \\t\\tint b = k % cnt; \\n        \\t\\tint c = prev - a; \\n        \\t\\tfor (int i = 0; i < cnt - b; i++) \\n        \\t\\t\\tpq.add(c);\\n        \\t\\tfor (int i = 0; i < b; i++) \\n        \\t\\t\\tpq.add(c - 1);\\n        \\t\\tpq.add(cur);\\n        \\t\\tk = 0;\\n        \\t}\\n        }\\n        long ans = 0;\\n        for (long diff : pq)\\n        \\tans += (long)diff * diff;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//Intuition:\\n//There is no difference between the purpose of k1 and k2, so we add them together and store it as a variable k\\n//Every time we want to find the maximum difference and reduce the difference, so we need to use a PriorityQueue to track the max diff\\n//But if every time we reduce the max diff by one, that will be time consuming. So here is the new strategy:\\n//The first time we poll a max diff, we store it to a variable prev, and cnt equals 1\\n//The next time we get another max diff, we try to reduce prev to the current max diff, and cnt++\\n//Thus (prev - current max diff) * cnt is the total times we have to reduce to maintain this structure, \\n//until (prev - current max diff) * cnt > k\\n//If (prev - current max diff) * cnt > k, it means we can not reduce all the previous number to the current max diff\\n\\n//Example:\\n//max diff: [10, 8, 5, 5, 1]  k = 18\\n//max diff: [8, 8, 5, 5, 1]  k = 16  prev = 8  cnt = 2 \\n//max diff: [5, 5, 5, 5, 1]  k = 10  prev = 5  cnt = 3 \\n//max diff: [5, 5, 5, 5, 1]  k = 10  prev = 5  cnt = 4 \\n//max diff: then (prev - current max diff) * cnt > k \\n//We enter into else condition, now we have  max diff = [5, 5, 5, 5, 1]  k = 10  prev = 5  cnt = 4\\n//we want to reduce the previous five\\'s all to 1, but the remaining k is not enough for us to do that, \\n//so we can only all the previous five\\'s to a value that is larger than one. \\n//Thus we have int a = k / cnt = 2; int b = k % cnt = 2; int c = prev - a = 3; \\n//a is the maximum value we can reduce, b is the remaining value that we can reduce after reducing a, \\n//c is the value after we reduce a.\\n//Thus, after reducing a, we have: max diff: [3, 3, 3, 3, 1]  \\n//And we still have b = 2 remaining, so we reduce the first two values by one, \\n//then we have max diff: [2, 2, 3, 3, 1], this is what we want\\n\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        pq.add(0);\\n        for (int i = 0; i < nums1.length; i++) {\\n        \\tint diff = Math.abs(nums1[i] - nums2[i]);\\n        \\tif (diff > 0)\\n        \\t\\tpq.add(diff);\\n        }\\n        int k = k1 + k2;\\n        int prev = 0, cnt = 0;\\n        while (k > 0 && !pq.isEmpty()) {\\n        \\tint cur = pq.poll();\\n        \\tlong x = (prev - cur) * cnt;\\n        \\tif (x <= k) {\\n        \\t\\tprev = cur;\\n        \\t\\tcnt++;\\n        \\t\\tk -= x;\\n        \\t} else {\\n        \\t\\tint a = k / cnt; \\n        \\t\\tint b = k % cnt; \\n        \\t\\tint c = prev - a; \\n        \\t\\tfor (int i = 0; i < cnt - b; i++) \\n        \\t\\t\\tpq.add(c);\\n        \\t\\tfor (int i = 0; i < b; i++) \\n        \\t\\t\\tpq.add(c - 1);\\n        \\t\\tpq.add(cur);\\n        \\t\\tk = 0;\\n        \\t}\\n        }\\n        long ans = 0;\\n        for (long diff : pq)\\n        \\tans += (long)diff * diff;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259168,
                "title": "java-solution-using-priorityqueue",
                "content": "The key idea is that you need to bring the overall maximum in the diff to lowest number possible.\\nIf you have 2 operations and you have 2 options to decrease it from, then first bring the bigger nubmer to equal to lower number and still if you have some operations left, reduce the lower number.\\n\\nI first tried using TreeMap for this but got MofificationException so rewrote the code to use PriorityQueue instead.\\n\\n```\\nclass Solution {\\n    class PQcomparator implements Comparator<int[]> {\\n        @Override\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(b[0], a[0]);\\n        }\\n    }\\n\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        int[] diffs = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            diffs[i] = Math.abs(nums1[i] - nums2[i]);\\n        }\\n        \\n        int op = k1 + k2;\\n\\n        Map<Integer, Integer> freqs = new HashMap<>();\\n        for(int num : diffs) {\\n            freqs.put(num, freqs.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new PQcomparator());\\n        for(int key : freqs.keySet()) {\\n            pq.offer(new int[]{key, freqs.get(key)});\\n        }\\n        \\n        while(!pq.isEmpty()) {\\n            if (op == 0) {\\n                break;\\n            }\\n            \\n            int[] top = pq.poll();\\n            \\n            int key = top[0];\\n            int count = top[1];\\n            \\n            if (key == 0) {\\n                break;\\n            }\\n\\n            int nextkey = 0;\\n            if (!pq.isEmpty()) {\\n                nextkey = pq.peek()[0];\\n            } else {\\n                pq.offer(new int[]{0, 0});\\n                nextkey = 0;\\n            }\\n            \\n            int diff = key - nextkey;\\n            if (count * diff <= op) {\\n                pq.peek()[1] += count;\\n                op -= count * diff;\\n            } else {\\n                int equalDistribute = op / count;\\n                int remaining = op - equalDistribute * count;\\n                \\n                int lowerKey = key - equalDistribute;\\n                if (lowerKey == 0) {\\n                    break;\\n                }\\n                \\n                pq.offer(new int[]{lowerKey, count - remaining});\\n                pq.offer(new int[]{lowerKey - 1, remaining});\\n                \\n                op = 0;\\n            }\\n        }\\n        \\n        long ans = 0;\\n        while(!pq.isEmpty()) {\\n            int[] top = pq.poll();\\n            int key = top[0];\\n            int count = top[1];\\n            ans += 1l * key * key * count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class PQcomparator implements Comparator<int[]> {\\n        @Override\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(b[0], a[0]);\\n        }\\n    }\\n\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        int[] diffs = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            diffs[i] = Math.abs(nums1[i] - nums2[i]);\\n        }\\n        \\n        int op = k1 + k2;\\n\\n        Map<Integer, Integer> freqs = new HashMap<>();\\n        for(int num : diffs) {\\n            freqs.put(num, freqs.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new PQcomparator());\\n        for(int key : freqs.keySet()) {\\n            pq.offer(new int[]{key, freqs.get(key)});\\n        }\\n        \\n        while(!pq.isEmpty()) {\\n            if (op == 0) {\\n                break;\\n            }\\n            \\n            int[] top = pq.poll();\\n            \\n            int key = top[0];\\n            int count = top[1];\\n            \\n            if (key == 0) {\\n                break;\\n            }\\n\\n            int nextkey = 0;\\n            if (!pq.isEmpty()) {\\n                nextkey = pq.peek()[0];\\n            } else {\\n                pq.offer(new int[]{0, 0});\\n                nextkey = 0;\\n            }\\n            \\n            int diff = key - nextkey;\\n            if (count * diff <= op) {\\n                pq.peek()[1] += count;\\n                op -= count * diff;\\n            } else {\\n                int equalDistribute = op / count;\\n                int remaining = op - equalDistribute * count;\\n                \\n                int lowerKey = key - equalDistribute;\\n                if (lowerKey == 0) {\\n                    break;\\n                }\\n                \\n                pq.offer(new int[]{lowerKey, count - remaining});\\n                pq.offer(new int[]{lowerKey - 1, remaining});\\n                \\n                op = 0;\\n            }\\n        }\\n        \\n        long ans = 0;\\n        while(!pq.isEmpty()) {\\n            int[] top = pq.poll();\\n            int key = top[0];\\n            int count = top[1];\\n            ans += 1l * key * key * count;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260328,
                "title": "easy-solution-priority-queue-hashmap-greedy-intuitive",
                "content": "Here, the question can be  reduced to the minimum number of operations required to minimise the square of numbers in an array, where the operation can only be to decrease a number k times, where k = k1+k2.\\n\\nFor instance, \\nnums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1\\n\\nour array will be : v= [4,4,4,3] where v[i] = abs(nums1[i]-nums2[i])\\n\\nAnd in one operation, we can choose any index and decrease its value by 1. \\nSo the best work we can do is always pick the maximum from v and decrease its value by 1 and keep repeating until k (number of operations) becomes 0 or the maximum element itself becomes 0. \\n\\nSo this idea can be implimented just using priority queue but it\\'ll be TLE, because of the constraints. So to optimise it further, make a hashmap for v which will contain the frequencies of the elements in v. And now, instead of just subtracting 1 from only one element (i.e 4), we can pick all three 4s together and directly decrease 3 from k (as 4 was our max element and it was occuring 3 times, so decrease 3 from the number of operations, thus making 4 to 3). Definately, we have to update the values in the hashmap and priority queue as well, which can be thought further.\\n\\nHere is the implimentation for reference : \\n\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        int n = nums1.size();\\n        \\n        map<ll,ll>mp;\\n        ll sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            mp[abs(nums1[i]-nums2[i])]++;\\n            \\n            sum+=abs(nums1[i]-nums2[i]);\\n            \\n        }\\n        \\n        ll k = k1+k2;\\n        \\n        if(k>=sum)return 0;\\n        \\n        priority_queue<ll>pq;\\n        \\n        for(auto i:mp){\\n            pq.push(i.first);\\n        }\\n        \\n        \\n        while(k>0 && pq.top()>0){\\n            \\n            ll ele = pq.top();\\n            ll count = mp[ele];\\n            \\n            if(count<=k){\\n                \\n                k=k-count;\\n                mp.erase(ele);\\n                pq.pop();\\n                ele--;\\n                \\n                if(mp.find(ele)!=mp.end()){\\n                    \\n                    mp[ele]+=count;\\n                    \\n                } else {\\n                    \\n                    mp[ele]=count;\\n                    pq.push(ele);\\n                    \\n                }\\n                \\n                \\n            } else {\\n             \\n                ll diff = count-k;\\n     \\n                ele--;\\n                \\n                if(mp.find(ele)!=mp.end()){\\n                    \\n                    mp[ele]+=k;\\n                    \\n                    \\n                } else{\\n                    \\n                    mp[ele]=k;\\n                    pq.push(ele);\\n                    \\n                }\\n                \\n                ele++;\\n                mp[ele]=diff;\\n                \\n                k=0;\\n                \\n                \\n            }\\n            \\n            \\n        }\\n    \\n        ll ans = 0;\\n        \\n        for(auto i:mp){\\n            \\n            ans+=i.first*i.first*i.second;\\n            \\n        }\\n\\n        \\n        return ans;\\n    \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        int n = nums1.size();\\n        \\n        map<ll,ll>mp;\\n        ll sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            mp[abs(nums1[i]-nums2[i])]++;\\n            \\n            sum+=abs(nums1[i]-nums2[i]);\\n            \\n        }\\n        \\n        ll k = k1+k2;\\n        \\n        if(k>=sum)return 0;\\n        \\n        priority_queue<ll>pq;\\n        \\n        for(auto i:mp){\\n            pq.push(i.first);\\n        }\\n        \\n        \\n        while(k>0 && pq.top()>0){\\n            \\n            ll ele = pq.top();\\n            ll count = mp[ele];\\n            \\n            if(count<=k){\\n                \\n                k=k-count;\\n                mp.erase(ele);\\n                pq.pop();\\n                ele--;\\n                \\n                if(mp.find(ele)!=mp.end()){\\n                    \\n                    mp[ele]+=count;\\n                    \\n                } else {\\n                    \\n                    mp[ele]=count;\\n                    pq.push(ele);\\n                    \\n                }\\n                \\n                \\n            } else {\\n             \\n                ll diff = count-k;\\n     \\n                ele--;\\n                \\n                if(mp.find(ele)!=mp.end()){\\n                    \\n                    mp[ele]+=k;\\n                    \\n                    \\n                } else{\\n                    \\n                    mp[ele]=k;\\n                    pq.push(ele);\\n                    \\n                }\\n                \\n                ele++;\\n                mp[ele]=diff;\\n                \\n                k=0;\\n                \\n                \\n            }\\n            \\n            \\n        }\\n    \\n        ll ans = 0;\\n        \\n        for(auto i:mp){\\n            \\n            ans+=i.first*i.first*i.second;\\n            \\n        }\\n\\n        \\n        return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260456,
                "title": "my-intution-and-thought-process",
                "content": "Gotta admit... I did struggle with this and couldn\\'t for the love of God choose between dp and greedy...\\nThe limits confused the hell out of me... and was adamant that a linear solution is the only one that would pass all test cases.\\n\\nWhy greedy?\\n* Its quite intutive to notice the solution really doesn\\'t depend on k1 and k2 being two seperate entities. Solving for k1 + k2 would give you the same outcome as solving individually for k1 and k2.\\n\\n* There would be three states each number in both nums1 and nums2 would take. Say for instance nums1[0]. The possible states would be nums1[0] + 1, nums1[0] - 1, nums1[0].\\n\\n* But does that matter? We are to take the difference between nums1[0] and num2[0], so would three states make sense? Mathematically, (a - 1) - (b - 1) is nothing but (a - b) + 0. (a + 1) - (b - 1) would be (a - b) + 2.\\n\\n* In all these cases, (a - 1), (a), (a + 1) with (b + 1), (b), (b - 1), (a - b) would be always a part. The constant, +0, +2 etc., would vary. So, it would make sense to start with the differences between the elements of same indexes.\\n\\n* Now that we have the differences, how would we make use of k1 + k2 moves to minimize our answer?\\n\\n* Its always better to equalize all numbers in the array, to minimize our answer. Why? Take only two numbers and try it yourself... Try adding +1, -1 to elements and see which gives you smallest answer... It\\'ll always be the ones where both numbers are equal. Because, squaring a larger number, would always magnify the answer, which is quite opposite of what we want. \\n\\n* So, we start with the highest differece, ( differences array sorted in decreasing order ) and try to bring it down to the smallest element in the heap.\\n\\n* That\\'s it. \\n\\n\\nHere\\'s the solution:\\n```\\nclass Solution {    \\n    \\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        \\n        PriorityQueue<Integer> differences = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\\n        for(int i = 0; i < n; ++i) {\\n            int difference = Math.abs(nums1[i] - nums2[i]);\\n            if(difference > 0) {\\n                differences.offer(Math.abs(nums1[i] - nums2[i]));    \\n            }            \\n        }\\n        \\n        int k = k1 + k2;\\n        while((k > 0) && (!differences.isEmpty())) {\\n\\n            int size = differences.size();\\n            \\n            int minK = k / size, element = differences.poll();                        \\n            int toDelete = k < size ? 1 : Math.min(minK, element);\\n            int toInsert = element - Math.min(toDelete, element);\\n\\n            k -= toDelete;\\n            if(toInsert > 0) {\\n                differences.offer(toInsert);\\n            }\\n        }\\n        \\n        long answer = 0;\\n        while(!differences.isEmpty()) {\\n            long element = differences.poll();            \\n            answer += (element * element);\\n        }        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {    \\n    \\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        \\n        PriorityQueue<Integer> differences = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\\n        for(int i = 0; i < n; ++i) {\\n            int difference = Math.abs(nums1[i] - nums2[i]);\\n            if(difference > 0) {\\n                differences.offer(Math.abs(nums1[i] - nums2[i]));    \\n            }            \\n        }\\n        \\n        int k = k1 + k2;\\n        while((k > 0) && (!differences.isEmpty())) {\\n\\n            int size = differences.size();\\n            \\n            int minK = k / size, element = differences.poll();                        \\n            int toDelete = k < size ? 1 : Math.min(minK, element);\\n            int toInsert = element - Math.min(toDelete, element);\\n\\n            k -= toDelete;\\n            if(toInsert > 0) {\\n                differences.offer(toInsert);\\n            }\\n        }\\n        \\n        long answer = 0;\\n        while(!differences.isEmpty()) {\\n            long element = differences.poll();            \\n            answer += (element * element);\\n        }        \\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259181,
                "title": "c-priority-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        unordered_map<int, int> freq; \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            int diff = abs(nums1[i] - nums2[i]); \\n            if (diff) ++freq[diff]; \\n        }\\n        priority_queue<pair<int, int>> pq; \\n        for (auto& [k, v] : freq) pq.emplace(k, v); \\n        for (int total = k1+k2, kk = 0, vv = 0; total && pq.size(); ) {\\n            auto [k, v] = pq.top(); pq.pop(); \\n            if (pq.size()) { \\n                tie(kk, vv) = pq.top(); pq.pop(); \\n            } else kk = vv = 0; \\n            int diff = k - kk; \\n            if (diff * v <= total) {\\n                total -= diff * v; \\n                if (vv) pq.emplace(kk, v+vv); \\n            } else {\\n                int x = total / v, y = total % v; \\n                total = 0; \\n                pq.emplace(k-x-1, y); \\n                pq.emplace(k-x, v-y); \\n                if (vv) pq.emplace(kk, vv); \\n            }\\n        }\\n        long long ans = 0; \\n        while (pq.size()) {\\n            auto [k, v] = pq.top(); pq.pop(); \\n            ans += (long long) k*k*v; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        unordered_map<int, int> freq; \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            int diff = abs(nums1[i] - nums2[i]); \\n            if (diff) ++freq[diff]; \\n        }\\n        priority_queue<pair<int, int>> pq; \\n        for (auto& [k, v] : freq) pq.emplace(k, v); \\n        for (int total = k1+k2, kk = 0, vv = 0; total && pq.size(); ) {\\n            auto [k, v] = pq.top(); pq.pop(); \\n            if (pq.size()) { \\n                tie(kk, vv) = pq.top(); pq.pop(); \\n            } else kk = vv = 0; \\n            int diff = k - kk; \\n            if (diff * v <= total) {\\n                total -= diff * v; \\n                if (vv) pq.emplace(kk, v+vv); \\n            } else {\\n                int x = total / v, y = total % v; \\n                total = 0; \\n                pq.emplace(k-x-1, y); \\n                pq.emplace(k-x, v-y); \\n                if (vv) pq.emplace(kk, vv); \\n            }\\n        }\\n        long long ans = 0; \\n        while (pq.size()) {\\n            auto [k, v] = pq.top(); pq.pop(); \\n            ans += (long long) k*k*v; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260326,
                "title": "o-nlogn-cpp-hindi-explanation-formula-formation-optimised-solution",
                "content": "**Given,**\\n1. Hume 2 array (nums1,nums2)  diye hue hai\\n2. k1 aur k2 , nums1 aur nums2 ke number of operations hai\\n\\n**Task**\\nHume The sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])^2 for each 0 <= i < n. iska minimum value nikalna hai\\n\\nFor better understanding of question ek baar question ko ache se padhle\\n\\nHume hrr index ke liye (nums1[i]-nums2[i])^2 nikalna hai jo ki humsa positive value aayega\\nhence. agar humara difference (diff) positive ho ya negative ho dono case mai diff^2 ka value same hi aayega. i.e (nums1[i]-nums2[i])^2=(nums2[i]-nums1[i])^2\\n\\n**Let diff=nums1[i]-nums2[i],**\\n\\nHum agar koi bhi operation kare to wo directly diff ko hi affect karega\\n**Case 1: Adding 1 in nums1[i] increase the value of diff by 1\\nCase 2: Adding 1 in nums2[i] decrease the value of diff by 1\\nCase 3: Substracting 1 in nums1[i] descrease the value of diff by 1\\nCase 2: Substracting 1 in nums2[i] increase the value of diff by 1**\\n\\n**At the end hume diff ka square krna hai isliye hume bss diff ke absolute value se hi mtlb hai isliye hum ek array create karenge jisme bss hrr index ke absolute difference ko store karenge aur sath hi sath iss new array ka sum bhi nikal lenge,**\\n\\n```\\nvector v;\\nlong long sum=0;\\nfor(int i=0;i<nums1.size();i++)\\n{\\nv.push_back(abs(nums1[i]-nums2[i]));\\nsum+=v.back();\\n}\\n```\\nhume apne sum of squared difference  ko minimise krna hai to humare array mai jo maximum values hai unka square humare sum mai sbse jyada contribute kr raha hai so hum humare array mai jo current maximum value hai unko -1 karenge. \\nIsse -1 krne ke liye hum kisi bhi array ko (nums1[i] or nums2[i] ) ko select krke -1 krne ke according apna operation kr skte hai\\n\\n**Case 1: nums1[i]>nums2[i]  then replace nums1[i] by nums1[i]-1 or nums2[i] by nums2[i]+1 , it replaces diff by diff-1.\\nCase 2: nums2[i]>nums1[i]  then replace nums2[i] by nums2[i]-1 or nums1[i] by nums1[i]+1 , it replaces diff by diff-1.**\\n\\nSince hum kisi bhi value ko change krne ke liye dono array ke help se kr sakte hai isliye humare pass total number of operation current array ko change krne ke liye k1+k2 available hai **(say it \\'t\\')**\\n**let t=k1+k2**\\n\\nHume sbse minimum value 0 mil skta hai aur ye tb hoga jb hum new array ke sare values ko 0 bana denge jisme hume Number of operation=sum of array lagega\\nSo,\\n```\\nif(t>=sum)\\nreturn 0;\\n```\\n\\nyaha tk humne basic model ready kr liya apne main kaam ko krne ke liye \\n**Now we have,**\\n**1. Difference array**\\n**2. total number of operation**\\nAur hume ye bhi pata hai ki humara answer zero nahi hoga\\n\\n**Humara target yahi hoga ki hume minimum answer pane ke liye apne array ke hr element ko jitna kmm ho sake utna kmm krna parega. Since humare sum mai sbse jyada contribution maximum value ka hai isliye hum unhi ko sbse pahle kmm kr rahe hai**\\n\\nAb hume apne current  maximum value ko nikalna hai aur usme -1 krna hai. Isse hume priority_queue use kr ke kr skte lekin wo optimised tarika nahi hoga bcz ( 0 <= k1, k2 <= 10^9 ) hume worst case mai 10^9 operations krne parenge joki possible nahi. \\n\\nOptimised way mai krne ke liye hum apne array ko sort kr denge \\naur hum hrr maximum value ko second maximum value ke jitna kr denge\\n\\nif we have,\\n1 2 3 4 5\\nwe will make it\\n1 2 3 4 4\\ncontinue....\\n\\nfir again hum aisa karenge ki sare value maximum value ko second maximum value ke jitna kr denge\\nif we have,\\n1 2 3 4 4\\nwe will make it\\n1 2 3 3 3\\nisase hum sare maximum value ko ek sath kaam kr rahe hai\\n\\n\\nHum yeh krne ke liye apne array ko piche se traverse karenge with second maximum with index i=v.size()-2 aur 0 tk chalte jayenge\\n**let x=No of element right of our current index**\\nHum ye sare element ko apne current index ke value ke equal karenge\\n**1 element ko equal krne ke liye hume v[i+1]-v[i] operations lagenge**\\nIsliye\\nHrr index ke liye hume **No of operation = x`*`(v[i+1]-v[i])** lagenge\\n\\nEk aisa samay aayega jb hum sare value ko current ke equal nahi kr payenge kyuki tb humare pass utne operation nahi back payenge uss case mai hum sabhi element mai se kuch equal amount minus kr denge jo ki (remaining total number of operation/x) hoga aur kuch remaining operations jo bachenge usko hum 1-1 krke sbme se minus kr denge jitne mai possible ho\\n\\nAab hume apna most optimised array having minimum sum of squared difference mil chuka hai\\n\\nAur aab hum apna answer sabhi value ke sqaure ka sum krke paa skte hai\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        vector<long long> v;\\n        long long sum=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            v.push_back(abs(nums1[i]-nums2[i])); // To make difference array\\n            sum+=v.back();  // Taking sum\\n        }\\n        sort(v.begin(),v.end()); // For doing sort\\n        long long t=k1+k2,i,x;  // t=total number of operation\\n        if(t>=sum) // agar hum sabhi element ko zero kr denge then return 0 yahi sbse minimum value hai\\n            return 0;\\n        for( i=v.size()-2;i>=0;i--) // traversing from second maximum value in backward direction\\n        {\\n            x=v.size()-1-i;  // No of element in the right side of i\\n            if(x*(v[i+1]-v[i])<=t) // agar hum sare value of right side ko current ke equal kr skte hai then\\n            {\\n                t-=(x*(v[i+1]-v[i])); // Number of operations required ko total se minus kr do\\n            }\\n            else\\n                break; // otherwise break kr do\\n        }\\n        if(i==-1) //agar i ka value -1 ho gaya then humara sara element ka value same hai aur aise elements ka number x hai\\n        {\\n            x=v.size();\\n        }\\n        long long val=v[i+1]; // maximum value\\n        long long temp=t/x; // itna sbme se equaly minus karenge\\n        long long rem=t%x,ans=0; // keval rem number of element mai se -1 karenge \\n        while(x) // For all element having maximum value\\n        {\\n            long long a=val; // maximum value\\n            if(rem) // For only rem number of element\\n            {\\n                rem--;\\n                a--;\\n                a-=temp;\\n            }\\n            else\\n                a-=temp;\\n            ans+=(a*a); // keeping our answer updated with sum of square of values\\n            x--;\\n        }\\n        for(int j=0;j<=i;j++) // for all the element except maximum one\\'s\\n        {\\n            ans+=(v[j]*v[j]);\\n        }\\n        return ans; // our final answer\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nvector v;\\nlong long sum=0;\\nfor(int i=0;i<nums1.size();i++)\\n{\\nv.push_back(abs(nums1[i]-nums2[i]));\\nsum+=v.back();\\n}\\n```\n```\\nif(t>=sum)\\nreturn 0;\\n```\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        vector<long long> v;\\n        long long sum=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            v.push_back(abs(nums1[i]-nums2[i])); // To make difference array\\n            sum+=v.back();  // Taking sum\\n        }\\n        sort(v.begin(),v.end()); // For doing sort\\n        long long t=k1+k2,i,x;  // t=total number of operation\\n        if(t>=sum) // agar hum sabhi element ko zero kr denge then return 0 yahi sbse minimum value hai\\n            return 0;\\n        for( i=v.size()-2;i>=0;i--) // traversing from second maximum value in backward direction\\n        {\\n            x=v.size()-1-i;  // No of element in the right side of i\\n            if(x*(v[i+1]-v[i])<=t) // agar hum sare value of right side ko current ke equal kr skte hai then\\n            {\\n                t-=(x*(v[i+1]-v[i])); // Number of operations required ko total se minus kr do\\n            }\\n            else\\n                break; // otherwise break kr do\\n        }\\n        if(i==-1) //agar i ka value -1 ho gaya then humara sara element ka value same hai aur aise elements ka number x hai\\n        {\\n            x=v.size();\\n        }\\n        long long val=v[i+1]; // maximum value\\n        long long temp=t/x; // itna sbme se equaly minus karenge\\n        long long rem=t%x,ans=0; // keval rem number of element mai se -1 karenge \\n        while(x) // For all element having maximum value\\n        {\\n            long long a=val; // maximum value\\n            if(rem) // For only rem number of element\\n            {\\n                rem--;\\n                a--;\\n                a-=temp;\\n            }\\n            else\\n                a-=temp;\\n            ans+=(a*a); // keeping our answer updated with sum of square of values\\n            x--;\\n        }\\n        for(int j=0;j<=i;j++) // for all the element except maximum one\\'s\\n        {\\n            ans+=(v[j]*v[j]);\\n        }\\n        return ans; // our final answer\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260068,
                "title": "c-map-greedy-well-explained",
                "content": "1) There is no difference between the purpose of k1 and k2. Adding +1 to one element in nums1 is same as performing -1 to one element in nums2, and vice versa.\\n2) Reduce the highest absolute difference greedily. \\n3) If you do decrement one at a time then it will give TLE.\\n4) Use sorted map to get the highest element along with freq.\\n5) Alter the map and change k as per the next larger element\\n\\n**Pls upvote if you find the explanation helpful**\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int k = k1 + k2;\\n        map<int, int, greater<int>>mp;\\n        for (int i = 0; i < nums1.size(); ++i) \\n        {\\n            int x=abs(nums1[i] - nums2[i]);\\n            if(x>0)mp[x]++;\\n        }\\n        mp[0]=0;\\n        while(k)\\n        {\\n            auto largest=mp.begin();\\n            \\n            map<int,int>::iterator nxt=next(largest);\\n            int val=largest->first;\\n            if(val==0)break;\\n            int freq=largest->second;\\n            int dec=k/freq;\\n            int remain=k%freq;\\n            int diff= val- nxt->first;\\n            \\n            if(dec>=diff)\\n            {\\n                dec=(largest->first-nxt->first)*largest->second;\\n                k-=dec;\\n                mp[nxt->first]+=freq;\\n                mp.erase(largest);\\n            }\\n            else\\n            {\\n                mp.erase(largest);\\n                mp[val-dec]+=freq-remain;\\n                mp[val-dec-1]+=remain;\\n                k=0;\\n            }            \\n        }  \\n        long long result = 0;\\n        for (const auto& [diff, freq] : mp) {\\n            result += long(diff) * long(diff) * freq;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int k = k1 + k2;\\n        map<int, int, greater<int>>mp;\\n        for (int i = 0; i < nums1.size(); ++i) \\n        {\\n            int x=abs(nums1[i] - nums2[i]);\\n            if(x>0)mp[x]++;\\n        }\\n        mp[0]=0;\\n        while(k)\\n        {\\n            auto largest=mp.begin();\\n            \\n            map<int,int>::iterator nxt=next(largest);\\n            int val=largest->first;\\n            if(val==0)break;\\n            int freq=largest->second;\\n            int dec=k/freq;\\n            int remain=k%freq;\\n            int diff= val- nxt->first;\\n            \\n            if(dec>=diff)\\n            {\\n                dec=(largest->first-nxt->first)*largest->second;\\n                k-=dec;\\n                mp[nxt->first]+=freq;\\n                mp.erase(largest);\\n            }\\n            else\\n            {\\n                mp.erase(largest);\\n                mp[val-dec]+=freq-remain;\\n                mp[val-dec-1]+=remain;\\n                k=0;\\n            }            \\n        }  \\n        long long result = 0;\\n        for (const auto& [diff, freq] : mp) {\\n            result += long(diff) * long(diff) * freq;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259374,
                "title": "easy-js-solution",
                "content": "```\\nvar minSumSquareDiff = function(nums1, nums2, k1, k2) {\\n    const len = nums1.length;\\n    const diff = new Array(len).fill(0);\\n    for(let i = 0; i < len; i++) {\\n        diff[i] = Math.abs(nums1[i] - nums2[i]);\\n    }\\n    diff.sort((a, b) => b - a);\\n    const bucket = new Array(diff[0] + 1).fill(0);\\n    let tk = k1 + k2;\\n    for(let i of diff) {\\n        bucket[i]++;\\n    }\\n    for(let i = bucket.length - 1; tk > 0 && i >= 0; i--) {\\n        if(bucket[i] == 0) continue; \\n        const reduce = Math.min(bucket[i], tk);\\n        bucket[i] -= reduce;\\n        bucket[i-1] += reduce;\\n        tk -= reduce;\\n    }\\n    let ans = 0;\\n    for(let i = bucket.length - 1; i >= 1; i--) {\\n        ans += bucket[i] * i * i;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSumSquareDiff = function(nums1, nums2, k1, k2) {\\n    const len = nums1.length;\\n    const diff = new Array(len).fill(0);\\n    for(let i = 0; i < len; i++) {\\n        diff[i] = Math.abs(nums1[i] - nums2[i]);\\n    }\\n    diff.sort((a, b) => b - a);\\n    const bucket = new Array(diff[0] + 1).fill(0);\\n    let tk = k1 + k2;\\n    for(let i of diff) {\\n        bucket[i]++;\\n    }\\n    for(let i = bucket.length - 1; tk > 0 && i >= 0; i--) {\\n        if(bucket[i] == 0) continue; \\n        const reduce = Math.min(bucket[i], tk);\\n        bucket[i] -= reduce;\\n        bucket[i-1] += reduce;\\n        tk -= reduce;\\n    }\\n    let ans = 0;\\n    for(let i = bucket.length - 1; i >= 1; i--) {\\n        ans += bucket[i] * i * i;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2321919,
                "title": "c-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans=0;\\n        //since we can do increase/decrease operation in either array so we can add value of k\\n        int k=k1+k2;\\n        // to minimize the sum, we would want max difference should be minimum. so thinking greedly we want to decrease max difference\\n        //so we will decrease the max diff one by one instead of making it ZERO(when we have k>max diff)\\n        //we would want to decrease all max diff one by one\\n        // so we are using map to store and diff and their frequency\\n        map<long long,int>mp;\\n        for(int i=0;i<nums1.size();i++){\\n            mp[abs(nums1[i]-nums2[i])]++;\\n        }\\n        while(k>0 && !mp.empty()){\\n            auto it = *--mp.end();\\n            if(it.first==0)break;\\n            int f=it.second;\\n            if(f>=k){\\n                //say max diff = 5, then we maki it to 4, hence freuency of 4 will increase correspondigly\\n                mp[it.first]-=k;\\n                mp[it.first-1]+=k;\\n                k=0;\\n            }\\n            else{\\n                mp.erase(it.first);\\n                mp[it.first-1]+=f;\\n                k-=f;\\n            }\\n        }\\n        for(auto x:mp){\\n            ans+= (x.first)*(x.first)*(x.second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease comment below, if you have any doubt",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans=0;\\n        //since we can do increase/decrease operation in either array so we can add value of k\\n        int k=k1+k2;\\n        // to minimize the sum, we would want max difference should be minimum. so thinking greedly we want to decrease max difference\\n        //so we will decrease the max diff one by one instead of making it ZERO(when we have k>max diff)\\n        //we would want to decrease all max diff one by one\\n        // so we are using map to store and diff and their frequency\\n        map<long long,int>mp;\\n        for(int i=0;i<nums1.size();i++){\\n            mp[abs(nums1[i]-nums2[i])]++;\\n        }\\n        while(k>0 && !mp.empty()){\\n            auto it = *--mp.end();\\n            if(it.first==0)break;\\n            int f=it.second;\\n            if(f>=k){\\n                //say max diff = 5, then we maki it to 4, hence freuency of 4 will increase correspondigly\\n                mp[it.first]-=k;\\n                mp[it.first-1]+=k;\\n                k=0;\\n            }\\n            else{\\n                mp.erase(it.first);\\n                mp[it.first-1]+=f;\\n                k-=f;\\n            }\\n        }\\n        for(auto x:mp){\\n            ans+= (x.first)*(x.first)*(x.second);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260473,
                "title": "java-treemap-intuitive-tc-o-n-logn-sc-o-n",
                "content": "Pre req for this solution is TreeMap\\nit uses Red-Black tree which returns basic operations like get, put, remove, contains in *logarithmic* time,\\nThis problem is not fully optimiesed to it\\'s potential,\\nlet\\'s have a look at the solution keeping that in mind,\\nit is sure that the condition for k1 and k2 is quite inconsequential,\\nsay you have ***a*** and ***b*** at ***i*** index,\\ntheir differnce will be ***(a - b)***,\\nif you want to apply operation on ***b*** it will be like,\\n***(a - (b-1)) \\u2192(a - b + 1) \\u2192(a+1 - b)*** , which is same as operation of ***+1*** in ***a***, so we will consider k1 and k2 as a whole.\\nNow, we will get a treemap which holds **unique differences** and it\\'s **occurence** throughout the arrays.\\n**lastkey** method on treemap returns largest **key** in map which is a ***logarithmic*** complexity\\nNow code is self explanatory\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i=0;i<nums1.length;i++){\\n            int diff = Math.abs(nums1[i] - nums2[i]);\\n            map.put(diff,map.getOrDefault(diff,0)+1);\\n        }\\n        while(k1+k2 >0){\\n            int largest = map.lastKey();\\n            if(largest == 0) break;\\n            int toRemove = Math.min(k1+k2, map.get(largest));\\n            map.put(largest-1,map.getOrDefault(largest-1,0)+toRemove);\\n            k1 -= Math.min(k1+k2, map.get(largest));\\n            map.put(largest,map.get(largest)-toRemove);\\n            if(map.get(largest) == 0) map.remove(largest);\\n        }\\n        long result = 0;\\n        for(int key: map.keySet()){\\n            result += 1L*map.get(key)*key*key;\\n        }\\n        return result;\\n    }\\n}\\n```\\nComplexity Analysis:\\nsince, we are cosidering unique differences, worst case for that would be *n* and k1&k2 are infininite to make whole differnce 0, \\nSo, **Worst Time Complexity** turns out to be: ***O(n * logn)***\\nSimilarly **Worst Space** will be ***O( n )***\\n\\nHope that was helpful,\\nHappy LeetCoding",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i=0;i<nums1.length;i++){\\n            int diff = Math.abs(nums1[i] - nums2[i]);\\n            map.put(diff,map.getOrDefault(diff,0)+1);\\n        }\\n        while(k1+k2 >0){\\n            int largest = map.lastKey();\\n            if(largest == 0) break;\\n            int toRemove = Math.min(k1+k2, map.get(largest));\\n            map.put(largest-1,map.getOrDefault(largest-1,0)+toRemove);\\n            k1 -= Math.min(k1+k2, map.get(largest));\\n            map.put(largest,map.get(largest)-toRemove);\\n            if(map.get(largest) == 0) map.remove(largest);\\n        }\\n        long result = 0;\\n        for(int key: map.keySet()){\\n            result += 1L*map.get(key)*key*key;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260318,
                "title": "java-solution-faster-than-100-java-submissions-with-comments",
                "content": "**Basic Idea**\\nFirst of all, incrementing a number by 1 or decrementing other number by 1 will lead to the same difference. So the basic idea is to decrement the number with highest difference value so that the value of it\\'s square will be decreased.\\n\\n**BruteForce SOLUTION**\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            int diff = Math.abs(nums1[i] - nums2[i]);\\n            pq.add(diff);\\n        }\\n        int tot = k1 + k2;\\n        while(tot > 0 && pq.size() > 0){\\n                int top = pq.remove();\\n            if(top == 0) continue;\\n                top--;\\n            if(top != 0)\\n                pq.add(top);\\n                tot--;\\n        }\\n        long ans = 0;\\n        while(pq.size() != 0){\\n            int top = pq.remove();\\n            ans += (top * top);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nSo in bruteforce solution we observed that decrementing the difference one by one will give us a TLE, so we have to optimise this step. How about we keep an array of freq, which will tell us how many number of times a particular diff occured, and then we will decrease it\\'s frequency as per the number of operations left because you will not choose a number (x - 1) to decrease until a number x will exist in the array. Let\\'s try to code this\\n**OPTIMAL SOLUTION** \\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = 100000; // maximum length of nums1[i] or nums2[i]\\n        int[] count = new int[n + 1]; // create an array to store freq of absolute diff of nums1[i] && nums2[i]\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            count[Math.abs(nums1[i] - nums2[i])]++; // create freq array\\n        }\\n        int op = k1 + k2; // total number of operations allowed\\n\\t\\t\\n\\t\\t// traverse from last to starting so that you encounter max value first and perform operations on them first\\n        for(int diff = n ; diff > 0 ; diff--){\\n\\t\\t// there will be three cases\\n\\t\\t// 1. count[i] = 0 means that number appeared 0 times so continue from there\\n\\t\\t// 2. count[i] i.e the freq of current no is less than the operations left\\n\\t\\t// in that case increment the freq of current number in the freq of current \\n\\t\\t//number - 1, because we will not perform any operation on number x - 1 \\n\\t\\t//until x exists.\\n\\t\\t// 3.if count[i] i.e the freq of current number is greater than the operations left,\\n\\t\\t//simply increment the freq of operations in the freq of current number  - 1, as\\n\\t\\t//we can only perform operartions  \"op\" no of times. Now operations left will be zero so simply break;\\n            if(count[diff] == 0) continue;\\n            if(op >= count[diff]){\\n                count[diff - 1] += count[diff];\\n                op -= count[diff];\\n                count[diff] = 0;\\n            }else{\\n                count[diff - 1] += op;\\n                count[diff] -= op;\\n                op = 0;\\n                break;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// now traverse the freq array and create your answer by squaring the  number and \\n\\t\\t//multiplying it with it\\'s freq, that is, how many number of times that particular number occured.\\n        long ans = 0;\\n        for(int j = 1 ; j <= n ; j++){\\n            if(count[j] != 0) ans += (long)j * j * count[j];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            int diff = Math.abs(nums1[i] - nums2[i]);\\n            pq.add(diff);\\n        }\\n        int tot = k1 + k2;\\n        while(tot > 0 && pq.size() > 0){\\n                int top = pq.remove();\\n            if(top == 0) continue;\\n                top--;\\n            if(top != 0)\\n                pq.add(top);\\n                tot--;\\n        }\\n        long ans = 0;\\n        while(pq.size() != 0){\\n            int top = pq.remove();\\n            ans += (top * top);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = 100000; // maximum length of nums1[i] or nums2[i]\\n        int[] count = new int[n + 1]; // create an array to store freq of absolute diff of nums1[i] && nums2[i]\\n        for(int i = 0 ; i < nums1.length ; i++){\\n            count[Math.abs(nums1[i] - nums2[i])]++; // create freq array\\n        }\\n        int op = k1 + k2; // total number of operations allowed\\n\\t\\t\\n\\t\\t// traverse from last to starting so that you encounter max value first and perform operations on them first\\n        for(int diff = n ; diff > 0 ; diff--){\\n\\t\\t// there will be three cases\\n\\t\\t// 1. count[i] = 0 means that number appeared 0 times so continue from there\\n\\t\\t// 2. count[i] i.e the freq of current no is less than the operations left\\n\\t\\t// in that case increment the freq of current number in the freq of current \\n\\t\\t//number - 1, because we will not perform any operation on number x - 1 \\n\\t\\t//until x exists.\\n\\t\\t// 3.if count[i] i.e the freq of current number is greater than the operations left,\\n\\t\\t//simply increment the freq of operations in the freq of current number  - 1, as\\n\\t\\t//we can only perform operartions  \"op\" no of times. Now operations left will be zero so simply break;\\n            if(count[diff] == 0) continue;\\n            if(op >= count[diff]){\\n                count[diff - 1] += count[diff];\\n                op -= count[diff];\\n                count[diff] = 0;\\n            }else{\\n                count[diff - 1] += op;\\n                count[diff] -= op;\\n                op = 0;\\n                break;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// now traverse the freq array and create your answer by squaring the  number and \\n\\t\\t//multiplying it with it\\'s freq, that is, how many number of times that particular number occured.\\n        long ans = 0;\\n        for(int j = 1 ; j <= n ; j++){\\n            if(count[j] != 0) ans += (long)j * j * count[j];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259403,
                "title": "sort-abs-in-reverse-scan-count",
                "content": "A little math shows that we want to give priority to reducing the largest absolute difference. So, sort the absolue differences in reverse and go through them one by one while keeping track of the `count` and the remaining allowance of `k` as we try to reduce all the prior differences to the current value. Break out of the loop once `k` is no longer large enough.\\n\\nThe differences beyond `count` will be unchanged. If there is any `k` left, distribute them as evenly as possible by using `divmod()`. Time O(nlogn), Space O(n).\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = sorted((abs(x - y) for x, y in zip(nums1, nums2)), reverse=True)\\n        n = len(nums1)\\n        k = k1 + k2\\n        count = 0\\n        curr = diff[0]\\n        while count < n and k >= count * (curr - diff[count]):\\n            k -= count * (curr - diff[count])\\n            curr = diff[count]\\n            count += 1\\n        div, mod = divmod(k, count)\\n        return sum(d ** 2 for d in diff[count:]) + (count - mod) * max(0, curr - div) ** 2 + mod * max(0, curr - div - 1) ** 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = sorted((abs(x - y) for x, y in zip(nums1, nums2)), reverse=True)\\n        n = len(nums1)\\n        k = k1 + k2\\n        count = 0\\n        curr = diff[0]\\n        while count < n and k >= count * (curr - diff[count]):\\n            k -= count * (curr - diff[count])\\n            curr = diff[count]\\n            count += 1\\n        div, mod = divmod(k, count)\\n        return sum(d ** 2 for d in diff[count:]) + (count - mod) * max(0, curr - div) ** 2 + mod * max(0, curr - div - 1) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690251,
                "title": "java-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int k = k1 + k2;\\n        int[] nums = new int[nums1.length+1];\\n        for(int i=0;i<nums1.length;i++) {\\n            nums[i+1] = absolute(nums1[i],nums2[i]);\\n        }\\n        Arrays.sort(nums);\\n        int sum = 0, i = nums.length-2;\\n        while(i>=0) {\\n            int curr = (nums[i+1] - nums[i]) * (nums.length - 1 - i);\\n            sum += curr;\\n            if(sum >= k) {\\n                break;\\n            }\\n            i--;\\n        }\\n        if(sum < k) return 0;\\n        int j = 1;\\n        sum -= k;\\n        int q = sum/(nums.length - i - 1);\\n        int mod = sum % (nums.length - i - 1);\\n        long abs = 0;\\n        while(j <= i) {\\n            abs += ((long)nums[j] * nums[j]);\\n            j++;\\n        }\\n        while(j < nums.length) {\\n            long val = nums[i] + q;\\n            if(mod > 0) {\\n                val += 1;\\n                mod--;\\n            }\\n            abs += (val * val);\\n            j++;\\n        }\\n        return abs;\\n    }\\n\\n    private int absolute(int num1, int num2) {\\n        return num1 < num2 ? num2 - num1: num1 - num2;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int k = k1 + k2;\\n        int[] nums = new int[nums1.length+1];\\n        for(int i=0;i<nums1.length;i++) {\\n            nums[i+1] = absolute(nums1[i],nums2[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2935309,
                "title": "another-method-o-10-5-other-than-bucket-sort-and-queue",
                "content": "```\\nclass Solution {\\npublic:\\n\\n\\n   const int N = 1e5;\\n   \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\n        vector<int> count(N+1, 0);\\n        for (int j = 0; j < nums1.size(); j ++) {\\n            count[abs(nums1[j] - nums2[j])] ++;\\n        }\\n        \\n        int operations = k1+k2;\\n        for (int i = N; i > 0; i --) {\\n            if (count[i] == 0) continue;\\n            \\n            if (operations >= count[i]) {\\n                count[i-1] += count[i];\\n                operations -= count[i];\\n                count[i] = 0;\\n            }\\n            else {\\n                count[i-1] += operations;\\n                count[i] -= operations;\\n                operations = 0;\\n                break;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (long long j = 1; j <= N; j ++) \\n            if (count[j] > 0) ans += j*j*count[j];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n   const int N = 1e5;\\n   \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\n        vector<int> count(N+1, 0);\\n        for (int j = 0; j < nums1.size(); j ++) {\\n            count[abs(nums1[j] - nums2[j])] ++;\\n        }\\n        \\n        int operations = k1+k2;\\n        for (int i = N; i > 0; i --) {\\n            if (count[i] == 0) continue;\\n            \\n            if (operations >= count[i]) {\\n                count[i-1] += count[i];\\n                operations -= count[i];\\n                count[i] = 0;\\n            }\\n            else {\\n                count[i-1] += operations;\\n                count[i] -= operations;\\n                operations = 0;\\n                break;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (long long j = 1; j <= N; j ++) \\n            if (count[j] > 0) ans += j*j*count[j];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303338,
                "title": "minimum-sum-of-squared-difference-java-solution",
                "content": "# Java Solution using HashMap\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long ans=0;\\n        //Creating a hashmap\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums1.length;i++){\\n            //Absolute difference between pair of values\\n            int b=Math.abs(nums1[i]-nums2[i]);\\n            //Updating the frequency of the absolute difference in hashmap\\n            map.put(b,map.getOrDefault(b,0)+1);\\n            //Adding the square of absolute difference to ans variable\\n            ans+=1L*b*b;\\n            //Updating the max value\\n            max=max<b?b:max;\\n        }\\n        //Taking sum of no. of modification allowed as modification could be made on any number among a pair of number\\n        int total=k1+k2;\\n        //While loop runs until no. of modifications left>0 and absoluediffernce>0\\n        while(total>0 && max>0){\\n            //Checking if map contains any frequency of that absolute differnce \\n            if(map.getOrDefault(max,0)>0){\\n                int count=map.get(max);\\n                //If total>count, all frequency of that absolute difference could be reduced by 1\\n                if(total>=count){\\n                    //Updating ans variable\\n                    ans-=1L*count*((max*max)-((max-1)*(max-1)));\\n                    map.remove(max);\\n                    map.put(max-1,map.getOrDefault(max-1,0)+count);\\n                    total-=count;\\n                }\\n                //All frequency of abolute difference could not be reduce by 1 so reducing permitted frequency of abolute differnce by 1 and returning ans\\n                else{\\n                    ans-=1L*total*((max*max)-((max-1)*(max-1)));\\n                    map.put(max-1,map.getOrDefault(max,0)-total);\\n                    map.put(max-1,map.getOrDefault(max-1,0)+total);\\n                    return ans;\\n                }\\n            }\\n            max--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long ans=0;\\n        //Creating a hashmap\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums1.length;i++){\\n            //Absolute difference between pair of values\\n            int b=Math.abs(nums1[i]-nums2[i]);\\n            //Updating the frequency of the absolute difference in hashmap\\n            map.put(b,map.getOrDefault(b,0)+1);\\n            //Adding the square of absolute difference to ans variable\\n            ans+=1L*b*b;\\n            //Updating the max value\\n            max=max<b?b:max;\\n        }\\n        //Taking sum of no. of modification allowed as modification could be made on any number among a pair of number\\n        int total=k1+k2;\\n        //While loop runs until no. of modifications left>0 and absoluediffernce>0\\n        while(total>0 && max>0){\\n            //Checking if map contains any frequency of that absolute differnce \\n            if(map.getOrDefault(max,0)>0){\\n                int count=map.get(max);\\n                //If total>count, all frequency of that absolute difference could be reduced by 1\\n                if(total>=count){\\n                    //Updating ans variable\\n                    ans-=1L*count*((max*max)-((max-1)*(max-1)));\\n                    map.remove(max);\\n                    map.put(max-1,map.getOrDefault(max-1,0)+count);\\n                    total-=count;\\n                }\\n                //All frequency of abolute difference could not be reduce by 1 so reducing permitted frequency of abolute differnce by 1 and returning ans\\n                else{\\n                    ans-=1L*total*((max*max)-((max-1)*(max-1)));\\n                    map.put(max-1,map.getOrDefault(max,0)-total);\\n                    map.put(max-1,map.getOrDefault(max-1,0)+total);\\n                    return ans;\\n                }\\n            }\\n            max--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260244,
                "title": "c-soln-with-complexity-analysis",
                "content": "```\\nclass Solution { \\npublic: \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) { \\n        unsigned long long int res = 0;\\n        vector<int> difference_freq(100002, 0); //store the count of every difference, maximum difference can be 10^5 so we take size of vector for safe side 100002\\n        for (int i=0; i<nums1.size(); i++){ \\n            difference_freq[abs(nums1[i]-nums2[i])]++;  \\n        } \\n \\n        int moves = k1+k2; \\n        for (int i=difference_freq.size()-1; i>0; i--){ //iterate from end to decrease the largest deifference because larger difference create more impact on result \\n            if (moves >difference_freq[i]){ //reduce all differnce by 1 \\n                difference_freq[i-1] += difference_freq[i]; \\n                moves -= difference_freq[i]; \\n                difference_freq[i]=0; \\n            }\\n            else{ \\n                difference_freq[i-1]+=moves; \\n                difference_freq[i]-=moves; \\n                moves=0; \\n                break; \\n            } \\n        } \\n\\n        for (long long int i=1; i<difference_freq.size(); i++){ \\n            unsigned long long ans=0; \\n            if (difference_freq[i] !=0){ \\n                ans=i*i; \\n                ans*=difference_freq[i]; \\n            } \\n            res+=ans; \\n        } \\n        return res; \\n    } \\n};\\n```\\n\\n**T.C---> O(100002) for memset function + O(N) for updating difference_freq vector + O(100002) for traversal**.\\n\\n**T.C--->O(100002+N+100002) ~= O(N)**\\n    \\n**S.C---> O(100002)**    \\n\\nPlease correct me in comments if I missed something in complexity analysis.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution { \\npublic: \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) { \\n        unsigned long long int res = 0;\\n        vector<int> difference_freq(100002, 0); //store the count of every difference, maximum difference can be 10^5 so we take size of vector for safe side 100002\\n        for (int i=0; i<nums1.size(); i++){ \\n            difference_freq[abs(nums1[i]-nums2[i])]++;  \\n        } \\n \\n        int moves = k1+k2; \\n        for (int i=difference_freq.size()-1; i>0; i--){ //iterate from end to decrease the largest deifference because larger difference create more impact on result \\n            if (moves >difference_freq[i]){ //reduce all differnce by 1 \\n                difference_freq[i-1] += difference_freq[i]; \\n                moves -= difference_freq[i]; \\n                difference_freq[i]=0; \\n            }\\n            else{ \\n                difference_freq[i-1]+=moves; \\n                difference_freq[i]-=moves; \\n                moves=0; \\n                break; \\n            } \\n        } \\n\\n        for (long long int i=1; i<difference_freq.size(); i++){ \\n            unsigned long long ans=0; \\n            if (difference_freq[i] !=0){ \\n                ans=i*i; \\n                ans*=difference_freq[i]; \\n            } \\n            res+=ans; \\n        } \\n        return res; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260021,
                "title": "bucket-sort-simple-and-easy-solution-o-n",
                "content": "# <---UPVOTE ME IF YOU LIKE THE SOLUTION \\nApproach : \\n* while solving this problem we are facing main problem of decreasing the value of our maximum diffirence one by one \\n* Due to this problem we are facing time limit exceed problem \\n* To tackle this problem I have created array of size maximum gap and in this array I have store the frequency of gap that is for how many times this gap is occur.\\n* Index of array represent gap and its value represent count of that gap \\n* By using this technique insted of removing value one by one we can remove it by occurrence of the gap \\n* after removing occurrence count from gap index in array we decrease the frequency of that gap array and increase the frequency of gap - 1 index in array because if we decrease gap of 4 it means that we have now increase gap of 3 by simply removing 1 from each gap size of 4\\n* I have travel in that gap frequency array in reverse order so that I am decreasing the highest effecting value first\\n* In this approach due to bucket sort I don\\'t need to sort the gap in descending order\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n\\n\\t\\t\\t\\tn = len(nums1)\\n\\n\\t\\t\\t\\tgap = [abs(nums1[i] - nums2[i]) for i in range(n)]\\n\\n\\t\\t\\t\\tm = max(gap) + 1\\n\\t\\t\\t\\tfrq = [0] * m\\n\\n\\t\\t\\t\\tfor value in gap:\\n\\t\\t\\t\\t\\tfrq[value] += 1\\n\\n\\t\\t\\t\\tmoves = k1 + k2\\n\\n\\t\\t\\t\\tfor i in range (m-1, 0, -1):\\n\\n\\t\\t\\t\\t\\tif frq[i] > 0 and moves >= frq[i]:\\n\\t\\t\\t\\t\\t\\tmoves -= frq[i]\\n\\t\\t\\t\\t\\t\\tfrq[i-1] += frq[i]\\n\\t\\t\\t\\t\\t\\tfrq[i] = 0\\n\\n\\t\\t\\t\\t\\telif frq[i] > 0 and moves < frq[i]:\\n\\t\\t\\t\\t\\t\\tfrq[i-1] += moves \\n\\t\\t\\t\\t\\t\\tfrq[i] -= moves\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\treturn sum(i * i * frq[i] for i in range(m))",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "# <---UPVOTE ME IF YOU LIKE THE SOLUTION \\nApproach : \\n* while solving this problem we are facing main problem of decreasing the value of our maximum diffirence one by one \\n* Due to this problem we are facing time limit exceed problem \\n* To tackle this problem I have created array of size maximum gap and in this array I have store the frequency of gap that is for how many times this gap is occur.\\n* Index of array represent gap and its value represent count of that gap \\n* By using this technique insted of removing value one by one we can remove it by occurrence of the gap \\n* after removing occurrence count from gap index in array we decrease the frequency of that gap array and increase the frequency of gap - 1 index in array because if we decrease gap of 4 it means that we have now increase gap of 3 by simply removing 1 from each gap size of 4\\n* I have travel in that gap frequency array in reverse order so that I am decreasing the highest effecting value first\\n* In this approach due to bucket sort I don\\'t need to sort the gap in descending order\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n\\n\\t\\t\\t\\tn = len(nums1)\\n\\n\\t\\t\\t\\tgap = [abs(nums1[i] - nums2[i]) for i in range(n)]\\n\\n\\t\\t\\t\\tm = max(gap) + 1\\n\\t\\t\\t\\tfrq = [0] * m\\n\\n\\t\\t\\t\\tfor value in gap:\\n\\t\\t\\t\\t\\tfrq[value] += 1\\n\\n\\t\\t\\t\\tmoves = k1 + k2\\n\\n\\t\\t\\t\\tfor i in range (m-1, 0, -1):\\n\\n\\t\\t\\t\\t\\tif frq[i] > 0 and moves >= frq[i]:\\n\\t\\t\\t\\t\\t\\tmoves -= frq[i]\\n\\t\\t\\t\\t\\t\\tfrq[i-1] += frq[i]\\n\\t\\t\\t\\t\\t\\tfrq[i] = 0\\n\\n\\t\\t\\t\\t\\telif frq[i] > 0 and moves < frq[i]:\\n\\t\\t\\t\\t\\t\\tfrq[i-1] += moves \\n\\t\\t\\t\\t\\t\\tfrq[i] -= moves\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\treturn sum(i * i * frq[i] for i in range(m))",
                "codeTag": "Java"
            },
            {
                "id": 2259912,
                "title": "python-priority-queue-heap",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        max_heap = []\\n        res = 0\\n        \\n        for i in range(n):\\n            diff = abs(nums1[i] - nums2[i])\\n            res += (diff ** 2)\\n            \\n            heapq.heappush(max_heap, -diff)\\n        \\n        subtractions = k1+k2\\n        while subtractions > 0 and max_heap and max_heap[0] != 0:\\n            biggest_diff = -heapq.heappop(max_heap)\\n            \\n            res -= (biggest_diff ** 2)\\n            delta = max(subtractions // n, 1)\\n            \\n            if delta > biggest_diff:\\n                delta = biggest_diff\\n           \\n            new_diff = (biggest_diff - delta)\\n            res += (new_diff ** 2)\\n            \\n            heapq.heappush(max_heap, -new_diff)\\n            subtractions -= delta\\n            \\n        return res\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        max_heap = []\\n        res = 0\\n        \\n        for i in range(n):\\n            diff = abs(nums1[i] - nums2[i])\\n            res += (diff ** 2)\\n            \\n            heapq.heappush(max_heap, -diff)\\n        \\n        subtractions = k1+k2\\n        while subtractions > 0 and max_heap and max_heap[0] != 0:\\n            biggest_diff = -heapq.heappop(max_heap)\\n            \\n            res -= (biggest_diff ** 2)\\n            delta = max(subtractions // n, 1)\\n            \\n            if delta > biggest_diff:\\n                delta = biggest_diff\\n           \\n            new_diff = (biggest_diff - delta)\\n            res += (new_diff ** 2)\\n            \\n            heapq.heappush(max_heap, -new_diff)\\n            subtractions -= delta\\n            \\n        return res\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259438,
                "title": "easy-c-priority-queue-greedy-approach-optimized",
                "content": "```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        map<long long int,long long int> mp;\\n        long long int k=k1+k2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp[abs(nums2[i]-nums1[i])]++;\\n        }\\n        priority_queue<pair<long long int,long long int>> pq;\\n        long long int sum=0;\\n        for(auto itr:mp)\\n        {\\n            pq.push({itr.first,itr.second});\\n            sum+=(itr.first*itr.second);\\n        }\\n        if(k>=sum )\\n        {\\n            return 0;\\n        }\\n        pq.push({0,0});\\n        while(k>0 && !pq.empty() && pq.top().first!=0)\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            if(k>=(temp.first-pq.top().first)*temp.second)\\n            {\\n                k-=(temp.first-pq.top().first)*temp.second;\\n                auto t=pq.top();\\n                pq.pop();\\n                pq.push({t.first,temp.second+t.second});\\n            }\\n            else\\n            {\\n                long long int div=k/temp.second,rem=k%temp.second;\\n                if(temp.first-div-1==pq.top().first)\\n                {\\n                    auto t=pq.top();\\n                    pq.pop();\\n                    \\n                    pq.push({t.first,t.second+rem});\\n                    pq.push({temp.first-div,temp.second-rem});\\n                }\\n                else\\n                {\\n                    if(rem!=0)\\n                    pq.push({temp.first-div-1,rem});\\n                    pq.push({temp.first-div,temp.second-rem});\\n                }\\n                k=0;\\n            }\\n        }\\n        long long ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=((pq.top().first*pq.top().first)*pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        map<long long int,long long int> mp;\\n        long long int k=k1+k2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp[abs(nums2[i]-nums1[i])]++;\\n        }\\n        priority_queue<pair<long long int,long long int>> pq;\\n        long long int sum=0;\\n        for(auto itr:mp)\\n        {\\n            pq.push({itr.first,itr.second});\\n            sum+=(itr.first*itr.second);\\n        }\\n        if(k>=sum )\\n        {\\n            return 0;\\n        }\\n        pq.push({0,0});\\n        while(k>0 && !pq.empty() && pq.top().first!=0)\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            if(k>=(temp.first-pq.top().first)*temp.second)\\n            {\\n                k-=(temp.first-pq.top().first)*temp.second;\\n                auto t=pq.top();\\n                pq.pop();\\n                pq.push({t.first,temp.second+t.second});\\n            }\\n            else\\n            {\\n                long long int div=k/temp.second,rem=k%temp.second;\\n                if(temp.first-div-1==pq.top().first)\\n                {\\n                    auto t=pq.top();\\n                    pq.pop();\\n                    \\n                    pq.push({t.first,t.second+rem});\\n                    pq.push({temp.first-div,temp.second-rem});\\n                }\\n                else\\n                {\\n                    if(rem!=0)\\n                    pq.push({temp.first-div-1,rem});\\n                    pq.push({temp.first-div,temp.second-rem});\\n                }\\n                k=0;\\n            }\\n        }\\n        long long ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=((pq.top().first*pq.top().first)*pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259437,
                "title": "c-priority-queue-with-map",
                "content": "When k is very small it can be easily solved by subtracting 1 from difference of both array from maximum element\\nAs K<10e9 \\nWe can store the freq of all differences and it is always optimal to remove the maximum number(upadating the map also) until k become Zero or all differnce reach to Zero\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll ans=0;\\n        int n=nums1.size();\\n        priority_queue<ll>pq;\\n        map<ll,ll>mp;\\n        ll res=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            nums1[i]=abs(nums1[i]-nums2[i]);\\n            res+=nums1[i];\\n            \\n            if(mp[nums1[i]]==0)\\n            pq.push(nums1[i]);\\n            \\n            mp[nums1[i]]++;          \\n        }\\n        \\n        int k=k1+k2;\\n    \\n        while(k>0)\\n        {\\n            //cout<<pq.size()<<endl;\\n            if(!pq.empty())\\n            {\\n                int fir=pq.top();\\n                pq.pop();\\n                \\n                //cout<<fir<<endl;\\n                \\n                int freq=mp[fir];\\n                \\n                if(!pq.empty())\\n                {\\n                    int sec=pq.top();\\n                    \\n                    int move=(fir-sec)*freq;\\n                    if(move<=k)\\n                    {\\n                        k=k-move;\\n                        mp.erase(fir);\\n                        mp[sec]+=freq;\\n                    }\\n                    else\\n                    {\\n                        int drop=k/freq;\\n                        int oneless=k%freq;\\n                        \\n                        mp.erase(fir);\\n                        \\n                        int l=max(0,fir-drop);\\n                        int r=max(0,fir-drop-1);\\n                        \\n                        mp[l]+=freq-oneless;\\n                        mp[r]+=oneless;\\n                        \\n                        k=0;\\n                    }\\n                }\\n                else\\n                {\\n                    int drop=k/freq;\\n                    int oneless=k%freq;\\n                    \\n                    mp.erase(fir);\\n                    \\n                    int l=max(0,fir-drop);\\n                    int r=max(0,fir-drop-1);\\n                        \\n                    mp[l]+=freq-oneless;\\n                    mp[r]+=oneless;\\n                    \\n                    k=0;\\n                }\\n            }\\n            else\\n                break;\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            //cout<<it.first<<\" \"<<it.second<<endl;\\n            ans+=1LL*(it.second)*(it.first)*(it.first);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll ans=0;\\n        int n=nums1.size();\\n        priority_queue<ll>pq;\\n        map<ll,ll>mp;\\n        ll res=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            nums1[i]=abs(nums1[i]-nums2[i]);\\n            res+=nums1[i];\\n            \\n            if(mp[nums1[i]]==0)\\n            pq.push(nums1[i]);\\n            \\n            mp[nums1[i]]++;          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2259421,
                "title": "only-priority-queue-c-o-nlogn-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue <long long> pq;\\n        int n=nums1.size();\\n        long long k=k1+k2;\\n        \\n        for(int i=0;i<n;i++){\\n            pq.push(abs(nums1[i]-nums2[i]));\\n        }\\n\\n        long long c=1;\\n        long long ans=0;\\n        while(!pq.empty()){\\n            if(pq.size()==1){\\n                long long p=pq.top();\\n                if(1LL*c*p<=k){\\n                    k-=(1LL*c*p);\\n                    ans=0;\\n                }\\n                else{\\n                    long long whole=(k/c);\\n                    long long remaining=k%c;\\n                    p-=whole;\\n                    ans+=(p-1)*1LL*(p-1)*(remaining);\\n                    ans+=(1LL*p*p*(c-remaining));\\n                }\\n                pq.pop();\\n            }\\n            else{\\n                long long p=pq.top();\\n                pq.pop();\\n                long long q=pq.top();\\n                if(c*1LL*(p-q)<=k){\\n                    k-=c*1LL*(p-q);\\n                    c++;\\n                }\\n                else{\\n                    long long whole=(k/c);\\n                    long long remaining=k%c;\\n                    p-=whole;\\n                    ans+=(p-1)*1LL*(p-1)*remaining;\\n                    ans+=1LL*p*p*(c-remaining);\\n                    while(!pq.empty()){\\n                        long long kk=pq.top();\\n                        ans+=kk*kk*1LL;\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue <long long> pq;\\n        int n=nums1.size();\\n        long long k=k1+k2;\\n        \\n        for(int i=0;i<n;i++){\\n            pq.push(abs(nums1[i]-nums2[i]));\\n        }\\n\\n        long long c=1;\\n        long long ans=0;\\n        while(!pq.empty()){\\n            if(pq.size()==1){\\n                long long p=pq.top();\\n                if(1LL*c*p<=k){\\n                    k-=(1LL*c*p);\\n                    ans=0;\\n                }\\n                else{\\n                    long long whole=(k/c);\\n                    long long remaining=k%c;\\n                    p-=whole;\\n                    ans+=(p-1)*1LL*(p-1)*(remaining);\\n                    ans+=(1LL*p*p*(c-remaining));\\n                }\\n                pq.pop();\\n            }\\n            else{\\n                long long p=pq.top();\\n                pq.pop();\\n                long long q=pq.top();\\n                if(c*1LL*(p-q)<=k){\\n                    k-=c*1LL*(p-q);\\n                    c++;\\n                }\\n                else{\\n                    long long whole=(k/c);\\n                    long long remaining=k%c;\\n                    p-=whole;\\n                    ans+=(p-1)*1LL*(p-1)*remaining;\\n                    ans+=1LL*p*p*(c-remaining);\\n                    while(!pq.empty()){\\n                        long long kk=pq.top();\\n                        ans+=kk*kk*1LL;\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259399,
                "title": "c-simple-binary-search-is-enough-with-explaination",
                "content": "**KEY CONCEPT**\\n- Sort the vector of `diff[i] = num1[i] - nums2[i]` for all `i`\\n- The search range is `0` to `diff[-1]`.\\n- You have `K = k1 + k2` to reduce each element in `diff`.\\n- Use binary search to find a target value that can be reduced from `diff`. (i.e., max(diff[:]) = target)\\n- If there are remaining `K`, use it!\\n```\\nclass Solution {\\npublic:\\n\\t// whether make each num -> tobe is acceptable\\n    bool criteria(vector<long long>& diff, long long tobe, long long maxCount) {\\n        long long count = 0;\\n        for (auto& num : diff) {\\n            if (num > tobe) count += (num - tobe);\\n        }\\n        return count <= maxCount;\\n    }\\n\\t// to make each num -> tobe, # of k should be used\\n    long long remainConut(vector<long long>& diff, long long tobe, long long maxCount) {\\n        long long count = 0;\\n        for (auto& num : diff) {\\n            if (num > tobe) count += (num - tobe);\\n        }\\n        return maxCount - count;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<long long> diff(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        sort(diff.begin(), diff.end());\\n        long long left = 0;\\n        long long right = diff[diff.size() - 1];\\n\\t\\t// do not care about where k comes from\\n        long long K = k1 + k2;\\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (criteria(diff, mid, K)) right = mid;\\n            else left = mid + 1;\\n        }\\n\\t\\t// if there are remain ks, use it!\\n        long long remainK = remainConut(diff, left, K);\\n        if (left == 0) return 0;\\n        long long res = 0;\\n        for (auto& num : diff) {\\n            if (num >= left) {\\n                if (remainK) {\\n                    res += (left - 1) * (left - 1);\\n                    remainK--;\\n                }\\n                else {\\n                    res += left * left;\\n                }                \\n            }\\n            else res += num * num;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// whether make each num -> tobe is acceptable\\n    bool criteria(vector<long long>& diff, long long tobe, long long maxCount) {\\n        long long count = 0;\\n        for (auto& num : diff) {\\n            if (num > tobe) count += (num - tobe);\\n        }\\n        return count <= maxCount;\\n    }\\n\\t// to make each num -> tobe, # of k should be used\\n    long long remainConut(vector<long long>& diff, long long tobe, long long maxCount) {\\n        long long count = 0;\\n        for (auto& num : diff) {\\n            if (num > tobe) count += (num - tobe);\\n        }\\n        return maxCount - count;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<long long> diff(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            diff[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        sort(diff.begin(), diff.end());\\n        long long left = 0;\\n        long long right = diff[diff.size() - 1];\\n\\t\\t// do not care about where k comes from\\n        long long K = k1 + k2;\\n        while (left < right) {\\n            long long mid = left + (right - left) / 2;\\n            if (criteria(diff, mid, K)) right = mid;\\n            else left = mid + 1;\\n        }\\n\\t\\t// if there are remain ks, use it!\\n        long long remainK = remainConut(diff, left, K);\\n        if (left == 0) return 0;\\n        long long res = 0;\\n        for (auto& num : diff) {\\n            if (num >= left) {\\n                if (remainK) {\\n                    res += (left - 1) * (left - 1);\\n                    remainK--;\\n                }\\n                else {\\n                    res += left * left;\\n                }                \\n            }\\n            else res += num * num;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259348,
                "title": "c-binary-search-bucketsort-explained",
                "content": "Solution 1: Binary Seach\\n* create diff[] then sort it\\n* find the max-diff that all diffs >max-diff can be changed to max-diff\\n* Notice that there may still some max-diff can minus 1  \\n\\n```\\n        public long MinSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2)\\n        {\\n            int n = nums1.Length;\\n            long[] arr = new long[n];// abs(nums1[i]-nums2[i])\\n            for(int i = 0; i < n; i++)\\n            {\\n                arr[i] = Math.Abs(nums1[i] - nums2[i]);\\n            }\\n            Array.Sort(arr);//sort ascending\\n            long left = 0;\\n            long right = arr[n-1];\\n\\t\\t\\t//using binary search to find the left value that all arr[i]>left can be changed to left\\n            while (left < right)\\n            {\\n                long mid = (left + right)/ 2;\\n                long k = 0;\\n                for(int i = n - 1; i >= 0; i--)\\n                {\\n                    if (k > k1 + k2) break;\\n                    if (arr[i] > mid)\\n                    {\\n                        k += arr[i] - mid;\\n                    }\\n                    else break;\\n                }\\n                if  (k <= k1 + k2)\\n                    right = mid;//this mid is available\\n                else\\n                    left = mid + 1;//not available, then +1\\n            }\\n\\n            long curr = k1 + k2;\\n            for(int i = n - 1; i >= 0 && curr>0; i--)\\n            {\\n                if (arr[i] <= left) break;\\n                var subtract = Math.Min(arr[i] - left, curr);\\n                curr -= subtract;\\n                arr[i] -= subtract;\\n            }\\n\\t\\t\\t//it may still left some k, then do subtract 1 on as many elements as possible \\n            for (int i = n - 1; i >= 0 && curr > 0; i--)\\n            {\\n                if (arr[i] <= 0) break;\\n                curr -= 1;\\n                arr[i] -= 1;\\n            }\\n            return arr.Sum(x => x * x);\\n        }\\n```\\n\\nSolution 2: BucketSort\\n* Create diff[] then sort it\\n* try loop from max-diff to 1, at each index, change minus 1 as many count as possible\\n\\n```\\n        public long MinSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2)\\n        {\\n            int n = nums1.Length;\\n            Dictionary<int, int> dict = new Dictionary<int, int>();\\n            int max = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                int diff = Math.Abs(nums1[i] - nums2[i]);\\n                max = Math.Max(max, diff);\\n                if(!dict.ContainsKey(diff))dict.Add(diff, 0);\\n                dict[diff]++;\\n            }\\n            int k = k1 + k2;\\n            for(int i = max; i >= 1 && k>0; i--)\\n            {\\n                if (!dict.ContainsKey(i) || dict[i] == 0) continue;\\n                int min = Math.Min(k, dict[i]);\\n                dict[i] -= min;\\n                k -= min;\\n                if (!dict.ContainsKey(i - 1)) dict.Add(i - 1, 0);\\n                dict[i - 1] += min;\\n            }\\n            long res = 0;\\n            foreach(var i in dict.Keys)\\n            {\\n                res += (long)dict[i] * i * i;\\n            }\\n            return res;\\n        }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n        public long MinSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2)\\n        {\\n            int n = nums1.Length;\\n            long[] arr = new long[n];// abs(nums1[i]-nums2[i])\\n            for(int i = 0; i < n; i++)\\n            {\\n                arr[i] = Math.Abs(nums1[i] - nums2[i]);\\n            }\\n            Array.Sort(arr);//sort ascending\\n            long left = 0;\\n            long right = arr[n-1];\\n\\t\\t\\t//using binary search to find the left value that all arr[i]>left can be changed to left\\n            while (left < right)\\n            {\\n                long mid = (left + right)/ 2;\\n                long k = 0;\\n                for(int i = n - 1; i >= 0; i--)\\n                {\\n                    if (k > k1 + k2) break;\\n                    if (arr[i] > mid)\\n                    {\\n                        k += arr[i] - mid;\\n                    }\\n                    else break;\\n                }\\n                if  (k <= k1 + k2)\\n                    right = mid;//this mid is available\\n                else\\n                    left = mid + 1;//not available, then +1\\n            }\\n\\n            long curr = k1 + k2;\\n            for(int i = n - 1; i >= 0 && curr>0; i--)\\n            {\\n                if (arr[i] <= left) break;\\n                var subtract = Math.Min(arr[i] - left, curr);\\n                curr -= subtract;\\n                arr[i] -= subtract;\\n            }\\n\\t\\t\\t//it may still left some k, then do subtract 1 on as many elements as possible \\n            for (int i = n - 1; i >= 0 && curr > 0; i--)\\n            {\\n                if (arr[i] <= 0) break;\\n                curr -= 1;\\n                arr[i] -= 1;\\n            }\\n            return arr.Sum(x => x * x);\\n        }\\n```\n```\\n        public long MinSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2)\\n        {\\n            int n = nums1.Length;\\n            Dictionary<int, int> dict = new Dictionary<int, int>();\\n            int max = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                int diff = Math.Abs(nums1[i] - nums2[i]);\\n                max = Math.Max(max, diff);\\n                if(!dict.ContainsKey(diff))dict.Add(diff, 0);\\n                dict[diff]++;\\n            }\\n            int k = k1 + k2;\\n            for(int i = max; i >= 1 && k>0; i--)\\n            {\\n                if (!dict.ContainsKey(i) || dict[i] == 0) continue;\\n                int min = Math.Min(k, dict[i]);\\n                dict[i] -= min;\\n                k -= min;\\n                if (!dict.ContainsKey(i - 1)) dict.Add(i - 1, 0);\\n                dict[i - 1] += min;\\n            }\\n            long res = 0;\\n            foreach(var i in dict.Keys)\\n            {\\n                res += (long)dict[i] * i * i;\\n            }\\n            return res;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587016,
                "title": "c-98-fater-than-all-easy-to-understand",
                "content": "```\\nclass solution{\\npublic:\\n #define ll long long\\n    ll k;\\n    \\n    bool ok(ll m, vector<int>& diff){\\n        ll total=0;\\n        for(auto x: diff){\\n            if(x>m) total+=x-m;\\n        }\\n        return total<=k;\\n    }\\n    \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll n=nums1.size(),l=-1,r=2*1e5+1;\\n        vector<int> diff(n);\\n        for(int i=0;i<n;i++) diff[i]=abs(nums1[i]-nums2[i]);\\n        k=(ll)(k1+k2);\\n        while(r>l+1){\\n            ll m=(l+r)>>1;\\n            if(ok(m,diff)) r=m;\\n            else l=m;\\n        }\\n        if(r==0) return 0;\\n        for(auto &x: diff){\\n            if(x>r) k-=x-r,x=r;\\n        }\\n        for(auto &x: diff){\\n            if(x>l&&k>0) x=l,k--;\\n        }\\n        ll ans=0;\\n        for(auto x: diff) ans+=(ll)x*(ll)x;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass solution{\\npublic:\\n #define ll long long\\n    ll k;\\n    \\n    bool ok(ll m, vector<int>& diff){\\n        ll total=0;\\n        for(auto x: diff){\\n            if(x>m) total+=x-m;\\n        }\\n        return total<=k;\\n    }\\n    \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll n=nums1.size(),l=-1,r=2*1e5+1;\\n        vector<int> diff(n);\\n        for(int i=0;i<n;i++) diff[i]=abs(nums1[i]-nums2[i]);\\n        k=(ll)(k1+k2);\\n        while(r>l+1){\\n            ll m=(l+r)>>1;\\n            if(ok(m,diff)) r=m;\\n            else l=m;\\n        }\\n        if(r==0) return 0;\\n        for(auto &x: diff){\\n            if(x>r) k-=x-r,x=r;\\n        }\\n        for(auto &x: diff){\\n            if(x>l&&k>0) x=l,k--;\\n        }\\n        ll ans=0;\\n        for(auto x: diff) ans+=(ll)x*(ll)x;\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2558157,
                "title": "c-o-nlog-max-arr-98-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll k;\\n    \\n    bool ok(ll m, vector<int>& diff){\\n        ll total=0;\\n        for(auto x: diff){\\n            if(x>m) total+=x-m;\\n        }\\n        return total<=k;\\n    }\\n    \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll n=nums1.size(),l=-1,r=2*1e5+1;\\n        vector<int> diff(n);\\n        for(int i=0;i<n;i++) diff[i]=abs(nums1[i]-nums2[i]);\\n        k=(ll)(k1+k2);\\n        while(r>l+1){\\n            ll m=(l+r)>>1;\\n            if(ok(m,diff)) r=m;\\n            else l=m;\\n        }\\n        if(r==0) return 0;\\n        for(auto &x: diff){\\n            if(x>r) k-=x-r,x=r;\\n        }\\n        for(auto &x: diff){\\n            if(x>l&&k>0) x=l,k--;\\n        }\\n        ll ans=0;\\n        for(auto x: diff) ans+=(ll)x*(ll)x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll k;\\n    \\n    bool ok(ll m, vector<int>& diff){\\n        ll total=0;\\n        for(auto x: diff){\\n            if(x>m) total+=x-m;\\n        }\\n        return total<=k;\\n    }\\n    \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll n=nums1.size(),l=-1,r=2*1e5+1;\\n        vector<int> diff(n);\\n        for(int i=0;i<n;i++) diff[i]=abs(nums1[i]-nums2[i]);\\n        k=(ll)(k1+k2);\\n        while(r>l+1){\\n            ll m=(l+r)>>1;\\n            if(ok(m,diff)) r=m;\\n            else l=m;\\n        }\\n        if(r==0) return 0;\\n        for(auto &x: diff){\\n            if(x>r) k-=x-r,x=r;\\n        }\\n        for(auto &x: diff){\\n            if(x>l&&k>0) x=l,k--;\\n        }\\n        ll ans=0;\\n        for(auto x: diff) ans+=(ll)x*(ll)x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309713,
                "title": "java-using-greedy-approch",
                "content": "\\n        \\n        int t[]=new int[100001];\\n        for(int i=0;i<nums1.length;i++){\\n            t[Math.abs(nums1[i]-nums2[i])]++;\\n        }\\n        int k=k1+k2;\\n        for(int i=100000;i>=1 && k>0;i--)\\n        {\\n            if(t[i]<=0)\\n                continue;\\n            else if(t[i]<=k)\\n            {\\n                t[i-1]+=t[i];\\n                k-=t[i];\\n                t[i]=0;\\n            }\\n            else\\n            {\\n                t[i-1]+=k;\\n                t[i]-=k;\\n                break;\\n\\n            }\\n        }\\n        long ans=0;\\n        for(long i=1;i<100001;i++)\\n        {\\n            while(t[(int)i]>0)\\n            {\\n                ans+=i*i;\\n                t[(int)i]--;\\n            }\\n    \\n        }\\n        return ans;\\n        \\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "\\n        \\n        int t[]=new int[100001];\\n        for(int i=0;i<nums1.length;i++){\\n            t[Math.abs(nums1[i]-nums2[i])]++;\\n        }\\n        int k=k1+k2;\\n        for(int i=100000;i>=1 && k>0;i--)\\n        {\\n            if(t[i]<=0)\\n                continue;\\n            else if(t[i]<=k)\\n            {\\n                t[i-1]+=t[i];\\n                k-=t[i];\\n                t[i]=0;\\n            }\\n            else\\n            {\\n                t[i-1]+=k;\\n                t[i]-=k;\\n                break;\\n\\n            }\\n        }\\n        long ans=0;\\n        for(long i=1;i<100001;i++)\\n        {\\n            while(t[(int)i]>0)\\n            {\\n                ans+=i*i;\\n                t[(int)i]--;\\n            }\\n    \\n        }\\n        return ans;\\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2301428,
                "title": "java-7-ms-100-faster-simple-sol-decrement-max-diffs",
                "content": "![image](https://assets.leetcode.com/users/images/40493513-d2fd-4209-be50-8e5d901f744c_1658188005.2798004.png)\\n\\n\\n\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        final int n = nums1.length;\\n        final int[] diffArr = new int[100_001];\\n        int maxDiff = 0;\\n        int totalReductions = k1 + k2;\\n        \\n        // store the diffs\\n        for (int i=0; i<n; i++) {\\n            final int diff = Math.abs(nums1[i]-nums2[i]);\\n            diffArr[diff]++;\\n            if (maxDiff < diff) maxDiff = diff;\\n        }\\n        \\n        // decrement max diffs one by one\\n        while(totalReductions > 0 && maxDiff > 0) {\\n            final int count = diffArr[maxDiff];\\n            if (count <= totalReductions) {\\n                diffArr[maxDiff-1] += diffArr[maxDiff];\\n                maxDiff--;\\n                totalReductions -= count; \\n            } else {\\n                diffArr[maxDiff] -= totalReductions;\\n                diffArr[maxDiff-1] += totalReductions;\\n                break;\\n            }\\n        }\\n        \\n        // iterate from maxDiff to 0\\n        long res = 0;\\n        while(maxDiff > 0) {\\n            res += (1L * maxDiff * maxDiff * diffArr[maxDiff]);\\n            maxDiff--;\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        final int n = nums1.length;\\n        final int[] diffArr = new int[100_001];\\n        int maxDiff = 0;\\n        int totalReductions = k1 + k2;\\n        \\n        // store the diffs\\n        for (int i=0; i<n; i++) {\\n            final int diff = Math.abs(nums1[i]-nums2[i]);\\n            diffArr[diff]++;\\n            if (maxDiff < diff) maxDiff = diff;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2278732,
                "title": "binary-search-python-solution",
                "content": "1. Store all the absolute differences in an array.\\n2. If k >= sum(arr), ans is 0. Else\\n3. Using binary search find out what can be the least possible element in our array after applying the k operations.\\n4. Now reduce all elements greater than least possible element in our array to least possible element.\\n5. If there is still some operations left (k > 0). use them to reduce the max elements.\\n6. The squared sum of the array is our result.\\n\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        store = []\\n        k = k1+k2\\n        n = len(nums1)\\n        best = 0\\n        \\n        for i in range(n):\\n            store.append(abs(nums1[i] - nums2[i]))\\n            best += abs(nums1[i] - nums2[i])*abs(nums1[i] - nums2[i])\\n        \\n        if k >= sum(store):\\n            return 0\\n        \\n        l = 0\\n        r = max(store)\\n        minPossible = r\\n        \\n        while l <= r:\\n            m = (l+r)//2\\n            \\n            c = 0\\n            current = 0\\n            \\n            for ele in store:\\n                if ele > m:\\n                    c += ele-m\\n            \\n            if c <= k:\\n                minPossible = m\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        \\n        for i, ele in enumerate(store):\\n            if ele > minPossible:\\n                k -= (ele - minPossible)\\n                store[i] = minPossible\\n        \\n        \\n        for i, ele in enumerate(store):\\n            if ele != minPossible:\\n                continue\\n            \\n            if k > 0:\\n                store[i] -= 1\\n                k -= 1\\n            else:\\n                break\\n        \\n        ans = 0\\n        for ele in store:\\n            ans += ele*ele\\n        \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        store = []\\n        k = k1+k2\\n        n = len(nums1)\\n        best = 0\\n        \\n        for i in range(n):\\n            store.append(abs(nums1[i] - nums2[i]))\\n            best += abs(nums1[i] - nums2[i])*abs(nums1[i] - nums2[i])\\n        \\n        if k >= sum(store):\\n            return 0\\n        \\n        l = 0\\n        r = max(store)\\n        minPossible = r\\n        \\n        while l <= r:\\n            m = (l+r)//2\\n            \\n            c = 0\\n            current = 0\\n            \\n            for ele in store:\\n                if ele > m:\\n                    c += ele-m\\n            \\n            if c <= k:\\n                minPossible = m\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        \\n        for i, ele in enumerate(store):\\n            if ele > minPossible:\\n                k -= (ele - minPossible)\\n                store[i] = minPossible\\n        \\n        \\n        for i, ele in enumerate(store):\\n            if ele != minPossible:\\n                continue\\n            \\n            if k > 0:\\n                store[i] -= 1\\n                k -= 1\\n            else:\\n                break\\n        \\n        ans = 0\\n        for ele in store:\\n            ans += ele*ele\\n        \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278708,
                "title": "java-solution-without-hashmap-array-used",
                "content": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int[] arr = new int[100001];\\n        for(int i=0;i<nums1.length;i++)\\n            arr[(Math.abs(nums1[i]-nums2[i]))]++;\\n        int total = k1+k2;\\n        for(int i=100000;i>0;i--){\\n            if(arr[i] == 0)\\n                continue;\\n            else{\\n                int difference = i;\\n                int count = arr[difference];\\n                if(total>=count){\\n                    arr[difference-1]+=count;\\n                    arr[difference] = 0;\\n                    total-=count;\\n                }else\\n                {\\n                    int available = total;\\n                    total = 0;\\n                    arr[difference-1]+= available;\\n                    arr[difference] = arr[i]-available;\\n                    break; // Completed. Exhaused all the decrements/increments.\\n                }\\n            }\\n        }\\n        long result = 0;\\n        for(int i=0;i<100001;i++)\\n        {\\n            if(arr[i]!=0){\\n                long current =(long) (Math.pow(i,2) * (1.0*arr[i]));\\n                result+=current;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int[] arr = new int[100001];\\n        for(int i=0;i<nums1.length;i++)\\n            arr[(Math.abs(nums1[i]-nums2[i]))]++;\\n        int total = k1+k2;\\n        for(int i=100000;i>0;i--){\\n            if(arr[i] == 0)\\n                continue;\\n            else{\\n                int difference = i;\\n                int count = arr[difference];\\n                if(total>=count){\\n                    arr[difference-1]+=count;\\n                    arr[difference] = 0;\\n                    total-=count;\\n                }else\\n                {\\n                    int available = total;\\n                    total = 0;\\n                    arr[difference-1]+= available;\\n                    arr[difference] = arr[i]-available;\\n                    break; // Completed. Exhaused all the decrements/increments.\\n                }\\n            }\\n        }\\n        long result = 0;\\n        for(int i=0;i<100001;i++)\\n        {\\n            if(arr[i]!=0){\\n                long current =(long) (Math.pow(i,2) * (1.0*arr[i]));\\n                result+=current;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271064,
                "title": "simplest-c-solution-without-priority-queue-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int> dif(1e5+1,0);\\n        \\n        for(int i=0; i<nums1.size(); i++) {\\n            dif[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        int left = k1+k2;\\n        int cur;\\n        for(int i=(1e5); i>-1; i--) {\\n            cur = dif[i];\\n            if(cur<=left) {\\n                if(i<=1) {\\n                    return 0;\\n                }\\n                \\n                dif[i-1] += dif[i];\\n                left -= dif[i];\\n                dif[i] = 0;\\n            } else {\\n                if(i==0) {\\n                    return 0;\\n                }\\n                \\n                dif[i] -= left;\\n                dif[i-1] += left;\\n                left = 0;\\n                break;\\n            }\\n        }\\n        \\n        long long int sum = 0;\\n        for(int i=0; i<=(1e5); i++) {\\n            sum += dif[i]*((long long)i*i);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int> dif(1e5+1,0);\\n        \\n        for(int i=0; i<nums1.size(); i++) {\\n            dif[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        int left = k1+k2;\\n        int cur;\\n        for(int i=(1e5); i>-1; i--) {\\n            cur = dif[i];\\n            if(cur<=left) {\\n                if(i<=1) {\\n                    return 0;\\n                }\\n                \\n                dif[i-1] += dif[i];\\n                left -= dif[i];\\n                dif[i] = 0;\\n            } else {\\n                if(i==0) {\\n                    return 0;\\n                }\\n                \\n                dif[i] -= left;\\n                dif[i-1] += left;\\n                left = 0;\\n                break;\\n            }\\n        }\\n        \\n        long long int sum = 0;\\n        for(int i=0; i<=(1e5); i++) {\\n            sum += dif[i]*((long long)i*i);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270179,
                "title": "easiest-c-solution-using-hashmap",
                "content": "First let\\'s understand the problem\\n\\n* We need to find minimum sum of squared difference\\n* For that we need to first make use of operations in such a way that differences between `nums1[i] and nums2[i]` is minimum\\n* So we will store the frequency of absolute diff between `nums1[i] and nums2[i]` and we will start decreasing highest diff\\n\\t* Let\\'s understand the above point\\n\\t\\t\\n\\t\\t`nums1 = [1,4,10,12]` and `nums2 = [5,8,6,9]`\\n\\t\\tOur diff will be `[4,4,4,3]`\\n\\t\\t\\n\\t\\tIf we store in map, it would be `4 -> 3` and `3 -> 1`\\n\\t\\tNow suppose we have `k1 = 1` and `k2 = 1` so total operations = 2\\n\\t\\t\\n\\t\\tNow if we decrease freq of 4 by 1, we have to increase freq of 3 by 1\\n\\t\\tFor example -> We know we can do either `+1` or `-1` to any number, so if we increase `nums1[0]` from 1 to 2 our new diff will be `[3,4,4,3]` \\n\\t\\t\\n\\t\\tWe will do this untill we run out of operations or our all `freq` of `diff` becomes zero\\n\\t\\t\\n* \\tAt last we will just perform square of all `keys` in the map and multiply with their freq\\n\\n```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        map<long long, long long> mp;\\n        \\n        for(int i = 0; i < nums1.size(); i++){\\n            mp[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        long long totalOperations = k1+k2;\\n        \\n        for(auto it = mp.rbegin(); it != mp.rend() and totalOperations > 0; it++){\\n            if(mp[it->first] < 0) continue;\\n            long long _min = min(it->second, totalOperations);\\n            mp[it->first] -= _min;\\n            mp[it->first-1] += _min;\\n            totalOperations -= _min;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        for(auto it: mp) {\\n            if(it.first < 0 or it.second == 0) continue;\\n            ans += it.first*it.first*it.second;\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\t\\t\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        map<long long, long long> mp;\\n        \\n        for(int i = 0; i < nums1.size(); i++){\\n            mp[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        long long totalOperations = k1+k2;\\n        \\n        for(auto it = mp.rbegin(); it != mp.rend() and totalOperations > 0; it++){\\n            if(mp[it->first] < 0) continue;\\n            long long _min = min(it->second, totalOperations);\\n            mp[it->first] -= _min;\\n            mp[it->first-1] += _min;\\n            totalOperations -= _min;\\n        }\\n        \\n        long long ans = 0;\\n        \\n        for(auto it: mp) {\\n            if(it.first < 0 or it.second == 0) continue;\\n            ans += it.first*it.first*it.second;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2270106,
                "title": "python3-priority-queue",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/04944f0a6a1f4d50ee6efd64fabfc227724cdc7a) for solutions of biweekly 82. \\n\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        freq = Counter(abs(x1-x2) for x1, x2 in zip(nums1, nums2) if x1 != x2)\\n        pq = [(-k, v) for k, v in freq.items()]\\n        heapify(pq)\\n        k1 += k2\\n        while pq and k1: \\n            x, v = heappop(pq)\\n            if pq: xx, vv = heappop(pq)\\n            else: xx = vv = 0\\n            diff = xx - x\\n            if diff * v <= k1: \\n                k1 -= diff * v \\n                if vv: heappush(pq, (xx, v+vv))\\n            else: \\n                q, r = divmod(k1, v)\\n                k1 = 0\\n                heappush(pq, (x+q+1, r))\\n                heappush(pq, (x+q, v-r))\\n                if vv: heappush(pq, (xx, vv))\\n        return sum(x*x*v for x, v in pq)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        freq = Counter(abs(x1-x2) for x1, x2 in zip(nums1, nums2) if x1 != x2)\\n        pq = [(-k, v) for k, v in freq.items()]\\n        heapify(pq)\\n        k1 += k2\\n        while pq and k1: \\n            x, v = heappop(pq)\\n            if pq: xx, vv = heappop(pq)\\n            else: xx = vv = 0\\n            diff = xx - x\\n            if diff * v <= k1: \\n                k1 -= diff * v \\n                if vv: heappush(pq, (xx, v+vv))\\n            else: \\n                q, r = divmod(k1, v)\\n                k1 = 0\\n                heappush(pq, (x+q+1, r))\\n                heappush(pq, (x+q, v-r))\\n                if vv: heappush(pq, (xx, vv))\\n        return sum(x*x*v for x, v in pq)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267657,
                "title": "python3-solution-o-nlogn-time",
                "content": "`Time Complexity` : `O(nlogn)`\\n`Space Complexity` : `O(n)`\\n\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\\n        n, k, l, ans = len(nums1), k1 + k2, 0, 0\\n        nums = sorted([abs(nums1[i] - nums2[i]) for i in range(n)] + [0], reverse = True)\\n        while l < n and (l + 1) * (nums[l] - nums[l+1]) < k:\\n            k -= (l + 1) * (nums[l] - nums[l+1])\\n            l += 1\\n        if l == n: return 0\\n        for i in range(l + 1, n):\\n            ans += nums[i] ** 2\\n        a, b = divmod(k, l + 1)\\n        return ans + (l - b + 1) * (nums[l] - a) ** 2 + b * (nums[l] - a - 1) ** 2\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\\n        n, k, l, ans = len(nums1), k1 + k2, 0, 0\\n        nums = sorted([abs(nums1[i] - nums2[i]) for i in range(n)] + [0], reverse = True)\\n        while l < n and (l + 1) * (nums[l] - nums[l+1]) < k:\\n            k -= (l + 1) * (nums[l] - nums[l+1])\\n            l += 1\\n        if l == n: return 0\\n        for i in range(l + 1, n):\\n            ans += nums[i] ** 2\\n        a, b = divmod(k, l + 1)\\n        return ans + (l - b + 1) * (nums[l] - a) ** 2 + b * (nums[l] - a - 1) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265258,
                "title": "python-3-simple-with-comments",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diffs = []\\n        for i in range(0, len(nums1)): diffs.append(abs(nums1[i]-nums2[i]))\\n        count = k1+k2\\n        if count >= sum(diffs): return 0\\n        diffs.sort(reverse=True) # high -> low\\n        L = len(diffs)\\n        upper = 1 # upper = the number of values in the array which will be symbolically decremented simultaineously\\n        val = diffs[0] # the value of diffs[0:upper]\\n        while count > 0:\\n            for i in range(upper, L):\\n                if val == diffs[i]:\\n                    upper+=1\\n                else:\\n                    break\\n            count -= (upper)\\n            val -= 1\\n        # if count < 0 there are abs(count) values in diffs which must be val+1\\n        # there are upper+count values if diffs which are val\\n        res = abs(count)*(val+1)*(val+1) + (upper+count)*val*val\\n        for i in range(upper, L): # square all values remaining in diffs which are < val\\n            res += diffs[i]*diffs[i]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diffs = []\\n        for i in range(0, len(nums1)): diffs.append(abs(nums1[i]-nums2[i]))\\n        count = k1+k2\\n        if count >= sum(diffs): return 0\\n        diffs.sort(reverse=True) # high -> low\\n        L = len(diffs)\\n        upper = 1 # upper = the number of values in the array which will be symbolically decremented simultaineously\\n        val = diffs[0] # the value of diffs[0:upper]\\n        while count > 0:\\n            for i in range(upper, L):\\n                if val == diffs[i]:\\n                    upper+=1\\n                else:\\n                    break\\n            count -= (upper)\\n            val -= 1\\n        # if count < 0 there are abs(count) values in diffs which must be val+1\\n        # there are upper+count values if diffs which are val\\n        res = abs(count)*(val+1)*(val+1) + (upper+count)*val*val\\n        for i in range(upper, L): # square all values remaining in diffs which are < val\\n            res += diffs[i]*diffs[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264043,
                "title": "simple-solution-w-o-using-heap-and-sorting-o-n-c-easy",
                "content": "Simply keep the count of absolute difference in a 1e5 size vector.\\nTime : O(1e5) \\nSpace : O(1e5+1)\\n\\n```\\nclass Solution {\\npublic:\\n    int t=1e5;\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        vector<int>v(t+1,0);\\n        int n=nums1.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            v[(abs(nums1[i]-nums2[i]))]++;\\n        }\\n        long long k=k1+k2;\\n        \\n        for(int d=t; d>0; d--)\\n        {\\n            if(v[d]==0)continue;\\n            if(v[d]<=k)\\n            {\\n                v[d-1]+=v[d];\\n                k-=v[d];\\n                v[d]=0;\\n            }\\n            else\\n            {\\n                v[d]-=k;\\n                v[d-1]+=k;\\n                k=0;\\n                break;\\n            }\\n        }\\n        long long ans=0;\\n        \\n        for(long long j=1; j<=t; j++)\\n        {\\n            if(v[j]>0)\\n            {\\n                ans+=((long long)j*(long long)j*(long long)v[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t=1e5;\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        vector<int>v(t+1,0);\\n        int n=nums1.size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            v[(abs(nums1[i]-nums2[i]))]++;\\n        }\\n        long long k=k1+k2;\\n        \\n        for(int d=t; d>0; d--)\\n        {\\n            if(v[d]==0)continue;\\n            if(v[d]<=k)\\n            {\\n                v[d-1]+=v[d];\\n                k-=v[d];\\n                v[d]=0;\\n            }\\n            else\\n            {\\n                v[d]-=k;\\n                v[d-1]+=k;\\n                k=0;\\n                break;\\n            }\\n        }\\n        long long ans=0;\\n        \\n        for(long long j=1; j<=t; j++)\\n        {\\n            if(v[j]>0)\\n            {\\n                ans+=((long long)j*(long long)j*(long long)v[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2262678,
                "title": "c-o-max-element-n-greedy",
                "content": "```\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        unordered_map<int,int> unmp;\\n        int n = nums1.size(),maxi = 0;\\n        long long k = k1+k2; // adding k1 and k2  since we can also use combination together\\n        for(int i=0;i<n;i++) if(abs(nums1[i]-nums2[i])) unmp[abs(nums1[i]-nums2[i])]++,\\n        maxi = max(maxi,abs(nums1[i]-nums2[i]));\\n        vector<int> arr(maxi+1,0); \\n        for(auto it:unmp) arr[it.first] = it.second; // we store absolute differences here\\n        for(int i=maxi;i>=1;i--)\\n        {\\n            if(k >= arr[i]) //when we can decrement all maximum elements by 1 we decrement them\\n            {\\n                arr[i-1] += arr[i];\\n                k -= arr[i];\\n                arr[i] = 0;\\n            }\\n            else //if we cannot decrement we decrement as many as possible\\n            { \\n                arr[i] -= k;\\n                arr[i-1] += k;\\n                break;\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i=1;i<=maxi;i++)  ans += i*1LL*i*arr[i];\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        unordered_map<int,int> unmp;\\n        int n = nums1.size(),maxi = 0;\\n        long long k = k1+k2; // adding k1 and k2  since we can also use combination together\\n        for(int i=0;i<n;i++) if(abs(nums1[i]-nums2[i])) unmp[abs(nums1[i]-nums2[i])]++,\\n        maxi = max(maxi,abs(nums1[i]-nums2[i]));\\n        vector<int> arr(maxi+1,0); \\n        for(auto it:unmp) arr[it.first] = it.second; // we store absolute differences here\\n        for(int i=maxi;i>=1;i--)\\n        {\\n            if(k >= arr[i]) //when we can decrement all maximum elements by 1 we decrement them\\n            {\\n                arr[i-1] += arr[i];\\n                k -= arr[i];\\n                arr[i] = 0;\\n            }\\n            else //if we cannot decrement we decrement as many as possible\\n            { \\n                arr[i] -= k;\\n                arr[i-1] += k;\\n                break;\\n            }\\n        }\\n        long long ans = 0;\\n        for(int i=1;i<=maxi;i++)  ans += i*1LL*i*arr[i];\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2262237,
                "title": "getting-tle-c-using-priority-queue-and-hashmaps",
                "content": "``` Any help would be appreciated ```\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<int,int>> pq; //maxheap\\n        int n= nums1.size();\\n        \\n        map<long long int,long long int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[abs(nums2[i]-nums1[i])]++;\\n        }\\n\\n        for(pair p:mp){\\n            pq.push({p.first,p.second});\\n        }\\n        \\n        long long ans=0;\\n        int k= k1+k2;\\n        while(!pq.empty()){\\n            pair p= pq.top();\\n            pq.pop();\\n            if(p.first==0) return ans;\\n            if(k>0 && k>=p.second){\\n                k-=p.second;\\n                p.first--;\\n                pq.push({p.first,p.second});\\n                continue;\\n            }\\n            else if(k>0 && k<p.second){\\n                pq.push({p.first,p.second-k});\\n                p.first--;\\n                pq.push({p.first,k});\\n                k=0;\\n                continue;\\n            }\\n          //when k=0\\n            ans+= (p.first*p.first)*p.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` Any help would be appreciated ```\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<int,int>> pq; //maxheap\\n        int n= nums1.size();\\n        \\n        map<long long int,long long int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[abs(nums2[i]-nums1[i])]++;\\n        }\\n\\n        for(pair p:mp){\\n            pq.push({p.first,p.second});\\n        }\\n        \\n        long long ans=0;\\n        int k= k1+k2;\\n        while(!pq.empty()){\\n            pair p= pq.top();\\n            pq.pop();\\n            if(p.first==0) return ans;\\n            if(k>0 && k>=p.second){\\n                k-=p.second;\\n                p.first--;\\n                pq.push({p.first,p.second});\\n                continue;\\n            }\\n            else if(k>0 && k<p.second){\\n                pq.push({p.first,p.second-k});\\n                p.first--;\\n                pq.push({p.first,k});\\n                k=0;\\n                continue;\\n            }\\n          //when k=0\\n            ans+= (p.first*p.first)*p.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260781,
                "title": "java-binary-search",
                "content": "Binary Search for the minimum difference that can be **fully** covered. \\nThen we just have to deal with `-1` at most once for each element, resulting in an overall Time Complexity of `O(18n)`.\\n\\n#### Question: Could you explain more in details?\\nFor example, we can fully cover to for all the array element to be different at most 10, but not 9.\\nThen we use binary search to search for 10, once we\\'ve found 10, we then for sure know that not all pairs of element can have a difference of 9, so we keep track of how many decrement/increment operation we have left available to use. Whenever, we encounter a \"10\" difference and when there is available operations left, we change that to 9. That\\'s what the last for loop is about.\\n```Java\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int lo=0,hi=100000,k=k1+k2;\\n        long extra=0,ans=0;\\n        while(lo<hi){\\n            int mid=(lo+hi)>>1;\\n            long need=0;\\n            for (int i = 0 ; i< nums1.length&&need<=k;i++){\\n                need += Math.max(0, Math.abs(nums1[i]-nums2[i])-mid);\\n            }\\n            if (need<=k){\\n                hi=mid;\\n                extra=k-need;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n\\n        for (int i = 0; i< nums1.length&&lo>0;i++){// make sure to check lo (diff) > 0 here.\\n            long diff = Math.min(lo, Math.abs(nums1[i]-nums2[i]));\\n            if (diff==lo&&extra>0){ \\n                --diff;\\n                --extra;\\n            }\\n            ans+=diff*diff;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int lo=0,hi=100000,k=k1+k2;\\n        long extra=0,ans=0;\\n        while(lo<hi){\\n            int mid=(lo+hi)>>1;\\n            long need=0;\\n            for (int i = 0 ; i< nums1.length&&need<=k;i++){\\n                need += Math.max(0, Math.abs(nums1[i]-nums2[i])-mid);\\n            }\\n            if (need<=k){\\n                hi=mid;\\n                extra=k-need;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n\\n        for (int i = 0; i< nums1.length&&lo>0;i++){// make sure to check lo (diff) > 0 here.\\n            long diff = Math.min(lo, Math.abs(nums1[i]-nums2[i]));\\n            if (diff==lo&&extra>0){ \\n                --diff;\\n                --extra;\\n            }\\n            ans+=diff*diff;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260034,
                "title": "o-n-logn-detailed-solution-using-only-map-in-c",
                "content": "The problem can be simply solved using hashmap. Now using both k1 and k2 steps we can make the difference small so we will consider them as total = (k1+k2) steps. Now we will simply maintain the frequency of absolute differences in the hashmap and start from the last element as the ordered hashmap is sorted in C++ and if the total steps remaining is greater than the frequency then we will add element-1 to the hashmap and decrease the total steps and if frequency is more then we will add element-1 with a frequency of total to the hashmap and then the total square sum can be calculated from the hash map.\\n**Time Complexity - O(N logN)\\nSpace Complesity - O(N)**\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        map<long long,long long> m;\\n        \\n        int n = nums1.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            m[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        long long tot = k1+k2;\\n        \\n        while (tot > 0) {\\n            if (m.size() == 0) break;\\n            \\n            auto it = m.end(); it--;\\n            int val = it->first, cnt = it->second;\\n            \\n            m.erase(it);\\n            \\n            if (tot >= cnt) {\\n                tot-=cnt;\\n                val--;\\n                if (val > 0) {\\n                    if (m.find(val) == m.end()) {\\n                        m[val] = cnt;\\n                    }\\n                    else m[val] += cnt;\\n                }\\n            }\\n            else {\\n                m[val] = cnt-tot;\\n                val--;\\n                if (val > 0) {\\n                    if (m.find(val) == m.end()) {\\n                        m[val] = tot;\\n                    }\\n                    else m[val] += tot;\\n                }\\n                tot = 0;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (auto x: m) ans += x.first*x.first*x.second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        map<long long,long long> m;\\n        \\n        int n = nums1.size();\\n        \\n        for (int i = 0; i < n; i++) {\\n            m[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        long long tot = k1+k2;\\n        \\n        while (tot > 0) {\\n            if (m.size() == 0) break;\\n            \\n            auto it = m.end(); it--;\\n            int val = it->first, cnt = it->second;\\n            \\n            m.erase(it);\\n            \\n            if (tot >= cnt) {\\n                tot-=cnt;\\n                val--;\\n                if (val > 0) {\\n                    if (m.find(val) == m.end()) {\\n                        m[val] = cnt;\\n                    }\\n                    else m[val] += cnt;\\n                }\\n            }\\n            else {\\n                m[val] = cnt-tot;\\n                val--;\\n                if (val > 0) {\\n                    if (m.find(val) == m.end()) {\\n                        m[val] = tot;\\n                    }\\n                    else m[val] += tot;\\n                }\\n                tot = 0;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (auto x: m) ans += x.first*x.first*x.second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259712,
                "title": "python-easy-to-understand-binary-search-solution",
                "content": "This solution can be broken down into two parts:\\n\\n1. Find the new max for the array of diffs\\n2. Find the index to first start replacing diffs with our new max\\n\\nWe can use binary search to solve both of these problems.\\n\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        k = k1+k2 # can combine k\\'s because items can be turned negative\\n        diffs = sorted((abs(x - y) for x, y in zip(nums1, nums2)))\\n        \\n        # First binary search to find our new max for our diffs array\\n        l, r = 0, max(diffs)\\n        while l < r:\\n            mid = (l+r)//2\\n            \\n            # steps needed to reduce all nums greater than newMax\\n            steps = sum(max(0, num-mid) for num in diffs)\\n            \\n            if steps <= k:\\n                r = mid\\n            else:\\n                l = mid+1\\n                \\n        newMax = l\\n        k -= sum(max(0, num-newMax) for num in diffs) # remove used k\\n\\n        # Second binary search to find first index to replace with max val\\n        l, r = 0, n-1\\n        while l < r:\\n            mid = (l+r)//2\\n            if diffs[mid] < newMax:\\n                l = mid+1\\n            else:\\n                r = mid\\n\\n        # Replace items at index >= l with newMax\\n        diffs = diffs[:l]+[newMax]*(n-l)\\n        \\n        # Use remaining steps to reduce overall score\\n        for i in range(len(diffs)-1,-1,-1):\\n            if k == 0 or diffs[i] == 0: break\\n            diffs[i] -= 1\\n            k -= 1\\n            \\n        return sum(diff*diff for diff in diffs)\\n```\\nLC streams: https://twitch.tv/fomiee",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        k = k1+k2 # can combine k\\'s because items can be turned negative\\n        diffs = sorted((abs(x - y) for x, y in zip(nums1, nums2)))\\n        \\n        # First binary search to find our new max for our diffs array\\n        l, r = 0, max(diffs)\\n        while l < r:\\n            mid = (l+r)//2\\n            \\n            # steps needed to reduce all nums greater than newMax\\n            steps = sum(max(0, num-mid) for num in diffs)\\n            \\n            if steps <= k:\\n                r = mid\\n            else:\\n                l = mid+1\\n                \\n        newMax = l\\n        k -= sum(max(0, num-newMax) for num in diffs) # remove used k\\n\\n        # Second binary search to find first index to replace with max val\\n        l, r = 0, n-1\\n        while l < r:\\n            mid = (l+r)//2\\n            if diffs[mid] < newMax:\\n                l = mid+1\\n            else:\\n                r = mid\\n\\n        # Replace items at index >= l with newMax\\n        diffs = diffs[:l]+[newMax]*(n-l)\\n        \\n        # Use remaining steps to reduce overall score\\n        for i in range(len(diffs)-1,-1,-1):\\n            if k == 0 or diffs[i] == 0: break\\n            diffs[i] -= 1\\n            k -= 1\\n            \\n        return sum(diff*diff for diff in diffs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259572,
                "title": "c-hashing-greedy-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       \\n        long long n=nums1.size();\\n        vector<long long> mp(1e5+5,0);\\n        long long ans=0;\\n            \\n        for(long long i=0;i<n;i++)\\n        {\\n            mp[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n   \\n       long long t=k1+k2;\\n      for(long long i=1e5+1;i>=0;i--)\\n      {\\n          long long k=mp[i];\\n          if(t>=k)\\n          {\\n              if(i<=1)return 0;\\n              mp[i-1]+=k;\\n              mp[i]=0;\\n              t-=k;\\n              \\n          }\\n          else \\n          {\\n              mp[i-1]+=t;\\n              mp[i]-=t;\\n              break;\\n          }\\n          \\n      }\\n        for(int i=0;i<1e5+1;i++)\\n        {ans+=(long long )(pow(i,2))*mp[i];}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       \\n        long long n=nums1.size();\\n        vector<long long> mp(1e5+5,0);\\n        long long ans=0;\\n            \\n        for(long long i=0;i<n;i++)\\n        {\\n            mp[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n   \\n       long long t=k1+k2;\\n      for(long long i=1e5+1;i>=0;i--)\\n      {\\n          long long k=mp[i];\\n          if(t>=k)\\n          {\\n              if(i<=1)return 0;\\n              mp[i-1]+=k;\\n              mp[i]=0;\\n              t-=k;\\n              \\n          }\\n          else \\n          {\\n              mp[i-1]+=t;\\n              mp[i]-=t;\\n              break;\\n          }\\n          \\n      }\\n        for(int i=0;i<1e5+1;i++)\\n        {ans+=(long long )(pow(i,2))*mp[i];}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259491,
                "title": "python-o-n-counting-solution-accepted-with-explanation-intuition",
                "content": "Firstly, we can observe that it doesn\\'t matter whether we make edits on nums1 or nums2, because only the diff between nums1[i] and nums2[i] matters and editing on nums1 or nums2 can create the same difference between nums1[i] and nums2[i]. Therefore, we can treat k1 and k2 the same thing and call the sum of them ```k```.\\n\\nThe idea is to keep picking the ```i``` that has the biggest diff of ```nums1[i]``` and ```nums2[i]``` and make the diff smaller. e.g. say the ```abs(nums1[i] - nums2[i]) ``` for  all ```i``` is [5, 5, 4, 1], we would want to make the diffs smaller, starting from the 5s and then the 4, and then the 1, as long as ```k > 0```.\\n\\nOne way to do this is to use a max heap to keep track of the ```i```s with the largest diff and then loop ```k``` times to make the diffs smaller. This is ```O(k log n)``` and results in TLE.\\n\\nA faster way would be a counting method which uses an array (which I called ```temp``` in the code below to keep track of the occurrences of the diffs). For the example above, we can count [5, 5, 4, 1] as an array of [0, 1, 0 ,0, 1, 2], meaning that 1 occured once, 4 once, and 5 twice.\\n\\nThis way, we can start loop through this array in reverse and make the edits (maximum is 10^5 times, which is constant), keep track of the result and the changes to this array, as long as ```k > 0``` and ```i > 0```. The time complexity is O(n).\\n\\n```\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        \\n        res = 0        \\n        n = len(nums1)    \\n        k = k1+k2        \\n        temp = [0]*(100000+1)   # this is for counting the occurence of abs(nums1[i]-nums2[i])\\n        \\n        for i in range(n):\\n            diff = abs(nums1[i]-nums2[i])\\n            res += diff**2     # compute the original sum of squared diffs        \\n            temp[diff] += 1 \\n        \\n        i = 100000\\n        while k > 0 and i >0:      # we keep minimising the diffs as long as k > 0 and there are diffs that are bigger than 0   \\n            while temp[i] == 0:\\n                i-= 1\\n            if i == 0:\\n                break\\n            \\n            c = min(k, temp[i])  # find how many changes we can make on this current diff\\n            k -= c\\n            temp[i] -= c\\n            temp[i-1] += c  \\n            res = res - (i**2 - (i-1)**2)*c   # edit the sum of squared diffs\\n                        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```k```\n```i```\n```nums1[i]```\n```nums2[i]```\n```abs(nums1[i] - nums2[i]) ```\n```i```\n```k > 0```\n```i```\n```k```\n```O(k log n)```\n```temp```\n```k > 0```\n```i > 0```\n```\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        \\n        res = 0        \\n        n = len(nums1)    \\n        k = k1+k2        \\n        temp = [0]*(100000+1)   # this is for counting the occurence of abs(nums1[i]-nums2[i])\\n        \\n        for i in range(n):\\n            diff = abs(nums1[i]-nums2[i])\\n            res += diff**2     # compute the original sum of squared diffs        \\n            temp[diff] += 1 \\n        \\n        i = 100000\\n        while k > 0 and i >0:      # we keep minimising the diffs as long as k > 0 and there are diffs that are bigger than 0   \\n            while temp[i] == 0:\\n                i-= 1\\n            if i == 0:\\n                break\\n            \\n            c = min(k, temp[i])  # find how many changes we can make on this current diff\\n            k -= c\\n            temp[i] -= c\\n            temp[i-1] += c  \\n            res = res - (i**2 - (i-1)**2)*c   # edit the sum of squared diffs\\n                        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2259464,
                "title": "hashmaps-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        map<int,int> mp;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int t = abs(nums1[i]-nums2[i]);\\n            mp[t]++;\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        while(k1>0)\\n        {\\n            auto it = mp.end();\\n            --it;\\n            int diff = it->first;\\n            int freq = mp[it->first];\\n            if(diff==0)\\n                break;\\n            if(freq<=k1)\\n            {\\n                mp.erase(diff);\\n                k1-=freq;\\n                mp[abs(diff-1)] += freq;\\n            }\\n            else\\n            {\\n                mp[diff]-=k1;\\n                mp[abs(diff-1)] += k1;\\n                break;\\n            }\\n        }\\n        \\n        while(k2>0)\\n        {\\n            auto it = mp.end();\\n            --it;\\n            int diff = it->first;\\n            int freq = mp[it->first];\\n            if(diff==0)\\n                break;\\n            if(freq<=k2)\\n            {\\n                mp.erase(diff);\\n                k2-=freq;\\n                mp[abs(diff-1)] += freq;\\n            }\\n            else\\n            {\\n                mp[diff]-=k2;\\n                mp[abs(diff-1)] += k2;\\n                break;\\n            }\\n        }\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            int diff = it->first;\\n            int freq = mp[diff];\\n            long long int a = diff;\\n            ans+=(a*a*freq);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        map<int,int> mp;\\n        \\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int t = abs(nums1[i]-nums2[i]);\\n            mp[t]++;\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        while(k1>0)\\n        {\\n            auto it = mp.end();\\n            --it;\\n            int diff = it->first;\\n            int freq = mp[it->first];\\n            if(diff==0)\\n                break;\\n            if(freq<=k1)\\n            {\\n                mp.erase(diff);\\n                k1-=freq;\\n                mp[abs(diff-1)] += freq;\\n            }\\n            else\\n            {\\n                mp[diff]-=k1;\\n                mp[abs(diff-1)] += k1;\\n                break;\\n            }\\n        }\\n        \\n        while(k2>0)\\n        {\\n            auto it = mp.end();\\n            --it;\\n            int diff = it->first;\\n            int freq = mp[it->first];\\n            if(diff==0)\\n                break;\\n            if(freq<=k2)\\n            {\\n                mp.erase(diff);\\n                k2-=freq;\\n                mp[abs(diff-1)] += freq;\\n            }\\n            else\\n            {\\n                mp[diff]-=k2;\\n                mp[abs(diff-1)] += k2;\\n                break;\\n            }\\n        }\\n        \\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            int diff = it->first;\\n            int freq = mp[diff];\\n            long long int a = diff;\\n            ans+=(a*a*freq);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259395,
                "title": "simple-python-solution-with-explanation-dictionary-counters-o-nlogn-time-complexity",
                "content": "Basic Idea:\\n=======\\n1. Get the absolute difference between ```nums1``` and ```nums2``` and store in ```diff``` list.\\n2. If ```k1 + k2``` > ```sum(diff)```, the result is 0, because we would want to reduce the differences between ```nums1``` and ```nums2``` to 0.\\n3. Create a dictionary from ```diff``` based on the number of elements found.\\n4. Basically, we want all the elements in ```diff``` to be as close to each other as possible, or as close to 0 as possible.\\n5. Sort the keys of the ```diff_ht``` (the counter for ```diff```) in reverse order.\\n6. Starting from the largest key, we see try to reduce it to the second largest key and so on, up to a maximum of ```k1 + k2``` times.\\n\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = [abs(nums2[i] - nums1[i]) for i in range(len(nums1))]\\n        diff_ht = Counter(diff)\\n        diff_ht[0] = 1\\n        diff_keys = sorted(list(diff_ht.keys()).copy(), reverse=True)\\n        \\n        k = k1 + k2\\n        if k >= sum(diff):\\n            return 0\\n        \\n        while k > 0:\\n            for i in range(1, len(diff_keys)):\\n                diff_next = (diff_keys[i-1] - diff_keys[i]) * diff_ht[diff_keys[i-1]]\\n                if diff_next < k:\\n                    diff_ht[diff_keys[i]] += diff_ht[diff_keys[i-1]]\\n                    diff_ht[diff_keys[i-1]] = 0\\n                    k -= diff_next\\n                else:\\n                    div = k//diff_ht[diff_keys[i-1]]\\n                    remainder = k % diff_ht[diff_keys[i-1]]\\n                    if div == 0:\\n                        diff_ht[diff_keys[i-1]] -= remainder\\n                        diff_ht[diff_keys[i-1] - 1] += remainder\\n                    else:\\n                        diff_ht[diff_keys[i-1] - div] += diff_ht[diff_keys[i-1]] - remainder\\n                        diff_ht[diff_keys[i-1] - div - 1] += remainder\\n                        del diff_ht[diff_keys[i-1]]\\n                    k = 0\\n                    break\\n                    \\n        total = 0\\n        for i in diff_ht:\\n            total += diff_ht[i]*i*i\\n        return total\\n```",
                "solutionTags": [],
                "code": "```nums1```\n```nums2```\n```diff```\n```k1 + k2```\n```sum(diff)```\n```nums1```\n```nums2```\n```diff```\n```diff```\n```diff_ht```\n```diff```\n```k1 + k2```\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = [abs(nums2[i] - nums1[i]) for i in range(len(nums1))]\\n        diff_ht = Counter(diff)\\n        diff_ht[0] = 1\\n        diff_keys = sorted(list(diff_ht.keys()).copy(), reverse=True)\\n        \\n        k = k1 + k2\\n        if k >= sum(diff):\\n            return 0\\n        \\n        while k > 0:\\n            for i in range(1, len(diff_keys)):\\n                diff_next = (diff_keys[i-1] - diff_keys[i]) * diff_ht[diff_keys[i-1]]\\n                if diff_next < k:\\n                    diff_ht[diff_keys[i]] += diff_ht[diff_keys[i-1]]\\n                    diff_ht[diff_keys[i-1]] = 0\\n                    k -= diff_next\\n                else:\\n                    div = k//diff_ht[diff_keys[i-1]]\\n                    remainder = k % diff_ht[diff_keys[i-1]]\\n                    if div == 0:\\n                        diff_ht[diff_keys[i-1]] -= remainder\\n                        diff_ht[diff_keys[i-1] - 1] += remainder\\n                    else:\\n                        diff_ht[diff_keys[i-1] - div] += diff_ht[diff_keys[i-1]] - remainder\\n                        diff_ht[diff_keys[i-1] - div - 1] += remainder\\n                        del diff_ht[diff_keys[i-1]]\\n                    k = 0\\n                    break\\n                    \\n        total = 0\\n        for i in diff_ht:\\n            total += diff_ht[i]*i*i\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259384,
                "title": "c-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long k = k1+k2;\\n        map<int, int> diff;\\n        for(int i = 0; i < nums1.size(); i++) diff[abs(nums1[i] - nums2[i])]++;\\n        \\n        diff[0] = 0;\\n        while(k > 0 && diff.size() > 1) {\\n            int maxi = (diff.rbegin()) -> first;\\n            int submaxi = (++diff.rbegin()) -> first;\\n            int cnt = (diff.rbegin()) -> second;\\n            \\n            int each = min((int)k / cnt, maxi - submaxi);\\n            if(each == 0) {\\n                diff[maxi] -= k, diff[maxi-1] += k;\\n                break;\\n            }\\n            diff.erase(maxi);\\n            diff[maxi-each] += cnt;\\n            k -= each * cnt;\\n        }\\n        \\n        long long ans = 0;\\n        for(auto it: diff) {\\n            long long d = it.first;\\n            ans += (d*d)*(it.second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long k = k1+k2;\\n        map<int, int> diff;\\n        for(int i = 0; i < nums1.size(); i++) diff[abs(nums1[i] - nums2[i])]++;\\n        \\n        diff[0] = 0;\\n        while(k > 0 && diff.size() > 1) {\\n            int maxi = (diff.rbegin()) -> first;\\n            int submaxi = (++diff.rbegin()) -> first;\\n            int cnt = (diff.rbegin()) -> second;\\n            \\n            int each = min((int)k / cnt, maxi - submaxi);\\n            if(each == 0) {\\n                diff[maxi] -= k, diff[maxi-1] += k;\\n                break;\\n            }\\n            diff.erase(maxi);\\n            diff[maxi-each] += cnt;\\n            k -= each * cnt;\\n        }\\n        \\n        long long ans = 0;\\n        for(auto it: diff) {\\n            long long d = it.first;\\n            ans += (d*d)*(it.second);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259375,
                "title": "c-vector-easy-understanding",
                "content": "```\\nclass Solution { \\npublic: \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) { \\n        vector<int> arr(100005, 0); \\n \\n        for (int i=0; i<nums1.size(); i++){ \\n            arr[abs(nums1[i]-nums2[i])]++; \\n        } \\n \\n        int red = k1+k2; \\n        for (int i=arr.size()-1; i>0; i--){ \\n            if (red >arr[i]){ \\n                \\n                arr[i-1] += arr[i]; \\n                red -= arr[i]; \\n                arr[i]=0; \\n            }else{ \\n                arr[i-1]+=red; \\n                arr[i]-=red; \\n                red=0; \\n                break; \\n            } \\n        } \\n \\n        long long int res = 0; \\n        for (int i=1; i<arr.size(); i++){ \\n            long long ans=0; \\n            if (arr[i] !=0){ \\n                ans=1; \\n                ans*=i; \\n                ans*=i; \\n                ans*=arr[i]; \\n            } \\n            res+=ans; \\n        } \\n        return res; \\n    } \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution { \\npublic: \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) { \\n        vector<int> arr(100005, 0); \\n \\n        for (int i=0; i<nums1.size(); i++){ \\n            arr[abs(nums1[i]-nums2[i])]++; \\n        } \\n \\n        int red = k1+k2; \\n        for (int i=arr.size()-1; i>0; i--){ \\n            if (red >arr[i]){ \\n                \\n                arr[i-1] += arr[i]; \\n                red -= arr[i]; \\n                arr[i]=0; \\n            }else{ \\n                arr[i-1]+=red; \\n                arr[i]-=red; \\n                red=0; \\n                break; \\n            } \\n        } \\n \\n        long long int res = 0; \\n        for (int i=1; i<arr.size(); i++){ \\n            long long ans=0; \\n            if (arr[i] !=0){ \\n                ans=1; \\n                ans*=i; \\n                ans*=i; \\n                ans*=arr[i]; \\n            } \\n            res+=ans; \\n        } \\n        return res; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259334,
                "title": "javascript-solution-using-hashmap-val-count",
                "content": "Please Upvote!! Please comment for more explanation.\\n```\\nIntuition:\\nStep 1: take store abs. (all positive) diff in hashmap with frequency which has not zero difference.\\nStep 2: if k1+k2 >= all positive difference return 0  (one of the optimization)\\nStep 3 otherwise create array from map and sort in asc\\nStep 4 t =k1+k2\\nStep 5a) pop largest value from sorted array return each element by 1 and t--;\\nStep 5b) compare also with after pop array last element is eqal to val-1 then update last element frequency\\nStep 6) once t==0 add all freq*(val^2) in finalans\\nStep7) return finalans \\n\\nvar minSumSquareDiff = function(nums1, nums2, k1, k2) {\\n    let n = nums1.length;\\n    let map = new Map();\\n    let total = 0;\\n    for(let i=0;i<n;i++) {\\n        let c = Math.abs(nums1[i]-nums2[i]);\\n        if(c==0)\\n            continue;\\n        total += c;\\n        if(map.has(c)) {\\n            let val = map.get(c)\\n            map.set(c,val+1);\\n        } else {\\n            map.set(c,1)\\n        }\\n    }\\n    let map2 = Array.from(map);\\n    map2.sort((a,b)=>a[0]-b[0]);\\n    let t = k1+k2;\\n    if(total<=t){\\n        return 0;\\n    }\\n    let lm = map2.length-1;\\n    let finalans  = 0;\\n    while(t>0 && map2.length>0)\\n    {\\n        let [val,count] = map2.pop();\\n        lm--;\\n        if(t>=count) {\\n            \\n            if(lm>=0 && map2[lm][0] + 1 == val) {\\n                map2[lm][1] += count\\n            } else if(val>1){\\n                map2.push([val-1,count])\\n                lm++;\\n            }\\n            t -= count;\\n        } else {\\n           finalans += (count-t)*(Math.pow(val,2)) + t*(Math.pow(val-1,2));\\n           t=0;\\n        }\\n    }\\n    for(let i=0;i<map2.length;i++) {\\n        let [val,count] = map2[i];\\n        finalans += count * Math.pow(val,2)\\n    }\\n    return finalans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nIntuition:\\nStep 1: take store abs. (all positive) diff in hashmap with frequency which has not zero difference.\\nStep 2: if k1+k2 >= all positive difference return 0  (one of the optimization)\\nStep 3 otherwise create array from map and sort in asc\\nStep 4 t =k1+k2\\nStep 5a) pop largest value from sorted array return each element by 1 and t--;\\nStep 5b) compare also with after pop array last element is eqal to val-1 then update last element frequency\\nStep 6) once t==0 add all freq*(val^2) in finalans\\nStep7) return finalans \\n\\nvar minSumSquareDiff = function(nums1, nums2, k1, k2) {\\n    let n = nums1.length;\\n    let map = new Map();\\n    let total = 0;\\n    for(let i=0;i<n;i++) {\\n        let c = Math.abs(nums1[i]-nums2[i]);\\n        if(c==0)\\n            continue;\\n        total += c;\\n        if(map.has(c)) {\\n            let val = map.get(c)\\n            map.set(c,val+1);\\n        } else {\\n            map.set(c,1)\\n        }\\n    }\\n    let map2 = Array.from(map);\\n    map2.sort((a,b)=>a[0]-b[0]);\\n    let t = k1+k2;\\n    if(total<=t){\\n        return 0;\\n    }\\n    let lm = map2.length-1;\\n    let finalans  = 0;\\n    while(t>0 && map2.length>0)\\n    {\\n        let [val,count] = map2.pop();\\n        lm--;\\n        if(t>=count) {\\n            \\n            if(lm>=0 && map2[lm][0] + 1 == val) {\\n                map2[lm][1] += count\\n            } else if(val>1){\\n                map2.push([val-1,count])\\n                lm++;\\n            }\\n            t -= count;\\n        } else {\\n           finalans += (count-t)*(Math.pow(val,2)) + t*(Math.pow(val-1,2));\\n           t=0;\\n        }\\n    }\\n    for(let i=0;i<map2.length;i++) {\\n        let [val,count] = map2[i];\\n        finalans += count * Math.pow(val,2)\\n    }\\n    return finalans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2259310,
                "title": "c-greedy-map-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& A, vector<int>& B, int k1, int k2) {\\n        int n = A.size(), k = k1+k2;\\n        map<int, int> m;\\n        for(int i = 0; i < n; i++) m[abs(A[i]-B[i])]++;\\n        while(k){\\n            auto it = m.rbegin();\\n            if(it->first == 0) return 0;\\n            int i = it->first, j = it->second;\\n            if(k >= j){\\n                m.erase(i);\\n                m[i-1] += j;\\n                k -= j;\\n            }\\n            else{\\n                m[i] -= k;\\n                m[i-1] += k;\\n                k -= k;\\n            }\\n            \\n        }\\n        long long res = 0;\\n        for(auto& [i, v] : m) res += (long long)v*i*i;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& A, vector<int>& B, int k1, int k2) {\\n        int n = A.size(), k = k1+k2;\\n        map<int, int> m;\\n        for(int i = 0; i < n; i++) m[abs(A[i]-B[i])]++;\\n        while(k){\\n            auto it = m.rbegin();\\n            if(it->first == 0) return 0;\\n            int i = it->first, j = it->second;\\n            if(k >= j){\\n                m.erase(i);\\n                m[i-1] += j;\\n                k -= j;\\n            }\\n            else{\\n                m[i] -= k;\\n                m[i-1] += k;\\n                k -= k;\\n            }\\n            \\n        }\\n        long long res = 0;\\n        for(auto& [i, v] : m) res += (long long)v*i*i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259231,
                "title": "c-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int l=0,n = size(nums1);\\n        for(auto &x:nums1)\\n            x = abs (x-nums2[l++]);\\n        sort(begin(nums1),end(nums1));\\n        reverse(begin(nums1),end(nums1));\\n        int k = k1+k2;\\n        int re = 0,i;\\n        for(i=0;i<n-1;i++){\\n            int dif = nums1[i]-nums1[i+1];\\n            if(dif*(i+1) > k)\\n                break;\\n            k-=dif*(i+1);\\n        }\\n        if(k>0)\\n        re = k/(i+1);\\n        for(int j = 0;j<=i;j++) nums1[j] = max(0,nums1[i]-re);\\n        re = 0;\\n        if(k>0)\\n         re = k%(i+1);\\n        for(int j = 0;j<re;j++) nums1[j] = max(0,nums1[j]-1);\\n        long long ans =0;\\n        for(auto x:nums1) ans += (long long)x*x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int l=0,n = size(nums1);\\n        for(auto &x:nums1)\\n            x = abs (x-nums2[l++]);\\n        sort(begin(nums1),end(nums1));\\n        reverse(begin(nums1),end(nums1));\\n        int k = k1+k2;\\n        int re = 0,i;\\n        for(i=0;i<n-1;i++){\\n            int dif = nums1[i]-nums1[i+1];\\n            if(dif*(i+1) > k)\\n                break;\\n            k-=dif*(i+1);\\n        }\\n        if(k>0)\\n        re = k/(i+1);\\n        for(int j = 0;j<=i;j++) nums1[j] = max(0,nums1[i]-re);\\n        re = 0;\\n        if(k>0)\\n         re = k%(i+1);\\n        for(int j = 0;j<re;j++) nums1[j] = max(0,nums1[j]-1);\\n        long long ans =0;\\n        for(auto x:nums1) ans += (long long)x*x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259223,
                "title": "easy-one-o-n-diff-frequency-count-no-use-of-heap-linear-approach",
                "content": "* First of all count differences and keep frequency of differences : O(n)\\n* iterate on frequency and then try to decreace big difference and it frequency until (k1+k2) greater than 0 : O(n)\\n\\n**Overall Tc : O(n) \\u2714\\uFE0F**\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       \\n        int n = nums2.size();\\n        \\n        vector<int>arr(1e5+7);\\n        \\n        ll sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll diff = abs(nums1[i]-nums2[i]);\\n            arr[diff]++;\\n        }\\n        \\n        \\n        \\n        ll ans = 0,p = k1+k2;\\n        \\n        for(int i=1e5+5;i>=0 && n>0;i--)\\n        {\\n            if(arr[i]==0)continue;\\n            \\n            if(arr[i]<=p)\\n            {\\n                p-=arr[i];\\n                if(i>0)\\n                    arr[i-1] += arr[i];\\n                arr[i]=0;\\n            }else\\n            {\\n                ll m = min(p,arr[i]*1LL);\\n                p-=m;\\n                if(i>0)\\n                    arr[i-1] += m;\\n                arr[i]-=m;\\n            }\\n            if(arr[i]==0)continue;\\n            ans += (1LL*arr[i]*i*i);   \\n            n-=arr[i];\\n            // cout<<i<<\" \"<<arr[i]<<\"\\\\n\";\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nI you have any query comment it below \\uD83D\\uDC47 . I would love to anwer it.\\uD83D\\uDC4D",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       \\n        int n = nums2.size();\\n        \\n        vector<int>arr(1e5+7);\\n        \\n        ll sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll diff = abs(nums1[i]-nums2[i]);\\n            arr[diff]++;\\n        }\\n        \\n        \\n        \\n        ll ans = 0,p = k1+k2;\\n        \\n        for(int i=1e5+5;i>=0 && n>0;i--)\\n        {\\n            if(arr[i]==0)continue;\\n            \\n            if(arr[i]<=p)\\n            {\\n                p-=arr[i];\\n                if(i>0)\\n                    arr[i-1] += arr[i];\\n                arr[i]=0;\\n            }else\\n            {\\n                ll m = min(p,arr[i]*1LL);\\n                p-=m;\\n                if(i>0)\\n                    arr[i-1] += m;\\n                arr[i]-=m;\\n            }\\n            if(arr[i]==0)continue;\\n            ans += (1LL*arr[i]*i*i);   \\n            n-=arr[i];\\n            // cout<<i<<\" \"<<arr[i]<<\"\\\\n\";\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2259222,
                "title": "c-ordered-map-o-n-easy-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\t\\t\\t\\tint k = k1 + k2;\\n\\t\\t\\t\\tmap<int, int> mapp;\\n\\n\\t\\t\\t\\tint n = nums1.size();\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\t\\tmapp[abs(nums1[i]-nums2[i])]++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twhile(k > 0){\\n\\t\\t\\t\\t\\tauto i = mapp.rbegin();\\n\\t\\t\\t\\t\\tif(i->first == 0)return 0;\\n\\t\\t\\t\\t\\tif(i->second <= k){\\n\\t\\t\\t\\t\\t\\tmapp[i->first-1] += i->second;\\n\\t\\t\\t\\t\\t\\tk -= i->second;\\n\\t\\t\\t\\t\\t\\tmapp.erase(i->first);\\n\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tmapp[i->first] -= k;\\n\\t\\t\\t\\t\\t\\tmapp[i->first-1] += k;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong long ans = 0;\\n\\t\\t\\t\\tfor(auto i : mapp){\\n\\t\\t\\t\\t\\tans += (i.second * pow(i.first, 2));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\t\\t\\t\\tint k = k1 + k2;\\n\\t\\t\\t\\tmap<int, int> mapp;\\n\\n\\t\\t\\t\\tint n = nums1.size();\\n\\t\\t\\t\\tfor(int i = 0; i < n; i++){\\n\\t\\t\\t\\t\\tmapp[abs(nums1[i]-nums2[i])]++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4090127,
                "title": "python3-simple-solution-beats-94-17-in-speed-includes-tricks-to-pass-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet absolute difference between members of num1, num2. Then we slowly decrement the absolute diff, from largest difference to the smallest in turn. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach should come as no surprise to anyone, it is not very complicated. \\nTo make it pass TLE, I used the following tricks:\\n1. Group the differences together by value, so you consider less differences.\\n2. In calculating the residual sum (as in the function in the code below). use a closed form solution instead of decrementing num by 1 each time.\\n3. Use counter from a library to speed up the process of counting occurences of differences. This is WAY faster than using a dictionary to manually count it\\'s occurences, and helped me go from TLE to faster than 94.17%. \\n\\nI hope this helps!\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = [abs(num1 - num2) for num1, num2 in zip(nums1, nums2)]\\n\\n        k = k1+ k2\\n        if sum(diff) <= k: return 0\\n\\n        diffCount = Counter(diff)\\n        diff = sorted(diffCount.keys(), reverse = True)\\n        n = len(diff)\\n\\n        i = 0; count = diffCount[diff[i]]\\n\\n        while i+1 < n and (diff[i] - diff[i+1])*count <= k:\\n            k -= (diff[i] - diff[i+1])*count\\n            count += diffCount[diff[i+1]]\\n            i += 1\\n\\n        def findResidualSum(k, num, count):\\n            if k >= num*count: return 0\\n\\n            k, num = k%count, num - k//count\\n            ret = k*(num-1)**2 + (count-k)*num**2\\n            return ret\\n\\n        res = findResidualSum(k, diff[i], count)\\n        ret = res + sum([diffCount[d]*d**2 for d in diff[i+1:]])\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = [abs(num1 - num2) for num1, num2 in zip(nums1, nums2)]\\n\\n        k = k1+ k2\\n        if sum(diff) <= k: return 0\\n\\n        diffCount = Counter(diff)\\n        diff = sorted(diffCount.keys(), reverse = True)\\n        n = len(diff)\\n\\n        i = 0; count = diffCount[diff[i]]\\n\\n        while i+1 < n and (diff[i] - diff[i+1])*count <= k:\\n            k -= (diff[i] - diff[i+1])*count\\n            count += diffCount[diff[i+1]]\\n            i += 1\\n\\n        def findResidualSum(k, num, count):\\n            if k >= num*count: return 0\\n\\n            k, num = k%count, num - k//count\\n            ret = k*(num-1)**2 + (count-k)*num**2\\n            return ret\\n\\n        res = findResidualSum(k, diff[i], count)\\n        ret = res + sum([diffCount[d]*d**2 for d in diff[i+1:]])\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009470,
                "title": "minimum-sum-of-squared-difference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI was required to minimize the sum of squares of difference. It was pretty clear that I need to minimize the difference after all. I decided to combine it into one array of difference and then proceed and finally I saw that I need to minimize the maximum value of array to get the optimal result so at last I decided to approach it using binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTook a array of differences of both the arrays.\\n\\n$\\\\text{dif[i] = abs(nums1[i] - nums2[i])}$\\n\\nThen sort the array. Search for the maximal possible value of the array using binary search. Now just one case left, assume you got the $\\\\text{maximal possible value = }5$ and you have six 5s but you also have some $\\\\text{k (number of times you can reduce the difference)}$ left with you. So just decrease $\\\\text{k}$ 5s by 1 and you got your answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$\\n\\\\begin{align}\\n\\\\text{T} &= O(n) + O(binary search) \\\\\\\\\\n         &= O(n) + O(log(max_value) * n) \\\\\\\\\\n         &= O(n) + O(nlog(a_{max})) \\\\\\\\\\n         &\\\\approx O(nlog(a_{max}))\\n\\\\end{align}\\n$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOnly few int variables used. Therefore\\n\\n$\\n\\\\begin{align}\\n\\\\text{S} &= O(1)\\n\\\\end{align}\\n$\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& a, ll x, int k){\\n        ll num = 0;\\n        for(int i=0; i<a.size(); i++){\\n            num += max(0ll, a[i] - x);\\n        }\\n\\n        return (num <= k);\\n    }\\n\\n    ll minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll ans = 0, n = nums1.size(), mx=0, k = k1+k2;\\n        for(int i=0; i<n; i++){\\n            nums1[i] = abs(nums1[i] - nums2[i]);\\n            mx = max((ll)nums1[i], mx);\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n        ll lo = 0, hi = mx, res=lo;\\n        while(lo<=hi){\\n            ll mid = lo + (hi - lo)/2;\\n\\n            if(isValid(nums1, mid, k)){\\n                res = mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        if(res == 0){\\n            return 0;\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            k -= max(0ll, nums1[i] - res);\\n            if(nums1[i] > res)   nums1[i] = res;\\n        }\\n\\n        // extra case we need to take care of\\n        if(k){\\n            for(int i=0; i<n; i++){\\n                if(nums1[i] == res && k){\\n                    nums1[i]--;\\n                    k--;\\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++){\\n            if(nums1[i] > res)  nums1[i] = res;\\n            ans += (ll)nums1[i] * nums1[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>& a, ll x, int k){\\n        ll num = 0;\\n        for(int i=0; i<a.size(); i++){\\n            num += max(0ll, a[i] - x);\\n        }\\n\\n        return (num <= k);\\n    }\\n\\n    ll minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll ans = 0, n = nums1.size(), mx=0, k = k1+k2;\\n        for(int i=0; i<n; i++){\\n            nums1[i] = abs(nums1[i] - nums2[i]);\\n            mx = max((ll)nums1[i], mx);\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n        ll lo = 0, hi = mx, res=lo;\\n        while(lo<=hi){\\n            ll mid = lo + (hi - lo)/2;\\n\\n            if(isValid(nums1, mid, k)){\\n                res = mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n        }\\n\\n        if(res == 0){\\n            return 0;\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            k -= max(0ll, nums1[i] - res);\\n            if(nums1[i] > res)   nums1[i] = res;\\n        }\\n\\n        // extra case we need to take care of\\n        if(k){\\n            for(int i=0; i<n; i++){\\n                if(nums1[i] == res && k){\\n                    nums1[i]--;\\n                    k--;\\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0; i<n; i++){\\n            if(nums1[i] > res)  nums1[i] = res;\\n            ans += (ll)nums1[i] * nums1[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989848,
                "title": "greedy-o-n-log-n-time-and-o-n-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n * log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n    long minSumSqDiff = 0;\\n    TreeMap<Long, Integer> diffFrequency = new TreeMap<>();\\n    for (int i = 0; i < nums1.length; i++) {\\n      long dif = Math.abs(nums1[i] - nums2[i]);\\n      minSumSqDiff += dif * dif;\\n      if (diffFrequency.containsKey(dif)) {\\n        diffFrequency.put(dif, diffFrequency.get(dif) + 1);\\n      } else {\\n        diffFrequency.put(dif, 1);\\n      }\\n    }\\n\\n    long countOps = k1 + k2;\\n    while (diffFrequency.size() > 1 && countOps > 0) {\\n      long maxDif = diffFrequency.lastKey();\\n      long nextMaxDif = diffFrequency.lowerKey(maxDif);\\n      int cntMax = diffFrequency.get(maxDif);\\n      int cntNextMax = diffFrequency.get(nextMaxDif);\\n      long delta = maxDif - nextMaxDif;\\n      if (countOps < cntMax * delta) {\\n        break;\\n      }\\n\\n      diffFrequency.put(nextMaxDif, cntNextMax + cntMax);\\n      diffFrequency.remove(maxDif);\\n      countOps -= cntMax * delta;\\n      minSumSqDiff += (delta * delta - 2 * maxDif * delta) * cntMax;\\n      if (countOps == 0) {\\n        return minSumSqDiff;\\n      }\\n    }\\n\\n    if (countOps > 0) {\\n      long maxDif = diffFrequency.lastKey();\\n      int countMax = diffFrequency.get(maxDif);\\n      long q = Math.min(maxDif, countOps / countMax);\\n      minSumSqDiff += countMax * (q * q - 2 * maxDif * q);\\n      maxDif -= q;\\n      if (maxDif > 0) {\\n        long r = countOps % countMax;\\n        minSumSqDiff += r * (1 - 2 * maxDif);\\n      }\\n    }\\n\\n    return minSumSqDiff;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n  public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n    long minSumSqDiff = 0;\\n    TreeMap<Long, Integer> diffFrequency = new TreeMap<>();\\n    for (int i = 0; i < nums1.length; i++) {\\n      long dif = Math.abs(nums1[i] - nums2[i]);\\n      minSumSqDiff += dif * dif;\\n      if (diffFrequency.containsKey(dif)) {\\n        diffFrequency.put(dif, diffFrequency.get(dif) + 1);\\n      } else {\\n        diffFrequency.put(dif, 1);\\n      }\\n    }\\n\\n    long countOps = k1 + k2;\\n    while (diffFrequency.size() > 1 && countOps > 0) {\\n      long maxDif = diffFrequency.lastKey();\\n      long nextMaxDif = diffFrequency.lowerKey(maxDif);\\n      int cntMax = diffFrequency.get(maxDif);\\n      int cntNextMax = diffFrequency.get(nextMaxDif);\\n      long delta = maxDif - nextMaxDif;\\n      if (countOps < cntMax * delta) {\\n        break;\\n      }\\n\\n      diffFrequency.put(nextMaxDif, cntNextMax + cntMax);\\n      diffFrequency.remove(maxDif);\\n      countOps -= cntMax * delta;\\n      minSumSqDiff += (delta * delta - 2 * maxDif * delta) * cntMax;\\n      if (countOps == 0) {\\n        return minSumSqDiff;\\n      }\\n    }\\n\\n    if (countOps > 0) {\\n      long maxDif = diffFrequency.lastKey();\\n      int countMax = diffFrequency.get(maxDif);\\n      long q = Math.min(maxDif, countOps / countMax);\\n      minSumSqDiff += countMax * (q * q - 2 * maxDif * q);\\n      maxDif -= q;\\n      if (maxDif > 0) {\\n        long r = countOps % countMax;\\n        minSumSqDiff += r * (1 - 2 * maxDif);\\n      }\\n    }\\n\\n    return minSumSqDiff;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928571,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // coppied  As my solution gives wrong answer\\n    \\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long minSumSquare = 0;\\n        int[] diffs = new int[100_001];\\n        long totalDiff = 0;\\n        long kSum = k1 + k2;\\n        int currentDiff;\\n        int maxDiff = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            // get current diff.\\n            currentDiff = Math.abs(nums1[i] - nums2[i]);\\n            // if current diff > 0, count/store it. If not,then ignore it.\\n            if (currentDiff > 0) {\\n                totalDiff += currentDiff;\\n                diffs[currentDiff]++;\\n                maxDiff = Math.max(maxDiff, currentDiff);\\n            }\\n        }\\n        // if kSum (k1 + k2) < totalDifferences, it means we can make all numbers/differences 0s\\n        if (totalDiff <= kSum) {\\n            return 0;\\n        }\\n        // starting from the back, from the highest difference, lower that group one by one to the previous group.\\n         // we need to make all n diffs to n-1, then n-2, as long as kSum allows it.\\n        for (int i = maxDiff; i> 0 && kSum > 0; i--) {\\n            if (diffs[i] > 0) {\\n                // if current group has more differences than the totalK, we can only move k of them to the lower level.\\n                if (diffs[i] >= kSum) {\\n                    diffs[i] -= kSum;\\n                    diffs[i-1] += kSum;\\n                    kSum = 0;\\n                } else {\\n                    // else, we can make this whole group one level lower.\\n                    diffs[i-1] += diffs[i];\\n                    kSum -= diffs[i];\\n                    diffs[i] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= maxDiff; i++) {\\n            if (diffs[i] > 0) {\\n                minSumSquare += (long) (Math.pow((long)i, 2)) * diffs[i];\\n            }\\n        }\\n        return minSumSquare;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // coppied  As my solution gives wrong answer\\n    \\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long minSumSquare = 0;\\n        int[] diffs = new int[100_001];\\n        long totalDiff = 0;\\n        long kSum = k1 + k2;\\n        int currentDiff;\\n        int maxDiff = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            // get current diff.\\n            currentDiff = Math.abs(nums1[i] - nums2[i]);\\n            // if current diff > 0, count/store it. If not,then ignore it.\\n            if (currentDiff > 0) {\\n                totalDiff += currentDiff;\\n                diffs[currentDiff]++;\\n                maxDiff = Math.max(maxDiff, currentDiff);\\n            }\\n        }\\n        // if kSum (k1 + k2) < totalDifferences, it means we can make all numbers/differences 0s\\n        if (totalDiff <= kSum) {\\n            return 0;\\n        }\\n        // starting from the back, from the highest difference, lower that group one by one to the previous group.\\n         // we need to make all n diffs to n-1, then n-2, as long as kSum allows it.\\n        for (int i = maxDiff; i> 0 && kSum > 0; i--) {\\n            if (diffs[i] > 0) {\\n                // if current group has more differences than the totalK, we can only move k of them to the lower level.\\n                if (diffs[i] >= kSum) {\\n                    diffs[i] -= kSum;\\n                    diffs[i-1] += kSum;\\n                    kSum = 0;\\n                } else {\\n                    // else, we can make this whole group one level lower.\\n                    diffs[i-1] += diffs[i];\\n                    kSum -= diffs[i];\\n                    diffs[i] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= maxDiff; i++) {\\n            if (diffs[i] > 0) {\\n                minSumSquare += (long) (Math.pow((long)i, 2)) * diffs[i];\\n            }\\n        }\\n        return minSumSquare;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831908,
                "title": "c-191ms-95-75-95-74mb-92-16-o-nlogn-binary-search",
                "content": "# Intuition\\nMy first solution using pq: TLE\\nSo, I use `mid` for pruning.\\n\\n# Complexity\\n- Time complexity: nlogn\\n\\n- Space complexity: n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int MAX_DIFF = (int)1e5 + 1;\\n  long long minSumSquareDiff(vector<int> &nums1, vector<int> &nums2, int k1,\\n                             int k2) {\\n    int n = nums1.size();\\n    int freq[MAX_DIFF];\\n    memset(freq, 0, sizeof(freq));\\n    uint64_t res = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n      int diff = abs(nums1[i] - nums2[i]);\\n      freq[diff]++;\\n    }\\n\\n    uint64_t k = k1 + k2;\\n    int left = 0, right = MAX_DIFF - 1;\\n\\n    while (left <= right) {\\n      uint64_t sum = 0, c = 0;\\n\\n      if (left == right) {\\n        int j;\\n\\n        for (int i = 0; i < MAX_DIFF; i++) {\\n          j = min(left, i);\\n          res += (uint64_t)freq[i] * j * j;\\n\\n          if (left <= i) {\\n            c += freq[i];\\n            k -= freq[i] * (i - left);\\n          }\\n        }\\n\\n        if (k > 0 && left > 0) {\\n          if (c >= k) {\\n            res = res - k * left * left + k * (left - 1) * (left - 1);\\n          } else {\\n            cout << \"PANIC\\\\n\";\\n          }\\n        }\\n\\n        return res;\\n      }\\n\\n      int mid = (left + right) >> 1;\\n\\n      for (int i = MAX_DIFF - 1; i > mid; i--) {\\n        c += freq[i];\\n        sum += (uint64_t)freq[i] * (i - mid);\\n\\n        if (sum > k) {\\n          break;\\n        }\\n      }\\n\\n      if (sum > k) {\\n        left = mid + 1;\\n      } else if (sum == k) {\\n        for (int i = 0; i <= mid; i++) {\\n          res += (uint64_t)freq[i] * i * i;\\n        }\\n\\n        res += c * mid * mid;\\n\\n        return res;\\n      } else {\\n        right = mid;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int MAX_DIFF = (int)1e5 + 1;\\n  long long minSumSquareDiff(vector<int> &nums1, vector<int> &nums2, int k1,\\n                             int k2) {\\n    int n = nums1.size();\\n    int freq[MAX_DIFF];\\n    memset(freq, 0, sizeof(freq));\\n    uint64_t res = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n      int diff = abs(nums1[i] - nums2[i]);\\n      freq[diff]++;\\n    }\\n\\n    uint64_t k = k1 + k2;\\n    int left = 0, right = MAX_DIFF - 1;\\n\\n    while (left <= right) {\\n      uint64_t sum = 0, c = 0;\\n\\n      if (left == right) {\\n        int j;\\n\\n        for (int i = 0; i < MAX_DIFF; i++) {\\n          j = min(left, i);\\n          res += (uint64_t)freq[i] * j * j;\\n\\n          if (left <= i) {\\n            c += freq[i];\\n            k -= freq[i] * (i - left);\\n          }\\n        }\\n\\n        if (k > 0 && left > 0) {\\n          if (c >= k) {\\n            res = res - k * left * left + k * (left - 1) * (left - 1);\\n          } else {\\n            cout << \"PANIC\\\\n\";\\n          }\\n        }\\n\\n        return res;\\n      }\\n\\n      int mid = (left + right) >> 1;\\n\\n      for (int i = MAX_DIFF - 1; i > mid; i--) {\\n        c += freq[i];\\n        sum += (uint64_t)freq[i] * (i - mid);\\n\\n        if (sum > k) {\\n          break;\\n        }\\n      }\\n\\n      if (sum > k) {\\n        left = mid + 1;\\n      } else if (sum == k) {\\n        for (int i = 0; i <= mid; i++) {\\n          res += (uint64_t)freq[i] * i * i;\\n        }\\n\\n        res += c * mid * mid;\\n\\n        return res;\\n      } else {\\n        right = mid;\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3821051,
                "title": "binary-search-the-answer",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        diffs = [abs(nums1[i] - nums2[i]) for i in range(n)]\\n        beg = 0\\n        end = max(diffs)\\n        mindiff = end\\n        ops = k1 + k2\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            curr = 0\\n            for i in range(n):\\n                curr += max(diffs[i] - mid, 0)\\n            if curr > ops:\\n                beg = mid + 1\\n            else:\\n                mindiff = mid\\n                end = mid - 1\\n        res = 0\\n        for i in range(n):\\n            extra = max(diffs[i] - mindiff, 0)\\n            diffs[i] -= extra\\n            ops -= extra\\n        diffs.sort(reverse = True)\\n        for i in range(n):\\n            if ops > 0 and diffs[i] > 0:\\n                diffs[i] -= 1\\n                ops -= 1\\n        return sum(el * el for el in diffs)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        diffs = [abs(nums1[i] - nums2[i]) for i in range(n)]\\n        beg = 0\\n        end = max(diffs)\\n        mindiff = end\\n        ops = k1 + k2\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            curr = 0\\n            for i in range(n):\\n                curr += max(diffs[i] - mid, 0)\\n            if curr > ops:\\n                beg = mid + 1\\n            else:\\n                mindiff = mid\\n                end = mid - 1\\n        res = 0\\n        for i in range(n):\\n            extra = max(diffs[i] - mindiff, 0)\\n            diffs[i] -= extra\\n            ops -= extra\\n        diffs.sort(reverse = True)\\n        for i in range(n):\\n            if ops > 0 and diffs[i] > 0:\\n                diffs[i] -= 1\\n                ops -= 1\\n        return sum(el * el for el in diffs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810800,
                "title": "easy-short-simple-math-sorting-c-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(nlog(n)) -->\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       long long n = nums1.size(), k = k1+k2, ans = 0;\\n       vector<ll>nums;\\n\\n       for(int i=0; i<n; i++)\\n       {\\n           int diff = abs(nums1[i]-nums2[i]);\\n           nums.push_back(diff);\\n       }\\n\\n       sort(nums.begin(), nums.end());\\nint ind =-1;\\n       for(int i = n-2; i>=0; i--)\\n       {\\n          ll x = (ll) (nums[i+1]-nums[i])*(ll)(n-i-1);\\n          if(k>=x)\\n          {\\n              k-=x;\\n          }else{\\n           ll len = n-i-1;\\n           ll y = k/len;\\n           nums[i+1]=nums[i+1]-y;\\n           int mini = k%len;\\n           ans+=(len-mini)*(nums[i+1])*nums[i+1];\\n           ans+=mini*(ll)(nums[i+1]-1)*(ll)(nums[i+1]-1);\\nind = i;\\n           break;\\n          }\\n       }\\n    for(int i = ind; i>=0; i--)\\n    {\\n        ans+=((ll)nums[i]*(ll)nums[i]);\\n    }\\n    if(ind==-1)\\n    {\\n          \\n           ll y = k/n;\\n           if(nums[0]-y<=0)\\n           {\\n               return 0;\\n           }\\n           nums[0]=nums[0]-y;\\n           int mini = k%n;\\n           ans+=(n-mini)*(nums[0])*nums[0];\\n           ans+=mini*(ll)(nums[0]-1)*(ll)(nums[0]-1);\\n    }\\n    return ans;\\n    }\\n\\n};\\n```\\nPlease upvote it, if you find it helpful.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       long long n = nums1.size(), k = k1+k2, ans = 0;\\n       vector<ll>nums;\\n\\n       for(int i=0; i<n; i++)\\n       {\\n           int diff = abs(nums1[i]-nums2[i]);\\n           nums.push_back(diff);\\n       }\\n\\n       sort(nums.begin(), nums.end());\\nint ind =-1;\\n       for(int i = n-2; i>=0; i--)\\n       {\\n          ll x = (ll) (nums[i+1]-nums[i])*(ll)(n-i-1);\\n          if(k>=x)\\n          {\\n              k-=x;\\n          }else{\\n           ll len = n-i-1;\\n           ll y = k/len;\\n           nums[i+1]=nums[i+1]-y;\\n           int mini = k%len;\\n           ans+=(len-mini)*(nums[i+1])*nums[i+1];\\n           ans+=mini*(ll)(nums[i+1]-1)*(ll)(nums[i+1]-1);\\nind = i;\\n           break;\\n          }\\n       }\\n    for(int i = ind; i>=0; i--)\\n    {\\n        ans+=((ll)nums[i]*(ll)nums[i]);\\n    }\\n    if(ind==-1)\\n    {\\n          \\n           ll y = k/n;\\n           if(nums[0]-y<=0)\\n           {\\n               return 0;\\n           }\\n           nums[0]=nums[0]-y;\\n           int mini = k%n;\\n           ans+=(n-mini)*(nums[0])*nums[0];\\n           ans+=mini*(ll)(nums[0]-1)*(ll)(nums[0]-1);\\n    }\\n    return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803277,
                "title": "sort",
                "content": "**time: `O(NlogN)`; space: `O(1)`**\\n```\\nlong long minSumSquareDiff(vector<int>& n1, vector<int>& n2, int k1, int k2) \\n{\\n\\tfor(int i{}; i<size(n1); ++i)\\n\\t\\tn1[i] = abs(n1[i]-n2[i]);\\n\\n\\tn1.push_back(0);\\n\\tsort(begin(n1), end(n1), greater{});\\n\\n\\tfor(int i{1}, k{k1+k2}; i<size(n1); ++i)\\n\\t\\tif(n1[i]<n1[i-1]) \\n\\t\\t\\tif(long long t = 1ll*i*(n1[i-1]-n1[i]); k>t) \\n\\t\\t\\t\\tk-=t;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto q = (t-k)/i,\\n\\t\\t\\t\\t\\t r = (t-k)%i;\\n\\t\\t\\t\\treturn accumulate(begin(n1)+i, end(n1), (n1[i]+q+1)*(n1[i]+q+1)*r+(n1[i]+q)*(n1[i]+q)*(i-r), [](auto s, auto & n1){ return s+1ll*n1*n1; });\\n\\t\\t\\t}\\n\\treturn 0ll;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long minSumSquareDiff(vector<int>& n1, vector<int>& n2, int k1, int k2) \\n{\\n\\tfor(int i{}; i<size(n1); ++i)\\n\\t\\tn1[i] = abs(n1[i]-n2[i]);\\n\\n\\tn1.push_back(0);\\n\\tsort(begin(n1), end(n1), greater{});\\n\\n\\tfor(int i{1}, k{k1+k2}; i<size(n1); ++i)\\n\\t\\tif(n1[i]<n1[i-1]) \\n\\t\\t\\tif(long long t = 1ll*i*(n1[i-1]-n1[i]); k>t) \\n\\t\\t\\t\\tk-=t;\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tauto q = (t-k)/i,\\n\\t\\t\\t\\t\\t r = (t-k)%i;\\n\\t\\t\\t\\treturn accumulate(begin(n1)+i, end(n1), (n1[i]+q+1)*(n1[i]+q+1)*r+(n1[i]+q)*(n1[i]+q)*(i-r), [](auto s, auto & n1){ return s+1ll*n1*n1; });\\n\\t\\t\\t}\\n\\treturn 0ll;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3747853,
                "title": "c-hashmap-only",
                "content": "The 2 arrays of the Q can be converted into a single array whose value is absolute differece of both values of the array. k1 and k2 can be combined to form a single k.\\nIts not difficult to observe that the Q is now converted to finding out min sum of squared indices where you can decrease each of the the array value by 1 , and you can do this k times in total.\\nUse hashmap to store count and to get the highest element. Every time you get a highest element , try to make it equal to 2nd highest minus 1 if there is 2nd highest or simply make it the minimum possible. Finally if the count of highest element is larger than k where we will break out of while loop with k>0, then decrease k of the highest elements by 1.\\nMake sure to not make any value of the array less than 0 as we need squared value which in case of negative numbers will further increase our answer.\\nTime Complexity - O(n * logn)\\nSpace Complexity - O(n)\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n=nums1.size();\\n        long long ans=0;\\n        int k=k1+k2;\\n        map<long,long> cnt;\\n        for (int i=0;i<n;i++) cnt[abs(nums1[i]-nums2[i])]++; \\n        while (1){\\n            int mmax=cnt.rbegin()->first;\\n            int diff=k/cnt[mmax];\\n            if (diff==0) break;\\n            int gg=cnt[mmax];\\n            cnt.erase(mmax);\\n            if (cnt.size()==0) {\\n                if (mmax-diff<=0) return 0;\\n                cnt[mmax-diff]+=gg;\\n                k-=diff*gg;\\n            }\\n            else {\\n                int val;\\n                auto it=cnt.rbegin(); \\n                if (mmax-diff<it->first){\\n                    val=mmax-it->first+1;\\n                }\\n                else val=diff;\\n                if (mmax-val>0) cnt[mmax-val]+=gg;\\n                k-=val*gg;\\n            }\\n        }\\n        if (k>0){\\n            int mmax=cnt.rbegin()->first;\\n            cnt[mmax]-=k;\\n            if (mmax-1>0) cnt[mmax-1]+=k;\\n        }\\n        for (auto &p:cnt) ans+=p.second*p.first*p.first;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n=nums1.size();\\n        long long ans=0;\\n        int k=k1+k2;\\n        map<long,long> cnt;\\n        for (int i=0;i<n;i++) cnt[abs(nums1[i]-nums2[i])]++; \\n        while (1){\\n            int mmax=cnt.rbegin()->first;\\n            int diff=k/cnt[mmax];\\n            if (diff==0) break;\\n            int gg=cnt[mmax];\\n            cnt.erase(mmax);\\n            if (cnt.size()==0) {\\n                if (mmax-diff<=0) return 0;\\n                cnt[mmax-diff]+=gg;\\n                k-=diff*gg;\\n            }\\n            else {\\n                int val;\\n                auto it=cnt.rbegin(); \\n                if (mmax-diff<it->first){\\n                    val=mmax-it->first+1;\\n                }\\n                else val=diff;\\n                if (mmax-val>0) cnt[mmax-val]+=gg;\\n                k-=val*gg;\\n            }\\n        }\\n        if (k>0){\\n            int mmax=cnt.rbegin()->first;\\n            cnt[mmax]-=k;\\n            if (mmax-1>0) cnt[mmax-1]+=k;\\n        }\\n        for (auto &p:cnt) ans+=p.second*p.first*p.first;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736684,
                "title": "easy-commented-explained-intition-code-priority-queue-o-nlogn",
                "content": "# If you have any doubts and queries, please let me know in the comments,  Please upvote if you liked my solution and explanation\\n\\n# Intuition\\nhow to make the sqaure lowest of ( a - b ) ? Simple either decrease a if a>b or increase b if b<a\\n\\nIf b>a, then either decrease b or increase a\\n\\nNow from this I got the intution that it dosnt matter the two arrays, just what matters is the difference, we want to cover up the difference as much as possible in K, also we need to make sure that the thing stays minium in the end.\\n\\nHow do we have sure it says minimum?\\nlet is say our difference array is like ```[ 3,4,4,4 ]``` and ```k ( k1 + k2 ) = 2```\\n\\nHere is is better to reduce 2-4\\'s to 3 rather than 1-4 to 2, check it yourself.\\n\\nSo based on this, we will try to convert the biggest numbers to the 2nd biggest numbers\\n\\n# Approach\\nSimple , get the differences array, sum up the k1 and k2.\\n\\nNow the question becomes to reduce this array with k1+k2 operations.\\n\\nget the frequency of each difference and push into q priority_queue\\n\\nWhy priority_queue?\\nbecause we have to first reduce the biggest element, and for that we want to get the biggest element in lowest time. also we want to push some things in the end, the converted ones and leftovers. \\nThis DS provides everything in logN\\n\\n# Complexity\\n- Time complexity: O(Nlog(n))\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll n=nums1.size();\\n\\n        // defining a map to store the frequency of differences\\n        unordered_map<int,int>mp;\\n        for(ll i=0;i<n;i++){\\n            ll diff=abs(nums1[i]-nums2[i]);\\n            mp[diff]++;\\n        }\\n\\n        // pushing everything in a map-heap\\n        ll k=k1+k2;\\n        priority_queue<pair<ll,ll>>q;\\n        for(auto&it:mp){\\n            q.push({it.first,it.second});\\n        }\\n\\n        // pushing this just to make sure our heap never goes empty, we need this ahead, when we are getting the next element\\n        q.push({0,0});\\n\\n        while(!q.empty() && k>0 && q.top().first!=0){\\n            auto p = q.top();\\n            q.pop();\\n            auto p2=q.top();\\n            ll req = (p.first-p2.first)*p.second;\\n\\n            // if we have K to reduce the current number to number-1, then do it\\n            if(k>=req){\\n                q.pop();\\n                k-=req;\\n                q.push({p2.first,p2.second+p.second});\\n            }\\n            else{\\n                // else do whatever we can\\n                ll convertible = min(k,p.second);\\n                k-=convertible;\\n                if(convertible!=0){\\n                    q.push({p.first-1,convertible});\\n                }\\n                if(p.second!=convertible){\\n                    q.push({p.first,p.second-convertible});\\n                }\\n            }\\n        }\\n\\n        // finally calculating the result\\n        ll ans=0;\\n        while(!q.empty()){\\n            auto p = q.top();\\n            q.pop();\\n            ans+=(pow(p.first,2)*p.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```[ 3,4,4,4 ]```\n```k ( k1 + k2 ) = 2```\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        ll n=nums1.size();\\n\\n        // defining a map to store the frequency of differences\\n        unordered_map<int,int>mp;\\n        for(ll i=0;i<n;i++){\\n            ll diff=abs(nums1[i]-nums2[i]);\\n            mp[diff]++;\\n        }\\n\\n        // pushing everything in a map-heap\\n        ll k=k1+k2;\\n        priority_queue<pair<ll,ll>>q;\\n        for(auto&it:mp){\\n            q.push({it.first,it.second});\\n        }\\n\\n        // pushing this just to make sure our heap never goes empty, we need this ahead, when we are getting the next element\\n        q.push({0,0});\\n\\n        while(!q.empty() && k>0 && q.top().first!=0){\\n            auto p = q.top();\\n            q.pop();\\n            auto p2=q.top();\\n            ll req = (p.first-p2.first)*p.second;\\n\\n            // if we have K to reduce the current number to number-1, then do it\\n            if(k>=req){\\n                q.pop();\\n                k-=req;\\n                q.push({p2.first,p2.second+p.second});\\n            }\\n            else{\\n                // else do whatever we can\\n                ll convertible = min(k,p.second);\\n                k-=convertible;\\n                if(convertible!=0){\\n                    q.push({p.first-1,convertible});\\n                }\\n                if(p.second!=convertible){\\n                    q.push({p.first,p.second-convertible});\\n                }\\n            }\\n        }\\n\\n        // finally calculating the result\\n        ll ans=0;\\n        while(!q.empty()){\\n            auto p = q.top();\\n            q.pop();\\n            ans+=(pow(p.first,2)*p.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727692,
                "title": "binary-search-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCovert both arrays into a single array of differences and check the total the minimum difference can make with less than or equal to k1+k2 and based on that results the final answer\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo space needed\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<long long>& nums1, long long mid, long long k){\\n        for(int i=0; i<nums1.size(); i++){\\n            if(nums1[i]>mid) k-=(nums1[i]-mid);\\n        }\\n        return (k>=0)?1:0;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<long long>nums(n);\\n        for(int i=0; i<n; i++) nums[i] = abs(nums1[i]-nums2[i]);\\n        sort(nums.begin(), nums.end());\\n        long long k  = k1 + k2;\\n        long long st = 0, end = nums[n-1], ans = 0;\\n        while(st<=end){\\n            long long mid = (st+end)/2;\\n            if(check(nums, mid, k)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else st = mid + 1;\\n        }\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>ans){k-=(nums[i]-ans); nums[i] = ans;  }\\n        }\\n        long long fin = 0;\\n        for(int i=n-1; i>=0; i--){\\n            if(k&&nums[i]){ nums[i]--; k--; }\\n            fin = (fin + (long long )(long long)nums[i]*(long long)nums[i]);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<long long>& nums1, long long mid, long long k){\\n        for(int i=0; i<nums1.size(); i++){\\n            if(nums1[i]>mid) k-=(nums1[i]-mid);\\n        }\\n        return (k>=0)?1:0;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<long long>nums(n);\\n        for(int i=0; i<n; i++) nums[i] = abs(nums1[i]-nums2[i]);\\n        sort(nums.begin(), nums.end());\\n        long long k  = k1 + k2;\\n        long long st = 0, end = nums[n-1], ans = 0;\\n        while(st<=end){\\n            long long mid = (st+end)/2;\\n            if(check(nums, mid, k)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else st = mid + 1;\\n        }\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>ans){k-=(nums[i]-ans); nums[i] = ans;  }\\n        }\\n        long long fin = 0;\\n        for(int i=n-1; i>=0; i--){\\n            if(k&&nums[i]){ nums[i]--; k--; }\\n            fin = (fin + (long long )(long long)nums[i]*(long long)nums[i]);\\n        }\\n        return fin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716515,
                "title": "easy-java-solution-without-priority-queue-arrays-upvote",
                "content": "Priority Queue solution gives TLE. \\n\\n# Code\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int t[]=new int[100001];\\n        for(int i=0;i<nums1.length;i++){\\n            t[Math.abs(nums1[i]-nums2[i])]++;\\n        }\\n        int k=k1+k2;\\n        for(int i=100000;i>=1 && k>0;i--)\\n        {\\n            if(t[i]<=0)\\n                continue;\\n            else if(t[i]<=k)\\n            {\\n                t[i-1]+=t[i];\\n                k-=t[i];\\n                t[i]=0;\\n            }\\n            else\\n            {\\n                t[i-1]+=k;\\n                t[i]-=k;\\n                break;\\n\\n            }\\n        }\\n        long ans=0;\\n        for(long i=1;i<100001;i++)\\n        {\\n            while(t[(int)i]>0)\\n            {\\n                ans+=i*i;\\n                t[(int)i]--;\\n            }\\n\\n        }\\n        return ans;\\n        \\n\\n\\n    }\\n   \\n    // public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        // PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        // int n = nums1.length;\\n        // for(int i = 0; i < n;i++){\\n        //     int diff = Math.abs(nums1[i] - nums2[i]);\\n        //     if(diff > 0) pq.add(diff);\\n        // }\\n\\n    //     int k = k1 + k2;\\n\\n    //     while(k > 0 && !pq.isEmpty()){\\n    //         int t = pq.poll();\\n    //         t = t - 1;\\n    //         k--;\\n    //         if(t > 0){\\n    //             pq.add(t);\\n    //         }\\n    //     }\\n\\n    //     long ans = 0;\\n    //     while(!pq.isEmpty()){\\n    //         int t = pq.poll();\\n    //         ans = ans + t * t;\\n    //     }\\n\\n    //     return ans;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int t[]=new int[100001];\\n        for(int i=0;i<nums1.length;i++){\\n            t[Math.abs(nums1[i]-nums2[i])]++;\\n        }\\n        int k=k1+k2;\\n        for(int i=100000;i>=1 && k>0;i--)\\n        {\\n            if(t[i]<=0)\\n                continue;\\n            else if(t[i]<=k)\\n            {\\n                t[i-1]+=t[i];\\n                k-=t[i];\\n                t[i]=0;\\n            }\\n            else\\n            {\\n                t[i-1]+=k;\\n                t[i]-=k;\\n                break;\\n\\n            }\\n        }\\n        long ans=0;\\n        for(long i=1;i<100001;i++)\\n        {\\n            while(t[(int)i]>0)\\n            {\\n                ans+=i*i;\\n                t[(int)i]--;\\n            }\\n\\n        }\\n        return ans;\\n        \\n\\n\\n    }\\n   \\n    // public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        // PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        // int n = nums1.length;\\n        // for(int i = 0; i < n;i++){\\n        //     int diff = Math.abs(nums1[i] - nums2[i]);\\n        //     if(diff > 0) pq.add(diff);\\n        // }\\n\\n    //     int k = k1 + k2;\\n\\n    //     while(k > 0 && !pq.isEmpty()){\\n    //         int t = pq.poll();\\n    //         t = t - 1;\\n    //         k--;\\n    //         if(t > 0){\\n    //             pq.add(t);\\n    //         }\\n    //     }\\n\\n    //     long ans = 0;\\n    //     while(!pq.isEmpty()){\\n    //         int t = pq.poll();\\n    //         ans = ans + t * t;\\n    //     }\\n\\n    //     return ans;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696339,
                "title": "simple-java-code-o-n-for-tc-and-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Freq of diff\\n\\n# Complexity\\n- Time complexity:\\n~O(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int k = k1 + k2;\\n        int n = nums1.length;\\n        int dp[] = new int[100002];\\n        for(int i = 0; i < n ; i++) {\\n            dp[Math.abs(nums1[i] - nums2[i])]++;\\n        }\\n        // System.out.println(dp[100000]);\\n        for(int i = 100001; i > 0 && k > 0 ; i--) {\\n            if(dp[i] > 0) {\\n                int minF = Math.min(dp[i], k);\\n                k -= minF;\\n                dp[i] -= minF;\\n                // setting freq for previous value\\n                dp[i-1] += minF;\\n            }\\n        }\\n\\n        long ans = 0;\\n        for(int i = 1; i <= 100001; i++) {\\n            if(dp[i] > 0) {\\n                ans += (long)((long)i * i) * (long)dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int k = k1 + k2;\\n        int n = nums1.length;\\n        int dp[] = new int[100002];\\n        for(int i = 0; i < n ; i++) {\\n            dp[Math.abs(nums1[i] - nums2[i])]++;\\n        }\\n        // System.out.println(dp[100000]);\\n        for(int i = 100001; i > 0 && k > 0 ; i--) {\\n            if(dp[i] > 0) {\\n                int minF = Math.min(dp[i], k);\\n                k -= minF;\\n                dp[i] -= minF;\\n                // setting freq for previous value\\n                dp[i-1] += minF;\\n            }\\n        }\\n\\n        long ans = 0;\\n        for(int i = 1; i <= 100001; i++) {\\n            if(dp[i] > 0) {\\n                ans += (long)((long)i * i) * (long)dp[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651790,
                "title": "brute-force-tle-optmized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nBrute force TLE\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2){\\n\\n    priority_queue<int> pq;\\n        for(int i=0; i<nums1.size(); i++){\\n            int ad = abs(nums1[i]-nums2[i]);\\n            if(ad != 0)\\n                pq.push(ad);\\n        }\\n        int k=k1+k2;\\n        while(k>0 && (!pq.empty())){\\n            k--;\\n            int t = pq.top();\\n            pq.pop();\\n            int new_ele = t-1;\\n            if(new_ele != 0){\\n                pq.push(new_ele);\\n            }\\n        }\\n            \\n\\n        long long sum=0;\\n        while(!pq.empty()){\\n            int temp = pq.top();\\n            sum += (temp*temp);\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n    \\n\\n\\nOptmized\\n\\n    class Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& a, vector<int>& b, int k1, int k2) {\\n        map<long long, long long> mp;\\n        int n = a.size();\\n        for(int i = 0; i < n; i++) {\\n            mp[abs(a[i] - b[i])]++;\\n        }\\n        long long k = k1 + k2;       \\n        while(k and !mp.empty()) {\\n            auto it = prev(mp.end());\\n            int val = it->first;\\n            int freq = it->second;\\n            if(freq <= k) {\\n                mp[val-1] += freq;\\n                mp.erase(it);\\n                k -= freq;\\n            }\\n            else {\\n                mp[val-1] += k;\\n                mp[val] -= k;\\n                k = 0;\\n            }\\n        }      \\n        long long ans = 0;\\n        for(auto &i : mp) {\\n            if(i.second > 0 and i.first > 0) {\\n                ans += (i.first * i.first) * i.second;\\n            }\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nBrute force TLE\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2){\\n\\n    priority_queue<int> pq;\\n        for(int i=0; i<nums1.size(); i++){\\n            int ad = abs(nums1[i]-nums2[i]);\\n            if(ad != 0)\\n                pq.push(ad);\\n        }\\n        int k=k1+k2;\\n        while(k>0 && (!pq.empty())){\\n            k--;\\n            int t = pq.top();\\n            pq.pop();\\n            int new_ele = t-1;\\n            if(new_ele != 0){\\n                pq.push(new_ele);\\n            }\\n        }\\n            \\n\\n        long long sum=0;\\n        while(!pq.empty()){\\n            int temp = pq.top();\\n            sum += (temp*temp);\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n    \\n\\n\\nOptmized\\n\\n    class Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& a, vector<int>& b, int k1, int k2) {\\n        map<long long, long long> mp;\\n        int n = a.size();\\n        for(int i = 0; i < n; i++) {\\n            mp[abs(a[i] - b[i])]++;\\n        }\\n        long long k = k1 + k2;       \\n        while(k and !mp.empty()) {\\n            auto it = prev(mp.end());\\n            int val = it->first;\\n            int freq = it->second;\\n            if(freq <= k) {\\n                mp[val-1] += freq;\\n                mp.erase(it);\\n                k -= freq;\\n            }\\n            else {\\n                mp[val-1] += k;\\n                mp[val] -= k;\\n                k = 0;\\n            }\\n        }      \\n        long long ans = 0;\\n        for(auto &i : mp) {\\n            if(i.second > 0 and i.first > 0) {\\n                ans += (i.first * i.first) * i.second;\\n            }\\n        }\\n        return\\xA0ans;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647656,
                "title": "good-enough-commented",
                "content": "# Approach\\nThe idia is that changeing larger differences will give more effect, so the first step is to get sorted difference array and then decrease larger elements as much as possible\\n\\n# Complexity\\n- Time complexity: $$O(n log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        # getting an array of number moduluses\\n        diffs = sorted([abs(nums1[i] - nums2[i]) for i in range(len(nums1))], reverse=True)\\n        # that\\'t easier to work with array extended with zero, the result won\\'t be affected\\n        diffs.append(0)\\n        # we dot\\'t need to separate decreases/increases caused by k1 and k2, both will affect the difference by 1\\n        # so let\\'s have a total number of decreases/increases\\n        k = k1 + k2\\n        id = 0\\n        rest = 0\\n        # now we\\'re moving through sorted array, \\'cutting off\\' as many as allows k\\n        while id < len(diffs) - 1 and k > 0:\\n            d = diffs[id] - diffs[id + 1] if id < len(diffs) - 1 else diffs[id]\\n            s = d * (id + 1)\\n            rest = s - k\\n            k -= min(s, k)\\n            id += 1\\n        # if we can bring all diffs to zero - just return zero\\n        if k > 0:\\n            return 0\\n        # we only have to keep this total value in first id elements, distributed equally\\n        keep = diffs[id] * id + rest\\n        val = 0 if id == 0 else keep // id\\n        rem = 0 if id == 0 else keep % id\\n        # updating first id elements\\n        for i in range(id):\\n            diffs[i] = val + 1 if i < rem else val\\n        sum = 0\\n        for val in diffs:\\n            sum += val ** 2\\n        return sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        # getting an array of number moduluses\\n        diffs = sorted([abs(nums1[i] - nums2[i]) for i in range(len(nums1))], reverse=True)\\n        # that\\'t easier to work with array extended with zero, the result won\\'t be affected\\n        diffs.append(0)\\n        # we dot\\'t need to separate decreases/increases caused by k1 and k2, both will affect the difference by 1\\n        # so let\\'s have a total number of decreases/increases\\n        k = k1 + k2\\n        id = 0\\n        rest = 0\\n        # now we\\'re moving through sorted array, \\'cutting off\\' as many as allows k\\n        while id < len(diffs) - 1 and k > 0:\\n            d = diffs[id] - diffs[id + 1] if id < len(diffs) - 1 else diffs[id]\\n            s = d * (id + 1)\\n            rest = s - k\\n            k -= min(s, k)\\n            id += 1\\n        # if we can bring all diffs to zero - just return zero\\n        if k > 0:\\n            return 0\\n        # we only have to keep this total value in first id elements, distributed equally\\n        keep = diffs[id] * id + rest\\n        val = 0 if id == 0 else keep // id\\n        rem = 0 if id == 0 else keep % id\\n        # updating first id elements\\n        for i in range(id):\\n            diffs[i] = val + 1 if i < rem else val\\n        sum = 0\\n        for val in diffs:\\n            sum += val ** 2\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646506,
                "title": "hashtable-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought of first getting the diff then using putting that in a map to count its occurence .\\nThen put that in a set of pairs so that i can reduce the maximum difference and put that back in set .\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans = 0;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[abs(nums1[i]-nums2[i])]++;\\n        }\\n        k1 += k2;\\n        multiset<pair<int,int>> s;\\n        for(auto p: m){\\n            s.insert({p.first,p.second});\\n            ans += 1ll*p.first*p.first*p.second;\\n        }\\n        if(k1 == 0) return ans;\\n        ans = 0;\\n        // Now we have to\\n        while(k1 > 0 && s.size()){\\n            auto t = s.rbegin();\\n            int v = (*t).first;\\n            int n = (*t).second;\\n            // Now delete \\n            s.erase(prev(s.end()));\\n            // now if \\n            if(n > k1){\\n                s.insert({v,n-k1});\\n                if(v-1 > 0) s.insert({v-1,k1});\\n            }else{\\n                if(v-1 > 0){ \\n                    int tn = 0;\\n                    if(m.find(v-1) != m.end()){ tn = m[v-1]; s.erase({v-1,tn}); }\\n                    s.insert({v-1,n+tn});\\n                }\\n            }\\n            k1 -= n;\\n        }\\n        while(!s.empty()){\\n            auto t = s.begin();\\n            int v = (*t).first;\\n            int n = (*t).second;\\n            // Now delete \\n            s.erase(t);\\n            ans += 1ll*v*v*n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans = 0;\\n        unordered_map<int,int> m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[abs(nums1[i]-nums2[i])]++;\\n        }\\n        k1 += k2;\\n        multiset<pair<int,int>> s;\\n        for(auto p: m){\\n            s.insert({p.first,p.second});\\n            ans += 1ll*p.first*p.first*p.second;\\n        }\\n        if(k1 == 0) return ans;\\n        ans = 0;\\n        // Now we have to\\n        while(k1 > 0 && s.size()){\\n            auto t = s.rbegin();\\n            int v = (*t).first;\\n            int n = (*t).second;\\n            // Now delete \\n            s.erase(prev(s.end()));\\n            // now if \\n            if(n > k1){\\n                s.insert({v,n-k1});\\n                if(v-1 > 0) s.insert({v-1,k1});\\n            }else{\\n                if(v-1 > 0){ \\n                    int tn = 0;\\n                    if(m.find(v-1) != m.end()){ tn = m[v-1]; s.erase({v-1,tn}); }\\n                    s.insert({v-1,n+tn});\\n                }\\n            }\\n            k1 -= n;\\n        }\\n        while(!s.empty()){\\n            auto t = s.begin();\\n            int v = (*t).first;\\n            int n = (*t).second;\\n            // Now delete \\n            s.erase(t);\\n            ans += 1ll*v*v*n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630497,
                "title": "c-priority-queue-o-nlogn",
                "content": "```\\npriority_queue<long long> pq;\\n        for(int i=0; i<nums1.size(); i++){\\n            pq.push(abs(nums1[i]-nums2[i]));\\n        }\\n        long long k = k1+k2, w = 0, res = 0, prev, cur, pivot, h;\\n        while(k>0&&!pq.empty()){\\n            cur = pq.top();\\n            while(!pq.empty()&&pq.top()==cur){\\n                w++;\\n                pq.pop();\\n            }\\n            prev = pq.empty() ? 0:pq.top();\\n            k -= w*(cur-prev);\\n        }\\n        //deal with edge case\\n        if(k<0){\\n            k += w*(cur-prev);\\n            pivot = k%w;\\n            h = cur-k/w-1;\\n            res += pivot*h*h+(w-pivot)*(h+1)*(h+1);\\n        }\\n        else if(!pq.empty())res += w*pq.top()*pq.top();\\n        while(!pq.empty()){\\n            res += pq.top()*pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n```",
                "solutionTags": [],
                "code": "```\\npriority_queue<long long> pq;\\n        for(int i=0; i<nums1.size(); i++){\\n            pq.push(abs(nums1[i]-nums2[i]));\\n        }\\n        long long k = k1+k2, w = 0, res = 0, prev, cur, pivot, h;\\n        while(k>0&&!pq.empty()){\\n            cur = pq.top();\\n            while(!pq.empty()&&pq.top()==cur){\\n                w++;\\n                pq.pop();\\n            }\\n            prev = pq.empty() ? 0:pq.top();\\n            k -= w*(cur-prev);\\n        }\\n        //deal with edge case\\n        if(k<0){\\n            k += w*(cur-prev);\\n            pivot = k%w;\\n            h = cur-k/w-1;\\n            res += pivot*h*h+(w-pivot)*(h+1)*(h+1);\\n        }\\n        else if(!pq.empty())res += w*pq.top()*pq.top();\\n        while(!pq.empty()){\\n            res += pq.top()*pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517358,
                "title": "c-greedy-reduce-largest-difference",
                "content": "1. Only `k1+k2` matters.\\n2. repeatedly reduce largest diff to the 2nd largest one\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        map<int,int, greater<>> diffcount { { pair(0,0) } };\\n        transform(nums1.begin(), nums1.end(), nums2.begin(), nums1.begin(), [](auto a, auto b) { return abs(a-b); });\\n        for(auto diff : nums1) \\n            diffcount[diff]++;\\n\\n        int k = k1 + k2;\\n        for(auto j = diffcount.begin(), i = j++; j != diffcount.end() && k; i = j++) {\\n            auto  [diffa, counta] = *i; // largest diff: reduce to the next largest diff\\n            auto& [diffb, countb] = *j; // next largest diff\\n            diffcount.erase(i);\\n            int dec = (diffa - diffb) * counta <= k ? diffa - diffb : k/counta;\\n            int rem = (diffa - diffb) * counta <= k ? 0 : k % counta;\\n            k -= dec * counta + rem;\\n            if(rem) diffcount[diffa - dec - 1] += rem;\\n            diffcount[diffa - dec] += counta - rem;\\n        }\\n        return accumulate(diffcount.begin(), diffcount.end(), 0LL, [](long long s, auto const& p) { return s + (long long)p.first*p.first*p.second; });\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        map<int,int, greater<>> diffcount { { pair(0,0) } };\\n        transform(nums1.begin(), nums1.end(), nums2.begin(), nums1.begin(), [](auto a, auto b) { return abs(a-b); });\\n        for(auto diff : nums1) \\n            diffcount[diff]++;\\n\\n        int k = k1 + k2;\\n        for(auto j = diffcount.begin(), i = j++; j != diffcount.end() && k; i = j++) {\\n            auto  [diffa, counta] = *i; // largest diff: reduce to the next largest diff\\n            auto& [diffb, countb] = *j; // next largest diff\\n            diffcount.erase(i);\\n            int dec = (diffa - diffb) * counta <= k ? diffa - diffb : k/counta;\\n            int rem = (diffa - diffb) * counta <= k ? 0 : k % counta;\\n            k -= dec * counta + rem;\\n            if(rem) diffcount[diffa - dec - 1] += rem;\\n            diffcount[diffa - dec] += counta - rem;\\n        }\\n        return accumulate(diffcount.begin(), diffcount.end(), 0LL, [](long long s, auto const& p) { return s + (long long)p.first*p.first*p.second; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440026,
                "title": "priority-queue-and-count",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        priority_queue<long long> diff;\\n        diff.push(0);\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            diff.push(abs(nums1[i] - nums2[i]));\\n        }\\n        if(diff.top() == 0)\\n        {\\n            return 0;\\n        }\\n        long long k = k1 + k2, num = diff.top(), cnt = 1;\\n        diff.pop();\\n        while(k > 0 && !diff.empty())\\n        {\\n            while(num == diff.top() && !diff.empty())\\n            {\\n                diff.pop();\\n                cnt++;\\n            }\\n            if((num - diff.top()) * cnt > k)\\n            {\\n                num -= k / cnt;\\n                k = k % cnt;\\n                break;\\n            }\\n            else\\n            {\\n                k -= (num - diff.top()) * cnt;\\n                num = diff.top();\\n            }\\n        }\\n        if(num == 0)\\n        {\\n            return 0;\\n        }\\n        long long ans = 0;\\n        for(int i = 0; i < cnt; i++)\\n        {\\n            if(i < k)\\n            {\\n                ans += (num - 1) * (num - 1);\\n            }\\n            else\\n            {\\n                ans += (num) * (num);\\n            }\\n        }\\n        while(!diff.empty())\\n        {\\n            ans += diff.top() * diff.top();\\n            diff.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        priority_queue<long long> diff;\\n        diff.push(0);\\n        int n = nums1.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            diff.push(abs(nums1[i] - nums2[i]));\\n        }\\n        if(diff.top() == 0)\\n        {\\n            return 0;\\n        }\\n        long long k = k1 + k2, num = diff.top(), cnt = 1;\\n        diff.pop();\\n        while(k > 0 && !diff.empty())\\n        {\\n            while(num == diff.top() && !diff.empty())\\n            {\\n                diff.pop();\\n                cnt++;\\n            }\\n            if((num - diff.top()) * cnt > k)\\n            {\\n                num -= k / cnt;\\n                k = k % cnt;\\n                break;\\n            }\\n            else\\n            {\\n                k -= (num - diff.top()) * cnt;\\n                num = diff.top();\\n            }\\n        }\\n        if(num == 0)\\n        {\\n            return 0;\\n        }\\n        long long ans = 0;\\n        for(int i = 0; i < cnt; i++)\\n        {\\n            if(i < k)\\n            {\\n                ans += (num - 1) * (num - 1);\\n            }\\n            else\\n            {\\n                ans += (num) * (num);\\n            }\\n        }\\n        while(!diff.empty())\\n        {\\n            ans += diff.top() * diff.top();\\n            diff.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360055,
                "title": "o-nlog-n-solution-beats-99-14",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nNote that y=x^2 is a convex function. Therefore we start from deducing maximal difference.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n  O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n) to storage the diff list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Further improvement\\n\\nWe can use python Counter to for loop different diff\\'s elements. Then, the time complexity can be reduced to O(mlog(m)), where m is the number of all different diff\\'s elements.\\n# Code\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        diff = [abs(nums1[i] - nums2[i]) for i in range(len(nums1))]\\n        diff.sort(reverse=True)\\n        prefix = list(accumulate(diff))\\n        total = k1+k2\\n        for i in range(1, n):\\n            if prefix[i-1] - i*diff[i] > total:\\n                if i == 1:\\n                    diff[0] -= total\\n                    return sum(d**2 for d in diff)\\n                else:\\n                    remain = (prefix[i-1] - i*diff[i] - total)\\n                    \\n                    left = ((remain // i + diff[i])**2)*(i - remain%i) + (remain%i)*((remain // i + 1 + diff[i])**2)\\n                    tmp = 0\\n                    for j in range(i, n):\\n                        tmp += diff[j]*diff[j]\\n                    return left + tmp\\n        else:\\n            remain = prefix[-1] - total\\n            if remain <= 0:\\n                return 0\\n            return ((remain//n)**2)*(n-remain%n) + ((remain//n + 1)**2)*(remain%n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n = len(nums1)\\n        diff = [abs(nums1[i] - nums2[i]) for i in range(len(nums1))]\\n        diff.sort(reverse=True)\\n        prefix = list(accumulate(diff))\\n        total = k1+k2\\n        for i in range(1, n):\\n            if prefix[i-1] - i*diff[i] > total:\\n                if i == 1:\\n                    diff[0] -= total\\n                    return sum(d**2 for d in diff)\\n                else:\\n                    remain = (prefix[i-1] - i*diff[i] - total)\\n                    \\n                    left = ((remain // i + diff[i])**2)*(i - remain%i) + (remain%i)*((remain // i + 1 + diff[i])**2)\\n                    tmp = 0\\n                    for j in range(i, n):\\n                        tmp += diff[j]*diff[j]\\n                    return left + tmp\\n        else:\\n            remain = prefix[-1] - total\\n            if remain <= 0:\\n                return 0\\n            return ((remain//n)**2)*(n-remain%n) + ((remain//n + 1)**2)*(remain%n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349289,
                "title": "easy-c-solution-without-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans = 0 ;\\n        priority_queue<long long> pq ; \\n        vector<long long > v(1e5+1  , 0) ;\\n        for(int i = 0 ; i < nums1.size() ; i++){\\n            v[abs(nums1[i] - nums2[i])]++ ;\\n        }\\n        long long k  = k1 + k2 ;\\n        for(int i = 1e5 ; i >= 1 ; i--){\\n            long long val = v[i] ; \\n            if(val <= k){\\n                if(i == 1)return 0 ; \\n                // v[i] = 0 ; \\n                v[i-1] += v[i] ;\\n                k -= v[i] ; \\n                v[i] = 0 ;\\n            }\\n            else{\\n                if(i == 0)return 0 ;\\n                v[i] -= k ;\\n                v[i-1]+= k ;\\n                break ;\\n            }\\n        }\\n        for(int i = 0 ; i <= 1e5 ; i++){\\n            ans += (long long )i*i *  (long long)v[i] ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans = 0 ;\\n        priority_queue<long long> pq ; \\n        vector<long long > v(1e5+1  , 0) ;\\n        for(int i = 0 ; i < nums1.size() ; i++){\\n            v[abs(nums1[i] - nums2[i])]++ ;\\n        }\\n        long long k  = k1 + k2 ;\\n        for(int i = 1e5 ; i >= 1 ; i--){\\n            long long val = v[i] ; \\n            if(val <= k){\\n                if(i == 1)return 0 ; \\n                // v[i] = 0 ; \\n                v[i-1] += v[i] ;\\n                k -= v[i] ; \\n                v[i] = 0 ;\\n            }\\n            else{\\n                if(i == 0)return 0 ;\\n                v[i] -= k ;\\n                v[i-1]+= k ;\\n                break ;\\n            }\\n        }\\n        for(int i = 0 ; i <= 1e5 ; i++){\\n            ans += (long long )i*i *  (long long)v[i] ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339089,
                "title": "c-priority-queue-solution-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        map<int ,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff = abs(nums1[i]-nums2[i]);\\n            m[diff]++;\\n        }\\n        priority_queue<int> pq;\\n        for(auto i:m)\\n        pq.push(i.first);\\n        int total = k1+k2;\\n        while(!pq.empty() && total>0)\\n        {\\n            int node = pq.top();\\n            if(node==0)\\n            break;\\n            if(m[node]==0)\\n            continue;\\n            int cnt = m[node];\\n            int tmp = min(cnt,total);\\n            total-=tmp;\\n            m[node]-=tmp;\\n            m[node-1]+=tmp;\\n            if(m[node]==0)\\n            pq.pop();\\n            if(node-1>0 && m[node-1]>0)\\n            {\\n                if(pq.size()==0)\\n                pq.push(node-1);\\n                else if(pq.size()>0 && pq.top()!=node-1)\\n                pq.push(node-1);\\n            }\\n        }\\n        long long ans=0;\\n        for(auto i:m)\\n        {\\n            long long num = i.first;\\n            long long fre = i.second;\\n            ans+=((num*num))*fre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        map<int ,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            int diff = abs(nums1[i]-nums2[i]);\\n            m[diff]++;\\n        }\\n        priority_queue<int> pq;\\n        for(auto i:m)\\n        pq.push(i.first);\\n        int total = k1+k2;\\n        while(!pq.empty() && total>0)\\n        {\\n            int node = pq.top();\\n            if(node==0)\\n            break;\\n            if(m[node]==0)\\n            continue;\\n            int cnt = m[node];\\n            int tmp = min(cnt,total);\\n            total-=tmp;\\n            m[node]-=tmp;\\n            m[node-1]+=tmp;\\n            if(m[node]==0)\\n            pq.pop();\\n            if(node-1>0 && m[node-1]>0)\\n            {\\n                if(pq.size()==0)\\n                pq.push(node-1);\\n                else if(pq.size()>0 && pq.top()!=node-1)\\n                pq.push(node-1);\\n            }\\n        }\\n        long long ans=0;\\n        for(auto i:m)\\n        {\\n            long long num = i.first;\\n            long long fre = i.second;\\n            ans+=((num*num))*fre;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210349,
                "title": "java-solutions-two-solutions-1-greedy-approach-2-treemap",
                "content": "\\n# code using treemap\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long ans = 0;\\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n        int i,n=nums1.length;\\n        for(i=0;i<n;i++)\\n        {\\n            int diff=Math.abs(nums1[i]-nums2[i]);\\n            map.put(diff,map.getOrDefault(diff,0)+1);\\n        }\\n        int k=k1+k2;\\n        while(k>0)\\n        {\\n            int largest=map.lastKey();\\n            if(largest==0) return 0;\\n            int mini=Math.min(k,map.get(largest));\\n            map.put(largest-1,map.getOrDefault(largest-1,0)+mini);\\n            k-=mini;\\n            map.put(largest,map.get(largest)-mini);\\n            if(map.get(largest)==0)\\n                map.remove(largest);\\n        }\\n        for(int key:map.keySet())\\n        {\\n            long x=key;\\n            long y=map.get(key);\\n            ans+=x*x*y;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# code greedy approach\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long ans = 0;\\n        int diff[] = new int[(int) 1e5 + 1];\\n        Arrays.fill(diff, 0);\\n        int i, n = nums1.length, k = k1 + k2;\\n        for (i = 0; i < n; i++) {\\n            diff[Math.abs(nums1[i] - nums2[i])]++;\\n        }\\n        for (i = 100000; i >= 1; i--) {\\n            int curr = diff[i];\\n            if(diff[i]<=0)\\n                continue;\\n            else if (curr <= k) {\\n                diff[i] = 0;\\n                diff[i - 1] += curr;\\n                k-=curr;\\n            } else {\\n                diff[i] -= k;\\n                diff[i - 1] += k;\\n                break;\\n            }\\n        }\\n        for (i = 1; i <= 100000; i++) {\\n            long x=(long)i;\\n            long y=(long)diff[i];\\n            long temp= (x*x);\\n            temp*=y;\\n            ans+=temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long ans = 0;\\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n        int i,n=nums1.length;\\n        for(i=0;i<n;i++)\\n        {\\n            int diff=Math.abs(nums1[i]-nums2[i]);\\n            map.put(diff,map.getOrDefault(diff,0)+1);\\n        }\\n        int k=k1+k2;\\n        while(k>0)\\n        {\\n            int largest=map.lastKey();\\n            if(largest==0) return 0;\\n            int mini=Math.min(k,map.get(largest));\\n            map.put(largest-1,map.getOrDefault(largest-1,0)+mini);\\n            k-=mini;\\n            map.put(largest,map.get(largest)-mini);\\n            if(map.get(largest)==0)\\n                map.remove(largest);\\n        }\\n        for(int key:map.keySet())\\n        {\\n            long x=key;\\n            long y=map.get(key);\\n            ans+=x*x*y;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        long ans = 0;\\n        int diff[] = new int[(int) 1e5 + 1];\\n        Arrays.fill(diff, 0);\\n        int i, n = nums1.length, k = k1 + k2;\\n        for (i = 0; i < n; i++) {\\n            diff[Math.abs(nums1[i] - nums2[i])]++;\\n        }\\n        for (i = 100000; i >= 1; i--) {\\n            int curr = diff[i];\\n            if(diff[i]<=0)\\n                continue;\\n            else if (curr <= k) {\\n                diff[i] = 0;\\n                diff[i - 1] += curr;\\n                k-=curr;\\n            } else {\\n                diff[i] -= k;\\n                diff[i - 1] += k;\\n                break;\\n            }\\n        }\\n        for (i = 1; i <= 100000; i++) {\\n            long x=(long)i;\\n            long y=(long)diff[i];\\n            long temp= (x*x);\\n            temp*=y;\\n            ans+=temp;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190960,
                "title": "261-ms",
                "content": "```ruby\\ndef min_sum_square_diff a, b, ka, kb\\n    a.map!.with_index { (_1 - b[_2]).abs }\\n    k, s, z, f = ka + kb, a.sum, a.size, 0\\n    return a.sum { _1 ** 2 } if k == 0\\n    return 0 if k >= s\\n    a.sort!\\n    for i in 0..z - 2\\n        b = f + (z - i) * a[i]\\n        if s - b <= k\\n            k -= s - b\\n            a.fill a[i], i + 1\\n            break\\n        end\\n        f += a[i]\\n    end\\n    if k > 0\\n        i = z - 1\\n        i -= 1 while i > 0 && a[i - 1] == a[i]\\n        x, k = k.divmod z - i\\n        for j in i...z\\n            (k -= 1; a[j] -= 1) if k > 0\\n            a[j] -= x\\n        end\\n    end\\n    a.sum { _1 ** 2 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_sum_square_diff a, b, ka, kb\\n    a.map!.with_index { (_1 - b[_2]).abs }\\n    k, s, z, f = ka + kb, a.sum, a.size, 0\\n    return a.sum { _1 ** 2 } if k == 0\\n    return 0 if k >= s\\n    a.sort!\\n    for i in 0..z - 2\\n        b = f + (z - i) * a[i]\\n        if s - b <= k\\n            k -= s - b\\n            a.fill a[i], i + 1\\n            break\\n        end\\n        f += a[i]\\n    end\\n    if k > 0\\n        i = z - 1\\n        i -= 1 while i > 0 && a[i - 1] == a[i]\\n        x, k = k.divmod z - i\\n        for j in i...z\\n            (k -= 1; a[j] -= 1) if k > 0\\n            a[j] -= x\\n        end\\n    end\\n    a.sum { _1 ** 2 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3170197,
                "title": "c",
                "content": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)b - *(int*)a;\\n}\\nlong long minSumSquareDiff(int* nums1, int nums1Size, int* nums2, int nums2Size, int k1, int k2){\\n    int n = nums1Size;\\n    int k = k1 + k2 ;\\n    int* diff = malloc(n * sizeof(int));\\n    for(int i = 0; i < n; i++){\\n        diff[i] = abs(nums1[i] - nums2[i]);\\n    }\\n    qsort(diff, n, sizeof(int), cmpfunc) ;\\n    long long* presum = malloc(n * sizeof(long long)) ;\\n    presum[0] = diff[0] ;\\n    for(int i = 1; i < n; i++){\\n        presum[i] = presum[i-1] + diff[i] ;\\n    }\\n    if(presum[n-1] <= k)\\n        return 0 ;\\n    int p = 0 ;\\n    while(p < n && (presum[p] - (long long)diff[p]*(p+1)) <= k )\\n        p++ ;\\n    p-- ;\\n\\n    int left = k - (presum[p] - (long long)diff[p]*(p+1)) ;\\n    int extra = left / (p+1) ;\\n    int r = left % (p+1) ;\\n    for(int i = 0; i < r ; i++)\\n        diff[i] = diff[p] - (extra + 1) ;\\n    for(int i = r; i <= p; i++)\\n        diff[i] = diff[p] - extra ;\\n    long long ans = 0; \\n    for(int i = 0; i < n; i++)\\n        ans += (long long)diff[i] * diff[i] ;\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)b - *(int*)a;\\n}\\nlong long minSumSquareDiff(int* nums1, int nums1Size, int* nums2, int nums2Size, int k1, int k2){\\n    int n = nums1Size;\\n    int k = k1 + k2 ;\\n    int* diff = malloc(n * sizeof(int));\\n    for(int i = 0; i < n; i++){\\n        diff[i] = abs(nums1[i] - nums2[i]);\\n    }\\n    qsort(diff, n, sizeof(int), cmpfunc) ;\\n    long long* presum = malloc(n * sizeof(long long)) ;\\n    presum[0] = diff[0] ;\\n    for(int i = 1; i < n; i++){\\n        presum[i] = presum[i-1] + diff[i] ;\\n    }\\n    if(presum[n-1] <= k)\\n        return 0 ;\\n    int p = 0 ;\\n    while(p < n && (presum[p] - (long long)diff[p]*(p+1)) <= k )\\n        p++ ;\\n    p-- ;\\n\\n    int left = k - (presum[p] - (long long)diff[p]*(p+1)) ;\\n    int extra = left / (p+1) ;\\n    int r = left % (p+1) ;\\n    for(int i = 0; i < r ; i++)\\n        diff[i] = diff[p] - (extra + 1) ;\\n    for(int i = r; i <= p; i++)\\n        diff[i] = diff[p] - extra ;\\n    long long ans = 0; \\n    for(int i = 0; i < n; i++)\\n        ans += (long long)diff[i] * diff[i] ;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3021866,
                "title": "binary-search-fully-explained-python",
                "content": "You should realise that it does not matter whether we reduce `nums1[i]` or `nums2[i]`\\nWhat matters is that we reduce their difference. \\n\\nIn 1 step we can reduce any difference by 1, maximum `k1+k2` steps are allowed\\n\\nWe should always try to reduce the largest difference first (can be easily proved)\\n\\nWe can use a max-heap/priorityque to always get the largest diff, reduce it to the next largest difference and then put it back in the heap but thats not very efficient. \\n\\nRephrase the problem to: **minimise the maximum value in the difference array**\\nWe can use binary search to find that minimum value.\\n\\n**Edge case**: sometimes there are extra operations left even after the minimisation\\nexample: difference array = [3,3,3], k = 2\\n**Time: O(n log n)**\\n**Space: O(n)**, can be reduced to O(1) if you change nums1 and nums2\\n```\\ndef minSumSquareDiff(self, n1: List[int], n2: List[int], k1: int, k2: int) -> int:\\n    k = k1+k2\\n    diff = [abs(n1[i] - n2[i]) for i in range(len(n1))]\\n\\n    operationCount = lambda x: sum([max(0, d - x) for d in diff])\\n    L = 0; R = max(diff)\\n    while L < R:\\n        M = (L+R)//2\\n        if operationCount(M) <= k:\\n            R = M\\n        else:\\n            L = M+1\\n\\n    if not L: return 0\\n\\n    count = k - operationCount(L)\\n    res = 0\\n    for d in diff:\\n        if d < L:\\n            res += d**2\\n        elif count:\\n            res += (L - 1)**2\\n            count -= 1\\n        else:\\n            res += L**2\\n    \\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef minSumSquareDiff(self, n1: List[int], n2: List[int], k1: int, k2: int) -> int:\\n    k = k1+k2\\n    diff = [abs(n1[i] - n2[i]) for i in range(len(n1))]\\n\\n    operationCount = lambda x: sum([max(0, d - x) for d in diff])\\n    L = 0; R = max(diff)\\n    while L < R:\\n        M = (L+R)//2\\n        if operationCount(M) <= k:\\n            R = M\\n        else:\\n            L = M+1\\n\\n    if not L: return 0\\n\\n    count = k - operationCount(L)\\n    res = 0\\n    for d in diff:\\n        if d < L:\\n            res += d**2\\n        elif count:\\n            res += (L - 1)**2\\n            count -= 1\\n        else:\\n            res += L**2\\n    \\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3010257,
                "title": "java-binary-search-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        int lo = 0, hi = Integer.MAX_VALUE;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (check(nums1, nums2, mid, k1 + k2) >= 0) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        long left = check(nums1, nums2, lo, k1 + k2);\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int d = Math.abs(nums1[i] -  nums2[i]);\\n            if (d >= lo && lo >= 1 && left > 0) {\\n                res += (long)(lo - 1) * (lo - 1);\\n                left--;\\n            } else if (d > lo) {\\n                res += (long)lo * lo;\\n            } else {\\n                res += (long)d * d;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public long check(int[] nums1, int[] nums2, int diff, long k) {\\n        for (int i = 0; i < nums1.length; i++) {\\n            int d = Math.abs(nums1[i] -  nums2[i]);\\n            if (d > diff) {\\n                k -= d - diff;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        int lo = 0, hi = Integer.MAX_VALUE;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (check(nums1, nums2, mid, k1 + k2) >= 0) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        long left = check(nums1, nums2, lo, k1 + k2);\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int d = Math.abs(nums1[i] -  nums2[i]);\\n            if (d >= lo && lo >= 1 && left > 0) {\\n                res += (long)(lo - 1) * (lo - 1);\\n                left--;\\n            } else if (d > lo) {\\n                res += (long)lo * lo;\\n            } else {\\n                res += (long)d * d;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public long check(int[] nums1, int[] nums2, int diff, long k) {\\n        for (int i = 0; i < nums1.length; i++) {\\n            int d = Math.abs(nums1[i] -  nums2[i]);\\n            if (d > diff) {\\n                k -= d - diff;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000127,
                "title": "easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func minSumSquareDiff(_ nums1: [Int], _ nums2: [Int], _ k1: Int, _ k2: Int) -> Int {\\n        guard nums1.count > 0 else { return 0 }\\n        var diff = Array(repeating: 0, count: nums1.count), maxEle = 0\\n        for i in 0 ..< nums1.count {\\n            diff[i] = abs(nums1[i] - nums2[i])\\n            maxEle = maxEle > diff[i] ? maxEle : diff[i]\\n        }\\n        var k = k1 + k2, bucket = Array(repeating: 0, count: maxEle + 1)\\n        for i in 0 ..< nums1.count {\\n            bucket[diff[i]] += 1\\n        }\\n        var i = maxEle\\n        while i > 0 {\\n            if bucket[i] > 0 {\\n                let minus = min(bucket[i],k)\\n                bucket[i] -= minus \\n                bucket[i - 1] += minus \\n                k -= minus\\n            }\\n            i -= 1\\n        }\\n        var ans = 0\\n        i = maxEle \\n        while i > 0 {\\n            ans += (bucket[i] * (i * i))\\n            i -= 1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minSumSquareDiff(_ nums1: [Int], _ nums2: [Int], _ k1: Int, _ k2: Int) -> Int {\\n        guard nums1.count > 0 else { return 0 }\\n        var diff = Array(repeating: 0, count: nums1.count), maxEle = 0\\n        for i in 0 ..< nums1.count {\\n            diff[i] = abs(nums1[i] - nums2[i])\\n            maxEle = maxEle > diff[i] ? maxEle : diff[i]\\n        }\\n        var k = k1 + k2, bucket = Array(repeating: 0, count: maxEle + 1)\\n        for i in 0 ..< nums1.count {\\n            bucket[diff[i]] += 1\\n        }\\n        var i = maxEle\\n        while i > 0 {\\n            if bucket[i] > 0 {\\n                let minus = min(bucket[i],k)\\n                bucket[i] -= minus \\n                bucket[i - 1] += minus \\n                k -= minus\\n            }\\n            i -= 1\\n        }\\n        var ans = 0\\n        i = maxEle \\n        while i > 0 {\\n            ans += (bucket[i] * (i * i))\\n            i -= 1\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920903,
                "title": "17-lines-of-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(log(n))** , n = max(nums1[i] - nums2[i])\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** , n = max(nums1[i] - nums2[i])\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        map<long long int, long long int> mp;\\n        for(int i = 0; i < n; i++) mp[abs(nums1[i] - nums2[i])]++;\\n        long long int k = k1 + k2;\\n        for(auto i = mp.rbegin(); i != mp.rend() && k > 0; i++){\\n            int mn = min(i->second, k);\\n            i->second -= mn;\\n            k -= mn;\\n            if(i->first == 0) break;\\n            mp[i->first - 1] += mn;\\n        }\\n        long long int ans = 0;\\n        for(auto i = mp.begin(); i != mp.end(); i++){\\n            if(i->second) ans += i->first*i->first*i->second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        map<long long int, long long int> mp;\\n        for(int i = 0; i < n; i++) mp[abs(nums1[i] - nums2[i])]++;\\n        long long int k = k1 + k2;\\n        for(auto i = mp.rbegin(); i != mp.rend() && k > 0; i++){\\n            int mn = min(i->second, k);\\n            i->second -= mn;\\n            k -= mn;\\n            if(i->first == 0) break;\\n            mp[i->first - 1] += mn;\\n        }\\n        long long int ans = 0;\\n        for(auto i = mp.begin(); i != mp.end(); i++){\\n            if(i->second) ans += i->first*i->first*i->second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891589,
                "title": "solution-in-go-with-sorting-and-counting-where-to-we-can-reduce-the-top-part",
                "content": "# Intuition\\n\\nIt seems we just can have one array and merge k1 and k2 and then reduce the top elements accordingly.\\n\\n# Approach\\n\\nOnce we understand how much we need to reduce, we can calculate how far in the sorted deltas we would be able to reduce, to get linear time.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(NLogN)$$\\n\\n# Code\\n```\\n\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n    abs := func (a int) int {\\n        if a < 0 {\\n            return -a\\n        }\\n        return a\\n    }\\n\\n    nums := make([]int, len(nums1))\\n    for i, a := range nums1 {\\n        b := nums2[i]\\n        nums[i] = abs(a-b)\\n    }\\n    k := k1+k2\\n    \\n    sort.Ints(nums)\\n    var i int\\n    for i = len(nums)-2; k > 0 && i >= 0; i-- {\\n        reduction := (nums[i+1] - nums[i])*(len(nums)-1 - i)\\n        if reduction <= k {\\n            k -= reduction\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    // Run reduction\\n    target := nums[i+1] - k / (len(nums)-1 - i)\\n    if target < 0 {\\n        target = 0\\n    }\\n    rest := k % (len(nums)-1 - i)\\n    for j := i+1; j < len(nums); j++ {\\n        nums[j] = target\\n        if rest > 0 && nums[j] > 0 {\\n            nums[j]--\\n            rest--\\n        }\\n    }\\n\\n    var ans int64\\n    for _, v := range nums {\\n        ans += int64(v * v)\\n    }\\n    return ans    \\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\n\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n    abs := func (a int) int {\\n        if a < 0 {\\n            return -a\\n        }\\n        return a\\n    }\\n\\n    nums := make([]int, len(nums1))\\n    for i, a := range nums1 {\\n        b := nums2[i]\\n        nums[i] = abs(a-b)\\n    }\\n    k := k1+k2\\n    \\n    sort.Ints(nums)\\n    var i int\\n    for i = len(nums)-2; k > 0 && i >= 0; i-- {\\n        reduction := (nums[i+1] - nums[i])*(len(nums)-1 - i)\\n        if reduction <= k {\\n            k -= reduction\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    // Run reduction\\n    target := nums[i+1] - k / (len(nums)-1 - i)\\n    if target < 0 {\\n        target = 0\\n    }\\n    rest := k % (len(nums)-1 - i)\\n    for j := i+1; j < len(nums); j++ {\\n        nums[j] = target\\n        if rest > 0 && nums[j] > 0 {\\n            nums[j]--\\n            rest--\\n        }\\n    }\\n\\n    var ans int64\\n    for _, v := range nums {\\n        ans += int64(v * v)\\n    }\\n    return ans    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2880732,
                "title": "swift-solution-100-efficient",
                "content": "```\\nclass Solution {\\n    func minSumSquareDiff(_ nums1: [Int], _ nums2: [Int], _ k1: Int, _ k2: Int) -> Int {\\n        var minSumSquare = 0\\n        var diffs = Array(repeating: 0, count: 100_001)\\n        var totalDiff = 0\\n        var kSum = k1 + k2\\n        var currentDiff = 0\\n        var maxDiff = 0\\n        for i in 0..<nums1.count \\n        {\\n            currentDiff = abs(nums1[i] - nums2[i])\\n            if currentDiff > 0 \\n            {\\n                totalDiff += currentDiff\\n                diffs[currentDiff] += 1\\n                maxDiff = max(maxDiff, currentDiff)\\n            }\\n        }\\n        if totalDiff <= kSum \\n        {\\n            return 0\\n        }\\n        for i in (0...maxDiff).reversed() where kSum > 0 {\\n            if diffs[i] > 0 \\n            {\\n                if diffs[i] >= kSum \\n                {\\n                    diffs[i] -= kSum\\n                    diffs[i-1] += kSum\\n                    kSum = 0\\n                } else \\n                {\\n                    diffs[i-1] += diffs[i]\\n                    kSum -= diffs[i]\\n                    diffs[i] = 0\\n                }\\n            }\\n        }\\n\\n        for i in 0...maxDiff {\\n            if diffs[i] > 0 {\\n                minSumSquare += Int(pow(Double(i), 2)) * diffs[i]\\n            }\\n        }\\n        return minSumSquare\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minSumSquareDiff(_ nums1: [Int], _ nums2: [Int], _ k1: Int, _ k2: Int) -> Int {\\n        var minSumSquare = 0\\n        var diffs = Array(repeating: 0, count: 100_001)\\n        var totalDiff = 0\\n        var kSum = k1 + k2\\n        var currentDiff = 0\\n        var maxDiff = 0\\n        for i in 0..<nums1.count \\n        {\\n            currentDiff = abs(nums1[i] - nums2[i])\\n            if currentDiff > 0 \\n            {\\n                totalDiff += currentDiff\\n                diffs[currentDiff] += 1\\n                maxDiff = max(maxDiff, currentDiff)\\n            }\\n        }\\n        if totalDiff <= kSum \\n        {\\n            return 0\\n        }\\n        for i in (0...maxDiff).reversed() where kSum > 0 {\\n            if diffs[i] > 0 \\n            {\\n                if diffs[i] >= kSum \\n                {\\n                    diffs[i] -= kSum\\n                    diffs[i-1] += kSum\\n                    kSum = 0\\n                } else \\n                {\\n                    diffs[i-1] += diffs[i]\\n                    kSum -= diffs[i]\\n                    diffs[i] = 0\\n                }\\n            }\\n        }\\n\\n        for i in 0...maxDiff {\\n            if diffs[i] > 0 {\\n                minSumSquare += Int(pow(Double(i), 2)) * diffs[i]\\n            }\\n        }\\n        return minSumSquare\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821455,
                "title": "python-binary-search-o-n-logn-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int: \\n        def count(b):\\n            return sum(d - b if d - b > 0 else 0 for d in diff)\\n        \\n        diff, n, k = sorted(abs(x - y) for x, y in zip(nums1, nums2)), len(nums1), k1 + k2\\n        l, r = 0, 100000\\n        while l < r:\\n            mid = (l + r) // 2\\n            if count(mid) > k:\\n                l = mid + 1\\n            else:\\n                r = mid\\n\\n        rem = k - count(l) if l > 0 else 0\\n        return sum(d ** 2 if d < l else l ** 2 for d in diff[:n - rem]) + (l - 1) ** 2 * rem\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int: \\n        def count(b):\\n            return sum(d - b if d - b > 0 else 0 for d in diff)\\n        \\n        diff, n, k = sorted(abs(x - y) for x, y in zip(nums1, nums2)), len(nums1), k1 + k2\\n        l, r = 0, 100000\\n        while l < r:\\n            mid = (l + r) // 2\\n            if count(mid) > k:\\n                l = mid + 1\\n            else:\\n                r = mid\\n\\n        rem = k - count(l) if l > 0 else 0\\n        return sum(d ** 2 if d < l else l ** 2 for d in diff[:n - rem]) + (l - 1) ** 2 * rem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791380,
                "title": "python-bucket-sort-easy-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        \\n        differences = [ abs(x - y) for x, y in zip(nums1, nums2)]\\n        \\n        if sum(differences) <= k1 + k2:\\n            return 0\\n        \\n        if k1 + k2 == 0:\\n            return sum([x**2 for x in differences])\\n        \\n        diff = defaultdict(int)\\n        for num in differences:\\n            diff[num] += 1\\n        \\n        total = k1 + k2\\n        maxK = max(diff.keys())\\n        for k in range(maxK, 0, -1):\\n            if diff[k] > 0:\\n                temp = min(total, diff[k])\\n                diff[k] -= temp\\n                diff[k - 1] += temp\\n                total-= temp\\n        \\n        res = 0\\n\\n        for k, v in diff.items():\\n            res += (v * (k **2))\\n        \\n        return res\\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        \\n        differences = [ abs(x - y) for x, y in zip(nums1, nums2)]\\n        \\n        if sum(differences) <= k1 + k2:\\n            return 0\\n        \\n        if k1 + k2 == 0:\\n            return sum([x**2 for x in differences])\\n        \\n        diff = defaultdict(int)\\n        for num in differences:\\n            diff[num] += 1\\n        \\n        total = k1 + k2\\n        maxK = max(diff.keys())\\n        for k in range(maxK, 0, -1):\\n            if diff[k] > 0:\\n                temp = min(total, diff[k])\\n                diff[k] -= temp\\n                diff[k - 1] += temp\\n                total-= temp\\n        \\n        res = 0\\n\\n        for k, v in diff.items():\\n            res += (v * (k **2))\\n        \\n        return res\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762211,
                "title": "python-priority-queue-approach-faster-than-77",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        sz, diffHash = len(nums1), defaultdict(int)\\n        total, heap, ans = k1 + k2, [], 0\\n        for num1, num2 in zip(nums1, nums2):\\n            diffHash[abs(num1 - num2)] += 1\\n        for diff in diffHash:\\n            if diff == 0:\\n                continue\\n            heappush(heap, [-diff, diffHash[diff]])\\n        while heap and total > 0:\\n            diffVal = heappop(heap)\\n            if len(heap) == 0:\\n                minimum = min(total, diffVal[1])\\n                total -= minimum\\n                diffVal[1] -= minimum\\n                if -diffVal[0] - 1 > 0: \\n                    heappush(heap, [-(-diffVal[0] - 1), minimum])\\n                if diffVal[1] > 0: \\n                    heappush(heap, diffVal)\\n            else:\\n                minimum = min(total, diffVal[1])\\n                total -= minimum\\n                diffVal[1] -= minimum\\n                if diffVal[1] > 0: \\n                    heappush(heap, diffVal)\\n                if -heap[0][0] == -diffVal[0] - 1:\\n                    diffVal1 = heappop(heap)\\n                    diffVal1[1] += minimum\\n                    heappush(heap, diffVal1)\\n                elif -diffVal[0] - 1 > 0:\\n                    heappush(heap, [-(-diffVal[0] - 1), minimum])\\n        while heap:\\n            diffVal = heappop(heap)\\n            ans += (diffVal[0] * diffVal[0] * diffVal[1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        sz, diffHash = len(nums1), defaultdict(int)\\n        total, heap, ans = k1 + k2, [], 0\\n        for num1, num2 in zip(nums1, nums2):\\n            diffHash[abs(num1 - num2)] += 1\\n        for diff in diffHash:\\n            if diff == 0:\\n                continue\\n            heappush(heap, [-diff, diffHash[diff]])\\n        while heap and total > 0:\\n            diffVal = heappop(heap)\\n            if len(heap) == 0:\\n                minimum = min(total, diffVal[1])\\n                total -= minimum\\n                diffVal[1] -= minimum\\n                if -diffVal[0] - 1 > 0: \\n                    heappush(heap, [-(-diffVal[0] - 1), minimum])\\n                if diffVal[1] > 0: \\n                    heappush(heap, diffVal)\\n            else:\\n                minimum = min(total, diffVal[1])\\n                total -= minimum\\n                diffVal[1] -= minimum\\n                if diffVal[1] > 0: \\n                    heappush(heap, diffVal)\\n                if -heap[0][0] == -diffVal[0] - 1:\\n                    diffVal1 = heappop(heap)\\n                    diffVal1[1] += minimum\\n                    heappush(heap, diffVal1)\\n                elif -diffVal[0] - 1 > 0:\\n                    heappush(heap, [-(-diffVal[0] - 1), minimum])\\n        while heap:\\n            diffVal = heappop(heap)\\n            ans += (diffVal[0] * diffVal[0] * diffVal[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747648,
                "title": "java-time-o-log-max-n-space-o-n-binary-search",
                "content": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length, k = k1+k2;\\n        long[] num = new long[n];\\n        long sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            num[i] = (long) Math.abs(nums1[i] - nums2[i]);\\n            sum += num[i];\\n        }\\n        if(sum<=k) return 0;\\n        \\n        long l = 0, r = 100001, pivot = -1;\\n        while(l<=r){\\n            long mid = (l+r)/2, s = 0;\\n            for(int i = 0; i<n;i++)\\n                s += Math.max(num[i],mid) - mid;\\n            if(s <= k){\\n                pivot = mid;\\n                r = mid - 1;\\n            }else\\n                l = mid + 1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(num[i]>pivot){\\n                k -= (num[i]-pivot);\\n                num[i] = pivot;\\n            }\\n        }\\n        \\n        for(int i=0;i<n&&k>0;i++){\\n            if(num[i]==pivot){\\n                num[i]--;\\n                k--;\\n            }\\n        }\\n        \\n        long result = 0L;\\n        for(long m:num)\\n            result += m*m;\\n        return result;\\n    }\\n}\\n\\n//4,4,4,3, k = 2\\n//3,4,4,4\\n//\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length, k = k1+k2;\\n        long[] num = new long[n];\\n        long sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            num[i] = (long) Math.abs(nums1[i] - nums2[i]);\\n            sum += num[i];\\n        }\\n        if(sum<=k) return 0;\\n        \\n        long l = 0, r = 100001, pivot = -1;\\n        while(l<=r){\\n            long mid = (l+r)/2, s = 0;\\n            for(int i = 0; i<n;i++)\\n                s += Math.max(num[i],mid) - mid;\\n            if(s <= k){\\n                pivot = mid;\\n                r = mid - 1;\\n            }else\\n                l = mid + 1;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(num[i]>pivot){\\n                k -= (num[i]-pivot);\\n                num[i] = pivot;\\n            }\\n        }\\n        \\n        for(int i=0;i<n&&k>0;i++){\\n            if(num[i]==pivot){\\n                num[i]--;\\n                k--;\\n            }\\n        }\\n        \\n        long result = 0L;\\n        for(long m:num)\\n            result += m*m;\\n        return result;\\n    }\\n}\\n\\n//4,4,4,3, k = 2\\n//3,4,4,4\\n//\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725416,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn min_sum_square_diff(nums1: Vec<i32>, nums2: Vec<i32>, k1: i32, k2: i32) -> i64 {\\n        let n = nums1.len();       \\n        let mut a = vec![(0i64,0);n];\\n        let mut tot = 0;\\n        for i in 0..n {\\n            a[i] = ((nums1[i] - nums2[i]).abs() as i64, 1);\\n            tot += a[i].0;\\n        }\\n    \\n        let mut num = (k1+k2) as i64;\\n        if tot <= num {\\n            return 0\\n        }\\n    \\n        a.sort();\\n        while 0 < num && a.len() > 1 {\\n            let (b1v, b1num) = a.pop().unwrap();\\n            let (b2v, b2num) = a.pop().unwrap();\\n    \\n            let diff = b1v - b2v;\\n            if diff == 0 {\\n                a.push((b2v, b2num + b1num));\\n            } else if diff * b1num <= num {\\n                num -= diff * b1num;\\n                a.push((b2v, b2num + b1num));\\n            } else {\\n                let v = num / b1num;\\n                let av = num % b1num;\\n                a.push((b2v, b2num));\\n                a.push((b1v-v-1, av));\\n                a.push((b1v-v, b1num-av));\\n                num = 0;\\n            }\\n        }\\n    \\n        let mut result = 0;\\n        if num != 0 {\\n            let (left_v, left_num) = a.pop().unwrap();\\n            let v = num / left_num;\\n            let av = num % left_num;\\n    \\n            a.push((left_v-v-1, av));\\n            a.push((left_v-v, left_num-av));\\n        }\\n    \\n        for (v, num) in a {\\n            result += v * v * num;\\n        }  \\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_sum_square_diff(nums1: Vec<i32>, nums2: Vec<i32>, k1: i32, k2: i32) -> i64 {\\n        let n = nums1.len();       \\n        let mut a = vec![(0i64,0);n];\\n        let mut tot = 0;\\n        for i in 0..n {\\n            a[i] = ((nums1[i] - nums2[i]).abs() as i64, 1);\\n            tot += a[i].0;\\n        }\\n    \\n        let mut num = (k1+k2) as i64;\\n        if tot <= num {\\n            return 0\\n        }\\n    \\n        a.sort();\\n        while 0 < num && a.len() > 1 {\\n            let (b1v, b1num) = a.pop().unwrap();\\n            let (b2v, b2num) = a.pop().unwrap();\\n    \\n            let diff = b1v - b2v;\\n            if diff == 0 {\\n                a.push((b2v, b2num + b1num));\\n            } else if diff * b1num <= num {\\n                num -= diff * b1num;\\n                a.push((b2v, b2num + b1num));\\n            } else {\\n                let v = num / b1num;\\n                let av = num % b1num;\\n                a.push((b2v, b2num));\\n                a.push((b1v-v-1, av));\\n                a.push((b1v-v, b1num-av));\\n                num = 0;\\n            }\\n        }\\n    \\n        let mut result = 0;\\n        if num != 0 {\\n            let (left_v, left_num) = a.pop().unwrap();\\n            let v = num / left_num;\\n            let av = num % left_num;\\n    \\n            a.push((left_v-v-1, av));\\n            a.push((left_v-v, left_num-av));\\n        }\\n    \\n        for (v, num) in a {\\n            result += v * v * num;\\n        }  \\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2699814,
                "title": "python-o-n-klogn-o-n",
                "content": "# Complexity\\nN = len(nums1)\\nK = min(k1 + k2, len(nums1))\\n\\n- Time complexity: O(N + KlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        heap = [-abs(n1 - n2) for n1, n2 in zip(nums1, nums2)]\\n        total = k1 + k2\\n        if -sum(heap) <= total:\\n            return 0\\n\\n        heapq.heapify(heap)\\n        \\n        while total > 0:\\n            val = heapq.heappop(heap) \\n            diff = max(min(heap[0] - val, total), 1)\\n            heapq.heappush(heap, val + diff)\\n            total -= diff\\n        \\n        return sum(pow(e,2) for e in heap)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        heap = [-abs(n1 - n2) for n1, n2 in zip(nums1, nums2)]\\n        total = k1 + k2\\n        if -sum(heap) <= total:\\n            return 0\\n\\n        heapq.heapify(heap)\\n        \\n        while total > 0:\\n            val = heapq.heappop(heap) \\n            diff = max(min(heap[0] - val, total), 1)\\n            heapq.heappush(heap, val + diff)\\n            total -= diff\\n        \\n        return sum(pow(e,2) for e in heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696069,
                "title": "python3-binary-search-solution-o-nlogn",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n      k = k1 + k2\\n      diff_data = [abs(x - y) for x,y in zip(nums1, nums2)]\\n      left, right = 0, max(diff_data)\\n      \\n      while left < right:\\n        mid = floor((left + right)/2)\\n        k_needed = sum([max(0, x - mid) for x in diff_data])\\n        if k_needed <= k:\\n          right = mid\\n        else:\\n          left = mid + 1\\n        \\n      if left == 0: return 0\\n      else:\\n        return sum([min(x, left)**2 for x in diff_data]) \\\\\\n               - (left**2 - (left-1)**2)*(k - sum([max(0, x - left) for x in diff_data]))\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n      k = k1 + k2\\n      diff_data = [abs(x - y) for x,y in zip(nums1, nums2)]\\n      left, right = 0, max(diff_data)\\n      \\n      while left < right:\\n        mid = floor((left + right)/2)\\n        k_needed = sum([max(0, x - mid) for x in diff_data])\\n        if k_needed <= k:\\n          right = mid\\n        else:\\n          left = mid + 1\\n        \\n      if left == 0: return 0\\n      else:\\n        return sum([min(x, left)**2 for x in diff_data]) \\\\\\n               - (left**2 - (left-1)**2)*(k - sum([max(0, x - left) for x in diff_data]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564250,
                "title": "python-simple-heap-solution",
                "content": "\\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\\n        n, k = len(nums1), k1+k2\\n        \\n        ans = [abs(nums1[i]-nums2[i]) for i in range(n)]\\n        \\n        if k >= sum(ans):\\n            return 0\\n        \\n        res =  []\\n        \\n        for i in range(n):\\n            heapq.heappush(res,-abs(nums1[i]-nums2[i]))\\n            \\n        while k:\\n            val = max(k//n,1)\\n            heapq.heappush(res, heapq.heappop(res) + val)\\n            k -= val\\n            \\n        return sum([i*i for i in res])",
                "solutionTags": [],
                "code": "\\n    def minSumSquareDiff(self, nums1, nums2, k1, k2):\\n        n, k = len(nums1), k1+k2\\n        \\n        ans = [abs(nums1[i]-nums2[i]) for i in range(n)]\\n        \\n        if k >= sum(ans):\\n            return 0\\n        \\n        res =  []\\n        \\n        for i in range(n):\\n            heapq.heappush(res,-abs(nums1[i]-nums2[i]))\\n            \\n        while k:\\n            val = max(k//n,1)\\n            heapq.heappush(res, heapq.heappop(res) + val)\\n            k -= val\\n            \\n        return sum([i*i for i in res])",
                "codeTag": "Python3"
            },
            {
                "id": 2552091,
                "title": "java-explained-in-great-detail-why-how-bucket-sort-work-here-tc-sc-explained",
                "content": "// Bucket Sort\\n\\n// The greater the diff of 2 pairs, the greater the total diff\\n// So in order to reduce the total diff, we should eliminate as mych HIGHEST diff pairs as possible\\n// By eliminate I mean that we should REDUCE the highest diff to as low as possible to make the total diff smaller\\n\\n// Perform adiff in ALL the pairs of nums1[] and nums2[] and bucket them in accordance to the difference\\n// This means, find how many pairs make a diff of 5, how many make a diff of 7 and so on.\\n// SO we would know that the max diff that could happen is 7 (for example) and there are 3 pairs such pairs, so if we perform subtraction from these pairs then we can reduce the max diff to 6 (may be) or 5 (if K1 and k2 are not exhausted)\\n// Doing this we reduced the maximum diff to lower number, hence reduced the total diff\\n\\n// Lets say total diff comes out to be 25\\n// There were 2 pairs with 7 as a difference -> 7^2 = 49\\n// Also, there were 2 pairs with 3 as a difference -> 3^2 = 9\\n// k1 = 1, k2 = 2\\n// Now if I reduce each pair of 3 by 1, since k1 + k2 = 2, we will get 2 pirs with diff 2 -> 2^2 = 4\\n// Also, if we reduce each pair of 7 by 1, since k1 + k2 = 2, we will get 2 pairs with diff 6 -> 6^2 = 36\\n// Now we changed from 7^2 - 6^2 = 49 - 36 = 13\\n// Also, 3^2 - 2^2 = 9 - 4 = 5\\n\\n// So by reducing larger diff, we reduced the toal diff mych more that smaller ones so we reduce the larger ones\\n\\n// Why k1 + k2 ? \\n// These are the total number of operations we can perform and in order to create larger effect, they needs to go together\\n\\n\\n// TC : O(100_000); 100_000 = max diff possible\\n// SC : O(100_000) ->\\n```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        // \\'i\\' here would be the difference between nums1[j] and nums2[j] for some \\'j\\'\\n        // bucketDiff[i] means NUMBER of PAIRS of nums1[] and nums2[] that has \\'i\\' as a difference\\n        int[] bucketDiff = new int[100_001]; // max diff netween nums1[i] and nums2[i] could be 100_000\\n        long totalDiff = 0; // totalDiff could go beyond \\'int\\' range so take it as a long\\n        // the maxDiff and currDiff could max become 100_000 which is well under \\'int\\' range\\n        int maxDiff = 0; \\n        int currDiff;\\n        \\n        for(int i = 0; i < n; i++) {\\n            currDiff = Math.abs(nums1[i] - nums2[i]);\\n            if(currDiff > 0) { // if there is ANY diff, then update the count for that diff in bucketDiff\\n                totalDiff += currDiff;\\n                bucketDiff[currDiff]++; \\n                maxDiff = Math.max(maxDiff, currDiff);\\n            }\\n        }\\n        \\n        long kSum = k1 + k2;\\n        if(totalDiff <= kSum) { // if the totalDiff between nums1[] and nums2[] APIRS together is less than kSum, that means we can surely reduce the difference to 0\\n            return 0;\\n        }\\n        \\n        // start from the end to because we want to reduce the MAX difference as much as possible to have maximum impact on total diff\\n        for(int i = maxDiff; i > 0 && kSum > 0; i--) { // always check for kSum as well \\n            if (bucketDiff[i] > 0) {\\n                if(bucketDiff[i] > 0) { // if there are few pairs (bucketDiff[i] pairs) whose diff is \\'i\\' (i starts from max)\\n                    if(bucketDiff[i] >= kSum) { // if the total operations we can perform on the diff is lesser tham the num of pairs with diff \\'i\\'\\n                        bucketDiff[i] -= kSum; // we can reduce ATMOST kSum pairs by 1 to make them \\'i - 1\\' diff, so number of pairs with \\'i\\' diff is reduced by kSum\\n                        bucketDiff[i - 1] += kSum; // since we reduced kSum pairs by 1, this means that number of pairs with \\'i - 1\\' diff increases by kSum\\n                        kSum = 0; // kSum is fully exhausted\\n                    } else { // if kSum is greater, that means we can reduce ALL the pairs with \\'i\\' diff to \\'i - 1\\' diff\\n                        bucketDiff[i - 1] += bucketDiff[i]; // so \\'i - 1\\' diff increase by the num of pairs with \\'i\\' diff\\n                        kSum -= bucketDiff[i]; // kSum is reduced by num of pairs with \\'i\\' diff but kSum is not fully exhausted, we can still reduce few pairs\\' diff\\n                        bucketDiff[i] = 0; // num of pairs with \\'i\\' diff becomes 0\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // we need to return the SUM of square of diff of nums1[j] - nums2[j] for ALL j\\n        // bucketDiff[i] means number of paird with \\'i\\' diff so essentially \\'i\\' is the diff so needs to be SQUARED and bucketDiff[i] will be multiplied with i^2\\n        long res = 0;\\n        for(int i = maxDiff; i >= 0; i--) {\\n            if(bucketDiff[i] > 0) {\\n                res += bucketDiff[i] * (long) (Math.pow((long)i, 2)); // number of pairs with \\'i\\' diff * diff (i) square\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        // \\'i\\' here would be the difference between nums1[j] and nums2[j] for some \\'j\\'\\n        // bucketDiff[i] means NUMBER of PAIRS of nums1[] and nums2[] that has \\'i\\' as a difference\\n        int[] bucketDiff = new int[100_001]; // max diff netween nums1[i] and nums2[i] could be 100_000\\n        long totalDiff = 0; // totalDiff could go beyond \\'int\\' range so take it as a long\\n        // the maxDiff and currDiff could max become 100_000 which is well under \\'int\\' range\\n        int maxDiff = 0; \\n        int currDiff;\\n        \\n        for(int i = 0; i < n; i++) {\\n            currDiff = Math.abs(nums1[i] - nums2[i]);\\n            if(currDiff > 0) { // if there is ANY diff, then update the count for that diff in bucketDiff\\n                totalDiff += currDiff;\\n                bucketDiff[currDiff]++; \\n                maxDiff = Math.max(maxDiff, currDiff);\\n            }\\n        }\\n        \\n        long kSum = k1 + k2;\\n        if(totalDiff <= kSum) { // if the totalDiff between nums1[] and nums2[] APIRS together is less than kSum, that means we can surely reduce the difference to 0\\n            return 0;\\n        }\\n        \\n        // start from the end to because we want to reduce the MAX difference as much as possible to have maximum impact on total diff\\n        for(int i = maxDiff; i > 0 && kSum > 0; i--) { // always check for kSum as well \\n            if (bucketDiff[i] > 0) {\\n                if(bucketDiff[i] > 0) { // if there are few pairs (bucketDiff[i] pairs) whose diff is \\'i\\' (i starts from max)\\n                    if(bucketDiff[i] >= kSum) { // if the total operations we can perform on the diff is lesser tham the num of pairs with diff \\'i\\'\\n                        bucketDiff[i] -= kSum; // we can reduce ATMOST kSum pairs by 1 to make them \\'i - 1\\' diff, so number of pairs with \\'i\\' diff is reduced by kSum\\n                        bucketDiff[i - 1] += kSum; // since we reduced kSum pairs by 1, this means that number of pairs with \\'i - 1\\' diff increases by kSum\\n                        kSum = 0; // kSum is fully exhausted\\n                    } else { // if kSum is greater, that means we can reduce ALL the pairs with \\'i\\' diff to \\'i - 1\\' diff\\n                        bucketDiff[i - 1] += bucketDiff[i]; // so \\'i - 1\\' diff increase by the num of pairs with \\'i\\' diff\\n                        kSum -= bucketDiff[i]; // kSum is reduced by num of pairs with \\'i\\' diff but kSum is not fully exhausted, we can still reduce few pairs\\' diff\\n                        bucketDiff[i] = 0; // num of pairs with \\'i\\' diff becomes 0\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // we need to return the SUM of square of diff of nums1[j] - nums2[j] for ALL j\\n        // bucketDiff[i] means number of paird with \\'i\\' diff so essentially \\'i\\' is the diff so needs to be SQUARED and bucketDiff[i] will be multiplied with i^2\\n        long res = 0;\\n        for(int i = maxDiff; i >= 0; i--) {\\n            if(bucketDiff[i] > 0) {\\n                res += bucketDiff[i] * (long) (Math.pow((long)i, 2)); // number of pairs with \\'i\\' diff * diff (i) square\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546825,
                "title": "c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int N = nums1.size();\\n        vector<int> dif(N);\\n        for(int i=0;i<N;i++){\\n            dif[i] = abs(nums1[i]-nums2[i]);\\n        }\\n        int k = k1+k2;\\n        \\n        sort(dif.begin(),dif.end());\\n        reverse(dif.begin(),dif.end());\\n        \\n        vector<long long> Sum(N);\\n        Sum[0] = dif[0];\\n        for(int i=1;i<N;i++){\\n            Sum[i] = Sum[i-1] + (long long)dif[i];\\n        }\\n        \\n        int ind;\\n        for(ind=0;ind<N;ind++){\\n            long long total = Sum[ind] - (long long)(ind+1)*(long long)dif[ind];\\n            if(total > k) break;\\n        }\\n        ind--;\\n        for(int i=0;i<=ind;i++){\\n            k -= (dif[i]-dif[ind]);\\n            dif[i] = dif[ind];\\n        }\\n        if(k==0){\\n            long long Ans = 0;\\n            for(int i=0;i<N;i++){\\n                Ans += (long long)dif[i]*(long long)dif[i];\\n            }\\n            return Ans;\\n        }\\n        \\n        int len = ind+1;\\n        int q = k/len;\\n        int r = k%len;\\n        for(int i=0;i<=ind;i++){\\n            dif[i] = max(dif[i]-q,0);\\n            k -= q;\\n            if(r){\\n                if(dif[i]) dif[i]--;\\n                k--;\\n                r--;\\n            }\\n        }\\n        \\n        long long Ans = 0;\\n        for(int i=0;i<N;i++){\\n            Ans += (long long)dif[i]*(long long)dif[i];\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int N = nums1.size();\\n        vector<int> dif(N);\\n        for(int i=0;i<N;i++){\\n            dif[i] = abs(nums1[i]-nums2[i]);\\n        }\\n        int k = k1+k2;\\n        \\n        sort(dif.begin(),dif.end());\\n        reverse(dif.begin(),dif.end());\\n        \\n        vector<long long> Sum(N);\\n        Sum[0] = dif[0];\\n        for(int i=1;i<N;i++){\\n            Sum[i] = Sum[i-1] + (long long)dif[i];\\n        }\\n        \\n        int ind;\\n        for(ind=0;ind<N;ind++){\\n            long long total = Sum[ind] - (long long)(ind+1)*(long long)dif[ind];\\n            if(total > k) break;\\n        }\\n        ind--;\\n        for(int i=0;i<=ind;i++){\\n            k -= (dif[i]-dif[ind]);\\n            dif[i] = dif[ind];\\n        }\\n        if(k==0){\\n            long long Ans = 0;\\n            for(int i=0;i<N;i++){\\n                Ans += (long long)dif[i]*(long long)dif[i];\\n            }\\n            return Ans;\\n        }\\n        \\n        int len = ind+1;\\n        int q = k/len;\\n        int r = k%len;\\n        for(int i=0;i<=ind;i++){\\n            dif[i] = max(dif[i]-q,0);\\n            k -= q;\\n            if(r){\\n                if(dif[i]) dif[i]--;\\n                k--;\\n                r--;\\n            }\\n        }\\n        \\n        long long Ans = 0;\\n        for(int i=0;i<N;i++){\\n            Ans += (long long)dif[i]*(long long)dif[i];\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545258,
                "title": "c-hashmap-optimized-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        unordered_map<int, int> count;\\n        \\n        long long ans = 0;\\n        int k = k1+k2;\\n        \\n        int maxDiff = 0;\\n        for(int i=0; i<n; i++) \\n        {\\n            int diff = abs(nums2[i] - nums1[i]);\\n            count[diff]++;                              //Calculate frequency of each absolute difference \\n            maxDiff = max(maxDiff, diff);\\n        }\\n        \\n        for(int diff = maxDiff; diff > 0; diff--)\\n        {\\n            if(count[diff] == 0) continue;\\n            \\n            int op = min(k, count[diff]);       //No of elemnet whose value is diff we can reduce by one\\n                                                //is minimum of k and count of diff (This is op)\\n            count[diff - 1] += op;              //When we reduce diff by 1 then diff-1 will increase by op\\n            count[diff] -= op;                  //Now reduce the count of diff as we reduced them by\\n            k -= op;                            //decrement k also\\n            \\n            if(k == 0) break;\\n        }\\n        \\n        for(auto &x:count)\\n        {\\n            if(x.second > 0)\\n            {\\n                ans += 1ll*x.first*x.first*x.second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        unordered_map<int, int> count;\\n        \\n        long long ans = 0;\\n        int k = k1+k2;\\n        \\n        int maxDiff = 0;\\n        for(int i=0; i<n; i++) \\n        {\\n            int diff = abs(nums2[i] - nums1[i]);\\n            count[diff]++;                              //Calculate frequency of each absolute difference \\n            maxDiff = max(maxDiff, diff);\\n        }\\n        \\n        for(int diff = maxDiff; diff > 0; diff--)\\n        {\\n            if(count[diff] == 0) continue;\\n            \\n            int op = min(k, count[diff]);       //No of elemnet whose value is diff we can reduce by one\\n                                                //is minimum of k and count of diff (This is op)\\n            count[diff - 1] += op;              //When we reduce diff by 1 then diff-1 will increase by op\\n            count[diff] -= op;                  //Now reduce the count of diff as we reduced them by\\n            k -= op;                            //decrement k also\\n            \\n            if(k == 0) break;\\n        }\\n        \\n        for(auto &x:count)\\n        {\\n            if(x.second > 0)\\n            {\\n                ans += 1ll*x.first*x.first*x.second;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508841,
                "title": "c-linear-time-o-n-k1-k2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    int n = (int)nums1.size();\\n    int k = k1 + k2;\\n\\n    unordered_map<int, int> frq;\\n    int m = 0;\\n    for(int i = 0, d = 0; i<n; i++){\\n      d = nums1[i] - nums2[i];\\n      d = max(d, -d);\\n      frq[d]++;\\n      m = max(m, d);\\n    }\\n\\n    for(int d = 0; k>0; k -= d){\\n      d = min(k, frq[m]);\\n      frq[m] -= d;\\n      frq[--m] += d;\\n    }\\n\\n    int64_t res = 0;\\n    for(auto& p : frq) {\\n      if(p.first<=0){\\n        continue;\\n      }\\n      for(int i = 0; i<p.second; i++){\\n        res += (int64_t)p.first * p.first;\\n      }\\n    }\\n    return res;  \\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    int n = (int)nums1.size();\\n    int k = k1 + k2;\\n\\n    unordered_map<int, int> frq;\\n    int m = 0;\\n    for(int i = 0, d = 0; i<n; i++){\\n      d = nums1[i] - nums2[i];\\n      d = max(d, -d);\\n      frq[d]++;\\n      m = max(m, d);\\n    }\\n\\n    for(int d = 0; k>0; k -= d){\\n      d = min(k, frq[m]);\\n      frq[m] -= d;\\n      frq[--m] += d;\\n    }\\n\\n    int64_t res = 0;\\n    for(auto& p : frq) {\\n      if(p.first<=0){\\n        continue;\\n      }\\n      for(int i = 0; i<p.second; i++){\\n        res += (int64_t)p.first * p.first;\\n      }\\n    }\\n    return res;  \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507130,
                "title": "python-semi-brute-force",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1, nums2, k1: int, k2: int) -> int:\\n        sorted_diffs = sorted([(num2-num1)**2 for num1,num2 in zip(nums1,nums2)], reverse=True)\\n        sorted_idx = sorted([i for i in range(len(nums1))], reverse=True, key=lambda i: (nums1[i]-nums2[i])**2)\\n        m = 0\\n        while not (k1 == 0 and k2 == 0):\\n            max_, argmax = sorted_diffs[m], sorted_idx[m]\\n            if max_ == 0:\\n                return 0\\n            if k2 > k1:\\n                if nums2[argmax]>nums1[argmax]:\\n                    nums2[argmax] -= 1\\n                else:\\n                    nums2[argmax] += 1\\n                k2 -= 1\\n            else:\\n                if nums1[argmax]>nums2[argmax]:\\n                    nums1[argmax] -= 1\\n                else:\\n                    nums1[argmax] += 1\\n                k1 -= 1\\n            sorted_diffs[m] = (nums1[argmax]-nums2[argmax])**2\\n            if m < len(nums1)-1:\\n                if sorted_diffs[m] < sorted_diffs[m+1]:\\n                    m+=1\\n            while m > 0 and sorted_diffs[m] <= sorted_diffs[m-1]:\\n                m-=1\\n        return sum(sorted_diffs)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1, nums2, k1: int, k2: int) -> int:\\n        sorted_diffs = sorted([(num2-num1)**2 for num1,num2 in zip(nums1,nums2)], reverse=True)\\n        sorted_idx = sorted([i for i in range(len(nums1))], reverse=True, key=lambda i: (nums1[i]-nums2[i])**2)\\n        m = 0\\n        while not (k1 == 0 and k2 == 0):\\n            max_, argmax = sorted_diffs[m], sorted_idx[m]\\n            if max_ == 0:\\n                return 0\\n            if k2 > k1:\\n                if nums2[argmax]>nums1[argmax]:\\n                    nums2[argmax] -= 1\\n                else:\\n                    nums2[argmax] += 1\\n                k2 -= 1\\n            else:\\n                if nums1[argmax]>nums2[argmax]:\\n                    nums1[argmax] -= 1\\n                else:\\n                    nums1[argmax] += 1\\n                k1 -= 1\\n            sorted_diffs[m] = (nums1[argmax]-nums2[argmax])**2\\n            if m < len(nums1)-1:\\n                if sorted_diffs[m] < sorted_diffs[m+1]:\\n                    m+=1\\n            while m > 0 and sorted_diffs[m] <= sorted_diffs[m-1]:\\n                m-=1\\n        return sum(sorted_diffs)",
                "codeTag": "Java"
            },
            {
                "id": 2502218,
                "title": "python-max-heap-solution",
                "content": "```\\ndef minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n\\tnums = [-abs(n1-n2) for n1, n2 in zip(nums1, nums2)]\\n\\ts, k = sum(nums), k1+k2\\n\\tif k+s>=0:\\n\\t\\treturn 0\\n\\n\\theapify(nums)\\n\\twhile(k>0):\\n\\t\\tgap = max(k//len(nums), 1)\\n\\t\\theappush(nums, heappop(nums)+gap)\\n\\t\\tk -= gap\\n\\treturn sum(n*n for n in nums)\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n\\tnums = [-abs(n1-n2) for n1, n2 in zip(nums1, nums2)]\\n\\ts, k = sum(nums), k1+k2\\n\\tif k+s>=0:\\n\\t\\treturn 0\\n\\n\\theapify(nums)\\n\\twhile(k>0):\\n\\t\\tgap = max(k//len(nums), 1)\\n\\t\\theappush(nums, heappop(nums)+gap)\\n\\t\\tk -= gap\\n\\treturn sum(n*n for n in nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2469372,
                "title": "c-max-heap",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tfor(int i=0;i<nums1.size();i++) {\\n\\t\\t\\t\\tmp[abs(nums1[i]-nums2[i])]++;\\n\\t\\t\\t}\\n\\t\\t\\tint k=k1+k2;\\n\\t\\t\\tpriority_queue<vector<int>> pq;\\n\\t\\t\\tfor(auto x:mp) {\\n\\t\\t\\t\\tpq.push({x.first,x.second});\\n\\t\\t\\t}\\n\\t\\t\\tpq.push({0,0});\\n\\t\\t\\twhile(k>0&&pq.size()>1) {\\n\\t\\t\\t\\tvector<int> l=pq.top();\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\tif(k>=(l[0]-pq.top()[0])*l[1]){\\n\\t\\t\\t\\t\\tvector<int> temp=pq.top();\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tpq.push({temp[0],temp[1]+l[1]});\\n\\t\\t\\t\\t\\tk-=(l[0]-temp[0])*l[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tint m=k/l[1];  \\n\\t\\t\\t\\t\\tint rem=k%l[1];\\n\\t\\t\\t\\t\\tvector<int> temp=pq.top();\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tif(temp[0]==l[0]-m-1) {\\n\\t\\t\\t\\t\\t\\ttemp[1]+=rem;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tpq.push({l[0]-m-1,rem});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpq.push(temp);\\n\\t\\t\\t\\t\\tpq.push({l[0]-m,l[1]-rem});\\n\\t\\t\\t\\t\\tk=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlong long res=0;\\n\\t\\t\\twhile(pq.size()) {\\n\\t\\t\\t\\tres+=1LL*pq.top()[0]*pq.top()[0]*pq.top()[1];\\n\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\t\\t\\tunordered_map<int,int> mp;\\n\\t\\t\\tfor(int i=0;i<nums1.size();i++) {\\n\\t\\t\\t\\tmp[abs(nums1[i]-nums2[i])]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2446034,
                "title": "python3-max-heap-o-nlogn",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        h=[]\\n        for a,b in zip(nums1,nums2):\\n            heapq.heappush(h,-abs(a-b))\\n        k=k1+k2\\n        if k>=-sum(h): return 0\\n        while k>0:\\n            val=-heapq.heappop(h)\\n            cut=max(k//len(nums1),1)\\n            heapq.heappush(h,-(val-cut))\\n            k-=cut\\n        return sum(el**2 for el in h)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        h=[]\\n        for a,b in zip(nums1,nums2):\\n            heapq.heappush(h,-abs(a-b))\\n        k=k1+k2\\n        if k>=-sum(h): return 0\\n        while k>0:\\n            val=-heapq.heappop(h)\\n            cut=max(k//len(nums1),1)\\n            heapq.heappush(h,-(val-cut))\\n            k-=cut\\n        return sum(el**2 for el in h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441604,
                "title": "python-bucket-sort-o-n",
                "content": "We need to minimize the number of max difference values.\\n1. Create a frequency map of differences.\\n1. Keep decreasing till you can (k times).\\nHere, k = k1 + k2, because it doesn\\'t matter which one we choose to change. The purpose of this change is to just reduce the difference.\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diffs = defaultdict(int)\\n        mx_diff = 0\\n        for i in range(len(nums1)):\\n            d = abs(nums1[i] - nums2[i])\\n            mx_diff = max(mx_diff, d)\\n            diffs[d] += 1\\n        \\n        k = k1 + k2\\n        while k > 0 and mx_diff > 0:\\n            if diffs[mx_diff] <= k:\\n                k -= diffs[mx_diff]\\n                diffs[mx_diff - 1] += diffs[mx_diff]\\n                diffs[mx_diff] = 0\\n                mx_diff -= 1\\n            else:\\n                diffs[mx_diff] -= k\\n                diffs[mx_diff - 1] += k\\n                k = 0\\n\\n        ssd = 0\\n        for d, f in diffs.items():\\n            ssd += f * d * d\\n\\n        return ssd\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diffs = defaultdict(int)\\n        mx_diff = 0\\n        for i in range(len(nums1)):\\n            d = abs(nums1[i] - nums2[i])\\n            mx_diff = max(mx_diff, d)\\n            diffs[d] += 1\\n        \\n        k = k1 + k2\\n        while k > 0 and mx_diff > 0:\\n            if diffs[mx_diff] <= k:\\n                k -= diffs[mx_diff]\\n                diffs[mx_diff - 1] += diffs[mx_diff]\\n                diffs[mx_diff] = 0\\n                mx_diff -= 1\\n            else:\\n                diffs[mx_diff] -= k\\n                diffs[mx_diff - 1] += k\\n                k = 0\\n\\n        ssd = 0\\n        for d, f in diffs.items():\\n            ssd += f * d * d\\n\\n        return ssd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440101,
                "title": "two-pointer-method-sorting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        long long sumi = 0;\\n        int mx = 0;\\n        for(int i = 0;i < n;i++){\\n            nums1[i] = abs(nums1[i]-nums2[i]);\\n            sumi+=nums1[i];\\n            mx = max(mx,nums1[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        int ind = 0;\\n        int k = k1+k2;\\n        if(k >= sumi)return 0;\\n        int it = n-1;\\n        while(it-1 >= 0 && nums1[it-1]==nums1[it])it--;\\n        it--;\\n        while(it-1 >= 0 && it >= 0 && nums1[it-1]==nums1[it])it--;\\n        if(it >= 0){\\n            ind = -1;\\n            for(int i = n-1;i >= 0;i--){   \\n                mx = nums1[it];\\n                it--;\\n                while(it >= 0 && it-1 >= 0 && nums1[it]==nums1[it-1])it--;\\n                while(i-1 >= 0 && nums1[i-1] == nums1[i]){\\n                    i--;\\n                }\\n                long long diff = nums1[i]-mx;\\n                long long freq = n-i;\\n                if(k-diff*freq < 0){\\n                    mx = nums1[i];\\n                    while(k-freq >= 0){\\n                        mx--;\\n                        k -= freq;\\n                    }\\n                    while(k && i < n){\\n                        nums1[i] = mx-1;\\n                        i++;\\n                        k--;\\n                    }\\n                    long long pp = 0;\\n                    for(int i = 0;i < n;i++){\\n                        long long lp = min(nums1[i],mx);\\n                        lp *= lp;\\n                        pp += (lp);\\n                    }\\n                    return pp;\\n                }\\n                else{\\n                    k -= (diff*freq);\\n                }\\n                if(it < 0){\\n                    break;\\n                }\\n            }\\n        }\\n        while(k-n >= 0){\\n            k-=n;\\n            mx--;\\n        }\\n        ind = 0;\\n        while(k && ind < n){\\n            nums1[ind] = mx-1;\\n            ind++;\\n            k--;\\n        }\\n        long long pp = 0;\\n        for(int i = 0;i < n;i++){\\n            long long lp = min(nums1[i],mx);\\n            lp *= lp;\\n            pp += (lp);\\n        }\\n        return pp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        long long sumi = 0;\\n        int mx = 0;\\n        for(int i = 0;i < n;i++){\\n            nums1[i] = abs(nums1[i]-nums2[i]);\\n            sumi+=nums1[i];\\n            mx = max(mx,nums1[i]);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        int ind = 0;\\n        int k = k1+k2;\\n        if(k >= sumi)return 0;\\n        int it = n-1;\\n        while(it-1 >= 0 && nums1[it-1]==nums1[it])it--;\\n        it--;\\n        while(it-1 >= 0 && it >= 0 && nums1[it-1]==nums1[it])it--;\\n        if(it >= 0){\\n            ind = -1;\\n            for(int i = n-1;i >= 0;i--){   \\n                mx = nums1[it];\\n                it--;\\n                while(it >= 0 && it-1 >= 0 && nums1[it]==nums1[it-1])it--;\\n                while(i-1 >= 0 && nums1[i-1] == nums1[i]){\\n                    i--;\\n                }\\n                long long diff = nums1[i]-mx;\\n                long long freq = n-i;\\n                if(k-diff*freq < 0){\\n                    mx = nums1[i];\\n                    while(k-freq >= 0){\\n                        mx--;\\n                        k -= freq;\\n                    }\\n                    while(k && i < n){\\n                        nums1[i] = mx-1;\\n                        i++;\\n                        k--;\\n                    }\\n                    long long pp = 0;\\n                    for(int i = 0;i < n;i++){\\n                        long long lp = min(nums1[i],mx);\\n                        lp *= lp;\\n                        pp += (lp);\\n                    }\\n                    return pp;\\n                }\\n                else{\\n                    k -= (diff*freq);\\n                }\\n                if(it < 0){\\n                    break;\\n                }\\n            }\\n        }\\n        while(k-n >= 0){\\n            k-=n;\\n            mx--;\\n        }\\n        ind = 0;\\n        while(k && ind < n){\\n            nums1[ind] = mx-1;\\n            ind++;\\n            k--;\\n        }\\n        long long pp = 0;\\n        for(int i = 0;i < n;i++){\\n            long long lp = min(nums1[i],mx);\\n            lp *= lp;\\n            pp += (lp);\\n        }\\n        return pp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438304,
                "title": "python-o-nlogn-sort-solution-with-explanations",
                "content": "Intuition: \\n* k1 and k2 dosen\\'t matters, sum of them matters.\\n* Decreasing the max difference every time.\\n\\nBut how much do we decrease each time?\\nAns: Decrease to next biggest difference which we haven\\'t hadle yet.\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        l = []\\n        for i in range(len(nums1)):\\n            l.append(abs(nums1[i] - nums2[i]))\\n        l.sort(reverse = True)\\n        total = k1 + k2\\n        l.append(0)\\n        for i in range(len(l) - 1):\\n            if (l[i] - l[i + 1]) * (i + 1) < total:\\n\\t\\t\\t\\t# decrease to next largest; i + 1 is the number of difference we handled and all of them are l[i]\\n                total -= (l[i] - l[i + 1]) * (i + 1)\\n            else:\\n\\t\\t\\t\\t# total is not enough, decreas as much as we can\\n                minus = total // (i + 1)\\n                mod = total - (minus * (i + 1))\\n                ans = 0\\n                ans += ((l[i] - minus - 1)**2) * (mod) + ((l[i] - minus)**2) * (i + 1 - mod)\\n                for j in range(i+1, len(l)):\\n\\t\\t\\t\\t\\t# adding the rest of elements\\n                    ans += l[j]**2\\n                return ans\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        l = []\\n        for i in range(len(nums1)):\\n            l.append(abs(nums1[i] - nums2[i]))\\n        l.sort(reverse = True)\\n        total = k1 + k2\\n        l.append(0)\\n        for i in range(len(l) - 1):\\n            if (l[i] - l[i + 1]) * (i + 1) < total:\\n\\t\\t\\t\\t# decrease to next largest; i + 1 is the number of difference we handled and all of them are l[i]\\n                total -= (l[i] - l[i + 1]) * (i + 1)\\n            else:\\n\\t\\t\\t\\t# total is not enough, decreas as much as we can\\n                minus = total // (i + 1)\\n                mod = total - (minus * (i + 1))\\n                ans = 0\\n                ans += ((l[i] - minus - 1)**2) * (mod) + ((l[i] - minus)**2) * (i + 1 - mod)\\n                for j in range(i+1, len(l)):\\n\\t\\t\\t\\t\\t# adding the rest of elements\\n                    ans += l[j]**2\\n                return ans\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418946,
                "title": "c-code-onlyone",
                "content": "```\\nlong long minSumSquareDiff(int* a, int n, int* b, int useless, int k1, int k2)\\n{\\n    int *p=(int *)malloc(sizeof(int)*n);\\n    int *map=(int *)malloc(sizeof(int)*(1e5+1));\\n    memset(map,0,(1e5+1));\\n    int m=INT_MIN;\\n    for(int i=0;i<n;i++)\\n    {\\n        p[i]=abs(a[i]-b[i]);\\n        map[p[i]]++;\\n        if(p[i]>m)\\n            m=p[i];\\n    }\\n    int k=k1+k2;\\n    for(int i=m;i>0;i--)\\n    {\\n        if(map[i]>=k)\\n        {\\n            map[i]=map[i]-k;\\n            map[i-1]+=k;\\n            break;\\n        }\\n        else\\n        {\\n            k=k-map[i];\\n            map[i-1]+=map[i];\\n            map[i]=0;\\n        }\\n        if(k==0)break;\\n        \\n    }\\n    long long s=0;\\n    for(int i=m;i>0;i--)\\n        s+=(long long)map[i]*((long long)i*i);\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long minSumSquareDiff(int* a, int n, int* b, int useless, int k1, int k2)\\n{\\n    int *p=(int *)malloc(sizeof(int)*n);\\n    int *map=(int *)malloc(sizeof(int)*(1e5+1));\\n    memset(map,0,(1e5+1));\\n    int m=INT_MIN;\\n    for(int i=0;i<n;i++)\\n    {\\n        p[i]=abs(a[i]-b[i]);\\n        map[p[i]]++;\\n        if(p[i]>m)\\n            m=p[i];\\n    }\\n    int k=k1+k2;\\n    for(int i=m;i>0;i--)\\n    {\\n        if(map[i]>=k)\\n        {\\n            map[i]=map[i]-k;\\n            map[i-1]+=k;\\n            break;\\n        }\\n        else\\n        {\\n            k=k-map[i];\\n            map[i-1]+=map[i];\\n            map[i]=0;\\n        }\\n        if(k==0)break;\\n        \\n    }\\n    long long s=0;\\n    for(int i=m;i>0;i--)\\n        s+=(long long)map[i]*((long long)i*i);\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2416267,
                "title": "python-o-nlogn-98-explained",
                "content": "1. Rephrase the problem: Given an array `nums`, where nums[i] = abs(nums1[i] - nums2[i]), substract at most `(k1 + k2)` from the elements to minimize sum(nums[i]^2)\\n2. When we choose an element to substract 1 from, we want to maximize the reduction of square sum. If the original elements is x, the reduction is x^2 - (x-1)^2 = 2x-1 -- It\\'s an increasing function. So we always want to do substraction on the maximum element of the array.\\n\\nThe direct approach: take out the maximum elements, substract 1, put it back into the array.\\nIn fact, we don\\'t need to do this.\\n\\nFor example, if the original nums is [10,8,4,2]\\n* If k1 + k2 <= 10-8, we do all substractions on 10\\n* Else if k1 + k2 <= 4 * 2 - (10+8)  [It\\'s the difference between [10,8,4] and [4,4,4]], we do all substractions on [10, 8]\\n* ...\\n* Generally, if k1+k2 <= sum(nums[:i])-i* nums[i], we do all substractions on nums[:i]\\n\\n\\n**Python**\\n```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        nums = [abs(nums1[i]-nums2[i]) for i in range(len(nums1))]\\n        nums.sort(reverse = True)\\n        nums.append(0)\\n        Sum = 0\\n        for i in range(len(nums)):\\n            x = Sum - nums[i]*i\\n            if x >= k1+k2:\\n                e1 = (Sum - k1 - k2) // i + 1 if i>0 else 0\\n                e2 = e1-1\\n                n1 = (Sum - k1 - k2) % i if i > 0 else 0\\n                n2 = i - n1\\n                return e1**2 * n1 + e2**2 * n2 + sum(y**2 for y in nums[i:])\\n            Sum += nums[i]\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        nums = [abs(nums1[i]-nums2[i]) for i in range(len(nums1))]\\n        nums.sort(reverse = True)\\n        nums.append(0)\\n        Sum = 0\\n        for i in range(len(nums)):\\n            x = Sum - nums[i]*i\\n            if x >= k1+k2:\\n                e1 = (Sum - k1 - k2) // i + 1 if i>0 else 0\\n                e2 = e1-1\\n                n1 = (Sum - k1 - k2) % i if i > 0 else 0\\n                n2 = i - n1\\n                return e1**2 * n1 + e2**2 * n2 + sum(y**2 for y in nums[i:])\\n            Sum += nums[i]\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395658,
                "title": "greedy-o-nlogn",
                "content": "```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\tlong long k=k1+k2;\\n\\t// insert 0 at end;\\n\\tvector<long long> nums(nums1.size()+1,0);\\n\\tfor(int i=0; i<nums1.size(); i++){\\n\\t\\tnums[i]=abs(nums1[i]-nums2[i]);\\n\\t}\\n\\tsort(nums.begin(),nums.end(),greater<int>());\\n\\tlong long ret=0;\\n\\tint index, val, mod, carry;\\n\\tfor(int i=1; i<nums.size(); i++){\\n\\t\\tif(k<i*(nums[i-1]-nums[i])){\\n\\t\\t\\tval=nums[i-1];\\n\\t\\t\\tcarry=k%i;\\n\\t\\t\\tmod=k/i;\\n\\t\\t\\tindex=i;\\n\\t\\t\\tk=-1;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tk-=i*(nums[i-1]-nums[i]);\\n\\t}\\n\\tif(k>=0) return 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(i<index){\\n\\t\\t\\tnums[i]=val;\\n\\t\\t\\tif(i<carry){\\n\\t\\t\\t\\tnums[i]-=1;\\n\\t\\t\\t}\\n\\t\\t\\tnums[i]-=mod;\\n\\t\\t}\\n\\t\\tret+=nums[i]*nums[i];\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n\\tlong long k=k1+k2;\\n\\t// insert 0 at end;\\n\\tvector<long long> nums(nums1.size()+1,0);\\n\\tfor(int i=0; i<nums1.size(); i++){\\n\\t\\tnums[i]=abs(nums1[i]-nums2[i]);\\n\\t}\\n\\tsort(nums.begin(),nums.end(),greater<int>());\\n\\tlong long ret=0;\\n\\tint index, val, mod, carry;\\n\\tfor(int i=1; i<nums.size(); i++){\\n\\t\\tif(k<i*(nums[i-1]-nums[i])){\\n\\t\\t\\tval=nums[i-1];\\n\\t\\t\\tcarry=k%i;\\n\\t\\t\\tmod=k/i;\\n\\t\\t\\tindex=i;\\n\\t\\t\\tk=-1;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tk-=i*(nums[i-1]-nums[i]);\\n\\t}\\n\\tif(k>=0) return 0;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tif(i<index){\\n\\t\\t\\tnums[i]=val;\\n\\t\\t\\tif(i<carry){\\n\\t\\t\\t\\tnums[i]-=1;\\n\\t\\t\\t}\\n\\t\\t\\tnums[i]-=mod;\\n\\t\\t}\\n\\t\\tret+=nums[i]*nums[i];\\n\\t}\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383912,
                "title": "brute-force-to-efficient-solution",
                "content": "```\\nbasic approach : \\n ** TLE .. 21 / 38 test cases **\\n\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans = 0;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>> pq;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            pq.push({abs(nums1[i] - nums2[i]),{nums1[i],nums2[i]}});\\n        }\\n      \\n        while(k1 || k2)\\n        {\\n           auto top = pq.top();\\n           auto prev = top;\\n           pq.pop();\\n              \\n           if(k1 > 0)\\n           {\\n               if(top.second.second<top.second.first)\\n               {\\n                   top.second.first--;\\n               }else{\\n                   top.second.first++;\\n               }\\n               k1--;\\n           }else if(k2>0)\\n           {\\n               if(top.second.second<top.second.first)\\n               {\\n                   top.second.second++;\\n               }else{\\n                   top.second.second--;\\n               }\\n               k2--;\\n           }\\n            \\n           top.first = abs(top.second.first - top.second.second);\\n           if(prev.first<top.first) \\n           {\\n               pq.push(prev);\\n               break;\\n           }\\n           pq.push({top.first,{top.second.first,top.second.second}});\\n        }\\n           \\n        while(!pq.empty())\\n        {\\n            int num = pq.top().first;\\n            ans += num * num;\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nefficient solution\\n\\n/*Makw the \\'count\\' array , count[i] = count of indices with difference \\'i\\'\\n    - operation_allowed = k1 + k2\\n    - for i = (M , ... 1)\\n         - if(count[i] > operation_allowed)\\n             \\n             - decrement count[i] by \\'operation_allowed\\' & break \\n         - else\\n             - increment count[i-1] by count[i]\\n             - decrement operation_allowed by count[i]\\n*/\\nclass Solution {\\n    typedef long long int ll;\\n    const int N = 1e5;\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int>count(N+1,0);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            count[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        int k = k1 + k2 ; // total opertion\\n        for(int diff = N;diff>0;diff--)\\n        {\\n            if(count[diff] == 0) continue;\\n            \\n            if(k>=count[diff])\\n            {\\n               count[diff-1] += count[diff]; // eg : 4443 -> 3333 freq of 3 gone to be increase\\n                \\n               k -= count[diff]; // decrement operation\\n               count[diff] = 0;\\n                \\n            }else{ \\n              count[diff-1] += k; // eg : 4443 -> 4333 update only those number which can be decrement under limited operation\\n              count[diff] -= k;\\n              k = 0;\\n              break;\\n            }\\n        }\\n        \\n        ll ans = 0;\\n        for(ll j=1;j<=N;j++)\\n        {\\n           if(count[j]>0) ans += j*j*count[j];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Counting"
                ],
                "code": "```\\nbasic approach : \\n ** TLE .. 21 / 38 test cases **\\n\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long ans = 0;\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>> pq;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            pq.push({abs(nums1[i] - nums2[i]),{nums1[i],nums2[i]}});\\n        }\\n      \\n        while(k1 || k2)\\n        {\\n           auto top = pq.top();\\n           auto prev = top;\\n           pq.pop();\\n              \\n           if(k1 > 0)\\n           {\\n               if(top.second.second<top.second.first)\\n               {\\n                   top.second.first--;\\n               }else{\\n                   top.second.first++;\\n               }\\n               k1--;\\n           }else if(k2>0)\\n           {\\n               if(top.second.second<top.second.first)\\n               {\\n                   top.second.second++;\\n               }else{\\n                   top.second.second--;\\n               }\\n               k2--;\\n           }\\n            \\n           top.first = abs(top.second.first - top.second.second);\\n           if(prev.first<top.first) \\n           {\\n               pq.push(prev);\\n               break;\\n           }\\n           pq.push({top.first,{top.second.first,top.second.second}});\\n        }\\n           \\n        while(!pq.empty())\\n        {\\n            int num = pq.top().first;\\n            ans += num * num;\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nefficient solution\\n\\n/*Makw the \\'count\\' array , count[i] = count of indices with difference \\'i\\'\\n    - operation_allowed = k1 + k2\\n    - for i = (M , ... 1)\\n         - if(count[i] > operation_allowed)\\n             \\n             - decrement count[i] by \\'operation_allowed\\' & break \\n         - else\\n             - increment count[i-1] by count[i]\\n             - decrement operation_allowed by count[i]\\n*/\\nclass Solution {\\n    typedef long long int ll;\\n    const int N = 1e5;\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int>count(N+1,0);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            count[abs(nums1[i]-nums2[i])]++;\\n        }\\n        \\n        int k = k1 + k2 ; // total opertion\\n        for(int diff = N;diff>0;diff--)\\n        {\\n            if(count[diff] == 0) continue;\\n            \\n            if(k>=count[diff])\\n            {\\n               count[diff-1] += count[diff]; // eg : 4443 -> 3333 freq of 3 gone to be increase\\n                \\n               k -= count[diff]; // decrement operation\\n               count[diff] = 0;\\n                \\n            }else{ \\n              count[diff-1] += k; // eg : 4443 -> 4333 update only those number which can be decrement under limited operation\\n              count[diff] -= k;\\n              k = 0;\\n              break;\\n            }\\n        }\\n        \\n        ll ans = 0;\\n        for(ll j=1;j<=N;j++)\\n        {\\n           if(count[j]>0) ans += j*j*count[j];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373043,
                "title": "c-gready-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sq(long long val) {\\n        return val * val;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        map<int, int> freq;\\n        for (int i = 0; i < n; i++) {\\n            int val = abs(nums1[i] - nums2[i]);\\n            ++freq[val];\\n        }\\n        vector<pair<int, int>> diff;\\n        for (auto p : freq) {\\n            diff.push_back(p);\\n        }\\n        int totalOperations = k1 + k2;\\n        while (diff.size() >= 1) {\\n            if (diff.size() == 1) {\\n                long long need = (long long) diff.back().first * diff.back().second;\\n                if (totalOperations >= need) {\\n                    return 0ll;\\n                }\\n                int times = totalOperations / diff.back().second;\\n                int rem = totalOperations % diff.back().second;\\n                auto p = diff.back();\\n                diff.pop_back();\\n                diff.emplace_back(p.first - times, p.second - rem);\\n                diff.emplace_back(p.first - times - 1, rem);\\n                break;\\n            }\\n            auto last = diff.end()[-1];\\n            auto llast = diff.end()[-2];\\n            long long d = last.first - llast.first;\\n            long long need = d * last.second;\\n            if (totalOperations >= need) {\\n                diff.pop_back();\\n                diff[(int) diff.size() - 1].second += last.second;\\n                totalOperations -= need;\\n            } else {\\n                int times = totalOperations / diff.back().second;\\n                int rem = totalOperations % diff.back().second;\\n                auto p = diff.back();\\n                diff.pop_back();\\n                diff.emplace_back(p.first - times, p.second - rem);\\n                diff.emplace_back(p.first - times - 1, rem);\\n                break;\\n            }\\n        }\\n        long long sol = 0;\\n        for (pair<int, int> p : diff) {\\n            sol += (long long) p.second * sq(p.first);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sq(long long val) {\\n        return val * val;\\n    }\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        map<int, int> freq;\\n        for (int i = 0; i < n; i++) {\\n            int val = abs(nums1[i] - nums2[i]);\\n            ++freq[val];\\n        }\\n        vector<pair<int, int>> diff;\\n        for (auto p : freq) {\\n            diff.push_back(p);\\n        }\\n        int totalOperations = k1 + k2;\\n        while (diff.size() >= 1) {\\n            if (diff.size() == 1) {\\n                long long need = (long long) diff.back().first * diff.back().second;\\n                if (totalOperations >= need) {\\n                    return 0ll;\\n                }\\n                int times = totalOperations / diff.back().second;\\n                int rem = totalOperations % diff.back().second;\\n                auto p = diff.back();\\n                diff.pop_back();\\n                diff.emplace_back(p.first - times, p.second - rem);\\n                diff.emplace_back(p.first - times - 1, rem);\\n                break;\\n            }\\n            auto last = diff.end()[-1];\\n            auto llast = diff.end()[-2];\\n            long long d = last.first - llast.first;\\n            long long need = d * last.second;\\n            if (totalOperations >= need) {\\n                diff.pop_back();\\n                diff[(int) diff.size() - 1].second += last.second;\\n                totalOperations -= need;\\n            } else {\\n                int times = totalOperations / diff.back().second;\\n                int rem = totalOperations % diff.back().second;\\n                auto p = diff.back();\\n                diff.pop_back();\\n                diff.emplace_back(p.first - times, p.second - rem);\\n                diff.emplace_back(p.first - times - 1, rem);\\n                break;\\n            }\\n        }\\n        long long sol = 0;\\n        for (pair<int, int> p : diff) {\\n            sol += (long long) p.second * sq(p.first);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371436,
                "title": "c-easy-explained-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/ddff26e6-1916-4740-a5be-ead384765d79_1659475494.5421603.png)\\nThe idea is to decrease/relax the max diff, say we have three 4 4 4 as max diff and k1+k2 = 6 then make 4 4 4 as 2 2 2. \\nIf k1+k2 would have been 5 then 4 4 4 becomes 3 2 2.\\n\\nRelax the top element of pq till next top element and increase it\\'s freq and continue the process if total>0\\n\\n```\\n#define sqr(x) ((x) * 1ll * (x))\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2)\\n    {\\n        int n = nums1.size();   \\n        \\n        //for storing count of abs diff\\n        unordered_map<int,int> m;\\n        \\n        // for getting max diff \\n        priority_queue<int> pq;\\n        \\n        // store all abs diff in a map with it\\'s count and push one of it into pq\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[abs(nums1[i]-nums2[i])]==0)\\n                pq.push(abs(nums1[i]-nums2[i]));\\n            m[abs(nums1[i]-nums2[i])]++;\\n        }\\n    \\n        int total = k1+k2;\\n        \\n        //get the curr/top element\\n        int curr = pq.top();\\n        pq.pop();\\n        \\n        while(!pq.empty() && total)\\n        {\\n            int next = pq.top();\\n            pq.pop();\\n            // total num of relaxation we can do to achieve next element in pq;\\n            int op = (curr-next)*m[curr]; \\n            if(op<=total)\\n            {\\n                total -= op;\\n                m[next] += m[curr];\\n                m[curr] = 0;\\n                curr=next;\\n                //completely relaxes all the count\\n            }\\n            else\\n            {\\n                int change = total/m[curr];\\n                if(change)\\n                {\\n                    m[curr-change]=m[curr];\\n                    total%=m[curr];\\n                    m[curr] = 0;\\n                    curr = curr-change;\\n                }\\n                //partially common relaxation \\n                // for leftover total\\n                if(total)\\n                {\\n                    m[curr]-=total;\\n                    m[curr-1]+=total;\\n                    total = 0;\\n                }\\n            }\\n        }\\n        \\n        // if curr > 0 and total is still left, relax again\\n        if(curr && total)\\n        {\\n            int change = total/m[curr];\\n            if(change)\\n            {\\n                m[curr-change]=m[curr];\\n                total%=m[curr];\\n                m[curr] = 0;\\n                curr = curr-change;\\n            }\\n            if(total)\\n            {\\n                m[curr]-=total;\\n                m[curr-1]+=total;\\n                total = 0;\\n            }    \\n        }\\n        \\n        long long int ans = 0;\\n        for(auto it : m)\\n        {\\n            if(it.first>0)\\n                ans+=it.second*sqr(it.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define sqr(x) ((x) * 1ll * (x))\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2)\\n    {\\n        int n = nums1.size();   \\n        \\n        //for storing count of abs diff\\n        unordered_map<int,int> m;\\n        \\n        // for getting max diff \\n        priority_queue<int> pq;\\n        \\n        // store all abs diff in a map with it\\'s count and push one of it into pq\\n        for(int i=0;i<n;i++)\\n        {\\n            if(m[abs(nums1[i]-nums2[i])]==0)\\n                pq.push(abs(nums1[i]-nums2[i]));\\n            m[abs(nums1[i]-nums2[i])]++;\\n        }\\n    \\n        int total = k1+k2;\\n        \\n        //get the curr/top element\\n        int curr = pq.top();\\n        pq.pop();\\n        \\n        while(!pq.empty() && total)\\n        {\\n            int next = pq.top();\\n            pq.pop();\\n            // total num of relaxation we can do to achieve next element in pq;\\n            int op = (curr-next)*m[curr]; \\n            if(op<=total)\\n            {\\n                total -= op;\\n                m[next] += m[curr];\\n                m[curr] = 0;\\n                curr=next;\\n                //completely relaxes all the count\\n            }\\n            else\\n            {\\n                int change = total/m[curr];\\n                if(change)\\n                {\\n                    m[curr-change]=m[curr];\\n                    total%=m[curr];\\n                    m[curr] = 0;\\n                    curr = curr-change;\\n                }\\n                //partially common relaxation \\n                // for leftover total\\n                if(total)\\n                {\\n                    m[curr]-=total;\\n                    m[curr-1]+=total;\\n                    total = 0;\\n                }\\n            }\\n        }\\n        \\n        // if curr > 0 and total is still left, relax again\\n        if(curr && total)\\n        {\\n            int change = total/m[curr];\\n            if(change)\\n            {\\n                m[curr-change]=m[curr];\\n                total%=m[curr];\\n                m[curr] = 0;\\n                curr = curr-change;\\n            }\\n            if(total)\\n            {\\n                m[curr]-=total;\\n                m[curr-1]+=total;\\n                total = 0;\\n            }    \\n        }\\n        \\n        long long int ans = 0;\\n        for(auto it : m)\\n        {\\n            if(it.first>0)\\n                ans+=it.second*sqr(it.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340098,
                "title": "tle-21-38-cases-passed-don-t-blindly-try-maxheap-java-solution",
                "content": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i]=Math.abs(nums1[i]-nums2[i]);\\n            maxHeap.add(nums1[i]);\\n        }\\n        \\n        int k=k1+k2;\\n        long result =0;\\n        \\n        while(k-->0){\\n            if(maxHeap.peek()==0){\\n                break;\\n            }\\n            \\n            int poppedNum = maxHeap.poll();\\n            maxHeap.add(poppedNum-1);\\n        }\\n        \\n        while(!maxHeap.isEmpty()){\\n            int poppedNum = maxHeap.poll();\\n            result+= (poppedNum*poppedNum);\\n        }\\n        \\n        return result;\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            nums1[i]=Math.abs(nums1[i]-nums2[i]);\\n            maxHeap.add(nums1[i]);\\n        }\\n        \\n        int k=k1+k2;\\n        long result =0;\\n        \\n        while(k-->0){\\n            if(maxHeap.peek()==0){\\n                break;\\n            }\\n            \\n            int poppedNum = maxHeap.poll();\\n            maxHeap.add(poppedNum-1);\\n        }\\n        \\n        while(!maxHeap.isEmpty()){\\n            int poppedNum = maxHeap.poll();\\n            result+= (poppedNum*poppedNum);\\n        }\\n        \\n        return result;\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338911,
                "title": "golang-solution",
                "content": "```go\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n\\tdiffMapping := make(map[int]int)\\n\\tfor i := range nums1 {\\n\\t\\tif nums1[i] >= nums2[i] {\\n\\t\\t\\tdiffMapping[nums1[i]-nums2[i]]++\\n\\t\\t} else {\\n\\t\\t\\tdiffMapping[nums2[i]-nums1[i]]++\\n\\t\\t}\\n\\t}\\n\\t// make sure key 0 exists in diffMapping\\n\\tdiffMapping[0] += 0\\n\\tdiffSlice := make([][2]int, 0, len(diffMapping))\\n\\tfor k, v := range diffMapping {\\n\\t\\tdiffSlice = append(diffSlice, [2]int{k, v})\\n\\t}\\n\\tsort.Slice(diffSlice, func(i, j int) bool {\\n\\t\\treturn diffSlice[i][0] < diffSlice[j][0]\\n\\t})\\n\\tmodify := k1 + k2\\n\\tfor len(diffSlice) > 1 && modify > 0 {\\n\\t\\tcost := (diffSlice[len(diffSlice)-1][0] - diffSlice[len(diffSlice)-2][0]) * diffSlice[len(diffSlice)-1][1]\\n\\t\\tif modify >= cost {\\n\\t\\t\\tdiffSlice[len(diffSlice)-2][1] += diffSlice[len(diffSlice)-1][1]\\n\\t\\t\\tdiffSlice = diffSlice[:len(diffSlice)-1]\\n\\t\\t\\tmodify -= cost\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tstep := modify / diffSlice[len(diffSlice)-1][1]\\n\\t\\tres := modify % diffSlice[len(diffSlice)-1][1]\\n\\t\\tnewDiff := make([][2]int, 0, 2)\\n\\t\\tnewDiff = append(newDiff, [2]int{diffSlice[len(diffSlice)-1][0] - step, diffSlice[len(diffSlice)-1][1]})\\n\\t\\tif res > 0 {\\n\\t\\t\\tnewDiff = append(newDiff, [2]int{newDiff[0][0] - 1, res})\\n\\t\\t\\tnewDiff[0][1] -= res\\n\\t\\t}\\n\\t\\tdiffSlice = diffSlice[:len(diffSlice)-1]\\n\\t\\tfor _, diff := range newDiff {\\n\\t\\t\\tdiffSlice = append(diffSlice, diff)\\n\\t\\t}\\n\\t\\tmodify = 0\\n\\t}\\n\\tsquareDiff := int64(0)\\n\\tfor _, diff := range diffSlice {\\n\\t\\tsquareDiff += int64(diff[0] * diff[0] * diff[1])\\n\\t}\\n\\treturn squareDiff\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n\\tdiffMapping := make(map[int]int)\\n\\tfor i := range nums1 {\\n\\t\\tif nums1[i] >= nums2[i] {\\n\\t\\t\\tdiffMapping[nums1[i]-nums2[i]]++\\n\\t\\t} else {\\n\\t\\t\\tdiffMapping[nums2[i]-nums1[i]]++\\n\\t\\t}\\n\\t}\\n\\t// make sure key 0 exists in diffMapping\\n\\tdiffMapping[0] += 0\\n\\tdiffSlice := make([][2]int, 0, len(diffMapping))\\n\\tfor k, v := range diffMapping {\\n\\t\\tdiffSlice = append(diffSlice, [2]int{k, v})\\n\\t}\\n\\tsort.Slice(diffSlice, func(i, j int) bool {\\n\\t\\treturn diffSlice[i][0] < diffSlice[j][0]\\n\\t})\\n\\tmodify := k1 + k2\\n\\tfor len(diffSlice) > 1 && modify > 0 {\\n\\t\\tcost := (diffSlice[len(diffSlice)-1][0] - diffSlice[len(diffSlice)-2][0]) * diffSlice[len(diffSlice)-1][1]\\n\\t\\tif modify >= cost {\\n\\t\\t\\tdiffSlice[len(diffSlice)-2][1] += diffSlice[len(diffSlice)-1][1]\\n\\t\\t\\tdiffSlice = diffSlice[:len(diffSlice)-1]\\n\\t\\t\\tmodify -= cost\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tstep := modify / diffSlice[len(diffSlice)-1][1]\\n\\t\\tres := modify % diffSlice[len(diffSlice)-1][1]\\n\\t\\tnewDiff := make([][2]int, 0, 2)\\n\\t\\tnewDiff = append(newDiff, [2]int{diffSlice[len(diffSlice)-1][0] - step, diffSlice[len(diffSlice)-1][1]})\\n\\t\\tif res > 0 {\\n\\t\\t\\tnewDiff = append(newDiff, [2]int{newDiff[0][0] - 1, res})\\n\\t\\t\\tnewDiff[0][1] -= res\\n\\t\\t}\\n\\t\\tdiffSlice = diffSlice[:len(diffSlice)-1]\\n\\t\\tfor _, diff := range newDiff {\\n\\t\\t\\tdiffSlice = append(diffSlice, diff)\\n\\t\\t}\\n\\t\\tmodify = 0\\n\\t}\\n\\tsquareDiff := int64(0)\\n\\tfor _, diff := range diffSlice {\\n\\t\\tsquareDiff += int64(diff[0] * diff[0] * diff[1])\\n\\t}\\n\\treturn squareDiff\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336747,
                "title": "python-gready",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        arr = [abs(n1 - n2) for n1, n2 in zip(nums1, nums2)]\\n        k = k1 + k2\\n        if sum(arr) <= k: return 0\\n        \\n        arr.sort(reverse = True)\\n        arr.append(0)\\n        for i in range(len(arr)):\\n            d = arr[i] - arr[i + 1]\\n            if k >= d * (i + 1):\\n                k -= d * (i + 1)\\n            else:\\n                x = k // (i + 1) \\n                y = k % (i + 1)\\n                for j in range(i + 1):\\n                    arr[j] = arr[i] - x - (1 if j < y else 0)\\n                break\\n                \\n        return sum([a * a  for a in arr])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        arr = [abs(n1 - n2) for n1, n2 in zip(nums1, nums2)]\\n        k = k1 + k2\\n        if sum(arr) <= k: return 0\\n        \\n        arr.sort(reverse = True)\\n        arr.append(0)\\n        for i in range(len(arr)):\\n            d = arr[i] - arr[i + 1]\\n            if k >= d * (i + 1):\\n                k -= d * (i + 1)\\n            else:\\n                x = k // (i + 1) \\n                y = k % (i + 1)\\n                for j in range(i + 1):\\n                    arr[j] = arr[i] - x - (1 if j < y else 0)\\n                break\\n                \\n        return sum([a * a  for a in arr])",
                "codeTag": "Java"
            },
            {
                "id": 2336470,
                "title": "python-heap",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = [-abs(n1 - n2) for n1, n2 in zip(nums1, nums2)]\\n        k = k1 + k2\\n        if -sum(diff) <= k: return 0\\n        heapq.heapify(diff)\\n        while k > 0 and diff:\\n            top = -heapq.heappop(diff)\\n            delta  = max(k // len(nums1),  1) \\n            heapq.heappush(diff, -(top - delta))\\n            k -= delta\\n        return sum([d * d for d in diff])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        diff = [-abs(n1 - n2) for n1, n2 in zip(nums1, nums2)]\\n        k = k1 + k2\\n        if -sum(diff) <= k: return 0\\n        heapq.heapify(diff)\\n        while k > 0 and diff:\\n            top = -heapq.heappop(diff)\\n            delta  = max(k // len(nums1),  1) \\n            heapq.heappush(diff, -(top - delta))\\n            k -= delta\\n        return sum([d * d for d in diff])",
                "codeTag": "Java"
            },
            {
                "id": 2334504,
                "title": "greedy-solution",
                "content": "The idea is to repeatedly convert `max_diff`\\'s to `max_diff-1`. We can use a counter to do this in batches.\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int> freq (100001);\\n        int max_d = 0;\\n        for (int i = 0; i < nums1.size(); ++i) {\\n            int d = abs(nums1[i] - nums2[i]);\\n            max_d = max(max_d, d);\\n            ++freq[d];\\n        }\\n        int rem = k1 + k2;\\n        while (max_d && rem) {\\n            int n = min(rem, freq[max_d]);\\n            rem -= n;\\n            freq[max_d-1] += n;\\n            if (!(freq[max_d] -= n)) --max_d;\\n        }\\n        long long res = 0;\\n        for (int d = max_d; d > 0; --d) {\\n            res += (long long) freq[d] * d * d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        vector<int> freq (100001);\\n        int max_d = 0;\\n        for (int i = 0; i < nums1.size(); ++i) {\\n            int d = abs(nums1[i] - nums2[i]);\\n            max_d = max(max_d, d);\\n            ++freq[d];\\n        }\\n        int rem = k1 + k2;\\n        while (max_d && rem) {\\n            int n = min(rem, freq[max_d]);\\n            rem -= n;\\n            freq[max_d-1] += n;\\n            if (!(freq[max_d] -= n)) --max_d;\\n        }\\n        long long res = 0;\\n        for (int d = max_d; d > 0; --d) {\\n            res += (long long) freq[d] * d * d;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317516,
                "title": "greedy-with-hash-map-c",
                "content": "let ```diff``` be an array where ```diff[i] = abs(n1[i] - n2[i])```, it should be clear(by elementary mathematics) that ```diff``` can only contain non-negetive integers(0, 1, 2, ...)\\nour goal is to make each one of max(diff) to max(diff)-1 and we have atmost k1+k2 number of operations(before every item in ```diff``` becomes zero) to do so.\\n\\n```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll minSumSquareDiff(vector<int>& n1, vector<int>& n2, int k1, int k2) {\\n      unordered_map<ll, ll>mp;\\n      ll nops = 0;\\n      ll sum = 0;\\n      for(int i=0; i<n1.size(); i++)\\n        mp[abs(n1[i] - n2[i])]++;\\n      ll top = 0;\\n      for(auto it=mp.begin(); it!=mp.end(); it++)\\n        top = max(top, it->first);\\n      while(nops < k1+k2 and top > 0){\\n        if(mp[top]){\\n          ll currOps = (mp[top] + nops <= k1+k2)?mp[top]:(k1+k2)-nops;\\n          mp[top] -= currOps;\\n          mp[top-1] += currOps;\\n          nops += currOps;         \\n        }\\n        top--;\\n      }\\n      for(auto [x, y]:mp)\\n        sum += x*x*y;\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```diff```\n```diff[i] = abs(n1[i] - n2[i])```\n```diff```\n```diff```\n```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll minSumSquareDiff(vector<int>& n1, vector<int>& n2, int k1, int k2) {\\n      unordered_map<ll, ll>mp;\\n      ll nops = 0;\\n      ll sum = 0;\\n      for(int i=0; i<n1.size(); i++)\\n        mp[abs(n1[i] - n2[i])]++;\\n      ll top = 0;\\n      for(auto it=mp.begin(); it!=mp.end(); it++)\\n        top = max(top, it->first);\\n      while(nops < k1+k2 and top > 0){\\n        if(mp[top]){\\n          ll currOps = (mp[top] + nops <= k1+k2)?mp[top]:(k1+k2)-nops;\\n          mp[top] -= currOps;\\n          mp[top-1] += currOps;\\n          nops += currOps;         \\n        }\\n        top--;\\n      }\\n      for(auto [x, y]:mp)\\n        sum += x*x*y;\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316608,
                "title": "java-c-hashing",
                "content": "**C++**\\nRuntime: 232 ms, faster than 93.29% of C++ online submissions for Minimum Sum of Squared Difference.\\nMemory Usage: 108.8 MB, less than 56.62% of C++ online submissions for Minimum Sum of Squared Difference.\\n```\\nclass Solution {\\npublic:\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    unordered_map<long, int> table;\\n    for(int i = 0; i != nums1.size(); i++)\\n      table[abs((long)nums1[i] - nums2[i])]++;\\n      \\n    int k = k1 + k2, id = 1;\\n    long ans = 0, dif;\\n    vector<pair<long, int>> t(table.size()+1);\\n    for(auto [d, v] : table)t[id++] = {d, v};\\n    sort(t.begin(), t.end());\\n    \\n    for(id = table.size(); id != 0 && k != 0; id--)                  \\n      if( (dif = (t[id].first - t[id-1].first) * t[id].second) <= k){\\n        t[id-1].second += t[id].second;\\n        k -= dif;\\n      }\\n      else{\\n        long n = t[id].first - k/t[id].second; \\n        ans += n * n * (t[id].second - k%t[id].second) + (n-1) * (n-1) * (k%t[id].second); \\n        k = 0;\\n      }\\n      \\n    for(; id >= 0; id--) ans += t[id].first * t[id].first * t[id].second;\\n    return ans;   \\n  }\\n};\\n```\\n**Java**\\nRuntime: 47 ms, faster than 56.14% of Java online submissions for Minimum Sum of Squared Difference.\\nMemory Usage: 59.4 MB, less than 95.53% of Java online submissions for Minimum Sum of Squared Difference.\\n```\\nclass Solution {\\n  public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n    HashMap<Long, Integer> table = new HashMap<Long, Integer>();\\n    for(int i = 0; i != nums1.length; i++){\\n      long dif = Math.abs((long)nums1[i] - nums2[i]);\\n      if(dif != 0)\\n        if(table.containsKey(dif)) table.put(dif, table.get(dif) + 1);\\n        else table.put(dif, 1);\\n    }\\n      \\n    int k = k1 + k2, id = 1;\\n    long ans = 0;\\n    long t[][] = new long[table.size()+1][2];\\n    for(Map.Entry<Long, Integer> it : table.entrySet()){\\n      t[id][0] = it.getKey();\\n      t[id++][1] = it.getValue();\\n    }\\n    Arrays.sort(t, Comparator.comparingLong(o -> o[0]));\\n    \\n    id = table.size();\\n    while(id != 0 && k != 0){\\n      long dif = (t[id][0] - t[id-1][0]) * t[id][1];                  \\n      if(dif <= k){\\n        id--;\\n        t[id][1] += t[id+1][1];\\n        k -= dif;\\n      }\\n      else{\\n        long n = t[id][0] - k/t[id][1]; \\n        ans += n * n * (t[id][1] - k%t[id][1]) + (n-1) * (n-1) * (k%t[id][1]); \\n        id--;\\n        break;\\n      }\\n    }\\n      \\n    for(; id >= 0; id--) ans += t[id][0] * t[id][0] * t[id][1];\\n    return ans;      \\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    unordered_map<long, int> table;\\n    for(int i = 0; i != nums1.size(); i++)\\n      table[abs((long)nums1[i] - nums2[i])]++;\\n      \\n    int k = k1 + k2, id = 1;\\n    long ans = 0, dif;\\n    vector<pair<long, int>> t(table.size()+1);\\n    for(auto [d, v] : table)t[id++] = {d, v};\\n    sort(t.begin(), t.end());\\n    \\n    for(id = table.size(); id != 0 && k != 0; id--)                  \\n      if( (dif = (t[id].first - t[id-1].first) * t[id].second) <= k){\\n        t[id-1].second += t[id].second;\\n        k -= dif;\\n      }\\n      else{\\n        long n = t[id].first - k/t[id].second; \\n        ans += n * n * (t[id].second - k%t[id].second) + (n-1) * (n-1) * (k%t[id].second); \\n        k = 0;\\n      }\\n      \\n    for(; id >= 0; id--) ans += t[id].first * t[id].first * t[id].second;\\n    return ans;   \\n  }\\n};\\n```\n```\\nclass Solution {\\n  public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n    HashMap<Long, Integer> table = new HashMap<Long, Integer>();\\n    for(int i = 0; i != nums1.length; i++){\\n      long dif = Math.abs((long)nums1[i] - nums2[i]);\\n      if(dif != 0)\\n        if(table.containsKey(dif)) table.put(dif, table.get(dif) + 1);\\n        else table.put(dif, 1);\\n    }\\n      \\n    int k = k1 + k2, id = 1;\\n    long ans = 0;\\n    long t[][] = new long[table.size()+1][2];\\n    for(Map.Entry<Long, Integer> it : table.entrySet()){\\n      t[id][0] = it.getKey();\\n      t[id++][1] = it.getValue();\\n    }\\n    Arrays.sort(t, Comparator.comparingLong(o -> o[0]));\\n    \\n    id = table.size();\\n    while(id != 0 && k != 0){\\n      long dif = (t[id][0] - t[id-1][0]) * t[id][1];                  \\n      if(dif <= k){\\n        id--;\\n        t[id][1] += t[id+1][1];\\n        k -= dif;\\n      }\\n      else{\\n        long n = t[id][0] - k/t[id][1]; \\n        ans += n * n * (t[id][1] - k%t[id][1]) + (n-1) * (n-1) * (k%t[id][1]); \\n        id--;\\n        break;\\n      }\\n    }\\n      \\n    for(; id >= 0; id--) ans += t[id][0] * t[id][0] * t[id][1];\\n    return ans;      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314485,
                "title": "minimum-sum-of-squared-difference-java-easy",
                "content": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int []diff=new int[100001];\\n        \\n        long k=k1+k2;\\n        int maxDiff=0;\\n        long totalDiff=0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            int currDiff=Math.abs(nums1[i]-nums2[i]);\\n            \\n            if(currDiff>0){\\n                totalDiff+=currDiff;\\n                diff[currDiff]++;\\n                maxDiff=Math.max(maxDiff, currDiff);\\n            }\\n            \\n        }\\n        \\n        if(totalDiff<=k){\\n            return 0;\\n        }\\n        \\n        for(int i=maxDiff;i>0 && k>0;i--){\\n            \\n            if(diff[i]>0){\\n                if(diff[i]>=k){\\n                    diff[i]-=k;\\n                    diff[i-1]+=k;\\n                    k=0;\\n                }else{\\n                    diff[i-1]+=diff[i];\\n                    k-=diff[i];\\n                    diff[i]=0;\\n                }\\n            } \\n        }\\n        \\n        long res=0;\\n        \\n        for(int i=0;i<=maxDiff;i++){\\n            if(diff[i]>0){\\n                res+=(long)Math.pow((long)i,2)*diff[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int []diff=new int[100001];\\n        \\n        long k=k1+k2;\\n        int maxDiff=0;\\n        long totalDiff=0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            int currDiff=Math.abs(nums1[i]-nums2[i]);\\n            \\n            if(currDiff>0){\\n                totalDiff+=currDiff;\\n                diff[currDiff]++;\\n                maxDiff=Math.max(maxDiff, currDiff);\\n            }\\n            \\n        }\\n        \\n        if(totalDiff<=k){\\n            return 0;\\n        }\\n        \\n        for(int i=maxDiff;i>0 && k>0;i--){\\n            \\n            if(diff[i]>0){\\n                if(diff[i]>=k){\\n                    diff[i]-=k;\\n                    diff[i-1]+=k;\\n                    k=0;\\n                }else{\\n                    diff[i-1]+=diff[i];\\n                    k-=diff[i];\\n                    diff[i]=0;\\n                }\\n            } \\n        }\\n        \\n        long res=0;\\n        \\n        for(int i=0;i<=maxDiff;i++){\\n            if(diff[i]>0){\\n                res+=(long)Math.pow((long)i,2)*diff[i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300193,
                "title": "c-binary-search-to-find-the-maximum-value-of-difference",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<int> diff(n);\\n        for (int i = 0; i < n; ++ i) {\\n            diff[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        int k = k1 + k2;\\n        sort(diff.begin(), diff.end());\\n        int l = 0, r = *prev(diff.end());\\n        vector<long long> dp(n + 1);\\n        dp[n] = 0;\\n        for (int i = n - 1; i >= 0; -- i) {\\n            dp[i] = dp[i + 1] + diff[i]; \\n        }\\n        auto ok = [&](int v) {\\n            auto it = lower_bound(diff.begin(), diff.end(), v);\\n            int i = it - diff.begin();\\n            return dp[i] - 1LL * v * (n - i) <= k;\\n        };\\n        while (l < r) {\\n            if (l + 1 == r) {\\n                if (ok(l)) {\\n                    break;\\n                } else {\\n                    ++ l;\\n                }\\n                break;\\n            }\\n            int m = (l + r) / 2;\\n            if (ok(m)) {\\n                r = m;\\n            } else {\\n                l = m;\\n            }\\n        \\n        long long res = 0;\\n        if (l == 0) {\\n            return 0;\\n        }\\n        for (int i = n - 1; i >= 0; -- i) {\\n            if (diff[i] > l) {\\n                res += 1LL * l * l;\\n                k -= (diff[i] - l);\\n            } else {\\n                res += 1LL * diff[i] * diff[i]; \\n            }\\n        }\\n        for (; k > 0; -- k) {\\n            res -= 1LL * l * l;\\n            res += 1LL * (l - 1) * (l - 1);\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n = nums1.size();\\n        vector<int> diff(n);\\n        for (int i = 0; i < n; ++ i) {\\n            diff[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        int k = k1 + k2;\\n        sort(diff.begin(), diff.end());\\n        int l = 0, r = *prev(diff.end());\\n        vector<long long> dp(n + 1);\\n        dp[n] = 0;\\n        for (int i = n - 1; i >= 0; -- i) {\\n            dp[i] = dp[i + 1] + diff[i]; \\n        }\\n        auto ok = [&](int v) {\\n            auto it = lower_bound(diff.begin(), diff.end(), v);\\n            int i = it - diff.begin();\\n            return dp[i] - 1LL * v * (n - i) <= k;\\n        };\\n        while (l < r) {\\n            if (l + 1 == r) {\\n                if (ok(l)) {\\n                    break;\\n                } else {\\n                    ++ l;\\n                }\\n                break;\\n            }\\n            int m = (l + r) / 2;\\n            if (ok(m)) {\\n                r = m;\\n            } else {\\n                l = m;\\n            }\\n        \\n        long long res = 0;\\n        if (l == 0) {\\n            return 0;\\n        }\\n        for (int i = n - 1; i >= 0; -- i) {\\n            if (diff[i] > l) {\\n                res += 1LL * l * l;\\n                k -= (diff[i] - l);\\n            } else {\\n                res += 1LL * diff[i] * diff[i]; \\n            }\\n        }\\n        for (; k > 0; -- k) {\\n            res -= 1LL * l * l;\\n            res += 1LL * (l - 1) * (l - 1);\\n        }\\n        return res;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294782,
                "title": "scala-recursion",
                "content": "```scala\\ndef minSumSquareDiff(nums1: Array[Int], nums2: Array[Int], k1: Int, k2: Int): Long = {\\n  val numbers =\\n    nums1.zip(nums2).foldLeft(Map.empty[Int, Int]) { case (m, (n1, n2)) => \\n      val d = math.abs(n1 - n2)\\n      m.updated(d, m.getOrElse(d, 0) + 1)\\n    }\\n\\n  numbers.toList.sortBy(- _._1) match {\\n    case Nil => ???\\n    case (v, cnt) :: tail =>\\n      minimize(v, cnt, tail, k1 + k2).foldLeft(0L) { case (sum, (v, c)) => sum + v.toLong * v * c }\\n  }\\n}\\n\\ndef minimize(value: Int, count: Int, list: List[(Int, Int)], operations: Int): List[(Int, Int)] =\\n  if(value == 0) (value, count) :: list\\n  else \\n    list match {\\n      case Nil =>\\n        if(count <= operations) minimize(value - 1, count, Nil, operations - count)\\n        else (value, count - operations) :: (value - 1, operations) :: Nil\\n      case (v, cnt) :: tail =>\\n        if(count <= operations && value - 1 == v) minimize(v, count + cnt, tail, operations - count)\\n        else if(count <= operations) minimize(value - 1, count, list, operations - count)\\n        else {\\n          val mid = if(value - 1 == v) List((v, cnt + operations)) else List((value - 1, operations), (v, cnt))\\n          (value, count - operations) :: mid ::: tail\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\ndef minSumSquareDiff(nums1: Array[Int], nums2: Array[Int], k1: Int, k2: Int): Long = {\\n  val numbers =\\n    nums1.zip(nums2).foldLeft(Map.empty[Int, Int]) { case (m, (n1, n2)) => \\n      val d = math.abs(n1 - n2)\\n      m.updated(d, m.getOrElse(d, 0) + 1)\\n    }\\n\\n  numbers.toList.sortBy(- _._1) match {\\n    case Nil => ???\\n    case (v, cnt) :: tail =>\\n      minimize(v, cnt, tail, k1 + k2).foldLeft(0L) { case (sum, (v, c)) => sum + v.toLong * v * c }\\n  }\\n}\\n\\ndef minimize(value: Int, count: Int, list: List[(Int, Int)], operations: Int): List[(Int, Int)] =\\n  if(value == 0) (value, count) :: list\\n  else \\n    list match {\\n      case Nil =>\\n        if(count <= operations) minimize(value - 1, count, Nil, operations - count)\\n        else (value, count - operations) :: (value - 1, operations) :: Nil\\n      case (v, cnt) :: tail =>\\n        if(count <= operations && value - 1 == v) minimize(v, count + cnt, tail, operations - count)\\n        else if(count <= operations) minimize(value - 1, count, list, operations - count)\\n        else {\\n          val mid = if(value - 1 == v) List((v, cnt + operations)) else List((value - 1, operations), (v, cnt))\\n          (value, count - operations) :: mid ::: tail\\n        }\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2289905,
                "title": "super-simple-solution-99",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n=nums1.size();\\n        int maxdiff=0;\\n        for(int i=0;i<n;i++) {\\n            nums1[i]=abs(nums1[i]-nums2[i]);\\n            maxdiff=max(maxdiff,nums1[i]);\\n        }\\n        vector<int> arr(maxdiff+1,0);\\n        for(int i=0;i<n;i++) {\\n            arr[nums1[i]]++;\\n        }\\n        k1=k1+k2;\\n        long long sum=0;\\n        for(long long i=maxdiff;i>0;i--) {\\n            if(arr[i]>0){\\n                if(arr[i]<=k1){\\n                    k1-=arr[i];\\n                    arr[i-1]+=arr[i];\\n                }\\n                else {\\n                    arr[i-1]+=k1;\\n                    sum+=(i*i*(arr[i]-k1));\\n                    k1=0;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        int n=nums1.size();\\n        int maxdiff=0;\\n        for(int i=0;i<n;i++) {\\n            nums1[i]=abs(nums1[i]-nums2[i]);\\n            maxdiff=max(maxdiff,nums1[i]);\\n        }\\n        vector<int> arr(maxdiff+1,0);\\n        for(int i=0;i<n;i++) {\\n            arr[nums1[i]]++;\\n        }\\n        k1=k1+k2;\\n        long long sum=0;\\n        for(long long i=maxdiff;i>0;i--) {\\n            if(arr[i]>0){\\n                if(arr[i]<=k1){\\n                    k1-=arr[i];\\n                    arr[i-1]+=arr[i];\\n                }\\n                else {\\n                    arr[i-1]+=k1;\\n                    sum+=(i*i*(arr[i]-k1));\\n                    k1=0;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287568,
                "title": "ruby-solution-beats-100-100",
                "content": "```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @param {Integer} k1\\n# @param {Integer} k2\\n# @return {Integer}\\ndef min_sum_square_diff(nums1, nums2, k1, k2)\\n  diffs = nums1.zip(nums2).map { (_1 - _2).abs }\\n  k = k1 + k2\\n  maxd = (0..diffs.max).bsearch { |mxd| diffs.sum { |d| d > mxd ? d - mxd : 0 } <= k }\\n  diffs.map! { |d| d > maxd ? (k -= (d - maxd); maxd) : d }\\n  diffs.map! { |d| d == maxd && k > 0 && d > 0 ? (k -= 1; d - 1) : d }\\n  diffs.sum { |d| d ** 2 }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @param {Integer} k1\\n# @param {Integer} k2\\n# @return {Integer}\\ndef min_sum_square_diff(nums1, nums2, k1, k2)\\n  diffs = nums1.zip(nums2).map { (_1 - _2).abs }\\n  k = k1 + k2\\n  maxd = (0..diffs.max).bsearch { |mxd| diffs.sum { |d| d > mxd ? d - mxd : 0 } <= k }\\n  diffs.map! { |d| d > maxd ? (k -= (d - maxd); maxd) : d }\\n  diffs.map! { |d| d == maxd && k > 0 && d > 0 ? (k -= 1; d - 1) : d }\\n  diffs.sum { |d| d ** 2 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2286256,
                "title": "c-sort",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        ll tot=k1+k2;\\n        int n=nums1.size();\\n        vector<ll>dif(n);\\n        for(int i=0;i<n;i++)dif[i]=abs(nums1[i]-nums2[i]);\\n        dif.push_back(0);\\n        sort(dif.begin(),dif.end());\\n        ll idx=n,cnt=1,ans=0;\\n        while(idx>0&&tot)\\n        {\\n            if(cnt*(dif[idx]-dif[idx-1])<=tot)\\n            {\\n                tot-=cnt*(dif[idx]-dif[idx-1]);\\n                cnt++;\\n            }else\\n            {\\n                ll avg=tot/cnt;\\n                tot-=avg*cnt;\\n                ans=(cnt-tot)*(dif[idx]-avg)*(dif[idx]-avg)+tot*(dif[idx]-avg-1)*(dif[idx]-avg-1);\\n                tot=0;\\n            }\\n            idx--;\\n        }\\n        while(idx)\\n        {\\n            ans+=dif[idx]*dif[idx];\\n            idx--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        ll tot=k1+k2;\\n        int n=nums1.size();\\n        vector<ll>dif(n);\\n        for(int i=0;i<n;i++)dif[i]=abs(nums1[i]-nums2[i]);\\n        dif.push_back(0);\\n        sort(dif.begin(),dif.end());\\n        ll idx=n,cnt=1,ans=0;\\n        while(idx>0&&tot)\\n        {\\n            if(cnt*(dif[idx]-dif[idx-1])<=tot)\\n            {\\n                tot-=cnt*(dif[idx]-dif[idx-1]);\\n                cnt++;\\n            }else\\n            {\\n                ll avg=tot/cnt;\\n                tot-=avg*cnt;\\n                ans=(cnt-tot)*(dif[idx]-avg)*(dif[idx]-avg)+tot*(dif[idx]-avg-1)*(dif[idx]-avg-1);\\n                tot=0;\\n            }\\n            idx--;\\n        }\\n        while(idx)\\n        {\\n            ans+=dif[idx]*dif[idx];\\n            idx--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283842,
                "title": "help-easy-but-29-37-test-cases-passed-o-max-n-k1-k2-iterative-solution",
                "content": "I don\\'t know where i am lagging, if you got it, then plz let me know down in the comment section.\\nHere, I am subtracting differences from greatest number till  K != 0.\\n```\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length, k = k1 + k2, j = n - 1;\\n        int[] diff = new int[n];\\n        long sum = 0, sumSquare = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            diff[i] = Math.abs(nums1[i] - nums2[i]);\\n            sum += diff[i];\\n        }\\n        \\n        if(k >= sum) return 0;\\n        Arrays.sort(diff);\\n        \\n        while(k-- > 0) {\\n            if(diff[j] < diff[j - 1]) j--;\\n            \\n            diff[j]--;\\n            if(j == 0 || diff[j] == 0 || diff[j - 1] == 0 || diff[j] == diff[j - 1]) j = n - 1;\\n        }\\n        \\n        for(long i : diff) sumSquare += (i * i);\\n        \\n        return sumSquare;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length, k = k1 + k2, j = n - 1;\\n        int[] diff = new int[n];\\n        long sum = 0, sumSquare = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            diff[i] = Math.abs(nums1[i] - nums2[i]);\\n            sum += diff[i];\\n        }\\n        \\n        if(k >= sum) return 0;\\n        Arrays.sort(diff);\\n        \\n        while(k-- > 0) {\\n            if(diff[j] < diff[j - 1]) j--;\\n            \\n            diff[j]--;\\n            if(j == 0 || diff[j] == 0 || diff[j - 1] == 0 || diff[j] == diff[j - 1]) j = n - 1;\\n        }\\n        \\n        for(long i : diff) sumSquare += (i * i);\\n        \\n        return sumSquare;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281812,
                "title": "c-map-of-differentces-to-count",
                "content": "```\\n//1. save map of difference to count (count of specific difference),\\n//for example there are 4 element difference of 3, then the pair will be {4, 3}, similar pairs will form the map\\n//2. then iterate the generated map, to reduce the k=(k1+k2), that to gradually remove the highest difference (map ordered by std::greater<int>)\\n//3. finally calculate the result from remaining map\\n\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        map<int, int, greater<int>> m;\\n        for (int i = 0; i < nums1.size(); ++i)\\n            m[abs(nums1[i] - nums2[i])]++;\\n\\n        long long k = k1 + k2;\\n        while (true) {\\n            auto f = m.begin();\\n            if (f == m.end()) break;\\n            int a = f->first;\\n            int count = f->second;\\n\\n            auto f2 = f;\\n            f2++;\\n            int b = f2 == m.end() ? 0: f2->first;\\n            long long diff = a - b;\\n\\t\\t\\t\\n\\t\\t\\tm.erase(f);\\n            if (diff * count >= k) { //this gap will fulfill all k moves\\n                int decrease = k / count;\\n                int count1 = k % count, count2 = count - count1;\\n\\n                int v1 = a - decrease, v2 = a - decrease - 1;;\\n                if(v1!=0) m[v1] += count2;\\n                if(v2!=0) m[v2] += count1;\\n\\n                k = 0;\\n                break;\\n            }\\n            else {\\n                if(b!=0) m[b] += count;\\n                k -= count* diff;\\n            }\\n        }\\n\\n        long long r = 0;\\n        for (auto& p : m)  r += ((long long)p.first * p.first) * p.second;\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//1. save map of difference to count (count of specific difference),\\n//for example there are 4 element difference of 3, then the pair will be {4, 3}, similar pairs will form the map\\n//2. then iterate the generated map, to reduce the k=(k1+k2), that to gradually remove the highest difference (map ordered by std::greater<int>)\\n//3. finally calculate the result from remaining map\\n\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        map<int, int, greater<int>> m;\\n        for (int i = 0; i < nums1.size(); ++i)\\n            m[abs(nums1[i] - nums2[i])]++;\\n\\n        long long k = k1 + k2;\\n        while (true) {\\n            auto f = m.begin();\\n            if (f == m.end()) break;\\n            int a = f->first;\\n            int count = f->second;\\n\\n            auto f2 = f;\\n            f2++;\\n            int b = f2 == m.end() ? 0: f2->first;\\n            long long diff = a - b;\\n\\t\\t\\t\\n\\t\\t\\tm.erase(f);\\n            if (diff * count >= k) { //this gap will fulfill all k moves\\n                int decrease = k / count;\\n                int count1 = k % count, count2 = count - count1;\\n\\n                int v1 = a - decrease, v2 = a - decrease - 1;;\\n                if(v1!=0) m[v1] += count2;\\n                if(v2!=0) m[v2] += count1;\\n\\n                k = 0;\\n                break;\\n            }\\n            else {\\n                if(b!=0) m[b] += count;\\n                k -= count* diff;\\n            }\\n        }\\n\\n        long long r = 0;\\n        for (auto& p : m)  r += ((long long)p.first * p.first) * p.second;\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281274,
                "title": "easy-understanding-c-solution",
                "content": "**Code:**\\n```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    ll n=nums1.size();\\n\\n    vector<ll> arr(n);\\n    for(ll i=0; i<n; i++){\\n        arr[i] = abs(nums1[i]-nums2[i]);\\n    }\\n\\n    sort(arr.begin(), arr.end());\\n    ll ans=0;\\n    ll j=n-1, k=k1+k2, count=1;\\n\\n    while(k>0 && j>0){\\n        //cout << arr[j] << endl;\\n        ll x = (arr[j]-arr[j-1]);\\n        if(x*count < k){\\n            k -= x*count;\\n            j--;\\n            count++;\\n        }\\n        else{\\n            ll y=k/count;\\n            ll z=k%count;\\n            j--;\\n            ll st = arr[j]+x-y;\\n            if(st<=0) return 0;\\n            ans += (st)*(st)*(count-z)+(st-1)*(st-1)*(z);\\n            k = 0;\\n        }    \\n    }\\n\\n    if(j==0 && k>0){\\n        ll x = arr[0];\\n        ll y=k/count;\\n        ll z=k%count;\\n        j--;\\n        if(x<=y) return 0;\\n        //cout << ans << endl;\\n        ans += (x-y)*(x-y)*(count-z)+(x-y-1)*(x-y-1)*(z);\\n        k = 0;\\n    }\\n\\n    while(j>=0){\\n        //cout << ans << endl;\\n        ans += arr[j]*arr[j];\\n        j--;\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n    ll n=nums1.size();\\n\\n    vector<ll> arr(n);\\n    for(ll i=0; i<n; i++){\\n        arr[i] = abs(nums1[i]-nums2[i]);\\n    }\\n\\n    sort(arr.begin(), arr.end());\\n    ll ans=0;\\n    ll j=n-1, k=k1+k2, count=1;\\n\\n    while(k>0 && j>0){\\n        //cout << arr[j] << endl;\\n        ll x = (arr[j]-arr[j-1]);\\n        if(x*count < k){\\n            k -= x*count;\\n            j--;\\n            count++;\\n        }\\n        else{\\n            ll y=k/count;\\n            ll z=k%count;\\n            j--;\\n            ll st = arr[j]+x-y;\\n            if(st<=0) return 0;\\n            ans += (st)*(st)*(count-z)+(st-1)*(st-1)*(z);\\n            k = 0;\\n        }    \\n    }\\n\\n    if(j==0 && k>0){\\n        ll x = arr[0];\\n        ll y=k/count;\\n        ll z=k%count;\\n        j--;\\n        if(x<=y) return 0;\\n        //cout << ans << endl;\\n        ans += (x-y)*(x-y)*(count-z)+(x-y-1)*(x-y-1)*(z);\\n        k = 0;\\n    }\\n\\n    while(j>=0){\\n        //cout << ans << endl;\\n        ans += arr[j]*arr[j];\\n        j--;\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2279319,
                "title": "consice-solution-using-counter-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        int n = nums1.size();\\n        map<long long  int,long long  int> mp;\\n        long long int ans =0;\\n        int cnt = k1 + k2;\\n        \\n        \\n        for (int i=0;i<n;i++)  { int t = abs (nums1[i] - nums2[i]) ;mp[-t] ++; }\\n        \\n        // to make it min we have to decrease from biggest difference.\\n        // it means if i have 10, 2 and 4, 0 10 and 4 makes bigger number (10 -4)^2\\n        // than (2-0)^2 ; so i keep a map of difference and counter \\n        // 4,3 means we have 3 pairs with 4 difference. so now based on k1+k2 we can \\n        // reduce this pairs diff and add to next pair. each time seems we decrease one\\n        // unit from each diff. so then 4,3 becomes to 4,0 we no longer have any pais with \\n\\t\\t// 4 diff. but one unit decreased and will be added to next diff. which is 3\\n        // so mp[3] += 3; untill cnt ==0 or we reach to all diff zero\\n        for (auto it = mp.begin();cnt > 0 && it != mp.end() && it->first !=0 ;it ++)\\n        {\\n            int itsec = it->second; \\n            int x = abs(itsec - cnt);\\n            if (cnt>= itsec)\\n            {  mp[(it->first) + 1] += itsec; it-> second =0; cnt -= itsec;}\\n            else\\n            {\\n               mp[(it->first) + 1] += cnt ; it-> second = x; cnt =0;\\n            }\\n\\n            \\n        }\\n        \\n        for (auto x : mp)\\n            ans += (x.first*x.first) * x.second; \\n            \\n        \\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) \\n    {\\n        int n = nums1.size();\\n        map<long long  int,long long  int> mp;\\n        long long int ans =0;\\n        int cnt = k1 + k2;\\n        \\n        \\n        for (int i=0;i<n;i++)  { int t = abs (nums1[i] - nums2[i]) ;mp[-t] ++; }\\n        \\n        // to make it min we have to decrease from biggest difference.\\n        // it means if i have 10, 2 and 4, 0 10 and 4 makes bigger number (10 -4)^2\\n        // than (2-0)^2 ; so i keep a map of difference and counter \\n        // 4,3 means we have 3 pairs with 4 difference. so now based on k1+k2 we can \\n        // reduce this pairs diff and add to next pair. each time seems we decrease one\\n        // unit from each diff. so then 4,3 becomes to 4,0 we no longer have any pais with \\n\\t\\t// 4 diff. but one unit decreased and will be added to next diff. which is 3\\n        // so mp[3] += 3; untill cnt ==0 or we reach to all diff zero\\n        for (auto it = mp.begin();cnt > 0 && it != mp.end() && it->first !=0 ;it ++)\\n        {\\n            int itsec = it->second; \\n            int x = abs(itsec - cnt);\\n            if (cnt>= itsec)\\n            {  mp[(it->first) + 1] += itsec; it-> second =0; cnt -= itsec;}\\n            else\\n            {\\n               mp[(it->first) + 1] += cnt ; it-> second = x; cnt =0;\\n            }\\n\\n            \\n        }\\n        \\n        for (auto x : mp)\\n            ans += (x.first*x.first) * x.second; \\n            \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277852,
                "title": "java-17ms-sort-greedy",
                "content": "first calculate the diff array, then we have k1+k2 operations to minimize the sum.\\nthe best way is to \"make the distribution even between all the numbers\".\\n\\nfor example:\\n\\nif diff array is [3,4,5,6] and we want to left 8(delete 10), we will make it [2,2,2,2]\\nif diff array is [3,4,5,6] and we want to left 15(delete 3), we will make it [3,4,4,4]\\n\\nso we just sort the diff array and check if the first element is big enough to hold the left numbers,\\nif so, we calculate the quotient and remainder to make it most even.\\notherwise the first number is useless, we just skip it.\\n\\n\\n\\n```\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        int[] diff = new int[n];\\n\\n        long sum = 0;\\n        for (int i=0; i<n; i++) {\\n            diff[i] = Math.abs(nums1[i] - nums2[i]);\\n            sum += diff[i];\\n        }\\n\\n        long sub = k1+k2;\\n        if (sub >= sum) return 0;\\n\\n        long left = sum-sub;\\n        Arrays.sort(diff);\\n        long ret = 0;\\n\\n        for (int i=0; i<n; i++) {\\n            long cur = diff[i];\\n            if (cur * (n-i) >= left) {\\n                ret += cal(left, n-i);\\n                break;\\n            } else {\\n                ret += cur * cur;\\n                left -= cur;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    private long cal(long left, long n) {\\n        long q = left / n;\\n        long m = left % n;\\n        return m * (q+1)*(q+1) + (n-m)*q*q;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\\n        int n = nums1.length;\\n        int[] diff = new int[n];\\n\\n        long sum = 0;\\n        for (int i=0; i<n; i++) {\\n            diff[i] = Math.abs(nums1[i] - nums2[i]);\\n            sum += diff[i];\\n        }\\n\\n        long sub = k1+k2;\\n        if (sub >= sum) return 0;\\n\\n        long left = sum-sub;\\n        Arrays.sort(diff);\\n        long ret = 0;\\n\\n        for (int i=0; i<n; i++) {\\n            long cur = diff[i];\\n            if (cur * (n-i) >= left) {\\n                ret += cal(left, n-i);\\n                break;\\n            } else {\\n                ret += cur * cur;\\n                left -= cur;\\n            }\\n        }\\n        return ret;\\n    }\\n\\n    private long cal(long left, long n) {\\n        long q = left / n;\\n        long m = left % n;\\n        return m * (q+1)*(q+1) + (n-m)*q*q;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2277369,
                "title": "python3-using-heap",
                "content": "class Solution:\\n\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        k = k1 + k2\\n        differences = [-abs(num1-num2) for num1,num2 in zip(nums1,nums2)]\\n        if k>=-sum(differences):\\n            return 0\\n        n = len(differences)\\n        heapq.heapify(differences)\\n        \\n        while k:\\n            curr = -heapq.heappop(differences)\\n            delta = max(k//n,1) if differences else k\\n            curr-=delta\\n            k-=delta\\n            heapq.heappush(differences,-curr)\\n        \\n        sums = 0\\n        for ele in differences:\\n            sums+=ele**2\\n        return sums",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        k = k1 + k2\\n        differences = [-abs(num1-num2) for num1,num2 in zip(nums1,nums2)]\\n        if k>=-sum(differences):\\n            return 0\\n        n = len(differences)\\n        heapq.heapify(differences)\\n        \\n        while k:\\n            curr = -heapq.heappop(differences)\\n            delta = max(k//n,1) if differences else k\\n            curr-=delta\\n            k-=delta\\n            heapq.heappush(differences,-curr)\\n        \\n        sums = 0\\n        for ele in differences:\\n            sums+=ele**2\\n        return sums",
                "codeTag": "Java"
            },
            {
                "id": 2277072,
                "title": "swift-solution-using-cache-and-sorted-uniq-numbers",
                "content": "```\\nfunc minSumSquareDiff(_ nums1: [Int], _ nums2: [Int], _ k1: Int, _ k2: Int) -> Int {\\n\\t// 1 - Cache differences and save max k reducing steps\\n\\tvar k = k1 + k2, dict = (0..<nums1.count).reduce(into: [Int:Int](), {\\n\\t\\t$0[abs(nums2[$1] - nums1[$1]), default: 0] += 1\\n\\t})\\n\\t// 2 - Declare result calculation closure\\n\\tvar result: Int { dict.reduce(0, { $0 + $1.value * Int(pow(Double($1.key), 2)) }) }\\n\\t// 3 - Verify if we can reduce our k steps\\n\\tguard k > 0 else { return result }\\n\\t// 4 - Caclulate sum of diff to see whether numer of k steps less then total steps. Otherwise we\\'ll have < 0 result so return faster.\\n\\tlet sum = dict.reduce(0, { $0 + $1.key * $1.value })\\n\\tguard k < sum else { return 0 }\\n\\t// 5 - Sort diff values\\n\\tvar uniq = dict.keys.sorted()\\n\\t// 6 - Calculate until k steps is available to use\\n\\twhile k > 0 {\\n\\t\\t// 7 - Get biggest diff and count of such numbers. Change - quantity of the same \\'max diff\\' numbers we change\\n\\t\\tlet diff = uniq.last!, count = dict[diff]!, change = min(count, k)\\n\\t\\t// 8 - If we need to change all \\'max diff\\' numbers\\n\\t\\tif count == change {\\n\\t\\t\\t// 9 - Remove this diff\\n\\t\\t\\tdict[diff] = nil\\n\\t\\t\\tuniq.remove(at: uniq.count-1)\\n\\t\\t\\t// 10 - If we don\\'t have diff that should be before previously removed then append it\\n\\t\\t\\tif uniq.last != diff-1 {\\n\\t\\t\\t\\tuniq.append(diff-1)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// 11 - If we need to change only part of \\'max diff\\' numbers\\n\\t\\telse {\\n\\t\\t\\tdict[diff]! -= change\\n\\t\\t}\\n\\t\\t// 12 - Update cache and k steps state\\n\\t\\tdict[diff-1, default: 0] += change\\n\\t\\tk -= change\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Greedy"
                ],
                "code": "```\\nfunc minSumSquareDiff(_ nums1: [Int], _ nums2: [Int], _ k1: Int, _ k2: Int) -> Int {\\n\\t// 1 - Cache differences and save max k reducing steps\\n\\tvar k = k1 + k2, dict = (0..<nums1.count).reduce(into: [Int:Int](), {\\n\\t\\t$0[abs(nums2[$1] - nums1[$1]), default: 0] += 1\\n\\t})\\n\\t// 2 - Declare result calculation closure\\n\\tvar result: Int { dict.reduce(0, { $0 + $1.value * Int(pow(Double($1.key), 2)) }) }\\n\\t// 3 - Verify if we can reduce our k steps\\n\\tguard k > 0 else { return result }\\n\\t// 4 - Caclulate sum of diff to see whether numer of k steps less then total steps. Otherwise we\\'ll have < 0 result so return faster.\\n\\tlet sum = dict.reduce(0, { $0 + $1.key * $1.value })\\n\\tguard k < sum else { return 0 }\\n\\t// 5 - Sort diff values\\n\\tvar uniq = dict.keys.sorted()\\n\\t// 6 - Calculate until k steps is available to use\\n\\twhile k > 0 {\\n\\t\\t// 7 - Get biggest diff and count of such numbers. Change - quantity of the same \\'max diff\\' numbers we change\\n\\t\\tlet diff = uniq.last!, count = dict[diff]!, change = min(count, k)\\n\\t\\t// 8 - If we need to change all \\'max diff\\' numbers\\n\\t\\tif count == change {\\n\\t\\t\\t// 9 - Remove this diff\\n\\t\\t\\tdict[diff] = nil\\n\\t\\t\\tuniq.remove(at: uniq.count-1)\\n\\t\\t\\t// 10 - If we don\\'t have diff that should be before previously removed then append it\\n\\t\\t\\tif uniq.last != diff-1 {\\n\\t\\t\\t\\tuniq.append(diff-1)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// 11 - If we need to change only part of \\'max diff\\' numbers\\n\\t\\telse {\\n\\t\\t\\tdict[diff]! -= change\\n\\t\\t}\\n\\t\\t// 12 - Update cache and k steps state\\n\\t\\tdict[diff-1, default: 0] += change\\n\\t\\tk -= change\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2275895,
                "title": "python3-using-differences-list",
                "content": "class Solution:\\n\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        k = k1+k2\\n        SIZE = 10**5+1\\n        differences = [0]*SIZE\\n        \\n        for num1,num2 in zip(nums1,nums2):\\n            differences[abs(num1-num2)]+=1\\n            \\n        for i in reversed(range(SIZE)):\\n            curr = differences[i]\\n            if k>=curr:\\n                if i==1:\\n                    return 0\\n                differences[i-1]+=curr\\n                differences[i]=0\\n                k-=curr\\n            else:\\n                if i==0:\\n                    return 0\\n                differences[i] = curr-k\\n                differences[i-1]+=k\\n                break\\n                \\n        res = 0\\n        for i,ele in enumerate(differences):\\n            res+=ele*i**2\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        k = k1+k2\\n        SIZE = 10**5+1\\n        differences = [0]*SIZE\\n        \\n        for num1,num2 in zip(nums1,nums2):\\n            differences[abs(num1-num2)]+=1\\n            \\n        for i in reversed(range(SIZE)):\\n            curr = differences[i]\\n            if k>=curr:\\n                if i==1:\\n                    return 0\\n                differences[i-1]+=curr\\n                differences[i]=0\\n                k-=curr\\n            else:\\n                if i==0:\\n                    return 0\\n                differences[i] = curr-k\\n                differences[i-1]+=k\\n                break\\n                \\n        res = 0\\n        for i,ele in enumerate(differences):\\n            res+=ele*i**2\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2274407,
                "title": "javascript-heap-hashmap",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k1\\n * @param {number} k2\\n * @return {number}\\n */\\nvar minSumSquareDiff = function (nums1, nums2, k1, k2) {\\n  const map = {};\\n  for (let i = 0; i < nums1.length; i++) {\\n    const diff = Math.abs(nums1[i] - nums2[i]);\\n    map[diff] = (map[diff] || 0) + 1;\\n  }\\n\\n  let array = Object.entries(map);\\n  array = array.filter(([diff, _]) => Number(diff) > 0);\\n  array = array.map((item) => [item[1], Number(item[0])]);\\n\\n  let sumOfK = k1 + k2;\\n  const maxHeap = new MaxHeap(array);\\n  while (maxHeap.getLength() > 0 && sumOfK > 0) {\\n    let [count, diff] = maxHeap.remove();\\n    const decrease = Math.min(count, sumOfK);\\n    sumOfK -= decrease;\\n    count -= decrease;\\n    if (count > 0) maxHeap.insert([count, diff]);\\n\\n    if (maxHeap.getLength() === 0 || maxHeap.peek()[1] !== diff - 1) {\\n      if (diff - 1 > 0) maxHeap.insert([decrease, diff - 1]);\\n    } else {\\n      let [nextCount, nextDiff] = maxHeap.remove();\\n      nextCount += decrease;\\n      maxHeap.insert([nextCount, nextDiff]);\\n    }\\n  }\\n\\n  let ans = 0;\\n  while (maxHeap.getLength() > 0) {\\n    const [count, diff] = maxHeap.remove();\\n    ans += diff * diff * count;\\n  }\\n\\n  return ans;\\n};\\n```\\n\\n[MaxHeap Link](https://github.com/faustaleonardo/data-structure-in-js/blob/main/MaxHeapWithArray.js)",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @param {number} k1\\n * @param {number} k2\\n * @return {number}\\n */\\nvar minSumSquareDiff = function (nums1, nums2, k1, k2) {\\n  const map = {};\\n  for (let i = 0; i < nums1.length; i++) {\\n    const diff = Math.abs(nums1[i] - nums2[i]);\\n    map[diff] = (map[diff] || 0) + 1;\\n  }\\n\\n  let array = Object.entries(map);\\n  array = array.filter(([diff, _]) => Number(diff) > 0);\\n  array = array.map((item) => [item[1], Number(item[0])]);\\n\\n  let sumOfK = k1 + k2;\\n  const maxHeap = new MaxHeap(array);\\n  while (maxHeap.getLength() > 0 && sumOfK > 0) {\\n    let [count, diff] = maxHeap.remove();\\n    const decrease = Math.min(count, sumOfK);\\n    sumOfK -= decrease;\\n    count -= decrease;\\n    if (count > 0) maxHeap.insert([count, diff]);\\n\\n    if (maxHeap.getLength() === 0 || maxHeap.peek()[1] !== diff - 1) {\\n      if (diff - 1 > 0) maxHeap.insert([decrease, diff - 1]);\\n    } else {\\n      let [nextCount, nextDiff] = maxHeap.remove();\\n      nextCount += decrease;\\n      maxHeap.insert([nextCount, nextDiff]);\\n    }\\n  }\\n\\n  let ans = 0;\\n  while (maxHeap.getLength() > 0) {\\n    const [count, diff] = maxHeap.remove();\\n    ans += diff * diff * count;\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273015,
                "title": "c-big-brain-move-prefix-sum",
                "content": "1. Same idea if you were using priority queue. However, to make it faster, i used prefix sum.\\n2. I first sorted the array formed by subtracting the given two arrays.\\n3. then calculated the prefix sum of that array. \\n3. i have to reduce the values from the right of this sorted array. in other words i have to find smallest value of j such that arr[j+1].. to arr[n-1] can be made equal to arr[j]. \\n4. then i subtracted the amount of steps i wasted in the above process.\\n5. if i still have some steps left. i can reduce the value from j to n-1 uniformly.\\n6. once reduced all, i can calculate the square of my numbers.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n     \\n        \\n        int n = nums1.size();\\n        vector<int> arr(n);\\n        \\n        for(int i=0;i<n;i=i+1)\\n        {\\n            arr[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        \\n        long long ans = 0;\\n        long long x = k1+k2;\\n        sort(arr.begin(),arr.end());\\n        \\n        vector<long long> prefix(n);\\n        prefix[0] = arr[0];\\n        for(int i=1;i<n;i=i+1)\\n        {\\n            prefix[i] = (long long)prefix[i-1] + (long long)arr[i];\\n        }\\n        \\n        int j = n-1;\\n        \\n        while(((long long)prefix[n-1] - (long long)prefix[j]) - (long long)(n-1-j)*(long long)arr[j]<=(long long)x)\\n        {\\n            j=j-1;if(j<0){break;}\\n        }\\n       \\n      \\n     j=j+1;\\n\\t int val = arr[j];\\n\\t int k = j;\\n           \\n     x = x - ((long long)prefix[n-1] - (long long)((long long)prefix[j] + (long long)(n-1-j)*(long long)arr[j]));\\n           \\n     while(j<n){arr[j] = val;j=j+1;}\\n        \\n        int s = x/(n-k);\\n        int d = x%(n-k);\\n        \\n        for(int i=k;i<n;i=i+1)\\n        {\\n            arr[i] = max(0,arr[i] - s);\\n        }\\n        for(int i=n -1;i>n-1-d;i=i-1)\\n        {\\n            arr[i] = max(0,arr[i]-1);\\n        }\\n     \\n       for(int i=0;i<n;i=i+1)\\n        {   \\n           ans = ans + (long long)arr[i] * (long long)arr[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n     \\n        \\n        int n = nums1.size();\\n        vector<int> arr(n);\\n        \\n        for(int i=0;i<n;i=i+1)\\n        {\\n            arr[i] = abs(nums1[i] - nums2[i]);\\n        }\\n        \\n        long long ans = 0;\\n        long long x = k1+k2;\\n        sort(arr.begin(),arr.end());\\n        \\n        vector<long long> prefix(n);\\n        prefix[0] = arr[0];\\n        for(int i=1;i<n;i=i+1)\\n        {\\n            prefix[i] = (long long)prefix[i-1] + (long long)arr[i];\\n        }\\n        \\n        int j = n-1;\\n        \\n        while(((long long)prefix[n-1] - (long long)prefix[j]) - (long long)(n-1-j)*(long long)arr[j]<=(long long)x)\\n        {\\n            j=j-1;if(j<0){break;}\\n        }\\n       \\n      \\n     j=j+1;\\n\\t int val = arr[j];\\n\\t int k = j;\\n           \\n     x = x - ((long long)prefix[n-1] - (long long)((long long)prefix[j] + (long long)(n-1-j)*(long long)arr[j]));\\n           \\n     while(j<n){arr[j] = val;j=j+1;}\\n        \\n        int s = x/(n-k);\\n        int d = x%(n-k);\\n        \\n        for(int i=k;i<n;i=i+1)\\n        {\\n            arr[i] = max(0,arr[i] - s);\\n        }\\n        for(int i=n -1;i>n-1-d;i=i-1)\\n        {\\n            arr[i] = max(0,arr[i]-1);\\n        }\\n     \\n       for(int i=0;i<n;i=i+1)\\n        {   \\n           ans = ans + (long long)arr[i] * (long long)arr[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272447,
                "title": "golang-solution-bucket-sort",
                "content": "```\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n    n := len(nums1)      \\n    diffs := make([]int, n)\\n    max := abs(nums1[0] - nums2[0])\\n    ans := 0\\n    for i,v := range nums1{              \\n        diff := abs(v - nums2[i])\\n        if diff > max{\\n            max = diff\\n        }\\n        diffs[i] = diff\\n        ans += diff * diff\\n    }        \\n    k := k1 + k2\\n    buckets := make([]int, max + 1)\\n    for i:=0; i < len(diffs); i++{\\n        buckets[diffs[i]]++\\n    }    \\n    for i := max; i >= 1; i--{    \\n        if k <= 0{\\n            break\\n        }\\n        if k > buckets[i]{\\n            ans -= buckets[i] * ((i * i) - (i-1) * (i - 1))            \\n            k -= buckets[i]\\n            buckets[i-1] += buckets[i]            \\n        }else{\\n            ans -= k * ((i * i) - (i-1) * (i - 1))\\n            break\\n        }\\n    }       \\n    return int64(ans)\\n}\\n\\nfunc abs(a int) int{\\n    if a > 0{\\n        return a\\n    }\\n    return -a\\n}",
                "solutionTags": [
                    "Go",
                    "Bucket Sort"
                ],
                "code": "```\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n    n := len(nums1)      \\n    diffs := make([]int, n)\\n    max := abs(nums1[0] - nums2[0])\\n    ans := 0\\n    for i,v := range nums1{              \\n        diff := abs(v - nums2[i])\\n        if diff > max{\\n            max = diff\\n        }\\n        diffs[i] = diff\\n        ans += diff * diff\\n    }        \\n    k := k1 + k2\\n    buckets := make([]int, max + 1)\\n    for i:=0; i < len(diffs); i++{\\n        buckets[diffs[i]]++\\n    }    \\n    for i := max; i >= 1; i--{    \\n        if k <= 0{\\n            break\\n        }\\n        if k > buckets[i]{\\n            ans -= buckets[i] * ((i * i) - (i-1) * (i - 1))            \\n            k -= buckets[i]\\n            buckets[i-1] += buckets[i]            \\n        }else{\\n            ans -= k * ((i * i) - (i-1) * (i - 1))\\n            break\\n        }\\n    }       \\n    return int64(ans)\\n}\\n\\nfunc abs(a int) int{\\n    if a > 0{\\n        return a\\n    }\\n    return -a\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2269294,
                "title": "easy-to-understand-c",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long minSumSquareDiff(vector<int> &nums1, vector<int> &nums2, int k1, int k2)\\n    {\\n        int n = nums1.size();\\n        map<long long, long long> m;\\n        for (int i = 0; i < n; i++)\\n        {\\n            m[abs(nums1[i] - nums2[i])]++;\\n        }\\n        int op = k1 + k2;\\n        map<long long, long long>::reverse_iterator rit;\\n        for (rit = m.rbegin(); !m.empty() &&op > 0 && rit != m.rend();)\\n        {\\n            \\n            if (op >= rit->second)\\n            {\\n                m[rit->first - 1] += rit->second;\\n                op-=rit->second;\\n                m.erase(rit->first);\\n            }\\n            else\\n            {\\n                m[rit->first - 1] += op;\\n                rit->second -= op;\\n                op = 0;\\n                \\n            }\\n        }\\n        if(m.empty())return 0;\\n        long long sum = 0;\\n        for (auto it : m)\\n        {\\n            if(it.first>0)\\n            sum += it.first * it.first * it.second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    long long minSumSquareDiff(vector<int> &nums1, vector<int> &nums2, int k1, int k2)\\n    {\\n        int n = nums1.size();\\n        map<long long, long long> m;\\n        for (int i = 0; i < n; i++)\\n        {\\n            m[abs(nums1[i] - nums2[i])]++;\\n        }\\n        int op = k1 + k2;\\n        map<long long, long long>::reverse_iterator rit;\\n        for (rit = m.rbegin(); !m.empty() &&op > 0 && rit != m.rend();)\\n        {\\n            \\n            if (op >= rit->second)\\n            {\\n                m[rit->first - 1] += rit->second;\\n                op-=rit->second;\\n                m.erase(rit->first);\\n            }\\n            else\\n            {\\n                m[rit->first - 1] += op;\\n                rit->second -= op;\\n                op = 0;\\n                \\n            }\\n        }\\n        if(m.empty())return 0;\\n        long long sum = 0;\\n        for (auto it : m)\\n        {\\n            if(it.first>0)\\n            sum += it.first * it.first * it.second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269180,
                "title": "golang",
                "content": "```\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n    l := len(nums1)\\n    k := k1 + k2\\n    list := make([]int, l)\\n    for i := 0; i < l; i++ {\\n        list[i] = abs(nums1[i] - nums2[i])\\n    }\\n    sort.Slice(list, func(i int, j int) bool {\\n        return list[i] > list[j]\\n    })\\n\\n    i := 0\\n    for {\\n        j := i\\n        for j < len(list) && list[j] == list[i] {\\n            j++\\n        }\\n        if j == len(list) {\\n            break\\n        }\\n        diff := list[i] - list[j]\\n        if k <= j * diff {\\n            a := k / j\\n            b := k % j        \\n            return int64(calc(list[i] - a, j - b) + calc(list[i] - a - 1, b) +\\n                         sumSquare(list[j:]))\\n        } else {\\n            k -= j * diff\\n            i = j\\n        }\\n    }\\n    \\n    \\n    a := k / l\\n    b := k % l\\n    return int64(calc(list[l - 1] - a, l - b) + calc(list[l - 1] - a - 1, b))\\n}\\n\\nfunc abs(a int) int {\\n    if a > 0 {\\n        return a\\n    }\\n    return -a\\n}\\n\\nfunc calc(a int, b int) int {\\n    a = max(a, 0)\\n    return a * a * b\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc sumSquare(a []int) int {\\n    res := 0\\n    for _, v := range a {\\n        res += v * v\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n    l := len(nums1)\\n    k := k1 + k2\\n    list := make([]int, l)\\n    for i := 0; i < l; i++ {\\n        list[i] = abs(nums1[i] - nums2[i])\\n    }\\n    sort.Slice(list, func(i int, j int) bool {\\n        return list[i] > list[j]\\n    })\\n\\n    i := 0\\n    for {\\n        j := i\\n        for j < len(list) && list[j] == list[i] {\\n            j++\\n        }\\n        if j == len(list) {\\n            break\\n        }\\n        diff := list[i] - list[j]\\n        if k <= j * diff {\\n            a := k / j\\n            b := k % j        \\n            return int64(calc(list[i] - a, j - b) + calc(list[i] - a - 1, b) +\\n                         sumSquare(list[j:]))\\n        } else {\\n            k -= j * diff\\n            i = j\\n        }\\n    }\\n    \\n    \\n    a := k / l\\n    b := k % l\\n    return int64(calc(list[l - 1] - a, l - b) + calc(list[l - 1] - a - 1, b))\\n}\\n\\nfunc abs(a int) int {\\n    if a > 0 {\\n        return a\\n    }\\n    return -a\\n}\\n\\nfunc calc(a int, b int) int {\\n    a = max(a, 0)\\n    return a * a * b\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc sumSquare(a []int) int {\\n    res := 0\\n    for _, v := range a {\\n        res += v * v\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2268745,
                "title": "c-priority-queue-solution",
                "content": "Initially I used plain priority_queue without any optimization. I used variable `total` to represent total times (i.e. `k1+k2`) I can make the changes. And prority_queue is basically pop the top element, and reduce it to the `next_element-1` and push it back to the queue. I was stuck at TLE. \\nTo make the program more efficient, we can also store the frequency of elements\\' differences. \\nThe tricky part is to deal with the cases when `total` is bigger/less than what we have from the top of the queue. \\n\\n```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        long long res = 0;\\n        \\n        int total = k1 + k2;\\n        \\n        unordered_map<int, int> freq;\\n        \\n        for (int i = 0, size = nums1.size(); i < size; ++i)\\n        {\\n            if (nums1[i] != nums2[i])\\n                ++freq[std::abs(nums1[i] - nums2[i])];\\n        }\\n        \\n        priority_queue<std::pair<int, int>> pq;\\n        for (auto it : freq)\\n        {\\n            pq.push({it.first, it.second});\\n        }\\n        \\n        int diff = 0;\\n        \\n        while (!pq.empty() && total > 0)\\n        {\\n            auto [k, v] = pq.top();\\n            pq.pop();\\n            \\n            if (pq.empty())\\n            {\\n                diff = k * v;\\n                \\n                if (total >= diff)\\n                {\\n                    total -= diff;\\n                }\\n                else\\n                {\\n                    int x = total / v;\\n                    int y = total % v;\\n                    \\n                    pq.push({ k-x-1, y });\\n                    pq.push({ k-x, v-y });\\n                    \\n                    total = 0;\\n                }\\n            }\\n            else\\n            {\\n                auto [kk, vv] = pq.top();\\n                pq.pop();\\n                \\n                diff = (k - kk) * v;\\n                if (total >= diff)\\n                {\\n                    pq.push({kk, v+vv});\\n                    total -= diff;\\n                }\\n                else\\n                {\\n                    int x = total / v;\\n                    int y = total % v;\\n                    \\n                    pq.push({ k-x-1, y});\\n                    pq.push({ k-x, v-y});\\n                    pq.push({kk, vv});\\n                    \\n                    total = 0;\\n                }\\n            }\\n        }\\n        \\n        while (!pq.empty())\\n        {\\n            auto [k, v] = pq.top();\\n            pq.pop();\\n            res += static_cast<long long>(k) * k * v;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        long long res = 0;\\n        \\n        int total = k1 + k2;\\n        \\n        unordered_map<int, int> freq;\\n        \\n        for (int i = 0, size = nums1.size(); i < size; ++i)\\n        {\\n            if (nums1[i] != nums2[i])\\n                ++freq[std::abs(nums1[i] - nums2[i])];\\n        }\\n        \\n        priority_queue<std::pair<int, int>> pq;\\n        for (auto it : freq)\\n        {\\n            pq.push({it.first, it.second});\\n        }\\n        \\n        int diff = 0;\\n        \\n        while (!pq.empty() && total > 0)\\n        {\\n            auto [k, v] = pq.top();\\n            pq.pop();\\n            \\n            if (pq.empty())\\n            {\\n                diff = k * v;\\n                \\n                if (total >= diff)\\n                {\\n                    total -= diff;\\n                }\\n                else\\n                {\\n                    int x = total / v;\\n                    int y = total % v;\\n                    \\n                    pq.push({ k-x-1, y });\\n                    pq.push({ k-x, v-y });\\n                    \\n                    total = 0;\\n                }\\n            }\\n            else\\n            {\\n                auto [kk, vv] = pq.top();\\n                pq.pop();\\n                \\n                diff = (k - kk) * v;\\n                if (total >= diff)\\n                {\\n                    pq.push({kk, v+vv});\\n                    total -= diff;\\n                }\\n                else\\n                {\\n                    int x = total / v;\\n                    int y = total % v;\\n                    \\n                    pq.push({ k-x-1, y});\\n                    pq.push({ k-x, v-y});\\n                    pq.push({kk, vv});\\n                    \\n                    total = 0;\\n                }\\n            }\\n        }\\n        \\n        while (!pq.empty())\\n        {\\n            auto [k, v] = pq.top();\\n            pq.pop();\\n            res += static_cast<long long>(k) * k * v;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268521,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long p = k1+k2,sum=0,n=nums1.size(),p1=0;\\n        long long arr[n];\\n        for(int i=0;i<nums1.size();i++) {\\n            arr[i] = abs(nums1[i]-nums2[i]);\\n            sum += arr[i];\\n            p1 += arr[i]*arr[i];\\n        }\\n        if(p==0) return p1;\\n        if(sum<=p) return 0;\\n        cout << sum << \" \" << p << endl;\\n        sort(arr,arr+n);\\n        long long a = 0,b=arr[n-1],ans=arr[n-1],cnt=0;\\n        while(a<=b){\\n            long long m = (a+b)/2,cnt1=0;\\n            for(int i=0;i<n;i++){\\n                if(arr[i]>m) cnt1 += arr[i] - m;\\n            }\\n            if(cnt1>p) a = m+1;\\n            else ans=m,b=m-1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(arr[i]<ans) continue;\\n            p -= (arr[i]-ans);\\n            arr[i] = ans;\\n            cnt++;\\n        }\\n        sort(arr,arr+n);\\n        cout << ans << endl;\\n        long long x = p / cnt;\\n        p -= x*cnt;\\n        int i = n-1,j=0;\\n        while(j<cnt && i>=0){\\n            if(arr[i]>x)arr[i] -= x;\\n            if(p && arr[i]>0) arr[i]--,p--;\\n            j++,i--;\\n        }\\n        long long ans1=0;\\n        for(int i=0;i<n;i++){\\n            ans1 += arr[i]*arr[i];\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        long long p = k1+k2,sum=0,n=nums1.size(),p1=0;\\n        long long arr[n];\\n        for(int i=0;i<nums1.size();i++) {\\n            arr[i] = abs(nums1[i]-nums2[i]);\\n            sum += arr[i];\\n            p1 += arr[i]*arr[i];\\n        }\\n        if(p==0) return p1;\\n        if(sum<=p) return 0;\\n        cout << sum << \" \" << p << endl;\\n        sort(arr,arr+n);\\n        long long a = 0,b=arr[n-1],ans=arr[n-1],cnt=0;\\n        while(a<=b){\\n            long long m = (a+b)/2,cnt1=0;\\n            for(int i=0;i<n;i++){\\n                if(arr[i]>m) cnt1 += arr[i] - m;\\n            }\\n            if(cnt1>p) a = m+1;\\n            else ans=m,b=m-1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(arr[i]<ans) continue;\\n            p -= (arr[i]-ans);\\n            arr[i] = ans;\\n            cnt++;\\n        }\\n        sort(arr,arr+n);\\n        cout << ans << endl;\\n        long long x = p / cnt;\\n        p -= x*cnt;\\n        int i = n-1,j=0;\\n        while(j<cnt && i>=0){\\n            if(arr[i]>x)arr[i] -= x;\\n            if(p && arr[i]>0) arr[i]--,p--;\\n            j++,i--;\\n        }\\n        long long ans1=0;\\n        for(int i=0;i<n;i++){\\n            ans1 += arr[i]*arr[i];\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2267520,
                "title": "go-o-nlogn-greedily-reduce-deltas",
                "content": "**Intuition**\\n\\n* Reducing a number to become negative makes no sense. The square will make the number positive anyway.\\n* For any pair of numbers, it doesn\\'t matter whether we have `k1` or `k2` remaining. We can use either to reduce the difference.\\n* At a given time, the largest delta is the optimal delta to change\\n\\n**Approach**\\n\\n1. Calculate deltas for each pair\\n2. Sort deltas in decreasing order\\n3. For each delta, as long as it\\'s possible, reduce all prior deltas to the current delta\\n5. When it is no longer possible, reduce prior deltas as much as possible before updating their values\\n\\n**Example**\\n\\nLet\\'s say that we have the sorted deltas `[9, 6, 4, 4, 1]`, `k1 = 2` and `k2 = 4` => `k = 4 + 2 = 6`.\\n\\nFirst, we visit `deltas[1]` (`6`) and notice that we can reduce all prior values to `6`,\\ngiving us `[6, 6, 4, 4, 1]` and `k = 3`.\\n\\nNext we visit `deltas[2]` (`4`). \\nSince we have reached this point, we know that values at `deltas[i]` and before must be `6`s,\\nso reducing all of them would require `i * (deltas[i-1] - deltas[i])`, i.e. `2 * (6-4) = 4`. \\nHowever, `k = 3` so out reduction has reached an end.\\nAt this point we do an update prior deltas to `[5, 4, 4, 4,1]` before summing the squares.\\n\\n**Complexity**\\n\\nTime: O(nlogn) - due to sorting the deltas\\nSpace: O(n) - space for deltas\\n\\nYou can find more solutions on my [Github](https://github.com/sebnyberg/leetcode).\\n\\n**Solution**\\n\\n```go\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n\\t// There is no point to negative integers, because it would just\\n\\t// result in the same value anyway\\n\\t// The goal is simply to reduce the largest difference each time.\\n\\tn := len(nums1)\\n\\tdeltas := make([]int, n, n+1)\\n\\tvar sum int\\n\\tfor i := range nums1 {\\n\\t\\tdeltas[i] = abs(nums1[i] - nums2[i])\\n\\t\\tsum += deltas[i]\\n\\t}\\n\\tk := k1 + k2\\n\\tif k >= sum {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tdeltas = append(deltas, 0) // sentinel\\n\\tsort.Slice(deltas, func(i, j int) bool {\\n\\t\\treturn deltas[i] > deltas[j]\\n\\t})\\n\\t// Each delta can be reduced either with k1 or k2\\n\\t// Reduce until we run out of k, or all deltas are zero.\\n\\tfor i := 1; k > 0; i++ {\\n\\t\\t// Attempt to reduce all prior numbers to match this one\\n\\t\\tshouldReduce := i * (deltas[i-1] - deltas[i])\\n\\n\\t\\t// Possible -> skip\\n\\t\\tif k >= shouldReduce {\\n\\t\\t\\tk -= shouldReduce\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// Not possible. Reduce prior numbers as much as possible\\n\\t\\tm := k / i\\n\\t\\trest := k % i\\n\\t\\tactual := deltas[i-1] - m\\n\\t\\tfor j := i - 1; j >= 0; j-- {\\n\\t\\t\\tdeltas[j] = actual\\n\\t\\t\\tif rest > 0 {\\n\\t\\t\\t\\tdeltas[j] -= 1\\n\\t\\t\\t\\trest--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tk = 0\\n\\t}\\n\\t// Calculate total sum of squares\\n\\tvar res int64\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres += int64(deltas[i] * deltas[i])\\n\\t}\\n\\treturn res\\n}\\n\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minSumSquareDiff(nums1 []int, nums2 []int, k1 int, k2 int) int64 {\\n\\t// There is no point to negative integers, because it would just\\n\\t// result in the same value anyway\\n\\t// The goal is simply to reduce the largest difference each time.\\n\\tn := len(nums1)\\n\\tdeltas := make([]int, n, n+1)\\n\\tvar sum int\\n\\tfor i := range nums1 {\\n\\t\\tdeltas[i] = abs(nums1[i] - nums2[i])\\n\\t\\tsum += deltas[i]\\n\\t}\\n\\tk := k1 + k2\\n\\tif k >= sum {\\n\\t\\treturn 0\\n\\t}\\n\\n\\tdeltas = append(deltas, 0) // sentinel\\n\\tsort.Slice(deltas, func(i, j int) bool {\\n\\t\\treturn deltas[i] > deltas[j]\\n\\t})\\n\\t// Each delta can be reduced either with k1 or k2\\n\\t// Reduce until we run out of k, or all deltas are zero.\\n\\tfor i := 1; k > 0; i++ {\\n\\t\\t// Attempt to reduce all prior numbers to match this one\\n\\t\\tshouldReduce := i * (deltas[i-1] - deltas[i])\\n\\n\\t\\t// Possible -> skip\\n\\t\\tif k >= shouldReduce {\\n\\t\\t\\tk -= shouldReduce\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// Not possible. Reduce prior numbers as much as possible\\n\\t\\tm := k / i\\n\\t\\trest := k % i\\n\\t\\tactual := deltas[i-1] - m\\n\\t\\tfor j := i - 1; j >= 0; j-- {\\n\\t\\t\\tdeltas[j] = actual\\n\\t\\t\\tif rest > 0 {\\n\\t\\t\\t\\tdeltas[j] -= 1\\n\\t\\t\\t\\trest--\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tk = 0\\n\\t}\\n\\t// Calculate total sum of squares\\n\\tvar res int64\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres += int64(deltas[i] * deltas[i])\\n\\t}\\n\\treturn res\\n}\\n\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267030,
                "title": "c-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       \\n        int n=nums1.size(); vector<ll> dp(100007,0);ll v=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[abs(nums1[i]-nums2[i])]++;\\n            v=max(v,(ll)abs(nums1[i]-nums2[i]));\\n        }   \\n        \\n       \\n        ll b=k1+k2,ans=0;\\n        for(ll i=v+1;i>0;i--){\\n            if(dp[i]==0)\\n                continue;\\n            ll x=max(0ll,dp[i]-b);\\n            \\n\\t\\t\\tdp[i-1]+=min(dp[i],b);      //because  we are doing -1 operation on i so either b>dp[i] or b<dp[i] just add min of them\\n            \\n            b-=dp[i];dp[i]=x;\\n         \\n            if(b<=0)\\n                break;\\n        }\\n       \\n        for(int i=0;i<v+2;i++)\\n            ans=ans+(dp[i]*i*i);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n       \\n        int n=nums1.size(); vector<ll> dp(100007,0);ll v=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[abs(nums1[i]-nums2[i])]++;\\n            v=max(v,(ll)abs(nums1[i]-nums2[i]));\\n        }   \\n        \\n       \\n        ll b=k1+k2,ans=0;\\n        for(ll i=v+1;i>0;i--){\\n            if(dp[i]==0)\\n                continue;\\n            ll x=max(0ll,dp[i]-b);\\n            \\n\\t\\t\\tdp[i-1]+=min(dp[i],b);      //because  we are doing -1 operation on i so either b>dp[i] or b<dp[i] just add min of them\\n            \\n            b-=dp[i];dp[i]=x;\\n         \\n            if(b<=0)\\n                break;\\n        }\\n       \\n        for(int i=0;i<v+2;i++)\\n            ans=ans+(dp[i]*i*i);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265747,
                "title": "python-greedy",
                "content": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n, d, k = len(nums1), defaultdict(int), k1+k2\\n        for i in range(n):\\n            if nums1[i]!=nums2[i]:\\n                d[abs(nums1[i]-nums2[i])]+=1\\n        l = [[item[0], item[1]] for item in d.items()]\\n        l.sort(reverse=True)\\n        i, size, res = 0, len(l), 0\\n        while k and i<size-1:\\n            diff, cnt = l[i]\\n            gap = diff-l[i+1][0]\\n            can_fill = k//gap\\n            if can_fill<cnt:\\n                break\\n            l[i+1][1]+=cnt\\n            k-=gap*cnt\\n            i+=1\\n        if i<len(l) and k:\\n            diff, cnt = l[i]\\n            dec_avg = k//cnt\\n            remaining = k%cnt\\n            res = max(0, diff-dec_avg-1)**2*remaining+max(0, diff-dec_avg)**2*(cnt-remaining)\\n            i+=1\\n        return res + sum(pow(l[i][0], 2)*l[i][1] for i in range(i, len(l)))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumSquareDiff(self, nums1: List[int], nums2: List[int], k1: int, k2: int) -> int:\\n        n, d, k = len(nums1), defaultdict(int), k1+k2\\n        for i in range(n):\\n            if nums1[i]!=nums2[i]:\\n                d[abs(nums1[i]-nums2[i])]+=1\\n        l = [[item[0], item[1]] for item in d.items()]\\n        l.sort(reverse=True)\\n        i, size, res = 0, len(l), 0\\n        while k and i<size-1:\\n            diff, cnt = l[i]\\n            gap = diff-l[i+1][0]\\n            can_fill = k//gap\\n            if can_fill<cnt:\\n                break\\n            l[i+1][1]+=cnt\\n            k-=gap*cnt\\n            i+=1\\n        if i<len(l) and k:\\n            diff, cnt = l[i]\\n            dec_avg = k//cnt\\n            remaining = k%cnt\\n            res = max(0, diff-dec_avg-1)**2*remaining+max(0, diff-dec_avg)**2*(cnt-remaining)\\n            i+=1\\n        return res + sum(pow(l[i][0], 2)*l[i][1] for i in range(i, len(l)))",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564756,
                "content": [
                    {
                        "username": "user13513968136132683",
                        "content": "This is actually a joke. Why do people cheat on leetcode contests as if it is going to help them in the interviews?? \\n![image](https://assets.leetcode.com/users/images/5dda8af3-f67c-4e0d-b5d4-a03d5ae0fa45_1657383015.3190749.png)\\n"
                    },
                    {
                        "username": "_Singaram",
                        "content": "haha there are peoples who cheat on interview even so cheating happens every where (a sad truth)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "Testcase 27 spoils your mood."
                    },
                    {
                        "username": "neelmittal2903",
                        "content": "agreed\\n"
                    },
                    {
                        "username": "shresthchomal",
                        "content": "class Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({abs(nums1[i]-nums2[i]),{nums1[i],nums2[i]}});\\n        }\\n        while(k1 and k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            pq.pop();\\n            if(value == 0)\\n                break;\\n            if(index1 < index2){\\n                value=value-1;\\n                index1=index1+1;\\n                pq.push({value,{index1,index2}});\\n                k1--;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2+1;\\n                pq.push({value,{index1,index2}});\\n                k2--;\\n            }\\n        }\\n        while(k1){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index1 <= index2){\\n                value=value-1;\\n                index1=index1+1;\\n            }\\n            else{\\n                value=value-1;\\n                index1=index1-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k1--;\\n        }\\n        while(k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index2 <= index1){\\n                value=value-1;\\n                index2=index2+1;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k2--;\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=(pq.top().first)*(pq.top().first);\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\nwhy it is giving tle\\n"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "What is wrong with my code?\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        vector<int>absdiff;\\n        for(int i=0; i<nums1.size(); i++){\\n            int ad=abs(nums1[i]-nums2[i]);\\n            absdiff.push_back(ad);\\n        }\\n\\n        priority_queue<int>pq;\\n\\n        for(int i=0; i<absdiff.size(); i++){\\n            pq.push(absdiff[i]);\\n        }\\n        \\n        int k=k1+k2;\\n        while(k){\\n            k--;\\n            int top=pq.top();\\n            int newele = top-1;\\n            if(newele){\\n                pq.push(newele);\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<pq.size(); i++){\\n            sum+=pq.top()*pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "[@wtfcoder](/wtfcoder)\nYou can check my solution here\n https://leetcode.com/problems/minimum-sum-of-squared-difference/solutions/3651790/brute-force-tle-optmized/"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "same doubt"
                    },
                    {
                        "username": "Putul77",
                        "content": "Can someone help me how to i get rid of TLE ?\\n\\n\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<vector<int>> q;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int x=abs(nums1[i]-nums2[i]);\\n            q.push({x,nums1[i],nums2[i]});\\n        }\\n        while(k1--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]+1-v[2]);\\n            int y=abs(v[1]-1-v[2]);\\n            if(d>x)\\n            {\\n                v[1]=v[1]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[1]=v[1]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        while(k2--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]-v[2]-1);\\n            int y=abs(v[1]-v[2]+1);\\n            if(d>x)\\n            {\\n                v[2]=v[2]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[2]=v[2]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            ans+=v[0]*v[0];\\n        }\\n        return ans;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 2030156,
                "content": [
                    {
                        "username": "user13513968136132683",
                        "content": "This is actually a joke. Why do people cheat on leetcode contests as if it is going to help them in the interviews?? \\n![image](https://assets.leetcode.com/users/images/5dda8af3-f67c-4e0d-b5d4-a03d5ae0fa45_1657383015.3190749.png)\\n"
                    },
                    {
                        "username": "_Singaram",
                        "content": "haha there are peoples who cheat on interview even so cheating happens every where (a sad truth)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "Testcase 27 spoils your mood."
                    },
                    {
                        "username": "neelmittal2903",
                        "content": "agreed\\n"
                    },
                    {
                        "username": "shresthchomal",
                        "content": "class Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({abs(nums1[i]-nums2[i]),{nums1[i],nums2[i]}});\\n        }\\n        while(k1 and k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            pq.pop();\\n            if(value == 0)\\n                break;\\n            if(index1 < index2){\\n                value=value-1;\\n                index1=index1+1;\\n                pq.push({value,{index1,index2}});\\n                k1--;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2+1;\\n                pq.push({value,{index1,index2}});\\n                k2--;\\n            }\\n        }\\n        while(k1){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index1 <= index2){\\n                value=value-1;\\n                index1=index1+1;\\n            }\\n            else{\\n                value=value-1;\\n                index1=index1-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k1--;\\n        }\\n        while(k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index2 <= index1){\\n                value=value-1;\\n                index2=index2+1;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k2--;\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=(pq.top().first)*(pq.top().first);\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\nwhy it is giving tle\\n"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "What is wrong with my code?\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        vector<int>absdiff;\\n        for(int i=0; i<nums1.size(); i++){\\n            int ad=abs(nums1[i]-nums2[i]);\\n            absdiff.push_back(ad);\\n        }\\n\\n        priority_queue<int>pq;\\n\\n        for(int i=0; i<absdiff.size(); i++){\\n            pq.push(absdiff[i]);\\n        }\\n        \\n        int k=k1+k2;\\n        while(k){\\n            k--;\\n            int top=pq.top();\\n            int newele = top-1;\\n            if(newele){\\n                pq.push(newele);\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<pq.size(); i++){\\n            sum+=pq.top()*pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "[@wtfcoder](/wtfcoder)\nYou can check my solution here\n https://leetcode.com/problems/minimum-sum-of-squared-difference/solutions/3651790/brute-force-tle-optmized/"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "same doubt"
                    },
                    {
                        "username": "Putul77",
                        "content": "Can someone help me how to i get rid of TLE ?\\n\\n\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<vector<int>> q;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int x=abs(nums1[i]-nums2[i]);\\n            q.push({x,nums1[i],nums2[i]});\\n        }\\n        while(k1--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]+1-v[2]);\\n            int y=abs(v[1]-1-v[2]);\\n            if(d>x)\\n            {\\n                v[1]=v[1]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[1]=v[1]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        while(k2--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]-v[2]-1);\\n            int y=abs(v[1]-v[2]+1);\\n            if(d>x)\\n            {\\n                v[2]=v[2]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[2]=v[2]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            ans+=v[0]*v[0];\\n        }\\n        return ans;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1946543,
                "content": [
                    {
                        "username": "user13513968136132683",
                        "content": "This is actually a joke. Why do people cheat on leetcode contests as if it is going to help them in the interviews?? \\n![image](https://assets.leetcode.com/users/images/5dda8af3-f67c-4e0d-b5d4-a03d5ae0fa45_1657383015.3190749.png)\\n"
                    },
                    {
                        "username": "_Singaram",
                        "content": "haha there are peoples who cheat on interview even so cheating happens every where (a sad truth)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "Testcase 27 spoils your mood."
                    },
                    {
                        "username": "neelmittal2903",
                        "content": "agreed\\n"
                    },
                    {
                        "username": "shresthchomal",
                        "content": "class Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({abs(nums1[i]-nums2[i]),{nums1[i],nums2[i]}});\\n        }\\n        while(k1 and k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            pq.pop();\\n            if(value == 0)\\n                break;\\n            if(index1 < index2){\\n                value=value-1;\\n                index1=index1+1;\\n                pq.push({value,{index1,index2}});\\n                k1--;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2+1;\\n                pq.push({value,{index1,index2}});\\n                k2--;\\n            }\\n        }\\n        while(k1){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index1 <= index2){\\n                value=value-1;\\n                index1=index1+1;\\n            }\\n            else{\\n                value=value-1;\\n                index1=index1-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k1--;\\n        }\\n        while(k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index2 <= index1){\\n                value=value-1;\\n                index2=index2+1;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k2--;\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=(pq.top().first)*(pq.top().first);\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\nwhy it is giving tle\\n"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "What is wrong with my code?\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        vector<int>absdiff;\\n        for(int i=0; i<nums1.size(); i++){\\n            int ad=abs(nums1[i]-nums2[i]);\\n            absdiff.push_back(ad);\\n        }\\n\\n        priority_queue<int>pq;\\n\\n        for(int i=0; i<absdiff.size(); i++){\\n            pq.push(absdiff[i]);\\n        }\\n        \\n        int k=k1+k2;\\n        while(k){\\n            k--;\\n            int top=pq.top();\\n            int newele = top-1;\\n            if(newele){\\n                pq.push(newele);\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<pq.size(); i++){\\n            sum+=pq.top()*pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "[@wtfcoder](/wtfcoder)\nYou can check my solution here\n https://leetcode.com/problems/minimum-sum-of-squared-difference/solutions/3651790/brute-force-tle-optmized/"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "same doubt"
                    },
                    {
                        "username": "Putul77",
                        "content": "Can someone help me how to i get rid of TLE ?\\n\\n\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<vector<int>> q;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int x=abs(nums1[i]-nums2[i]);\\n            q.push({x,nums1[i],nums2[i]});\\n        }\\n        while(k1--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]+1-v[2]);\\n            int y=abs(v[1]-1-v[2]);\\n            if(d>x)\\n            {\\n                v[1]=v[1]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[1]=v[1]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        while(k2--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]-v[2]-1);\\n            int y=abs(v[1]-v[2]+1);\\n            if(d>x)\\n            {\\n                v[2]=v[2]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[2]=v[2]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            ans+=v[0]*v[0];\\n        }\\n        return ans;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1931823,
                "content": [
                    {
                        "username": "user13513968136132683",
                        "content": "This is actually a joke. Why do people cheat on leetcode contests as if it is going to help them in the interviews?? \\n![image](https://assets.leetcode.com/users/images/5dda8af3-f67c-4e0d-b5d4-a03d5ae0fa45_1657383015.3190749.png)\\n"
                    },
                    {
                        "username": "_Singaram",
                        "content": "haha there are peoples who cheat on interview even so cheating happens every where (a sad truth)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "Testcase 27 spoils your mood."
                    },
                    {
                        "username": "neelmittal2903",
                        "content": "agreed\\n"
                    },
                    {
                        "username": "shresthchomal",
                        "content": "class Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({abs(nums1[i]-nums2[i]),{nums1[i],nums2[i]}});\\n        }\\n        while(k1 and k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            pq.pop();\\n            if(value == 0)\\n                break;\\n            if(index1 < index2){\\n                value=value-1;\\n                index1=index1+1;\\n                pq.push({value,{index1,index2}});\\n                k1--;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2+1;\\n                pq.push({value,{index1,index2}});\\n                k2--;\\n            }\\n        }\\n        while(k1){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index1 <= index2){\\n                value=value-1;\\n                index1=index1+1;\\n            }\\n            else{\\n                value=value-1;\\n                index1=index1-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k1--;\\n        }\\n        while(k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index2 <= index1){\\n                value=value-1;\\n                index2=index2+1;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k2--;\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=(pq.top().first)*(pq.top().first);\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\nwhy it is giving tle\\n"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "What is wrong with my code?\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        vector<int>absdiff;\\n        for(int i=0; i<nums1.size(); i++){\\n            int ad=abs(nums1[i]-nums2[i]);\\n            absdiff.push_back(ad);\\n        }\\n\\n        priority_queue<int>pq;\\n\\n        for(int i=0; i<absdiff.size(); i++){\\n            pq.push(absdiff[i]);\\n        }\\n        \\n        int k=k1+k2;\\n        while(k){\\n            k--;\\n            int top=pq.top();\\n            int newele = top-1;\\n            if(newele){\\n                pq.push(newele);\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<pq.size(); i++){\\n            sum+=pq.top()*pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "[@wtfcoder](/wtfcoder)\nYou can check my solution here\n https://leetcode.com/problems/minimum-sum-of-squared-difference/solutions/3651790/brute-force-tle-optmized/"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "same doubt"
                    },
                    {
                        "username": "Putul77",
                        "content": "Can someone help me how to i get rid of TLE ?\\n\\n\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<vector<int>> q;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int x=abs(nums1[i]-nums2[i]);\\n            q.push({x,nums1[i],nums2[i]});\\n        }\\n        while(k1--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]+1-v[2]);\\n            int y=abs(v[1]-1-v[2]);\\n            if(d>x)\\n            {\\n                v[1]=v[1]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[1]=v[1]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        while(k2--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]-v[2]-1);\\n            int y=abs(v[1]-v[2]+1);\\n            if(d>x)\\n            {\\n                v[2]=v[2]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[2]=v[2]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            ans+=v[0]*v[0];\\n        }\\n        return ans;\\n        \\n    }"
                    }
                ]
            },
            {
                "id": 1867234,
                "content": [
                    {
                        "username": "user13513968136132683",
                        "content": "This is actually a joke. Why do people cheat on leetcode contests as if it is going to help them in the interviews?? \\n![image](https://assets.leetcode.com/users/images/5dda8af3-f67c-4e0d-b5d4-a03d5ae0fa45_1657383015.3190749.png)\\n"
                    },
                    {
                        "username": "_Singaram",
                        "content": "haha there are peoples who cheat on interview even so cheating happens every where (a sad truth)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "Testcase 27 spoils your mood."
                    },
                    {
                        "username": "neelmittal2903",
                        "content": "agreed\\n"
                    },
                    {
                        "username": "shresthchomal",
                        "content": "class Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({abs(nums1[i]-nums2[i]),{nums1[i],nums2[i]}});\\n        }\\n        while(k1 and k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            pq.pop();\\n            if(value == 0)\\n                break;\\n            if(index1 < index2){\\n                value=value-1;\\n                index1=index1+1;\\n                pq.push({value,{index1,index2}});\\n                k1--;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2+1;\\n                pq.push({value,{index1,index2}});\\n                k2--;\\n            }\\n        }\\n        while(k1){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index1 <= index2){\\n                value=value-1;\\n                index1=index1+1;\\n            }\\n            else{\\n                value=value-1;\\n                index1=index1-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k1--;\\n        }\\n        while(k2){\\n            int value=pq.top().first;\\n            int index1=pq.top().second.first;\\n            int index2=pq.top().second.second;\\n            if(value == 0)\\n                break;\\n            pq.pop();\\n            if(index2 <= index1){\\n                value=value-1;\\n                index2=index2+1;\\n            }\\n            else{\\n                value=value-1;\\n                index2=index2-1;\\n            }\\n            pq.push({value,{index1,index2}});\\n            k2--;\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=(pq.top().first)*(pq.top().first);\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n\\n\\nwhy it is giving tle\\n"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "What is wrong with my code?\\nclass Solution {\\npublic:\\n    long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        \\n        vector<int>absdiff;\\n        for(int i=0; i<nums1.size(); i++){\\n            int ad=abs(nums1[i]-nums2[i]);\\n            absdiff.push_back(ad);\\n        }\\n\\n        priority_queue<int>pq;\\n\\n        for(int i=0; i<absdiff.size(); i++){\\n            pq.push(absdiff[i]);\\n        }\\n        \\n        int k=k1+k2;\\n        while(k){\\n            k--;\\n            int top=pq.top();\\n            int newele = top-1;\\n            if(newele){\\n                pq.push(newele);\\n            }\\n        }\\n\\n        int sum=0;\\n        for(int i=0; i<pq.size(); i++){\\n            sum+=pq.top()*pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "Rutuj_P",
                        "content": "[@wtfcoder](/wtfcoder)\nYou can check my solution here\n https://leetcode.com/problems/minimum-sum-of-squared-difference/solutions/3651790/brute-force-tle-optmized/"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "same doubt"
                    },
                    {
                        "username": "Putul77",
                        "content": "Can someone help me how to i get rid of TLE ?\\n\\n\\n  long long minSumSquareDiff(vector<int>& nums1, vector<int>& nums2, int k1, int k2) {\\n        priority_queue<vector<int>> q;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int x=abs(nums1[i]-nums2[i]);\\n            q.push({x,nums1[i],nums2[i]});\\n        }\\n        while(k1--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]+1-v[2]);\\n            int y=abs(v[1]-1-v[2]);\\n            if(d>x)\\n            {\\n                v[1]=v[1]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[1]=v[1]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        while(k2--)\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            int d=v[0];\\n            if(d==0)\\n            break;\\n            int x=abs(v[1]-v[2]-1);\\n            int y=abs(v[1]-v[2]+1);\\n            if(d>x)\\n            {\\n                v[2]=v[2]+1;\\n                d=x;\\n            }\\n            else if(d>y)\\n            {\\n                v[2]=v[2]-1;\\n                d=y;\\n            }\\n            q.push({d,v[1],v[2]});\\n        }\\n        long long ans=0;\\n        while(!q.empty())\\n        {\\n            auto v=q.top();\\n            q.pop();\\n            ans+=v[0]*v[0];\\n        }\\n        return ans;\\n        \\n    }"
                    }
                ]
            }
        ]
    }
]